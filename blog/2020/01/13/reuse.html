<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Lessons in Hardware Reuse</title>
  <meta name="description" content="Fig 1. Can hardware designs be recycled?">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2020/01/13/reuse.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Lessons in Hardware Reuse</h1>
    <p class="post-meta"><time datetime="2020-01-13T00:00:00-05:00" itemprop="datePublished">Jan 13, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. Can hardware designs be recycled?</caption><tr><td><img src="/img/reuse/recycle.png" alt="" width="320" /></td></tr></table>

<p>When I first started doing digital design, I had a strong software background.
One of the first lessons you learn in software is to reuse your own code as
much as possible.  The sooner you learn this lesson, the faster you’ll be able
to finish your next homework problem.</p>

<p>The lesson goes well beyond school, but into industry as well.  Consider the
various operating systems and how often they are reused.  Are you reading this
article from a device running Linux, MacOS, Windows, or something else?  Just
being able to list the number of major operating systems on one hand is a
testament itself to software reuse.</p>

<p>The same lesson applies to compilers and system libraries.  How is it, for
example, that
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>,
<a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html">Quartus</a>,
<a href="https://github.com/YosysHQ/yosys">Yosys</a>,
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
or any other EDA tool can run on so many platforms?  Software reuse.
It’s real.  It works.</p>

<p>But what about hardware?  Specifically, what about reusing digital design
components?</p>

<p>Here, in this field, reuse becomes a bit more of a challenge.</p>

<p>The first and biggest challenge are the hardware licenses.  The licenses that
worked so well for software don’t apply as well to hardware.  While I personally
love the <a href="https://www.gnu.org/licenses/gpl.html">GPLv3 license</a>, conveying a
hardware design that uses a <a href="https://www.gnu.org/licenses/gpl.html">GPLv3</a>
component to someone else requires also conveying to them the ability to
rebuild the rest of the <em>entire design</em>.
This isn’t so easy, since many of the popular major design components, ARM
cores, SERDES cores, I/O components, and so forth, are still very proprietary.</p>

<p>Within a company, however, design reuse shouldn’t be a problem.  The company
owns all of their own designs, so they should be able to use them freely from
one product to another, right?</p>

<p>This is the case here, within <a href="/about/gisselquist-technology.html">Gisselquist Technology,
LLC</a>, and yet even in
this optimal reuse environment hardware design reuse is still a long way from
achieving the goals that have been achieved by software reuse.</p>

<p>Let’s take some time today to look at several experiences I’ve had with
design reuse since I started with digital design over a decade ago.
(Wow, has it actually been that long?)  We’ll start by looking over
standardization problems I’ve had across tools, and then work our way
from the bottom of a design all the way up through some components,
through bus slaves, and on to bus master interoperability.</p>

<h2 id="tools-arent-standard">Tools aren’t standard</h2>

<p>The first problem with design reuse is that the various tools tend to be
vendor and often even platform centric.  This makes it a challenge to reuse
designs from one platform to the next.  For example, design constraint files
(XDC, UCF, SDC, PCF, etc.) differ in format and content from one vendor to
the next.  This means that I/O timing constraints and false path constraints
all need to be rewritten when attempting to reuse a design across different
vendors.</p>

<p>Well, at least the HDL languages are standard among vendors and tools, right?
How about just the subset of Verilog that I like to use?</p>

<p>Well, no.  Not even Verilog is standard across vendor tools.</p>

<ol>
  <li>
    <p>One of the first things I teach anyone who will listen is to place a
<code class="language-plaintext highlighter-rouge">default_nettype none</code> declaration at the top of every Verilog source file.
Doing this prevents the synthesis tool from turning a spelling mistake into
a new signal within your design.  It has helped me catch a lot of mistakes
over the years.</p>

    <p>The problem is that placing this line in a
<a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html">Quartus</a>
<a href="/blog/2018/02/09/first-cyclonev.html">DE-10 Nano design</a>
will cause
<a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html">Quartus</a>
to fail to build the design.  Why?  Because the
<code class="language-plaintext highlighter-rouge">default_nettype</code> setting isn’t applied across a single file, but rather
every design file following, if not the entire design.  Worse, it seems
as though the Altera’s engineers used this language “feature” to avoid
declaring signals within their designs.  Hence, what makes my design better
breaks their design components.</p>

    <p>The problem isn’t limited to
<a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html">Quartus</a>.
<a href="https://github.com/YosysHQ/yosys">Yosys</a> handles the <code class="language-plaintext highlighter-rouge">default_nettype</code>
statement on a file by file basis.  This means that if I change
<code class="language-plaintext highlighter-rouge">default_nettype</code> back to its original <code class="language-plaintext highlighter-rouge">wire</code> setting at the end of the
file, the design will now work with
<a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html">Quartus</a>
but <a href="https://github.com/YosysHQ/yosys/issues/684">it will no longer get the <code class="language-plaintext highlighter-rouge">default_nettype</code> benefit
from</a>
<a href="https://github.com/YosysHQ/yosys">Yosys</a>.</p>

    <p>There is one annoying detail associated with this command: <code class="language-plaintext highlighter-rouge">input</code> ports
need to be declared as <code class="language-plaintext highlighter-rouge">input wire</code> rather than just <code class="language-plaintext highlighter-rouge">input</code> once you set
<code class="language-plaintext highlighter-rouge">default_nettype</code> to <code class="language-plaintext highlighter-rouge">none</code>.  The Verilog standard requires this, yet
neither <a href="https://github.com/YosysHQ/yosys">Yosys</a> nor
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
require it.  This means that designs that pass a
<code class="language-plaintext highlighter-rouge">verilator -Wall -cc topmodule.v</code> check
might still fail to be built under another tool.</p>
  </li>
  <li>
    <p>HDL designs don’t build without warnings</p>

    <p>If there’s one thing that frustrates me, it’s the inconsistency of
warnings across tools.  Coming from the software world, I’m used to a
program that can be compiled without warnings.  Here in the hardware
world, this is a challenge.</p>

    <p>Consider, for example, the following code.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="n">W</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="kt">reg</span> <span class="p">[</span><span class="n">W</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">A</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk</span><span class="p">)</span>
		<span class="n">A</span> <span class="o">&lt;=</span> <span class="n">A</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>This will generate a warning that a 32-bit number, the <code class="language-plaintext highlighter-rouge">1</code>, is being added
   to a 5 bit number, and so there might be a loss of precision.  While I
   might rewrite this to get rid of the warning,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk</span><span class="p">)</span>
		<span class="n">A</span> <span class="o">&lt;=</span> <span class="n">A</span> <span class="o">+</span> <span class="mh">5'h1</span><span class="p">;</span></code></pre></figure>

<p>the warning will then return again whenever I change the width, <code class="language-plaintext highlighter-rouge">W</code>,
   to something other than five.</p>

<p>If I then try to change the design to</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk</span><span class="p">)</span>
		<span class="n">A</span> <span class="o">&lt;=</span> <span class="n">A</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>I then get rid of the warning when using <a href="https://www.verific.com/products/">Verific based front
   ends</a>, only for it to return with
   <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>.</p>

<p>My solution has been to build my designs so that they have no warnings when
   using <code class="language-plaintext highlighter-rouge">verilator -Wall</code>, and then to ignore any of the warnings generated
   by the <a href="https://www.verific.com/products/">Verific</a>, parser used by both
   <a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>, ISE and
   <a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html">Quartus</a>.</p>

<p>Still, its annoying to have a design build without warnings in one
   environment, but not in another.</p>

<ol start="3">
  <li>
    <p>Unused values</p>

    <p>Many interfaces have signals that aren’t used by all cores.  In order
to make the cores generic, I pass those signals that aren’t used along with
the interface anyway.
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
generates a warning when I do this.
<a href="https://www.verific.com/products/">Verific</a>
(i.e. the front-end language parser used by
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>, ISE, and
<a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html">Quartus</a>)
also generates a warning.  However, I can turn the
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
warnings off on a case by case basis by simply using,</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Verilator lint_off UNUSED</span>
	<span class="kt">wire</span>	<span class="n">unused</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">unused</span> <span class="o">=</span> <span class="o">&amp;{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">unused_signal_one</span><span class="p">,</span> <span class="n">unused_signal_two</span><span class="p">,</span> <span class="n">etc</span> <span class="o">}</span><span class="p">;</span>
	<span class="c1">// Verilator lint_on UNUSED</span></code></pre></figure>

<p>While this doesn’t get rid of the warnings when using the commercial
   vendor tools, at least those warnings are now about the wire named
   <code class="language-plaintext highlighter-rouge">unused</code> being unused, and so they’re now easy to work through.</p>

<p>Of course, the problem with ignoring synthesis warnings like this is what
   happens when a design mysteriously stops working.  In that case, I find
   myself digging through all of the useless warnings generated in the logs
   of the various tools and looking for any evidence of what might’ve happened.</p>

<ol start="4">
  <li>
    <p>Generate loop block names</p>

    <p>Much to my surprise, a design that worked in
<a href="https://github.com/YosysHQ/yosys">Yosys</a>,
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>,
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>, and ISE
failed to synthesize under
<a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/download.html">Quartus</a>
for the simple reason that the for loops within my <code class="language-plaintext highlighter-rouge">generate</code> blocks
weren’t named.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">generate</span> <span class="k">genvar</span> <span class="n">k</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">NADC</span><span class="p">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">begin</span> <span class="o">:</span> <span class="n">BLOCK_NAME_NEEDED_HERE</span>
	<span class="k">assign</span> <span class="n">adc_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
	<span class="o">=</span> <span class="n">raw_adc_data</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">ADCBITS</span> <span class="o">+:</span> <span class="n">ADCBITS</span><span class="p">];</span>
<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>My point here is simply that seemingly useless differences between vendor
tools can become quite annoying in practice and a hindrance to design reuse.
All of a sudden, you find that a design component that worked under one
vendor’s tools mysteriously causes build failures under another vendor’s
tools.</p>

<p>This problem was solved in software by an open source compiler,
<a href="https://gcc.gnu.org">gcc</a>.  Verilog has an open source synthesizer,
<a href="https://github.com/YosysHQ/yosys">Yosys</a>
which can come close.  It can synthesize designs for
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>s,
iCE40, ECP5, Xilinx 7-series, and <a href="/zipcpu/2019/03/12/arrowzip.html">some Intel
designs</a>.  In many ways
this is halfway to nirvana.  Unfortunately, there’s no open source synthesis
tool for VHDL, nor is there any open source tool for SystemVerilog–although
there is a <a href="https://github.com/YosysHQ/yosys">Yosys</a>
plugin, called <a href="https://github.com/tgingold/ghdlsynth-beta">ghdl-synth</a>,
that <a href="http://pepijndevos.nl/2019/08/15/open-source-formal-verification-in-vhdl.html">I’m told is getting close to offering VHDL
support</a>
in <a href="https://github.com/YosysHQ/yosys">Yosys</a>.</p>

<h2 id="why-not-reuse-fifos">Why not reuse FIFOs?</h2>

<table align="center" style="float: left; padding: 15px"><caption>Fig 2. Surely common components can be reused?</caption><tr><td><img src="/img/reuse/fifo-reuse.svg" alt="" width="320" /></td></tr></table>

<p>Once you get past the tool issues, the next biggest question is why can’t I
reuse some of my most common components?  The most obvious of these common
components is a FIFO.  FIFOs are perhaps the most common core used across
designs.  I use FIFOs in my <a href="https://github.com/ZipCPU/wb2axip">bus bridges</a>,
my ADC cores, <a href="https://github.com/ZipCPU/wbpmic">a microphone core</a> I’ve built,
<a href="https://github.com/ZipCPU/wbuart32">my UART cores</a>, and even in my
<a href="/blog/2017/06/05/wb-bridge-overview.html">debugging bus</a>.
Surely one simple FIFO design can be used across all architectures?</p>

<table align="center" style="float: right"><caption>Fig 3. Common FIFO ports</caption><tr><td><img src="/img/reuse/fifo-ports.svg" alt="" width="320" /></td></tr></table>

<p>The good news, at least for me, is that after writing <em>many</em> (dissimilar) FIFO
implementations, I’m now starting to coalesce around a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v">single synchronous FIFO
implementation</a>.
Even with this implementation, there are a lot of per-design configuration
differences that need to be made.</p>

<ul>
  <li>
    <p>The data width changes from one application to the next, as does the
necessary FIFO depth (RAM size).</p>

    <p>Thankfully, these changes are easily parameterized–making the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v">FIFO</a>
(mostly) generic.</p>
  </li>
  <li>
    <p>Should the empty/full flags be registered?  Do they need to be?  It costs
<a href="/blog/2017/06/12/minimizing-luts.html">extra LUTs</a>
to calculate these values one clock earlier, but doing so can
also keep any FIFO users off the critical timing path.</p>
  </li>
  <li>
    <p>Some <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
have distributed RAM, others don’t–something I discuss in my <a href="/tutorial">tutorial
lesson on FIFOs</a>.  On an iCE40, <a href="/formal/2018/07/21/zipcpu-icoboard.html">all RAM reads
must be done directly into a
register</a> before
they can be read, whereas Xilinx architectures support “distributed RAM”
reads on the same clock cycle they are used.</p>
  </li>
  <li>
    <p>Handshake signaling differs from one implementation to another.  My current
FIFO implementation uses a <code class="language-plaintext highlighter-rouge">READY/VALID</code> type of handshake for reading
(<code class="language-plaintext highlighter-rouge">i_rd</code> and <code class="language-plaintext highlighter-rouge">!o_empty</code>) from and writing (<code class="language-plaintext highlighter-rouge">i_wr</code> and <code class="language-plaintext highlighter-rouge">!o_full</code>) to the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v">FIFO</a>.</p>

    <p>The problem is that this interface isn’t necessarily appropriate for all
applications.  In some data centric applications, such as coming from an
A/D or a video source where the data comes in at a fixed speed, the
source will write to the FIFO regardless of whether or not the FIFO is ready.
Doing this properly really requires generating an error signal, which my
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v">one-size-fits-most
FIFO</a>
implementation doesn’t (yet) have.</p>
  </li>
  <li>
    <p>Some applications, such as a <a href="https://github.com/ZipCPU/wbuart32">UART</a>,
require being able to know how much data is in the FIFO.  They want to read
the FIFO’s fill level back out.  This can be useful for waking up a
processor only when the FIFO is half full or half empty, for example, or
reading until it is empty following an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.  Other
applications don’t care about the fill.  Leaving a port unused and dangling,
however, is likely to cause a tool warning and get in the way of building a
warning-less design.</p>
  </li>
  <li>
    <p>Other applications, such as <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">stream to memory
bridges</a>,
might want a trigger threshold implemented within the FIFO.  Such a
trigger, in the case of a stream to memory component, might cause the
FIFO to empty into memory like flushing toilet empties the tank into the
bowl.</p>
  </li>
</ul>

<p>Can <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v">one FIFO</a>
work in all applications?  I haven’t managed to do it (yet).
In addition to reuse, there is something to be said for keeping things simple.
Of course, the problem then comes about when I <a href="/blog/2019/11/14/sdspi.html">fix a bug in one FIFO that
then still remains</a>
in one of my other implementations.</p>

<p>Xilinx’s solution appears to be to use a <a href="https://www.xilinx.com/support/documentation/ip_documentation/fifo_generator/v13_1/pg057-fifo-generator.pdf">FIFO
generator</a>
that will then generate the logic for a FIFO that can be used across many
Xilinx hardware platforms.  At the same time, this (proprietary) <a href="https://www.xilinx.com/support/documentation/ip_documentation/fifo_generator/v13_1/pg057-fifo-generator.pdf">FIFO
generator</a>
has given me no end of hassles when trying to
formally verify
what little they have published about their
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>.
Tell me, for example, why does a FIFO require nearly 100 parameters and just
as many ports?  Hence, while configurability in the name of reuse is a good
thing, <a href="https://www.xilinx.com/support/documentation/ip_documentation/fifo_generator/v13_1/pg057-fifo-generator.pdf">this
generator</a>
appears to be taking configuration to an extreme.</p>

<h2 id="can-we-reuse-serial-ports">Can we reuse serial ports?</h2>

<table align="center" style="float: left; padding: 15px"><caption>Fig 4. A common serial port interface</caption><tr><td><img src="/img/reuse/wbuart-reuse.svg" alt="" width="320" /></td></tr></table>

<p>So let’s move up the ladder, from FIFOs to full level design components.
How about serial ports?  What can we learn about hardware reuse from serial
ports?</p>

<p>A fellow open source designer, <a href="https://twitter.com/OlofKindgren">Olof
Kindgren</a>, is known for his strong opinion
that we should stop building new serial ports.  Surely among all design
components serial ports should be prime candidates for reuse!  The
communications standard hasn’t changed in years, so why ever build a new
serial port?</p>

<p>To put it in his own words,</p>

<blockquote>
  <p>I use the UART as a pathological example because it’s a function so
simple that many people feel it’s easier to write a new rather than reuse
an existing one.  But in practice this leads to another implementation with
bugs but without proper docs, tests, and drivers.</p>

  <p>(<a href="https://twitter.com/OlofKindgren/status/1216145721268809728">Twitter</a>)</p>
</blockquote>

<p>There are a lot of things you can learn from serial ports.</p>

<ol>
  <li>
    <p>Building a serial port is a good beginner’s design exercise.</p>

    <p>If you’ve never built a serial port before, go ahead and build one.  It’s a
fun design to learn from, especially since you can typically “see” your
design working when you are done.  Indeed, serial ports are one of the
many designs I work through in my <a href="/tutorial">beginners
tutorial</a>.</p>
  </li>
  <li>
    <p>The <a href="https://en.wikipedia.org/wiki/16550_UART">UART16550 interface</a>
has long since outlived its time.</p>

    <p>The classic serial port interface goes back to the
<a href="https://en.wikipedia.org/wiki/16550_UART">UART16550 chip</a>
built by <a href="https://en.wikipedia.org/wiki/National_Semiconductor">National
Semiconductor</a>.  It
seems that much of the industry has standardized around its software
interface.  Its not hard to find software drivers that can communicate
with this interface, so why not just reuse it?</p>

    <p>Sadly, this chip appears to have been built back in the days of 8-bit buses.
In order to set the baud rate of this chip, you need to set two different
registers, and you’ll need to adjust a paging register in the meantime
just to get access to those other registers.</p>

    <p>Worse, the <a href="https://en.wikipedia.org/wiki/16550_UART">UART16550</a>
only supports a 16-element FIFO.  Why not increase the
size of the FIFO?  That should be easy, right?  Well, yes, it is fairly
easy to do—it’s just that you now need to adjust all of the software that
depends the size of this FIFO.</p>

    <p>From my own perspective, I only came across the
<a href="https://en.wikipedia.org/wiki/16550_UART">UART16550</a>
after building <a href="https://github.com/ZipCPU/wbuart32">my own serial port core</a>.
Using <a href="https://github.com/ZipCPU/wbuart32">my own serial port</a>, I can
completely configure baud rate, number of stop bits, number of bits per
byte, the parity bit, and even whether or not flow control will be used
by just writing one 32-bit value to a 32-bit bus-based interface.</p>

    <p>Pretty cool, huh?</p>

    <p>Sure, you could reuse the older core, but it’d be easier to configure,
reconfigure, and use with a more modern interface.  (Such as my own …)</p>

    <p>Of course, it doesn’t help that the <a href="https://github.com/freecores/uart16550">open source
UART16550 core</a> has a
(formal-verification discovered) bug within it that might cause it to
send arbitrary data across the channel ….</p>
  </li>
</ol>

<table align="center" style="float: right"><caption>Fig 5. How much does a serial port require?</caption><tr><td><img src="/img/reuse/wbuart-extras.svg" alt="" width="320" /></td></tr></table>

<ol start="3">
  <li>
    <p><a href="https://github.com/ZipCPU/wbuart32">My first UART</a> cores
(<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">TX</a>, and
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuart.v">RX</a>)</p>

    <p>As I said above, everybody digital designer should take the opportunity to
build their own serial port.  It’s a fun project.  It’s also one of the
first projects I ever did.</p>

    <p>As with many projects, I started with all the material I could find on
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">online about serial
ports</a>.
I discovered all the things a serial port could or should support:
5, 6, 7, or 8-bit bytes, 1 or 2 stop bits, odd,
even, mark, space, or no-<a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>,
and baud rates from 300 Baud all the way up to 25MBaud or higher.</p>

    <p>Did I implement all that?  Yep.  You guessed it.  My first serial port
was such an awesome design, it could do <em>anything</em>!  It even supported
sending or detecting BREAK conditions.</p>

    <p>It just <a href="/blog/2017/06/12/minimizing-luts.html">wouldn’t fit in a Spartan 6/LX4 next to my
CPU</a>.  Neither
did I ever use the <a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>,
the BREAK conditions, the 5 or 6 bit bytes, changing the baud rate, etc.</p>

    <p>This awesome design wasn’t very reuse friendly.  It “cost” too much.</p>
  </li>
  <li>
    <p>Building a UART-Lite core</p>

    <p>As a result, I now support UART-Lite cores: a
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">transmit</a>
and <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v">receiver</a>
pair that will only ever use 8-data bits, no parity, and one stop
bits–<a href="https://en.wikipedia.org/wiki/8-N-1"><code class="language-plaintext highlighter-rouge">8N1</code> as it is commonly called</a>.
These lite cores no longer handle BREAK conditions.  They only support a
fixed baud rate, predetermined at design build time.</p>
  </li>
</ol>

<p>So why rebuild the wheel when it comes to <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">serial
ports</a>?
Because 1) the <a href="https://en.wikipedia.org/wiki/16550_UART">UART16550</a> interface
hasn’t aged well, and 2) my “ultimate” serial port cost me too much to use.</p>

<p>If you compare these problems to software, wouldn’t these also be problems
that where one might learn lessons from software reuse?  Not really.  Unlike
hardware, software bloat doesn’t nearly cost as much.  Just a kB here, and a
kB there, and no one will notice that a piece of software has a lot of
unnecessary functionality in it.  The fact that the <a href="https://en.wikipedia.org/wiki/Microsoft_litigation#United_States">Internet Explorer was
declared to be an integral part of the Windows operating
system</a>
should prove my point about software bloat.</p>

<p>What about <a href="https://twitter.com/OlofKindgren">Olof</a>’s advice?  In hind sight,
he has a strong point.  Several latent bugs existed in the core prior
to formal verification.  Despite the fact that the full service core had
so much functionality, barely any of it was properly verified prior to that
time.  Further, the software driver had to be rewritten multiple times over.
Still, the core components have been used over and over again in many projects
with great success.</p>

<h2 id="reusing-an-sd-card-component">Reusing an SD-Card component</h2>

<table align="center" style="float: left; padding: 15px"><caption>Fig 6. Reusing an SD-Card Controller</caption><tr><td><img src="/img/reuse/sdspi-reuse.svg" alt="" width="360" /></td></tr></table>

<p>What about other components?  For example, what about SD-cards?  Why can’t
we reuse SD card controllers from one design to another?  Can reuse finally be
achieved here?</p>

<ol>
  <li>
    <p>Let’s start by looking over this <a href="https://github.com/mczerski/SD-card-controller">SD Card
controller</a> found on
<a href="https://github.com">github</a>, but which traces its roots back to
<a href="https://opencores.org/project,sdcard_mass_storage_controller">OpenCores</a>.
This is a nice, full featured driver–but also one that I’ve never used.</p>

    <p>Why not?</p>

    <ul>
      <li>
        <p>While <a href="https://github.com/mczerski/SD-card-controller">this core</a>
implements the full SDIO interface, it also contains DMA’s and other
items I don’t need in a
<a href="/blog/2017/06/12/minimizing-luts.html">resource-constrained</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design.  If my design already has a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA</a>
within it, why add another one (or two, or three) that I won’t be using
regularly?</p>
      </li>
      <li>
        <p>I like to use the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone pipelined bus standard</a>, not the
<a href="/doc/wbspec_b4.pdf">Wishbone classic standard</a>. 
Unlike <a href="/doc/wbspec_b4.pdf">Wishbone classic standard</a>,
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone pipeline</a>
is faster, and scales better up to higher clock rates.</p>
      </li>
      <li>
        <p>This <a href="https://github.com/mczerski/SD-card-controller">full SDIO controller</a>
requires 2.8k Xilinx 6-LUTs, nearly 10% of a basic Artix-7/35T design.
On an iCE40 with 4-LUTs, this would use 4k of the 8k LUTs available–a
full 50% of the area, vice the simpler <a href="https://github.com/ZipCPU/sdspi">601 LUT design</a> discussed below.</p>

        <p>As I mentioned earlier, when discussing <a href="https://github.com/ZipCPU/wbuart32">my serial port</a>, people don’t
necessarily notice software bloat whereas hardware bloat costs money.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>How about building and reusing <a href="https://github.com/ZipCPU/sdspi">my own SD card
controller</a> then?  Surely I
might be able to use this across multiple designs?</p>

    <p>This, again, is a good and bad reuse story.</p>

    <p>Yes, I built an <a href="https://github.com/ZipCPU/sdspi">SD card controller</a>
based upon the SPI interface supported by most cards.  You can see it
pictured above in Fig. 6.  I also built an <a href="https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdspisim.cpp">SD
card emulator</a>
to go with it, one that worked with a backing file in a
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
based
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
context.  The <a href="https://github.com/ZipCPU/sdspi">controller</a> worked nicely in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>. 
I was even able to read and write sectors when commanding it from <a href="/blog/2017/06/05/wb-bridge-overview.html">my
debugging bus</a>
in hardware.</p>

    <p>What more could one want for reuse?</p>

    <p>In this case, when I finally went to use the core as part of one of a
design for contract, <a href="/blog/2019/11/14/sdspi.html">I discovered several
bugs</a>.  First, I missed part
of the spec, and then needed to retrofit the design in order to provide
the SD-card with a startup clock–even before lowering <code class="language-plaintext highlighter-rouge">CS#</code> for its first
command.    <a href="https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdspisim.cpp">My
emulator</a>
didn’t (initially) require this.  Next, the low-level clock generator wasn’t
generating a clock output of a constant width.  Worse, the core had a bug
where it just couldn’t handle high speed bus transactions–such as
transactions from or with the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA</a>–transactions
it was specifically designed to handle.</p>

    <p>What happened?</p>

    <p>Under the hood, what happened was that it took two clocks to read a value:
one to generate the address, and a second clock to read from that (new)
address.  High speed reads only provided one clock per read transaction, and
so they read the first word of any sector twice.  Anything slower wouldn’t
notice the problem.</p>

    <p>Because I had only tested this design with <em>constant valued sectors</em>, or
perhaps because I’d never stared hard enough at the results of reading or
writing sectors, I’d never noticed this bug.  (I’m still scratching my
head, to be honest, wondering how I could’ve missed this one …)</p>

    <p>While <a href="https://github.com/ZipCPU/sdspi">the core</a> has since been fixed, this
story does a good job of illustrating some of the problems with reuse:
Verification is the expensive part of any design process, and how shall you
know that a design has been properly verified <em>for your usage environment</em>?</p>

    <p>Even better, <a href="https://github.com/ZipCPU/sdspi">the core</a> (now) uses only
about 601 4-LUTs on an iCE40, so it’s much cheaper to use than the
<a href="https://github.com/mczerski/SD-card-controller">OpenCores-based 4k LUT core</a>.</p>
  </li>
</ol>

<p>This illustrates another big problem with reuse: Just because a design
“works” in one bus/interconnect environment, doesn’t mean it will work
in practice in your environment.  This leaves the individual reusing the
core with the unenviable task of needing to debug his own design enough
to convince the author of any subcore within it that a bug remains within
the component, rather than within the context in which it was written.</p>

<p>Doesn’t software also have the same problem?  I suppose you might argue that
it does.  The difference, however, is the difficulty associated with debugging
“broken” hardware components.  Debugging software is fairly easy.  Debugging
hardware, that’s <a href="/fpga-hell.html">much harder</a>.</p>

<p>The good news is that by using a
<a href="/zipcpu/2017/11/07/wb-formal.html">formal property file</a>,
you can verify that a core will function in <em>all bus interconnect and usage
environments</em>–something you don’t get from either a bench test, nor an
integrated simulation environment.</p>

<h2 id="reusing-an-i2c-controller">Reusing an I2C controller</h2>

<table align="center" style="float: right"><caption>Fig 7. Reusing an I2C Controller</caption><tr><td><img src="/img/reuse/rpi-edid.svg" alt="" width="480" /></td></tr></table>

<p>Some time ago, I built an <a href="https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cmaster.v">I2C
master</a>
and separate
<a href="https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2cslave.v">slave</a>
controller.  They were built to support an
<a href="https://en.wikipedia.org/wiki/HDMI">HDMI</a>
based pass-through design, and so one controller would read the
<a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID</a>
information from a downstream monitor, and then that information would be
used to populate the
<a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID</a>
information used by the upstream
<a href="https://en.wikipedia.org/wiki/HDMI">HDMI</a>
source–in this case a <a href="https://raspberrypi.org">Raspberry Pi</a>.</p>

<p>Did the design work?  Beautifully.  No, it wasn’t automatic, but it was still
quite general purpose.  (It required a
<a href="/about/zipcpu.html">ZipCPU</a> program to forward the
information from the
<a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID</a>
master to the slave.)</p>

<p>Recently, however, someone gave me an <a href="https://www.nxp.com/docs/en/data-sheet/SC18IS602B.pdf">I2C
chip</a> to work with
that doesn’t follow the single byte address, multi-byte data protocol.  Try
as I might, I can’t seem to figure out any way to control this new device
with my older <a href="https://github.com/ZipCPU/wbi2c">I2C controller</a>.</p>

<p>Why not reuse?  Because even though the lower level protocol remained the
same, the upper level protocol changed and the cores that I might’ve used
combined the two protocol layers.</p>

<h2 id="reuse-at-the-interconnect-level">Reuse at the interconnect level</h2>

<p>Connecting components like a serial port and/or an I2C controller together
within a design tends to require some sort of glueware–an
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>–that
holds the components together while allowing them to talk to each other.  <a href="/zipcpu/2017/10/05/autofpga-intro.html">Many
modern designs</a>
are composed of some kind of system level bus, or even a <a href="/zipcpu/2019/09/03/address-assignment.html">hierarchical bus
structure</a>,
that connects many components together.  Components to be connected include
<a href="/blog/2017/06/08/simple-wb-master.html">bus masters</a>–those
that want to drive an interaction, bus bridges, and <a href="/zipcpu/2017/05/29/simple-wishbone.html">bus
slaves</a>–those
that actually perform some resulting action.</p>

<table align="center" style="float: center"><caption>Fig 8. Can the interconnect be reused?</caption><tr><td><img src="/img/autofpga/multimaster.svg" alt="" width="560" /></td></tr></table>

<p>This may be the one level at which I have seen the least reuse between
designs crossing multiple vendors.  There just aren’t that many well-known
<a href="/zipcpu/2017/10/05/autofpga-intro.html">interconnect
generators</a>
that will work cross platform.</p>

<p>What keeps
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnects</a>
from being reused?</p>

<ol>
  <li>
    <p>First and foremost, an
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
is often tailor-made on a design by design basis.</p>

    <p>One design might have one master and twenty slaves.  Another design might
have two masters and four slaves.  <a href="/zipcpu/2019/09/03/address-assignment.html">Slave address
regions</a>
might change, bus data widths change from design to design, etc.  Worse,
it takes a lot of work to connect all these masters and slaves to <a href="/blog/2019/07/17/crossbar.html">an
interconnect that will allow each of the masters to talk to each of the
slaves</a>.</p>

    <p>It is for this reason that the solutions I have seen typically involve code
generators–something that can “automatically” connect various
components together.  I’m going to call such a core generator in this
context an
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
generator.</p>

    <p><a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
was designed from its inception to be such an
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
generator.</p>
  </li>
  <li>
    <p>Connectivity is further complicated by the number of bus standards.
Perhaps you are familiar with some of these:
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>,
<a href="/formal/2018/12/28/axilite.html">AXI-Lite</a>,
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>,
Avalon, AHB, APB, or even TileLink?</p>

    <p>A design integrator, that is someone composing their design from multiple
cores they intend to reuse, just wants to be able to “plug” things together
and immediately “play” with them.</p>

    <p>Moving from one protocol to another requires bus bridges.  Will the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
<a href="/zipcpu/2017/10/05/autofpga-intro.html">generator</a>
insert these automatically?  If so, what will the performance cost be?
In one example I worked with, I ended up <a href="/blog/2019/04/27/axi-addr.html">inserting so many bus bridges
that I could no longer maintain the I/O speed I had promised my
customer</a>.</p>

    <p>The worst part of bridging between bus standards is that not all
functionality can be bridged.  For example, although I have an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axim2wbsp.v">AXI to
Wishbone bus
bridge</a>,
consisting of both <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximrd2wbsp.v">read</a>
and <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximwr2wbsp.v">write</a>
component bridges, the AXI <code class="language-plaintext highlighter-rouge">AxLOCK</code> functionality doesn’t bridge from one
side to the other very well.  Neither do the <code class="language-plaintext highlighter-rouge">AxCACHE</code>, <code class="language-plaintext highlighter-rouge">AxPROT</code>, <code class="language-plaintext highlighter-rouge">AxSIZE</code>,
etc, have clear analogs in
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.</p>

    <p>What about bus widths?  DDR3 SDRAM works best with a bus that is multiples
of 64-bits wide.  The <a href="https://github.com/freecores/uart16550">UART16550
core</a> I mentioned above wants
an 8-bit bus width.  Modern CPU’s naturally want to interact at the width
of their register size–that’s 32-bits for the
<a href="/about/zipcpu.html">ZipCPU</a>.  Reuse requires being able
to bridge across these multiple bus sizes, something that doesn’t always
work across all peripherals and bus standards.  In particular, what happens
to a peripheral that performs a side-effect on reads, as for example a
<a href="https://github.com/ZipCPU/wbuart32">serial port</a> might, when you try to
read it from a wider bus standard?</p>

    <p>Of course, I haven’t mentioned the problem of getting the bus to <a href="/blog/2017/10/20/cdc.html">cross
clock domains</a> as part of the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>–something
which leads to a whole new can of worms.  As an example, you are very
likely going to need to be able to <a href="/blog/2018/07/06/afifo.html">cross clock domains to support both
video and memory</a> at the
same time–as you would with any sort of
<a href="https://en.wikipedia.org/wiki/Framebuffer">framebuffer</a>
<a href="/blog/2018/11/29/llvga.html">implementation</a>.</p>

    <p>Neither have I mentioned how the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
should handle “optional” bus capabilities.  For example,
<a href="/doc/axi-spec.pdf">AXI</a> offers USER interface wires:
<code class="language-plaintext highlighter-rouge">AWUSER</code>, <code class="language-plaintext highlighter-rouge">WUSER</code>, <code class="language-plaintext highlighter-rouge">ARUSER</code>, <code class="language-plaintext highlighter-rouge">BUSER</code>, and <code class="language-plaintext highlighter-rouge">RUSER</code>.  These tend to have
context-defined meanings, which can change from one design to the next.
How then should the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
handle connecting slaves together that have multiple, dissimilar,
definitions of these USER wires?  The <a href="/doc/wbspec_b4.pdf">Wishbone
classic</a> tag signals have similar
problems.</p>
  </li>
  <li>
    <p>Performance and verification factor in here as well</p>

    <p>To illustrate this, let me point out that Xilinx offers several options
when configuring their
<a href="/doc/axi-spec.pdf">AXI</a>
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>.
One option turns an <code class="language-plaintext highlighter-rouge">N:M</code>
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> into an <code class="language-plaintext highlighter-rouge">N:1:M</code>
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>:
<code class="language-plaintext highlighter-rouge">N</code> masters get arbitrated to a single read and write channel (never
both), which then gets fed to one of M slaves.  Only one of those
slaves will ever be addressed at any time, so they all share the same
read and write addresses.  (Yes, even the read and write addresses are
shared across channels–defeating much of the purpose of having separate
read and write channels in the first place–but that’s another story.)</p>
  </li>
</ol>

<table align="center" style="float: center"><caption>Fig 9. Xilinx's Area Optimized N:1:M AXI Crossbar</caption><tr><td><img src="/img/reuse/axi-n-1-m.svg" alt="" width="560" /></td></tr></table>

<p>This is all fine and good until you switch a design component from the
   N:1:M <a href="/blog/2019/07/17/crossbar.html">crossbar</a>
   <a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
   to the full N:M <a href="/blog/2019/07/17/crossbar.html">crossbar</a>.
   Chances are, if you do that, that you’ll discover that your design
   no longer works.  Both <a href="/formal/2019/09/06/axi-story.html">Xilinx’s demonstration IP
   cores</a> and their
   <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_ethernetlite/v3_0/pg135-axi-ethernetlite.pdf">AXI Ethernet-Lite core</a> would break–if
   not other Xilinx cores as well.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 10. Whose core do you blame when something goes wrong?</caption><tr><td><img src="/img/tweets/brken-axilite.svg" alt="" width="420" /></td></tr></table>

<p>Tell me, what would you do?  If you reconfigured your
   <a href="/blog/2019/07/17/crossbar.html">crossbar</a>
   and suddenly your design stopped working, where would you look for
   the bug?  Would you try to find a bug in Xilinx’s
   <a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>?
   That’s where I would look!  Worse, I’d get all frustrated that their
   <a href="/blog/2019/07/17/crossbar.html">crossbar</a>
   was closed source, and then likely blame them for the bug–even if it was
   in <a href="/formal/2019/05/13/axifull.html">one of my own design
   components</a>!  This is
   what you’ll suffer from when your own core can’t handle
   backpressure properly.</p>

<ol start="4">
  <li>Did I mention changing standards?  Some of the earlier
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
based <a href="/blog/2018/11/03/soc-fpga.html">SOCs</a>, Zynqs
included, supported only <a href="/doc/axi-spec.pdf">AXI3</a>–even
though most <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designs today use <a href="/doc/axi-spec.pdf">AXI4</a>.</li>
</ol>

<ol start="5">
  <li>
    <p>It doesn’t help that vendor based
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnects</a>
can’t be simulated with 3rd party tools like
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>,
or verified with things like
<a href="https://symbiyosys.readthedocs.io/en/latest/">SymbiYosys</a>,
simply because the designs are proprietary.</p>

    <p>As I mentioned above, this proprietary nature of most
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
generators just hides the bugs within them, and obscures any bugs hidden
elsewhere in the design.</p>
  </li>
</ol>

<p>This may be perhaps the biggest place where good open source based reuse
might improve designs.</p>

<h2 id="reusing-the-zipcpu">Reusing the ZipCPU</h2>

<p>Let’s now turn our attention to a place where all the stars <em>should</em>  align
to make reuse easy: within IP cores generated by a single company, owned by
a single entity, and all using the same bus standard.</p>

<p>In this ideal environment, reuse should be easy.  Right?</p>

<ol>
  <li>
    <p>The <a href="/about/zipcpu.html">ZipCPU</a> (now) supports many
hardware architectures.  It has been built on
<a href="https://github.com/ZipCPU/icozip">iCE40s</a>,
<a href="https://github.com/ZipCPU/zipversa">ECP5s</a>,
<a href="https://github.com/ZipCPU/arrowzip">Intel MAX-10s</a>,
Xilinx <a href="https://github.com/ZipCPU/s6soc">Spartan 6s</a> and
<a href="https://github.com/ZipCPU/openarty">Artix 7s</a>.</p>
  </li>
  <li>
    <p>The <a href="/zipcpu/2017/10/05/autofpga-intro.html">automated bus interconnect
generator</a>
that I now use has also demonstrated its ability to compose designs
across architectures.</p>
  </li>
</ol>

<p>So have I managed to achieve reuse nirvana then?  Let’s take a look at several
<a href="/about/zipcpu.html">ZipCPU</a> designs and
see what might be learned from reusing the
<a href="/about/zipcpu.html">ZipCPU</a> across multiple designs.</p>

<ol>
  <li>
    <p>Designs require resources.  The
<a href="/about/zipcpu.html">ZipCPU</a> is no different.  It
requires both LUTs for logic and one (or more) on-chip RAMs for the
register file.  Not all FPGAs have the LUTs required to build a
full-featured design.</p>

    <p>No, the <a href="/about/zipcpu.html">ZipCPU</a> will not fit on a
1k iCE40 <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
Sorry.</p>

    <p>Perhaps a better example of this is the <a href="https://github.com/ZipCPU/s6soc">ZipCPU design I
built</a> for the
<a href="https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module">CMod S6</a>.
<a href="https://github.com/ZipCPU/s6soc">This design</a> was based around a
Spartan 6/LX4, and demonstrated an ability to run a multitasking “O/S”–or
at least that’s what I’m going to call it.  (It did do multitasking,
but whether it was an actual “O/S” that fit into less than 16kB of RAM is
really another question for another day.)</p>

    <p>Just getting the <a href="/about/zipcpu.html">ZipCPU</a> to
<a href="/blog/2017/06/12/minimizing-luts.html">fit on the LX4</a>
meant that I needed to adjust the CPU–<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v">removing “features” that cost
too much</a>.  I
removed the cache, pipelining, the LOCK instruction, and I used a <a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/cpu/memops.v">really
cheap load/store memory
solution</a>.
I even scoured all my peripherals for lower logic alternatives and dumped my
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>.</p>

    <p>In the end, the design fit with less than 10 LUTs to spare–depending upon
the build.  Sometimes it fit with no LUTs to spare.</p>

    <p>This has since left me with a problem:  ISE is a pain to use.  I don’t
often open it up.  This means that the
<a href="/about/zipcpu.html">CPU</a>, once ported to this platform,
doesn’t often get the updates also ported to the platform.  This particular
design is then well out of date.  Sure, I’ve reused the
<a href="/about/zipcpu.html">CPU</a>.  However, I’m not convinced
that the current version of the
<a href="/about/zipcpu.html">ZipCPU</a>
will still fit on this device, and I’m fairly certain that the version that
does fit has bugs that have since been “fixed” in the master branch.</p>
  </li>
  <li>
    <p>My <a href="https://github.com/ZipCPU/xulalx25soc">XuLA2 LX25 design</a> is another
interesting story.  Years ago, I bought <a href="http://www.xess.com/shop/product/xula2-lx25">one of these
boards</a> from
<a href="http://www.xess.com">Xess.com</a>.
I really liked it too, although it’s now a bit dated.  I even built a
<a href="https://github.com/ZipCPU/xulalx25soc">ZipCPU based SoC</a> for this board.</p>

    <p>Then someone wanted to reuse this design on their own XuLA2 LX board, only
they purchased a XuLA2 LX9 board and not the LX25 board.</p>

    <p>Did the design fit on their board?  Nope!</p>

    <p>Did this user understand why not?  Not at all.</p>

    <p>Size matters.</p>
  </li>
  <li>
    <p>Then there’s the reuse challenge associated with clock speed.  The
<a href="/about/zipcpu.html">ZipCPU</a> was originally built
on and for a Basys3 containing an Artix 7.  On that device, it runs
comfortably at 100MHz.</p>

    <p>It doesn’t run at 100MHz on other devices.  It only gets about 80MHz or so
on a Spartan 6, 50MHz or so on an iCE40 HX, and 25MHz or so on an iCE40 LX.
The only good news here is that one user reported running it on a Kintex
7 at over 140MHz if I recall correctly.</p>

    <p>This, however, oversimplifies reality.</p>

    <p>The <a href="/about/zipcpu.html">ZipCPU</a> on an
<a href="https://github.com/ZipCPU/videozip">Artix-7</a> with
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">instruction</a>
and <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data</a>
caches runs can run at nearly <a href="https://en.wikipedia.org/wiki/Cycles_per_instruction">one instruction per clock
period</a>, and so the
100MHz number is fairly accurate.</p>

    <p>The <a href="/about/zipcpu.html">ZipCPU</a> performance on the
<a href="https://github.com/ZipCPU/s6soc">Spartan 6 LX4 within the CMod S6</a>?  That
didn’t run nearly as fast.  Sure, it runs at an 80MHz clock speed.  The
problem is that it might take 20+ clocks to <a href="/zipcpu/2018/03/21/dblfetch.html">read a single instruction from
flash memory</a>.  Since
there’s barely any block RAM, and certainly no caches, the
<a href="/about/zipcpu.html">same CPU</a> can run at best at nearly
4<a href="https://en.wikipedia.org/wiki/Instructions_per_second">MIPS</a>.</p>

    <p>As a result, the <a href="/about/zipcpu.html">CPU</a> that might
manage to meet a real-time requirement on an Artix-7 35T, might get
nowhere close on a lesser architecture.</p>
  </li>
  <li>
    <p>The <a href="/about/zipcpu.html">ZipCPU</a> requires RAM.
Even if you turn the caches off, the
<a href="/about/zipcpu.html">ZipCPU</a>
still uses RAM for its register file.</p>

    <p>On most Xilinx devices, this isn’t a problem.</p>

    <p>Where this becomes a problem is <a href="https://github.com/ZipCPU/icozip">on an
iCE40</a>, since the
<a href="/formal/2018/07/21/zipcpu-icoboard.html">iCE40 requires that all RAM outputs need to be
registered</a>.
Reuse?  Sure, but I had to <a href="/formal/2018/07/21/zipcpu-icoboard.html">rearrange internal details of how the
ZipCPU operated</a>
just to support this platform.</p>
  </li>
  <li>
    <p>What about those multiplies?  The
<a href="/about/zipcpu.html">ZipCPU</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/mpyop.v">handles
multiplication</a>
by inference, as in <code class="language-plaintext highlighter-rouge">OUT &lt;= IN1 * IN2</code>.  What
then happens if the device it is on has no DSP support?</p>

    <p>This was first a problem in my Spartan 6 designs.  I was unable to get
decent timing on a Spartan 6 with this <a href="https://github.com/ZipCPU/zipcpu/blob/b3bee662b54a54d5b9ff27379e52d79b1e7f0a88/rtl/core/mpyop.v#L106-L130">multiplication
algorithm</a>.
So I created a <a href="https://github.com/ZipCPU/zipcpu/blob/b3bee662b54a54d5b9ff27379e52d79b1e7f0a88/rtl/core/mpyop.v#L132-L188">parameterized multiplication approach that did polynomial
multiplication based around 16x16 bit hard multipliers</a>.</p>

    <p>Even this didn’t work on an iCE40 with no built-in DSP support.  In that
case, I needed to build a <a href="https://github.com/ZipCPU/zipcpu/blob/b3bee662b54a54d5b9ff27379e52d79b1e7f0a88/rtl/core/slowmpy.v#L101-L122">shift and add based
multiplier</a>.
Even this took several rounds of design until I had an implementation
that not only worked, but also left enough room behind for non-CPU design
components.</p>
  </li>
  <li>
    <p>I should also mention my
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>
here.  One of the key components to any design I build is my
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>.
This allows me to load the
<a href="/about/zipcpu.html">ZipCPU</a>
externally, to run a
<a href="/zipcpu/2017/08/25/hw-debugging.html">ZipCPU debugger</a>,
and to <a href="/zipcpu/2017/05/20/which-came-first.html">interact with peripherals even when the ZipCPU is
halted</a>.</p>

    <p>This <a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>
didn’t fit on the <a href="https://github.com/ZipCPU/s6soc">Spartan 6/LX4 of the CMod
S6</a>, and so this is the one design where
I wasn’t able to make (much) use of it–although I still used it as part of
a special design to <a href="/blog/2019/03/27/qflexpress.html">load software onto the
flash</a>.</p>

    <p>My <a href="/blog/2017/06/05/wb-bridge-overview.html">supersized debugging
bus</a>
implementation, with FIFOs and
<a href="/formal/2019/10/05/formal-enough.html">compression</a>,
didn’t <a href="https://github.com/ZipCPU/icozip">fit on the iCE40</a>.  The <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">hexbus
implementation</a>
that we built together on the blog did fit.  I had never intended
to use this implementation in any of my designs, yet now having
built it I’m glad that I did.</p>

    <p>With all that said, the <a href="/blog/2017/06/16/dbg-bus-forest.html">debugging
bus</a> implementations
are really reuse success stories, since they’ve been used across so many
of my designs.</p>
  </li>
  <li>
    <p>Clocks.  Yes, clocks.  It should come as no surprise that I’ve had to
redesign the clocking logic from one architecture to the next.  Every
vendor provides their own PLLs, they all need to be configured differently,
etc.</p>

    <p>The good news is that
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
can handle this nicely.</p>

    <p>No, <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
doesn’t do clock configuration.  However, you can use
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
to propagate clock-based configuration constants across the design.  This
makes it easy, for example, to adjust the clock rate and have all of the
<a href="https://github.com/ZipCPU/wbuart32">UART</a> or SDRAM constant design
parameters adjust themselves automatically.</p>

    <p>Isn’t this just as easy as setting a parameter in the top level Verilog
file?  Not at all!  Don’t forget that the emulated serial port needs
to be adjusted for the new baud rate, as does the host software.
One of the nice things
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
handles is propagating information across multiple files of dissimilar
languages.</p>
  </li>
  <li>
    <p><a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
has worked wonders for building cross platform
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnects</a>,
and I’ve been very pleased with it.</p>

    <p>My <a href="https://github.com/ZipCPU/autofpga/tree/dev">newer version (still in the dev branch at this
time)</a> has support for
<a href="/zipcpu/2019/08/22/tech-debt.html">multiple bus masters and multiple bus
types</a>.  (The
original version required manually placing bus arbiters into a design
to whittle the design down to one master, and only ever supported the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone pipeline</a>
bus type.) Even better, all of the components are open source–so any
design so composed should work nicely with
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>.</p>

    <p>My problem is that this <a href="https://github.com/ZipCPU/autofpga/tree/dev">new version of
AutoFPGA</a>
is somewhat incompatible with the last one.  Why?  Because the <a href="/zipcpu/2019/08/22/tech-debt.html">interfaces
have changed</a>.</p>

    <p>Creating a design with multiple bus masters meant that I needed to rename
the bus, giving all of the bus slaves their own individual bus signal
wires to work with.  This alone is an incompatible change to
all of my designs that assumed all bus wires would be prefixed with <code class="language-plaintext highlighter-rouge">wb_</code>:
<code class="language-plaintext highlighter-rouge">wb_cyc</code>, <code class="language-plaintext highlighter-rouge">wb_stb</code>, <code class="language-plaintext highlighter-rouge">wb_we</code>, etc.</p>

    <p>I’ve also struggled with designs where I haven’t set up the bus logic
properly.  In earlier versions of
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>,
I’d pass <code class="language-plaintext highlighter-rouge">wb_stb &amp;&amp; (slave_sel)</code> to the design’s
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
strobe pin, and then suffered any time I forgot to properly place the
<code class="language-plaintext highlighter-rouge">slave_sel</code> in that logic.  The new version allows you to just say
<code class="language-plaintext highlighter-rouge">@$(SLAVE.PORTLIST)</code> and it then fills in all the necessary bus
connections.  This has <a href="/zipcpu/2019/08/22/tech-debt.html">forced all of my slaves to use the same bus
portlist order and format–another incompatible
change</a>.
(I could also use the ANSI ‘dot’ notation for connecting ports,
with just <code class="language-plaintext highlighter-rouge">@$(SLAVE.ANSIPORTLIST)</code>.)</p>

    <p>My point is simply this: after making a simple interface change like this,
I’m going to need to go back and re-build and then re-verify all of my
designs.  This isn’t all that unlike the configuration hell vendors have
found themselves within.  (But … my design worked with Vivado 2016.1,
why doesn’t it work any more with Vivado 2018.2?)</p>
  </li>
</ol>

<p>Still, the fact that the
<a href="/about/zipcpu.html">ZipCPU</a>
has been successfully used across so many architectures is by itself a reuse
success story.  Nirvana?  Perhaps not, but still quite valuable.</p>

<h2 id="reusing-the-design-across-cpus">Reusing the design across CPUs</h2>

<p>Okay, so I’ve now got a design framework I like using.  Can it be reused?</p>

<p>Specifically, one customer wanted me to reuse my framework to build a <a href="https://github.com/ZipCPU/zipversa">platform
containing a RISC-V CPU</a> instead of the
<a href="/about/zipcpu.html">ZipCPU</a>.  Surely reuse would work here,
right?</p>

<p>Let’s see: I owned all the submodule and component designs except for the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32 CPU</a>
I chose to use, so licensing wasn’t a problem.  I used
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> to compose
the component cores together, so there was no problem with building the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>.
I could reuse <a href="https://github.com/ZipCPU/zipversa/blob/master/sw/host/zipload.cpp">my CPU
loader</a>
to load the (flash) memory into a design, so that wouldn’t be a problem.  The
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>, like the
<a href="/about/zipcpu.html">ZipCPU</a>, was highly configurable
so it could be configured to start from the <a href="/zipcpu/2019/09/03/address-assignment.html">memory
address</a>
provided by <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>, it could be
configured for the number of
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>s
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> assigned to it, the design
had support for 32x32 bit multiplies, … what could possibly go wrong?</p>

<p>Since it looked so easy, I made a big mistake: I mis-estimated the amount
of time the project would take.  Since it was all reuse, it should’ve all been
easy.  Again, what could’ve gone wrong?</p>

<table align="center" style="float: right"><caption>Fig 11. Endianness: Which byte of a word is byte zero?</caption><tr><td><img src="/img/reuse/endianness.svg" alt="" width="360" /></td></tr></table>

<ol>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Endianness">Endianness</a>.</p>

    <p>That’s right.  The
<a href="/about/zipcpu.html">ZipCPU</a>,
is <a href="https://en.wikipedia.org/wiki/Endianness">big-endian</a>, and <a href="https://riscv.org/specifications/">RISC-V
machines are little endian</a>.
While <a href="/formal/2018/12/28/axilite.html">AXI</a> specifically
uses a <a href="https://en.wikipedia.org/wiki/Endianness">little-endian byte order</a>,
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> can be
either <a href="https://en.wikipedia.org/wiki/Endianness">big or little endian</a>.</p>

    <p>This left me with the age old question of how do you fit a square peg in a
round hole?</p>

    <p>My first thought was that I should add to the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/picorv/wb_picorv32.v">wrapper</a>
the logic necessary to swap all the words on the bus.</p>

    <p>Then I got to thinking–all of my peripherals depended upon the data bits of
the bus, from bits 31 down to bit 0, being in MSB down to LSB order.  If
I swapped the bytes in any of these control words, then writes to these
peripherals would’ve all been provided in
<code class="language-plaintext highlighter-rouge">{ data[7:0], data[15:8], data[23:16], data[31:24] }</code> order.</p>

    <p>That would never work.</p>

    <p>In the end, I created a new concept: bus endian.  Every peripheral that was
word addressable would use bus endian order and stay the same.  Every
peripheral that was byte addressable, rather than word addressable, would
get its byte order swapped.  This now limited my pain to the
<a href="/blog/2019/03/27/qflexpress.html">flash</a> and the
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/enet/enetpackets.v">network</a>
controllers.  A simple parameter, set by the <a href="https://github.com/ZipCPU/zipversa/blob/master/auto-data/picorv.txt#L60">CPU’s AutoFPGA
configuration</a>,
could then control whether or not the
<a href="/blog/2019/03/27/qflexpress.html">flash</a> or
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/enet/enetpackets.v">network</a>
controller needed to have their
<a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> swapped.</p>
  </li>
  <li>
    <p>There was a second problem as well, and that had to deal with the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>’s
bus interface.  It was custom, not
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.
No, it wasn’t all that hard to <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/picorv/wb_picorv32.v">convert from the PicoRV32’s custom
interface to a Wishbone interface</a>,
but the <a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>
took a big performance hit in the process.</p>

    <p>What?  Why?</p>

    <p>Well, the <a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>
only ever issues one bus request at a time.  That request waits on the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>’s
I/O lines until it is fulfilled.  Without knowing the next request location,
every I/O request becomes independent.  Every I/O request then requires a
number of clocks defined by the bus latency plus the peripherals latency.</p>

    <p>At best, the <a href="https://github.com/cliffordwolf/picorv32">250MHz (on a Xilinx device) capable PicoRV32
CPU</a> then ran slower than <a href="https://en.wikipedia.org/wiki/Cycles_per_instruction">40
clocks per instruction</a>.
No, this design didn’t support a <a href="/blog/2019/03/27/qflexpress.html">DDR based
flash</a>, and I didn’t
manage to get the <a href="/formal/2019/11/18/genuctrlr.html">DDR3 SDRAM
support</a>
working–hence it took 40 clocks to <a href="/zipcpu/2018/03/21/dblfetch.html">read each instruction from the
flash</a>.
Further, because the rest of the design slowed down the system clock,
the <a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>
could only ever run at 50MHz.  Then, because the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> didn’t support a
pipelined bus by nature, the best speed it could ever achieve was limited to
(roughly) 1.25<a href="https://en.wikipedia.org/wiki/Instructions_per_second">MIPS</a>.</p>
  </li>
  <li>
    <p>Finally, I needed to adjust the software ecosystem</p>

    <p>This is both a win and a fail for software reuse.  It’s a win, since most of
what I did was to copy the example boot loader that came with the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>,
and the <a href="https://github.com/ZipCPU/zipversa/blob/master/sw/rv32/syscalls.c">example newlib system
calls</a>
from the
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/zlib/syscalls.c">ZipCPU</a>.
It’s a fail because I still had to edit the two, but in general by the time
I got this far things “just worked”.</p>
  </li>
</ol>

<p>What’s the lesson here?  Did reuse work?  Well, yes and no.  I did manage to
reuse most of the design across both CPUs.  I did manage to reuse the <a href="/zipcpu/2017/10/05/autofpga-intro.html">bus
interconnect framework</a>
across both CPUs.  No, I wasn’t able to reuse the <a href="/zipcpu/2017/08/25/hw-debugging.html">ZipCPU’s
debugger</a> with the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>–but then again I wasn’t
expecting to.  That said, it wasn’t all that hard to <a href="/zipcpu/2017/08/25/hw-debugging.html">issue halt or reset
commands</a> to the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> from the <a href="/blog/2017/06/16/dbg-bus-forest.html">debugging
bus</a> interface over the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
bus like I <a href="/zipcpu/2017/08/25/hw-debugging.html">would’ve done with the
ZipCPU</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Hardware is not software.</p>

<p>Let me say that again, hardware is not software.  What’s easy to do in software
can be ten times harder in hardware where its that much <a href="/fpga-hell.html">harder to “see” your
bugs</a>.</p>

<p>What else might we conclude?</p>

<ol>
  <li>
    <p>There’s a large portion of digital design that isn’t covered by any HDL
standard, but that is rather vendor and even device dependent.  This
includes clocks, PLLs, I/O primitives, sometimes RAM structures, and
definitely hardware multiplies.</p>

    <p>To be reusable across platforms, you’ll need to take these differences into
account.</p>
  </li>
  <li>
    <p>If that’s not enough, the differences between the “standard” languages the
tools accept can also be really annoying.</p>

    <p>Don’t expect a design that hasn’t been used across vendor tools before to
immediately work when switching tools.</p>
  </li>
  <li>
    <p>Software bloat costs more memory than anything else, whereas hardware bloat
costs actual dollars in terms of scarce <a href="/blog/2017/06/12/minimizing-luts.html">hardware
resources</a> on an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> or area
on an <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>.  As a
result, hardware designs take more work in order to become reusable across
a large variety of needs.</p>
  </li>
  <li>
    <p>Bus standards are awesome–when they are truly <em>standard</em>.  AXI USER or
Wishbone tag signals aren’t really standard.  Similarly, the bus bridges
necessary to cross standards have a cost in both area and performance
that can’t always be ignored during reuse.</p>

    <p>Making sure bus standards are <em>standard</em> is one of those reasons why
I maintain a series of formal bus protocol checkers in my <a href="https://github.com/ZipCPU/wb2axip/">Wishbone to AXI
(pipelined) repository</a>: 
<a href="/formal/2018/12/28/axilite.html">AXI-Lite</a>,
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone (pipeline)</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/fwbc_slave.v">Wishbone (classic)</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/fav_slave.v">Avalon</a>,
and even <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/fapb_slave.v">APB</a>.</p>
  </li>
  <li>
    <p>The worst reuse stories, not necessarily those captured above, are reserved
for trying to reuse a core that was never formally verified in the first
place.  It’s in these cases that I most often find myself mis-estimating
the time and energy required to get a design “working”, leaving me
<a href="/blog/2019/11/14/sdspi.html">burning the midnight oil to get a design done by the
deadline</a>.</p>
  </li>
</ol>

<p>Can reuse happen?  Yes, it can.</p>

<p>Do be prepared for all kinds of unexpected issues along the way.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>The thing that hath been, it is that which shall be; and that which is done is that which shall be done: and there is no new thing under the sun. (Eccl 1:9)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
