<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>2019: AXI Meets Formal Verification</title>
  <meta name="description" content="It’s a new year!  Let’s continue our end-of-year tradition from2017and 2018and take a moment to look back over 2019, from theperspective of the ZipCPU blog, ...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2020/01/01/2019-in-review.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">2019: AXI Meets Formal Verification</h1>
    <p class="post-meta"><time datetime="2020-01-01T00:00:00-05:00" itemprop="datePublished">Jan 1, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>It’s a new year!  Let’s continue our end-of-year tradition from
<a href="/blog/2018/01/01/top-ten.html">2017</a>
and <a href="/blog/2018/01/01/top-ten.html">2018</a>
and take a moment to look back over 2019, from the
perspective of the ZipCPU blog, and see what stands out.</p>

<h2 id="blog-history">Blog History</h2>

<p>If you aren’t familiar with the back story, I started the ZipCPU blog back in
2017.  Back then, times were tough.  It had only been four years since starting
<a href="/about/gisselquist-technology.html">Gisselquist Technology</a>,
and contacts and jobs were drying up.</p>

<p>Did I know what I was doing when I began
<a href="/about/gisselquist-technology.html">Gisselquist Technology</a>
back in 2013?  While we can argue about whether I understood digital design
back then, I clearly did not understand business.  I knew it too.</p>

<p>Prior to 2017, I’d had a couple of gift jobs: friends I knew who just happened
to have just the right job for me.  At one time, I remember traveling to visit
my mother and then visited some friends who worked nearby.  These friends asked
me to come visit them at the office, during business hours, and so I found
myself walking into a meeting where the foregone conclusion was that they
wanted me to do a job for them.</p>

<p>This is what I consider a “gift”–not because it isn’t valid work, nor because
there’s anything untoward going on, but simply because I was the right person
for the job at the right time.  I walked into someone else’s need.  Such jobs
are <em>gifts</em> from the Almighty.</p>

<p>That said, it’s hard to plan on gifts, and I needed to learn how to find
business the hard way.</p>

<p>My original approach to business development was to build a portfolio of
digital designs on <a href="https://opencores.org">OpenCores</a>, and then use them
as discussion pieces on various digital forums.  Indeed, they made great
example designs for that purpose.  That said, this approach wasn’t bringing
in any business (at the time).  (I’ve since gotten several contracts from
this work.)</p>

<table align="center" style="float: right"><caption>Fig. 1.  Inbound Marketing</caption><tr><td><img src="/img/inbound-marketing.jpeg" alt="" width="240" /></td></tr></table>

<p>Then, in May of 2017 my aunt came to visit.  She took the whole family to
the local used book store to pick out gifts that were to be from Grandma–who
was getting too frail to visit everyone.  At the time, I picked up a book
titled, <a href="https://www.amazon.com/Inbound-Marketing-Found-Google-Social/dp/0470499311">Inbound
Marketing: Get Found using Google, Social Media, and
Blogs</a>.
I had heard of inbound marketing before, and the concept appealed to me.
Instead of cold calling prospective customers promoting my work, I’d promote
my work and capabilities on a blog to the extent that prospective customers
would contact me about what they wanted done, and I could make contacts that
way.</p>

<p>The idea appealed to me, so I started up <a href="https://zipcpu.com">zipcpu.com</a>
and started writing blog articles.  I also started creating a <a href="https://twitter.com/ZipCPU">twitter
feed</a>–all at the suggestion of the <a href="https://www.amazon.com/Inbound-Marketing-Found-Google-Social/dp/0470499311">Inbound
Marketing</a> book.</p>

<p>Thus began the ZipCPU blog.  Since that time, my <a href="https://twitter.com/ZipCPU">twitter
following</a> have grown to over three
thousand.  Wow.  Thanks, everybody!</p>

<h2 id="zipcpu-meets-formal-verification">ZipCPU meets Formal Verification</h2>

<p>Later that year, as I was preparing to head to <a href="https://orconf.org">OrConf</a>
for the second time, Edmund from <a href="https://symbioticeda.com">SymbioticEDA</a>
contacted me.  He wanted me to try out
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>, their new
formal verification tool.</p>

<p>What was I to say?  Did I need formal verification?  Of course not!  Why would
I need some bright new gadget to help me do what I’d been doing already?
What I did need, however, was marketing material for my blog.  So I decided
to condescend and see how this new formal verification tool worked, and then
<a href="/blog/2017/10/19/formal-intro.html">write a blog article about
it</a>.</p>

<blockquote>
  <p>When pride cometh, then cometh shame: but with the lowly is wisdom.
(<a href="https://www.blueletterbible.org/kjv/pro/11/2">Prov 11:2</a>)</p>
</blockquote>

<p>Much to my surprise, the formal verification tool taught me some desperately
needed humility.  <a href="/blog/2017/10/19/formal-intro.html">I applied the formal verification tool to a very basic
design, a simple FIFO that I’d used for years, only to discover it had bugs
in it that were never found by my test
bench</a>.</p>

<p>I then set out to <a href="/blog/2018/01/22/formal-progress.html">formally verify the rest of my
portfolio</a>.  Over and
over I found bugs, sometimes subtle ones, sometimes not so subtle.  I found
bugs in all kinds of places, notably in designs that had passed all of my
test benches: <a href="/zipcpu/2017/12/28/ugliest-bug.html">my prefetch and
cache</a>, <a href="/blog/2018/04/02/formal-cpu-bugs.html">my
CPU</a>,
my SDRAM controller,
<a href="/blog/2019/11/14/sdspi.html">my SD-Card controller</a>, <a href="/dsp/2018/10/02/fft.html">an
FFT</a> and much more.  Indeed, I’ve
since found so many bugs using formal verification, that I’m not sure I could
go back to what I was doing before–I no longer trust my ability to write
a test bench that would be “good enough”.</p>

<p>This has also made the blog quite unique: In a world where no one discusses
hardware bugs, where bugs get quietly swept under the rug, I was discussing
bugs in my own work.</p>

<p>Yes, I suppose the verse above is worth repeating.</p>

<blockquote>
  <p>When pride cometh, then cometh shame: but with the lowly is wisdom.
(<a href="https://www.blueletterbible.org/kjv/pro/11/2">Prov 11:2</a>)</p>
</blockquote>

<h2 id="formal-verification-meets-axi">Formal Verification meets AXI</h2>

<table align="center" style="float: left; padding: 20px"><caption>Fig. 2.  AXI uses 5 channels, any of which can stall</caption><tr><td><img src="/img/bus-axi-channels.svg" alt="" width="360" /></td></tr></table>

<p>While most of my designs used a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
bus</a>, every now and
again <a href="/blog/2019/04/27/axi-addr.html">I needed something using
AXI</a>.  So, back in late
2018, I started building a set of formal properties that could be used to
verify an AXI component–much like the <a href="/zipcpu/2017/11/07/wb-formal.html">formal properties I’d already used for
verifying my Wishbone
components</a>.</p>

<p>As with any project, I started off simple and just looked at
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>.  Unlike the full
AXI protocol, AXI-lite doesn’t have nearly as many signals to it, and so it
was fairly easy to work with.  I began simply  with the <a href="https://github.com/ZipCPU/wb2axip/blob/master/doc/busprops.pdf">four basic bus
properties</a>
I had learned to use when working with
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>:</p>

<ol>
  <li>Following a reset, everything should return to idle.</li>
  <li>When a request is stalled, its details shouldn’t be changed</li>
  <li>There shall be no responses without prior requests, and</li>
  <li>All requests get responses.</li>
</ol>

<p>These are pretty basic, and in the case of
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>
they weren’t all that hard to write out.</p>

<table align="center" style="float: right"><caption>Fig. 3.  Xilinx's 2016.3 AXI-lite demonstration design drops write acknowledgments.  Fixed by 2018.3</caption><tr><td><img src="/img/xilinx-axil/axil-xilinx-write-fail.svg" alt="" width="360" /></td></tr></table>

<p>I then looked around for a working design to try my new properties on.  It
didn’t take too long before I found <a href="/formal/2018/12/28/axilite.html">Xilinx’s demonstration
designs</a>.  Much to
my surprise, I found bugs.  The core would drop transaction responses,
as shown in Fig’s 3 and 4 where, with just a little bit of back pressure,
the second request’s response would get dropped.</p>

<p>The presumption, of course, was that my brand-new, untested <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal bus
properties</a>
were broken.  This would be the only sensible conclusion.  The <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">Xilinx
design</a>
I was trying to verify had been around for years.  It had been used by many
Xilinx customers.  Indeed, you’d expect the bugs to have been worked out of
them by the time I started working with them.</p>

<p>So I dug into the demonstration designs to see what was going on.  Again to
my surprise, I was able to verify that the bugs the formal tool found
were indeed valid.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig. 4.  Xilinx's 2016.3 demonstration AXI-Lite drops read acknowledgments.  Bug remains in 2019.1</caption><tr><td><img src="/img/xilinx-axil/axil-xilinx-read-fail.svg" alt="" width="360" /></td></tr></table>

<p>While this took place in late 2018, this was really the start of what I’m
going to call, the <em>year when AXI met formal</em>.</p>

<p>My surprise at <a href="/formal/2018/12/28/axilite.html">finding bugs in Xilinx’s AXI-lite
core</a> only intensified when
one of Xilinx’s engineer’s contacted me to explain that not returning a
response to a transaction wasn’t a bug, since the response might yet be
returned later.  Indeed, from just looking at Fig’s 3 and 4 you might not
catch that the trace ends in a <em>steady state</em>!  However, if you looked at the
core, you could tell that the response had been dropped and would never be
returned.</p>

<p>I then had to explain to them that this was their IP core I had found bugs in,
and not my own.  Unfortunately, this took more explaining than I was expecting.
Yes, I had modified the core: I had adjusted the white space, removed white
space from the ends of lines, and corrected spelling mistakes in the comments.
No, the logic wasn’t modified, etc.</p>

<table align="center" style="float: right"><caption>Fig. 5. The formal property file makes checking even the code of others easy</caption><tr><td><img src="/img/tweets/brken-axilite.svg" alt="" width="420" /></td></tr></table>

<p>Of course, from this point out things only got easier for me.  You see, now
that I had a <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal property file describing an AXI-lite
interface</a>,
testing and checking other cores became routine.  With this property set,
plus the <a href="https://www.symbioticeda.com/seda-suite">Symbiotic EDA Suite</a>,
I could now take any AXI-lite design, Verilog, VHDL, or even System Verilog,
posted to any forum, attach <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">my property
file</a>,
and verify that the bus interface to such a core was (or was not)
working—even before I understood all of the details of how the core was
supposed to work.  Several cores were forwarded to me at that time to verify.
Almost all were  broken, and worse <em><a href="/formal/2019/04/16/axi-mistakes.html">most were broken in the same
way</a></em>.  The most
notable exception was an <a href="https://github.com/analogdevicesinc/hdl/hdl/library/common/up_axi.v">Analog Devices
core</a>–a
pleasant surprise along the way since it <em>just worked</em> unlike the other cores
I had been checking.</p>

<p>Now that I had <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">my own formal property
file</a>,
I could do more than check the properties of others, I could now <a href="/formal/2019/01/12/demoaxilite.html">build my own
AXI-lite slave core</a>
as well.  At this point, it was easy to do.  Fig. 6 shows the kind of
throughput I was able to achieve on the write channel,</p>

<table align="center" style="float: right"><caption>Fig. 6. AXI-lite demonstration, showing 100% write throughput</caption><tr><td><a href="/img/xilinx-axil/axil-demo-write.svg"><img src="/img/xilinx-axil/axil-demo-write.svg" alt="" width="780" /></a></td></tr></table>

<p>and Fig. 7 shows the performance on the write channel.  In both cases, I was
able to achieve 100% throughput–shown at the end of the traces above.
This is in contrast to Xilinx’s demonstration cores which achieved only 50%
throughput in Vivado 2016.3 (less in 2018.3) and many of Xilinx’s AXI full IP
cores.</p>

<table align="center" style="float: right"><caption>Fig. 7. AXI-lite demonstration, showing 100% write throughput</caption><tr><td><a href="/img/xilinx-axil/axil-demo-read.svg"><img src="/img/xilinx-axil/axil-demo-read.svg" alt="" width="780" /></a></td></tr></table>

<p>I then turned my attention to building a full AXI4 property set, rather than
just the AXI-Lite version.</p>

<p>AXI4 was much more of a challenge to formally verify, and that for a couple of
reasons.  First, the IDs make things challenging.  An AXI slave is allowed to
return transactions in any order, as long as all of the transactions associated
with a given ID are returned in order.  Second, the burst lengths are a
challenge.  In particular, it can be a challenge to verify that the <code class="highlighter-rouge">RLAST</code>
signal is properly set after two or more read address requests have been
accepted.  In any implementation, a FIFO would fix this kind of problem nicely.
Indeed, AXI processing and FIFOs work well together.  This of course led
to the third problem: verifying properties of the output of a
FIFO can be quite a challenge.</p>

<p>When designing an AXI component, these various constraints aren’t really all
that hard to deal with.  The various transaction information may be placed
into FIFOs within the slave, and dealt with accordingly–but how shall these
extra properties be handled in the context of <a href="/blog/2018/03/10/induction-exercise.html">formal
induction</a>?</p>

<p>If you haven’t worked with
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
before, you should at least know that
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
has its own particular challenges.  In particular, the formal engine will
start in the middle of time–with your design already in some state.  Only
your assertions and to some extent your assumptions will hold that state
consistent.   While it is possible to provide assertions to describe
every item in a FIFO, it’s typically an expensive and challenging thing to do.
But without doing this, it would be easy for the design and the formal
properties to get into an inconsistent state.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig. 8. Xilinx's 2018.3 AXI4 demonstration design didn't guarantee the right return ID</caption><tr><td><img src="/img/axifull/axifull-rdid.svg" alt="" width="360" /></td></tr></table>

<p>With some help from Clifford, I managed to put a set of AXI properties
together.</p>

<p>As before, I first turned to one of <a href="/formal/2019/05/13/axifull.html">Xilinx’s demonstration
cores</a> to test my
properties.  Again, to my surprise, <a href="/formal/2019/05/13/axifull.html">Xilinx’s demonstration AXI4 (full) IP was
also broken</a>.</p>

<p>First, it didn’t guarantee the right packet ID would be returned on either
read (Fig 8) or write channels.  Second, the write channel couldn’t handle
backpressure as shown in Fig. 9.</p>

<p>This left me somewhat perplexed.  <a href="/formal/2019/09/06/axi-story.html">How could such example designs have been
broken for so long</a>?
Indeed, Xilinx was using their examples in all of their training material.
Surely these examples would’ve been important for them to get right?</p>

<table align="center" style="float: right"><caption>Fig 9. Xilinx's core can't handle backpressure</caption><tr><td><a href="/img/axifull/axifull-bvalid-fail.svg"><img src="/img/axifull/axifull-bvalid-fail.svg" alt="" width="560" /></a></td></tr></table>

<p>After a bit of digging, I discovered reports of AXI designs that would hang
dating back several years.  Customers trusted Xilinx’s demo designs, and so
believed the bugs were elsewhere–but then struggled to find the problem
that was causing their design to lock up.  Forum moderators typically blamed
customer designs, since no one was able to reproduce the bugs in a test-bench.
Not only that, but not all interconnect configurations or transaction
combinations would trigger the bugs.  Many of the more common interconnect
configurations wouldn’t trigger the bugs at all.  However, if you then
switched configurations, the bug would get triggered and you’d end up looking
in the wrong place.</p>

<table align="center" style="float: center"><caption>Fig 10. Xilinx's 2018.3 AXI4 demonstration design checks for WLAST without also checking for WVALID.  As a result, WREADY gets dropped before the transaction is complete</caption><tr><td><a href="/img/axifull/axifull-wlast.svg"><img src="/img/axifull/axifull-wlast.svg" alt="" width="490" /></a></td></tr></table>

<p>I then discovered that Xilinx would <a href="/formal/2019/09/06/axi-story.html">delete forum posts of dissatisfied
customers, or of posters who would complain of broken
infrastructure</a>.  Indeed,
Fig. 11 shows a comment recommending the use of formal methods, the only
method that has so far found these sorts of bugs, that Xilinx deleted from
their forums.</p>

<table align="center" style="float: center"><caption>Fig 11. Xilinx deletes posts that would lead you to their bugs</caption><tr><td><img src="/img/tweets/xilinx-deleted-recommending-formal-tools.png" alt="" width="780" /></td></tr></table>

<p>No wonder why the bugs went so long without ever getting fixed.</p>

<p>During this time, I had the opportunity to speak with Xilinx’s representatives
as well.  Thankfully, they (eventually) acknowledged the faults in their
demonstration cores.</p>

<table align="center" style="float: center"><caption>Fig 12. Xilinx's core checks for WLAST without also checking for WVALID</caption><tr><td><a href="/img/tweets/xilinx-demarco-acknowledges.png"><img src="/img/tweets/xilinx-demarco-acknowledges.png" alt="" width="780" /></a></td></tr></table>

<p>Xilinx’s explanation was that these “IP Packager” cores, the ones I call
their demonstration cores, came from an uncertain open source origin and
were never placed under Xilinx configuration management, and so they were
never verified along with the cores Xilinx considers their IP.  I was then
assured that Xilinx’s proper IP cores would never have these problems.
Those were verified by a “best in class” verification methodology (not formal)
every night, so I could rest assured that these other cores were bug free.
No, this “best in class” verification methodology did not use their
AXI VIP.  (I asked.)  Apparently, they didn’t even trust their own Verification
IP for this purpose.</p>

<table align="center" style="float: left"><caption>Fig 13. Intel's demo core also checks WLAST without also checking WVALID and WREADY</caption><tr><td><a href="/img/axi-intel/axi-intel-wlast.svg"><img src="/img/axi-intel/axi-intel-wlast.svg" alt="" width="490" /></a></td></tr></table>

<p>I didn’t stop with Xilinx, however.  I checked out Intel’s demonstration core
too.  This one was an AXI3 core, and so not quite the type of AXI4 core my
properties had been built to handle.  On the other hand, if you limited the
proof to looking at one ID only, then it wasn’t hard to use the same properties
for both.</p>

<p>Just like Xilinx’s demonstration core, Intel’s was broken as well–in multiple
places.  Fig. 13 shows a burst request, attempting to send <code class="highlighter-rouge">AWLEN+1</code> or two
words of data, but where <code class="highlighter-rouge">BVALID</code> is set high before the second <code class="highlighter-rouge">WDATA</code> element
was received.  Not only that, <code class="highlighter-rouge">WREADY</code> was dropped.  Like the Xilinx bugs
above, this would likely cause the design to freeze.</p>

<p>Nor was this the only bug.  Fig. 14 shows an example where just a little bit
of back-pressure from the first burst would cause Intel’s core to drop the
second response.</p>

<table align="center" style="float: right"><caption>Fig 14. Intel's demo core can't handle backpressure on BREADY either</caption><tr><td><a href="/img/axi-intel/axi-intel-bvalid.svg"><img src="/img/axi-intel/axi-intel-bvalid.svg" alt="" width="560" /></a></td></tr></table>

<p>The story didn’t stop there, however.  Now that I had a formal property set
to describe AXI4 transactions, I could verify just about any AXI4 interface.
Doing so was as easy as creating a wrapper for the design in question, attaching
the formal property set and the core in question to the wrapper, and then
running the formal tools.  Running the test rarely required more than a lot
of typing.</p>

<p>As an example, I recently applied the
<a href="https://www.symbioticeda.com/seda-suite">Symbiotic EDA Suite</a>,
to <a href="https://www.xilinx.com/products/intellectual-property/axi_ethernetlite.html">Xilinx’s AXI Ethernet-Lite IP
core</a>.  Here’s what I discovered:</p>

<ol>
  <li>Contrary to <a href="/doc/axi-spec.pdf#page=41">spec</a>, Xilinx’s
RVALID logic requires RREADY to be set</li>
</ol>

<table align="center" style="float: center"><caption>Fig 15. Xilinx's Ethernet-Lite, RREADY depends upon RVALID</caption><tr><td><a href="/img/xilinx-axi-ethernetlite-axi_rvalid.png"><img src="/img/xilinx-axi-ethernetlite/axi_rvalid.png" alt="" width="511" /></a></td></tr></table>

<ol start="2">
  <li>This means that the design will hang if the interconnect doesn’t hold
RREADY high during any read request</li>
</ol>

<table align="center" style="float: center"><caption>Fig 16. Xilinx's Ethernet-Lite, reads will never set RVALID if !RREADY</caption><tr><td><a href="/img/xilinx-axi-ethernetlite/axi_rvalidtrace.png"><img src="/img/xilinx-axi-ethernetlite/axi_rvalidtrace.png" alt="" width="780" /></a></td></tr></table>

<ol start="3">
  <li>Not only will the design hang waiting for the master to raise <code class="highlighter-rouge">RREADY</code>, but
it will also accept new requests during this time.  The resulting returns
might then have the wrong <code class="highlighter-rouge">RID</code>.  Fig. 17, for example, shows a request
of length <code class="highlighter-rouge">ARLEN+1</code> or one data value using ID <code class="highlighter-rouge">3'b101</code>.  The response
then comes back with an <code class="highlighter-rouge">RID</code> of <code class="highlighter-rouge">3'b100</code>–an error, since the <code class="highlighter-rouge">3'b100</code>
response needed <code class="highlighter-rouge">8'h91</code> values before getting a return with <code class="highlighter-rouge">RLAST</code> set.</li>
</ol>

<table align="center" style="float: center"><caption>Fig 17. Xilinx's Ethernet-Lite, reads will never set RVALID if !RREADY</caption><tr><td><img src="/img/xilinx-axi-ethernetlite/axi_rid.png" alt="" width="780" /></td></tr></table>

<ol start="4">
  <li>Returns might even be given the wrong <code class="highlighter-rouge">RLAST</code>.  While Fig. 17 hinted at this
problem, you can see it clearly in Fig. 18 below.  In this case, two requests
are made for <code class="highlighter-rouge">ARID=3'b000</code>.  The first request is for a single beat, the
second for <code class="highlighter-rouge">1+8'h3E</code> beats.  However, when the core responds to the first
request, <code class="highlighter-rouge">RLAST</code> is still low.  The cause?  Primarily the simple fact that
this core can’t handle backpressure.</li>
</ol>

<table align="center" style="float: center"><caption>Fig 18. Xilinx's Ethernet-Lite, reads will never set RVALID if !RREADY</caption><tr><td><img src="/img/xilinx-axi-ethernetlite/axi_rlast.png" alt="" width="780" /></td></tr></table>

<ol start="5">
  <li>If all of that wasn’t bad enough, writes accepted at the same time reads
are accepted will <em>write their values to the address given on the read
channel.</em>  You can see this by examining the code from their design.
If you want to check your own install, check out the
<code class="highlighter-rouge">axi_ethernetlite_v3_0/hdl/axi_ethernetlite_v3_0_vh_rfs.vhd</code> file in your
Vivado <code class="highlighter-rouge"><span class="p">{</span><span class="err">INSTALL</span><span class="p">}</span><span class="err">/data/ip/xilinx/data/ip/xilinx/axi_ethernetlite_v</span><span class="mi">3</span><span class="err">_</span><span class="mi">0</span><span class="err">/hdl</span></code>
directory.</li>
</ol>

<table align="center" style="float: center"><caption>Fig 19. Xilinx's Ethernet-Lite, reads will never set RVALID if !RREADY</caption><tr><td><a href="/img/xilinx-axi-ethernetlite/axi-addr.png"><img src="/img/xilinx-axi-ethernetlite/axi-addr.png" alt="" width="746" /></a></td></tr></table>

<ol start="6">
  <li>To keep this from happening, their design prohibits reads during writes and
writes during reads.  The only problem is, they never check for read and
write requests being made on the same clock cycle.</li>
</ol>

<table align="center" style="float: center"><caption>Fig 20. Xilinx's Ethernet-Lite, doesn't keep AWVALID &amp; ARVALID from both starting accesses at the same time</caption><tr><td><a href="/img/xilinx-axi-ethernetlite/awready_arready.png"><img src="/img/xilinx-axi-ethernetlite/awready_arready.png" alt="" width="915" /></a></td></tr></table>

<p>Apparently, Xilinx’s professional “best in class” AXI property checker
doesn’t include a formal property check.  Just like my own <a href="/blog/2017/10/19/formal-intro.html">first experiences
with formal methods</a>,
they’ve now been burned by designs that passed a test bench without being
specification compliant.</p>

<p>I’ve also applied formal methods to their <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">Block RAM
controller</a>.  Along the way I discovered that it
could only handle reads or writes, never both at the same time–despite the
fact that AXI has channels for both.  (This seems like a common theme, no?)
Not only that, but <a href="/blog/2019/05/29/demoaxi.html">my own example
design</a> achieved better
throughput on single channels.  Here’s their best block RAM read performance,
requiring <code class="highlighter-rouge">N+3</code> clocks to read <code class="highlighter-rouge">N</code> elements.</p>

<table align="center" style="float: center"><caption>Fig 21. Xilinx's block RAM controller, requires N+3 clocks to read N elements</caption><tr><td><img src="/img/xilinx-bram-ctrl/read-burst.png" alt="" width="746" /></td></tr></table>

<p>Poor burst performance wasn’t limited to reads, but also affected the write
channel as well.</p>

<table align="center" style="float: center"><caption>Fig 22. Xilinx's block RAM controller, requires N+3 clocks to read N elements</caption><tr><td><img src="/img/xilinx-bram-ctrl/write-burst.png" alt="" width="746" /></td></tr></table>

<p>Let’s now think this through.  These bugs were found within just a few of
Xilinx’s IP cores where they’ve publicly posted their design code.  How many
bugs would you now expect from IP that hasn’t been posted publicly?</p>

<p>This is where and why open source becomes so important.  When the design source
is open, you can verify the existence of any bugs on your own.</p>

<p>To this end, I’ve also managed to verify and demonstrate several <a href="https://github.com/ZipCPU/wb2axip">IP cores of
my own</a> using this AXI4 property set as
well:</p>

<ol>
  <li><a href="/blog/2019/07/17/crossbar.html">An AXI Crossbar</a></li>
  <li>
    <p>Data movers:
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">AXIMM2S</a>
and <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">AXIS2MM</a>.</p>

    <p>These two are my own.  They bare no internal resemblance to Xilinx’s
(encrypted) data mover cores–or shall I say they bare no resemblance that
I am aware of.</p>

    <p>No, I haven’t verified Xilinx’s data movers as either working on not.
Unlike their data movers, 1) these two cores work within Verilator, and
2) they can both achieve a 100% AXI throughput.</p>
  </li>
  <li><a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">An AXI to AXI-lite
bridge</a>.
Better yet, an AXI to AXI-lite bridge that gets 100% throughput–meaning you
can write an AXI-lite slave that can still process AXI transactions without
slowing down.</li>
</ol>

<table align="center" style="float: center"><caption>Fig 23. Read performance of my own AXI to AXI-Lite bridge</caption><tr><td><img src="/img/tweets/axi2axil-read-burst.png" alt="" width="940" /></td></tr></table>

<ol start="4">
  <li><a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axim2wbsp.v">An AXI to Wishbone bridge</a></li>
</ol>

<ol start="5">
  <li><a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">A Wishbone to AXI bridge</a></li>
</ol>

<ol start="6">
  <li><a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">An AXI
Firewall</a>,
which can detect any of the bugs discussed above, forcing
a slave to either be compliant or to be reset.  As a special bonus, the
slave can be reset and re-integrated into the design–without either hanging
or propagating any non-compliant responses upstream.</li>
</ol>

<p>None of these insights would’ve been possible without either the
<a href="https://www.symbioticeda.com/seda-suite">Symbiotic EDA Suite</a>,
or the formal AXI4 property set for verifying AXI cores.</p>

<h2 id="the-new-tutorial">The New Tutorial</h2>

<p>In the middle of all of this, I also built a <a href="/tutorial">beginners Verilog
tutorial</a>.  My work on this
<a href="/tutorial">tutorial</a>
started in 2018, although it took until May of 2019 for me to finish it.  The
<a href="/tutorial">tutorial</a>
was initially intended to be something that could be used as a set of
lecture slides for a class.  As a result, it consists of a series of PDF
files and some partially completed (and deliberately broken) homework exercises.</p>

<p>Unlike many other approaches, my own approach doesn’t teach the full Verilog
test-bench syntax.  Instead, I chose to use Verilator and C++ design wrappers.
My reason was simply due to the fact that I’d seen so many students get
confused when attempting to synthesize what should’ve been test-bench only code.</p>

<p>The second big difference with my approach was that I taught how to apply
formal verification to every design, starting in lesson three.</p>

<p>The third big difference was that I tried to be hardware agnostic.  All you
needed was a simulator–in this case, Verilator.  As a bonus, if you had an
FPGA, any FPGA with nothing more than serial port, a button (or switch),
and several LEDs, you could build all of the designs for your board.  Indeed,
I avoided proprietary design components like the plague–in order to keep the
<a href="/tutorial">tutorial</a> fully generic.</p>

<p>The course has been well received, albeit with caveats:</p>

<ol>
  <li>
    <p>Students with some Verilog background have balked at my liberal usage of
C++ and Makefiles.  Why, they’ve asked, should they be required to learn
a new language?  This is understandable.  On the other hand, students with
more of a software background have likely felt quite at home with this
approach.</p>
  </li>
  <li>
    <p>Since the rest of the industry uses Verilog test benches (or SystemVerilog,
or VHDL …), the <a href="/tutorial">tutorial</a>
has often left students either without this valuable skill
or wondering how they should be using it.</p>
  </li>
  <li>
    <p>Since I used Verilator and the open version of
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
for all of the projects, there was no ability to add a parallel VHDL
tutorial.  Many students have asked for one.  This is currently something
that I am unable to provide using free tools.</p>
  </li>
  <li>
    <p>Because I used PDF files, I can’t track downloads.  This makes it hard to
know if students are really interacting with the
<a href="/tutorial">tutorial</a> itself, or perhaps just the
formal verification courseware slides that are further down on the same
page.  I suppose it doesn’t matter, both would be good things, I’d just
love to know and understand more about my readers.</p>
  </li>
</ol>

<p>Finally, several individuals have asked for a course that goes into the next
step–an <a href="/blog/2019/08/16/intermediate.html">intermediate design
course</a>.  Such a
course would teach design in the context of a system with either a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
or an AXI-Lite internal bus.</p>

<table align="center" style="float: none"><caption>Fig 24. Proposed intermediate tutorial structure</caption><tr><td><a href="/img/im-tutorial/tut-intermediate.svg"><img src="/img/im-tutorial/tut-intermediate.svg" alt="" width="720" /></a></td></tr></table>

<p>At this point, however, my world <a href="/tutorial">tutorial</a>
domination plans have gotten slowed down.  Specifically, I want my
<a href="/blog/2019/08/16/intermediate.html">intermediate design
tutorial</a>
to remain vendor agnostic–while still being useful on SOC (FPGA+ARM) chips.
That means that the
<a href="/blog/2019/08/16/intermediate.html">tutorial</a> will need to
teach students how to connect bus components to a design using only open
source tools.</p>

<p>As of today, I think I’ve finally got
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> lined up for that purpose.
It now has an (untested, and quite likely buggy) <a href="https://github.com/ZipCPU/autofpga/tree/be56554f65c84a7bed96bec61c2224e53d39c0e4">development
branch</a>
that supports not only <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
(pipeline)</a>,
but also AXI-lite and AXI–with an appropriate set of <a href="https://github.com/ZipCPU/wb2axip">crossbars, bridges,
and bus simplifiers</a> to make certain
things work together properly.</p>

<table align="center" style="float: none"><caption>Fig 25. Simplifying SOC component development using Wishbone</caption><tr><td><a href="/img/zynqsoc-axiwb.svg"><img src="/img/zynqsoc-axiwb.svg" alt="" width="560" /></a></td></tr></table>

<p><a href="https://www.blueletterbible.org/kjv/jas/4/15">If the Lord is willing</a>,
I look forward to finally getting some of the lessons associated with this
course written in 2020.</p>

<h2 id="viewership-in-2019">Viewership in 2019</h2>

<p>With all that background aside, it’s now time to turn our attention to some
statistics from 2019.  Care to see how well the blog has done?  As you can
see from the chart below, the ZipCPU blog has really taken off this last year.</p>

<table align="center" style="float: none"><caption>Fig 26. 2019 ZipCPU Page Views</caption><tr><td><img src="/img/2019-pageviews.png" alt="" width="720" /></td></tr></table>

<p>Last year, the blog had 183,281 page views.  This year, we’ve had 332,735 page
views.  Readership is definitely up.</p>

<p>Even better, the blog has gone from a maximum of 647 page views per day within
a week, shown on the far left of Fig. 26 above, to 1,984 page views in one day
during one week in December.  This is nearly a three-fold increase in the
number of page views.</p>

<p>If you are new to the blog, then, welcome!</p>

<p>That said, if you want to sell me web software to help my blog get
noticed by the big search engines, then No, Thank you.  The blog is doing
quite nicely on its own.</p>

<p>Another thing to notice that’s fascinating about this chart is that most of
the page views take place between Monday and Friday.  This tells me that the
ZipCPU blog isn’t just read by hobbyists–apparently the professionals
find this information quite relevant as well.</p>

<p>Welcome, professionals!</p>

<p>Third, you’ll notice that readership slowed somewhat during June and July.
Initially, I attributed this to the fact that I was working on so many
contracts that it was difficult to write new articles.  Now, looking over the
months since then, I’m not so sure.  Instead, I’m more tempted to believe that
this slump is due to the end of the school year and either students not
reading the articles, or professionals going on vacation.</p>

<p>Finally, I think that in many ways the reason why the blog took off this year
is because of my AXI work above.  I was pleasantly surprised to see how many
hits the various AXI articles received, as I’ll discuss in the next section.</p>

<h2 id="top-articles-written-in-2019">Top Articles Written in 2019</h2>

<p>Let’s now look at some of the most popular articles from 2019.  As we did
last year, I’ll treat these as a top ten list, and work my way from number
ten (least popular) down to number one (most popular).  I’ll also continue
my tradition of splitting the lists into two.  The first list will consist
of the most popular articles <em>written</em> in 2019, and then in the next section
we’ll look at a list of the most popular articles over all based upon what
was <em>viewed</em> in 2019.</p>

<p>I’ll start with two honorable mentions.</p>

<ul>
  <li>
    <p><a href="/formal/2019/09/06/axi-story.html">AXI Verification, the story so far</a></p>

    <p>While this article didn’t quite break into the 2019 top ten, to me it tells
the <em>story</em> of what’s been going on, told in a way that even a manager might
understand it.  In short, user after user has tried to build an AXI
component, likely following the demonstration guides given them by their
vendor, only to find that their design will suddenly freeze for a reason
they can’t seem to fathom.</p>

    <p>The fact that these bugs were finally found using formal methods should
be a lesson to all.</p>

    <p>This article had 1,018 page views.</p>
  </li>
  <li>
    <p><a href="/formal/2019/08/03/proof-duration.html">Just how long does a formal proof take to
finish?</a></p>

    <p>A second article to miss the top ten was this neat one on proof durations.
Since I’ve now performed and maintain nearly a thousand proofs, it’s easy
to draw some statistics from them.  Surprisingly, as this article
demonstrates, formal proofs tend to be fairly fast overall–something
worth remembering.</p>

    <p>Of course, the statistic might also be biased by the fact that I always use
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.
Without
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
it’s hard to know how much formal verification is enough.  With it,
proofs can confidently be shortened to a minimum length.</p>

    <p>That said, I’ll let you read more about this yourself if you’d like.</p>

    <p>This article had 1,130 page views.  It is currently the #1 result of
a <a href="https://duckduckgo.com">duckduckgo.com</a> search on <a href="https://duckduckgo.com/?q=how+long+does+a+formal+proof+take&amp;t=canonical&amp;ia=web">how long does a formal proof
take</a>.
I would share Google search result rankings, except that Google seems to
know what I’m looking for even before I type anything.  This is why I’m
posting <a href="https://duckduckgo.com">duckduckgo</a> search result rankings.</p>
  </li>
</ul>

<ol start="10">
  <li>
    <p><a href="/zipcpu/2019/02/04/debugging-that-cpu.html">Debugging that CPU</a></p>

    <p>This is a fascinating article because it walks through the steps I went
through to find a fault within a design where the ZipCPU suddenly froze
mid-program.  It walks through and describes the various tools which can be
used to debug a CPU design, and then discusses how they did (or did not)
help in this case.</p>

    <p>The bug in question was a particularly ugly one too–involving a race
condition between the interrupt line and the compressed instruction word
decoder.  In the end, a watchdog timer connected to an internal logic
analyzer was used to provide evidences of the bug, evidences which were
then be placed into a formal verification context to find the details
surrounding what caused the bug.</p>

    <p>Looking back over the article today, it’s a fond memory and a fun read.</p>

    <p>This article had 1,184 page views.  It is currently the #1 result of
a <a href="https://duckduckgo.com">duckduckgo.com</a> search on <a href="https://duckduckgo.com/?q=debugging+a+cpu&amp;t=canonical&amp;ia=web">Debugging a
CPU</a>.</p>
  </li>
</ol>

<ol start="9">
  <li>
    <p><a href="/blog/2019/06/28/genclk.html">Breaking all the rules to create an arbitrary clock signal</a></p>

    <p>One of the first <a href="/blog/2017/08/21/rules-for-newbies.html">rules I give to beginning digital
designers</a> is
that you should never, ever, transition your logic on the positive (or
negative) edge of something that isn’t a bonafide clock signal.  Never.
Just … don’t do it.  There be dragons there.</p>

    <p>In this article, however, I poke into the issue to see if a clock can be
generated at an arbitrary clock rate using logic and an OSERDES.  Sure
enough, I demonstrate FPGA-based clock generation with sub-Hz resolution
and less than <code class="highlighter-rouge">1ns</code> phase noise.</p>

    <p>Yes, folks, it can be done!  Even better, the design isn’t all that hard
to understand either.</p>

    <p>This article had 1,233 page views.  It is currently the #1 <a href="https://duckduckgo.com">duckduckgo.com</a>
hit for <a href="https://duckduckgo.com/?q=arbitrary+clock+generator+example&amp;t=canonical&amp;ia=web">arbitrary clock generator example</a>.</p>
  </li>
</ol>

<ol start="8">
  <li>
    <p><a href="/blog/2019/07/17/crossbar.html">Lessons learned while building Crossbar
Interconnects</a></p>

    <p>Most of the designs I’ve reviewed on either
<a href="https://forum.digilentinc.com">Digilent’s</a>
or <a href="https://forums.xilinx.com">Xilinx’s</a>
forums include some form of an AXI Interconnect within them.  Indeed, my
own Intel Cyclone-V design starts with the AXI Interconnect output from
the ARM SoC.  These are very vendor dependent interconnects.  They are
proprietary, encrypted, and cannot run under Verilator.</p>

    <p>Building my own interconnect was therefore a necessary part of building
a vendor independent infrastructure.  Sure, I hear the question now, but
aren’t you a vendor?  I suppose you might say that.  However, I’ve posted
the design files for my (unencrypted) interconnect(s) online–so feel free
to use them as you need them.</p>

    <p>Sadly, an interconnect is really too complicated for a blog article.  So,
instead, this article discusses the design of an interconnect in broad brush
terms so you can see how one might work and what the various internal
components might look like.</p>

    <p>This article had 1,428 page views.  It is currently the #2 <a href="https://duckduckgo.com">duckduckgo.com</a>
hit for <a href="https://duckduckgo.com/?q=crossbar+interconnect&amp;t=canonical&amp;ia=web">crossbar interconnect</a>.</p>
  </li>
</ol>

<ol start="7">
  <li>
    <p><a href="/blog/2019/03/27/qflexpress.html">Building a Universal QSPI Flash
Controller</a></p>

    <p>After building about four other flash controllers, it was time to see if I
could build one that might work for all of my designs, across all of the
various flash components I’ve worked with, while maintaining high speed.</p>

    <p>This article, one of my longer ones, goes through what it took to do this,
while also describing how design bloat took hold to make this
one-size-fits-all design more complex than a special purpose controller
would have been.  Indeed, at one point I named this a piece of <em>Franken-IP</em>.</p>

    <p>Of course, the devil lies in the details.  Since writing the article, I was
disappointed to discover that the core didn’t support a flash design that
had neither DDR support for the flash clock, nor XiP support.  Of course,
this didn’t happen on any of <em>my</em> hardware …</p>

    <p>This article had 1,696 page views.  It is currently the #4 <a href="https://duckduckgo.com">duckduckgo.com</a>
hit for <a href="https://duckduckgo.com/?q=crossbar+interconnect&amp;t=canonical&amp;ia=web">QSPI flash controller</a>,
behind (among other things) <a href="https://opencores.org/projects/qspiflash">my own QSPI flash controller
core</a> on
<a href="https://opencores.org">OpenCores</a>.</p>
  </li>
</ol>

<ol start="7">
  <li>
    <p><a href="/formal/2019/05/13/axifull.html">Examining Xilinx’s AXI Demonstration
Core</a></p>

    <p>As mentioned above, one of my first tasks after building a formal property
set for the full AXI protocol was to verify a core using it.  This article
discusses all of the bugs I found when verifying Xilinx’s AXI demonstration
IP core.</p>

    <p>This article had 1,873 page views.
It is currently the #16 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=xilinx+axi+slave&amp;t=canonical&amp;ia=web">Xilinx AXI
slave</a>,
falling behind my own article on <a href="/blog/2019/05/29/demoaxi.html">Building the perfect AXI4
slave</a>
at #11.</p>
  </li>
</ol>

<ol start="5">
  <li>
    <p><a href="/blog/2019/05/22/skidbuffer.html">Building a Skid Buffer for AXI
Processing</a></p>

    <p>AXI has a particular requirement that there can be no combinatorial paths
between AXI inputs and outputs.  This applies most painfully to the <code class="highlighter-rouge">xREADY</code>
wires.  The easy way around this is to use a <em>skidbuffer</em>, as discussed in
this article.  Indeed, creating a skid buffer makes building AXI logic so
easy that I’ve since been converting all of my designs so that they use them
explicitly.  If you want to see an example of this, check out the
data mover cores:
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">AXIMM2S</a>
and <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">AXIS2MM</a>.
These both have a skidbuffer based AXI-lite interface–one that was almost
as easy as a <a href="/zipcpu/2017/05/29/simple-wishbone.html">Wishbone
interface</a> to
write.</p>

    <p>This article had 2,003 page views.
It is currently the #1 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for
<a href="https://duckduckgo.com/?q=skidbuffer&amp;t=canonical&amp;ia=web">skidbuffer</a>.</p>
  </li>
</ol>

<ol start="4">
  <li>
    <p><a href="/formal/2019/04/16/axi-mistakes.html">The Most Common AXI Mistake</a></p>

    <p>After verifying Xilinx’s AXI-lite and AXI (full) demonstration cores, as
well as Intel’s cores, and after looking over several examples of on-line
cores, it quickly became apparent that the same bug was being replicated
across many designs.  This article discusses that bug, showing how it may
easily be spotted, and how to adjust your design so it doesn’t have that
bug.</p>

    <p>This article had 2,436 page views.
It is currently the #1 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for
<a href="https://duckduckgo.com/?q=axi+mistakes&amp;t=canonical&amp;ia=web">AXI mistakes</a>.</p>
  </li>
</ol>

<ol start="3">
  <li>
    <p><a href="/blog/2019/05/29/demoaxi.html">Building the Perfect AXI4 Slave</a></p>

    <p>It’s not enough to just criticize the IP of others, at some point you need
to generate your own.  This article discusses how to generate an AXI4
slave.  It also introduces my own goal for AXI based designs: 100%
throughput without stalling between requests.  This is better than the
<code class="highlighter-rouge">N+3</code> (burst length plus 3 clocks) performance of <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">Xilinx’s block RAM
controller</a>,
while also offering concurrent read and write performance.</p>

    <p>Since writing this example, I’ve added <a href="https://github.com/ZipCPU/wb2axip">several more of my designs to this
mix</a>–all with the same design goal:
100% throughput across burst boundaries.  I’ll admit, getting the data
movers to meet this standard was a challenge, but all very possible using
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
together with the formal property set mentioned above.</p>

    <p>Sadly, many new FPGA designers want to know how they can build AXI4
components as well.  Having read this article, they’ve often complained
that it is too difficult to understand.  At this point, I’m at a loss:
is my development really that complicated?  Or is the problem the simple
reality that the AXI protocol <em>is</em> a complicated protocol?  Do I blame
Xilinx for choosing AXI, when other protocols such as
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
are so much simpler?  Or should I blame a problem on unreasonable
expectations?</p>

    <p>Let’s face it: AXI is hard.  Building bug-free AXI components is not
something many <em>professionals</em> are good at, much less brand new students
and hobbyists.  This should be well evidenced by AXI bugs listed above, bugs
that I found this year–even in code that had been verified by a professional
“best in class” AXI verification methodology.</p>

    <p>What if I just want an example design I can start from?  Such a design is
provided by the article above.  Enjoy it!</p>

    <p>This article had 3,417 page views.  It is currently the #31 <a href="https://duckduckgo.com">duckduckgo.com</a>
hit for <a href="https://duckduckgo.com/?q=example+axi+slave&amp;t=canonical&amp;ia=videos">Example AXI Slave</a>–behind
many other hits recommending that someone use one of <a href="/formal/2019/05/13/axifull.html">Xilinx’s broken
designs</a>.</p>
  </li>
</ol>

<ul>
  <li>
    <p><a href="/formal/2018/12/28/axilite.html">Using a Formal Property File to Verify an AXI-lite Peripheral</a></p>

    <p>While technically not a 2019 article, my first AXI-lite article deserves an
honorable mention in this list.  This is the article that first pointed out
the bugs in Xilinx’s AXI-lite demonstration core.  It has been placed here
in rank order, where it would fall if it were 2019 article.</p>

    <p>Unfortunately, my page views per year metric of articles written in the
same year doesn’t treat articles written late in the year fairly.  As a
result, this article didn’t score well in the few remaining days of year it
was written, and so <a href="/blog/2019/01/01/top-ten.html">didn’t make the list last
year</a>.  An honorable
mention is therefore all the more appropriate for this article.</p>

    <p>This article had 3,825 page views in 2019.</p>
  </li>
</ul>

<ol start="2">
  <li>
    <p><a href="/formal/2019/01/12/demoaxilite.html">Building a Custom yet Functional AXI-Lite Slave</a></p>

    <p>Holding the number two spot for the year among articles written this year,
is an article on building an AXI-lite slave core.  This follows from the
AXI-lite formal property set article that just received honorable mention,
and discusses how to build (and verify) an AXI-lite core.  This core is
special among many AXI-lite cores in that 1) it’s fully verified, unlike
the other examples out there, and 2) it can achieve 100% throughput on
both read and write channels.</p>

    <p>Unfortunately, the name doesn’t do any justice to the article.  It’s not
a flashy name.  Of course you’d want to build a <em>Custom yet Functional</em>
AXI-lite slave!  Who wouldn’t want to build such?  The name, however, stands
in contrast to Xilinx’s demonstration IP core which was clearly broken.</p>

    <p>Since building this first design, I’ve had to build other AXI-lite designs,
such as those for my data movers discussed above.  Using the skidbuffers
made building these designs so much easier, that I may come back later and
rewrite this article showing how simple a full-featured AXI-lite slave
component can be to write.</p>

    <p>This article had 4,241 page views.  It is currently the #4
<a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=example+axi-lite+slave&amp;t=canonical&amp;ia=web">Example AXI-lite
slave</a>.</p>
  </li>
</ol>

<ol start="1">
  <li>
    <p><a href="/blog/2019/04/27/axi-addr.html">Understanding AXI
Addressing</a></p>

    <p>Finally, in the number one spot, is an article on AXI addressing.  Unlike
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>,
AXI has several extra addressing signals which can be used to capture the
width of a request.  Wires like <code class="highlighter-rouge">AxSIZE</code>, for example, can be used to ensure
that AXI transactions can go through resizing modules without any loss
of information.</p>

    <p>That said, all that extra functionality comes with a cost in terms of
complexity.  This article works its way through the design of a
“next-address” calculator that works across sizes, across unaligned address
requests, fixed, incrementing, or wrapped burst addressing and more.</p>

    <p>This “next-address” calculator has since formed a core part of many of my
subsequent AXI designs.  With little more than the inclusion of <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">this
core</a>, it’s
easy to create a core with “Narrow Burst” support.</p>

    <p>This article had 4,665 page views.
It is currently the #1 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=axi+addressing&amp;t=canonical&amp;ia=web">AXI
Addressing</a>.</p>
  </li>
</ol>

<h2 id="top-articles-viewed-in-2019">Top Articles Viewed in 2019</h2>

<p>Let’s now turn from the most popular articles <em>written</em> in 2019, to the most
popular articles <em>viewed</em> in 2019.</p>

<ul>
  <li>
    <p><a href="/gun-control.html">Why more gun control won’t solve our
problems</a></p>

    <p>This blog is not about Gun Control.  It is about avoiding FPGA Hell through
proper design and verification.  While I have promised a certain number of
articles on Christianity and/or professional ethics, this doesn’t really fit
either category.  However, this particular article needs an honorable
mentions if for no other reason than the number of page views it
has received this year.</p>

    <p>So how does an article on gun-control make its way to a blog on FPGAs?
It started on twitter.  As the conversation on twitter continued, it became
apparent that I would likely struggle to present my case one tweet at a time.
Worse, I found myself in the regrettable position of irritating my FPGA
twitter followers who weren’t interested in a discussion of gun policy.
Therefore, in order to try to make a graceful exit from this situation, I
wrote down my views and evidences into this article back in Feb 19, 2018.</p>

    <p>Because the blog isn’t focused on gun control, I never linked to this article
anywhere but in a single tweet.  Today, this article comes in the
surprising #11 position of all time popular articles viewed in 2019.</p>

    <p>This article had 5,459 page views in 2019.</p>
  </li>
</ul>

<ol start="10">
  <li>
    <p><a href="/blog/2017/06/12/minimizing-luts.html">Minimizing FPGA Resource Utilization</a></p>

    <p>The Spartan 6 LX4 is a <em>small</em> FPGA.  Digilent sold it as part of their
CMod S6 carrier module board.  My goal when purchasing this design was
to see if I could get the ZipCPU to run on this board.  Logic was
tight–there was no room a debug bus.  In spite of all of this,
the ZipCPU demonstrated the ability to run a multi-tasking system.</p>

    <p>This article, coming in at #10, was all about what it took to get the logic
resource usage down low enough that the ZipCPU could successfully fit 
into this design.</p>

    <p>This article had 5,637 page views in 2019.
It is currently the #1 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=minimizing+lut+usage&amp;t=canonical&amp;ia=web">minimizing lut
usage</a>.</p>
  </li>
</ol>

<ol start="9">
  <li>
    <p><a href="/dsp/2017/08/30/cordic.html">Using a CORDIC to calculate sines and cosines in an FPGA</a></p>

    <p>CORDIC’s are common solutions used for generating sines and cosines within
an FPGA.  This particular article discusses the theory and math behind
building one, and getting it to work on an FPGA.</p>

    <p>What’s not said or discussed here is that CORDIC’s are relatively expensive,
in terms of both computation and latency, especially when you want to get a
lot of bits of precision and hardware multiplies are available to you.  As
a result, I may come back to this topic and discuss how to generate a
better, cleaner, sinewave for less logic later.</p>

    <p>For now, this article comes in at #9 for the most page views during 2019.</p>

    <p>This article had 5,705 page views in 2019.
It is currently the #8 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=cordic+example&amp;t=canonical&amp;ia=web">CORDIC
example</a>.
Interesting enough, my <a href="https://github.com/ZipCPU/cordic">CORDIC repository on
Github</a> is listed as the #10 hit.</p>
  </li>
</ol>

<ol start="8">
  <li>
    <p><a href="/dsp/2017/09/15/fastfir.html">Building a high speed Finite Impulse Response (FIR) Digital Filter</a></p>

    <p>One of my earlier series articles was about filtering.  In that article set,
I presented the <a href="/dsp/2017/08/19/simple-filter.html">basics of digital
filtering</a>, and then
some basic filters.  I then showed <a href="/dsp/2017/12/06/fastfir-tb.html">how to verify that these filters
worked</a>
using a <a href="/dsp/2017/11/04/genfil-tb.html">generic test bench
framework</a>
coupled with Verilator.  The framework even went so far as to <a href="/dsp/2017/11/22/fltr-response.html">measure the
expected frequency response of the
filter</a>, so you
could therefore measure both
<a href="https://en.wikipedia.org/wiki/Passband">passband</a>
and <a href="https://en.wikipedia.org/wiki/Stopband">stopband</a>
cutoffs, as well as a
<a href="https://en.wikipedia.org/wiki/Stopband">stopband</a> depth.</p>

    <p>This article was the first in the set of example filter implementations.</p>

    <p>This article had 6,208 page views in 2019.
It is currently the #11 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=verilog+fir+filter&amp;t=canonical&amp;ia=web">Verilog FIR
filter</a>.</p>
  </li>
</ol>

<ol start="7">
  <li>
    <p><a href="/dsp/2017/07/11/simplest-sinewave-generator.html">Simplest Sinewave Generator</a></p>

    <p>How simple can sinewave generation be?  As simple as grabbing the top bit
of the phase input.  Want better than that?  Use a quick table lookup.
At just the cost of one 6-LUT per output bit, you can calculate a sinewave
with +/- 2.5-degree accuracy.</p>

    <p>That’s not bad for something really simple, and the performance is often
good enough as well!</p>

    <p>This article had 6,261 page views in 2019.
It is currently the #11 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=verilog+sinewave&amp;t=canonical&amp;ia=web">Verilog
sinwave</a>.</p>
  </li>
</ol>

<ol start="6">
  <li>
    <p><a href="/dsp/2017/12/14/logic-pll.html">Building a Simple Logic PLL</a></p>

    <p>Digital data transmission requires a clock.  In <a href="/about/gisselquist-technology.html">my own
experience</a>, that
clock is often embedded within the data waveform itself and needs to be
recovered.  A PLL forms one common approach to this recovering such a clock.</p>

    <p>There are a couple of ways to implement a PLL in logic.  The classic method
requires a CORDIC, a multiply, some filtering–and lots of clock ticks.
All this logic comes at a cost impacting the PLLs ability to quickly track
and lock to any incoming clock signal.</p>

    <p>This article discusses a means of creating a PLL in logic but without
the sinewave generator or the multiply.  The result is a simple PLL,
using little more than adds and subtracts, but yet one that is still
very effective at clock tracking.  What the article doesn’t discuss is
the math required to get the tracking coefficients right.  I may yet come
back and explain that in a future article.</p>

    <p>This article had 6,655 page views in 2019.
It is currently the #2 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=verilog+pll&amp;t=canonical&amp;ia=web">Verilog
PLL</a>.</p>
  </li>
</ol>

<ul>
  <li>
    <p><a href="/fpga-hell.html">FPGA Hell</a></p>

    <p>The one article that really pulls all of this site together is the
<a href="/fpga-hell.html">FPGA Hell</a>
article.  I’m listing it here as an honorable mention simply because I
don’t consider it to be one of my blog articles, but rather one of the
articles that the blog and the purpose of it.  That said, it’s still a
favorite and so it has earned it’s place here in my list.</p>

    <p>This “article” had 6,919 page views in 2019.</p>
  </li>
  <li>
    <p><a href="/projects.html">Projects</a></p>

    <p>A second honorable mention goes to my projects page.  This is where I offer
quick descriptions of <a href="https://github.com/ZipCPU">my various github projects</a>,
in case there’s something you might be looking for.</p>

    <p>This “article” had 7,386 page views in 2019.</p>
  </li>
</ul>

<ol start="5">
  <li>
    <p><a href="/blog/2017/06/21/looking-at-verilator.html">Taking a New Look at Verilator</a></p>

    <p>Yes, I enjoy Verilator.  This article discusses why.  In particular, I enjoy
mixing O/S calls with my simulations–allowing me to <a href="/blog/2017/06/17/why-network-debugging.html">simulate serial ports
over TCP/IP</a>,
<a href="/blog/2019/11/14/sdspi.html">SD cards with files and file
systems</a>, and even OLED or
<a href="/blog/2018/11/29/llvga.html">VGA graphics</a>.
Network ports remain on my “to-do” list.</p>

    <p>This article goes over the basics of how to create a simulation using
Verilator, and how you can then debug your design from such a simulation.</p>

    <p>This article had 7,466 page views in 2019.
It is currently the #6 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=verilator&amp;t=canonical&amp;ia=web">Verilator</a>.</p>
  </li>
</ol>

<ol start="4">
  <li>
    <p><a href="/blog/2017/07/29/fifo.html">Getting the basic FIFO right</a></p>

    <p>… and then there’s my FIFO article.  This was written before I started
using formal methods.  Since writing it, I’ve found so many bugs in my
FIFOs–first in the pointers, and then again in the data itself, so I no
longer trust either this article or the implementation within it.  Most
of these bugs surround reads while empty, or writes while full.</p>

    <p>That said, I’m really going to need to come back and rewrite this FIFO
article properly, while also showing how to handle formally verifying
the FIFO.  Such a new article would follow the FIFO development in the
<a href="/tutorial">tutorial</a>, so feel free to check that
lesson out if you want to see how to build a working FIFO in the meantime.</p>

    <p>This article had 11,917 page views in 2019.
It is currently the #8 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=verilog+fifo&amp;t=canonical&amp;ia=web">Verilator
FIFO</a>.</p>
  </li>
</ol>

<ol start="3">
  <li>
    <p><a href="/blog/2018/07/06/afifo.html">Crossing clock domains with an Asynchronous
FIFO</a></p>

    <p>The Asynchronous FIFO article, on the other hand, is much better.  This
FIFO starts with Cliff Cummings’ asynchronous FIFO and then applies formal
methods to it.</p>

    <p>I’ve since had the opportunity to revisit asynchronous FIFOs in order to
create my own implementation–separate and distinct from Cummings’.  Feel
free to check out this newer <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/afifo.v">implementation
here</a> if you
want to take a peek.  In particular, the proof runs a whole lot faster,
and I no longer insist that the write reset be released in a clock
synchronous fashion.  (You’ll still need to meet timing …)</p>

    <p>This article had 12,009 page views in 2019.
It is currently the #8 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=asynchronous+FIFO&amp;t=canonical&amp;ia=web">Asynchronous
FIFO</a>.</p>
  </li>
</ol>

<ol start="2">
  <li>
    <p><a href="/blog/2017/10/20/cdc.html">Some Simple Clock-Domain Crossing Solutions</a></p>

    <p>The basics of crossing clock domains are fairly straightforward, and this
article works through how to handle them.  The article primarily discusses
the basic 2FF synchronizer, but also looks at how that 2FF synchronizer
can be used to create a cross-clock handshake.</p>

    <p>This article had 13,530 page views in 2019.
It is currently the #2 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=clock+domain+crossing&amp;t=canonical&amp;ia=web">Clock Domain
Crossing</a>.</p>
  </li>
</ol>

<ol start="1">
  <li>
    <p><a href="/tutorial/">Verilog, Formal Verification, and Verilato Beginner’s Tutorial</a></p>

    <p>The number one web request across the entire ZipCPU blog during 2019 was for
my Verilog tutorial page.</p>

    <p>I’d like to say of a certainty that this was due to the Verilog tutorial
itself.  Sadly, due to the fact that the tutorial is written as a set of
PDF files, and the fact that Google Analytics doesn’t track PDF viewing
very well, I have no idea whether these web hits are to which lesson, which
lesson might be confusing, or if these are to my formal courseware slides.</p>

    <p>This may mean that I need to restructure this page in the future.</p>

    <p>For now, I’ll let it simply mean that my tutorial page is well loved.</p>

    <p>This page had 22,595 page views in 2019.
It is currently the #16 <a href="https://duckduckgo.com">duckduckgo.com</a> hit for <a href="https://duckduckgo.com/?q=verilog+tutorial&amp;t=canonical&amp;ia=web">Verilog
Tutorial</a>,
and the #1 hit for <a href="https://duckduckgo.com/?q=formal+verification+tutorial&amp;t=canonical&amp;ia=web">Formal Verification
Tutorial</a>.</p>
  </li>
</ol>

<p>The list isn’t quite accurate.  The actual web page receiving more page views
than any other was my <a href="">main index page</a>.  Citing this
page seems like quoting usage statistics for words like “the”–it’s just not
that interesting.</p>

<p>Many thanks to all for making 2019 a wonderful year on the ZipCPU Blog!
<a href="https://www.blueletterbible.org/kjv/num/6/25">May God bless your new year</a>
with a <a href="https://www.blueletterbible.org/kjv/phi/4/7">peace that passes all
understanding</a>.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Behold, we count them happy which endure. Ye have heard of the patience of Job, and have seen the end of the Lord; that the Lord is very pitiful, and of tender mercy.  (James 5:11)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
