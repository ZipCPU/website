<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>The hard part of building a bursting AXI Master</title>
  <meta name="description" content="This article continues our series on building AXI based components.  So far,we’ve discussed what it takes toverify and then build anAXI-lite slave, and thena...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2020/06/16/axiaddr-limits.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">The hard part of building a bursting AXI Master</h1>
    <p class="post-meta"><time datetime="2020-06-16T00:00:00-04:00" itemprop="datePublished">Jun 16, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>This article continues our series on building AXI based components.  So far,
we’ve discussed what it takes to
<a href="/formal/2018/12/28/axilite.html">verify</a> and then <a href="/blog/2019/01/12/demoaxilite.html">build an
AXI-lite slave</a>, and then
an <a href="/blog/2019/05/29/demoaxi.html">AXI (full) slave</a>.  We’ve
examined what it takes to calculate <a href="/blog/2019/04/27/axi-addr.html">the next address within a
burst</a>, and looked at the
<a href="/formal/2019/04/16/axi-mistakes.html">most common AXI
mistakes</a> along the way.
More recently, we discussed <a href="/blog/2020/03/23/wbm2axisp.html">how to build a basic AXI
master</a>–one that could
issue multiple outstanding singleton read or write requests.</p>

<p>What we haven’t discussed is how to build an AXI master that will issue burst
requests.</p>

<p>It’s not easy.</p>

<p>Today, let’s dig into one of the harder challenges involved in building a
bursting AXI master: how to handle setting the various <code class="language-plaintext highlighter-rouge">AxVALID</code>, <code class="language-plaintext highlighter-rouge">AxADDR</code>,
and <code class="language-plaintext highlighter-rouge">AxLEN</code> bus signals.   In particular, the <a href="/doc/axi-spec.pdf">AXI bus
protocol</a> imposes several
constraints on these signals that all need to be met at the same time.  The
challenge is figuring out how to generate bursts, meeting all of these
constraints, without slowing down any transfers.
How then should an AXI bus
<a href="/blog/2020/03/23/wbm2axisp.html">master</a>
be built that can fill the bus with as many requests as possible?</p>

<p>So let’s start by looking at what these constraints are.  I’ll then share
<a href="https://github.com/ZipCPU/wb2axip">several examples of open source AXI masters</a>
that can generate burst requests meeting these constraints, progressing from
simple to more complex examples along the way.  My examples will include a
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">virtual FIFO</a>, a
<a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/memscope.v">memory-backed logic analyzer</a>,
a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivdisplay.v">vide frame buffer reader</a>,
and a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">stream to memory DMA</a>.
Each of these designs solves the multiple constraint problem in a slightly
different way, so they form a useful set of examples to learn from.</p>

<h2 id="axvalid-axlen-and-what-makes-this-difficult">AxVALID, AxLEN, and what makes this difficult</h2>

<p>Let’s start by taking a peek at the logic required when setting <code class="language-plaintext highlighter-rouge">AxLEN</code>, and
then what’s required to set <code class="language-plaintext highlighter-rouge">AxVALID</code>.  Here, I’m using the <code class="language-plaintext highlighter-rouge">Ax</code> prefix to
reference either the <code class="language-plaintext highlighter-rouge">AW</code> (write address) channel or the <code class="language-plaintext highlighter-rouge">AR</code> (read address)
channel interchangeably.  Specifically, there are four challenging requirements
when driving <code class="language-plaintext highlighter-rouge">AxLEN</code>, and then some other requirements when driving <code class="language-plaintext highlighter-rouge">AxVALID</code>.
These requirements also impact the addresses we might choose to send, and so
also the <code class="language-plaintext highlighter-rouge">AxADDR</code> signal.  Getting all of these requirements right, without
impacting the maximum frequency of the design, tends to be one of the most
challenging parts of generating AXI bursts.</p>

<p>So let’s start out by looking over the four requirements of <code class="language-plaintext highlighter-rouge">AxLEN</code>.</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">AxLEN</code> can’t be any larger than one less than your maximum burst size.</p>

    <p>For AXI4, the maximum burst length is 256 beats.  Since <code class="language-plaintext highlighter-rouge">AxLEN</code> is one less
than the requested burst size, that means AxLEN must be no greater than 255.
AXI3 is similar, but with a maximum burst size of 16 beats, so the <code class="language-plaintext highlighter-rouge">AxLEN</code>
signal in AXI3 can be no larger than 15.</p>

    <p>I’ve tried to capture this basic protocol difference using a parameter
containing the log of this maximum burst size, <code class="language-plaintext highlighter-rouge">LGMAXBURST</code>, which will be
set to either <code class="language-plaintext highlighter-rouge">8</code>, for a 255 beat burst, or <code class="language-plaintext highlighter-rouge">4</code>, for a 16 beat burst, or to
any user configurable value less than the protocol maximum.
This allows us to express the maximum burst size as <code class="language-plaintext highlighter-rouge">(1&lt;&lt;LGMAXBURST)</code>, and
the maximum <code class="language-plaintext highlighter-rouge">AxLEN</code> value as <code class="language-plaintext highlighter-rouge">(1&lt;&lt;LGMAXBURST)-1</code>.</p>

    <p>To illustrate these various constraints, let’s build a draft of the logic
necessary to calculate this <code class="language-plaintext highlighter-rouge">AxLEN</code> value, and then update it after each
constraint.  To start out, we’ll obviously like to move as much data as
we can, so our first constraint would be that we want to set the next
<code class="language-plaintext highlighter-rouge">AxLEN</code> value to the size of a full burst.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="n">next_axlen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<ol start="2">
  <li>
    <p>If you want to read or write a burst from or to a fixed address, then the
size of the maximum length burst drops down from 256 beats to 16 beats
for both AXI4 and AXI3.</p>

    <p>This also applies to bursts using WRAP addressing as well, although I
haven’t (yet) found a good use for them–and that includes even after
building a CPU cache.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@*</span>
<span class="k">begin</span>
	<span class="n">next_axlen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fixed_burst</span><span class="p">)</span>
		<span class="n">next_axlen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAX_FIXED_BURST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<table align="center" style="float: left; padding: 20px"><caption>Fig 1. Goals when building an AXI master component</caption><tr><td><img src="/img/axil2axis/throughput-goal.svg" alt="" width="320" /></td></tr></table>

<p>I suppose I could make all of my bursts 16-beats, but I’m also aware that
   several vendor AXI components have a <a href="/blog/2020/03/23/wbm2axisp.html">per-burst overhead of a couple of clock
   cycles</a>.
   My goal when building any bus component is throughput, and so that requires
   minimizing any overhead.  That then means that I’ll need to use
   256-beat bursts when writing
   to incrementing (subsequent) addresses, and 16-beat bursts when writing
   to fixed (identical) addresses.  This forces the <code class="language-plaintext highlighter-rouge">if</code> statement above.</p>

<ol start="3">
  <li>
    <p>It’s illegal in AXI to cross 4kB boundaries.</p>

    <p>This comes directliy from the <a href="/doc/axi-spec.pdf">AXI4
specification</a>.  While I’m not quite
certain why this is, my guess is that it’s to guarantee that bursts will not
cross either MMU page or device boundaries.  This certainly simplifies the
design of any
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
since it prevents the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
from needing to check whether or not a particular burst
needs to be split when crossing device boundaries.</p>

    <p>Either way, this requirement is going to mean that we’re going to need
to limit our <code class="language-plaintext highlighter-rouge">AxLEN</code> field again.  This time it will need to be limited
such that <code class="language-plaintext highlighter-rouge">AxADDR[11:ADDRLSB] + (AxLEN +1) &lt; 4kB</code></p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// ADDRLSB captures the the word size of the bus in relevant address bits</span>
<span class="k">localparam</span>	<span class="n">ADDRLSB</span> <span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">);</span>

<span class="k">always</span> <span class="o">@</span>
<span class="k">begin</span>
	<span class="n">next_axlen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fixed_burst</span><span class="p">)</span>
		<span class="n">next_axlen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAX_FIXED_BURST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_address</span><span class="p">[</span><span class="mi">11</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]</span> <span class="o">+</span> <span class="n">next_axlen</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="n">ADDRLSB</span><span class="p">)))</span>
		<span class="n">next_axlen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="n">ADDRLSB</span><span class="p">))</span><span class="o">-</span><span class="n">next_address</span><span class="p">[</span><span class="mi">11</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">];</span>
<span class="k">end</span></code></pre></figure>

<table align="center" style="float: right"><caption>Fig 2. Aligned addressing</caption><tr><td><img src="/img/axiaddr-limits/wbs2mm.svg" alt="" width="480" /></td></tr></table>

<p>At this point, we might be done if all bursts were to be multiples of the
   maximum burst size.</p>

<p>Sorry, but no.  That’s not good enough.  While that might work for the
   <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">virtual FIFO</a>,
   that strategy won’t work for the more common (arbitrary)
   <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">DMA case</a>.</p>

<ol start="4">
  <li>
    <p>You don’t want to request to transfer more memory than the total amount
you want to transfer.</p>

    <p>Yes, this sounds obvious.  It is just about as obvious as it sounds too.
However obvious it might be, though, we’ll still need to pay the logic
required check this.</p>

    <p>Basically, in many data moving application–to include two of our later
examples, the amount of memory that needs to be transferred is chosen
by the user at run-time.  That means you are going to need a counter
that counts down as each burst is requested, so you can always know how
much data you have left to send.  Then, using this counter, you can ask
whether or not your burst length is less than the maximum burst length,
and if so you would then only transmit what’s remaining.  That is,
if you have <code class="language-plaintext highlighter-rouge">LEN</code> words remaining in your transfer, you don’t want to
transfer more than those <code class="language-plaintext highlighter-rouge">LEN</code> words.</p>

    <p>We’ll use <code class="language-plaintext highlighter-rouge">remaining_transfer_length</code> as our value below.  Further, for
a full featured data mover, checking this value requires a comparison
across as many bits as you are using to represent LEN.  Since I tend to
be a perfectionist, that can be a 32-bit comparison.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span>
<span class="k">begin</span>
	<span class="n">next_axlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fixed_burst</span><span class="p">)</span>
		<span class="n">next_axlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAX_FIXED_BURST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_address</span><span class="p">[</span><span class="mi">11</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]</span> <span class="o">+</span> <span class="n">next_axlen</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="n">ADDRLSB</span><span class="p">)))</span>
		<span class="n">next_axlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">12</span><span class="o">-</span><span class="n">ADDRLSB</span><span class="p">))</span><span class="o">-</span><span class="n">next_address</span><span class="p">[</span><span class="mi">11</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_axlen</span> <span class="o">&gt;=</span> <span class="n">remaining_transfer_length</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">next_axlen</span> <span class="o">=</span> <span class="n">remaining_transfer_length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>That’s our four criteria.</p>

<p>Now let’s add to this mess my rule of thumb that any 32-bit operation takes
one clock cycle.  That means that calculating the next <code class="language-plaintext highlighter-rouge">AxLEN</code> value alone
is going to require two clock cycles.</p>

<table align="center" style="float: none"><caption>Fig 3. Clock Cycles</caption><tr><td><img src="/img/axiaddr-limits/double-op.svg" alt="" width="560" /></td></tr></table>

<p>This is still unacceptable.</p>

<p>We have a second and similar problem with <code class="language-plaintext highlighter-rouge">AxVALID</code>, although it’s not nearly
quite as bad.  The problem with AxVALID is that you don’t want to set <code class="language-plaintext highlighter-rouge">AxVALID</code>
unless you have <code class="language-plaintext highlighter-rouge">next_axlen+1</code> data items available to be sent, in the case of
writing, or <code class="language-plaintext highlighter-rouge">next_axlen+1</code> spaces available in your FIFO if you are reading.
Sure, the AXI bus allows you to stall the bus in both directions if the data
isn’t quite ready yet, but do you really want to slow the rest of your design
down by this component?  Indeed, the rule of thumb here should be that once a
burst has been requested then either <code class="language-plaintext highlighter-rouge">WVALID</code>, for writes, or <code class="language-plaintext highlighter-rouge">RREADY</code> for
reads, such remain asserted until all of the beats of the burst transfer are
complete.</p>

<p>So let’s build up some generic logic for starting a burst.  We’ll call this
<code class="language-plaintext highlighter-rouge">start_transaction</code> here, and we’ll make it combinatorial–since many things
might depend upon it.  So, in general, we’ll start a burst as soon as we
either have data or space available for the transfer.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">start_transaction</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_or_space_available</span> <span class="o">&gt;</span> <span class="n">next_axlen</span><span class="p">);</span></code></pre></figure>

<p>We’re going to need ot be careful not to start a new transaction while the
last transaction request remains outstanding and stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_AWREADY</span><span class="p">)</span>
		<span class="n">start_transaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Moreover, we don’t want to start a transaction while a burst write is in
process.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WLAST</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_WREADY</span><span class="p">))</span>
		<span class="n">start_transaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>This will also align the write address and write data channels.  While this
isn’t specifically required by the <a href="/doc/axi-spec.pdf">AXI
specification</a>, it simplifies the masters:
This way, you can go about generating the AXI length once, and use it for both
channels without requiring a FIFO in between them to keep their lengths
synchronized.  Be aware, though, that AXI doesn’t require this in general, so
while this is a nice place to start when generating bursts, it’s not something
you can depend upon <a href="/blog/2019/05/29/demoaxi.html">in a slave when processing
them</a>.</p>

<p>Let’s add in two other basic criteria as well.  For example, you want to be
able to <a href="/blog/2020/03/14/axi-reset.html">abort any transfer on a soft reset, such as might be caused by an
error or external user reset
request</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">soft_reset</span><span class="p">)</span>
		<span class="n">start_transaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>You also want to be able to guarantee that you won’t start an operation until
the user has requested it.  We’ll use an <code class="language-plaintext highlighter-rouge">r_busy</code> here to indicate that the AXI
master is in it’s “transfer data” state.  This yields another start condition.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
		<span class="n">start_transaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>If we’re not careful, all of this logic will eat into our timing slack, slowing
down our over all data transfer rate.  The worst offender in this chain is
the check for whether or not the data (or space) available is greater than
the amount we want to transfer.  Worse, it depends upon knowing the amount
of data to be transferred, so this test can’t take place until we’ve finished
the two clocks above.  That might slow our burst-to-burst issue time down
from two clocks to three clocks.</p>

<p>Again, unacceptable.</p>

<p>If the goal is to be able to achieve 100% bus throughput, then we’re going to
have to figure out a way to do better.</p>

<h2 id="simplifying-the-problen">Simplifying the problen</h2>

<p>Looking at these criteria, I wasn’t ready to settle for a three clock delay
when building my AXI masters.  So, I looked around to see if the problem
could be simplified first.  Sure enough, there are plenty of simplifications
available to you.</p>

<h3 id="axi-lite-bursts">AXI-Lite bursts</h3>

<p>The easy way to handle this whole problem would be to use a burst length of 1.
In this case, the logic would get <em>really</em> simple.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// Always do singleton bursts</span>
	<span class="n">next_axlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="c1">// Every burst advances the address by one word</span>
	<span class="n">next_axaddr</span> <span class="o">=</span> <span class="n">axaddr</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ADDRLSB</span><span class="p">);</span>
	<span class="c1">//</span>
	<span class="c1">// Word-align all subsequent burst addresses</span>
	<span class="n">next_axaddr</span><span class="p">[</span><span class="n">ADDRLSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="c1">// Start a transaction as soon as space is available</span>
	<span class="n">start_transaction</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_or_space_available</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">axvalid</span> <span class="o">?</span> <span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
	<span class="c1">//</span>
	<span class="c1">// We'll still need to check other start transaction checks though</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_AWREADY</span><span class="p">)</span>
		<span class="n">start_transaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_WREADY</span><span class="p">)</span>
		<span class="n">start_transaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">soft_reset</span> <span class="o">||</span> <span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
		<span class="n">start_transaction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>If you are going straight into a MIG generated memory controller, this would
be good enough.  If you have to go into an ARM, an AXI
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> or <a href="/blog/2020/03/23/wbm2axisp.html">Xilinx’s AXI
block RAM controller</a>,
on the other hand, this might cripple any throughput you might’ve otherwise had.
<a href="/blog/2019/05/29/demoaxi.html">The AXI slave controller we built on this
blog</a>,
as well as <a href="/blog/2019/07/17/crossbar.html">my own crossbar</a>
would be fine both ways.</p>

<p>I’ll admit, sometimes I wonder why the designers of AXI didn’t just leave
everything that simple.  It would’ve made the bus so much easier to work
with.  Indeed, under conditions like this I was able to generate and verify
the stream to Wishbone master I mentioned above in just a half a day.  It was
that easy.</p>

<p>Alas, AXI is not so simple, so let’s look at some other ways to simplify this
problem.</p>

<h3 id="burst-alignment">Burst Alignment</h3>

<p>One suggestion I came across early on was to align every burst to the size of
the maximum burst.  If we did that, then the first burst would need an alignment
check, but nothing following would need to check for crossing any boundaries.</p>

<p>Now, for example, the first bursts length computation would look like …</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fixed_burst</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">initial_axlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAX_FIXED_BURST</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="n">initial_axlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">initial_address</span><span class="p">[</span><span class="n">ADDRLSB</span> <span class="o">+:</span> <span class="n">LGMAXBURST</span><span class="p">]</span> <span class="o">+</span> <span class="n">initial_axlen</span>
				<span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">))</span>
			<span class="n">initial_axlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">LGMAXBURST</span><span class="o">-</span><span class="n">ADDRLSB</span><span class="p">))</span>
				<span class="o">-</span> <span class="n">initial_address</span><span class="p">[</span><span class="n">LGMAXBURST</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">initial_axlen</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">transfer_length</span><span class="p">)</span>
		<span class="n">initial_axlen</span> <span class="o">=</span> <span class="n">transfer_length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>That gets us down to three constraints–down from four.  Wait, though, it gets
better.  On subsequent bursts, we can now set axlen based upon the remaining
transfer size alone.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fixed_burst</span><span class="p">)</span>
		<span class="n">next_axlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAX_FIXED_BURST</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">next_axlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next_axlen</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">remaining_transfer_length</span><span class="p">)</span>
		<span class="n">next_axlen</span> <span class="o">=</span> <span class="n">remaining_transfer_length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>Even though the initial length will still take two cycles, the subsequent
length calculation might now just fit within a single clock cycle.</p>

<h3 id="hiding-computations">Hiding Computations</h3>

<p>Let’s take a step back for a moment though.  Our goal is to be able to maintain
100% throughput across our bus.  That means that we should be able to transfer
one beat of information, whether <code class="language-plaintext highlighter-rouge">WVALID &amp;&amp; WREADY</code> or <code class="language-plaintext highlighter-rouge">RVALID &amp;&amp; RREADY</code>, on
every clock cycle.  Our goal is also to issue bus requests as soon
as we either have the data available for any write requests, or alternatively
as soon as we have the space available for any read requests.  If our burst
length is going to be anything more than 2 beats, does it really matter if we
take a clock or two to calculate these values as long as they are calculated
and issued early enough so as not to impact performace?</p>

<p>Let’s therefore take one clock cycle to start the transaction, and then a
second clock cycle between any two <code class="language-plaintext highlighter-rouge">AxVALID</code> signals to do our work above.</p>

<p>Fig. 4 below shows what this might look like for a write process.</p>

<table align="center" style="float: none"><caption>Fig 4. Hiding write address calculations</caption><tr><td><img src="/img/axiaddr-limits/write-recycle.svg" alt="" width="560" /></td></tr></table>

<p>The burst would start by setting both <code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code> at the same time.
The core could then take one clock cycle to be able to regenerate the next
<code class="language-plaintext highlighter-rouge">AWVALID</code>.  However, we wouldn’t set it until after sending <code class="language-plaintext highlighter-rouge">WLAST</code>.  Therefore,
as long as the burst is longer than two beats, we won’t suffer any loss.
I’ve tried to show this by making the <code class="language-plaintext highlighter-rouge">AWVALID</code> signal in Fig. 4 an unknown,
just to mark that it could go high early, but the fact is that it isn’t an
unknown: it’s zero until the last beat is sent.  There’s also the less likely
possibility of needing to send a burst that’s just one beat away from
a 256-beat boundary, but that’s a rare case and even then we’d only lose one
clock cycle in this setup.</p>

<p>Reads are similar, but having the primary difference that read requests are
not synchronized with the read data.  If we can keep our processing down to
every other clock cycle, then we should be able to issue multiple read requests
before the first result is ever returned.  Further, after issuing some (user
design dependent) number of read requests, we’d have to pause anyway to wait for
uncommitted space available for more read returns.</p>

<table align="center" style="float: none"><caption>Fig 5. Hiding read address calculations</caption><tr><td><img src="/img/axiaddr-limits/write-recycle.svg" alt="" width="560" /></td></tr></table>

<p>As with the writes, however, the ultimate bus slave can only operate at some
point on one beat at a time.  Therefore, this will also only cost us a delay
if the burst is less than two beats.</p>

<p>That could buy us some time.</p>

<p>What would happen, though, if the slave didn’t accept our <code class="language-plaintext highlighter-rouge">AxVALID</code> signal
immediately?  The answer is that it could impact our throughput if we waited
for the burst to be accepted before calculating the next burst’s parameters.</p>

<p>This is why I started using <code class="language-plaintext highlighter-rouge">phantom</code> signals as I called them.  You’ll see
them throughout <a href="https://github.com/ZipCPU/wb2axip">all of my AXI bursting
master</a> designs–all named something
like <code class="language-plaintext highlighter-rouge">phantom_read</code>, <code class="language-plaintext highlighter-rouge">phantom_write</code>, or perhaps even <code class="language-plaintext highlighter-rouge">phantom_start</code>.  The
idea is that all of our burst calculation logic can take place when the
<code class="language-plaintext highlighter-rouge">phantom</code> signal is true.  We can then hide this logic inside any potential
stall signals.</p>

<table align="center" style="float: none"><caption>Fig 6. "Phantom" start signals</caption><tr><td><img src="/img/axiaddr-limits/phantom-starts.svg" alt="" width="560" /></td></tr></table>

<p>Let’s walk through how this might work.</p>

<ol>
  <li>
    <p>First, we’d have our <code class="language-plaintext highlighter-rouge">start_transaction</code> signal–whatever it is.  This
is a combinatorial signal, and simply tells us that it’s time to start a
new burst.</p>
  </li>
  <li>
    <p>Then, on the next cycle, <code class="language-plaintext highlighter-rouge">AxVALID</code> would be high–indicating a registered
transaction start.  On this same cycle, the <code class="language-plaintext highlighter-rouge">phantom_write</code> or <code class="language-plaintext highlighter-rouge">phantom_read</code>
signal would also be high–but only for one cycle only.  This would be a
signal internal to the design that registered values (not the actual AXI
protocol signals) can be adjusted as though the burst request had actually
taken place.</p>
  </li>
  <li>
    <p>On the third cycle, the <code class="language-plaintext highlighter-rouge">phantom</code> signal would be low again–even though
<code class="language-plaintext highlighter-rouge">AxVALID</code> might stay high until the channel was no longer stalled.  This
is the clock we’ll take to recycle our addressing.  It’s also the first
cycle where the <code class="language-plaintext highlighter-rouge">start_transaction</code> combinatorial signal might be high
again.</p>

    <p>This is partially what’s being shown in Fig. 6 above.  The <code class="language-plaintext highlighter-rouge">phantom_read</code>
signal is only high for one clock tick, but on the first clock of any new
read request cycle.  That way, if it takes a couple cycles for the
read to be acknowledged, we’ll be ready for the next cycle at that time.</p>
  </li>
  <li>
    <p>Once the <code class="language-plaintext highlighter-rouge">AxVALID &amp;&amp; AxREADY</code> indicates a request has been accepted, we
then can set <code class="language-plaintext highlighter-rouge">start_transaction</code> on the next cycle and the
process repeats until the transfer is complete.</p>
  </li>
</ol>

<p>I’ve found this <code class="language-plaintext highlighter-rouge">phantom</code> starting signal to be quite useful.  It decouples the
<code class="language-plaintext highlighter-rouge">AxLEN</code> constraint logic from needing to wait on <code class="language-plaintext highlighter-rouge">AxREADY</code>.  Better yet, it
allows us to issue burst requests as fast as one burst request every other
clock cycle–even when we are requesting full length bursts.</p>

<p>That’s useful.</p>

<h3 id="space-available">Space available</h3>

<p>There’s also another criteria we haven’t discussed yet, and we’ll only
touch on it below, and that is that you don’t want to start a transaction
until you know you can finish it.  For writes, this means you don’t want
to start the transaction until you have the data available somewhere–likely
in a local FIFO.  For reads, you don’t want to issue the read request until
there’s somewhere for the returned data to go.</p>

<p>In general, this means you need to keep track of a counter of either the data
available to be written, or the space available to be read into.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// For writes, the amount of data available in the FIFO which can be</span>
	<span class="c1">// sent across the interface</span>
	<span class="k">assign</span>	<span class="n">data_available</span> <span class="o">=</span> <span class="n">fifo_fill</span><span class="p">;</span>

	<span class="c1">// For reads, the amount of empty space available in the FIFO which</span>
	<span class="c1">// can be filled with a subsequent read.</span>
	<span class="k">assign</span>	<span class="n">space_available</span> <span class="o">=</span> <span class="n">FIFO_SIZE</span> <span class="o">-</span> <span class="n">fifo_fill</span><span class="p">;</span></code></pre></figure>

<p>Only … it’s not quite so simple.  In particular, after issuing a burst
request, even if nothing else in the FIFO changes, the amount of data (or space)
available changes just due to the fact that we’ve requested the transfer.</p>

<p>That leads to something closer to the following (for writes).</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="n">data_available</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span> <span class="n">fifo_write</span><span class="p">,</span> <span class="n">phantom_write</span> <span class="o">}</span><span class="p">)</span>
<span class="mb">2'b00</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
<span class="mb">2'b10</span><span class="o">:</span> <span class="n">data_available</span> <span class="o">&lt;=</span> <span class="n">data_available</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="mb">2'b01</span><span class="o">:</span> <span class="n">data_available</span> <span class="o">&lt;=</span> <span class="n">data_available</span> <span class="o">-</span> <span class="n">AWLEN</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="mb">2'b11</span><span class="o">:</span> <span class="n">data_available</span> <span class="o">&lt;=</span> <span class="n">data_available</span> <span class="o">-</span> <span class="n">AWLEN</span><span class="p">;</span>
<span class="k">endcase</span></code></pre></figure>

<table align="center" style="float: right"><caption>Fig 7. Data Available</caption><tr><td><img src="/img/axiaddr-limits/data-available.svg" alt="" width="360" /></td></tr></table>

<p>Data then enters the FIFO any time <code class="language-plaintext highlighter-rouge">fifo_write</code> is true.  Once enough data
has accumulated to form a burst write request, the <code class="language-plaintext highlighter-rouge">data_available</code> counter
is dropped by the length of that request–even before the data is read out of
the FIFO.  That way we make certain we aren’t requesting writes based upon
data that’s already been committed to a prior write.  Indeed, I’ll often
add the assertion to my design that,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span><span class="p">)</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">fifo_fill</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>just to make certain that I never request a data transfer for data that isn’t
present.</p>

<p>You might think of this like a chemical production factory, as depicted in
Fig. 7.  As new product
is created, it gets placed into a giant tank.  As that product gets sold, the
amount of product remaining in the tank that hasn’t yet been sold is the
amount that’s available to be sold to the next customer.  Hence, even if the
tank is full, there might not be a full tank’s worth of product available
to be sold.  The amount available for sale, or in this case transfer, is
what we keep track of.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 8. Uncommitted Space Available</caption><tr><td><img src="/img/axiaddr-limits/space-available.svg" alt="" width="360" /></td></tr></table>

<p>A similar structure would work nicely for reads, as illustrated in Fig. 8.  The
difference is that you’d be counting uncommitted <em>empty</em> space.  That count
would start with the full FIFO’s size as space available, and would then be
decremented on any <code class="language-plaintext highlighter-rouge">phantom_read</code> signal.  Once the data was (later) read
out of the FIFO, you could return it to the count of uncommitted space
available.</p>

<p>This counter would be analogous to something like a coal bin at a power
plant.  One of the responsibilities of the staff at the power plant is to
make certain that it never runs out of coal while in operation.  They will
therefore purchase train loads of coal to fill up the coal bin.  It costs
money, however, for the
train to have to wait in order to unload.  Therefore, you wouldn’t request a
new trainload of coal until there’s room in the coal bin for not only the
new trainload, but also for all other trains to empty in the bin that may have
been previously ordered but not (yet) arrived.  That’s the idea behind the
“space available” calculation used with reads.</p>

<p>The <code class="language-plaintext highlighter-rouge">phantom</code> signals also allows us to hide the calculation of the amount
of data (or space) available, similar to the way we handled our other
calculations.  That way if <code class="language-plaintext highlighter-rouge">AxVALID</code> is ever stalled, even by one clock
cycle, we’ll have this answer ready to request the next burst as soon as
it’s no longer stalled.</p>

<p>With a little help, we can also register whether two or more full bursts of
data are present in this counter as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">new_data_available</span> <span class="o">=</span> <span class="n">data_available</span><span class="p">;</span>
	<span class="k">case</span><span class="p">(</span><span class="o">{</span> <span class="n">fifo_write</span><span class="p">,</span> <span class="n">phantom_write</span> <span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b00</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="n">new_data_available</span> <span class="o">=</span> <span class="n">data_available</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="n">new_data_available</span> <span class="o">=</span> <span class="n">data_available</span> <span class="o">-</span> <span class="n">AWLEN</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="mb">2'b11</span><span class="o">:</span> <span class="n">new_data_available</span> <span class="o">=</span> <span class="n">data_available</span> <span class="o">-</span> <span class="n">AWLEN</span><span class="p">;</span>
	<span class="k">endcase</span>
<span class="k">end</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="n">data_available</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">multiple_bursts_available</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
	<span class="n">data_available</span> <span class="o">&lt;=</span> <span class="n">new_data_available</span><span class="p">;</span>
	<span class="n">multiple_bursts_available</span> <span class="o">&lt;=</span> <span class="o">|</span><span class="n">new_data_available</span><span class="p">[</span><span class="n">LGFIFO</span><span class="o">:</span><span class="n">LGMAXBURST</span><span class="p">];</span>
<span class="k">end</span></code></pre></figure>

<p>While not all of my examples below use this <code class="language-plaintext highlighter-rouge">multiple_bursts_available</code>
signal, it can be useful if the FIFO “size” is much larger than the maximum
burst size.  In that case, a 32-bit comparison might be reduced to 9-bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">start_transaction</span> <span class="o">=</span> <span class="p">(</span><span class="n">multiple_bursts_available</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">data_available</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">next_awlen</span><span class="p">);</span></code></pre></figure>

<p>With those preliminaries out of the way, let’s take a look at several example
designs to see how these problems might be either solved or at least mitigated.</p>

<h2 id="example-vfifo">Example: VFIFO</h2>

<table align="center" style="float: right"><caption>Fig 9. A Virtual FIFO</caption><tr><td><img src="/img/axiaddr-limits/axivfifo.svg" alt="" width="360" /></td></tr></table>

<p>Our first example is that of a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">virtual
FIFO</a>.  You might
also call this a “memory backed FIFO”.  The idea is that it implements all
of the capability of a basic FIFO, but also that it uses an external memory
in case the block RAM available in your FPGA isn’t sufficient for the task
at hand.  Indeed, if all you need from your SDRAM is a FIFO, and you don’t
care (that much) about the latency, then
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">this</a>
might be the perfect capability for your application.</p>

<p>The cool thing about the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">virtual FIFO</a>
is that the problem definition solves most of our AXI burst logic generation
problems for us.  For example,
because there’s no limit to the amount of data you might wish to transfer,
we don’t have to check for the maximum data amount anymore.  Better yet, we
can keep all bursts at the same (power-of-two) length, which then means that
our addresses will always be aligned and we don’t need to check 4kB boundaries
at all.</p>

<p>Let’s take a look at how this might work.  We’ll examine the write path alone
below, just for simplicity, although the read path is quite similar.</p>

<p>The first step is to determe when we are ready to write a burst of data to
memory.  This is the combinatorial flag, called <code class="language-plaintext highlighter-rouge">start_write</code> in this design,
that takes place before the <code class="language-plaintext highlighter-rouge">phantom</code> signal–the same signal we called
<code class="language-plaintext highlighter-rouge">start_transaction</code> above.</p>

<p>We’ll start any write as soon as we have enough data in our incoming FIFO to
fill up a burst.  Note here that even if our FIFO can hold <code class="language-plaintext highlighter-rouge">(1&lt;&lt;LGFIFO)</code>
elements, this comparison only requires <code class="language-plaintext highlighter-rouge">LGFIFO-LGMAXBURST</code> bits.  It’s
a nifty trick you can often get away with, but you’ll have to be aware
of the difference between <code class="language-plaintext highlighter-rouge">&gt;</code> and <code class="language-plaintext highlighter-rouge">&gt;=</code> to do it.  (Using <code class="language-plaintext highlighter-rouge">&gt;</code> would’ve created
an <code class="language-plaintext highlighter-rouge">LGFIFO</code> bit comparison, not an <code class="language-plaintext highlighter-rouge">LGFIFO-LGMAXBURST</code> bit comparison.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">start_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ififo_fill</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">))</span>
			<span class="n">start_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>However, we can’t start writing if the entire FIFO–equivalent to the
size of the external SDRAM–is full.  Yes, that would take a <em>lot</em> of data to
fill up most DRAMs–you’ll need
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
to catch any problems here.  Likewise, we don’t want to start writing if we
are still in the middle of a
<a href="/blog/2020/03/14/axi-reset.html">soft reset</a>.
(A <a href="/blog/2020/03/14/axi-reset.html">soft reset</a>
is where we reset the core without resetting the bus.)  Similarly, we won’t
start any new burst on that same cycle where we’ve just issued a new
request–to give us a clock for the <code class="language-plaintext highlighter-rouge">space_available</code> counter to adjust.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">vfifo_full</span> <span class="o">||</span> <span class="n">soft_reset</span> <span class="o">||</span> <span class="n">phantom_write</span><span class="p">)</span>
			<span class="n">start_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Further, if there’s no external/SDRAM memory space available for
us to put this burst into, then we’ll just have to wait and start again
once data is available.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">mem_space_available_w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">start_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>How is this different from the <code class="language-plaintext highlighter-rouge">vfifo_full</code> flag above?  As I’ve currently
defined the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">virtual FIFO</a>,
it only has much space available as there is memory space.  Practically, it
also has space for the two FIFO’s as well, but since I’m counting them
separately I need to check for them separately here as well.</p>

<p>Next, this <code class="language-plaintext highlighter-rouge">mem_space_available_w</code> flag represents whether or not there’s a
full burst’s worth of space available in the 
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">FIFO</a>’s
memory or not.  It’s not counting beats, but rather bursts.  That way we
can check 20-bits of a memories address space instead of 32–assuming a
4GB memory (32-bit address), 256-beat bursts (8-bits of address), and a
128-bit wide memory bus (4-bits of address).</p>

<p>Coming back to the problem at hand, we don’t want to issue a new write command
while the last one is either still in progress or stalled while being issued.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WREADY</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_WLAST</span><span class="p">))</span>
			<span class="n">start_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_AWREADY</span><span class="p">)</span>
			<span class="n">start_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>I think I mentioned above that I like aligning my write address channel
request with the first data word of the first data beat.  While the AXI bus
protocol doesn’t require this, it simplifies the formal property check and so I
require it of my designs.</p>

<p>Finally, this particular core will stop all transactions on any downstream
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
Errors like these should never happen and are usually an
indication that you don’t (yet) have your memory space set up properly.
Given that I’ve been burned before by writing to a peripheral when I thought
I was writing to memory, I’m careful to avoid this possibility if possible.
(My flash memory has never been the same since …)  Hence,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">the FIFO</a>
comes to a hard stop following any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">o_err</span><span class="p">)</span>
			<span class="n">start_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Address adjustments are fairly easy as well.  On a reset, the address gets
set to zero.  On a
<a href="/blog/2020/03/14/axi-reset.html">soft reset</a>,
it only gets set to zero if there’s no
outstanding (stalled) request.  In all other cases, we just add one burst
length (times the bus address width) to the address every time a burst has
been accepted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_awaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span>
			<span class="n">axi_awaddr</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">LGMAXBURST</span><span class="o">+</span><span class="n">ADDRLSB</span><span class="p">]</span>
			<span class="o">&lt;=</span> <span class="n">axi_awaddr</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">LGMAXBURST</span><span class="o">+</span><span class="n">ADDRLSB</span><span class="p">]</span> <span class="o">+</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">M_AXI_AWVALID</span> <span class="o">||</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">soft_reset</span><span class="p">)</span>
			<span class="n">axi_awaddr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">axi_awaddr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Well, there is one trick here.  Specifically, since I know that every burst must
be aligned, I’m going to make certain that all of the lower address bits remain
zero on every clock cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">axi_awaddr</span><span class="p">[</span><span class="n">LGMAXBURST</span><span class="o">+</span><span class="n">ADDRLSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>This has two purposes.  First, it simplifies the synthesis optimization pass
by making it crystal clear what I want–these lower bits will <em>always</em> be zero.
Second, it keeps me from needing to write an assertion that these bits will be
zero–since they’ll be set back to zero on every clock cycle.</p>

<p>The final step is to set the write address length to the size of one burst.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">M_AXI_AWLEN</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LGMAXBURST</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>To see how this works, let’s take a peek at a nominal trace, shown in Fig. 10.
This is a shortened trace for demonstration purposes only.  Specifically, the
burst length has been shortened to 4-beats, whereas it would normally be
256-beats per burst for better performance.</p>

<table align="center" style="float: none"><caption>Fig 10. Approximate virtual FIFO trace</caption><tr><td><img src="/img/axiaddr-limits/vfifo-trace.svg" alt="" width="780" /></td></tr></table>

<p>Here in this figure you can see incoming data coming into the FIFO.  Once a
full burst has arrived, the <code class="language-plaintext highlighter-rouge">start_write</code> flag is raised.  This starts the
cycle whereby this burst gets written to the external RAM.  Once the
<code class="language-plaintext highlighter-rouge">BVALID</code> acknowledgment is returned, there’s then memory available to be read
so the <code class="language-plaintext highlighter-rouge">start_read</code> flag gets set and a read transaction begins.  Further read
transactions are then triggered every time there’s sufficient data in memory
to trigger them.  The data is read into an outgoing FIFO, and then delivered to
any follow on AXI stream component from there.</p>

<h2 id="example-wbscope">Example: WBSCOPE</h2>

<table align="center" style="float: right"><caption>Fig 11. A memory backed logic analyzer</caption><tr><td><img src="/img/axiaddr-limits/memscope.svg" alt="" width="360" /></td></tr></table>

<p>One <a href="/blog/2017/06/02/design-process.html">common debugging component used during FPGA
development</a> is an
<a href="/blog/2017/06/08/simple-scope.html">internal logic analyzer</a>
of some type.  Such an analyzer records data until
some number of clocks following a trigger (defined externally), and then stops.
This allows you to see what lead up to an event, or alternatively what happened
after some event.</p>

<p>I like to use my own <a href="https://github.com/ZipCPU/wbscope">Wishbone Scope</a>
for this purpose.  I’ve even got an <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v">AXI4-lite version of the same
scope</a>–just not (yet) an AXI4-lite version of the <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v">compressed
scope</a>.  In this
discussion, though, I’d like to discuss the idea of a similar
<a href="/blog/2017/06/08/simple-scope.html">scope</a>,
with a nearly identical user interface, but using AXI to be able to save
the memory contents in an external (SD)RAM of some type.</p>

<p>I call this a <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/memscope.v">MEMSCOPE</a>–for lack of a better name.
Fig. 11 above sort of shows the conceptual idea behind it.</p>

<p>I bring it up here because it’s just a little more complicated than the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">Virtual
FIFO</a>–not
by much though.  Much like the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">Virtual
FIFO</a>,
everything about the
<a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/memscope.v">MEMSCOPE</a>
is aligned–up until the last burst, which might need to terminate
early.  Unlike the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">Virtual
FIFO</a>,
we don’t need to check if there’s  space available in the memory–the
<a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/memscope.v">MEMSCOPE</a>
just perpetually overwrites memory until it is told to stop.</p>

<p>Let’s take a peek at how this works.</p>

<p>We’ll start with the combinatorial <code class="language-plaintext highlighter-rouge">start_transaction</code> signal, herein called
the <code class="language-plaintext highlighter-rouge">w_phantom_start</code> signal.</p>

<p>As before, we only want to start if there’s data available in our local
FIFO storage.  Unlike before, we also have to check whether or not the
<a href="/blog/2017/06/08/simple-scope.html">scope</a>
has stopped recording and there is (potentially) a partial burst left
to be written.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// We start again if there's more information to transfer</span>
		<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_available</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">))</span>
				<span class="o">||</span><span class="p">(</span><span class="n">s_stopped</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">data_available</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_WVALID</span><span class="p">);</span></code></pre></figure>

<p>Of course, we can’t start a new burst if the write address channel is still
stalled with the last burst.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// If the address channel is stalled, then we can't issue any</span>
		<span class="c1">// new requests</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_AWREADY</span><span class="p">)</span>
			<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Neither do we want to issue a new burst request if the data from the last
burst hasn’t (yet) finished writing to memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// If we're still writing the last burst, then don't start</span>
		<span class="c1">// any new ones</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WLAST</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_WREADY</span><span class="p">))</span>
			<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>During a
<a href="/blog/2020/03/14/axi-reset.html">soft reset</a>,
one where we reset this core without resetting the bus,
or likewise after
<a href="/blog/2017/06/08/simple-scope.html">the scope</a>
has stopped collecting data, we’ll want to avoid
writing anything more to the external RAM.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">scope_reset</span> <span class="o">||</span> <span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
			<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Finally, we insist on one clock between new burst requests to allow all of our
registered counters to adjust to the new burst.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Finally, don't start any new bursts if we aren't haven't</span>
		<span class="c1">// yet adjusted our counters from the last burst</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phantom_start</span><span class="p">)</span>
			<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>So far, this should look very similar to the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">Virtual
FIFO</a>.</p>

<p>The length handling, however, is subtly different.  In particular, we’ll always
send a full burst unless we’ve stopped collecting data and there remains a
partial burst’s worth of data left.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_awaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_AWVALID</span> <span class="o">||</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s_stopped</span> <span class="o">||</span> <span class="p">(</span><span class="o">|</span><span class="n">data_available</span><span class="p">[</span><span class="n">LGFIFO</span><span class="o">:</span><span class="n">LGMAXBURST</span><span class="p">]))</span>
				<span class="n">axi_awlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">axi_awlen</span>  <span class="o">&lt;=</span> <span class="n">data_available</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">end</span></code></pre></figure>

<p>The neat thing about this is that we don’t ever need to check against any 4kB
boundaries–even though we permit an other-than-full-length burst.</p>

<p>The write address signal is only slightly more complex than the one for the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v">Virtual FIFO</a>.
Here, we use the AWLEN value for the burst that has just been
completed to adjust the address–meaning that when we stop, the <code class="language-plaintext highlighter-rouge">AWADDR</code>
signal will point to the oldest address in memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">axi_awaddr</span><span class="p">[</span><span class="n">ADDRLSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">axi_awaddr</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]</span>
				    <span class="o">&lt;=</span> <span class="n">axi_awaddr</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]</span>
						<span class="o">+</span> <span class="p">(</span><span class="n">M_AXI_AWLEN</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">end</span></code></pre></figure>

<p>Up until the <a href="/blog/2017/06/08/simple-scope.html">scope</a>
stops, however, the lower bits will remain aligned.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s_stopped</span><span class="p">)</span>
			<span class="n">axi_awaddr</span><span class="p">[</span><span class="n">LGMAXBURST</span><span class="o">+</span><span class="n">ADDRLSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Of course, we’ll start back at the beginning of RAM on any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span> <span class="o">&amp;&amp;</span> <span class="n">scope_reset</span><span class="p">))</span>
			<span class="n">axi_awaddr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>This core also issues word-aligned requests only.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">axi_awaddr</span><span class="p">[</span><span class="n">ADDRLSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>So, that wasn’t so bad.  As you saw, we were able to nicely simplify those
four <code class="language-plaintext highlighter-rouge">AxLEN</code> criteria down to something usable, and so only lost one clock
between initiating one burst transaction and being able to initiate a
second–a clock cycle that wouldn’t be noticed anyway due to the fact that
we don’t issue write requests until the last one is complete.</p>

<h2 id="example-vdma">Example: VDMA</h2>

<table align="center" style="float: right"><caption>Fig 12. A video frame reader</caption><tr><td><img src="/img/axiaddr-limits/axivdma.svg" alt="" width="360" /></td></tr></table>

<p>Where things really start getting dicey is when the controller no longer has
control over the start address or the length of any given burst.  A classical
example of this would be in the
<a href="https://en.wikipedia.org/wiki/Framebuffer">framebuffer</a> reader capability
found within <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivdisplay.v">my AXI video
DMA</a>.
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivdisplay.v">This core</a>
reads from a <a href="https://en.wikipedia.org/wiki/Framebuffer">framebuffer</a>
and generates an outgoing video stream signal from it.</p>

<p>The AXI operations themselves are all line based reads, as shown in Fig. 13
below.</p>

<table align="center" style="float: none"><caption>Fig 13. A video frame reader</caption><tr><td><img src="/img/axiaddr-limits/video-memory.svg" alt="" width="560" /></td></tr></table>

<p>The reader starts reading from the first line in memory, located at a
configurable frame address.  Subsequent lines are all separated by a
configurable “line step”, specifying the distance between lines.  Then,
within a given line, bursts start at the base address for the line and
continue sequentially until the end of the line.  Between one line and the
next, there may be some unused space–it’s not required, but it is illustrated
in Fig. 13 above.</p>

<p>To see how this works, let’s check out the line address generation logic below.
It should match Fig. 13 above quite nicely.</p>

<ol start="1">
  <li>When the design is first activated, the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivdisplay.v">VDMA</a>
always starts reading from the beginning of a frame.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">req_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">req_line_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span>  <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span> <span class="o">||</span> <span class="n">r_stopped</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">req_addr</span>       <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">cfg_frame_addr</span> <span class="o">}</span><span class="p">;</span>
		<span class="n">req_line_addr</span>  <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">cfg_frame_addr</span> <span class="o">}</span><span class="p">;</span>
		<span class="n">req_line_words</span> <span class="o">&lt;=</span> <span class="n">cfg_line_words</span><span class="p">;</span></code></pre></figure>

<ol start="2">
  <li>The internal addresses are only adjusted when a new read is <em>issued</em>.
This is separate and distinct from the <code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code> cycle  where it
is <em>accepted</em> by the bus.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phantom_start</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<ol start="3">
  <li>
    <p>Internally, line and frame control are driven by two control signals:
<code class="language-plaintext highlighter-rouge">req_hlast</code> (the last burst request in a line has been issued), and
<code class="language-plaintext highlighter-rouge">req_vlast</code> (we are processing the last line in a frame).  If both of
these signals are true, then we need to re-start processing from the base
address of the entire video frame.</p>

    <p>In this case, the <code class="language-plaintext highlighter-rouge">cfg_</code> prefix denotes configuration values set by the user
at run time.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">req_hlast</span> <span class="o">&amp;&amp;</span> <span class="n">req_vlast</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">req_addr</span>       <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">cfg_frame_addr</span> <span class="o">}</span><span class="p">;</span>
			<span class="n">req_line_addr</span>  <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">cfg_frame_addr</span> <span class="o">}</span><span class="p">;</span>
			<span class="n">req_line_words</span> <span class="o">&lt;=</span> <span class="n">cfg_line_words</span><span class="p">;</span></code></pre></figure>

<ol start="4">
  <li>Otherwise, if this isn’t the last line of the frame, but we have already
issued the last burst of the line, then we need to step our burst
starting address, herein called <code class="language-plaintext highlighter-rouge">req_addr</code>, forward by one line.  In order
to maintain where the first line of the frame was, we’ll also step the
“beginning of line” address forward by one line as well.  Finally, we’ll
charge a counter containing the remaining number of words to be read in this
line to its full width.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">req_hlast</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// verilator lint_off WIDTH</span>
			<span class="n">req_addr</span> <span class="o">&lt;=</span> <span class="n">req_line_addr</span>
					<span class="o">+</span> <span class="p">(</span><span class="n">r_line_step</span> <span class="o">&lt;&lt;</span> <span class="n">M_AXI_ARSIZE</span><span class="p">);</span>
			<span class="n">req_line_addr</span>  <span class="o">&lt;=</span> <span class="n">req_line_addr</span>
					<span class="o">+</span> <span class="p">(</span><span class="n">r_line_step</span> <span class="o">&lt;&lt;</span> <span class="n">M_AXI_ARSIZE</span><span class="p">);</span>
			<span class="c1">// verilator lint_on WIDTH</span>
			<span class="n">req_line_words</span> <span class="o">&lt;=</span> <span class="n">r_line_words</span><span class="p">;</span></code></pre></figure>

<ol start="5">
  <li>
    <p>In all other circumstances, we’ll step forward by the length of one
burst–whatever that might currently be.</p>

    <p>You might also notice the <code class="language-plaintext highlighter-rouge">ADDRLSB</code> value in the request below.  As you
may recall from above, this is the log (based two) of the bus width in
bytes.  It’s equivalent to AXI’s <code class="language-plaintext highlighter-rouge">M_AXI_ARSIZE</code> and it’s simply used here
to adjust our burst address by the number of bytes within a single bus word.</p>

    <p>One final point I want to bring out here: whereas the first burst of any
line might be misaligned, subsequent bursts will always be aligned
<em>with a maximum burst sized boundary</em>.  For this reason, you can always
clear the bottom <code class="language-plaintext highlighter-rouge">LGMAXBURST+ADDRLSB</code> bits, even though measuring the
number of remaining words will take a bit more work.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="c1">// verilator lint_off WIDTH</span>
			<span class="n">req_addr</span> <span class="o">&lt;=</span> <span class="n">req_addr</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">LGMAXBURST</span><span class="o">+</span><span class="n">ADDRLSB</span><span class="p">));</span>
			<span class="n">req_line_words</span> <span class="o">&lt;=</span> <span class="n">req_line_words</span> <span class="o">-</span> <span class="p">(</span><span class="n">M_AXI_ARLEN</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="c1">// verilator lint_on  WIDTH</span>

			<span class="n">req_addr</span><span class="p">[</span><span class="n">LGMAXBURST</span><span class="o">+</span><span class="n">ADDRLSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>All of that is background information describing how a burst’s address is
determined.  It’s important if for no other reason than it points out that
we really have no control over the initial address of a given burst, nor
do we have any control over length of any lines.  All of that information
is determined by the user at run-time.</p>

<p>That means we’re going to need to suffer the two clock loss when calculating
the next burst’s starting information.  In this case, it’s not as bad as it
sounds, and here’s why:</p>

<ol>
  <li>
    <p>While you might want to use 100% of the memory bandwidth while reading a
line of pixels, video timing typically gives you several free clocks
between lines.</p>
  </li>
  <li>
    <p>We could still hide our calculations in the throughput of the bus
in all cases other than the first burst of any line.</p>

    <p>If we wanted to, we could pre-calculate some line statistics while running
through the previous line–sort of pipelining the calculation if you will–I
just don’t think that’s required here.</p>
  </li>
</ol>

<p>As a result, we have three clocks of interest:</p>

<ol>
  <li>
    <p>There’s the first clock of the calculation.  I’ll use the flag, <code class="language-plaintext highlighter-rouge">lag_start</code>,
to identify this clock.</p>
  </li>
  <li>
    <p>There’s the combinatorial clock when <code class="language-plaintext highlighter-rouge">start_burst</code> is true.  This clock
cycle follows the <code class="language-plaintext highlighter-rouge">lag_start</code> cycle, and forms the second of the two
clocks between burst starts.</p>
  </li>
  <li>
    <p>Finally, there’s the clock cycle where <code class="language-plaintext highlighter-rouge">phantom_start</code> is true.  This is
the clock cycle where the actual read is first issued on the bus.</p>
  </li>
  <li>
    <p>This is followed by another <code class="language-plaintext highlighter-rouge">lag_start</code> clock and the cycle repeats.</p>
  </li>
</ol>

<p>Fig. 14 below shows how these signals all work together.  This figure was built
under the assumption of a very large FIFO for the receive data.  As such, more
requests are issued for memory than there are beats returned in this trace.
That’s actually a good thing–when the slave can’t handle any more requests,
it will drop <code class="language-plaintext highlighter-rouge">ARREADY</code>.  That’s a slave responsibility.  It’s not the master’s
responsibility.  The master should be holding <code class="language-plaintext highlighter-rouge">ARVALID</code> high anytime it knows
it wants to request another packet.  In the meantime, our requests will cross
the <a href="/blog/2019/07/17/crossbar.html">interconnect</a>
while waiting for the slave to finish replying to our request.  This means that
the read data, once produced, should be able to continue from one burst to the
next without hiccups–assuming the slave can handle that pace in the first
place.</p>

<table align="center" style="float: none"><caption>Fig 14. VDMA example trace reading from a framebuffer</caption><tr><td><img src="/img/axiaddr-limits/vdma-trace.svg" alt="" width="780" /></td></tr></table>

<p>Let’s walk through and discuss this figure, so you’ll follow what’s going
on below.</p>

<ol>
  <li>
    <p>The figure starts out on the far left with the user writing the number of
words per line and the number of lines per frame to the core.  On the next
cycle, the user gives
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivdisplay.v">the core</a>
the frame’s base address.  Finally, the user turns the interface on.  From
there on out, <code class="language-plaintext highlighter-rouge">cfg_active</code> is asserted indicating that the configuration
is active.</p>
  </li>
  <li>
    <p>It takes us three clocks to get started once the configuration becomes
active.  On the last of these clocks, the <code class="language-plaintext highlighter-rouge">req_addr</code> is set.  This will
form the basics of the request that follows.</p>
  </li>
  <li>
    <p>A second clock is used to determine the maximum allowable burst length.</p>
  </li>
  <li>
    <p>From this maximum allowable burst length we can now set <code class="language-plaintext highlighter-rouge">ARLEN</code> and issue
a read command.</p>
  </li>
  <li>
    <p>Immediately after the read command, and possibly even before it is accepted
by the bus, the <code class="language-plaintext highlighter-rouge">lag_start</code> signal goes high and we restart the process all
over again.</p>
  </li>
</ol>

<p>Let’s now take a look into the design to see how all this was accomplished.
We’ll start by examining the <code class="language-plaintext highlighter-rouge">start_transaction</code> combinatorial flag, which in
this core is called `start_burst.  In this design, burst requests are issued
if there’s room in the FIFO to receive another burst’s worth of data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">start_burst</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">no_fifo_space_available</span><span class="p">)</span>
			<span class="n">start_burst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>What might not be apparent here is that I’m checking for whether or not there’s
space enough for a full burst in the FIFO.  This particular
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivdisplay.v">Video DMA core</a>
can’t (yet) handle single or even finite frame counts.  It either outputs a
stream of ongoing video data or nothing.  For this reason, it doesn’t
check whether or not there’s enough room in the FIFO for anything less
than a full burst’s size.</p>

<p>That gets us started, unless … and there are a lot of “unless”es, just like
the last core.  In this case, we’ll start if we have room in our FIFO unless
we are in one of our two burst data calculation clocks.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">phantom_start</span> <span class="o">||</span> <span class="n">lag_start</span><span class="p">)</span>
			<span class="c1">// Insist on a minimum of two clocks between burst</span>
			<span class="c1">// starts, so we can get our lengths right</span>
			<span class="n">start_burst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Similarly, we can’t request a new burst if we are still stalled waiting for the
last burst request to be accepted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Can't start a new burst if the outgoing channel is still</span>
		<span class="c1">// stalled.</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_ARREADY</span><span class="p">)</span>
			<span class="n">start_burst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Finally, if the user has turned off video production, i.e. if he has dropped
the <code class="language-plaintext highlighter-rouge">cfg_active</code> flag, or if we are waiting to for a
<a href="/blog/2020/03/14/axi-reset.html"><code class="language-plaintext highlighter-rouge">soft_reset</code></a>
to complete, then we refuse to start a new burst until after we come to a
complete halt.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// If the user wants us to stop, then stop</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">soft_reset</span> <span class="o">||</span> <span class="o">!</span><span class="n">cfg_active</span><span class="p">)</span>
			<span class="n">start_burst</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p><a href="/blog/2017/06/12/minimizing-luts.html">How much logic did we
use</a>?  Well,
everything in this combinatorial path is one bit, save for the
<code class="language-plaintext highlighter-rouge">no_fifo_space_available</code> signal which just checks the
top bits of how much space is available, so perhaps about 7-8 bits.  This
is quite within reason.</p>

<p>Now we need to calculate the actual burst length, <code class="language-plaintext highlighter-rouge">ARLEN</code>, we are going to
request.  This is the hard part, and so we’ll do this in two steps.</p>

<p>For the first step, we check the remaining number of words to be read in the
current line.  If it’s greater than our maximum burst amount, then the maximum
burst length would be a full burst, otherwise it would be limited by however
much requested data is available.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lag_start</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req_line_words</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">))</span>
			<span class="n">max_burst</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">max_burst</span> <span class="o">&lt;=</span> <span class="n">req_line_words</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>This happens on the <code class="language-plaintext highlighter-rouge">lag_start</code> clock cycle.</p>

<p>The key piece of this check is that <code class="language-plaintext highlighter-rouge">req_line_words</code>, our signal holding the
number of words remaining in a line, is set on the <code class="language-plaintext highlighter-rouge">phantom_start</code> clock cycle
and this check is taking place on the cycle following–as soon as a new
<code class="language-plaintext highlighter-rouge">req_line_words</code> value is available.  For reference, this is shown in Fig. 14
above as part of <code class="language-plaintext highlighter-rouge">req_addr</code>.</p>

<p>That’s only the first part of generating <code class="language-plaintext highlighter-rouge">arlen</code>.  For the second step, we’ll
now need to compare this value against how many beats are between us and the
nearest burst boundary.  Again, we check against the nearest burst boundary
because it’s at most an 8-bit check, rather than the 12-bit check required
for a full 4kB check.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// till_boundary is the distance to the boundary (minus one)</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">till_boundary</span> <span class="o">=</span> <span class="o">~</span><span class="n">req_addr</span><span class="p">[</span><span class="n">ADDRLSB</span> <span class="o">+:</span> <span class="n">LGMAXBURST</span><span class="p">];</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARVALID</span> <span class="o">||</span> <span class="n">M_AXI_ARREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">till_boundary</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">max_burst</span> <span class="o">&lt;=</span> <span class="n">till_boundary</span><span class="p">)</span>
			<span class="n">axi_arlen</span> <span class="o">&lt;=</span> <span class="n">max_burst</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">axi_arlen</span> <span class="o">&lt;=</span> <span class="n">till_boundary</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>You might notice above that I played a little sleight of hand with the two’s
compliment check.  I want to check whether or not the <code class="language-plaintext highlighter-rouge">req_addr + max_burst</code>
is greater than <code class="language-plaintext highlighter-rouge">(1 &lt;&lt; LGMAXBURST)</code> (checking only the lowest
<code class="language-plaintext highlighter-rouge">ADDRLSB +: LGMAXBURST</code> bits of <code class="language-plaintext highlighter-rouge">req_addr</code>).  After subtracting these <code class="language-plaintext highlighter-rouge">req_addr</code>
bits from both sides, I then want to check whether or not <code class="language-plaintext highlighter-rouge">max_burst</code> is
greater than <code class="language-plaintext highlighter-rouge">(1 &lt;&lt; LGMAXBURST) - req_addr</code>.  This is the same as checking
whether <code class="language-plaintext highlighter-rouge">max_burst &gt; (1 &lt;&lt; LGMAXBURST) + ~req_addr + 1</code>.  (Just a two’s
compliment equality replacement here.)  If I then swap from a <code class="language-plaintext highlighter-rouge">&gt;</code> check to
a <code class="language-plaintext highlighter-rouge">&gt;=</code> check I can drop the <code class="language-plaintext highlighter-rouge">+1</code> and the carry chain–as you can see above.</p>

<p>This computation will take place on the clock period just prior to
<code class="language-plaintext highlighter-rouge">phantom_start</code>, and so we have the time to do this.</p>

<p>The last step is to generate the AXI address.  This was calculated a couple of
clocks earlier by <code class="language-plaintext highlighter-rouge">req_addr</code> above, so it’s simply listed below as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_araddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start_burst</span><span class="p">)</span>
			<span class="n">axi_araddr</span> <span class="o">&lt;=</span> <span class="n">req_addr</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">axi_araddr</span><span class="p">[</span><span class="n">ADDRLSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>The key point to remember from this algorithm is that, yes, we did take two
clocks to calculate the burst size, <code class="language-plaintext highlighter-rouge">ARLEN</code>.  However, most video streams would
never notice this two clock hiccup.</p>

<p>That said, I have thought about adjusting this so that we only take two clocks
on the first burst of any line, and one clock on any subsequent burst.  We’ll
see what the future brings for this algorithm.</p>

<h2 id="example-s2mm">Example: S2MM</h2>

<table align="center" style="float: right"><caption>Fig 15. An S2MM core copies a data stream to memory</caption><tr><td><img src="/img/axiaddr-limits/axis2mm.svg" alt="" width="360" /></td></tr></table>

<p>The most complicated of all my examples, however, is <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">my own AXI stream to
memory data mover</a>.
This one took quite a bit of time to get right, and then even longer to adjust
it so that it would work in a minimum amount of time.  Here are some key points
to the problem to consider:</p>

<ol>
  <li>
    <p>The user can select any address to start on, regardless of whether it is
burst aligned or not.  (<a href="https://github.com/ZipCPU/wb2axip/blob/3fd18664246707f06924fddc5c8a5de4b62517fc/rtl/axis2mm.v">My current version</a>
still requires word alignment–but that’s another topic.)</p>
  </li>
  <li>
    <p>The user can also select any length to start with, with the only constraint
being that it must be greater than zero.</p>
  </li>
  <li>
    <p>Once the user selects the address he wants to read from and the number of
words to read, he must still issue a start command to the controller.  This
extra clock cycle is a gift.  We can hide one of our two bounds checking
clock cycles inside this free clock cycle.</p>
  </li>
  <li>
    <p>Unlike the frame buffer reader above, we only have to deal with this initial
burst check once rather than at the beginning of every new line.  Every
burst following that initial burst will be burst aligned, and so won’t need
to be checked against a 4kB boundary.</p>
  </li>
  <li>
    <p>We also offer the new feature of being able to write all of our data values
to a fixed word in memory space—perhaps the input word of some other
programming logic controller, perhaps even an output controller of some type.
This adds a new requirement to our list of things to check: we now have to
check against one of two maximum burst sizes depending upon whether or not
the user wants us to used the fixed addressing mode (max burst size of 16)
or not (max burst size of 256, and <code class="language-plaintext highlighter-rouge">r_increment</code> is asserted).</p>
  </li>
</ol>

<p>To see how this all works out, let’s examine a trace showing this timing in
Fig. 16 below.</p>

<table align="center" style="float: none"><caption>Fig 16. S2MM Trace</caption><tr><td><img src="/img/axiaddr-limits/s2mm-trace.svg" alt="" width="780" /></td></tr></table>

<p>This figure shows a memory copy of nine words, where the first burst isn’t
aligned on a burst boundary, and so it takes two clock cycles.  Let’s walk
through how it works piece by piece.</p>

<p>First, just like the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivdisplay.v">VDMA</a>
example above, this one also starts with a user issuing a configuration
command containing the memory address to copy to as well as the length of
the memory copy.  This configuration ends with the user issuing a command
to start.</p>

<p>As the user enters a new address, we’ll set two flags.  One flag,
<code class="language-plaintext highlighter-rouge">aw_needs_alignment</code>, records whether or not the first burst will be
artificially limited to the burst boundary.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">aw_needs_alignment</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">new_wideaddr</span><span class="p">[</span><span class="n">ADDRLSB</span> <span class="o">+:</span> <span class="n">LGMAXBURST</span><span class="p">])</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">new_widelen</span><span class="p">[</span><span class="n">LGLEN</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="p">(</span><span class="n">LGMAXBURST</span><span class="o">+</span><span class="n">ADDRLSB</span><span class="p">)])</span>
				<span class="n">aw_needs_alignment</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">new_wideaddr</span><span class="p">[</span><span class="n">ADDRLSB</span> <span class="o">+:</span> <span class="n">LGMAXBURST</span><span class="p">]</span>
					<span class="o">&lt;</span> <span class="n">new_widelen</span><span class="p">[</span><span class="n">ADDRLSB</span> <span class="o">+:</span> <span class="n">LGMAXBURST</span><span class="p">])</span>
				<span class="n">aw_needs_alignment</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p><a href="https://github.com/ZipCPU/wb2axip/blob/3fd18664246707f06924fddc5c8a5de4b62517fc/rtl/axis2mm.v#L754-L755">Two other flags record whether or not the user has asked for multiple
bursts</a>.
One flag checks for multiple bursts assuming that the addresses will be
incrementing and bursts will be 256 beats in length, whereas the other flag
checks whether the transfer would require multiple bursts of
16-beats in length.</p>

<p>Only once the user issues the start command do we know which of the two
will limits will constrain us.  That means we’re going to need a flag to
let us know that this initial burst computation isn’t (quite) done yet.
That’s the purpose of the <code class="language-plaintext highlighter-rouge">r_pre_start</code> flag, also shown in Fig. 16 above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
		<span class="n">r_pre_start</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">r_pre_start</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>This core is a bit different from the others above in that it keeps track of
an <code class="language-plaintext highlighter-rouge">aw_multiple_bursts_remaining</code> flag.  This flag is equivalent to whether
or not two or more bursts are remaining.  To maintain this equivalence, it is
set and maintained together with the counter containing the amount of remaining
data left to transfer.</p>

<p>It’s initialized once the full size of the transfer is available.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">aw_none_remaining</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">aw_requests_remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">aw_requests_remaining</span> <span class="o">&lt;=</span> <span class="n">cmd_length_w</span><span class="p">;</span>
		<span class="n">aw_none_remaining</span>     <span class="o">&lt;=</span> <span class="n">zero_length</span><span class="p">;</span>
		<span class="n">aw_multiple_bursts_remaining</span> <span class="o">&lt;=</span> <span class="o">|</span><span class="n">cmd_length_w</span><span class="p">[</span><span class="n">LGLENW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">LGMAXBURST</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span></code></pre></figure>

<p>On any abort, as part of the
<a href="/blog/2020/03/14/axi-reset.html">soft reset</a> logic,
the request lengths are cleared.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd_abort</span> <span class="o">||</span> <span class="n">axi_abort_pending</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">aw_requests_remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">aw_none_remaining</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">aw_multiple_bursts_remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>In all other cases this remaining length is updated any time a new burst
request is issued.  What’s not apparent from <a href="https://github.com/ZipCPU/wb2axip/blob/3fd18664246707f06924fddc5c8a5de4b62517fc/rtl/axis2mm.v#L965-L972">these
lines</a>
is that the number of items remaining is <a href="https://github.com/ZipCPU/wb2axip/blob/3fd18664246707f06924fddc5c8a5de4b62517fc/rtl/axis2mm.v#L917-L929">calculated combinatorially from the
current number of items minus the number in
<code class="language-plaintext highlighter-rouge">AWLEN</code></a>.
That way I can use one new remaining length signal in three separate
non-blocking assignments.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phantom_start</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">aw_requests_remaining</span> <span class="o">&lt;=</span> <span class="n">aw_next_remaining</span><span class="p">;</span>
		<span class="n">aw_none_remaining</span><span class="o">&lt;=</span> <span class="o">!</span><span class="n">aw_multiple_bursts_remaining</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">aw_next_remaining</span><span class="p">[</span><span class="n">LGMAXBURST</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">aw_multiple_bursts_remaining</span>
				<span class="o">&lt;=</span> <span class="o">|</span><span class="n">aw_next_remaining</span><span class="p">[</span><span class="n">LGLENW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">LGMAXBURST</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">end</span></code></pre></figure>

<p>The real key to this algorithm lies in how the length of the first burst is
calculated.  In particular, because of the flags we calculated earlier, we
can keep this burst length calculation short and based on a small number of
9-bit comparisons only.</p>

<p>The first step is to calculate (combinatorially) the distance to the next
burst boundary.  This is roughly equivalent to
<code class="language-plaintext highlighter-rouge">(1&lt;&lt;(LGMAXBURST+ADDRLSB))-cmd_addr)</code>.  I have to separate it out for special
treatment here for two reasons.  First, I want to make certain that the
operation is limited to <code class="language-plaintext highlighter-rouge">LGMAXBURST</code> bits–not <code class="language-plaintext highlighter-rouge">LGMAXBURST+1</code> bits, so we
drop a bit here.  The second reason is that I want to drop the lower sub-word
address bits from this calculation.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">addralign</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="o">~</span><span class="n">cmd_addr</span><span class="p">[</span><span class="n">ADDRLSB</span> <span class="o">+:</span> <span class="n">LGMAXBURST</span><span class="p">]);</span></code></pre></figure>

<p>Here’s the key you’ve been waiting for.</p>

<p>In general, the initial burst length is the full size.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">initial_burstlen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">);</span></code></pre></figure>

<p>If we are going to be using FIXED addressing, then we need to limit ourselves
to a maximum of 16 beats, not 256.  Moreover, if we aren’t doing multiple
bursts, we’ll limit the burst length to one burst only.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_increment</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">initial_burstlen</span> <span class="o">=</span> <span class="n">MAX_FIXED_BURST</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aw_multiple_fixed_bursts</span><span class="p">)</span>
				<span class="n">initial_burstlen</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">cmd_length_w</span><span class="p">[</span><span class="n">LGMAXBURST</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Did you catch how this computation only requires two bits so far?  That’s
much better than the 32-bit comparisons we started with.</p>

<p>What about normal incrementing addressing?  That’s the next check.  Remember
how we were able to check if we needed alignment and reduce it into a single
flag above?  That check can now be handled in a single check here.  Similarly,
if we don’t need to realign the burst, and if we aren’t issuing multiple full
bursts, then we can issue a smaller burst length.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aw_needs_alignment</span><span class="p">)</span>
			<span class="n">initial_burstlen</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">addralign</span> <span class="o">}</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aw_multiple_full_bursts</span><span class="p">)</span>
			<span class="n">initial_burstlen</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">cmd_length_w</span><span class="p">[</span><span class="n">LGMAXBURST</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>So, from four flags and two lengths, we’ve been able to determine our initial
burst length.  That’s <a href="/blog/2017/06/12/minimizing-luts.html">one LUT per bit of
<code class="language-plaintext highlighter-rouge">initial_burstlen</code></a>.
Not bad.  We might’ve also been able to handle this initial value one
clock earlier if <code class="language-plaintext highlighter-rouge">r_increment</code> were defined prior to the user’s start command.</p>

<p>From here, we get to define the maximum burst length we can process.  This is
initially set by the clock following the start command to the initial value
we just calculated above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_max_burst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span> <span class="o">||</span> <span class="n">r_pre_start</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Force us to align ourself early</span>
		<span class="c1">//   That way we don't need to check for</span>
		<span class="c1">//   alignment (again) later</span>
		<span class="n">r_max_burst</span> <span class="o">&lt;=</span> <span class="n">initial_burstlen</span><span class="p">;</span></code></pre></figure>

<p>We then update this maximum burst length on every <code class="language-plaintext highlighter-rouge">phantom_start</code> clock cycle.
That also means that we’ll know the maximum size of our burst immediately
following any <code class="language-plaintext highlighter-rouge">phantom_start</code> cycle.  That would be enough to start a second
cycle immediately, save only that we still need to check whether this much
data is in our FIFO–so it will still take the minimum two clocks between burst
starts as illustrated in Fig. 16 above.</p>

<p>There are four cases to consider when checking for the next burst size, divided
here into two categories.  The first category is the “normal” one, where
addresses are incrementing throughout the transfer.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phantom_start</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Verilator lint_off WIDTH</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r_increment</span> <span class="o">||</span> <span class="n">LGMAXBURST</span> <span class="o">&lt;=</span> <span class="n">LGMAX_FIXED_BURST</span><span class="p">)</span>
		<span class="k">begin</span></code></pre></figure>

<p>In this case, if we don’t have multiple bursts remaining, then we need to check
the number of beats remaining against the maximum size of the burst.  Otherwise,
we stick with the maximum burst size.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aw_multiple_bursts_remaining</span>
				<span class="o">&amp;&amp;</span> <span class="n">aw_next_remaining</span><span class="p">[</span><span class="n">LGMAXBURST</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">))</span>
				<span class="n">r_max_burst</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">aw_next_remaining</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">r_max_burst</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGMAXBURST</span><span class="p">);</span>
		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>We then repeat the calculation for fixed addressing, with the only difference
being that the maximum burst size (16 beats) is smaller.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aw_multiple_bursts_remaining</span>
				<span class="o">&amp;&amp;</span> <span class="n">aw_next_remaining</span><span class="p">[</span><span class="n">LGMAXBURST</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">MAX_FIXED_BURST</span><span class="p">)</span>
				<span class="n">r_max_burst</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">aw_next_remaining</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">r_max_burst</span> <span class="o">&lt;=</span> <span class="n">MAX_FIXED_BURST</span><span class="p">;</span>
		<span class="k">end</span>
		<span class="c1">// Verilator lint_on WIDTH</span>
	<span class="k">end</span></code></pre></figure>

<p>At this point, we know the size of our next burst.  That was the hard
part.</p>

<p>The next piece is knowing when to start the next burst.  In this case, I named
the <code class="language-plaintext highlighter-rouge">start_transaction</code> combinatorial signal as <code class="language-plaintext highlighter-rouge">w_phantom_start</code>.  As before,
we start a burst whenever there is sufficient data in the FIFO to complete
the burst.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// We start again if there's more information to transfer</span>
		<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="o">!</span><span class="n">aw_none_remaining</span><span class="p">;</span>

		<span class="c1">// But not if the amount of information we need isn't (yet)</span>
		<span class="c1">// in the FIFO.</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sufficiently_filled</span><span class="p">)</span>
			<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>This is a combinatorial check, depending upon the value of
<a href="https://github.com/ZipCPU/wb2axip/blob/3fd18664246707f06924fddc5c8a5de4b62517fc/rtl/axis2mm.v#L1255-L1260"><code class="language-plaintext highlighter-rouge">sufficiently_filled</code></a>.
So we’ll need to remember that burden as we work through this logic.</p>

<p>We’re also going to insist on a minimum of one clock between bursts, and an
extra clock to calculate the burst size initially.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Insist on a minimum of one clock between burst starts,</span>
		<span class="c1">// since our burst length calculation takes a clock to do</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phantom_start</span> <span class="o">||</span> <span class="n">r_pre_start</span><span class="p">)</span>
			<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>As with our other checks, we can’t start any new bursts if we are still stalled
waiting for the last burst request to be accepted, or likewise if we are still
transmitting the data from the last burst.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// We can't start if the last request hasn't yet been accepted</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_AWREADY</span><span class="p">)</span>
			<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="c1">// If we're still writing the last burst, then don't start</span>
		<span class="c1">// any new ones</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WLAST</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_WREADY</span><span class="p">))</span>
			<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Finally, if we aren’t busy doing a copy then we can’t start, neither should
we start any new bursts following any request for a bus abort.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Finally, don't start any new bursts if we aren't already</span>
		<span class="c1">// busy transmitting, or if we are in the process of aborting</span>
		<span class="c1">// our transfer</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span> <span class="o">||</span> <span class="n">cmd_abort</span> <span class="o">||</span> <span class="n">axi_abort_pending</span><span class="p">)</span>
			<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>That leaves only two pieces of logic left.  First, we’ll need to set <code class="language-plaintext highlighter-rouge">AWLEN</code>
on any new burst request.  Thankfully, this has already been calculated
above from <code class="language-plaintext highlighter-rouge">r_max_burst</code>, so it’s little more than a register copy here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_AWVALID</span> <span class="o">||</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span>
			<span class="n">axi_awlen</span>  <span class="o">&lt;=</span> <span class="n">r_max_burst</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">8'd1</span><span class="p">;</span></code></pre></figure>

<p>The outgoing address is updated as soon as any successful burst is completed.
Note the check for whether or not the <code class="language-plaintext highlighter-rouge">r_increment</code> flag is set–since the core
supports both incrementing and fixed addressing.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">axi_awaddr</span><span class="p">[</span><span class="n">ADDRLSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="c1">// Verilator lint_off WIDTH</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r_increment</span><span class="p">)</span>
				<span class="n">axi_awaddr</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]</span>
				    <span class="o">&lt;=</span> <span class="n">axi_awaddr</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]</span>
						<span class="o">+</span> <span class="p">(</span><span class="n">M_AXI_AWLEN</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="c1">// Verilator lint_on WIDTH</span>
		<span class="k">end</span></code></pre></figure>

<p>We’ll also set the write address any time we are not (yet) busy so that it
is set to the first word of any upcoming transfer.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
			<span class="n">axi_awaddr</span><span class="o">&lt;=</span> <span class="n">cmd_addr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_UNALIGNED</span><span class="p">)</span>
			<span class="n">axi_awaddr</span><span class="p">[</span><span class="n">ADDRLSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<h2 id="conclusion">Conclusion</h2>

<p>Achieving high throughput in any design is dependent upon being able to sustain
read or write data transfers on every single clock cycle, even crossing
multiple beats if necessary.  This requires creating AXI burst requests as
soon as the data (or space) is available to make them.  It also requires making
sure that your request has crossed the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> and
made it to the downstream slave as early as possible.  Ideally, you’ll want
the slave to have any subsequent burst requests waiting, on its doorstep,
as soon as it has finished with processing the last transaction so that you
can minimize any hiccups in the transfer.</p>

<p>Sadly, the complexity associated with making such requests is non-trivial.
In particular, there are four criteria that need to be checked of any
transfer length before it can be used to generate the next burst cycle.
Depending upon the speed of your FPGA, these four criteria can take several
clocks to accomplish.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 17. Bus interaction goal</caption><tr><td><img src="/img/axiaddr-limits/nothing-less.svg" alt="" width="280" /></td></tr></table>

<p>Today, we looked at four separate AXI masters which all generate AXI burst
transaction requests, and in particular we looked over how they could handle
generating requests faster than the data could be delivered.  Some solutions
were very basic, such as insisting that all requests were of the same length.
Other solutions were more complicated and required multiple clock cycles to
set up.  One common theme across all of these solutions was the need to
calculate the details of the next burst in a pipelined fashion, so that those
details would be ready before it was time to request the next burst.  As a
result, each of these AXI masters is able to sustain a full 100% bus throughput
with one beat of data transferred on every clock cycle even as the requests
crossed the boundary from one burst to the next, to the next one after that,
and so on.</p>

<p>100% AXI throughput is therefore very achievable.  You should accept nothing
less in your designs.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>He hath shewed thee, O man, what is good; and what doth the LORD require of thee, but to do justly, and to love mercy, and to walk humbly with thy God?  (Mic 6:8)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
