<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Moving values and strobes cross clock domains</title>
  <meta name="description" content="It’s been a while since we’ve discussed cross-clockdomain anything,so it’s probably worth coming back to the topic.  So far, we’ve alreadydiscussed the basic...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2020/10/03/tfrvalue.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Moving values and strobes cross clock domains</h1>
    <p class="post-meta"><time datetime="2020-10-03T00:00:00-04:00" itemprop="datePublished">Oct 3, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>It’s been a while since we’ve discussed <a href="/blog/2017/10/20/cdc.html">cross-clock
domain</a> anything,
so it’s probably worth coming back to the topic.  So far, we’ve already
discussed the <a href="/blog/2017/10/20/cdc.html">basics of crossing clock domains, and the need for a 2FF
synchronizer</a>,
<a href="/formal/2018/04/12/areset.html">synchronizing resets</a>,
and <a href="/blog/2018/07/06/afifo.html">formally verifying an asynchronous
FIFO</a>.  Today, I’d like to
come back to the topic of moving data across clock domains, but without the
use of the <a href="/blog/2018/07/06/afifo.html">asynchronous FIFO</a>.
Specifically, I’d like to revisit <a href="/blog/2017/10/20/cdc.html">the concept I posted earlier for moving words
across clock domains</a>.  This time,
I intend to increase the speed of the transfer by nearly a factor of two over
the last time I presented the concept.</p>

<p>Here’s the idea:  Imagine you have a design that requires two
<a href="/blog/2017/10/20/cdc.html">clock domains</a>.
Let’s suppose one of those domains responds to a bus-based controller which
can be used to set design registers.  These values, set from the first clock
domain, are then needed in the second clock domain.  How shall this register
information cross clock domains, with the requirement that the register in
the new clock domain either has the prior value or the new value but never
any inconsistent values?  That is, we don’t want some bits to arrive earlier
than any others, but rather to have all the bits of our register arrive in the
new clock domain at the same time.</p>

<p>A classic example of such a circuit is shown below in Fig. 1.</p>

<table align="center" style="float: none"><caption>Fig 1. Moving a counter across clock domains</caption><tr><td><img src="/img/tfrvalue/tfrcounter.svg" alt="" width="360" /></td></tr></table>

<p>This design requires moving a counter of many bits from one
<a href="/blog/2017/10/20/cdc.html">clock domains</a>,
the launching domain shown in yellow, to a new
<a href="/blog/2017/10/20/cdc.html">clock domains</a>, shown in green.
If the new <a href="/blog/2017/10/20/cdc.html">clock domains</a>
is faster than the launching domain, then the updated clock
might skip some values to keep up.  This is normal.  What’s not normal
might be the counter appearing to count backwards or out of order  because
some bits arrive before others–such as I discuss in <a href="/tutorial">my
tutorial</a>.</p>

<table align="center" style="float: left; padding: 20pt"><caption>Fig 2. A 4-phase clock transfer</caption><tr><td><img src="/img/cdc-dbl-ack.svg" alt="" width="320" /></td></tr></table>

<p><a href="/blog/2017/10/20/cdc.html">When we built this before</a>,
we placed the value to be transferred into a holding
register, and then sent a request signal to the
new <a href="/blog/2017/10/20/cdc.html">clock domain</a>.  Once an
acknowledgment was returned, we cleared the request, the acknowledgment was
then cleared, and we were then ready to send a new request.  You can see it
diagrammed in Fig. 2 on the left as a <em>four phase</em> clock transfer.  (Not to be
confused with the <a href="https://en.wikipedia.org/wiki/Four-Phase_Systems">Four-Phase
Systems</a> company my father
once worked for …)</p>

<p>This whole process of going back and forth from one
<a href="/blog/2017/10/20/cdc.html">clock domain</a> to the next,
however, is very time consuming.  If the two clocks were (nearly) synchronous,
it requires about ten clock cycles to move words from one domain to the
next, as shown in Fig. 2 above.  Anything faster would require an
<a href="/blog/2018/07/06/afifo.html">asynchronous FIFO</a>.</p>

<p>Then one of my readers sent me another approach to the same challenge, an
approach which roughly halves the time required.</p>

<h2 id="the-new-approach">The new approach</h2>

<p>Here’s the diagram I was sent.</p>

<table align="center" style="float: none"><caption>Fig 3. A proposed 2-phase CDC structure</caption><tr><td><a href="/img/tfrvalue/proposed.png"><img src="/img/tfrvalue/proposed.png" alt="" width="780" /></a></td></tr></table>

<p>Perhaps some of you may have seen this before.  It’s a <em>two phase</em> clock
transfer circuit.  While you may have seen it before, this was quite new to
me.  It took me a while after seeing this diagram to fully get a grasp on
how this proposal was different–and then to make it better.</p>

<p>As with the original design, data is first clocked in the one domain, and then
held constant until it’s transferred to the second domain.  The output value
of this design, at the new clock domain, <em>never</em> changes except on the positive
edge of the new clock domain.  (Clock crossing changes are hidden internally.)
Similarly, as with
the first design, there are two
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
synchronizers in both paths.
Well, almost: the control path has a sort of modified three
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
synchronizer–but we’ll get to that in a moment.</p>

<table align="center" style="float: right"><caption>Fig 4. A 2-phase clock transfer</caption><tr><td><img src="/img/tfrvalue/two-phase-cdc.svg" alt="" width="320" /></td></tr></table>

<p>The big difference is that the data updates any time the control line,
previously called a request line, <em>changes</em>.  Before, we sent data by
asserting a request line, and so new data was indicated by a positive edge.
We then required the request line clear before sending a new piece of data–or
we’d never be able to generate a new positive edge.  This updated two-phase
design sends
a request by changing the control line–either positively or negatively.  Once
the change has been observed in the feedback path, this updated design doesn’t
wait to clear the control line back to its original value, but rather uses the
next change in the control line to send a new value.  This removes the
requirement for the second round trip to clear the control lines before going
back around again.  As such, this is a <em>two-phase</em> data crossing design.</p>

<p>So, how might we build this?</p>

<h2 id="the-design">The design</h2>

<p>For the sake of discussion, let’s use the basic <a href="/dsp/2020/04/20/axil2axis.html">AXI stream
protocol</a>.  This will allow
<a href="https://en.wikipedia.org/wiki/Back_pressure">back pressure</a>
at both the input and the output.  Better yet, if you don’t need this
<a href="https://en.wikipedia.org/wiki/Back_pressure">back pressure</a>,
then just tie the ready wires to one.  We could also
use this basic protocol to pass a strobe across
<a href="/blog/2017/10/20/cdc.html">clock domains</a>:
tie the readies
to one, then any time the valid is asserted on the input (provided it’s not
raised too often) will result on a single valid being asserted at the output.</p>

<table align="center" style="float: none"><caption>Fig 5. Basic AXI-Stream port list for crossing clock domains</caption><tr><td><img src="/img/tfrvalue/portlist.svg" alt="" width="480" /></td></tr></table>

<p>Fig. 5 shows our basic portlist above, enumerated again below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">tfrvalue</span> <span class="p">#(</span>
		<span class="k">parameter</span>	<span class="n">W</span> <span class="o">=</span> <span class="mi">32</span>
	<span class="p">)</span> <span class="p">(</span>
		<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_a_clk</span><span class="p">,</span>
		<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_a_reset_n</span><span class="p">,</span>
		<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_a_valid</span><span class="p">,</span>
		<span class="kt">output</span>	<span class="kt">wire</span>		<span class="n">o_a_ready</span><span class="p">,</span>
		<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">W</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_a_data</span><span class="p">,</span>
		<span class="c1">//</span>
		<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_b_clk</span><span class="p">,</span>
		<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_b_reset_n</span><span class="p">,</span>
		<span class="kt">output</span>	<span class="kt">reg</span>		<span class="n">o_b_valid</span><span class="p">,</span>
		<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_b_ready</span><span class="p">,</span>
		<span class="kt">output</span>	<span class="kt">reg</span>	<span class="p">[</span><span class="n">W</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">o_b_data</span>
	<span class="p">);</span>

	<span class="c1">// Register declarations</span>
	<span class="k">localparam</span>	<span class="n">NFF</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">reg</span>			<span class="n">a_req</span><span class="p">,</span> <span class="n">a_ack</span><span class="p">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="n">W</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">a_data</span><span class="p">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="n">NFF</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">a_pipe</span><span class="p">;</span>

	<span class="kt">reg</span>			<span class="n">b_req</span><span class="p">,</span> <span class="n">b_last</span><span class="p">,</span> <span class="n">b_stb</span><span class="p">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="n">NFF</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">b_pipe</span><span class="p">;</span></code></pre></figure>

<p>I’ve used the prefix <code class="language-plaintext highlighter-rouge">i_a_*</code> to describe signals from the source side of this
transaction, and <code class="language-plaintext highlighter-rouge">o_a_ready</code> to capture any
<a href="https://en.wikipedia.org/wiki/Back_pressure">back pressure</a>
feedback on this side.
Similarly, the <code class="language-plaintext highlighter-rouge">i_b_*</code> and <code class="language-plaintext highlighter-rouge">o_b_*</code> prefixes describe the transaction on the
receiving side.  As you can see, we’ll be following AXI’s handshaking protocol
for this exercise.</p>

<p>The first key to this algorithm is that on any incoming request, we’ll
toggle a request value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">a_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_a_clk</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_a_reset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_a_reset_n</span><span class="p">)</span>
		<span class="n">a_req</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_a_valid</span> <span class="o">&amp;&amp;</span> <span class="n">o_a_ready</span><span class="p">)</span>
		<span class="n">a_req</span>  <span class="o">&lt;=</span> <span class="o">!</span><span class="n">a_req</span><span class="p">;</span></code></pre></figure>

<p>We’re also going to grab a copy of the data before moving
<a href="/blog/2017/10/20/cdc.html">cross clock domains</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_a_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_a_valid</span> <span class="o">&amp;&amp;</span> <span class="n">o_a_ready</span><span class="p">)</span>
		<span class="n">a_data</span> <span class="o">&lt;=</span> <span class="n">i_a_data</span><span class="p">;</span></code></pre></figure>

<p>This data copy is important.  It allows the launching side to continue on,
knowing that it’s request has been sent.  This will speed up your throughput
over forcing the sender to leave <code class="language-plaintext highlighter-rouge">i_a_valid</code> high while waiting for the
return path to set <code class="language-plaintext highlighter-rouge">o_a_ready</code>.</p>

<p>Now that we’ve changed <code class="language-plaintext highlighter-rouge">a_req</code> and copied the data, it’s time to actually
<a href="/blog/2017/10/20/cdc.html">cross clock domains</a>.
This is a basic two
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
<a href="/blog/2017/10/20/cdc.html">clock domain crossing</a>,
with the exception that we’re using a third
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
to keep track of the last value.  We call this one-clock-ago value <code class="language-plaintext highlighter-rouge">b_last</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="o">{</span> <span class="n">b_last</span><span class="p">,</span> <span class="n">b_req</span><span class="p">,</span> <span class="n">b_pipe</span> <span class="o">}</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_b_clk</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_b_reset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_b_reset_n</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">b_last</span><span class="p">,</span> <span class="n">b_req</span><span class="p">,</span> <span class="n">b_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">begin</span>
		<span class="o">{</span> <span class="n">b_last</span><span class="p">,</span> <span class="n">b_req</span><span class="p">,</span> <span class="n">b_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">b_req</span><span class="p">,</span> <span class="n">b_pipe</span><span class="p">,</span> <span class="n">a_req</span> <span class="o">}</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_b_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_b_ready</span><span class="p">)</span>
			<span class="n">b_last</span> <span class="o">&lt;=</span> <span class="n">b_last</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>There’s one additional trick to the definition of <code class="language-plaintext highlighter-rouge">b_last</code> above.  Did you
notice that I didn’t set <code class="language-plaintext highlighter-rouge">b_last</code> until I knew that the prior output wasn’t
stalled?  As you may recall, a stall would be any time
<code class="language-plaintext highlighter-rouge">o_b_valid &amp;&amp; !i_b_ready</code>.  This extra stall check wasn’t in the original
design I was given, but it helps to guarantee proper <a href="/dsp/2020/04/20/axil2axis.html">AXI stream
protocol</a>
handling.  This is where stalls will happen, if at all, but not until a prior
word has already
<a href="/blog/2017/10/20/cdc.html">crossed clock domains</a>
and set <code class="language-plaintext highlighter-rouge">o_b_valid</code> to indicate that
there’s a word ready to be received.  This also spares us some throughput,
since the receiving side can accept this data immediately if desired.</p>

<p><code class="language-plaintext highlighter-rouge">b_last</code> is therefore true once the word has
<a href="/blog/2017/10/20/cdc.html">crossed clock domains</a> <em>and</em>
once it has been accepted on our output port.  That means we can now start
sending the acknowledgment back to the beginning–the <code class="language-plaintext highlighter-rouge">a_*</code> clock domain–even
before the outgoing word has been accepted (<code class="language-plaintext highlighter-rouge">o_b_valid &amp;&amp; i_b_ready</code>) by
the receiving stream.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_a_clk</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_a_reset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_a_reset_n</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">a_ack</span><span class="p">,</span> <span class="n">a_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="mb">2'b00</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">{</span> <span class="n">a_ack</span><span class="p">,</span> <span class="n">a_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">a_pipe</span><span class="p">,</span> <span class="n">b_last</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Once this flag returns to the original clock domain, we can then compare it to
<code class="language-plaintext highlighter-rouge">a_req</code> in order to know the round-trip is complete.  Until <code class="language-plaintext highlighter-rouge">a_ack</code> matches
<code class="language-plaintext highlighter-rouge">a_req</code>, a transfer remains in progress and so <code class="language-plaintext highlighter-rouge">o_a_ready</code> needs to be false.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_a_ready</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_ack</span> <span class="o">==</span> <span class="n">a_req</span><span class="p">);</span></code></pre></figure>

<p>Notice that, unlike the four-phase clock transfer, we can’t depend upon the
value of <code class="language-plaintext highlighter-rouge">a_ack</code> to get this result, but rather need to compare <code class="language-plaintext highlighter-rouge">a_ack</code> to
<code class="language-plaintext highlighter-rouge">a_req</code>.  That’s one of the keys to the success of this two-phase algorithm.</p>

<p>Let’s now go back to the output port on the receiving side.  We’ll move our
word across that final clock whenever <code class="language-plaintext highlighter-rouge">b_last</code> isn’t equal to <code class="language-plaintext highlighter-rouge">b_req</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">b_stb</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_last</span> <span class="o">!=</span> <span class="n">b_req</span><span class="p">);</span></code></pre></figure>

<p>We also need to do a protocol check.  If ever <code class="language-plaintext highlighter-rouge">!o_b_valid || i_b_ready</code>, we
can set the output.  However, we don’t want to set <code class="language-plaintext highlighter-rouge">o_b_data</code> based upon
<code class="language-plaintext highlighter-rouge">a_data</code> unless we are confident that <code class="language-plaintext highlighter-rouge">a_data</code> has held steady for at least
one clock period in the new domain.  That way, we’re guaranteed there won’t
be any
<a href="/blog/2017/10/20/cdc.html">cross clock domain</a>
issues with it.  Hence, we’ll only adjust
<code class="language-plaintext highlighter-rouge">o_b_data</code> if <code class="language-plaintext highlighter-rouge">b_stb</code> is high, telling us that there’s a cross-clock data
request pending.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_b_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_b_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b_stb</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">o_b_valid</span> <span class="o">||</span> <span class="n">i_b_ready</span><span class="p">))</span>
		<span class="n">o_b_data</span> <span class="o">&lt;=</span> <span class="n">a_data</span><span class="p">;</span></code></pre></figure>

<p>We’ve also discussed setting an <a href="/dsp/2020/04/20/axil2axis.html">AXI stream valid
before</a>.
As with setting the data component, there’s a strict pattern
to setting valid:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_b_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_b_clk</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_b_reset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_b_reset_n</span><span class="p">)</span>
		<span class="n">o_b_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_b_valid</span> <span class="o">||</span> <span class="n">i_b_ready</span><span class="p">)</span></code></pre></figure>

<p>Once you follow the pattern, all that’s left is to set the <code class="language-plaintext highlighter-rouge">o_b_valid</code> value
to whatever your design requires.  This time, we’ll set it to <code class="language-plaintext highlighter-rouge">b_stb</code> to
indicate there’s a new value arriving on the new clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">o_b_valid</span> <span class="o">&lt;=</span> <span class="n">b_stb</span><span class="p">;</span></code></pre></figure>

<p>That’s the design.  It’s pretty basic.</p>

<p>I suppose I should offer a word about <a href="/formal/2018/04/12/areset.html">asynchronous
resets</a>.
This design uses them, even though <a href="/blog/2017/08/21/rules-for-newbies.html">I recommend against them in
general</a>.
Why?  Well, <a href="/blog/2017/10/20/cdc.html">cross clock domain</a>
designs often require <a href="/formal/2018/04/12/areset.html">asynchronous
resets</a>.
Without the <a href="/formal/2018/04/12/areset.html">asynchronous
reset</a>,
there’s no real way to guarantee that both sides are
reset in proper order.</p>

<p>Indeed, while writing this article, I had the opportunity of examining
another similar design that didn’t use <a href="/formal/2018/04/12/areset.html">asynchronous
resets</a>.  That design had
no feedback to each
<a href="/blog/2017/10/20/cdc.html">clock domain</a>
to know when the reset in the other
<a href="/blog/2017/10/20/cdc.html">clock domain</a>
had completed.  As a result,
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
found many ways of violating the reset assumptions within that design.  For
example, <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
found a way to launch a first value from the sending to the receiving domain,
followed by a reset and then a second value, only to see the first value end
up in the new domain <em>after</em> the reset.</p>

<p>Yes, those <a href="/formal/2018/04/12/areset.html">asynchronous
resets</a> 
are an important part of this design.</p>

<p>The next step, though, is the fun part: verifying that this design <a href="/blog/2017/10/20/cdc.html">crosses
clock domains</a> properly.</p>

<h2 id="formal-verification">Formal Verification</h2>

<p>The first step to formally verifying any <a href="/blog/2017/10/20/cdc.html">cross-clock
domain</a>
transfer is to adjust the <a href="https://github.com/ZipCPU/website/blob/master/examples/tfrvalue.sby">SBY
file</a> to
set the <a href="https://symbiyosys.readthedocs.io/en/latest/reference.html#options-section"><code class="language-plaintext highlighter-rouge">multiclock on</code>
option</a>.
This is a minimum requirement of any design that uses more than one clock.
We’ll then need to get access to the formal timestep, <code class="language-plaintext highlighter-rouge">gbl_clk</code> by using the
<a href="http://www.clifford.at/yosys">Yosys</a> <code class="language-plaintext highlighter-rouge">(* gclk *)</code> attribute.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="p">(</span><span class="o">*</span> <span class="n">gclk</span> <span class="o">*</span><span class="p">)</span>	<span class="kt">reg</span>		<span class="n">gbl_clk</span><span class="p">;</span></code></pre></figure>

<p>In order to use <code class="language-plaintext highlighter-rouge">$past()</code> successfully, you’ll also need an <code class="language-plaintext highlighter-rouge">f_past_valid*</code>
type of value.  In this case, there are three separate clocks–each of which
need an <code class="language-plaintext highlighter-rouge">f_past_valid*</code> check.  I’ve labeled each of these with a suffix
identifying the clock they are associated with: the formal time step, the
incoming (launching or sending) clock on the <code class="language-plaintext highlighter-rouge">_a_</code> interface, and then the
clock on the outgoing (destination, or receiving) <code class="language-plaintext highlighter-rouge">_b_</code> interface.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="kt">reg</span>		<span class="n">f_past_valid_gbl</span><span class="p">,</span> <span class="n">f_past_valid_a</span><span class="p">,</span>
					<span class="n">f_past_valid_b</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">f_past_valid_gbl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">gbl_clk</span><span class="p">)</span>
		<span class="n">f_past_valid_gbl</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">f_past_valid_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_a_clk</span><span class="p">)</span>
		<span class="n">f_past_valid_a</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">f_past_valid_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_b_clk</span><span class="p">)</span>
		<span class="n">f_past_valid_b</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>We have two more pieces of boiler plate left.  First, we’ll need to create
a clock, and then assume our two resets are properly related.  Let’s
start with the clocks.</p>

<p>We’ll “generate” a clock by adding an arbitrary step to a counter.  We can
then assume the incoming clocks are equal to the MSB’s of each counter.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="p">(</span><span class="o">*</span> <span class="n">anyconst</span> <span class="o">*</span><span class="p">)</span>	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_step_a</span><span class="p">,</span>  <span class="n">f_step_b</span><span class="p">;</span>
			<span class="kt">reg</span>	<span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_count_a</span><span class="p">,</span> <span class="n">f_count_b</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">gbl_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">f_count_a</span> <span class="o">&lt;=</span> <span class="n">f_count_a</span> <span class="o">+</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">f_step_a</span> <span class="o">}</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">f_count_b</span> <span class="o">&lt;=</span> <span class="n">f_count_b</span> <span class="o">+</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">f_step_b</span> <span class="o">}</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_a_clk</span> <span class="o">==</span> <span class="n">f_count_a</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_b_clk</span> <span class="o">==</span> <span class="n">f_count_b</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span></code></pre></figure>

<table align="center" style="float: left; padding: 20pt"><caption>Fig 6. Proof duration as a function of clock precision</caption><tr><td><img src="/img/tfrvalue/proof-durations.svg" alt="" width="480" /></td></tr></table>

<p>This is your basic fractional clock divider circuit that we’ve covered many
times before.  Do be careful when you build one of these for a formal proof:
the number of bits in the divider will drive the length of the proof.
As it is, this proof as written will take 33 steps to verify against all
possible faults using a 5-bit counter.  You can see how this would change
with other counter lengths in Fig. 6.</p>

<p>Normally I would assume that the step is greater than zero and less than or
equal to half the range.  Here, I’ve found another way of insisting on this
property–by using a step of one less bit than the counter’s bit width and
adding a constant one to it.  This guarantees that each counter will step
forward, and also that it won’t step forward so far that the counter appears
to go backwards.</p>

<p>That should handle assuming the existence of two incoming clocks.</p>

<p>The next step is to handle the <a href="/formal/2018/04/12/areset.html">two
resets</a>.
As we did for the <a href="/blog/2018/07/06/afifo.html">asynchronous
FIFO</a>, we’ll want to assume that
the design starts in reset and that both resets will fall together or never
at all.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid_gbl</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_a_reset_n</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_b_reset_n</span><span class="p">);</span>

	<span class="c1">// Both resets will always fall together</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">gbl_clk</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">fell</span><span class="p">(</span><span class="n">i_b_reset_n</span><span class="p">)</span> <span class="o">==</span> <span class="p">$</span><span class="nb">fell</span><span class="p">(</span><span class="n">i_a_reset_n</span><span class="p">));</span></code></pre></figure>

<p>This is also going to force all of our properties onto the global clock.
From here on out, we won’t be able to use any <code class="language-plaintext highlighter-rouge">always @(*) assert();</code>
statements.  If we did otherwise, any such combinatorial assertions would get
applied before this assumption was applied.  For example, we might see one
reset becoming active prior to the other.  If we instead trigger any assertions
on <code class="language-plaintext highlighter-rouge">always @(posedge gbl_clk)</code>, the resets will behave properly.</p>

<p>Just to see what I’m talking about here, consider the trace shown in
Fig. 7 below.</p>

<table align="center" style="float: none"><caption>Fig 7. Assertion failure on the final clock</caption><tr><td><img src="/img/tfrvalue/bad-reset.png" alt="" width="686" /></td></tr></table>

<p>In this picture, the formal proof failed when <code class="language-plaintext highlighter-rouge">a_req</code> suddenly dropped,
due to the sending side reset getting activated before the receiving side
reset.  We can delay this check by one time cycle by using transitioning
our always block on <code class="language-plaintext highlighter-rouge">gbl_clk</code> instead of <code class="language-plaintext highlighter-rouge">@(*)</code>–something you’ll see more of
as we go along.</p>

<p>Let’s move on and force our input values to be clock synchronous, while
verifying that our outputs are also clock synchronous.</p>

<p>One of the sad realities of multi-clock domain proofs is that you have to
assume the inputs are synchronous to their respective clocks–something that you
get for free when running proofs with a single clock only.  Here, we’ll
assume that <code class="language-plaintext highlighter-rouge">i_a_valid</code> and <code class="language-plaintext highlighter-rouge">i_a_data</code> are synchronous to the <code class="language-plaintext highlighter-rouge">i_a_clk</code>.
We’ll also force <code class="language-plaintext highlighter-rouge">i_a_reset_n</code> to only rise synchronous to <code class="language-plaintext highlighter-rouge">i_a_clk</code> as well:
asynchronous reset assertion, synchronous release as it is sometimes called.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">gbl_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_a_clk</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_a_reset_n</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_a_valid</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_a_data</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_a_reset_n</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">o_a_ready</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>We’ll also add an assertion above that <code class="language-plaintext highlighter-rouge">o_a_ready</code> is stable unless the
clock changes.  This follows my master rule of formal verification: assume
inputs, assert any local state or outputs.  However, since we are using an
<a href="/formal/2018/04/12/areset.html">asynchronous resets</a>,
this value might change if the reset is ever activated.  Since we know the
reset will last more than one clock cycle, we can just escape the assertion
here if the reset is ever active.</p>

<p>We can just about repeat those same properties on the <code class="language-plaintext highlighter-rouge">_b_</code> clock controlling
our outputs.  The difference here is that they now need to be assertions instead
of assumptions, since we are applying them to <em>outputs</em>.  The only two
exceptions are the reset in the <code class="language-plaintext highlighter-rouge">B</code> clock domain and the ready signal
<code class="language-plaintext highlighter-rouge">i_b_ready</code>, which are the only remaining inputs on this side.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">gbl_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_b_clk</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_b_reset_n</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_past_valid_b</span> <span class="o">&amp;&amp;</span> <span class="n">i_b_reset_n</span> <span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_b_reset_n</span><span class="p">))</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">o_b_valid</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">o_b_data</span><span class="p">));</span>
		<span class="k">end</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_b_reset_n</span><span class="p">)</span>
			<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_b_ready</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>You might notice that I’m requiring the <code class="language-plaintext highlighter-rouge">o_b_data</code> value to be synchronous
with the destination clock.  While this isn’t strictly required, I find it to
be good form.  Another common approach is to insist that it is synchronous
with the destination clock only if <code class="language-plaintext highlighter-rouge">o_b_valid</code> is true, and trust the
downstream logic to handle it properly.</p>

<p>Now that we are set up, it’s time to address the key components of any
proof.  We’ll start with the <a href="/dsp/2020/04/20/axil2axis.html">AXI stream
protocol</a>
<a href="/formal/2020/06/12/four-keys.html">interface properties</a>.
Here, we assume these properties of our inputs:</p>

<ol>
  <li>Valid gets cleared following any reset</li>
  <li>As long as an outgoing request is stalled, it isn’t allowed to change.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_a_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid_a</span> <span class="o">||</span> <span class="o">!</span><span class="n">i_a_reset_n</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_a_valid</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_a_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_a_ready</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_a_valid</span><span class="p">);</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_a_data</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>We then repeat those properties, only this time as assertions applied
to our outputs.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_b_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid_b</span> <span class="o">||</span> <span class="o">!</span><span class="n">i_b_reset_n</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_b_valid</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">o_b_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_b_ready</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_b_valid</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">o_b_data</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>Once our design passes these properties, we’ll know it is
<a href="/dsp/2020/04/20/axil2axis.html">AXI stream</a>
compliant.</p>

<p><a href="/blog/2018/03/10/induction-exercise.html">Taming the induction
engine</a>
can be a bit of a challenge.  In this case, we
need to make certain that the various <code class="language-plaintext highlighter-rouge">ack</code>, <code class="language-plaintext highlighter-rouge">pipe</code>, <code class="language-plaintext highlighter-rouge">last</code>, and <code class="language-plaintext highlighter-rouge">req</code> signals
are consistent.  These registers essentially form a changed pulse, expressed
as a shift register, through time.  Therefore, let’s place these values
together into a shift register and make sure the shift register only takes
on acceptable values.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">gbl_clk</span><span class="p">)</span>
	<span class="k">case</span><span class="p">(</span><span class="o">{</span> <span class="n">a_ack</span><span class="p">,</span> <span class="n">a_pipe</span><span class="p">,</span> <span class="n">b_last</span><span class="p">,</span> <span class="n">b_req</span><span class="p">,</span> <span class="n">b_pipe</span><span class="p">,</span> <span class="n">a_req</span> <span class="o">}</span><span class="p">)</span>
	<span class="mb">6'b000_000</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b000_001</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b000_011</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b000_111</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b001_111</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b011_111</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b111_111</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b111_110</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b111_100</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b111_000</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b110_000</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b100_000</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="mb">6'b000_000</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="nl">default:</span> <span class="k">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">endcase</span></code></pre></figure>

<p>Incidentally, this was the assertion I changed to <code class="language-plaintext highlighter-rouge">always @(*)</code> in order
to demonstrate the problem in Fig. 7 above.</p>

<p>I personally like this <code class="language-plaintext highlighter-rouge">case</code> statement means of expressing this sort of
thought, and so I’ve used it often in many of my designs.</p>

<p>We have one final assertion–the one we’re doing this for, and that is that
the <code class="language-plaintext highlighter-rouge">a_data</code> register won’t be changed for at least one <code class="language-plaintext highlighter-rouge">i_b_clk</code> cycle
before it is read.  This guarantees that we won’t be suffering from any
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>
issues on the data register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_b_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;{</span><span class="n">b_req</span><span class="p">,</span> <span class="n">b_pipe</span><span class="o">}</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">{</span><span class="n">b_req</span><span class="p">,</span> <span class="n">b_pipe</span><span class="o">}</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">a_data</span><span class="p">));</span></code></pre></figure>

<p>For the most part, this proof is boiler plate.  It’s boiler plate
<a href="/blog/2017/10/20/cdc.html">clock domain crossing</a>
properties, boiler plate properties to describe something
synchronous with a clock, and boilerplate <a href="/dsp/2020/04/20/axil2axis.html">AXI stream
properties</a>.</p>

<p>What isn’t here is a property to verify the correctness of the output data,
nor any properties to prove that the number of outputs equals the number of
inputs.  For those, I’ve only desk checked the design so far.  At this point,
that’s been good enough, although I may need to come back and do a better
job of that as time goes on.</p>

<h2 id="cover-checks">Cover Checks</h2>

<p>That leaves us with only one question, how well does this design work?</p>

<p>To answer that question, I thought I might count the number of times a
valid is available and ready on the <code class="language-plaintext highlighter-rouge">b</code> outgoing interface.  Given that a
<code class="language-plaintext highlighter-rouge">cover()</code> check will return the <em>first</em> possible time an item becomes valid,
this should also be a good check of the speed of the interface as a whole.</p>

<p>Just for fun, I also added in the requirement that the outgoing data change
with the count of the number of outgoing items.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">cvr_stbcount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_b_clk</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_b_reset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_b_reset_n</span><span class="p">)</span>
		<span class="n">cvr_stbcount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o_b_valid</span> <span class="o">&amp;&amp;</span> <span class="n">i_b_ready</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">o_b_data</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cvr_stbcount</span><span class="p">))</span>
		<span class="n">cvr_stbcount</span> <span class="o">&lt;=</span> <span class="n">cvr_stbcount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>That left me with the ability to check throughput.  However, after my first
cover check, <code class="language-plaintext highlighter-rouge">cover(cvr_stbcount[3])</code> failed, I had to back up and start over.
I replaced that cover check therefore with several intermediate steps.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_stbcount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_stbcount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_stbcount</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_stbcount</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_stbcount</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>This allowed me to determine how many formal timesteps would be needed for
each step.  It also allowed me to answer the question of how much patience I
had.  In this case, five results required about nineteen seconds and six
<a href="/blog/2017/10/20/cdc.html">clock domain crossings</a>
weren’t really necessary.  (Eight might’ve taken into the next century.)</p>

<p>Here’s how the transfer looks.</p>

<table align="center" style="float: none"><caption>Fig 8. Cover trace illustrating performance</caption><tr><td><a href="/img/tfrvalue/cover-trace.png"><img src="/img/tfrvalue/cover-trace.png" alt="" width="780" /></a></td></tr></table>

<p>This is twice as fast as our previous method of moving data across clock
<a href="/blog/2017/10/20/cdc.html">clock domains</a>.
Just for reference, I’ve posted <a href="https://github.com/ZipCPU/website/blob/master/examples/tfrslow.v">the older, slower, 4-phase
implementation</a>
as well, and I’ve shown a before and after comparison below.</p>

<table align="center" style="float: none"><caption>Fig 9. Comparing the four phase and two phase CDC crossing approaches</caption><tr><td><a href="/img/tfrvalue/comparison-trace-annotated.png"><img src="/img/tfrvalue/comparison-trace-annotated.png" alt="" width="780" /></a></td></tr></table>

<p>Given that there’s little to no logic difference between the two phase and four
phase
<a href="/blog/2017/10/20/cdc.html">CDC</a> word transfers algorithms,
I think I’m going to recommend the two phase approach from now on.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The two-phase handshake method of moving values from <a href="/blog/2017/10/20/cdc.html">one clock domain to
another</a> isn’t about
speed.  It’s not.  If you want speed and throughput, use an <a href="/blog/2018/07/06/afifo.html">asynchronous
FIFO</a>.
This method is instead about moving data coherently from one clock domain to
another for a <em>minimum amount of logic</em>.  It works independent of the speed
of the two clocks: A can be faster, or B, it doesn’t matter, this method
will work both ways.  Indeed, we just proved that it would work for arbitrary
clocks A and B.</p>

<p>The fascinating part of this upgrade over the four-phase handshake is that
it is a <em>no cost upgrade</em> to our data transfer algorithm.  Whereas our prior
design used four <a href="/blog/2017/06/12/minimizing-luts.html">Xilinx
LUTs</a>, this new and
updated design also uses four LUTs while achieving twice the speed.</p>

<p>To this, I thank my reader for bringing this design approach to my attention.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For God hath not given us the spirit of fear, but of power, and of love, and of a sound mind. (2Tim 1:7)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
