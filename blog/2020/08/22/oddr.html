<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Driving an output on both edges of the clock</title>
  <meta name="description" content="Most FPGAvendor libraries include hardware I/O elements for driving a signal onboth edges of a clock.  I like to refer to these elements as ODDR modules,sinc...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2020/08/22/oddr.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Driving an output on both edges of the clock</h1>
    <p class="post-meta"><time datetime="2020-08-22T00:00:00-04:00" itemprop="datePublished">Aug 22, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Most <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
vendor libraries include hardware I/O elements for driving a signal on
both edges of a clock.  I like to refer to these elements as <em>ODDR</em> modules,
since they create a hardware <em>output</em> on both edges, i.e. <em>dual data rate</em>, of
a clock.  If you are building a design for an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
then I highly recommend that you use such a module.</p>

<p>Sadly, I recently found myself in a position where I couldn’t use a
pre-built ODDR on a project.  My favorite
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
vendor I/O libraries weren’t available to me.</p>

<p>Now what?</p>

<p>I needed to build my own hardware DDR output element.</p>

<p>Without a second thought, I scribbled out the following implementation:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">oddr</span><span class="p">(</span>
	<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_clk</span><span class="p">,</span>
	<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_en</span><span class="p">,</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_data</span><span class="p">,</span>
	<span class="kt">output</span>	<span class="kt">reg</span>		<span class="n">o_pad</span>
	<span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_en</span><span class="p">)</span>
		<span class="n">ddr_data</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">{</span><span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">}}</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ddr_data</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_clk</span><span class="p">)</span>
		<span class="n">o_pad</span> <span class="o">=</span> <span class="n">ddr_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">o_pad</span> <span class="o">=</span> <span class="n">ddr_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="k">endmodule</span></code></pre></figure>

<p>It wasn’t until some time later that I started wondering if this was really
the best way to handle the problem.</p>

<p>Here’s the missing subtlety: we <em>imagine</em>
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
data changing on a clock tick.
In reality, the clock rises and then only some fractional amount of time later
the actual data changes.  During this time between the clock rising and
the <code class="language-plaintext highlighter-rouge">ddr_data[1]</code> register changing, there’s the chance such a circuit might
create a <a href="https://en.wikipedia.org/wiki/Glitch">glitch</a>,
such as the one shown in Fig. 1 below.</p>

<table align="center" style="float: none"><caption>Fig 1. The naive implementation will create glitches</caption><tr><td><img src="/img/oddr/naive-glitch.svg" alt="" width="780" /></td></tr></table>

<p>That wasn’t what I wanted.</p>

<p>So I did some internet searching, and came across <a href="https://www.doe.carleton.ca/~shams/ELEC3500/hazards.pdf">this lecture on
hazards</a>.  I quickly
learned:</p>

<table align="center" style="float: right"><caption>Fig 2. The three types of logic hazards</caption><tr><td><img src="/img/oddr/hazard-types.svg" alt="" width="360" /></td></tr></table>

<ol>
  <li>
    <p>That there are three basic types of
<a href="https://en.wikipedia.org/wiki/Hazard_(logic)">hazards</a>, each of which
might produce a different type of
<a href="https://en.wikipedia.org/wiki/Glitch">glitch</a>.</p>
  </li>
  <li>
    <p>That with a bit of math, you could not only predict when a
<a href="https://en.wikipedia.org/wiki/Hazard_(logic)">hazard</a>
might take place, but also lean how to adjust your logic so no
<a href="https://en.wikipedia.org/wiki/Hazard_(logic)">hazard</a>
would be created.</p>
  </li>
</ol>

<p>That left me wondering, could I build something better by just paying attention
to a bit of math?</p>

<h2 id="first-draft">First Draft</h2>

<p>My first draft attempted to follow the same logic as my naive approach above.
First, I copied the data into a special register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">ddr_data</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_en</span><span class="p">)</span>
		<span class="n">ddr_data</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">{</span><span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">}}</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ddr_data</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">;</span></code></pre></figure>

<p>Then I needed to find a way to switch between halves of that register.</p>

<p>I thought I might use a <code class="language-plaintext highlighter-rouge">cycle</code> variable to capture which half of the clock
cycle I was in.  Someone suggested something like the following</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">cyclep</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">cyclep</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">cyclep</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">cyclen</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">negedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">cyclen</span> <span class="o">&lt;=</span> <span class="n">cyclep</span><span class="p">;</span></code></pre></figure>

<p>This would require clocking logic on both the positive and negative edges of
a given clock.  This is in general quite <em>bad</em>, however you are kind of stuck
with doing something on both edges of the clock to build a <a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.v">circuit like
this</a>
in the first place.  At least I was only looking at one register.</p>

<p>The last step would then select between which of two bits based upon
whether these two <code class="language-plaintext highlighter-rouge">cycle*</code> registers matched.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cyclep</span> <span class="o">^</span> <span class="n">cyclen</span><span class="p">)</span>
		<span class="n">o_pad</span> <span class="o">=</span> <span class="n">ddr_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">o_pad</span> <span class="o">=</span> <span class="n">ddr_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span></code></pre></figure>

<p>But was this better?</p>

<p>At this point, I tried applying the math from the <a href="https://www.doe.carleton.ca/~shams/ELEC3500/hazards.pdf">slides I had
found</a>.  This required
expressing my design as either a sum of products, or a product of sums.  So,
I rewrote the logic for <code class="language-plaintext highlighter-rouge">o_pad</code> as a sum (OR) of products (ANDs).</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_pad</span> <span class="o">=</span>    <span class="p">(</span><span class="n">ddr_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span>  <span class="n">cyclep</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cyclen</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">ddr_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cyclep</span> <span class="o">&amp;&amp;</span>  <span class="n">cyclen</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">ddr_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span>  <span class="n">cyclep</span> <span class="o">&amp;&amp;</span>  <span class="n">cyclen</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">ddr_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cyclep</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cyclen</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Now, if you suppose that <code class="language-plaintext highlighter-rouge">ddr_data[1] == ddr_data[0]</code>, and look for
<a href="https://en.wikipedia.org/wiki/Glitch">glitches</a>,
you’ll find a couple of static zero
<a href="https://en.wikipedia.org/wiki/Glitch">glitches</a>.</p>

<p><a href="https://www.doe.carleton.ca/~shams/ELEC3500/hazards.pdf">The same slides</a>
suggested that I should add a fifth term to avoid these
<a href="https://en.wikipedia.org/wiki/Hazard_(logic)">hazard</a>s.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_pad</span> <span class="o">=</span>    <span class="p">(</span><span class="n">ddr_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span>  <span class="n">cyclep</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cyclen</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">ddr_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cyclep</span> <span class="o">&amp;&amp;</span>  <span class="n">cyclen</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">ddr_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span>  <span class="n">cyclep</span> <span class="o">&amp;&amp;</span>  <span class="n">cyclen</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">ddr_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cyclep</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cyclen</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">ddr_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">ddr_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">end</span></code></pre></figure>

<p>By the time I got this far, I was feeling pretty proud of myself: I had just
discovered that my system would
<a href="https://en.wikipedia.org/wiki/Glitch">glitch</a>.
Not only that, I’d also figured out how to keep it from
<a href="https://en.wikipedia.org/wiki/Glitch">glitching</a>.</p>

<p>I was so proud of myself, that I wanted to see how this circuit would look.
So, I ran <a href="https://github.com/YosysHQ/yosys">Yosys</a> to get a peek at it.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% yosys <span class="nt">-p</span> <span class="s1">'read -sv oddr.v; synth -top oddr; show'</span></code></pre></figure>

<p>The result was Fig. 3 below.</p>

<table align="center" style="float: none"><caption>Fig 3. Circuit structure</caption><tr><td><a href="/img/oddr/yosys-show-draft-unopt.png"><img src="/img/oddr/yosys-show-draft-unopt.png" alt="" width="780" /></a></td></tr></table>

<p>If I stared hard enough at the figure, I could see all of my logic carefully
laid out within it.</p>

<p>Nice.</p>

<p>But then I got to wondering, what would the logic optimizer do to a circuit
like this?</p>

<p>So, I ran a pass of <a href="https://people.eecs.berkeley.edu/~alanmi/abc/">ABC</a>
followed by the <a href="https://github.com/YosysHQ/yosys">Yosys</a> optimizer.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% yosys <span class="nt">-p</span> <span class="s1">'read -sv oddr.v; synth -top oddr; abc; opt; show'</span></code></pre></figure>

<table align="center" style="float: none"><caption>Fig 4. Circuit after optimization</caption><tr><td><a href="/img/oddr/yosys-show-draft.png"><img src="/img/oddr/yosys-show-draft.png" alt="" width="780" /></a></td></tr></table>

<p>The result was that all my special glitch-reducing logic had been removed.
It was redundant.  Sure, the optimizer did what I would expect, but how should
I now fix my circuit?</p>

<p>Worse, as I looked over my draft further, I could quickly see that this
combinatorial equation was much more complicated than I would ever want to
have driving the output of a chip.  There was just too much room for error.</p>

<p>I needed something simpler.</p>

<h2 id="a-better-approach">A Better Approach</h2>

<p>Here was the rub: no matter how I built the circuit, I was going to need
some combinatorial logic past the last clock.  Further, if I wanted to avoid
using the clock itself in my output, then I was going to need to transition
on both edges of the clock.  There was no way around that.</p>

<p>This left me with the following structure.</p>

<ol>
  <li>First, I would need to do something
to my inputs, to transform them somehow into local registers to
<a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.v">this module</a>.
This would happen on the positive edge of the clock–and would work like any
other piece of logic I might use in my design.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">positive_edge_logic</span> <span class="o">=</span> <span class="n">f0</span><span class="p">(</span><span class="n">inputs</span><span class="p">);</span></code></pre></figure>

<ol start="2">
  <li>I would then need to move one of those pieces of logic from the positive
to the negative edge of the clock.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">negedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">negative_edge_logic</span> <span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="n">positive_edge_logic</span><span class="p">);</span></code></pre></figure>

<p>Although I’ve shown this as a predicate logic function, <code class="language-plaintext highlighter-rouge">f1</code>, in reality this
needs to be just a register copy since time is important and I want to make
certain that nothing gets lost in this translation–especially since I’m
not sure how well I trust my tools to handle this logic.</p>

<ol start="3">
  <li>The third step would then be some form of logic function on the two halves:
the logic generated on the positive edge of the clock and the logic created on
the negative edge.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">o_pad</span> <span class="o">=</span> <span class="n">f2</span><span class="p">(</span><span class="n">positive_edge_logic</span><span class="p">,</span> <span class="n">negative_edge_logic</span><span class="p">);</span></code></pre></figure>

<table align="center" style="float: left"><caption>Fig 5. Partial circuit design</caption><tr><td><img src="/img/oddr/oddrfn.svg" alt="" width="360" /></td></tr></table>

<p>I also wanted to keep this third function simple.  Something that would not only
be <a href="https://en.wikipedia.org/wiki/Glitch">glitch</a> free,
but would also be simple enough to not have a lot of logic
delays within it.  While both <code class="language-plaintext highlighter-rouge">AND</code> and <code class="language-plaintext highlighter-rouge">OR</code> might work individually, they
would both require the inputs change on both edges of the clock–there would
be no way to “undo” the output from one clock half once the next clock half
arrived.  In the end, I decided that <code class="language-plaintext highlighter-rouge">f2</code> above needed to be an
<a href="https://en.wikipedia.org/wiki/Exclusive_or">exclusive OR (XOR)</a>
function–especially since an
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> can be accomplished
simply with a small number of transitors.  Not only that, it’s a basic
<a href="https://en.wikipedia.org/wiki/Standard_cell">standard cell</a> element in most
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> logic libraries.</p>

<p>That left me with something like Fig. 5 above and on the left and written
out below,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cnp</span> <span class="o">}</span> <span class="o">=</span> <span class="n">f0</span><span class="p">(</span><span class="n">inputs</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">negedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">cn</span> <span class="o">&lt;=</span> <span class="n">cnp</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">o_pad</span> <span class="o">=</span> <span class="n">cp</span> <span class="o">^</span> <span class="n">cn</span><span class="p">;</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">cp</code> and <code class="language-plaintext highlighter-rouge">cn</code> would be the outputs of
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
set on positive and negative edges of the clock respectively.  <code class="language-plaintext highlighter-rouge">cnp</code>, on the
other hand, would be an intermediate result used to pre-calculate the logic
for the negative
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>.</p>

<p>But what should I use for the positive clock edge logic?</p>

<p>For that, I worked both clock phases out independently.</p>

<p>For the first phase of the clock, I’d be able to control the <code class="language-plaintext highlighter-rouge">cp</code> of the
<code class="language-plaintext highlighter-rouge">cp ^ cn</code> function.  In order to output the first data element on the
positive edge of the clock, I only needed to annihilate the <code class="language-plaintext highlighter-rouge">cn</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">cp</span>  <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">cn</span><span class="p">;</span></code></pre></figure>

<p>Unfortunately, this made for a second and unnecessary clock domain crossing,
from the negative edge of the clock to the positive edge.  On the other hand,
<code class="language-plaintext highlighter-rouge">cn</code> was just a copy of <code class="language-plaintext highlighter-rouge">cnp</code> from the prior positive edge of the clock,
so I could just as easily reference <code class="language-plaintext highlighter-rouge">cnp</code> instead without incurring any 
additional edge-to-edge crossings.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">cp</span>  <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">cnp</span><span class="p">;</span></code></pre></figure>

<p>Generating an equation to set <code class="language-plaintext highlighter-rouge">cnp</code> would’ve been just as easy, except I needed
the new value of <code class="language-plaintext highlighter-rouge">cnp</code> to depend upon the result of <code class="language-plaintext highlighter-rouge">cp</code> which was still being
calculated on this same clock period.  If I just place a parenthesis around the
new <code class="language-plaintext highlighter-rouge">cp</code> value, then the equation becomes almost identical as the one for <code class="language-plaintext highlighter-rouge">cp</code>
above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">cp</span>  <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="p">(</span><span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">cnp</span><span class="p">);</span></code></pre></figure>

<p>But would it work?</p>

<p>To double check my work, I fired up
<a href="https://github.com/YosysHQ/SymbiYosys">SymbiYosys</a>.</p>

<p>No, <a href="https://github.com/YosysHQ/SymbiYosys">SymbiYosys</a> can’t handle analog
logic–which is really what this attempt at
<a href="https://en.wikipedia.org/wiki/Glitch">glitch</a>-free
logic is.  However, it can handle digital logic on both halves of a clock.
That was what I wanted here for a quick check.</p>

<h2 id="formal-methods-check">Formal methods check</h2>

<p>Thankfully, the formal check of <a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.v">this
logic</a> is fairly easy.  The first step is
to use the <a href="https://symbiyosys.readthedocs.io/en/latest/reference.html#options-section"><code class="language-plaintext highlighter-rouge">multiclock on</code> option</a> within the
<a href="https://github.com/YosysHQ/SymbiYosys">SymbiYosys</a>
<a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.sby">configuration file</a>.
Once done, you’ll need to <a href="/formal/2018/05/31/clkswitch.html">assume the existence of a toggling
clock</a>–taking
two formal timesteps per clock cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="p">(</span><span class="o">*</span> <span class="n">gclk</span> <span class="o">*</span><span class="p">)</span> <span class="kt">reg</span>	<span class="n">gbl_clk</span><span class="p">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_data</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">gbl_clk</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_clk</span> <span class="o">!=</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_clk</span><span class="p">));</span></code></pre></figure>

<p>I then needed to assume the inputs were clock synchronous.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">gbl_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_clk</span><span class="p">))</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="o">{</span> <span class="n">i_en</span><span class="p">,</span> <span class="n">i_data</span> <span class="o">}</span><span class="p">));</span></code></pre></figure>

<p>Or, rather, I forgot to include this assumption at first and then got surprised
when the result wasn’t what I wanted.  When the design then failed,
resulting in a trace where the inputs didn’t “look” right,
I figured I should add the assumption above.</p>

<p>The last step to setting up the problem was to keep track of the bits I wanted
to output.  I used a quick two-bit register, <code class="language-plaintext highlighter-rouge">f_data</code>, for this purpose.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_data</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">f_data</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">;</span></code></pre></figure>

<p>The last step was the assertion: I wanted to make certain that the result
was correct on each half of the clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_clk</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_pad</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">else</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_pad</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span></code></pre></figure>

<p>Yes, this looks just like the logic I started with that I am trying to replace.</p>

<p>Indeed, it did do–although I did initially need to skip the first couple of
time-steps until everything sync’d up.  Still, it worked quite nicely to
help me figure out what I was doing right and wrong.</p>

<h2 id="polishing-off-the-design">Polishing off the design</h2>

<p>The last step was to implement the “off” function, where the
<a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.v">ODDR module</a>
wasn’t enabled.  My first thought was that I should keep the output from
toggling when not enabled.  A second thought was that I should just set the
pins to the first bit of input.</p>

<p>Adjusting <code class="language-plaintext highlighter-rouge">f_data</code> was the easiest way to at least describe what I wanted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_en</span><span class="p">)</span>
		<span class="n">f_data</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">{</span><span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">}}</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">f_data</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">;</span></code></pre></figure>

<p>From here, I could design something that met my formal criteria and
<a href="https://github.com/YosysHQ/SymbiYosys">SymbiYosys</a>
could then tell me if I got it right or not.</p>

<p>My first draft for <a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.v">this
logic</a> was just
to set everything to a constant if ever the enable input was low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_en</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cnp</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">?</span> <span class="mb">2'b01</span> <span class="o">:</span> <span class="mb">2'b00</span><span class="p">;</span>
	<span class="k">else</span> <span class="c1">// ...</span></code></pre></figure>

<p>Only … this didn’t pass the formal check.</p>

<p>After a little bit of floundering, I realized I would have to build this based
upon <code class="language-plaintext highlighter-rouge">cnp</code>.  That led me instead to the following logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_en</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="o">{</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cnp</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">cnp</span><span class="p">)</span> <span class="o">?</span> <span class="mb">2'b01</span> <span class="o">:</span> <span class="mb">2'b10</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">{</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cnp</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">cnp</span><span class="p">)</span> <span class="o">?</span> <span class="mb">2'b11</span> <span class="o">:</span> <span class="mb">2'b00</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="n">cp</span>  <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">cnp</span><span class="p">;</span>
		<span class="n">cnp</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">i_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">cnp</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Even better, <a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.v">the
result</a>
is pretty simple logically.  It only requires three
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> elements, three
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>,
and a mux.  Even better, as designed above, the output is driven by an
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> of two
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a> outputs.</p>

<table align="center" style="float: none"><caption>Fig 6. Final circuit</caption><tr><td><a href="/img/oddr/yosys-show.png"><img src="/img/oddr/yosys-show.png" alt="" width="780" /></a></td></tr></table>

<p>Not only that, <a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.v">this
circuit</a> will
not <a href="https://en.wikipedia.org/wiki/Glitch">glitch</a>–assuming the
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>
can be implemented as a single gate.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This entire exercise was a lot of fun, and I learned a lot about <a href="https://www.doe.carleton.ca/~shams/ELEC3500/hazards.pdf">glitchless
logic</a>
in the process.</p>

<p>How practical is <a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.v">this
design</a>?  Well,
it’s not portable to any
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s.  Indeed,
I wouldn’t use it on an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
at all.  There are better structures on
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s,
and those structures are ideally placed on the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
to handle final timing properly.</p>

<p>See, that’s the big problem with <a href="https://github.com/ZipCPU/website/blob/master/examples/oddr.v">this
design</a>:
it’s highly susceptible to placement.  Were the
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> placed on the opposite
side of the chip from the pad it is driving, you might easily have multiple
pins transitioning on apparently separate clocks.  Even if the
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> were placed next to the pad,
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a> placement
will adjust both clock period and phase.  That means that in order to make this
work properly, you’ll need to make certain that both the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s and the
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>
are placed right next to the output pad.  That places further requirements on
the tools you use and what they need to support in order to make this happen.</p>

<p>So, is this doable?  Absolutely!  Is the task done?  Far from it.  Still, it
was a fun distraction for a evening.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Are not two sparrows sold for a farthing? and one of them shall not fall on the ground without your Father. (Matthew 10:29)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
