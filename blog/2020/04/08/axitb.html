<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Adding an AXI-Lite interface to your Verilator test script</title>
  <meta name="description" content="It should come as no surprise to anyone that I like working withVerilator.In sum: Verilator is faster than most if not all other Verilog simulatorsout there....">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2020/04/08/axitb.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Adding an AXI-Lite interface to your Verilator test script</h1>
    <p class="post-meta"><time datetime="2020-04-08T00:00:00-04:00" itemprop="datePublished">Apr 8, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>It should come as no surprise to anyone that I like working with
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>.
In sum: <a href="https://www.youtube.com/watch?v=en8JMz7v3LU">Verilator is faster than most if not all other Verilog simulators
out there</a>.  It achieves this
high speed in part by not supporting <code class="language-plaintext highlighter-rouge">1'bz</code> or <code class="language-plaintext highlighter-rouge">1'bx</code>, nor does it support
statements with delays in them like, “a &lt;= #5 b;”.  This doesn’t bother me
much, since delays and <code class="language-plaintext highlighter-rouge">1'bx</code> values <a href="/blog/2018/08/04/sim-mismatch.html">aren’t really synthesizable
anyway</a>.</p>

<p>No, where
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a> really
shines is in its software interface.  With my own background in software, I feel
at home working in software and so I feel at home working with
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>.
Using
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>’s
software interface, it’s been easy to integrate hardware emulation into my
simulations.  This is <a href="/blog/2018/08/22/what-is-simulation.html">something we’ve covered
before</a>.  Indeed,
I’m not sure how I would have debugged a compressed video decoder without
being able to <a href="/blog/2018/11/29/llvga.html">visualize the resulting
video</a> to know if the core I
was testing was working or not.</p>

<p><a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
also shines when you are trying to <a href="/blog/2020/04/01/design-flow.html">simulate the interaction of a CPU
with your design</a>.
No, it’s not quite everything I would want: what I really want for testing a
CPU’s interface to my design is something where I can issue memory reads and
writes to my design-implemented registers as though those registers were part
of my own memory space.  While we won’t quite get there with today’s example,
we’ll get pretty close.  We might even get close enough that <a href="/blog/2018/11/03/soc-fpga.html">with a little
work</a>
you could directly port your C++ test program to your
<a href="/about/zipcpu.html">ZipCPU</a>
(or MicroBlaze/Nios/Zynq/SoC) and know that it’s going to work.</p>

<p>Today, I want to share with you how you might go about driving a
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
of your design from an
<a href="/formal/2018/12/28/axilite.html">AXI-Lite</a>
control port into the same design.</p>

<h2 id="the-need">The Need</h2>

<p>To understand why you might want to drive a
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
using an
<a href="/formal/2018/12/28/axilite.html">AXI-Lite</a>
control port, consider the task I was struggling with last month: I’d built an
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">AXI DMA
controller</a>,
and it wasn’t passing all of my <code class="language-plaintext highlighter-rouge">cover()</code> checks.</p>

<p>That’s not good.</p>

<p>To make matters worse, it’s not often clear what causes a <code class="language-plaintext highlighter-rouge">cover()</code> statement to
fail.  Unlike assertion failures, <code class="language-plaintext highlighter-rouge">cover()</code> failures don’t normally produce a
<a href="/blog/2017/07/31/vcd.html">trace</a>
identifying the line of code and the step in your
<a href="/blog/2017/07/31/vcd.html">trace</a> where your design first
failed.  No, when a <code class="language-plaintext highlighter-rouge">cover()</code> statement fails it just fails.
You as the designer get to know which <code class="language-plaintext highlighter-rouge">cover()</code> statement failed, but not why.
Worse, <code class="language-plaintext highlighter-rouge">cover()</code> statements don’t fail until the formal solver has exhaustively
checked every one of the number of steps you’ve asked for to see if there’s
one, any one, possible way the <code class="language-plaintext highlighter-rouge">cover()</code> statement might be made true.  Sorry,
there’s no early “I can’t get there” terminations.</p>

<p>Why might a <code class="language-plaintext highlighter-rouge">cover()</code> property fail?  It might be that your logic is broken.
It might also be that your <code class="language-plaintext highlighter-rouge">cover()</code> property is broken, or that you aren’t
looking far enough into the future.  (I suffered from both.)  That said, after
six hours of running any tool, I’ve looked “far enough” into the future and
if the <code class="language-plaintext highlighter-rouge">cover()</code> property hasn’t passed, it’s time to figure out why not.  Did
I say six hours?  I’d prefer five minutes.  Once things worked, 20 minutes
turned out to be sufficient–but that’s part of another story.</p>

<p>In my case, the <code class="language-plaintext highlighter-rouge">cover()</code> check was failing because
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">the DMA</a>
was accomplishing <em>most</em> of the transfer and then hanging for certain
combinations of transfers needing realignment.  Without a
<a href="/blog/2017/07/31/vcd.html">trace</a>
to <em>see</em> what was going on, I got lucky with a guess that figured out what
was happening.  I don’t want to depend on getting lucky.  I needed
another way of figuring out what was going on.</p>

<p>That’s just part of the story though.</p>

<p>The other part of the story is that I’ve recently finished building several
DMA implementations, and I don’t really have a design that will showcase
these components.  These include new
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">MM2S</a>,
and <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">DMA (MM2MM)</a>
data movers.</p>

<p>But what kind of design would showcase multiple
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>
components?</p>

<p>Obviously, we’d need some memory to transfer data to or from.  Our <a href="/blog/2019/05/29/demoaxi.html">AXI
(full) demonstrator core</a>
should fit this role quite nicely.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> cores also
need a controller to tell them from where to make their copies, and how many
bytes to copy.  So we’ll need to add an <a href="/blog/2020/03/23/wbm2axisp.html">AXI
master</a> test controller
to this mix as well.</p>

<table align="center" style="float: none"><caption>Fig 1. Pieces of a multi-DMA test bench</caption><tr><td><img src="/img/axitb/random-components.svg" alt="" width="780" /></td></tr></table>

<p>Of course, random components don’t do anyone any good.  Something needs
to connect them together, and that’s the purpose of the
<a href="/blog/2019/07/17/crossbar.html">AXI interconnect</a> we’ll
add into our test set as well.  Such an
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> can be used
to arbitrate between which component had access to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> at any given time.
Normally, I’d say that’s too hard to do, but I’d recently built my own <a href="/blog/2019/07/17/crossbar.html">AXI
interconnect</a>,
so let’s add trying that out to our to do list as well.</p>

<p>That gets us a touch farther along, but we’re not quite there yet.</p>

<table align="center" style="float: none"><caption>Fig 2. Using an interconnect to connect components</caption><tr><td><img src="/img/axitb/partial-interconnect.svg" alt="" width="780" /></td></tr></table>

<p>The problem is that each of my DMA
cores has a control port to control the copy: where to to copy from, where
to copy to, how much to copy, etc.  This control port doesn’t support the
<a href="/blog/2019/05/29/demoaxi.html">full AXI protocol</a>,
but rather the
<a href="/blog/2020/03/08/easyaxil.html">AXI4-lite</a>
subset alone.  My
<a href="/blog/2019/07/17/crossbar.html">AXI interconnect</a>
doesn’t connect to
<a href="/blog/2020/03/08/easyaxil.html">AXI4-lite</a> slaves.
No, the <a href="/blog/2019/07/17/crossbar.html">AXI interconnect</a>
I’ve built will connect
<a href="/blog/2020/03/23/wbm2axisp.html">AXI4 masters</a> to
<a href="/blog/2019/05/29/demoaxi.html">AXI4 slaves</a>, not to a set of
<a href="/blog/2020/03/08/easyaxil.html">AXI4-lite</a> control ports.
If we want to interact with those various control ports, then we’ll need a
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">bridge from AXI to
AXI-Lite</a>
in order to drive these registers.</p>

<p>Ok, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">AXI to AXI-lite bridge, got
that</a>.</p>

<p>What else?  How about an <a href="/zipcpu/2019/08/30/subbus.html">AXI-lite bus
simplifier</a>
that can lump all of my <a href="/formal/2018/12/28/axilite.html">AXI-lite
peripherals</a> together and
act as a sort of <a href="/blog/2019/07/17/crossbar.html">AXI-lite
crossbar</a>?</p>

<table align="center" style="float: none"><caption>Fig 3. Connecting the AXI-lite control ports</caption><tr><td><img src="/img/axitb/axilite-simplified.svg" alt="" width="780" /></td></tr></table>

<p>Ok, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axildouble.v">got that
too</a>.</p>

<p>What else?</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 4. AXI Signals</caption><tr><td><img src="/img/tweets/axi-signals.png" alt="" width="375" /></td></tr></table>

<p>We’d also need a way of composing the entire design together.  One of the sad
realities of
<a href="/doc/axi-spec.pdf">AXI</a>
is that with the number of wires that compose an
<a href="/doc/axi-spec.pdf">AXI bus</a>,
just connecting two components together is a recipe for a lot of typing–not
to mention a lot of errors should anything go wrong, and that’s only two
components.  To put something like this together, you’d need to connect at
least eighteen
<a href="/doc/axi-spec.pdf">AXI</a>
interfaces together and we’re not done yet.</p>

<p>This is the point where you can use <a href="https://www.intel.com/content/www/us/en/programmable/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html">Intel’s platform
designer</a>
or <a href="https://www.xilinx.com/content/dam/xilinx/support/documentation/sw_manuals/xilinx2019_2/ug995-vivado-ip-subsystems-tutorial.pdf">Xilinx’s IP integrator</a>.
The problem is that, once you are done, you’ll have a design that can’t be used
with <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>,
nor can it be easily moved from one
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
(or <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>)
environment to another.  No, a cross platform tool that allows us to keep our
design in Verilog would be preferrable.</p>

<p>The good news here is that we can use
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
to connect <a href="/doc/axi-spec.pdf">AXI</a>
interfaces together.  <a href="https://github.com/ZipCPU/autofpga/commit/b6f2e206cfd3a880eb1be488c71a9e61a36a6cce">AXI support with AutoFPGA is still
fairly new</a>,
but it would be worth checking out.  (Hint: AXI support is currently only found
in the <a href="https://github.com/ZipCPU/autofpga/tree/dev/">dev branch</a>.)</p>

<p>Those are the hard parts.  The other details are easier.</p>

<h3 id="the-stream-source">The Stream Source</h3>

<p>To test an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">AXI stream to memory
copy</a>,
we’ll need a <a href="https://github.com/ZipCPU/axidmacheck/blob/master/autodata/streamsrc.txt">stream
source</a>
in addition to our <a href="/blog/2019/05/29/demoaxi.html">memory
component</a>.
For this, a simple counter will work nicely.  That will also allow us to measure
both how long the stream copy took, as well as whether or not any words were
lost along the way.  The code for this is simple enough that we might just
want to copy it directly into our <a href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/main.v">main design
file</a>.  We can
do that using the <code class="language-plaintext highlighter-rouge">MAIN.INSERT</code> tag in an
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
<a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsrc.txt#L44-L63">configuration file</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">tvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">tvalid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">tlast</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">counter</span> <span class="o">&lt;=</span> <span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">tvalid</span> <span class="o">||</span> <span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">tready</span><span class="p">)</span>
		<span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">tdata</span> <span class="o">&lt;=</span> <span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="mi">_</span><span class="n">counter</span><span class="p">;</span></code></pre></figure>

<p>In <a href="https://github.com/ZipCPU/axidmacheck/blob/master/autodata/streamsrc.txt">this example</a>,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
will replace the <code class="language-plaintext highlighter-rouge">@$(PREFIX)</code> tags with the <a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsrc.txt#L38">name of this
core</a>.
Using name prefixes like this forms a sort of poor man’s variable scoping.
I say “poor man’s” since nothing really prevents another core from stomping
on these register names, since these lines will eventually all get pasted into
the same <a href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/main.v">main.v</a>
file as all of the other <code class="language-plaintext highlighter-rouge">MAIN.INSERT</code> blocks from all of the other components.</p>

<p>But what does this logic do?  The most important parts are the counter and
the <code class="language-plaintext highlighter-rouge">TDATA</code> values.  The counter always counts up on every clock tick,
eventually wrapping around at <code class="language-plaintext highlighter-rouge">2^32</code> clock ticks.  The <code class="language-plaintext highlighter-rouge">TDATA</code> logic sets our
data to be equal to the counter any time the source isn’t stalled.</p>

<p>The result is that this stream source will gladly drop data values if the
memory copy can’t keep up.  Once the memory transfers start again, we’ll be
able to tell from the counter how many clock ticks took place that did
(or didn’t) transfer memory.</p>

<p>If you browse through the
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/autodata/streamsrc.txt">configuration file</a>,
you’ll notice only two other tags defined.  Those are the <a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsrc.txt#L38"><code class="language-plaintext highlighter-rouge">PREFIX</code>
tag</a>,
giving a name to our element, and the
<a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsrc.txt#L39-L43"><code class="language-plaintext highlighter-rouge">MAIN.DEFNS</code> tag</a>–allowing
us to copy
our register definitions to the top of our
<a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/rtl/main.v#L164-L167">main.v</a>
logic file.</p>

<h3 id="the-stream-sink">The Stream Sink</h3>

<p>In a similar fashion, if we want to test <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">a memory to stream
copy</a>, we’d need a
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/streamcounter.v">stream sink</a>.
Perhaps we can build <a href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/streamcounter.v">something that measures
performance</a>
in this case, so that we can see how well and fast <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">our
copy</a> works.</p>

<p>Remember, what’s the goal when working with
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s?
Speed!  That’s one of the reasons why you are using an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
in the first place, right?  It’s also one of the greatest strengths of
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s.
But what good is speed if you waste it on a poor
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> implementation?  For
this reason, if none other, it would be worthwhile to check out via
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
just how fast the overall
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> implementation is.</p>

<table align="center" style="float: right"><caption>Fig 5. Measuring AXI stream performance</caption><tr><td><img src="/img/axitb/stream-measures.svg" alt="" width="360" /></td></tr></table>

<p>What measures might we use?  I picked three simple ones.</p>

<ol>
  <li>The number of beats of information that have been transferred in total.
This would be a count of <code class="language-plaintext highlighter-rouge">TVALID &amp;&amp; TREADY</code> cycles.</li>
  <li>The number of packets.  This would be a count of <code class="language-plaintext highlighter-rouge">TVALID &amp;&amp; TREADY &amp;&amp; TLAST</code>.</li>
  <li>The number of clocks taken from the first beat to the last.  This would be
a counter with a reset, that starts running upon the first beat of any
transfer, and whose value gets copied on any <code class="language-plaintext highlighter-rouge">TVALID &amp;&amp; TREADY</code> clock cycle.</li>
</ol>

<p>For this, I’ll use a simple
<a href="/formal/2018/12/28/axilite.html">AXI-Lite slave</a>,
much like the <a href="/blog/2020/03/08/easyaxil.html">Easy AXI-lite slave I posted a while
back</a>,
but this time with <a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/rtl/streamcounter.v#L221-L256">our
measures</a> within it.</p>

<p>In this case, the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
<a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsink.txt">configuration file</a>
also includes the information within it necessary to connect us to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.  First, we tell
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
that we want to be a slave of an AXI-Lite bus that I’ve named <code class="language-plaintext highlighter-rouge">axil</code>, and
that our design will have four addressable (word) registers within it.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@PREFIX=streamsink
@NADDR=4
@SLAVE.BUS=axil
@SLAVE.TYPE=DOUBLE</code></pre></figure>

<p>Moreover, the <code class="language-plaintext highlighter-rouge">@SLAVE.TYPE=DOUBLE</code> announces that this will be a <a href="/zipcpu/2019/08/30/subbus.html"><em>simplified</em>
AXI-lite slave that can share it’s bus logic with other AXI-lite
slaves</a>.</p>

<p>Connecting this component to our design is as simple as instantiating the
component within our design.  It’s really just a matter of hooking wires up
together.  While this would normally be quite tedious,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
attempts to simplify the task–as you’ll see in a moment.</p>

<p>We’ll first give our <a href="http://www.mrc.uidaho.edu/mrc/people/jff/EO_440/Handouts/AMBA%20Protocols/AXI-Stream/IHI0051A_amba4_axi4_stream_v1_0_protocol_spec.pdf">AXI stream</a>
a name.  The <code class="language-plaintext highlighter-rouge">@$(PREFIX)</code> of this component gives us a nice (hopefully) unique
name we can work with.  (If it’s not unique, we can easily change it later.)</p>

<p>We can also define tags specific to this
<a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsink.txt">configuration file</a>,
sort of like local variables if you will.  Here, we define the name of the
<code class="language-plaintext highlighter-rouge">STREAM</code> we are going to consume.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@STREAM=@$(PREFIX)</code></pre></figure>

<p>Now when we reference <code class="language-plaintext highlighter-rouge">@$(STREAM)</code>, it will get replaced with the name of this
component–currently set by the <a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsink.txt#L38"><code class="language-plaintext highlighter-rouge">@PREFIX=streamsink</code> statement
above</a>.</p>

<p>The following <a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/autodata/streamsink.txt#L46-L61"><code class="language-plaintext highlighter-rouge">MAIN.INSERT</code> tag
</a>
then just <a href="https://github.com/ZipCPU/axidmacheck/blob/75ca30f582491f5358e0881fb846f5cfd0f4b3cb/rtl/main.v#L1525-L1560">copies logic into our
main.v</a>
logic file, while substituting any <code class="language-plaintext highlighter-rouge">@$(X)</code> constructs with whatever the meaning
we’ve given to <code class="language-plaintext highlighter-rouge">X</code> is.  That includes the clock associated with our bus, as
well as the reset signal for the bus.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">streamcounter</span> <span class="p">#(</span>
		<span class="p">.</span><span class="n">C_AXIS_DATA_WIDTH</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
		<span class="p">.</span><span class="n">OPT_LOWPOWER</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">)</span>
	<span class="p">)</span> <span class="o">@</span><span class="p">$(</span><span class="n">PREFIX</span><span class="p">)</span><span class="n">i</span> <span class="p">(</span>
		<span class="p">.</span><span class="n">S_AXI_ACLK</span><span class="p">(</span><span class="o">@</span><span class="p">$(</span><span class="n">SLAVE</span><span class="p">.</span><span class="n">BUS</span><span class="p">.</span><span class="n">CLOCK</span><span class="p">.</span><span class="n">WIRE</span><span class="p">)),</span>
		<span class="p">.</span><span class="n">S_AXI_ARESETN</span><span class="p">(</span><span class="o">@</span><span class="p">$(</span><span class="n">SLAVE</span><span class="p">.</span><span class="n">BUS</span><span class="p">.</span><span class="n">RESET</span><span class="p">)),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">S_AXIS_TVALID</span><span class="p">(</span><span class="o">@</span><span class="p">$(</span><span class="n">STREAM</span><span class="p">)</span><span class="mi">_</span><span class="n">tvalid</span><span class="p">),</span>
		<span class="p">.</span><span class="n">S_AXIS_TREADY</span><span class="p">(</span><span class="o">@</span><span class="p">$(</span><span class="n">STREAM</span><span class="p">)</span><span class="mi">_</span><span class="n">tready</span><span class="p">),</span>
		<span class="p">.</span><span class="n">S_AXIS_TDATA</span><span class="p">(</span><span class="o">@</span><span class="p">$(</span><span class="n">STREAM</span><span class="p">)</span><span class="mi">_</span><span class="n">tdata</span><span class="p">),</span>
		<span class="p">.</span><span class="n">S_AXIS_TLAST</span><span class="p">(</span><span class="o">@</span><span class="p">$(</span><span class="n">STREAM</span><span class="p">)</span><span class="mi">_</span><span class="n">tlast</span><span class="p">),</span>
		<span class="c1">//</span></code></pre></figure>

<p>Now comes the hard part … enumerating all of those annoying AXI signals–most
of which we aren’t using anyway.  To make this easier,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
automatically defines a <a href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L310"><code class="language-plaintext highlighter-rouge">SLAVE.ANSIPORTLIST</code> tag</a>
for every bus slave.  If we
just reference that,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
will do the rest of the work for us.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="o">@</span><span class="p">$(</span><span class="n">SLAVE</span><span class="p">.</span><span class="n">ANSIPORTLIST</span><span class="p">)</span>
	<span class="p">);</span></code></pre></figure>

<p>After variable expansion, <a href="https://github.com/ZipCPU/axidmacheck/blob/77911683d1fd0e547629058342c972c673cea57f/rtl/main.v#L1544-L1566">these lines will get copied
directly</a>
into our
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/main.v">main.v</a>
file and we’ll be back to working in Verilog again.</p>

<p>We’ll need one more piece to this file before we are done with it, and that
is that we need to declare names for our three control words so that we can
<a href="https://github.com/ZipCPU/axidmacheck/blob/77911683d1fd0e547629058342c972c673cea57f/sw/regdefs.h#L58-L60">reference their addresses by name</a>
later.  In this case, we have three control
words at offsets of <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">4</code>, and <code class="language-plaintext highlighter-rouge">8</code> bytes from the base address.  We can
give these words names <code class="language-plaintext highlighter-rouge">R_STREAMSINK_BEATS</code>, <code class="language-plaintext highlighter-rouge">R_STREAMSINK_PACKETS</code>, and
<code class="language-plaintext highlighter-rouge">R_STREAMSINK_CLOCKS</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@REGS.N=3
@REGS.0=0 R_STREAMSINK_BEATS   BEATS
@REGS.1=1 R_STREAMSINK_PACKETS PACKETS
@REGS.2=2 R_STREAMSINK_CLOCKS  CLOCKS</code></pre></figure>

<table align="center" style="float: left; padding: 15px"><caption>Fig 6. A Shopping-List for this design</caption><tr><td><img src="/img/axitb/shopping-list.svg" alt="" width="360" /></td></tr></table>

<p><a href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/streamcounter.v">This stream sink component</a>
is now ready for assembly into the
<a href="https://github.com/ZipCPU/axidmacheck">full DMA checking core</a>.</p>

<p>Put together, though, we now have quite the shopping list of components to work
with, as shown in Fig. 6.  We’ve gone from needing to test just a simple set of
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA controllers</a>,
to a much larger, bigger, and more complex design.  The
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA controllers</a>
needed memory, and then we needed a
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> to tie all of our
components together.  Even that wasn’t enough, since we needed to control
the AXI-lite control ports of the various
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA controllers</a>, meaning
that we also needed an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">AXI to AXI-lite
bridge</a>.
We then added in our <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axildouble.v">bus
simplifier</a>.
What I haven’t mentioned is that, because I intend to drive this from an
AXI-Lite script, I’m also going to need an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilite2axi.v">AXI-lite to AXI
bridge</a>.</p>

<p>There’s only a little bit of requirements creep here, right?
All that’s left now is the infamous “Some assembly required,” followed by
giving it all a good shakedown to convince ourselves that everything
really works like it’s supposed to.</p>

<h3 id="assembly">Assembly</h3>

<p>So, if <a href="https://github.com/ZipCPU/axidmacheck">we put everything together</a>,
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/doc/block-diagram.png">here’s the system
diagram</a>
I came up with.</p>

<table align="center" style="float: none"><caption>Fig 7. An AXI DMA test bench</caption><tr><td><img src="/img/axi-dma/dma-tb.svg" alt="" width="780" /></td></tr></table>

<p><a href="https://github.com/ZipCPU/axidmacheck/blob/master/doc/block-diagram.png">In this
figure</a>,
I’ve tried to place the <a href="/blog/2020/03/23/wbm2axisp.html">AXI
masters</a> above the
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>
and the slaves beneath it, but this approach falls apart somewhat for the
simple reason that these
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA controllers</a>
are both
<a href="/blog/2020/03/23/wbm2axisp.html">masters</a> and
<a href="/blog/2019/05/29/demoaxi.html">slaves</a>.  They have a
<a href="/blog/2020/03/23/wbm2axisp.html">full master</a>
interface for doing the memory copies, so I’d like to place them above the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
yet they also have a control interface placing them as slaves below the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>.</p>

<p>Still, although it looks complex, it’s nothing more than what we discussed
above.  We’ve now got all of our parts and pieces in place.
The project is a combination of cores from my
<a href="https://github.com/ZipCPU/wb2axip">WB2AXIP repository</a>, together with a bit of
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a> logic
from a <a href="https://github.com/ZipCPU/axidmacheck/">new repository to tie it all
together</a>.  We’ve now used
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
to handle all of the bus compositing necessary to build a Verilog project.
All that’s left is to drive the entire simulation from a <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/automaster_tb.cpp">C++ Verilator test
script</a>
from the top.</p>

<p>What’s our purpose?  Well, initially my purpose was to find out why the
<code class="language-plaintext highlighter-rouge">cover()</code> statements in my
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">AXI DMA</a>
weren’t passing.  Now that I’ve figured that out, though, I have some rather
grander visions.  I’d like to see just how well memory copies like this can
perform.  I’d also like a test bed where I can see how changes to one
part/piece/component affect other things.</p>

<table align="center" style="float: right"><caption>Fig 8. If it works, what next?</caption><tr><td><img src="/img/axi-dma/if-it-works.svg" alt="" width="360" /></td></tr></table>

<p>As an example of what I’d like to learn, one of the comments I see often on
<a href="https://forums.xilinx.com">Xilinx’s forums</a> is, “Why doesn’t my [S/MM]2[MM/S]
memory core work?”  Or even “Why won’t my (whatever core) copy multiple
packets?”  My typical thought is, I’m not sure–what logic did Xilinx stuff into
their <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_datamover/v5_1/pg022_axi_datamover.pdf">data movers</a>
that would break them like that?  I mean, my own packet logic is really simple:
for the most part it ignores any <code class="language-plaintext highlighter-rouge">TLAST</code> signals.  Comments like this, though,
make me wonder if I shouldn’t be adding in something more for “better” <code class="language-plaintext highlighter-rouge">TLAST</code>
processing.  I mean, if it works, it must not have enough features, right?</p>

<p>To make all of this work, we are going to need to be able to drive this
entire design using an <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">AXI interface into the Verilated
design</a>.
Building <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">this AXI interface to a Verilated
design</a>
will be the subject of the rest of this article.</p>

<h2 id="building-the-axi-interface">Building the AXI Interface</h2>

<p>Some time ago, I presented my own <a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">vision for how an FPGA out to be
controlled</a>.
<a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">This vision</a>
was presented in terms of a
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/devbus.h">C++ interface</a>
that could then be used from test scripts or control programs to interact
with the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
Since that time, <a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">this
vision</a>
has worked surprisingly well for me–so well in fact that I’ve hardly changed
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/devbus.h">the interface</a>
since then.  Indeed, the biggest changes have been adding more documentation
to it–nothing more.</p>

<p><a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">The basic control
vision</a>
involves a <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">C++ class
implementing</a> an
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/devbus.h">interface to the
design</a>.  This
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/devbus.h">interface</a>
has six primary functions.  The simplest two are the
<code class="language-plaintext highlighter-rouge">readio()</code> function to read from a single memory address and the <code class="language-plaintext highlighter-rouge">writeio()</code>
function to write to a single memory address.  There’s also a <code class="language-plaintext highlighter-rouge">readi()</code>
function to read from multiple addresses in a row as part of a burst,
and the similar <code class="language-plaintext highlighter-rouge">writei()</code> instruction.  The last two functions, <code class="language-plaintext highlighter-rouge">readz()</code>
and <code class="language-plaintext highlighter-rouge">writez()</code> work the same as <code class="language-plaintext highlighter-rouge">readi()</code> and <code class="language-plaintext highlighter-rouge">writei()</code> save that they use
the same address for every read or write  in the burst.</p>

<p>Under the hood, there are <code class="language-plaintext highlighter-rouge">readv()</code> and <code class="language-plaintext highlighter-rouge">writev()</code> functions that implement
the <code class="language-plaintext highlighter-rouge">readi()</code>/<code class="language-plaintext highlighter-rouge">readz()</code> and <code class="language-plaintext highlighter-rouge">writei()</code>/<code class="language-plaintext highlighter-rouge">writez()</code> pairs.  This function either
increments the address between beats or … it doesn’t, depending upon a
argument given to it.</p>

<p><a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/devbus.h">This is the
interface</a> I
use when I want to interact with a design from an external serial port.  I call
it the <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/devbus.h"><code class="language-plaintext highlighter-rouge">DEVBUS</code> interface</a>.
The steps to interacting with a design are then,</p>

<ol>
  <li>
    <p>Some external program will call a class implementing these functions.
Initially, this program is one I call <a href="/blog/2017/06/29/sw-dbg-interface.html">wbregs</a> that provides a command line
based <a href="https://en.wikipedia.org/wiki/PEEK_and_POKE">PEEK/POKE interface into the
design</a>.  Eventually, though,
as I work with the design, I’ll get tired of <a href="/blog/2017/06/29/sw-dbg-interface.html">typing commands like
this</a> and make a
shell script and then even <a href="/blog/2017/07/08/getting-started-with-wbscope.html">replace that with a C++
program</a>
running coordinated testing.</p>

    <p>We discussed <a href="/blog/2020/04/01/design-flow.html">how this testing progression typically went just
recently</a>, when I
described how I go about bringing up a new hardware component.  Ideally,
you’d want to do it from
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
before hardware, and that’s what we’re discusing.</p>
  </li>
  <li>
    <p>A library associated with a <a href="/blog/2017/06/05/wb-bridge-overview.html">debugging
bus</a>
converts these interface functions into a characters that can be sent over
a serial port, and then sends them over a <a href="/blog/2017/06/17/why-network-debugging.html">TCP/IP
link</a>.
Ideally, this includes some type of
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus/wbucompress.v">compression</a> and
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus/wbudecompress.v">decompression</a> as well.</p>
  </li>
  <li>
    <p>A program then intercepts the other half of this
<a href="/blog/2017/06/17/why-network-debugging.html">TCP/IP link</a>
and either forwards the characters to the serial port of a device
implementing my design, or (if it’s my simulation script) then to the
emulated serial port in a
<a href="/blog/2018/08/22/what-is-simulation.html">simulated</a>
design.</p>
  </li>
  <li>
    <p>Then, within the design, the byte stream is recomposed into transaction
commands.  If those commands were
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus/wbucompress.v">compressed</a>,
they are then
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus/wbudecompress.v">decompressed</a>.
The result may then be sent into a FIFO, depending upon my implementation,
and then into a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interface.</p>
  </li>
  <li>
    <p>Once the result comes back from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
it’s then (optionally)
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/wbubus/wbucompress.v">compressed</a>
and returned over the (possibly simulated) serial port, back over the
<a href="/blog/2017/06/17/why-network-debugging.html">TCP/IP link</a>,
and back to the software that sent the command.</p>
  </li>
</ol>

<p>This is how I normally do my debugging, and <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">we’ve talked extensively about this
interface on this blog</a>.
The good news is that, if you like this type of interface, I’ve recently
written an <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbexecaxi.v">AXI-lite
master</a>
that can drive this “debugging bus”–instead of just the
<a href="/blog/2017/06/08/simple-wb-master.html">Wishbone interface</a>
I’ve traditionally used.</p>

<p>Today, though, that’s not what we’re going to build.</p>

<p>Instead, today I want to build a
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/automaster_tb.cpp">Verilator test script</a>
that will drive an
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">AXI-lite interface</a>
but without the
<a href="/blog/2017/06/17/why-network-debugging.html">TCP/IP link</a>
in the middle.  In many ways, this simplifies the process–we’ll no longer
need the byte stream, the compression, the
<a href="/blog/2017/06/17/why-network-debugging.html">TCP/IP</a>,
etc.  It’ll be easier to get us going that much faster.</p>

<p>However, there is one problem associated with doing things this way:
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
time.  When using the
<a href="/blog/2017/06/17/why-network-debugging.html">TCP/IP</a>
interface,
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
time advances any time you aren’t transmitting anything.  Today, though, we’ll
need to advance
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
time ourselves.
We’ll do that by calling our favorite <a href="/blog/2017/06/21/looking-at-verilator.html"><code class="language-plaintext highlighter-rouge">tick()</code>
function</a>
to toggle the clock from within our simulation script.  This works great
when your design only has one clock, but we’ll make a slight adjustment
to guarantee that we can support any
<a href="/blog/2018/09/06/tbclock.html">multiclock simulations</a>
later on.  This adjustment will guarantee that our
<code class="language-plaintext highlighter-rouge">tick()</code> method always toggles the
<a href="/doc/axi-spec.pdf">AXI</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="/blog/2017/09/18/clocks-for-sw-engineers.html">clock</a>.</p>

<p>To make certain that
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
time passes when we need it to, we’ll add an <code class="language-plaintext highlighter-rouge">idle()</code> function to
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">our interface</a>
that just causes the design to move forward some predetermined number of
clock ticks.</p>

<p>The <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/devbus.h"><code class="language-plaintext highlighter-rouge">DEVBUS</code> interface</a>
also includes some number of
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>
processing functions as well:</p>

<ol>
  <li>
    <p>There’s the  <code class="language-plaintext highlighter-rouge">poll()</code> function for determining if an
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>
has taken place.</p>
  </li>
  <li>
    <p>A similar <code class="language-plaintext highlighter-rouge">wait()</code> function just sits in a loop waiting for an
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>
to take place.</p>
  </li>
  <li>
    <p>A third function, <code class="language-plaintext highlighter-rouge">usleep()</code>, can also be used to wait on an
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>.
<code class="language-plaintext highlighter-rouge">usleep()</code> allows us to wait for an
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>,
while still timing out after some number of milliseconds in case the
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>
never shows up.</p>
  </li>
</ol>

<p>So here’s how this class structure will work:</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 9. C++ Class Structure</caption><tr><td><img src="/img/axitb/vfiles.svg" alt="" width="360" /></td></tr></table>

<h3 id="vmain">VMain</h3>

<p>We’ll start off with the <code class="language-plaintext highlighter-rouge">Vmain</code> C++ class generated by
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>,
and any subclasses
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
may choose to create.  This class will faithfully implement our design logic
for us, from
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/main.v">main.v</a> on down.
Our task will simply be to adjust the inputs and then call an
<code class="language-plaintext highlighter-rouge">eval()</code> function provided by the class to update any design outputs.</p>

<h3 id="testb">TESTB</h3>

<p>We’ll then wrap that class with a <a href="/blog/2017/06/21/looking-at-verilator.html">TESTB
class</a> providing
some helper functions, as shown in Fig. 9.  This will give us access to a
<code class="language-plaintext highlighter-rouge">tick()</code> method that <a href="/blog/2018/09/06/tbclock.html">toggles our clock and advances simulation
time</a>,
while also encapsulating any <a href="/blog/2017/07/31/vcd.html">trace
file</a> generation routines.
This class is automatically generated for us by
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>,
to make sure that all <a href="/blog/2018/09/06/tbclock.html">clocks are properly
modeled</a> for us.</p>

<h3 id="main_tb">MAIN_TB</h3>

<p><a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/testb.h">This TESTB
class</a>
will be wrapped by the <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/main_tb.cpp"><code class="language-plaintext highlighter-rouge">MAINTB()</code> class, also automatically
generated</a>
by <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.
This latter class will include any calls to emulator functions that you
tell <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
to include.  As you may recall,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
is first a copy/paste
utility, and only then a bus compositor.  Three particular
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
keys give you access to these functions.  <a href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L262-L264"><code class="language-plaintext highlighter-rouge">SIM.CLOCK</code></a>
defines the clock your core needs
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
support at.
<a href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L237-L239"><code class="language-plaintext highlighter-rouge">SIM.INIT</code></a>
can be used to define any C++ variables
you need in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
can be used to initialize any of these variables, and
<a href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L245-L246"><code class="language-plaintext highlighter-rouge">SIM.TICK</code></a>
can be used to define any logic that might need to happen on a clock tick.</p>

<p>For example, I often like to define a serial port encapsulated by the class,
<a href="https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.h"><code class="language-plaintext highlighter-rouge">UARTSIM</code></a>.
In the <a href="https://github.com/ZipCPU/autofpga/blob/95df250da1d829d9ec0ad67822ebe7e85bac00eb/doc/icd.txt#L231-L232"><code class="language-plaintext highlighter-rouge">SIM.INCLUDE</code> tag</a>,
I’d reference the definition of my <a href="https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.h"><code class="language-plaintext highlighter-rouge">UARTSIM</code>
class</a>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@SIM.INCLUDE=
#include "uartsim.h"</code></pre></figure>

<p>This would get placed at the top of the <code class="language-plaintext highlighter-rouge">main_tb.cpp</code> class file.  A second
piece of logic,
<a href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L235-L236"><code class="language-plaintext highlighter-rouge">SIM.DEFNS</code></a>,
will be used to hold a pointer to an object of this serial port class.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@SIM.DEFNS=
	UARTSIM *m_@$(PREFIX);</code></pre></figure>

<p>Realistically, the name of the serial port could be anything–it doesn’t have
to include the <code class="language-plaintext highlighter-rouge">PREFIX</code> tag of this component at all.  I could’ve just called
it <code class="language-plaintext highlighter-rouge">UARTSIM *m_uart;</code>.  I just like to use the <code class="language-plaintext highlighter-rouge">PREFIX</code> tag here to help
provide some ability to separate device names.  That way the same UART
configuration file can be used to define many UARTs, each with different
<code class="language-plaintext highlighter-rouge">PREFIX</code> tags.</p>

<p>Now that such a value is declared, the <a href="https://github.com/ZipCPU/autofpga/blob/5e8b431eecebbd51feaf308ee641e1fb58464881/doc/icd.txt#L237-L239"><code class="language-plaintext highlighter-rouge">SIM.INIT</code>
tag</a>,
tells us how we need to initialize this value before any simulations start.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@SIM.INIT=
		m_@$(PREFIX) = new UARTSIM(FPGAPORT,UARTSETUP);</code></pre></figure>

<p>In this case, the <code class="language-plaintext highlighter-rouge">FPGAPORT</code> is a <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP port
number</a> for this
serial port, and <code class="language-plaintext highlighter-rouge">UARTSETUP</code> captures the parameters of the UART–baud rate,
parity, stop bits, etc.</p>

<p>Finally, on every clock tick we’ll want to have our emulated serial port
act on the data given to it.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@SIM.TICK=
		m_core-&gt;i_@$(PREFIX)_rx = (*m_@$(PREFIX))(m_core-&gt;o_@$(PREFIX)_tx);</code></pre></figure>

<p>Once variable expansion takes place, and assuming this components <code class="language-plaintext highlighter-rouge">PREFIX</code>
tag is given by <code class="language-plaintext highlighter-rouge">uart</code>, this will turn into the C++ statement,</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">		m_core-&gt;i_uart_rx = (*m_uart)(m_core-&gt;o_uart_tx);</code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">m_uart</code> C++ object then emulates a serial port–given the output serial
port wire from the design, <code class="language-plaintext highlighter-rouge">o_uart_tx</code>, it produces the serial port input for
the next time step, <code class="language-plaintext highlighter-rouge">i_uart_tx</code>.</p>

<p>This is just an example of what you could do here.  Other examples might
include emulated video or audio inputs, outputs, and … well, the sky’s
roughly the limit.</p>

<p>Supporting these emulation software calls is the purpose of the <code class="language-plaintext highlighter-rouge">main_tb.cpp</code>
wrapper.  For today’s DMA testing design, though, we won’t be using any of
this emulation capability.</p>

<h3 id="axi_tb">AXI_TB</h3>

<p>We can now come to our <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">AXI test bench
wrapper</a>.
This is the part and piece of this design that I’d like to discuss in detail.
This C++ <code class="language-plaintext highlighter-rouge">AXI\_TB</code> class will need to wrap the <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/main_tb.cpp">main test
bench</a>.
It will also provide us with simplified commands that we can use to access
the AXI bus within the design from the perspective of an
<a href="/blog/2020/03/23/wbm2axisp.html">AXI master</a>.</p>

<p>Let’s walk through
<a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">this class</a>
definition in detail.</p>

<p>We’ll define this <code class="language-plaintext highlighter-rouge">AXI\_TB</code> class as a template class, defined using our <a href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/main.v">test
bench software</a>,
herein called <code class="language-plaintext highlighter-rouge">TB</code>.  (This would be the software containing any emulation
layers that we just discussed before.)  Based on our <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/main_tb.cpp"><code class="language-plaintext highlighter-rouge">MAIN\_TB</code>
test bench</a>,
wrapping the <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/testb.h"><code class="language-plaintext highlighter-rouge">TESTB</code> helper
class</a>,
we’ll make a copy of whatever it is into <code class="language-plaintext highlighter-rouge">m_tb</code>.  If you’ve gotten lost in
this process, feel free to reference Fig. 9 above.</p>

<p>Here’s how <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">this class
definition</a>
starts out.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="cp">#include &lt;verilated.h&gt;
#include &lt;verilated_vcd_c.h&gt;
#include "testb.h"
</span>
<span class="c1">//</span>
<span class="c1">// devbus.h provides the definition of our common interface</span>
<span class="cp">#include "devbus.h"
</span>
<span class="c1">//</span>
<span class="c1">// Number of clocks before deciding a peripheral is broken</span>
<span class="k">const</span> <span class="kt">int</span>	<span class="n">BOMBCOUNT</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TB</span><span class="p">&gt;</span>	<span class="k">class</span>	<span class="nc">AXI_TB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DEVBUS</span> <span class="p">{</span>
	<span class="kt">bool</span>	<span class="n">m_buserr</span><span class="p">;</span>
<span class="cp">#ifdef	INTERRUPTWIRE
</span>	<span class="kt">bool</span>	<span class="n">m_interrupt</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="n">VerilatedVcdC</span>	<span class="o">*</span><span class="n">m_trace</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="c1">//</span>
	<span class="c1">// m_tb wraps the TESTB wrapper of the actual logic</span>
	<span class="n">TB</span>		<span class="o">*</span><span class="n">m_tb</span><span class="p">;</span>

	<span class="c1">//</span>
	<span class="c1">// A 32-bit unsigned integer is a bus word for our purposes today</span>
	<span class="k">typedef</span>	<span class="kt">uint32_t</span>	<span class="n">BUSW</span><span class="p">;</span>
	
	<span class="kt">bool</span>	<span class="n">m_bomb</span><span class="p">;</span></code></pre></figure>

<p>Constructing one of these <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">AXI test bench wrapper
objects</a>
is straight forward.  We primarily just create a <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/main_tb.cpp">simulation test bench
wrapper</a>
within, and clear the (simulated) master’s AXI signals.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">AXI_TB</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//</span>
		<span class="c1">// Create a new test bench</span>
		<span class="n">m_tb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TB</span><span class="p">;</span>

		<span class="c1">//</span>
		<span class="c1">// Notify Verilator that we might turn tracing on later</span>
		<span class="n">Verilated</span><span class="o">::</span><span class="n">traceEverOn</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>


		<span class="c1">// On startup, nothing has timed out (yet)</span>
		<span class="n">m_bomb</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="c1">//</span>
		<span class="c1">// Before reset, all VALIDs must be zero.  We're also not</span>
		<span class="c1">// going to touch AxPROT again, so let's give it a useful</span>
		<span class="c1">// value going forward.  (Most of my designs have ignored</span>
		<span class="c1">// AxPROT so far.)</span>
		<span class="c1">//</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWPROT</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WSTRB</span>   <span class="o">=</span> <span class="mh">0x0f</span><span class="p">;</span>
		<span class="c1">//</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARPROT</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="c1">//</span>
		<span class="c1">// Technically xREADY could be anything.  We'll set it to</span>
		<span class="c1">// zero as well.</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BREADY</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RREADY</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_buserr</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="cp">#ifdef	INTERRUPTWIRE
</span>		<span class="c1">// If INTERRUPTWIRE is defined, it is defined to the</span>
		<span class="c1">// name of the interrupt output from the design.  If not,</span>
		<span class="c1">// we won't support interrupt logic.</span>
		<span class="n">m_interrupt</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="p">}</span></code></pre></figure>

<p>Normally, the <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/main_tb.cpp">main_tb.cpp</a>
file offers us a function to open a <a href="/blog/2017/07/31/vcd.html">VCD
file</a> for tracing the design.
Since we’ve wrapped this interface, we’ll need to re-expose access to this
function to the rest of the design.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">virtual</span>	<span class="kt">void</span>	<span class="nf">opentrace</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vcdname</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">opentrace</span><span class="p">(</span><span class="n">vcdname</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<p>More recently, I’ve <a href="https://github.com/ZipCPU/axidmacheck/blob/77911683d1fd0e547629058342c972c673cea57f/sim/testb.h#L49-L55">allowed other traces to be
generated</a>
other than <a href="/blog/2017/07/31/vcd.html">VCD</a>.  At this point,
the jury is still out whether or not the extra simulation time required to
compress these other formats (primarily FST) is truly worth the wait.</p>

<p>The <code class="language-plaintext highlighter-rouge">tick()</code> method is fundamental.  That said, it just calls <a href="https://github.com/ZipCPU/axidmacheck/blob/77911683d1fd0e547629058342c972c673cea57f/sim/testb.h#L175-L205">an underlying
simulation tick method</a>.  The <code class="language-plaintext highlighter-rouge">tick_clk()</code> method
is similar.  It keeps adjusting clocks and calling <code class="language-plaintext highlighter-rouge">eval()</code> on the underlying
model until the clock we are based upon, one called <code class="language-plaintext highlighter-rouge">i_clk</code> in this design,
actually toggles.  Since we only have one clock in this design, <a href="https://github.com/ZipCPU/axidmacheck/blob/77911683d1fd0e547629058342c972c673cea57f/sim/main_tb.cpp#L134"><code class="language-plaintext highlighter-rouge">tick_clk</code>
is just a pass-through function</a>
).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">tick_clk</span><span class="p">();</span>
<span class="cp">#ifdef	INTERRUPTWIRE
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">INTERRUPTWIRE</span><span class="p">)</span>
			<span class="n">m_interrupt</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="p">}</span></code></pre></figure>

<p>We’ll use a special <code class="language-plaintext highlighter-rouge">reset()</code> call to place the design into reset.  This resets
all of the various <code class="language-plaintext highlighter-rouge">*VALID</code> signals and pulls <code class="language-plaintext highlighter-rouge">ARESETN</code> low.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">virtual</span>	<span class="kt">void</span>	<span class="nf">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARESETN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>One common user misunderstanding, when working with Xilinx cores, is that they
don’t typically reset their entire designs within a single clock cycle.
Indeed, <a href="https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf">Xilinx’s AXI implementations insist that the reset be held low for
at least sixteen clock ticks</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>While my own designs rarely need these extra clock cycles, perhaps placing
them here will make this <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">AXI
wrapper</a>
more versatile across designs.</p>

<p>There’s one other trick which isn’t obvious: once we clear the reset, we have
to have a whole clock tick with the reset clear.  (See
<a href="/doc/axi-spec.pdf">Fig. A3-1</a>.)</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARESETN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tick</span><span class="p">();</span>
	<span class="err">}</span></code></pre></figure>

<p>The next function, <code class="language-plaintext highlighter-rouge">idle(cnt)</code>, is also a helper function.  Because we are
running in a
<a href="/blog/2018/08/22/what-is-simulation.html">simulated</a>
environment, if you just call AXI read/write commands,
you might push the bus harder than you ever would in practice.  For this
reason, <code class="language-plaintext highlighter-rouge">idle()</code> just holds the
entire design in an idle state for some number of counts.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">idle</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">counts</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BREADY</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RREADY</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">counts</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tick</span><span class="p">();</span>
			<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RVALID</span><span class="p">);</span>
			<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BVALID</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span></code></pre></figure>

<p>How many idle counts should you hold it for?  One?  Two?  Twenty?  That’s
between you and your design.  Just remember, any call to <code class="language-plaintext highlighter-rouge">idle()</code>, or even
a failure to call <code class="language-plaintext highlighter-rouge">idle()</code> or to <code class="language-plaintext highlighter-rouge">idle()</code> for the right amount, might mask
an error within your core.  For this reason–and many more which are common
to simulation in general–I wouldn’t trust this routine not to <a href="/formal/2018/12/28/axilite.html">miss bugs
already existing within your
core</a>.</p>

<p>For example, by just waiting for the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
protocol to complete any transaction,
this simulation would miss the bug in <a href="/blog/2020/01/01/2019-in-review.html">Xilinx’s AXI Ethernet-lite
core</a> whereby
writes to the core, if they showed up at the same time as a read request,
would be applied to the read address.  The moment you insist that your
simulation only ever simulate reads or writes but never both, is <a href="/formal/2019/05/13/axifull.html">the moment
you abandon ever fully verifying your
core in the first place</a>.</p>

<p>Remember–<a href="/formal/2018/12/28/axilite.html"><em>use formal
methods</em></a>
for verifying any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
based component.</p>

<p>But I digress.  Today’s purpose is just to <a href="https://github.com/ZipCPU/axidmacheck">exercise a
complex AXI-based design</a> using
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
and using a
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a> based
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
at that.  It’s not to prove the design works, but rather just to demonstrate
that we can interact with an AXI based design from a
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a> based
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a></p>

<p>The next thing we’re going to try is to read a value from memory.</p>

<p>When you consider the <a href="/blog/2020/03/23/wbm2axisp.html">various classes of AXI masters I discussed
earlier</a>, this
read method would fall in the class of a <em>Single beat master</em>.  It issues a
single beat request to your design, and then waits for the return.</p>

<p>Let’s see how we might do that.  We’ll read one value from the AXI-lite bus
having
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a> <code class="language-plaintext highlighter-rouge">a</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">BUSW</span> <span class="nf">readio</span><span class="p">(</span><span class="n">BUSW</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUSW</span>		<span class="n">result</span><span class="p">;</span>
		<span class="kt">uint32_t</span>	<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="c1">//</span>
		<span class="c1">// One of my first steps of debugging when a design doesn't</span>
		<span class="c1">// work, is to ask myself what AXI requests were taking place</span>
		<span class="c1">// or in progress.  This printf() gives me that kind of</span>
		<span class="c1">// context while the simulation is taking place.  In a longer</span>
		<span class="c1">// simulation, however, these printf's could get overwhelming,</span>
		<span class="c1">// so I just leave it commented here.</span>
		<span class="c1">//</span>
		<span class="c1">// printf("AXI-READM(%08x)\n", a);</span></code></pre></figure>

<p>The first step is to issue the request itself.  This means setting <code class="language-plaintext highlighter-rouge">ARVALID</code>
and setting the requested
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>
to the given one.  We’ll clear the bottom two
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>
bits
to make certain our
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>
is aligned–it just makes things simpler.
(Remember, if you want to check for <em>every</em> condition, <a href="/formal/2018/12/28/axilite.html">use formal methods
methods</a>.)</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARADDR</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RREADY</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Now we have to tick the clock and wait for <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> to go high.
Once it becomes set, we have to toggle one more time to make certain we’ve
completed the clock cycle with <code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARREADY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tick</span><span class="p">();</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">delay_count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">BOMBCOUNT</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>When I first built this simulation wrapper, I didn’t include the <code class="language-plaintext highlighter-rouge">delay_count</code>
increment and assertion above.  Then an <a href="https://www.youtube.com/watch?v=NKzqRum1ksg">mutant
core</a> never raised <code class="language-plaintext highlighter-rouge">ARREADY</code>
and my
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
task just hung.</p>

<p>Wiser now, I’m using <code class="language-plaintext highlighter-rouge">delay_count</code> as a wrapper in every one of my loops
to make certain I never wait for any undetermined (infinite) delay.  While
such an (infinite) delay might be <em>legal</em> under the
<a href="/doc/axi-spec.pdf">AXI protocol</a>, it’s
certainly not what I would wish to allow.</p>

<p>Now that we’ve had one clock tick with <code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code>, we need to clear
<code class="language-plaintext highlighter-rouge">ARVALID</code> and our delay count.  The next step is to wait for the <code class="language-plaintext highlighter-rouge">RVALID</code>
response.  Again, we’ll count how long the peripheral takes to reply, and
make sure the peripheral replies within a reasonable number of clock ticks.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RVALID</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// || !RVALID</span>
			<span class="n">tick</span><span class="p">();</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">delay_count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">BOMBCOUNT</span><span class="p">);</span>
		<span class="p">}</span></code></pre></figure>

<p>Now that the slave has raised <code class="language-plaintext highlighter-rouge">RVALID</code>, we want to capture the the value to
return as our result.  We’ll also check <code class="language-plaintext highlighter-rouge">RRESP</code> to see if a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
has taken place, whether a slave error or an interconnect error.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">result</span> <span class="o">=</span> <span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RDATA</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RRESP</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">m_buserr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span></code></pre></figure>

<p>Finally, we’ll let one more clock tick pass–the clock tick where
<code class="language-plaintext highlighter-rouge">RVALID &amp;&amp; RREADY</code>, before returning the value returned from our design.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">tick</span><span class="p">();</span>

		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="err">}</span></code></pre></figure>

<p>Always be aware when you do this what state you are leaving the design in.
In this case, we left <code class="language-plaintext highlighter-rouge">RREADY</code> high.  It’s not really a problem.  <code class="language-plaintext highlighter-rouge">RREADY</code> is
a don’t care when nothing’s pending.  It’s just something you want to be
aware of.</p>

<p>That function will read a single 32-bit value from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.</p>

<p>What if you want to read a 64-bit value from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>?
In this case, our
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
is only 32-bits wide.  We’d need to read two words in an incrementing fashion,
and then merge the two into a single result.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">uint64_t</span> <span class="nf">read64</span><span class="p">(</span><span class="n">BUSW</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint64_t</span>	<span class="n">result</span><span class="p">;</span>
		<span class="kt">int32_t</span>		<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

		<span class="n">readv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>Reading more than one value at a time is really the purpose of <code class="language-plaintext highlighter-rouge">readv()</code>.</p>

<p>If you remember, we support three read calls internally: <code class="language-plaintext highlighter-rouge">readio()</code> reads a
single word, <code class="language-plaintext highlighter-rouge">readi()</code> reads some number of words while incrementing the
address, and <code class="language-plaintext highlighter-rouge">readz()</code> reads some number of words from a constant address–such
as a
<a href="https://github.com/ZipCPU/wbuart32">UART</a> or
<a href="/blog/2017/06/08/simple-scope.html">my scope</a>
might use.  (I was once stingier with my <a href="/zipcpu/2019/09/03/address-assignment.html">address space
assignments</a>.)
As I mentioned above, both <code class="language-plaintext highlighter-rouge">readi()</code> and <code class="language-plaintext highlighter-rouge">readz()</code> call a third function,
<code class="language-plaintext highlighter-rouge">readv()</code> to do the heavy lifting.  That’ll be our next function to examine.</p>

<p>To use <code class="language-plaintext highlighter-rouge">readv()</code>, we’ll need
<a href="/zipcpu/2019/09/03/address-assignment.html">an address</a>,
a number of words to read from, and a length.  A fourth parameter, <code class="language-plaintext highlighter-rouge">inc</code>,
will tell us whether or not we want to increment
<a href="/zipcpu/2019/09/03/address-assignment.html">the address</a>
or not.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">readv</span><span class="p">(</span><span class="k">const</span> <span class="n">BUSW</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">BUSW</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">inc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>		<span class="n">cnt</span><span class="p">,</span> <span class="n">rdidx</span><span class="p">,</span> <span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>As you might expect, the first step in a bulk read is to set <code class="language-plaintext highlighter-rouge">ARVALID</code>,
<code class="language-plaintext highlighter-rouge">ARADDR</code>, and <code class="language-plaintext highlighter-rouge">RREADY</code>.  As before, we’ll trim off the lower address bits from
<code class="language-plaintext highlighter-rouge">ARADDR</code>, to force the read to be word aligned even though
<a href="/doc/axi-spec.pdf">AXI</a> doesn’t necessarily require the
first word in any burst to be aligned.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">printf</span><span class="p">(</span><span class="s">"AXI-READM(%08x, %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARADDR</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
		<span class="c1">//</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RREADY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>At this point, we could probably do a burst read if this were an full AXI4
test bench interface, instead of just an AXI4-lite script.  Were we to do
that, we’d also want to set <code class="language-plaintext highlighter-rouge">ARBURST</code> to either <code class="language-plaintext highlighter-rouge">FIXED</code> (if <code class="language-plaintext highlighter-rouge">inc==0</code>) or <code class="language-plaintext highlighter-rouge">INCR</code>
(if <code class="language-plaintext highlighter-rouge">inc==1</code>).  <code class="language-plaintext highlighter-rouge">ARSIZE</code> would be set to the log (based two) of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
width minus three (<code class="language-plaintext highlighter-rouge">ARSIZE==0</code> for byte-width transactions, <code class="language-plaintext highlighter-rouge">1</code> for 16-bit
words, <code class="language-plaintext highlighter-rouge">2</code> for 32-bit words, etc.), so we would set that to <code class="language-plaintext highlighter-rouge">2</code>.  <code class="language-plaintext highlighter-rouge">ARID</code> could
be set to any integer with the right number of bits and just held constant.  The
tricky one would be <code class="language-plaintext highlighter-rouge">ARLEN</code>.  Nominally, we might set <code class="language-plaintext highlighter-rouge">ARLEN</code> to be <code class="language-plaintext highlighter-rouge">len-1</code>.
However, we’d have to adjust that since <code class="language-plaintext highlighter-rouge">ARLEN</code> can only go up to 255, and
that only if <code class="language-plaintext highlighter-rouge">ARBURST == INCR</code>.  For a <code class="language-plaintext highlighter-rouge">FIXED</code> burst, <code class="language-plaintext highlighter-rouge">ARLEN</code> can only go up
to 15.  That’s only the first constraint on <code class="language-plaintext highlighter-rouge">ARLEN</code>.  The second constraint
on <code class="language-plaintext highlighter-rouge">ARLEN</code> would be that we can’t cross 4kB boundaries.  In other words,
building a proper AXI4 burst would take some more work, but it is quite doable.</p>

<p>With a <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">basic AXI-lite read request
generator</a>,
things can be kept simple.</p>

<p>Let’s now keep track of how many reads we’ve requested in <code class="language-plaintext highlighter-rouge">cnt</code>, and the
index into our return arrow, kept in <code class="language-plaintext highlighter-rouge">rdidx</code>.  Now we can start making
requests, until <code class="language-plaintext highlighter-rouge">cnt==len</code> and all requests have been made.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">rdidx</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">s</span><span class="p">;</span>

			<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>If ever, during this process, <code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code>, then a request has been
accepted by the
<a href="/blog/2019/07/17/crossbar.html">slave we are talking to</a>–or,
rather, it will be accepted once the clock with <code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code> clock
tick completes.  (Remember, we are peeking here at what happens just before
the clock tick.) Therefore, if <code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code>, we need to <a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/testb.h#L175-L205">tick the
clock</a>
once to make the request happen.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">s</span> <span class="o">=</span> <span class="p">((</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARVALID</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARREADY</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
			<span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>If a request was just accepted, then we’ll want to increment our
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>,
and also increment the count of requests that have been accepted.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARADDR</span> <span class="o">+=</span> <span class="p">(</span><span class="n">inc</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
			<span class="n">cnt</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span></code></pre></figure>

<p>During this time, <a href="/blog/2019/05/29/demoaxi.html">the slave</a>
might also return values our way.  If ever
<code class="language-plaintext highlighter-rouge">S_AXI_RVALID &amp;&amp; S_AXI_RREADY</code>, then we’ll need to place a value into our
buffer.  Remember, we’re holding <code class="language-plaintext highlighter-rouge">RREADY</code> high.  Therefore, this means
copying data and increasing our buffer index, <code class="language-plaintext highlighter-rouge">rdidx</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RVALID</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buf</span><span class="p">[</span><span class="n">rdidx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RDATA</span><span class="p">;</span>
				<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span></code></pre></figure>

<p>We’ll also reset our delay counter.  This is the counter we’re going to use
to determine if the slave is alive or dead–so that our
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
never hangs.  If <a href="/blog/2019/05/29/demoaxi.html">the slave</a>
responds at all, then the
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
isn’t dead.  We’ll increment
this counter in a moment–we just haven’t gotten that far yet.</p>

<p>We also need to check for any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>
on return.  For now, we’ll just record whether or not a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
has taken place or not.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RVALID</span>
					<span class="o">&amp;&amp;</span> <span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RRESP</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">m_buserr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span></code></pre></figure>

<p>As the last step in our loop, we’ll increment <code class="language-plaintext highlighter-rouge">delay_count</code> and double check
that <a href="/blog/2019/05/29/demoaxi.html">the slave</a>
isn’t taking forever.  (Remember, you can define <code class="language-plaintext highlighter-rouge">BOMBCOUNT</code> to
whatever is appropriate for your project at the <a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/axi_tb.h#L47">top of this
file</a>).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">assert</span><span class="p">(</span><span class="n">delay_count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">BOMBCOUNT</span><span class="p">);</span>
		<span class="err">}</span> <span class="k">while</span><span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">);</span></code></pre></figure>

<p>The only unfortunate part about using an assertion like this is that the
assertion will often fail <em>before</em> writing to any
<a href="/blog/2017/07/31/vcd.html">VCD file</a>.
Therefore, there’s a risk that the vital information you need in your
<a href="/blog/2017/07/31/vcd.html">VCD file</a>
about why things are failing might not make it in there.</p>

<p>This is why I routinely
<a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/testb.h#L191-L192">flush any</a>
<a href="/blog/2017/07/31/vcd.html">VCD file</a>
output routines during every call to move the clock forward, <code class="language-plaintext highlighter-rouge">tick()</code>.  Perhaps
it slows down performance, but then again–the whole reason why I’m generating a
<a href="/blog/2017/07/31/vcd.html">VCD file</a>
in the first place is because I want to find problems like this, so
having the last little bit in them is important.</p>

<p>At this point in our processing, we’ve now requested all of the values we want
to read.  The last step is to wait until the values we’ve requested come back.
Since this is
<a href="/formal/2018/12/28/axilite.html">AXI-Lite</a>,
they will come back in order.  Similarly, if we’d held <code class="language-plaintext highlighter-rouge">ARID</code> constant, they’d
also come back in order–even if we were using the <a href="/formal/2019/05/13/axifull.html">full AXI
protocol</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span><span class="p">(</span><span class="n">rdidx</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>When an item comes back, as marked by <code class="language-plaintext highlighter-rouge">RVALID &amp;&amp; RREADY</code>, copy the value into
our buffer.  We can also reset our delay counter here as well.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="k">if</span> <span class="p">((</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RREADY</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">buf</span><span class="p">[</span><span class="n">rdidx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RDATA</span><span class="p">;</span>
				<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>But if ever the response was not <code class="language-plaintext highlighter-rouge">OKAY</code> (zero), we then have a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">				<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RRESP</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">m_buserr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span></code></pre></figure>

<p>The last step is to double check that we aren’t stuck in an infinite loop
waiting for a broken core to respond.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">assert</span><span class="p">(</span><span class="n">delay_count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">BOMBCOUNT</span><span class="p">);</span>
		<span class="err">}</span></code></pre></figure>

<p>We now have all of our values read, only the last <code class="language-plaintext highlighter-rouge">RVALID &amp;&amp; RREADY</code> hasn’t
been clocked through the core (yet).  That means we’re going to need one more
<code class="language-plaintext highlighter-rouge">tick()</code> of the clock before we shut <code class="language-plaintext highlighter-rouge">RREADY</code> down.  Once that clock has
passed, our transaction should be complete.  Therefore <code class="language-plaintext highlighter-rouge">RVALID</code> and <code class="language-plaintext highlighter-rouge">BVALID</code>
should both be clear–we’ll just double check that one more time to be certain.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">tick</span><span class="p">();</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RREADY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BVALID</span><span class="p">);</span>
		<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RVALID</span><span class="p">);</span>
	<span class="err">}</span></code></pre></figure>

<p>Remember, any bug you can find here is one less bug you need to find in
hardware.  That said, this core is not sufficient to prove that an
<a href="/doc/axi-spec.pdf">AXI</a>
core is protocol compliant.  In particular, we have done nothing here to double
check that the core we are talking to can handle backpressure.  Why not?
First, because it’s not important to our simulation, and second because that’s
much easier checked with formal methods.</p>

<p>Now that we know how to read a burst of items, we can define our two wrapper
functions: <code class="language-plaintext highlighter-rouge">readi()</code> which reads with an incrementing
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>,
and <code class="language-plaintext highlighter-rouge">readz()</code> which reads multiple times from the same
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">readi</span><span class="p">(</span><span class="k">const</span> <span class="n">BUSW</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">BUSW</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">readv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span>	<span class="nf">readz</span><span class="p">(</span><span class="k">const</span> <span class="n">BUSW</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">BUSW</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">readv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<p>Unfortunately, <a href="/doc/axi-spec.pdf">AXI</a> reads are much easier
than <a href="/doc/axi-spec.pdf">AXI</a> writes.  Handling write
transactions is going to be a touch harder, particularly because the master has
to allow the <code class="language-plaintext highlighter-rouge">AW*</code> and <code class="language-plaintext highlighter-rouge">W*</code> channels to get out of sync.</p>

<p>Let’s start with the single write transaction, <code class="language-plaintext highlighter-rouge">writeio()</code>, which requests
that a single word, <code class="language-plaintext highlighter-rouge">v</code>, be written to the
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>,
<code class="language-plaintext highlighter-rouge">a</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">writeio</span><span class="p">(</span><span class="k">const</span> <span class="n">BUSW</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">BUSW</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Much as you might expect, we’ll start by setting <code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code>
together.  We’ll also force our
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>
to be aligned, and set all of the
<code class="language-plaintext highlighter-rouge">WSTRB</code> values.  (This routine only writes whole words–but it wouldn’t be
hard to adjust it to write half-words or bytes.)  Finally, the all important
<code class="language-plaintext highlighter-rouge">WDATA</code> is set to the value we wish to write.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// printf("AXI-WRITEM(%08x) &lt;= %08x\n", a, v);</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWADDR</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WDATA</span>   <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WSTRB</span>   <span class="o">=</span> <span class="mh">0x0f</span><span class="p">;</span></code></pre></figure>

<p>Several individuals have recently posted to Xilinx’s forums wondering why
<code class="language-plaintext highlighter-rouge">AWREADY</code> never goes high for them.  In their case, they were setting <code class="language-plaintext highlighter-rouge">AWVALID</code>
and waiting for <code class="language-plaintext highlighter-rouge">AWREADY</code> to go high before setting <code class="language-plaintext highlighter-rouge">WVALID</code>.  Unfortunately,
many <a href="/doc/axi-spec.pdf">AXI</a> slaves, <a href="/blog/2020/03/08/easyaxil.html">like our own
even</a>,
wait for <code class="language-plaintext highlighter-rouge">AWVALID &amp;&amp; WVALID</code> before ever dropping <code class="language-plaintext highlighter-rouge">AWREADY</code> in the first place.
These cores might also hold <code class="language-plaintext highlighter-rouge">AWREADY == WREADY</code>, much as our
<a href="/blog/2020/03/08/easyaxil.html">easy AXI-lite slave</a>
did.  You can avoid this problem by always setting
<code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code> together.  Indeed, the one core where I set <code class="language-plaintext highlighter-rouge">WREADY</code>
one clock after <code class="language-plaintext highlighter-rouge">AWVALID &amp;&amp; AWREADY</code> slows my DMA checking design down.
Balancing the two channels with a
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a> (or two)
would probably fix this.</p>

<p>We now want to loop until both <code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code> have been accepted, being
aware that the slave might accept them both together or individually and <em>in
any order</em>.  Hence, we can’t wait for one and then the other–this wait needs
to be done in parallel.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="k">while</span><span class="p">((</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">awready</span> <span class="o">=</span> <span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWREADY</span><span class="p">;</span>
			<span class="kt">int</span>	<span class="n">wready</span> <span class="o">=</span> <span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WREADY</span><span class="p">;</span>

			<span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>If <code class="language-plaintext highlighter-rouge">AWVALID &amp;&amp; AWREADY</code>, we’ll drop <code class="language-plaintext highlighter-rouge">AWVALID</code>: we’ve now made our write address
request.  The same is true of <code class="language-plaintext highlighter-rouge">WVALID &amp;&amp; WREADY</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="k">if</span> <span class="p">(</span><span class="n">awready</span><span class="p">)</span>
				<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wready</span><span class="p">)</span>
				<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>A delay check at this point will also keep us from running into an infinite
loop here in the case of a broken slave, so it’s a good thing to do.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">assert</span><span class="p">(</span><span class="n">delay_count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">BOMBCOUNT</span><span class="p">);</span>
		<span class="err">}</span></code></pre></figure>

<p>After making any write request it’s important to make certain that <code class="language-plaintext highlighter-rouge">BREADY</code>
is high, so that we might capture the write acknowledgment.  Although we
didn’t set it initially, that’s not a problem.  The write acknowledgment
isn’t allowed to come back before the slave has accepted both write address
and write data, so before this point <code class="language-plaintext highlighter-rouge">BREADY</code> is really a don’t care.</p>

<p>We’ll also clear our delay count–since the slave has fully replied to us.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BREADY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>The last step is to wait for <code class="language-plaintext highlighter-rouge">BVALID</code>, the acknowledgment from the slave.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BVALID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tick</span><span class="p">();</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">delay_count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">BOMBCOUNT</span><span class="p">);</span>
		<span class="p">}</span></code></pre></figure>

<p>Once the slave acknowledges the write, we’ll check for any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>,
but
otherwise push the <code class="language-plaintext highlighter-rouge">BVALID &amp;&amp; BREADY</code> cycle through with one more clock tick.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BRESP</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">m_buserr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">tick</span><span class="p">();</span>
	<span class="err">}</span></code></pre></figure>

<p>While we could drop <code class="language-plaintext highlighter-rouge">BREADY</code> here, it’s not necessary.  As I mentioned above,
if nothing is pending then <code class="language-plaintext highlighter-rouge">BREADY</code> is really a don’t care.</p>

<p>That’s what it takes to write one value and wait for a response.  It was a
little more complicated than reading, simply because the write address and
write data channels could be out of sync.</p>

<p>What if we wanted to write a 64-bit value?  That’s the purpose of <code class="language-plaintext highlighter-rouge">writei()</code>
(write with incrementing
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>).
There’s also <code class="language-plaintext highlighter-rouge">writez()</code>, just as with <code class="language-plaintext highlighter-rouge">readi()</code> and <code class="language-plaintext highlighter-rouge">readz()</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">write64</span><span class="p">(</span><span class="k">const</span> <span class="n">BUSW</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span>	<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="c1">// printf("AXI-WRITE64(%08x) &lt;= %016lx\n", a, v);</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">v</span><span class="p">;</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">writei</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<p>Both <code class="language-plaintext highlighter-rouge">writei()</code> and <code class="language-plaintext highlighter-rouge">writez()</code> are handled by a third function, <code class="language-plaintext highlighter-rouge">writev()</code>,
which writes a burst of data to an (optionally) incrementing
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">writev</span><span class="p">(</span><span class="k">const</span> <span class="n">BUSW</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ln</span><span class="p">,</span> <span class="k">const</span> <span class="n">BUSW</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">inc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">nacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">awcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Personally, I think <a href="https://www.reddit.com/r/FPGA/comments/egkrce/is_axi_too_complicated/">AXI became unnecessarily
complicated</a>
when they 1) split the write address channel from the write data channel,
2) created the <code class="language-plaintext highlighter-rouge">AxLEN</code> burst field, and 3) the <a href="/blog/2019/04/27/axi-addr.html"><code class="language-plaintext highlighter-rouge">AxBURST</code> address
algorithms</a>.</p>

<p>Yes, I know, certain pieces of hardware can handle bursts better than they can
handle singletons.  Having written <a href="/formal/2019/11/18/genuctrlr.html">controllers for
SDRAM’s</a> and <a href="/blog/2019/03/27/qflexpress.html">flash
devices</a>,
I’ve been able to achieve 100% throughput using such a simplified
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
structure, and even done so with much lower latency due to a simpler
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> implementation.</p>

<p>Did I mention that the AXI5 specification is even more complex than the
<a href="https://www.reddit.com/r/FPGA/comments/egkrce/is_axi_too_complicated/">already overly
complex</a>
<a href="/doc/axi-spec.pdf">AXI4 specification</a>?</p>

<p>But, you know, who am I to complain?</p>

<p>On to burst writes.  As with singleton writes, our first step is to set
<code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code> at the same time.  Everything else here at this point
is roughly the same as it was for <code class="language-plaintext highlighter-rouge">writeio()</code> above.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// printf("AXI-WRITEM(%08x, %d, ...)\n", a, ln);</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWADDR</span>  <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WSTRB</span>  <span class="o">=</span> <span class="mh">0x0f</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WDATA</span>  <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BREADY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RREADY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">awready</span><span class="p">,</span> <span class="n">wready</span><span class="p">;</span></code></pre></figure>

<p>Where things start to get different is within our loop.  For example, we now
need to issue <code class="language-plaintext highlighter-rouge">ln</code> <code class="language-plaintext highlighter-rouge">AWVALID</code>s and <code class="language-plaintext highlighter-rouge">ln</code> <code class="language-plaintext highlighter-rouge">WVALID</code>s, and these won’t necessarily
be in sync with each other.  We can use <code class="language-plaintext highlighter-rouge">awcnt</code> therefore to count
the number of <code class="language-plaintext highlighter-rouge">AWVALID</code>s that have been accepted, and <code class="language-plaintext highlighter-rouge">wcnt</code> to do the same
but for writes.  That allows us to set <code class="language-plaintext highlighter-rouge">WDATA</code> to the right location from
within our buffer, and <code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code> based on whether or not the
full <code class="language-plaintext highlighter-rouge">ln</code> number of requests has been received on each channel.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WDATA</span>   <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">wcnt</span><span class="p">];</span>

			<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="p">(</span><span class="n">awcnt</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ln</span><span class="p">);</span>
			<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span>  <span class="o">=</span> <span class="p">(</span><span class="n">wcnt</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ln</span><span class="p">);</span></code></pre></figure>

<p>As before, we’ll take a peek at what <code class="language-plaintext highlighter-rouge">awready</code> and <code class="language-plaintext highlighter-rouge">wready</code> are <em>before</em> the
<a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/testb.h#L175-L205">actual clock tick</a>,
so we’ll know what’s going to happen on <a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/testb.h#L175-L205">this clock
tick</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">awready</span> <span class="o">=</span> <span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWREADY</span><span class="p">;</span>
			<span class="n">wready</span>  <span class="o">=</span> <span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WREADY</span><span class="p">;</span>

			<span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>Once the <a href="/blog/2017/06/21/looking-at-verilator.html">clock has
ticked</a>,
we can adjust our counter for the <code class="language-plaintext highlighter-rouge">AW*</code> channel.  If the channel is live, we’ll
clear our delay count.  Finally, if we are incrementing an
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>,
we’ll update <code class="language-plaintext highlighter-rouge">AWADDR</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">awready</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">awcnt</span><span class="o">++</span><span class="p">;</span>
				<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="c1">// Update the address</span>
				<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWADDR</span> <span class="o">+=</span> <span class="p">(</span><span class="n">inc</span><span class="p">)</span><span class="o">?</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span></code></pre></figure>

<p>Advancing the write data channel is almost identical to the write address
channel above.  If a piece of write data was accepted,
we’ll update <code class="language-plaintext highlighter-rouge">wcnt</code> and clear the delay counter.  Note that we don’t need to
adjust <code class="language-plaintext highlighter-rouge">WDATA</code> here.  Although we might, we’ve already set <code class="language-plaintext highlighter-rouge">WDATA</code> earlier in
this loop, so doing so here as well would be redundant.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">wready</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">wcnt</span><span class="o">++</span><span class="p">;</span>
				<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span></code></pre></figure>

<p>Unlike the <code class="language-plaintext highlighter-rouge">writeio()</code> routine, we need to check whether or not we receive
any acknowledgments while issuing requests.  On any acknowledgment, we’ll
update our acknowledgments counter.  On any acknowledgment indicating a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
we’ll also set our <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
<a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/axi_tb.h#L50">flag</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BVALID</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nacks</span><span class="o">++</span><span class="p">;</span>

				<span class="c1">// Check for any bus errors</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BRESP</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
					<span class="n">m_buserr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span></code></pre></figure>

<p>Two comments here about
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.
First, we checked for <code class="language-plaintext highlighter-rouge">RRESP == 0</code> above,
and <code class="language-plaintext highlighter-rouge">BRESP &amp; 2</code> here.  It is illegal for an AXI-lite slave to return an
<code class="language-plaintext highlighter-rouge">xRESP</code> value of <code class="language-plaintext highlighter-rouge">1</code> (EXOKAY), so the two are equivalent.  Indeed, this latter
test might take up less hardware and so be cheaper–in hardware.  Here in
software, it might actually be costlier.  Second,
<a href="/zipcpu/2017/11/07/wb-formal.html">unlike Wishbone</a>
where we could halt an operation on a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
we’re not going to do that here.  While we might clear <code class="language-plaintext highlighter-rouge">WSTRB</code> on a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
we’ll just note it and go on.  How we actually deal with
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>
will depend upon if the <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/automaster_tb.cpp">calling C++ test
script</a>
checks for <code class="language-plaintext highlighter-rouge">m_buserr</code> or not.</p>

<p>Finally, we’ll increase our loop counter to catch any design that might hang,
and loop as long as either the number of write addresses or write data
transactions are less than our desired length.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">assert</span><span class="p">(</span><span class="n">delay_count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">BOMBCOUNT</span><span class="p">);</span>
		<span class="err">}</span> <span class="k">while</span><span class="p">((</span><span class="n">awcnt</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ln</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">wcnt</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ln</span><span class="p">));</span></code></pre></figure>

<p>Once all write address and write data transaction requests have been made,
all that remains is to wait for the last acknowledgments to come through.
We’ll drop <code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code>, and then look for <code class="language-plaintext highlighter-rouge">BVALID</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">nacks</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ln</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>If (when) our <code class="language-plaintext highlighter-rouge">BVALID</code> acknowledgments come back, we’ll process them as before.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BVALID</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nacks</span><span class="o">++</span><span class="p">;</span>
				<span class="n">delay_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BRESP</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
					<span class="n">m_buserr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span></code></pre></figure>

<p>Perhaps I should be checking for <code class="language-plaintext highlighter-rouge">BVALID &amp;&amp; BREADY</code> here.  The difference would
only be a pedantic one, though, since I’ve already guaranteed (above) that
<code class="language-plaintext highlighter-rouge">BREADY</code> will be high whenever we are waiting on a response from the core.</p>

<p>The last step is our loop counter, and the one last tick that would accept
the <code class="language-plaintext highlighter-rouge">BVALID</code> noted above.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">assert</span><span class="p">(</span><span class="n">delay_count</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">BOMBCOUNT</span><span class="p">);</span>
		<span class="err">}</span>

		<span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>We’ve now completed our burst.  Let’s clear up the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
and just double check that it’s clear like we are expecting it to be.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Release the bus</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BREADY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RREADY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_BVALID</span><span class="p">);</span>
		<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_RVALID</span><span class="p">);</span>
		<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_AWVALID</span><span class="p">);</span>
		<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">S_AXI_WVALID</span><span class="p">);</span>
	<span class="err">}</span></code></pre></figure>

<p>The next two routines, <code class="language-plaintext highlighter-rouge">writei()</code> and <code class="language-plaintext highlighter-rouge">writez()</code>, are simple references
to <code class="language-plaintext highlighter-rouge">writev</code> above–that makes them easy.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">writei</span><span class="p">(</span><span class="k">const</span> <span class="n">BUSW</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ln</span><span class="p">,</span> <span class="k">const</span> <span class="n">BUSW</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writev</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ln</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span>	<span class="nf">writez</span><span class="p">(</span><span class="k">const</span> <span class="n">BUSW</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ln</span><span class="p">,</span> <span class="k">const</span> <span class="n">BUSW</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writev</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ln</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<p>In the <code class="language-plaintext highlighter-rouge">tick()</code> method above, we checked whether an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
wire (if defined) were true, and set a flag <code class="language-plaintext highlighter-rouge">m_interrupt</code> if it were.  We
can come back later and <code class="language-plaintext highlighter-rouge">poll()</code> this value to see if an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
has taken place.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">bool</span>	<span class="nf">poll</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef	INTERRUPTWIRE
</span>		<span class="k">return</span> <span class="p">(</span><span class="n">m_interrupt</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">m_tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">INTERRUPTWIRE</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#else
</span>		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="p">}</span></code></pre></figure>

<p>Alternatively, we might wait some number of clock cycles for an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.
That’s the purpose of this <code class="language-plaintext highlighter-rouge">usleep()</code> method.  It runs our design for some
maximum number of clock cycles, until an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
has been received.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">usleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">msec</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef	CLKRATEHZ
</span>		<span class="kt">unsigned</span> <span class="n">count</span> <span class="o">=</span> <span class="n">CLKRATEHZ</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">msec</span><span class="p">;</span>
<span class="cp">#else
</span>		<span class="c1">// Assume 100MHz if no clockrate is given</span>
		<span class="kt">unsigned</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="mi">100</span> <span class="o">*</span> <span class="n">msec</span><span class="p">;</span>
<span class="cp">#endif
</span>		<span class="k">while</span><span class="p">(</span><span class="n">count</span><span class="o">--</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="cp">#ifdef	INTERRUPTWIRE
</span>			<span class="k">if</span> <span class="p">(</span><span class="n">poll</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span> <span class="k">else</span>
<span class="cp">#endif
</span>			<span class="n">tick</span><span class="p">();</span>
	<span class="p">}</span></code></pre></figure>

<p>A riskier approach might be to wait without a limit.  Since I’m usually sitting
at a keyboard with a control-C key waiting me, this hasn’t been a problem
(yet).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">wait</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef	INTERRUPTWIRE
</span>		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">poll</span><span class="p">())</span>
			<span class="n">tick</span><span class="p">();</span>
<span class="cp">#else
</span>		<span class="n">assert</span><span class="p">((</span><span class="s">"No interrupt defined"</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="cp">#endif
</span>	<span class="p">}</span>
<span class="err">}</span><span class="p">;</span></code></pre></figure>

<p>If you use this routine, always keep an eye on the size of any
<a href="/blog/2017/07/31/vcd.html">VCD file</a> you might be
generating.  They can grow many GB quickly.</p>

<p>While today’s <a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/automaster_tb.cpp">DMA test
script</a>
isn’t going to use these routines, it certainly could.</p>

<h2 id="the-simulation-script">The Simulation Script</h2>

<p>Now that we’ve seen <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">how we might issue transactions to an AXI
slave</a> from
a <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/automaster_tb.cpp">C++ Verilator script</a>,
let’s turn our attention to the <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/automaster_tb.cpp">Verilator script
itself</a>,
and see how this all worked out.</p>

<p>We’ll use a couple of macros to help drive the script.  One of them is this
test bench RAM macro, or <code class="language-plaintext highlighter-rouge">TBRAM</code> for short.  With this macro, we can then
treat the RAM elements within the design as though they were actually
elements of our C++ project–which in effect they are.</p>

<p>To get to the <code class="language-plaintext highlighter-rouge">TBRAM</code> definition, we’ll first need to define an
<a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/main_tb.cpp#L64-L73">AXIRAM</a>
macro to get us from the
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
design to the
<a href="/blog/2019/05/29/demoaxi.html">AXI block RAM</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	VVAR(A)	main__DOT_ ## A
#define	AXIRAM	VVAR(_axiram_mem)</span></code></pre></figure>

<p>We can then <a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/automaster_tb.cpp#L56">define a second macro to reference this one at the top of our test
script</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	TBRAM	m_tb-&gt;m_core-&gt;AXIRAM</span></code></pre></figure>

<p>Our <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">memory to
stream</a>
test will transfer data coming from <code class="language-plaintext highlighter-rouge">MM2S_START_ADDR</code>, and it will transfer
<code class="language-plaintext highlighter-rouge">MM2S_LENGTH</code> bytes.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	MM2S_START_ADDR		0x24
#define	MM2S_LENGTH		32768 // 262144</span></code></pre></figure>

<p>We’ll keep track of the same values, but in word addressing and word lengths,
just to simplify things later.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	MM2S_START_ADDRW	(MM2S_START_ADDR/4)
#define	MM2S_LENGTHW		(MM2S_LENGTH/4)</span></code></pre></figure>

<p>The commands to interact with the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">MM2S module</a>
are listed <a href="https://github.com/ZipCPU/wb2axip/blob/f807e355f37ee8663eca59c253be705de0ad54c4/rtl/aximm2s.v#L16-L97">at the top of the module
itself</a>.
From there, we can draw these commands from it that we might use.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	MM2S_START_CMD		0xc0000000
#define	MM2S_ABORT_CMD		0x6d000000
#define	MM2S_CONTINUOUS		0x10000000</span></code></pre></figure>

<p>We’ll then repeat this work for the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">stream to
memory</a>
test description.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	S2MM_START_ADDR		0x30
#define	S2MM_LENGTH		32768 // 262144
#define	S2MM_START_ADDRW	(MM2S_START_ADDR/4)
#define	S2MM_LENGTHW		(MM2S_LENGTH/4)
#define	S2MM_START_CMD		0xc0000000
#define	S2MM_ABORT_CMD		0x26000000</span></code></pre></figure>

<p>We’ll repeat similar definitions for the regular <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">memory to memory
DMA</a> as well.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	DMA_START_CMD		0x00000011
#define	DMA_BUSY_BIT		0x00000001
</span><span class="c1">// Extra realignment read (only)</span>
<span class="c1">// #define	DMA_SRC_ADDR		0x00000203</span>
<span class="c1">// #define	DMA_DST_ADDR		0x00008201</span>
<span class="c1">// #define	DMA_LENGTH		0x00000401</span>
<span class="c1">//</span>
<span class="c1">// Extra realignment write</span>
<span class="cp">#define	DMA_SRC_ADDR		0x00000201
#define	DMA_DST_ADDR		0x00008202
#define	DMA_LENGTH		0x00000403</span></code></pre></figure>

<p>From here, we’ll skip some of the boiler plate necessary to getting
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
up and running, and for optionally recording results to a
<a href="/blog/2017/07/31/vcd.html">VCD file</a>.</p>

<p>Let’s jump instead to right after our reset.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span></code></pre></figure>

<p>We’ll then start a test of the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">MM2S
module</a>
by setting the RAM to known values.  (A basic increment.)</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">//</span>
	<span class="c1">// Test the AXIMM2S</span>
	<span class="c1">//</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">TBRAM</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">RAMSIZE</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">MM2S_LENGTHW</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">TBRAM</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">MM2S_START_ADDRW</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span></code></pre></figure>

<p>We can then set the
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>
to transfer from, and the length of the transfer.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">write64</span><span class="p">(</span><span class="n">R_MM2SADDRLO</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">MM2S_START_ADDR</span> <span class="o">+</span> <span class="n">R_AXIRAM</span><span class="p">);</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">write64</span><span class="p">(</span><span class="n">R_MM2SLENLO</span><span class="p">,</span>  <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">MM2S_LENGTH</span><span class="p">);</span></code></pre></figure>

<p>Let’s take a peek at what that first <code class="language-plaintext highlighter-rouge">write64()</code> transaction looks like, shall
we?</p>

<table align="center" style="float: none"><caption>Fig 10. AXI-Lite write64() call</caption><tr><td><a href="/img/axitb/axil-write64.png"><img src="/img/axitb/axil-write64.png" alt="" width="780" /></a></td></tr></table>

<p>There’s a lot going on here, and it’s not all that apparent from this short
trace.  Let me walk you through it.</p>

<p>First, don’t get thrown off, but the changes we make from the test bench don’t
happen <em>on</em> the clock.  <a href="https://github.com/ZipCPU/axidmacheck/blob/c93f8672734ccf7095aba107f6949547faf93cbd/sim/testb.h#L181-L182">They happen just
before</a>.
This puts them a little bit out of sync with the test bench itself, but if
you look carefully you can see what’s going on in this trace.</p>

<p>What’s going on is that this request must first go through the
<a href="/blog/2019/07/17/crossbar.html">AXI crossbar</a>.  The
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>
needs to <a href="/zipcpu/2019/09/03/address-assignment.html">decode the address
request</a>,
and then arbitrate among all of the possible masters to get access to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.  Hence it accepts the
<code class="language-plaintext highlighter-rouge">AW*</code> transaction immediately.  The next <code class="language-plaintext highlighter-rouge">AW*</code> transaction, and even the first
<code class="language-plaintext highlighter-rouge">W*</code> transaction, both get stuck in the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffers</a> for several
clocks while arbitration takes place.  Once the channel grant has been given,
the transactions can then come out of the
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>
and go into the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">AXI to AXI-lite
bridge</a>.</p>

<table align="center" style="float: none"><caption>Fig 11. AXI write64() call, coming out of the AXI crossbar</caption><tr><td><a href="/img/axitb/axil-write64-postxbar.png"><img src="/img/axitb/axil-write64-postxbar.png" alt="" width="780" /></a></td></tr></table>

<p>All parts of the transaction now appear to line up with the clock.</p>

<p>The <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">AXI to AXI-lite
bridge</a>
produces it’s output about a clock later, going into the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axildouble.v">AXI-lite
simplifier</a>.
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">This bridge</a>
handles any and all
<a href="/blog/2019/04/27/axi-addr.html">AXI addressing</a>, as well
as reflecting any AXI ID values from request to response via a FIFO.</p>

<table align="center" style="float: none"><caption>Fig 12. AXI write64() call, now converted to AXI-lite</caption><tr><td><a href="/img/axitb/axil-write64-double.png"><img src="/img/axitb/axil-write64-double.png" alt="" width="780" /></a></td></tr></table>

<p>Once we come out of <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axildouble.v">the
simplifier</a>,
we now have an AXI-lite transaction going directly to our
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">AXI MM2S</a>
<a href="/blog/2020/03/08/easyaxil.html">control port</a>.</p>

<table align="center" style="float: none"><caption>Fig 13. AXI write64() call, perspective of the MM2S core</caption><tr><td><a href="/img/axitb/axil-write64-mm2s.png"><img src="/img/axitb/axil-write64-mm2s.png" alt="" width="780" /></a></td></tr></table>

<p>Did you notice through all these calls how the distance between <code class="language-plaintext highlighter-rouge">AWVALID</code>
and <code class="language-plaintext highlighter-rouge">BVALID</code> got successively shorter as we worked our way through these
<a href="/blog/2017/07/31/vcd.html">traces</a>?  Remember, there are no
combinatorial paths allowed in AXI components between inputs and outputs.
That means that there <em>must</em> be at least one clock edge between any inputs and
their respective outputs.  The result is that every AXI to AXI bridge costs at
least two clock cycles.  In the end, writing just two values took 12 clock
cycles, or 120ns if we assume a 100MHz clock.</p>

<p>Ouch, but that’s what we’ll have to deal with if we want to <a href="/blog/2019/04/27/axi-addr.html">play with AXI
and go through bus bridges</a>.
There’s always a cost.</p>

<p>As a last step before kicking off our <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">memory to stream copy
test</a>,
we’ll reset the <a href="https://github.com/ZipCPU/axidmacheck/blob/master/rtl/streamcounter.v">stream
sink</a>
<a href="/blog/2020/03/08/easyaxil.html">AXI-lite core</a>
that’s going to record how we’re doing and account for any
missed values.  We can also record the current clock.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_STREAMSINK_BEATS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">start_counts</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tickcount</span><span class="p">();</span></code></pre></figure>

<p>The last step is to issue the start command and … they’re off!</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_MM2SCTRL</span><span class="p">,</span> <span class="n">MM2S_START_CMD</span><span class="p">);</span></code></pre></figure>

<p>We’ll then sit back and wait for the copy to finish.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">while</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_MM2SCTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span>
		<span class="p">;</span></code></pre></figure>

<p>How’d we do?  We can read the results right from the design using the <code class="language-plaintext highlighter-rouge">readio()</code>
method from above.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">printf</span><span class="p">(</span><span class="s">"AXIMM2S Check:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">BEATS:  0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_STREAMSINK_BEATS</span><span class="p">));</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">CLOCKS: 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_STREAMSINK_CLOCKS</span><span class="p">));</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">COUNTS: 0x%08lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tickcount</span><span class="p">()</span><span class="o">-</span><span class="n">start_counts</span><span class="p">);</span></code></pre></figure>

<p>If you are interested in the timing of this <code class="language-plaintext highlighter-rouge">readio()</code> command, feel free to
try the test bench out and see for yourself.</p>

<p>I’m more interested in the report: <code class="language-plaintext highlighter-rouge">0x2000</code> or 32768 beats written in as
many clock cycles.  We can also see that there were another <code class="language-plaintext highlighter-rouge">0x27</code>, or
39 clocks, used between starting the core and the first beat that was
transferred.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">AXIMM2S Check:
	BEATS:  0x00002000
	CLOCKS: 0x00002000
	COUNTS: 0x00002027</code></pre></figure>

<p>That’s a
<a href="/blog/2017/07/31/vcd.html">trace</a>
worth examining, so let’s take a peek at how this large transfer looked.</p>

<table align="center" style="float: none"><caption>Fig 14. AXI MM2S performance</caption><tr><td><a href="/img/axitb/axi-mm2s-trace.png"><img src="/img/axitb/axi-mm2s-trace.png" alt="" width="780" /></a></td></tr></table>

<p>Here you can see the whole purpose of this exercise, finding out how well the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">AXI MM2S core</a>
worked.  <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">The core</a>
is designed so that it never issues more read
requests than what it has space in its FIFO, so you’ll see above as soon as
space opens up for the results from an AXI burst a new read request is issed.
You’ll also notice that these read requests are for <code class="language-plaintext highlighter-rouge">ARLEN=8'hff</code> or 256
beats at a time.  That’s full speed.</p>

<p>Even better, did you notice that <code class="language-plaintext highlighter-rouge">RVALID &amp;&amp; RREADY</code> hold constant?  That’s
right!  Once <code class="language-plaintext highlighter-rouge">RVALID &amp;&amp; RREADY</code> go high, this
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">AXI MM2S core</a>
is able to keep the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
busy at full speed transferring data.  Our goal, 100% throughput, has been
achieved!</p>

<p>Well, it’s not that simple.  Getting 100% throughput through the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">AXI MM2S core</a>
was only part of the battle.  We also needed an <a href="/blog/2019/05/29/demoaxi.html">AXI
slave</a> that could handle
100% throughput, as well as an <a href="/blog/2019/07/17/crossbar.html">AXI
crossbar</a> that could do it
as well.  This is indeed one of those cases where your performance will only
ever be as fast as your weakest link.</p>

<p>There are <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/automaster_tb.cpp">a couple other
tests</a>
of the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">MM2S core</a>,
but I’d like to move on to see how the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM core</a>
works.</p>

<p>In this case, the setup is nearly the same.  We’ll write a starting
<a href="/zipcpu/2019/09/03/address-assignment.html">address</a>
and a length to <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the S2MM
core</a>, and then
tell it to go.  We’ll then wait for it to complete.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">//</span>
	<span class="c1">// Test the AXIS2MM</span>
	<span class="c1">//</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">TBRAM</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">RAMSIZE</span><span class="p">);</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">write64</span><span class="p">(</span><span class="n">R_S2MMADDRLO</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">S2MM_START_ADDR</span> <span class="o">+</span> <span class="n">R_AXIRAM</span><span class="p">);</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">write64</span><span class="p">(</span><span class="n">R_S2MMLENLO</span><span class="p">,</span>  <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">S2MM_LENGTH</span><span class="p">);</span>
	<span class="n">start_counts</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tickcount</span><span class="p">();</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_S2MMCTRL</span><span class="p">,</span> <span class="n">S2MM_START_CMD</span><span class="p">);</span>
	<span class="k">while</span><span class="p">((</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_S2MMCTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_S2MMCTRL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span>
		<span class="p">;</span></code></pre></figure>

<p>How many counts did it take us from start to finish?  Let’s check our
internal clock counter, and then check for any error codes that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the core</a>
might report.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">printf</span><span class="p">(</span><span class="s">"AXIS2MM Check:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">COUNTS: 0x%08lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tickcount</span><span class="p">()</span><span class="o">-</span><span class="n">start_counts</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">ERR-CODE: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_S2MMCTRL</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">23</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x07</span><span class="p">);</span></code></pre></figure>

<p>We can also check to see if any values were corrupted.  For example, we can
check that the values whose addresses occur before our memory write address
remain at -1.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mh">0x30</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">TBRAM</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Pre-corruption: AXIRAM[%d] = 0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">TBRAM</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
			<span class="n">fail</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span></code></pre></figure>

<p>Remember how our stream source was a counter?  That means that we can walk
through the values that were transferred looking for any dropped data.
Indeed, any deviation from being a one-up counter will let us know of a
dropped value or, if not, whether we truly did manage to send continuous
values from start to finish.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span> <span class="o">+</span><span class="p">(</span><span class="mh">0x30</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">);</span> <span class="n">k</span><span class="o">&lt;</span><span class="p">(</span><span class="mh">0x30</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">16384</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">);</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">TBRAM</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">TBRAM</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Result: AXIRAM[%d] = 0x%08x != 0x%08x + 1</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">TBRAM</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">TBRAM</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">fail</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span></code></pre></figure>

<p>Here’s where sending and receiving a counter helped–we had a known input,
and we could verify a known output.  The result?</p>

<p>No data lost!  That’s a good sign.</p>

<p>But what I really want to know about is performance.  How well did this design
perform, with all of its parts and pieces?</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">AXIS2MM Check:
	COUNTS: 0x00002171
	ERR-CODE: 0</code></pre></figure>

<p>That’s not nearly the high speed performance that the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">memory to stream
core</a> achieved.
What happened?  Both were designed to be able to achieve 100% throughput.</p>

<p>To know that answer, we’ll need to take a peek at
<a href="/blog/2017/07/31/vcd.html">the trace</a>
recording this transfer.</p>

<table align="center" style="float: none"><caption>Fig 15. AXI S2MM performance from a high level</caption><tr><td><a href="/img/axitb/axi-s2mm-trace.png"><img src="/img/axitb/axi-s2mm-trace.png" alt="" width="780" /></a></td></tr></table>

<p>From this <a href="/blog/2017/07/31/vcd.html">trace</a>, you can see that
the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM core</a>
is issuing maximum length
packets, over and over, much as we might expect.  However, unlike before
where <code class="language-plaintext highlighter-rouge">RVALID &amp;&amp; RREADY</code> stayed unbroken for the whole transfer, this data
transfer isn’t continuous.  Sure, after the first burst, <code class="language-plaintext highlighter-rouge">WVALID</code> holds high
but <code class="language-plaintext highlighter-rouge">WREADY</code> doesn’t.  Something is slowing us down.  If we want to find out
what’s going on, then we’ll need to do a bit of digging.</p>

<p>Let’s zoom in on a new burst cycle once the design is fully loaded and take
a peek at what’s going on there.</p>

<table align="center" style="float: none"><caption>Fig 16. AXI S2MM, new burst</caption><tr><td><a href="/img/axitb/axi-s2mm-zoom.png"><img src="/img/axitb/axi-s2mm-zoom.png" alt="" width="780" /></a></td></tr></table>

<p>Let’s start pulling this together from the end of the last burst.  This end is
marked by the <code class="language-plaintext highlighter-rouge">WLAST</code> signal.  Here you can see <code class="language-plaintext highlighter-rouge">WLAST</code> is true first coming
out of the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM core</a>,
and then on the next cycle it’s true coming out of the
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>.
A one cycle latency is as good as it gets.</p>

<p>The <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">AXI S2MM
core</a>
then sets <code class="language-plaintext highlighter-rouge">AWVALID</code> on the next cycle, right after <code class="language-plaintext highlighter-rouge">WLAST</code> was true.  This is
good, and a nice sign of 100% throughput from the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM
core</a>.  This new
burst then starts with a new <code class="language-plaintext highlighter-rouge">WVALID</code> on the same cycle as well, also as coming
out of the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM
core</a>,
so we’re still doing good here.</p>

<p>Until we aren’t.</p>

<p>The first problem is that the
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> has a two cycle
latency on the <code class="language-plaintext highlighter-rouge">AWVALID</code>, not just the one cycle on <code class="language-plaintext highlighter-rouge">WVALID</code>.  The
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>
also holds onto the <code class="language-plaintext highlighter-rouge">W*</code>
channel until <em>after</em> <code class="language-plaintext highlighter-rouge">AWVALID</code> is sent–notice when <code class="language-plaintext highlighter-rouge">axi_axiram_wvalid</code> goes
high–it’s one clock cycle <em>AFTER</em> <code class="language-plaintext highlighter-rouge">AWVALID</code> gets received by the
<a href="/blog/2019/05/29/demoaxi.html">block RAM slave</a>.
Worse, the <a href="/blog/2019/05/29/demoaxi.html">block RAM slave</a> we
are using takes a second clock cycle after <code class="language-plaintext highlighter-rouge">AWVALID</code> before releasing <code class="language-plaintext highlighter-rouge">WREADY</code>.
That means we just lost three clock cycles on this single burst.  These
clock cycles were do to the fact that each of these cores wanted a different
alignment of the <code class="language-plaintext highlighter-rouge">W*</code> channel.</p>

<blockquote>
  <p>2020-04-08 update: One clock was lost in this process due to the
<a href="/blog/2019/05/29/demoaxi.html">block RAM slave</a>’s
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a> being
configured with <code class="language-plaintext highlighter-rouge">OPT_OUTREG</code> enabled.  <a href="https://github.com/ZipCPU/wb2axip/commit/e92ff9023b4875386c3c2922823804ea7da08361#diff-856aaa29a51c53586777697cb31c19af">Disabling <code class="language-plaintext highlighter-rouge">OPT_OUTREG</code></a>
advanced when the <a href="/blog/2019/05/29/demoaxi.html">block RAM
slave</a> raised it’s
<code class="language-plaintext highlighter-rouge">WREADY</code> signal by one clock.  This resulted in a 30 clock savings overall.</p>
</blockquote>

<p>Here’s where an “AXI Slice” might come in handy.  Had there been enough
slices to delay the <code class="language-plaintext highlighter-rouge">W*</code> channel so that it matched the delays in the <code class="language-plaintext highlighter-rouge">AW*</code>
channel, I might’ve been able to keep the <code class="language-plaintext highlighter-rouge">W*</code> channel fully loaded.  No,
I don’t need any Xilinx AXI register slices to do this, the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
with it’s registered output option should work quite well for this purpose.</p>

<p>Balancing those two channels will be one of my next tasks–or maybe placing
this onto actual hardware.  We’ll see.  Since this work isn’t really funded,
I might also end up sitting on it for a while too.</p>

<h2 id="conclusion">Conclusion</h2>

<p>As you can see, it is quite possible to build and test an
<a href="https://github.com/ZipCPU/axidmacheck">AXI design</a>
without needing
a proprietary tool set.  Even better, we were able to fully build and
<a href="/blog/2018/08/22/what-is-simulation.html">simulate</a>
such a design from a high level using
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>.
What we discovered, by drilling through and around the design, was that we
could trace what happened to our
<a href="/doc/axi-spec.pdf">AXI</a>
transaction(s) on every clock cycle.</p>

<p>Not bad.</p>

<p>My purpose today, though, was just to share the <a href="https://github.com/ZipCPU/axidmacheck/blob/master/sim/axi_tb.h">AXI test bench
script</a>
that I used to gain access to the underlying AXI infrastructure within
my design.  Did it fully test or fully verify my cores?  Not at all, but
it did allow me to generate traces that I could then use to test out various
scenarios and see how they worked.</p>

<p>We also discovered that there are consequences for having separate alignments
between the <code class="language-plaintext highlighter-rouge">AW*</code> and <code class="language-plaintext highlighter-rouge">W*</code> channels.  That will help me guide my future
designs.</p>

<p>Remember the goal: 100% throughput!  That’s why you bought your FPGA, right?
For unbridled processing power?  Don’t let your
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> hold you back.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Prove all things; hold fast that which is good.  (1Thess 5:21)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
