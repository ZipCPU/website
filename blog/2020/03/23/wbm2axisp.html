<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a basic AXI Master</title>
  <meta name="description" content="Fig 1. AXI is not a simple protocol">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2020/03/23/wbm2axisp.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building a basic AXI Master</h1>
    <p class="post-meta"><time datetime="2020-03-23T00:00:00-04:00" itemprop="datePublished">Mar 23, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. AXI is not a simple protocol</caption><tr><td><img src="/img/tweets/axi-not-simple.svg" alt="" width="420" /></td></tr></table>

<p>Over the course of the last year, I spent a lot of time on <a href="https://zipcpu.com/">this
blog</a>  discussing how to build
<a href="/doc/axi-spec.pdf">AXI</a> slave components.  We discussed first
<a href="/formal/2018/12/28/axilite.html">how to verify an AXI-lite
slave</a>,
and then <a href="/blog/2019/01/12/demoaxilite.html">how to build an AXI-lite slave that is neither broken nor
crippled</a> like <a href="/formal/2018/12/28/axilite.html">Xilinx’s
example IP packager design
was</a>.  We then spent some
time discussing <a href="/formal/2019/04/16/axi-mistakes.html">the most common AXI
mistake</a> I’ve come
across, <a href="/blog/2019/04/27/axi-addr.html">AXI addressing</a> and
<a href="/blog/2019/05/22/skidbuffer.html">skid buffers</a>.
We could then <a href="/formal/2019/05/13/axifull.html">examine Xilinx’s AXI slave, discover the bugs within
it</a>, and <a href="/blog/2019/05/29/demoaxi.html">write our own
slave with twice the
throughput</a>.</p>

<p>That’s all well and good for <a href="/doc/axi-spec.pdf">AXI</a> slaves,
but what about <a href="/doc/axi-spec.pdf">AXI</a> masters?  To date,
we haven’t discussed the logic behind creating an
<a href="/doc/axi-spec.pdf">AXI</a> master on <a href="https://zipcpu.com/">the
blog</a> at all.  So, today, I thought I’d
spend some time discussing how to build an
<a href="/doc/axi-spec.pdf">AXI</a> master that you could then use to
interact with an <a href="/doc/axi-spec.pdf">AXI</a> design.</p>

<p>Specifically, let’s discuss how to bridge from a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone (WB)
slave</a> to an
<a href="/doc/axi-spec.pdf">AXI</a> master interface.</p>

<h2 id="classes-of-axi-masters">Classes of AXI Masters</h2>

<table align="center" style="float: left; padding: 15px"><caption>Fig 2. Four classes of AXI masters</caption><tr><td><img src="/img/wbm2axisp/master-classes.svg" alt="" width="360" /></td></tr></table>

<p>For the purpose of discussion, I’m going to divide
<a href="/doc/axi-spec.pdf">AXI</a> all master designs into one of four
general categories or classes: single beat, single beat pipelined,
bursting, and multichannel bursting.  I’ve shown each of these four classes
on the left in Fig. 2, together with their defining characteristics.  In
general, they are ordered from the least complexity to the most.  Let’s take
a brief moment, though, to look a bit deeper at the defining characteristics of
masters written in each of these classes, and see how that affects both
design and performance.</p>

<h3 id="single-beat-masters">Single beat masters</h3>

<p>A single beat master is an <a href="/doc/axi-spec.pdf">AXI</a> master
that issues requests, one at a time, and then waits for the response from that
request before issuing a second request.  These masters are perhaps the easiest
masters to build, since you don’t need to keep track of how many transactions
are outstanding at all.</p>

<table align="center" style="float: none"><caption>Fig 3. A single beat master only issues one request at a time</caption><tr><td><img src="/img/wbm2axisp/single-master-reads.svg" alt="" width="640" /></td></tr></table>

<p>A good example of such a master is my recent <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbexecaxi.v">AXI-lite master for the “hexbus”
debugging
bus</a>.
This master uses the <code class="language-plaintext highlighter-rouge">RREADY</code> and <code class="language-plaintext highlighter-rouge">BREADY</code> signals as states in a state
machine to know whether or not it is in the middle of a read or write cycle.
Once the last acknowledgment is returned, <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbexecaxi.v">the
core</a>
returns to idle, lowers <code class="language-plaintext highlighter-rouge">RREADY</code> and <code class="language-plaintext highlighter-rouge">BREADY</code>, and is then ready to accept a
new burst request.  Indeed, the trace shown in Fig. 3 above was drawn from <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbexecaxi.v">this
core</a>.</p>

<p>The key to this being a <em>single beat</em> master is that both <code class="language-plaintext highlighter-rouge">AWLEN</code> and <code class="language-plaintext highlighter-rouge">ARLEN</code>
are held at zero.  This drastically simplifies the logic of the master:
1) you can hold <code class="language-plaintext highlighter-rouge">WLAST</code> high and ignore <code class="language-plaintext highlighter-rouge">RLAST</code>, and 2) you don’t need to worry
about the maximum burst length, whether or not your burst addresses are
incrementing or not, or whether or not the burst will cross a 4kB boundary.</p>

<p>Indeed, this is the easiest type of <a href="/doc/axi-spec.pdf">AXI</a>
master to write.  Even more, you should be able to verify it using the
<a href="/formal/2018/12/28/axilite.html">AXI-Lite properties</a> we’ve
already discussed on <a href="https://zipcpu.com/">this blog</a>.  Indeed,
the <a href="/blog/2018/03/10/induction-exercise.html">induction</a>
property is quite simple: there’s either one burst outstanding on one of the
two channels, or no bursts are outstanding at all.</p>

<h3 id="single-beat-pipelined">Single beat pipelined</h3>

<table align="center" style="float: right"><caption>Fig 4. Xilinx Tech Support and AXI</caption><tr><td><img src="/img/crossbar/xiltech-support.svg" alt="" width="476" /></td></tr></table>

<p>The problem with single beat masters is simply throughput: you aren’t going
to get much throughput from a single beat master.  If that’s not a problem
for your application, such as if you just need to create a simple
<a href="/doc/axi-spec.pdf">AXI</a> control script to control some minor
<a href="/doc/axi-spec.pdf">AXI</a> core, single beat masters are
awesome.  Forget the advice you’ve gotten from your vendor tech support, shown
for reference in Fig. 4, just build a single beat master.  If you want
performance, however, then you will need to issue multiple requests without
waiting for their responses.  This is the purpose of the single beat
<em>pipelined</em> master.</p>

<p>A single beat pipelined master will potentially issue multiple single beat
requests before ever getting the first response, as illustrated in Fig. 5
below.</p>

<table align="center" style="float: none"><caption>Fig 5. Four single read beats from a pipelined master</caption><tr><td><img src="/img/wbm2axisp/single-pipelined-reads.svg" alt="" width="480" /></td></tr></table>

<p>There are two big differences between single beat masters and single beat
pipelined masters.  The first difference is that you really need a state
machine to handle issuing requests and a separate state machine to handle
request responses.  You may even need a third state machine to coordinate
the two, as we’ll see in a moment.  The second big difference between the
two is that the single beat pipelined master must maintain a counter of
outstanding transactions and possibly even an internal FIFO to keep track of
what needs to be done when the response returns.</p>

<p>In general, the single beat pipelined master is still fairly easy to design.
One key to the single beat pipelined processor, though, is that the <code class="language-plaintext highlighter-rouge">AWID</code> and
<code class="language-plaintext highlighter-rouge">ARID</code> fields need to be held constant.  This will make sure your responses
get returned in order.</p>

<p>The biggest problem you’ll need to look out for with any single beat pipelined
master implementation is that the counter of outstanding transactions cannot
be allowed to overflow.  This is easily caught by formal methods and
specifically by an <a href="/blog/2018/03/10/induction-exercise.html">inductive
proof</a>.  With
simulation, you might instead be tempted to to set the number of bits in the
counter to an arbitrarily large number just to keep the counter from
overflowing.  Sadly, this just creates the deceptive appearance that something
works even when it doesn’t.  You really need the formal <a href="/blog/2018/03/10/induction-exercise.html">inductive
proof</a>
here to know that your design will always work.</p>

<h3 id="bursting-single-channel">Bursting, single channel</h3>

<p>Single beat pipelined masters are awesome.  They are the simplest masters that
should be able to achieve the full speed of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.</p>

<p>The key word in that sentence is <em>should</em>.</p>

<p>Unfortunately, many <a href="/doc/axi-spec.pdf">AXI</a> components are
optimized around <em>burst</em> processing and perform dismally with single beat
bursts.  <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">Xilinx’s AXI block RAM
interface</a>
provides a perfect example of such a crippled core.
<a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">This block RAM core</a>
requires <code class="language-plaintext highlighter-rouge">3+N</code> clocks per burst, where <code class="language-plaintext highlighter-rouge">N</code> is the length of the
burst (<code class="language-plaintext highlighter-rouge">AxLEN+1</code>).  As we’ll see in a moment, if your master interface doesn’t
support bursting, you’ll suffer from a 25% maximum throughput when interacting
with one of these cores.</p>

<p>Ouch!</p>

<p>Consider for example the trace shown below in Fig. 6, showing how three
<a href="/doc/axi-spec.pdf">AXI</a> bursts of four beats each requires
21 clocks to go through <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">Xilinx’s block RAM
interface</a>.</p>

<table align="center" style="float: none"><caption>Fig 6. Xilinx's AXI Block RAM controller's read performance</caption><tr><td><a href="/img/wbm2axisp/xilinx-bram-read-burst.png"><img src="/img/wbm2axisp/xilinx-bram-read-burst.png" alt="" width="780" /></a></td></tr></table>

<p>While <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">this slave</a>
is able to handle one clock per beat of information, it can’t handle two
bursts in short succession without taking some time to reset its internal
logic.  In this case, <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">the
core</a>
requires three clocks to reset and get ready for the next burst.  With a
16-beat burst, perhaps 85% throughput isn’t really all that bad.</p>

<p>While 85% throughput might not be “that bad”, consider the throughput shown
in Fig. 7 below, where <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">this same
core</a>
needs to respond to five separate <a href="/doc/axi-spec.pdf">AXI</a>
bursts for one beat of information each.</p>

<table align="center" style="float: none"><caption>Fig 7. Xilinx's AXI Block RAM controller's singleton read performance</caption><tr><td><a href="/img/wbm2axisp/xilinx-bram-read-singles.png"><img src="/img/wbm2axisp/xilinx-bram-read-singles.png" alt="" width="780" /></a></td></tr></table>

<p>Go ahead and count those clock cycles.  For every <code class="language-plaintext highlighter-rouge">ARVALID &amp; ARREADY</code>, <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">the
core</a>
requires three clock cycles before it will accept a new transaction.  That’s
then one transaction every four cycles, to yield a 25% throughput.  Yeah, ouch.
Didn’t you purchase your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
because you wanted raw processing speed?  If this 25% throughput is
unacceptable to you, and it should be, then you’ll either need to <a href="/blog/2019/05/29/demoaxi.html">fix this
(very crippled) AXI slave
interface</a>, or adjust your
master to issue burst requests.</p>

<p>Bursts take more work since there’s a lot of rules associated with issuing
bursts in a protocol compliant manner.
The most obvious change is simply that you’ll now need to keep track
of both the number of beats outstanding as well as the number bursts
outstanding.  The master will also need to carefully make certain that <code class="language-plaintext highlighter-rouge">WLAST</code>
is properly set on the last beat of every write burst.</p>

<p>Those are the easy changes.  The more challenging changes have to deal with
burst addressing and length calculations.</p>

<ul>
  <li>
    <p>Bursts to or from a fixed address can be no longer than 16 beats in length.
This applies to wrapped addressing as well.  If the address increments,
however, bursts of 256 beats are allowed.</p>
  </li>
  <li>
    <p>Bursts are not allowed to cross 4kB boundaries.</p>

    <p>Making sure bursts don’t cross 4kB boundaries, together with making certain
that they are limited at 256 (or 16) beats, together with making certain
that you only issue burst requests for the bursts you need, can become
a very complex process.  Sure, you could take two (or more) clocks to run
your calculations, but then you might no longer be achieving 100% throughput.</p>

    <p>No, the key or trick to this calculation, shared with me by one of my
<a href="https://twitter.com/ZipCPU">twitter followers</a>, is to pick a maximum burst
length that isn’t longer than 4kB, and then to align the start of all
subsequent bursts on a burst length boundary.  This will spare you from
checking against both the burst length and the 4kB boundary before issuing
a burst request.</p>
  </li>
  <li>
    <p>For performance reasons you’ll also want to do your business and then get
off the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Therefore, I recommend not ever attempting a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> transfer
until you can make that transfer at 100% throughput within a burst.</p>

    <p>Remember, every time your core is using the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>, there’s resources that
need to be allocated to tracking that connection within the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>.  If your
core isn’t using the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
those resources can be dedicated for other purposes.</p>
  </li>
</ul>

<p>While I hope to blog about how to do this eventually, you can check out some
of my examples in the meantime.  I have three examples of bursting
<a href="/doc/axi-spec.pdf">AXI</a> masters that you are free to
examine if you are interested in more information.  These are my
<a href="/doc/axi-spec.pdf">AXI</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">MM2S</a>, and
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">DMA (MM2MM)</a>
cores.  Compare, for example, the throughput these cores can achieve, as
measured by my <a href="https://github.com/ZipCPU/axidmacheck">new AXIDMACHECK design</a>
design, with that of the crippled throughput achieved by the <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">block RAM
controller</a>
shown above.</p>

<table align="center" style="float: none"><caption>Fig 8. Example of a high performance memory transfer</caption><tr><td><a href="/img/wbm2axisp/axidmacheck-trace.png"><img src="/img/wbm2axisp/axidmacheck-trace.png" alt="" width="780" /></a></td></tr></table>

<p>This figure, Fig. 8 above, shows a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">memory to stream
master</a> using the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
followed by a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">stream to memory
master</a>
using the same <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> and
both interacting with an <a href="/blog/2019/05/29/demoaxi.html">AXI block RAM
core</a>.</p>

<p>Notice how each master issues multiple burst transfers in a row, all at 256
beats each.  You might also wish to note that the <code class="language-plaintext highlighter-rouge">xVALID</code> and <code class="language-plaintext highlighter-rouge">xREADY</code>
channels are high for extended periods of time.  (Okay, the WREADY channel
has an issue due to the fact that <a href="/blog/2019/05/29/demoaxi.html">we didn’t align the <code class="language-plaintext highlighter-rouge">AW*</code> and <code class="language-plaintext highlighter-rouge">W*</code> channels
within the slave</a>–something
that would be easily fixed by adding a <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a> to the write
channel.)</p>

<p>I’ll also readily admit that comparing the <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">AXI block RAM
controller</a>
above with <a href="https://github.com/ZipCPU/wb2axip">these DMA controllers</a> going
through an <a href="/blog/2019/07/17/crossbar.html">interconnect</a> on
to an <a href="/blog/2019/05/29/demoaxi.html">optimized slave</a>
isn’t really a fair apples to apples comparison.  <a href="/blog/2019/05/29/demoaxi.html">My own AXI block RAM
slave</a>
isn’t nearly as crippled as <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">Xilinx’s AXI block RAM
controller</a>
is.  No, it’s not fair since the trace shown in Fig. 8 above also includes both
master and <a href="/blog/2019/07/17/crossbar.html">interconnect</a>.
Still, you should be able to get the idea: if you are using
<a href="/doc/axi-spec.pdf">AXI</a>
bursts, you should still be able to achieve 100% throughput even when crossing
burst boundaries.  Indeed, I might argue that you shouldn’t accept anything
less.</p>

<p>As with the single beat pipelined master, this class of cores maintains
constant values for <code class="language-plaintext highlighter-rouge">AWID</code> and <code class="language-plaintext highlighter-rouge">ARID</code> for simplicity.</p>

<h3 id="bursting-multiple-channel">Bursting, multiple channel</h3>

<p>The fourth type of
<a href="/doc/axi-spec.pdf">AXI</a>
master is the one that adjusts <code class="language-plaintext highlighter-rouge">AWID</code> and <code class="language-plaintext highlighter-rouge">ARID</code>.  This
class really describes a master that has multiple transaction sources internal
to it.  Each transaction source makes requests of a different stream of data,
and in return can demultiplex those different streams back out based upon the
returned <code class="language-plaintext highlighter-rouge">BID</code> and <code class="language-plaintext highlighter-rouge">RID</code> values.</p>

<p>They key difference between constant
<a href="/doc/axi-spec.pdf">AXI</a>
ID’s and varying
<a href="/doc/axi-spec.pdf">AXI</a>
ID’s is that
<a href="/doc/axi-spec.pdf">AXI</a>
only guarantees that returned responses will be in order when those
responses have the same ID.  In other words, if you use multiple IDs, you’ll
never know which ID of the many transactions IDs you may have outstanding
will be the next one returned.</p>

<p>At one time I had a nice example of a bursting, multiple channel master.  That
master would issue multiple requests with incrementing ID’s associated with
them.  The ID’s were then held in a sort-of random access FIFO that allowed
values within to be returned in a random order.  The FIFO structure then
reordered the responses so that they would be returned in order.</p>

<p>I’ve since torn this master apart and replaced it with an implementation
of the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">simpler bursting master
logic</a> that
we’ll discuss the implementation of below.</p>

<p>Why did I tear it up and replace it?  There were a couple of reasons.  First,
it was very difficult to verify that it worked.  Yes, it worked in practice
for about two years or so, but I couldn’t really <em>verify</em> that it would always
work.  Second, the reorder buffer slowed it down by adding an additional clock
or two of latency to the logic.</p>

<p>Today, I only have one example of such a master, my <a href="/blog/2019/07/17/crossbar.html">AXI crossbar
core</a>.  Sadly,
that’s not really a very useful master to use as an example of how to build
a bursting multiple channel
<a href="/doc/axi-spec.pdf">AXI</a>
master.  Worse, from an example point of view,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">my crossbar
implementation</a>
doesn’t exploit the ID’s to its advantage at all.  In its current
implementation, it just forwards the ID’s downstream.  While this is a
protocol compliant approach, the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">crossbar</a>
doesn’t benefit from the purpose of the ID’s when doing so.  (Yes, I’m hoping
to fix this, feel free to check back with me later on whether or not I’ve
updated this, and if so what the cost was of doing so.)</p>

<p>Where multiple channel
<a href="/doc/axi-spec.pdf">AXI</a>
masters really start to shine is if a single master
needs to access multiple slaves.  Imagine an
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
that doesn’t truly support IDs, such as <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">my current AXI crossbar
implementation</a>.
In such an <a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
a master might issue two requests: one for slave 1, and then
a second one for slave 2.  The
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
that doesn’t support ID’s must
first route the request to slave 1 <em>and then wait for the response</em> from slave
1 before routing the second request to slave number 2, as shown in Fig. 9
below.</p>

<table align="center" style="float: none"><caption>Fig 9. Interconnect only allows one connection between master and slave at a time</caption><tr><td><img src="/img/wbm2axisp/single-intercon.svg" alt="" width="480" /></td></tr></table>

<p>If the first slave takes a long time, the second request will be stuck
behind that first one until that reply comes back.  In the example shown in
Fig. 9 above, the first slave takes four clocks to return.  This keeps the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
from routing the second packet to the second slave until this first
response returns.  The second packet, therefore, suffers from a delay of
seven clock cycles, when a single clock cycle delay might have been possible.</p>

<p>On the other hand, if the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
were to provide full ID support, it should route the first request to slave 1,
and then route the second request to slave 2 even before slave 1 responds.</p>

<table align="center" style="float: none"><caption>Fig 10. Interconnect allows one connection between any given master,ID pair and slave at a time</caption><tr><td><img src="/img/wbm2axisp/multid-intercon.svg" alt="" width="408" /></td></tr></table>

<p>Unfortunately, while this looks faster in our figure above, the complexity
of the operation coupled with the desire for high clock speeds makes it so
that this form of
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
isn’t necessarily faster at all.  For example, the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
must now make certain that it keeps track of outstanding requests of every
&lt;master,ID&gt; combination, rather than one counter per master.  It needs to
know to what slave such &lt;master,ID&gt; pairs are assigned to, as well as the
number of outstanding transactions assigned to that slave.  This counter
is required to prevent a request from the same &lt;master,ID&gt; from being sent
to a subsequent slave and returning before the first slave’s response
returns.  This means it needs <code class="language-plaintext highlighter-rouge">2^{IDW}*(num masters)</code> counters, which might
each need to be updated on every cycle.</p>

<p>To make matters worse, what happens if both slave one and slave two respond
to the same master at the same time?  One of those two requests will need
to be stalled.  This return arbitration is likely going to cost another
clock, and another
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.</p>

<p>That leads to two obvious results of all of this extra logic: First, all
logic within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
or an <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>
has a cost.  You’ll pay for this extra cost.
Second, just because it sounds better on paper doesn’t mean it truly is in
practice.</p>

<p>There’s a third cost as well: <a href="/formal/2019/05/13/axifull.html">Xilinx’s demonstration AXI slave, generated by
their IP packager, will break if ever driven by a bursting multiple channel
master</a>.  It will also
break in a busy environment when driven by an
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
that needs to arbitrate return responses.  If your company uses designs built
from <a href="/formal/2019/05/13/axifull.html">these example designs</a>,
you’ll need to <a href="/blog/2019/05/29/demoaxi.html">update them</a>
before upgrading your
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> just to <a href="/formal/2019/09/06/axi-story.html">keep
your design from suddenly
seizing</a>.</p>

<p>This leads me to the following summary comparing single vs multichannel masters,
shown in Fig. 11 below.</p>

<table align="center" style="float: none"><caption>Fig 11. Comparing the advantages and disadvantages of using multiple AXI IDs</caption><tr><td><img src="/img/wbm2axisp/multichannel.svg" alt="" width="720" /></td></tr></table>

<p>Put simply, I haven’t yet found an example that makes the cost, both in logic
and latency, worth the price in complexity.</p>

<h2 id="designing-a-single-beat-pipelined-axi-master">Designing a single beat, pipelined AXI master</h2>

<table align="center" style="float: left; padding: 15px"><caption>Fig 12. Reasons you might not be able to use burst support</caption><tr><td><img src="/img/wbm2axisp/no-burst-reasons.svg" alt="" width="360" /></td></tr></table>

<p>For today’s design, let’s focus on an
<a href="/doc/axi-spec.pdf">AXI</a>
master that can handle single beat
requests in a pipelined fashion.  This would be the kind of
<a href="/doc/axi-spec.pdf">AXI</a> master you might write if you
didn’t know from one beat to the next if another request would be coming, or
even if so if you didn’t know where the next request would be made to.
Alternatively, maybe you do know the address of the next address, but it
doesn’t fit into any of
<a href="/doc/axi-spec.pdf">AXI</a>’s predetermined next burst address
choices.  Perhaps your are examining an image down the rows rather than across
the columns.  Perhaps you are attempting to feed a convolutional neural network
from voxels in a three dimensional space.  If for whatever reason you find
yourself unable to use bursts, this class of
<a href="/doc/axi-spec.pdf">AXI</a>
master should work nicely for you.</p>

<p>The good news for all of these applications is that <a href="https://www.xilinx.com/support/documentation/ip_documentation/mig_7series/v1_4/ug586_7Series_MIS.pdf">Xilinx’s SDRAM MIG
controller</a>
controller can handle single beat random access requests for reads or
writes (not both) with 100% throughput–depending of course upon your access
pattern.  This is based upon my own experience with it.  The bad news is that
their <a href="/doc/axi-spec.pdf">AXI</a>
<a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">block RAM controller</a>
cannot, as discussed above.</p>

<p>We’re going to go a bit beyond that minimum requirement today, however, and
discuss a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">Wishbone (pipelined, not classic) to AXI
bridge</a> such as
you might wish to use to access a <a href="https://www.xilinx.com/support/documentation/ip_documentation/mig_7series/v1_4/ug586_7Series_MIS.pdf">MIG memory
core</a>
from <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.  Due to
the <a href="/zipcpu/2017/11/07/wb-formal.html">specifics of our Wishbone bus
implementation</a>, this
is going to force some additional requirements on the bridge.</p>

<ul>
  <li>
    <p><a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> only allows
a single request, either read or write, at a time.
<a href="/doc/axi-spec.pdf">AXI</a>
allows independent read and write channels.  In order to make certain
we maintain the correct ordering between read and write responses, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this
core</a>
will only ever accept read requests or write requests.  Further, all
requests will be flushed before switching between the two.</p>

    <p>Yes, we could go faster by keeping track of which requests we issued and in
what order, but we’ll try to keep things a bit simpler today.</p>
  </li>
  <li>
    <p>My own <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
implementations</a>
allow a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort.  By this, I mean that if a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
master wants to abort all outstanding transactions, it can do
this by just dropping the cycle line for one clock cycle.
After that, all pending acknowledgments need to be suppressed.</p>

    <p>Unfortunately, <a href="/doc/axi-spec.pdf">AXI</a> offers no similar
capability.  This is the reason why so many individuals have struggled to
<a href="/blog/2020/03/14/axi-reset.html">reset AXI DMA cores</a>: if
your <a href="/formal/2019/05/13/axifull.html">AXI slave is broken</a>,
the <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>
might hang.  However, <a href="/blog/2020/03/14/axi-reset.html">you can’t reset the DMA while a transaction is
outstanding</a>–no matter
what the <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>
instructions might tell you.
<a href="/doc/axi-spec.pdf">AXI</a> <em>requires</em> one
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> response for every
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> request.</p>

    <p>This will mean that we need to <a href="/blog/2020/03/14/axi-reset.html">keep track of the number of outstanding
AXI responses</a>,
in case the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
master ever wish to abort an outstanding transaction, and so keep subsequent
responses from producing
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
acknowledgments.</p>
  </li>
</ul>

<table align="center" style="float: right"><caption>Fig 13. Lesson learned: Halt on a bus error</caption><tr><td><img src="/img/wbm2axisp/halt-on-error.svg" alt="" width="360" /></td></tr></table>

<ul>
  <li>
    <p>I also insist that every
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
master must issue a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort following any <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.  While the
<a href="/doc/wbspec_b4.pdf">Wishbone specification</a>
doesn’t necessarily require this, <a href="/zipcpu/2017/11/07/wb-formal.html">my own implementations
do</a>.</p>

    <p>In many ways, this just makes sense.  What should a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
do on a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>?
In general, the “right” answer is to halt the program at the first
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> return.  What should a
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>
do on a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>?
It should <a href="/blog/2020/03/14/axi-reset.html">halt the transfer as soon as possible on the first erroneous
return</a>.</p>
  </li>
  <li>
    <p>There’s one more piece of logic in
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this bridge</a>
that isn’t necessarily required by a generic bridge, and we’ll gloss over it
below: <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this
bridge</a>
will also (optionally) cross from a smaller
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
size to (possibly) a much larger
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
size.  The reason for this is quite simple: I use this core to drive the
<a href="/doc/axi-spec.pdf">AXI</a>
interface of an <a href="https://www.xilinx.com/support/documentation/ip_documentation/mig_7series/v1_4/ug586_7Series_MIS.pdf">MIG generated SDRAM
controller</a>,
and the natural width provided by the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
tends to be much larger.</p>

    <p>Yes, I suppose I could use one of the
<a href="/doc/axi-spec.pdf">AXI</a> size adjustment bridges within
<a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_interconnect/v2_1/pg059-axi-interconnect.pdf">Xilinx’s interconnect</a>.
I could, but it doesn’t really make sense to.  The size adjustment is
just a minimal amount of logic yet it requires a FIFO and a clock of latency
in each direction.  If I can merge those clocks together, I can then reduce
the overall latency in my design.</p>
  </li>
</ul>

<p>Were it not for these changes, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this AXI master
design</a>
would be really simple:</p>

<ol>
  <li>Set the <a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>
stall signal so that we’ll stall if any request is waiting to
be sent forwards.  This is perhaps the most complex part, since there are
many reasons why we might need to stall the upstream
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Let’s walk through each of them.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>First, we might stall if ever the AW channel is stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">o_axi_awvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_awready</span><span class="p">)</span>
			<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>We might also need to stall for essentially the same reason if the
write data channel is stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">o_axi_wvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_wready</span><span class="p">)</span>
			<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>The same applies to the read address channel.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">o_axi_arvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_arready</span><span class="p">)</span>
			<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>If you are <a href="/blog/2017/06/12/minimizing-luts.html">counting combinatorial logic bits, like you should
be</a>, then we are
now at six bits.  That’s not really so bad, it fits nicely in just one 6-LUT.</p>

<p>Only … we haven’t yet added our extra requirements.  Specifically, if we are
waiting on read (or write) returns and we now want to reverse the direction
of the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
then we need to stall until the system is flushed enough that we can reverse the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> direction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_we</span> <span class="o">!=</span> <span class="n">direction</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">))</span>
			<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Remember, we’ve chosen the approach that we’ll only ever go in one direction
at a time, and we’ll flush the design before switching directions.</p>

<p>Finally, if we are in the process of flushing all
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> returns following a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> abort, or if our
counter is about ready to overflow, then we’ll need to stall the incoming
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">flushing</span> <span class="o">||</span> <span class="n">nearfull</span><span class="p">)</span>
			<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Since that’s a lot of logic, we’ll be using a
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a> below to
make sure it gets registered before leaving
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">our core</a>.</p>

<ol start="2">
  <li>On any <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.
write request, where <code class="language-plaintext highlighter-rouge">i_wb_stb &amp;&amp; i_wb_we</code>, set <code class="language-plaintext highlighter-rouge">AWVALID</code>, <code class="language-plaintext highlighter-rouge">WVALID</code>
<code class="language-plaintext highlighter-rouge">AWADDR</code>, and <code class="language-plaintext highlighter-rouge">WDATA</code>.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Always clear any handshaking signals on reset.</span>
		<span class="c1">//</span>
		<span class="n">o_axi_awvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">o_axi_wvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_wb_we</span> <span class="o">&amp;&amp;</span> <span class="n">i_wb_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// On any new write request, set both AWVALID and AWREADY</span>
		<span class="n">o_axi_awvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="n">o_axi_wvalid</span>  <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>Once each of these gets accepted, we’ll clear it to prepare for the next
transaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">i_axi_awready</span><span class="p">)</span>
			<span class="n">o_axi_awvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_axi_wready</span><span class="p">)</span>
			<span class="n">o_axi_wvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Always be aware, when building a cascaded if structure like this, of what
would happen in an earlier if statement were true.  In this case, <code class="language-plaintext highlighter-rouge">o_wb_stall</code>
will keep us from setting both <code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code> if ever one of the
two is still stalled from a prior request.  Otherwise, it would preempt the
clearing of one of the two, and so it allows us to send multiple requests
on consecutive clock cycles.</p>

<p>This was what we wanted.</p>

<p>Let me pause here for a moment to note that this is the structure your
logic will need–even if you are building a pipelined master for a different
purpose.  Surprisingly, this write logic structure doesn’t change much from
one design to the next.  1) You always want to reset any <code class="language-plaintext highlighter-rouge">*VALID</code>
signals.  2) You’ll always want to set both <code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code> together
on any new write request (even if the
<a href="/doc/axi-spec.pdf">spec</a> doesn’t require that they be
synchronized).  3) Once the
the appropriate <code class="language-plaintext highlighter-rouge">*READY</code> line has been raised, you’ll want to clear each of
<code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code> individually.  4) Don’t start a new request
until both would otherwise be clear on the next cycle.</p>

<p>Not all designs keep the write address and write data channels synchronized.
I find that it’s easier to verify the designs if the two channels are
synchronized, so we’ll force them to be synchronized here by not initiating any
new transactions until both signals from the last transaction have been
accepted.  Further, as I’ve learned from my new <a href="https://github.com/ZipCPU/axidmacheck">DMA testbed
project</a> shown in Fig. 8 above, if you
don’t keep the two write channels synchronized, then the entire write operation
will be slowed down every time a slave needs to synchronize them.</p>

<p>Moving on to the write channel, the logic is similar but subtly different.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_axi_wvalid</span> <span class="o">||</span> <span class="n">i_axi_wready</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_axi_wdata</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">;</span>
		<span class="n">o_axi_wstrb</span> <span class="o">&lt;=</span> <span class="n">i_wb_sel</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>While you might reset any data associated with a request as well, it’s not
necessary to do so.  In an effort to keep our logic low, we’ll set both
<code class="language-plaintext highlighter-rouge">WDATA</code> and <code class="language-plaintext highlighter-rouge">WSTRB</code> above any time the channel isn’t stalled.  This isn’t
necessarily the low power approach.  If you wanted lower power, you
would want to minimize the number of transitions on your wires–particularly
on any <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> wires.  Adding a
little bit of logic here to make that happen isn’t all that hard,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_stb</span> <span class="o">&amp;&amp;</span> <span class="n">i_wb_we</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_axi_wdata</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">;</span>
		<span class="n">o_axi_wstrb</span> <span class="o">&lt;=</span> <span class="n">i_wb_sel</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>but in this case it just makes timing more difficult.  Remember, for example,
that <code class="language-plaintext highlighter-rouge">o_wb_stall</code> had a rather large computational burden on it already.
This is why I chose to gate these values on <code class="language-plaintext highlighter-rouge">(!o_axi_wvalid || i_axi_wready)</code>
instead.</p>

<p>Setting <code class="language-plaintext highlighter-rouge">AWADDR</code> is a touch more difficult, simply because
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> is word
addressed whereas <a href="/doc/axi-spec.pdf">AXI</a> is byte addressed.
Hence, we’ll need to take the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
address and append some number of zeros to it.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">DW</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="c1">// Wishbone data width</span>

	<span class="c1">// ...</span>

	<span class="kt">wire</span>	<span class="p">[$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">WB_DATA_WIDTH</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">axi_lsbs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// ...</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_axi_awvalid</span> <span class="o">||</span> <span class="n">i_axi_awready</span><span class="p">)</span>
		<span class="n">o_axi_awaddr</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">m_addr</span><span class="p">,</span> <span class="n">axi_lsbs</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Note that this also follows the same logical structure that <code class="language-plaintext highlighter-rouge">WDATA</code> followed
above: the address gets updated if ever the channel isn’t stalled.  As before,
a lower power approach exists, but I’ve chosen to go with the lower logic
approach here.</p>

<ol start="3">
  <li>Read requests are similar.  On any read request, where
<code class="language-plaintext highlighter-rouge">i_wb_stb &amp;&amp; !i_wb_we</code>, set <code class="language-plaintext highlighter-rouge">ARVALID</code> and <code class="language-plaintext highlighter-rouge">ARADDR</code>.</li>
</ol>

<p>Setting <code class="language-plaintext highlighter-rouge">ARADDR</code> is identical to what we did before with <code class="language-plaintext highlighter-rouge">AWADDR</code>, but
<code class="language-plaintext highlighter-rouge">ARVALID</code> is just a touch different simply because we don’t have two channels
that need synchronization.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="c1">// Clear on any reset</span>
		<span class="n">o_axi_arvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_wb_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_wb_we</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
		<span class="c1">// Set on any request</span>
		<span class="n">o_axi_arvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_axi_arready</span><span class="p">)</span>
		<span class="c1">// Clear once the request is accepted</span>
		<span class="n">o_axi_arvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<ol start="4">
  <li>As long as the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
widths are the same, we can just return the read values.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">i_axi_rdata</span><span class="p">;</span></code></pre></figure>

<ol start="5">
  <li><a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
has no ability to stall any returns.  This makes setting any
<code class="language-plaintext highlighter-rouge">o_wb_ack</code> or <code class="language-plaintext highlighter-rouge">o_wb_err</code> signal easy.</li>
</ol>

<p>Unlike <a href="/doc/axi-spec.pdf">AXI</a>,
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> has two return
signals, <code class="language-plaintext highlighter-rouge">ack</code> and <code class="language-plaintext highlighter-rouge">err</code>.  <a href="/doc/axi-spec.pdf">AXI</a> has a
valid signal together with a 2-bit status captured by the <code class="language-plaintext highlighter-rouge">xRESP</code> signal.  Of
the four possible status returns, we only care if the top bit is high
indicating an <a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.  Hence, we
can write:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_wb_ack</span> <span class="o">=</span> <span class="o">!</span><span class="n">flushing</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_bresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="o">||</span><span class="p">(</span><span class="n">i_axi_rvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_rresp</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

	<span class="k">assign</span>	<span class="n">o_wb_err</span> <span class="o">=</span> <span class="o">!</span><span class="n">flushing</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_bresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="o">||</span><span class="p">(</span><span class="n">i_axi_rvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_rresp</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span></code></pre></figure>

<p>The big difference here from what might otherwise be a simple return is
this <code class="language-plaintext highlighter-rouge">flushing</code> signal.  I use this signal as part of the <a href="/blog/2020/03/14/axi-reset.html">core’s reset
logic</a>.  If we are ever
<code class="language-plaintext highlighter-rouge">flushing</code> the pipeline, then we want to <a href="/blog/2020/03/14/axi-reset.html">ignore any and all acknowledgments
as we return back to an idle
state</a>.</p>

<ol start="6">
  <li>Given that
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
has no ability to stall the return acknowledgment, we can also hold
the respective backpressure signals high.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_axi_bready</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">o_axi_rready</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Indeed, I’d recommend you hold these signals high in any master you build.
If you hold these constant, you might be able to get the optimizer to remove
any return <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
that might be within the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>.
That said, I haven’t consistently held these values high within my own
designs.  While my <a href="/doc/axi-spec.pdf">AXI</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM</a> and
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">MM2S</a>
cores do hold these high, my <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbexecaxi.v">AXI-lite debugging bus
master</a>
captures state information within these two ready signals so adjusting the
logic so as to hold these signals high would require some rework.</p>

<p>Well, at least that’s the basics.</p>

<p>There’s one ugly trick remaining, and that is counting the number of
transaction returns we are expecting so that we can 1) <a href="/blog/2020/03/14/axi-reset.html">flush the
channel</a>
on any <a href="https://en.wikipedia.org/wiki/Bus_error">error</a> or
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort, and 2) know that the channel is clear in order to change direction.</p>

<p>The reason why this is ugly is that any time you place a counter within
your design, a counter that should never overflow, then you also need to
place a check within your design to make certain that the counter truly
never overflows.  Don’t forget this check!</p>

<p>Our basic counter will count up any time <code class="language-plaintext highlighter-rouge">o_wb_stb &amp;&amp; !o_wb_stall</code>, and
down any time <code class="language-plaintext highlighter-rouge">BVALID || RVALID</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">npending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span> <span class="p">(</span><span class="n">o_wb_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_wb_stall</span><span class="p">),</span> <span class="p">(</span><span class="n">i_axi_bvalid</span> <span class="o">||</span> <span class="n">i_axi_rvalid</span><span class="p">)</span><span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="n">npending</span> <span class="o">&lt;=</span> <span class="n">npending</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="n">npending</span> <span class="o">&lt;=</span> <span class="n">npending</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">endcase</span>

	<span class="k">assign</span>	<span class="n">empty</span> <span class="o">=</span> <span class="p">(</span><span class="n">npending</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">assign</span>	<span class="n">full</span> <span class="o">==</span> <span class="p">(</span><span class="n">npending</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGFIFO</span><span class="p">));</span>
	<span class="k">assign</span>	<span class="n">nearfull</span> <span class="o">==</span> <span class="p">(</span><span class="n">npending</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGFIFO</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Or at least that’s the idea.  In <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">my implementation
below</a>,
I’m going to register <code class="language-plaintext highlighter-rouge">empty</code>, <code class="language-plaintext highlighter-rouge">full</code>, and <code class="language-plaintext highlighter-rouge">nearfull</code> so that I don’t
<a href="/blog/2017/06/12/minimizing-luts.html">burden the logic on any subsequent
clocks</a>
with those calculations.</p>

<p>Once we know when there are no requests outstanding, we can then keep
track of direction.  Specifically, we can change direction any time
there’s nothing pending.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
		<span class="n">direction</span> <span class="o">&lt;=</span> <span class="n">i_wb_we</span><span class="p">;</span></code></pre></figure>

<p>That leaves us with only one more piece of logic: when do we need to
<a href="/blog/2020/03/14/axi-reset.html">flush</a> the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="/blog/2017/08/14/strategies-for-pipelining.html">pipeline</a>
of any pending requests?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">flushing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">flushing</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>On any read or write <a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
we’ll want to start <a href="/blog/2020/03/14/axi-reset.html">flushing the
pipeline</a>–since
we are assuming that the
<a href="/blog/2017/06/08/simple-wb-master.html">Wishbone master</a>
will immediately abort any ongoing
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transactions following an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> return.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_axi_rvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_rresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="o">||</span><span class="p">(</span><span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_bresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></code></pre></figure>

<p>Similarly, if the master ever drops the cycle line while a request is pending
then we’ll also want to <a href="/blog/2020/03/14/axi-reset.html">flush any ongoing
operations</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">empty</span><span class="p">))</span>
		<span class="n">flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Once the <a href="/blog/2020/03/14/axi-reset.html">pipeline has been
flushed</a>
and there are no more outstanding transactions, then we can return to servicing
incoming requests.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
		<span class="n">flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Or, at least that’s a brief overview of how
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this core</a>
would work if it were really that simple.  In general, your own core may
easily follow the same structure, since this isn’t all that different from any
<a href="/doc/axi-spec.pdf">AXI</a> master in general.  At least it’s
not that different from any other <a href="/doc/axi-spec.pdf">AXI</a>
master that 1) holds the <code class="language-plaintext highlighter-rouge">AxID</code> fields constant, and 2) holds <code class="language-plaintext highlighter-rouge">AxLEN==0</code>.</p>

<p>Notice also that setting the the <code class="language-plaintext highlighter-rouge">Ax*</code> register fields was fairly simple.
Handling returns wasn’t that hard either.  The big trick to <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this
core</a>
is the counter that counts the number of ongoing transactions.</p>

<p>Imagine that: after years of studying
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designs you find that the tricky part of the design turns out to be a
counter, the very same thing you studied back on day one when you started
learning digital logic.</p>

<h2 id="axi-master-logic">AXI Master Logic</h2>

<p>It’s now time to walk through the logic of
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">the core</a>
itself.  As we do this walk through, you’ll see a couple big differences
from the conceptual logic we quickly sketched above.  The first big
difference is that we use a
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
on the input to reduce the timing burden on the actual <code class="language-plaintext highlighter-rouge">o_wb_stall</code> signal.
The second big difference is that <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this
core</a> can
handle an upsizing data width conversion.  This would be really easy, save for
selecting the correct subword from the returned data word.  The last big
difference is that several of the transaction counter flags are registered.</p>

<p>Perhaps these differences really aren’t all that big.  Either way, let’s start
our walk through in detail.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
generator, <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
in this case, knows the size of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> widths <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this
core</a> connects
to.  The parameters <code class="language-plaintext highlighter-rouge">C_AXI_DATA_WIDTH</code> and <code class="language-plaintext highlighter-rouge">DW</code> capture the width of the
<a href="/doc/axi-spec.pdf">AXI</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> and the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> respectively.  In a
similar manner, <code class="language-plaintext highlighter-rouge">C_AXI_ADDR_WIDTH</code> and <code class="language-plaintext highlighter-rouge">AW</code> capture the address widths of the
two busses, <a href="/doc/axi-spec.pdf">AXI</a> and
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a> respectively,
as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">wbm2axisp</span> <span class="p">#(</span>
	<span class="k">parameter</span> <span class="n">C_AXI_DATA_WIDTH</span>	<span class="o">=</span> <span class="mi">128</span><span class="p">,</span><span class="c1">// Width of the AXI R&amp;W data</span>
	<span class="k">parameter</span> <span class="n">C_AXI_ADDR_WIDTH</span>	<span class="o">=</span>  <span class="mi">28</span><span class="p">,</span>	<span class="c1">// AXI Address width (log wordsize)</span>
	<span class="k">parameter</span> <span class="n">C_AXI_ID_WIDTH</span>	<span class="o">=</span>   <span class="mi">1</span><span class="p">,</span>
	<span class="k">parameter</span> <span class="n">DW</span>			<span class="o">=</span>  <span class="mi">32</span><span class="p">,</span>	<span class="c1">// Wishbone data width</span>
	<span class="k">parameter</span> <span class="n">AW</span>			<span class="o">=</span>  <span class="mi">26</span><span class="p">,</span>	<span class="c1">// Wishbone address width (log wordsize)</span>
	<span class="k">parameter</span> <span class="p">[</span><span class="n">C_AXI_ID_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">AXI_WRITE_ID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">,</span>
	<span class="k">parameter</span> <span class="p">[</span><span class="n">C_AXI_ID_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">AXI_READ_ID</span>  <span class="o">=</span> <span class="mb">1'b1</span><span class="p">,</span>
	<span class="k">parameter</span> <span class="n">LGFIFO</span>		<span class="o">=</span>   <span class="mi">6</span>
	<span class="p">)</span> <span class="p">(</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_clk</span><span class="p">,</span>	<span class="c1">// System clock</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_reset</span><span class="p">,</span><span class="c1">// Reset signal,drives AXI rst</span></code></pre></figure>

<p>The two IDs, <code class="language-plaintext highlighter-rouge">AXI_WRITE_ID</code> and <code class="language-plaintext highlighter-rouge">AXI_READ_ID</code>, will contain our constant
<a href="/doc/axi-spec.pdf">AXI</a> ID values–assuming the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> even uses them.</p>

<p>The <code class="language-plaintext highlighter-rouge">LGFIFO</code> parameter captures the size of the FIFO above.  You can think of
this as the log of the number of transactions you might have outstanding, the
bit width of our transaction counter if you will.  It’s more than that though.
When doing a data conversion, even going up, you need to keep track of the
low order address bits in order to be able to select the correct data word
on return.  This requires a per-beat FIFO, and <code class="language-plaintext highlighter-rouge">LGFIFO</code> also keeps track of
the log of the number of elements in our FIFO.  At <code class="language-plaintext highlighter-rouge">LGFIFO=6</code>, we can keep
track of 64 outstanding transactions.  That’s enough latency that we shouldn’t
need to worry about being impacted by the <a href="https://opencores.org/projects/wbddr3">(horrendous) latency of the MIG
SDRAM controller</a>.</p>

<p>We can simplify some of these parameters as well here.  In particular, the
conversion from a word based address to a byte based address on a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> that might not be the same
size is going to take a bit of help.  These <code class="language-plaintext highlighter-rouge">localparam</code>s will help simplify
that conversion.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">LG_AXI_DW</span>	<span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">);</span>
	<span class="k">localparam</span>	<span class="n">LG_WB_DW</span>	<span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">DW</span><span class="p">);</span>
	<span class="k">localparam</span>	<span class="n">FIFOLN</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGFIFO</span><span class="p">);</span>
	<span class="k">localparam</span>	<span class="n">SUBW</span> <span class="o">=</span> <span class="n">LG_AXI_DW</span><span class="o">-</span><span class="n">LG_WB_DW</span><span class="p">;</span></code></pre></figure>

<p>It’s important to note that the address widths of the two busses are coupled
in a way that’s not really captured by the parameters above.  In particular,
the <a href="/doc/axi-spec.pdf">AXI</a> address width must be equal to
the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> address
width plus the number of subword address bits.  (Note that the
<a href="/doc/axi-spec.pdf">AXI</a> address width doesn’t change as the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> changes data widths,
unlike the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
address width.) Here, we can use the Verilog <code class="language-plaintext highlighter-rouge">$stop</code> function to make certain
that the design won’t even build if the parameters aren’t set up properly.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span> <span class="o">&lt;</span> <span class="n">DW</span><span class="p">)</span>
			<span class="p">$</span><span class="nb">stop</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">C_AXI_ADDR_WIDTH</span> <span class="o">!=</span> <span class="n">AW</span> <span class="o">+</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">DW</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
			<span class="p">$</span><span class="nb">stop</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span>	  <span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span> <span class="o">/</span> <span class="n">DW</span> <span class="o">!=</span><span class="mi">32</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span> <span class="o">/</span> <span class="n">DW</span> <span class="o">!=</span><span class="mi">16</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span> <span class="o">/</span> <span class="n">DW</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span> <span class="o">/</span> <span class="n">DW</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span> <span class="o">/</span> <span class="n">DW</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span>      <span class="o">!=</span> <span class="n">DW</span><span class="p">))</span>
			<span class="p">$</span><span class="nb">stop</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Most of the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> wires don’t
ever need to be changed.  The more values we fix like this, the simpler our
logic will be below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">DWSIZE</span> <span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">DW</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">;</span>
	<span class="k">assign</span> <span class="n">o_axi_awid</span>    <span class="o">=</span> <span class="n">AXI_WRITE_ID</span><span class="p">;</span>
	<span class="k">assign</span> <span class="n">o_axi_awlen</span>   <span class="o">=</span> <span class="mh">8'h0</span><span class="p">;</span>	<span class="c1">// Burst length is one</span>
	<span class="k">assign</span> <span class="n">o_axi_awsize</span>  <span class="o">=</span> <span class="n">DWSIZE</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">assign</span> <span class="n">o_axi_wlast</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">assign</span> <span class="n">o_axi_awburst</span> <span class="o">=</span> <span class="mb">2'b01</span><span class="p">;</span>	<span class="c1">// Incrementing address (ignored)</span>
	<span class="k">assign</span> <span class="n">o_axi_awlock</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>	<span class="c1">// Normal signaling</span>
	<span class="k">assign</span> <span class="n">o_axi_arlock</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>	<span class="c1">// Normal signaling</span>
	<span class="k">assign</span> <span class="n">o_axi_awcache</span> <span class="o">=</span> <span class="mh">4'h2</span><span class="p">;</span>	<span class="c1">// Normal: no cache, no buffer</span>
	<span class="k">assign</span> <span class="n">o_axi_awprot</span>  <span class="o">=</span> <span class="mb">3'b010</span><span class="p">;</span>	<span class="c1">// Unpriviledged, unsecure, data access</span>
	<span class="k">assign</span> <span class="n">o_axi_awqos</span>   <span class="o">=</span> <span class="mh">4'h0</span><span class="p">;</span>	<span class="c1">// Lowest quality of service (unused)</span>
	<span class="c1">//</span>
	<span class="k">assign</span> <span class="n">o_axi_arid</span>    <span class="o">=</span> <span class="n">AXI_READ_ID</span><span class="p">;</span>
	<span class="k">assign</span> <span class="n">o_axi_arlen</span>   <span class="o">=</span> <span class="mh">8'h0</span><span class="p">;</span>	<span class="c1">// Burst length is one</span>
	<span class="k">assign</span> <span class="n">o_axi_arsize</span>  <span class="o">=</span> <span class="n">DWSIZE</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">assign</span> <span class="n">o_axi_arburst</span> <span class="o">=</span> <span class="mb">2'b01</span><span class="p">;</span>	<span class="c1">// Incrementing address (ignored)</span>
	<span class="k">assign</span> <span class="n">o_axi_arcache</span> <span class="o">=</span> <span class="mh">4'h2</span><span class="p">;</span>	<span class="c1">// Normal: no cache, no buffer</span>
	<span class="k">assign</span> <span class="n">o_axi_arprot</span>  <span class="o">=</span> <span class="mb">3'b010</span><span class="p">;</span>	<span class="c1">// Unpriviledged, unsecure, data access</span>
	<span class="k">assign</span> <span class="n">o_axi_arqos</span>   <span class="o">=</span> <span class="mh">4'h0</span><span class="p">;</span>	<span class="c1">// Lowest quality of service (unused)</span></code></pre></figure>

<p>In particular, you should note that we’ve held the <code class="language-plaintext highlighter-rouge">AxID</code> values constant,
and that <code class="language-plaintext highlighter-rouge">AxLEN == 0</code> for every burst.  These are the two defining
characteristics of <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this particular class of AXI
master</a>.
They also allow me to simplify the <code class="language-plaintext highlighter-rouge">WLAST</code> calculation, and simply hold that
signal high above.  Similarly, the <code class="language-plaintext highlighter-rouge">AxSIZE</code> parameter is set based upon the
size of the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
<code class="language-plaintext highlighter-rouge">$clog2(DW)-3</code>.  You might wish to note that by referencing a bit-range
within a constant <code class="language-plaintext highlighter-rouge">localparam</code>, I’ve been able to get past the bit-width warning
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
might otherwise produce.</p>

<p>Most of the rest of the signals above will be ignored by the large majority
of <a href="/doc/axi-spec.pdf">AXI</a> components out there.  In general
they can be set to 0, although I’ve tried to be a bit fancier here by setting
<code class="language-plaintext highlighter-rouge">AxPROT</code> to <code class="language-plaintext highlighter-rouge">3'b010</code> and <code class="language-plaintext highlighter-rouge">AxCACHE</code> to <code class="language-plaintext highlighter-rouge">4'h2</code>.  I haven’t really had any good
feedback, either from the <a href="/doc/axi-spec.pdf">AXI
specification</a> or any cores that
depend upon these values, to know if they’ve been well chosen or not.</p>

<p>I mentioned above that I’d need to know the number of bits that needed to be
set to convert a <a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>
address to an <a href="/doc/axi-spec.pdf">AXI</a> address.  In order to
avoid setting these bits to <code class="language-plaintext highlighter-rouge">{($clog2(DW)-3){1'b0}}</code> every time, I’ve created
a simple helper value in <code class="language-plaintext highlighter-rouge">axi_lsbs</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">wire</span>	<span class="p">[$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">DW</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">axi_lsbs</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">axi_lsbs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>I don’t normally discuss register declarations here, but I did want to make
one point regarding the following declarations.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>			<span class="n">direction</span><span class="p">,</span> <span class="n">full</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">flushing</span><span class="p">,</span> <span class="n">nearfull</span><span class="p">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="n">LGFIFO</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">npending</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="kt">wire</span>			<span class="n">skid_ready</span><span class="p">,</span> <span class="n">m_valid</span><span class="p">,</span> <span class="n">m_we</span><span class="p">;</span>
	<span class="kt">reg</span>			<span class="n">m_ready</span><span class="p">;</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">m_addr</span><span class="p">;</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="n">DW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">m_data</span><span class="p">;</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">m_sel</span><span class="p">;</span></code></pre></figure>

<p>After finding one major vendor tool that couldn’t properly handle a reference
to a register that was defined later in a design, I’ve been slowly converting
all of my designs so that the register or wire declarations are all done at
the top of every module and before any logic that might reference them.  Yes,
this simple “language feature” that was treated differently by diffferent tools
led to <a href="/blog/2018/08/04/sim-mismatch.html">simulation/synthesis
mismatch</a>.  By declaring
my registers up top, I should be able to help avoid that again in the future.</p>

<p>The second thing to comment on are the <code class="language-plaintext highlighter-rouge">m_*</code> signals.  In order to simplify the
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>, I added a
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.
As we’ll see further down, these <code class="language-plaintext highlighter-rouge">m_*</code> signals capture the outputs of that
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
so they should (roughly) mirror the <code class="language-plaintext highlighter-rouge">i_wb_*</code> signals.  (The names aren’t
perfect matches, though, since I’m using <code class="language-plaintext highlighter-rouge">m_value</code> to mirror <code class="language-plaintext highlighter-rouge">i_wb_stb</code>.)</p>

<p>As discussed above, if ever nothing is pending we can change the direction
the design is going in.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">direction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
		<span class="n">direction</span> <span class="o">&lt;=</span> <span class="n">m_we</span><span class="p">;</span></code></pre></figure>

<p>Here’s the first big change from above.  Remember the count of outstanding
transactions?  Here’s that count again, only this time we’re going to keep
track of and register all of the other associated signals along the way.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">npending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">empty</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">full</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">nearfull</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">npending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">empty</span>    <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">full</span>     <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nearfull</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">case</span> <span class="p">(</span><span class="o">{</span><span class="n">m_valid</span> <span class="o">&amp;&amp;</span> <span class="n">m_ready</span><span class="p">,</span> <span class="n">i_axi_bvalid</span><span class="o">||</span><span class="n">i_axi_rvalid</span><span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">npending</span> <span class="o">&lt;=</span> <span class="n">npending</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">empty</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nearfull</span> <span class="o">&lt;=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">npending</span><span class="p">[</span><span class="n">LGFIFO</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">full</span> <span class="o">&lt;=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">npending</span><span class="p">[</span><span class="n">LGFIFO</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">end</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">nearfull</span> <span class="o">&lt;=</span> <span class="n">full</span><span class="p">;</span>
		<span class="n">npending</span> <span class="o">&lt;=</span> <span class="n">npending</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">empty</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">npending</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">full</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>I should note that I’ve now debugged several student designs that have
gotten this simple logic wrong.  It’s not if <code class="language-plaintext highlighter-rouge">(m_valid &amp;&amp; m_ready)</code> then
increment the counter, else if <code class="language-plaintext highlighter-rouge">(bvalid||bready)</code> decrement it.  This seems
to be a common mistake.  Don’t forget the likelihood that both might be true
at the same time!  Verilog design is not software design, <a href="/blog/2017/09/18/clocks-for-sw-engineers.html">everything runs in
parallel</a>.</p>

<p>Don’t let the the <code class="language-plaintext highlighter-rouge">m_valid</code> signal look new at all.  It’s simply a replacement
for the <code class="language-plaintext highlighter-rouge">i_wb_stb</code> signal but on the other side of the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>, since I
used the <a href="/doc/axi-spec.pdf">AXI</a> handshaking terminology
when building my <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a>.
For that reasons, the <code class="language-plaintext highlighter-rouge">m_ready</code> signal is a <code class="language-plaintext highlighter-rouge">!stall</code> indicator at the same
interface.</p>

<p>The <code class="language-plaintext highlighter-rouge">flushing</code> logic matches what we discussed above.  We start flushing the
design on any <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
or <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> abort condition, and
then keep flushing until there are no more outstanding transactions.  We’ll
use the formal tools to make certain we have this and our counter right
along the way.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">flushing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">flushing</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_axi_rvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_rresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="o">||</span><span class="p">(</span><span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_bresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">empty</span><span class="p">))</span>
		<span class="n">flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
		<span class="n">flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>That brings us to the <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a>.  We’ll send all of
the incoming <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> signals into
the <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.  This
allows us to present <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this design
component</a>
to the <a href="/blog/2019/07/17/crossbar.html">interconnect</a>
using a registered stall signal, albeit while burdening the logic of the other
incoming signals.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">DW</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">AW</span><span class="o">+</span><span class="n">DW</span><span class="o">+</span><span class="p">(</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="p">)),</span>
		<span class="p">.</span><span class="n">OPT_OUTREG</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">))</span>
	<span class="n">skid</span> <span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="n">i_reset</span> <span class="o">||</span> <span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">,</span>
		<span class="n">i_wb_stb</span><span class="p">,</span> <span class="n">skid_ready</span><span class="p">,</span>
			<span class="o">{</span> <span class="n">i_wb_we</span><span class="p">,</span> <span class="n">i_wb_addr</span><span class="p">,</span> <span class="n">i_wb_data</span><span class="p">,</span> <span class="n">i_wb_sel</span> <span class="o">}</span><span class="p">,</span>
		<span class="n">m_valid</span><span class="p">,</span> <span class="n">m_ready</span><span class="p">,</span>
			<span class="o">{</span> <span class="n">m_we</span><span class="p">,</span> <span class="n">m_addr</span><span class="p">,</span> <span class="n">m_data</span><span class="p">,</span> <span class="n">m_sel</span> <span class="o">}</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="o">!</span><span class="n">skid_ready</span><span class="p">;</span></code></pre></figure>

<p>Let me pause here, though, to point out the <code class="language-plaintext highlighter-rouge">!i_wb_cyc</code> term in the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>’s
reset input.  This is part of flushing the design in case of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort–anything that hasn’t gone to the
<a href="/doc/axi-spec.pdf">AXI</a> side of the design needs to be wiped
clean if ever <code class="language-plaintext highlighter-rouge">!i_wb_cyc</code>.  (Yes, it took a couple times through with the
formal tools to get this right.)</p>

<p>Remember the <code class="language-plaintext highlighter-rouge">o_wb_stall</code> logic we worked through above?  This is now the
<code class="language-plaintext highlighter-rouge">m_ready</code> logic below.  It captures whether or not we are ready to accept
a signal from the <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a> or not.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">m_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flushing</span> <span class="o">||</span> <span class="n">nearfull</span> <span class="o">||</span> <span class="p">((</span><span class="n">m_we</span> <span class="o">!=</span> <span class="n">direction</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">)))</span>
			<span class="n">m_ready</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_axi_awvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_awready</span><span class="p">)</span>
			<span class="n">m_ready</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_axi_wvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_wready</span><span class="p">)</span>
			<span class="n">m_ready</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_axi_arvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_arready</span><span class="p">)</span>
			<span class="n">m_ready</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>As you may rememeber, this ready signal was a key part of the <a href="/blog/2020/03/08/easyaxil.html">simplified
AXI-lite design</a>.  It
fulfills the same basic function here, even though we’ve combined both
read and write channels when building it.  The goal is simply that we know
we are accepting a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> signal into the
<a href="/doc/axi-spec.pdf">AXI</a>
side of the interface anytime <code class="language-plaintext highlighter-rouge">m_valid &amp;&amp; m_ready</code> are true together.</p>

<p>The <code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code> logic below should match our logic above signal
for signal, save for the difference of using the outputs from the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_axi_awvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">o_axi_wvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_axi_awvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">o_axi_wvalid</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_valid</span> <span class="o">&amp;&amp;</span> <span class="n">m_we</span> <span class="o">&amp;&amp;</span> <span class="n">m_ready</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_axi_awvalid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">o_axi_wvalid</span>  <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_axi_awready</span><span class="p">)</span>
			<span class="n">o_axi_awvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_axi_wready</span><span class="p">)</span>
			<span class="n">o_axi_wvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">WDATA</code> logic is slightly different as well.  In this case, we assume
we are upsizing.  We also know that
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
sizes are only ever powers of two.
This allows us to just repeat our data register across <code class="language-plaintext highlighter-rouge">o_axi_wdata</code>.
The alternative, shifting <code class="language-plaintext highlighter-rouge">m_data</code> by an amount given in the low order bits
of <code class="language-plaintext highlighter-rouge">m_addr</code>, would be annoying to do and get right.  Duplicating everything
is just the simple way to handle it.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_axi_wvalid</span> <span class="o">||</span> <span class="n">i_axi_wready</span><span class="p">)</span>
		<span class="n">o_axi_wdata</span>   <span class="o">&lt;=</span> <span class="o">{</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">/</span><span class="n">DW</span><span class="p">)</span><span class="o">{</span><span class="n">m_data</span><span class="o">}}</span><span class="p">;</span></code></pre></figure>

<p>Here’s the <code class="language-plaintext highlighter-rouge">ARVALID</code> logic.  Again, it’s much like you might expect.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_axi_arvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_axi_arvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">m_we</span> <span class="o">&amp;&amp;</span> <span class="n">m_ready</span><span class="p">)</span>
		<span class="n">o_axi_arvalid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_axi_arready</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_axi_arvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>The big thing to note about this <code class="language-plaintext highlighter-rouge">ARVALID</code> logic is that 1) it represents
a separate state machine from the <code class="language-plaintext highlighter-rouge">RVALID</code> logic below, and 2) we allow
multiple transactions to be outstanding.</p>

<p>We can also update the address registers any time the respective
address channels aren’t stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_axi_awvalid</span> <span class="o">||</span> <span class="n">i_axi_awready</span><span class="p">)</span>
		<span class="n">o_axi_awaddr</span>  <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">m_addr</span><span class="p">,</span> <span class="n">axi_lsbs</span> <span class="o">}</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_axi_arvalid</span> <span class="o">||</span> <span class="n">i_axi_arready</span><span class="p">)</span>
		<span class="n">o_axi_araddr</span>  <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">m_addr</span><span class="p">,</span> <span class="n">axi_lsbs</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Notice the <code class="language-plaintext highlighter-rouge">!VALID || READY</code> check.  This one’s easy to mess up.  In one
<a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_ethernetlite/v3_0/pg135-axi-ethernetlite.pdf">Xilinx ethernet design</a>,
the designer only checked for <code class="language-plaintext highlighter-rouge">READY</code>, not <code class="language-plaintext highlighter-rouge">!VALID || READY</code>.  The
<a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_ethernetlite/v3_0/pg135-axi-ethernetlite.pdf">design</a>
would then fail in the presence of a multiple master-ID capable
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
that had to arbitrate return responses.  Further, it’s worth reflecting on the
fact that <code class="language-plaintext highlighter-rouge">!VALID || READY</code> is the negation of <code class="language-plaintext highlighter-rouge">VALID &amp;&amp; !READY</code>,
<a href="/doc/axi-spec.pdf">AXI</a> stall condition.
Hence, any time the respective address channels are not stalled,
then we want to adjust the addresses.</p>

<p>When it comes to setting <code class="language-plaintext highlighter-rouge">WSTRB</code>, I chose a rather verbose approach.  If
the two data widths are the same, <code class="language-plaintext highlighter-rouge">m_sel</code> can just be copied to <code class="language-plaintext highlighter-rouge">WSTRB</code>.
If not, you need to be careful which <code class="language-plaintext highlighter-rouge">WSTRB</code> bits get set–since these
indicate which bytes will actually be written as part of the
<a href="/doc/axi-spec.pdf">AXI</a> transaction.</p>

<p>Here’s the generate statement for two of the combinations.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">DW</span> <span class="o">==</span> <span class="n">C_AXI_DATA_WIDTH</span><span class="p">)</span>
	<span class="k">begin</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_axi_wvalid</span> <span class="o">||</span> <span class="n">i_axi_wready</span><span class="p">)</span>
			<span class="n">o_axi_wstrb</span>   <span class="o">&lt;=</span> <span class="n">m_sel</span><span class="p">;</span>

	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DW</span><span class="o">*</span><span class="mi">2</span> <span class="o">==</span> <span class="n">C_AXI_DATA_WIDTH</span><span class="p">)</span>
	<span class="k">begin</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_axi_wvalid</span> <span class="o">||</span> <span class="n">i_axi_wready</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="n">o_axi_wstrb</span>   <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">m_sel</span><span class="p">,</span> <span class="o">{</span><span class="p">(</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span> <span class="o">}</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">o_axi_wstrb</span>   <span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span> <span class="n">m_sel</span> <span class="o">}</span><span class="p">;</span>
		<span class="k">end</span>

	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="c1">// ...</span>
	<span class="c1">// ...</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>As I mentiond above, if there was no data width conversion, then setting
<code class="language-plaintext highlighter-rouge">o_wb_ack</code>, <code class="language-plaintext highlighter-rouge">o_wb_err</code>, and <code class="language-plaintext highlighter-rouge">o_wb_data</code> were fairly straightforward.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">DW</span> <span class="o">==</span> <span class="n">C_AXI_DATA_WIDTH</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">NO_READ_DATA_SELECT_NECESSARY</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">o_wb_data</span> <span class="o">=</span> <span class="n">i_axi_rdata</span><span class="p">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">o_wb_ack</span> <span class="o">=</span> <span class="o">!</span><span class="n">flushing</span><span class="o">&amp;&amp;</span><span class="p">((</span><span class="n">i_axi_rvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_rresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="o">||</span><span class="p">(</span><span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_bresp</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">o_wb_err</span> <span class="o">=</span> <span class="o">!</span><span class="n">flushing</span><span class="o">&amp;&amp;</span><span class="p">((</span><span class="n">i_axi_rvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_rresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="o">||</span><span class="p">(</span><span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_bresp</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span></code></pre></figure>

<p>Where things get tricky are when we need to do a data width conversion.
Sending the right data down the write channel wasn’t that hard, but the
read channel is a touch harder.  In particular, we’ll need a small FIFO
to keep track of the low order bits of the address–at least enough of a
FIFO to select the right subword from the returned <code class="language-plaintext highlighter-rouge">RDATA</code> value later.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">READ_FIFO_DATA_SELECT</span>

		<span class="kt">reg</span>	<span class="p">[</span><span class="n">SUBW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">addr_fifo</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGFIFO</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="kt">reg</span>	<span class="p">[</span><span class="n">SUBW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">fifo_value</span><span class="p">;</span>
		<span class="kt">reg</span>	<span class="p">[</span><span class="n">LGFIFO</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">wr_addr</span><span class="p">,</span> <span class="n">rd_addr</span><span class="p">;</span>
		<span class="kt">wire</span>	<span class="p">[</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">return_data</span><span class="p">;</span></code></pre></figure>

<p>Because of this difficulty, we’ll need to take an extra clock to select the
data we want during the return.  That means that the acknowledgment and
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
lines will need to be registered in order to keep things aligned.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">o_wb_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span> <span class="o">||</span> <span class="o">!</span><span class="n">i_wb_cyc</span> <span class="o">||</span> <span class="n">flushing</span><span class="p">)</span>
			<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">i_axi_rvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_rresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="o">||</span><span class="p">(</span><span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_bresp</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

		<span class="k">initial</span>	<span class="n">o_wb_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span> <span class="o">||</span> <span class="o">!</span><span class="n">i_wb_cyc</span> <span class="o">||</span> <span class="n">flushing</span><span class="p">)</span>
			<span class="n">o_wb_err</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">o_wb_err</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">i_axi_rvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_rresp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="o">||</span><span class="p">(</span><span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="n">i_axi_bresp</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span></code></pre></figure>

<p>As you’ll see above, it’s not just a simple matter of registering these
signals.  They now need to be subject to the reset signal and the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort signal, in addition to the signals they were sensitive to before.</p>

<p>I suppose technically I might’ve only chosen to register the read return and
not the write returns as well, since I’m preventing the
<a href="/doc/axi-spec.pdf">AXI</a> side from ever having both reads and
writes outstanding.  On second thought, though, the logic above is complex
enough that I’m torn between whether or not to always register these return
signals before leaving <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this
core</a> or not.</p>

<p>Now we need some FIFO logic.  The good part of this is that our <code class="language-plaintext highlighter-rouge">npending</code>,
<code class="language-plaintext highlighter-rouge">empty</code>, and <code class="language-plaintext highlighter-rouge">full</code> signals above properly mirror the number of elements in
this FIFO.  That will at least clear up some of the challenge of getting
the control signals right.</p>

<p>We’ll still need to adjust the address of the FIFO on any write.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">wr_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">wr_addr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_valid</span> <span class="o">&amp;&amp;</span> <span class="n">m_ready</span><span class="p">)</span>
			<span class="n">wr_addr</span> <span class="o">&lt;=</span> <span class="n">wr_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>And we’ll still need to write the value we need into the FIFO.  Here, we’re
just grabbing the low order bits of the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
address.  These are the bits which we’ll need later to select which
subword of the return data word is the one we need.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_valid</span> <span class="o">&amp;&amp;</span> <span class="n">m_ready</span><span class="p">)</span>
			<span class="n">addr_fifo</span><span class="p">[</span><span class="n">wr_addr</span><span class="p">[</span><span class="n">LGFIFO</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">m_addr</span><span class="p">[</span><span class="n">SUBW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span></code></pre></figure>

<p>As with the write address above, on a read we’ll adjust the read address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">rd_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">rd_addr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_axi_bvalid</span> <span class="o">||</span> <span class="n">i_axi_rvalid</span><span class="p">)</span>
			<span class="n">rd_addr</span> <span class="o">&lt;=</span> <span class="n">rd_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Do note that neither of these FIFO addresses are subject to either
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a> or
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> aborts.  They live on the
<a href="/doc/axi-spec.pdf">AXI</a> side of the bridge, and so <a href="/blog/2020/03/14/axi-reset.html">they
don’t get reset whenever we need to flush the
pipeline</a>.</p>

<p>Since the FIFO is fairly short and the number of bits in each word are
fairly small, we can use <a href="/formal/2018/07/21/zipcpu-icoboard.html">distributed RAM
here</a>.  That
means we can both read from the FIFO and use the value we’ve read from
it on the same clock cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">fifo_value</span> <span class="o">=</span> <span class="n">addr_fifo</span><span class="p">[</span><span class="n">rd_addr</span><span class="p">[</span><span class="n">LGFIFO</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]];</span></code></pre></figure>

<p>The last step of this processing is to select the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
word we are interested in.  If the sub-bits of our address were zero, those
would be the low order subword.  Remember,
<a href="/doc/axi-spec.pdf">AXI</a>
stores the low address bytes in the least significant positions of their data
word.  That makes this shift easy to do.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">assign</span>	<span class="n">return_data</span> <span class="o">=</span> <span class="n">i_axi_rdata</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">fifo_value</span> <span class="o">*</span> <span class="n">DW</span><span class="p">);</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">return_data</span><span class="p">[</span><span class="n">DW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>This isn’t really the end of the story.
<a href="/doc/axi-spec.pdf">AXI</a> is naturally a little
<a href="https://en.wikipedia.org/wiki/Endianness">endian</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Yes, I know <a href="/doc/axi-spec.pdf">the spec</a> says that it’s
neither big nor little <a href="https://en.wikipedia.org/wiki/Endianness">endian</a>,
but if you look at how words are laid out on the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>, words naturally end up
in a little <a href="https://en.wikipedia.org/wiki/Endianness">endian</a>, setting.
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> on the
other hand is also neither big nor little endian, but it doesn’t specifically
state which bytes within a word are more or least significant.</p>

<p>If you ask me, the entire little
<a href="https://en.wikipedia.org/wiki/Endianness">endian</a> format is messed up since
I can’t see a number in it’s natural order from a hex dump: most significant
byte first.  As a result, I’ve built the
<a href="/about/zipcpu.html">ZipCPU</a> so that it would be big
<a href="https://en.wikipedia.org/wiki/Endianness">endian</a> from the beginning.  Sadly,
this also leaves me swimming upstream as I fight between my own view of the
world and what seems to be the dominant view of the topic.</p>

<p>My point is simply this, I may need to come back through here later and swap
the byte order of these various words if I really want to interact with
<a href="/doc/axi-spec.pdf">AXI</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
components.  Thankfully, I haven’t needed to yet.  Instead, I’ve been able
to get by with what I call
<a href="/blog/2020/01/13/reuse.html">“word-endian”</a> where as
long as words are properly placed on the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
(MSB=MSB) then everything is good.  Unfortunately, I’m fighting against the
<a href="https://en.wikipedia.org/wiki/Borg">Borg</a> here, and it’s not clear how much
longer I’ll last before being assimilated.</p>

<p>The last step in this core is to make certain we hold the various ready signals
high.  As discussed above, this might permit the optimizer to reduce the
amount of logic required surrounding <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this
core</a>–but
there are no guarantees.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_axi_rready</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">o_axi_bready</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>We’ll skip the formal methods check of <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">this
core</a> today.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="c1">//</span>
	<span class="c1">// ... Formal properties ...</span>
<span class="cp">`endif</span>
<span class="k">endmodule</span></code></pre></figure>

<p>It’s not nearly all that hard to do, so I may come back and present it later.
The big thing is that it depends upon my formal
<a href="/doc/axi-spec.pdf">AXI</a> property set–something that
I’ve been known to offer to <a href="https://www.patreon.com/ZipCPU">patron’s of the
blog</a>.</p>

<h2 id="performance">Performance</h2>

<p>At this point you might be wondering, how did we do?  So let’s look at a couple
of traces to illustrate the kind of performance that’s possible–but that you
aren’t likely to see in real life.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 14. Multiple write performance</caption><tr><td><img src="/img/wbm2axisp/writes.svg" alt="" width="420" /></td></tr></table>

<p>Fig. 14 on the left shows the write performance going through <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">the
core</a>.  I’ve
trimmed the figure down so you don’t see any of the constant signals associated
with this transaction.  In particular, this trace and the ones following will
have <code class="language-plaintext highlighter-rouge">AWREADY</code>, <code class="language-plaintext highlighter-rouge">WREADY</code>, and <code class="language-plaintext highlighter-rouge">ARREADY</code> all held high.  Don’t expect this in
practice when working either with an
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
or any of Xilinx’s cores, but it’s nice when it does happen.</p>

<p>As you consider Fig. 14, pay close attention to the fact that both
<code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">WVALID</code>, as well as by inference above
<code class="language-plaintext highlighter-rouge">AWREADY</code> and <code class="language-plaintext highlighter-rouge">WREADY</code>, are all high for multiple clocks in a row.  This
is the key characteristic of any single beat, pipelined master.</p>

<p>Indeed, this is how
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> components <em>should</em> work.</p>

<p>Note also how the write address and data channels are each synchronized.
While this isn’t required by the protocol, it’s really the ideal configuration
for high speed.</p>

<p>Looking at latency, you’ll notice a two clock loss.  First, there’s a clock
taken between the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> request and the
<a href="/doc/axi-spec.pdf">AXI</a> request.  This follows from the
<a href="/doc/axi-spec.pdf">AXI</a> requirement that outputs should
not combinatorially depend upon inputs, even though that’s not strictly the
case here since these are
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> inputs and not
<a href="/doc/axi-spec.pdf">AXI</a> inputs.  Second, there’s another
clock lost between <code class="language-plaintext highlighter-rouge">AWVALID</code> and <code class="language-plaintext highlighter-rouge">BVALID</code>.  This time, the clock lost is
required by the <a href="/doc/axi-spec.pdf">AXI</a> protocol.  Were we
to adjust the width of the return, we would lose another clock in the return
path as well.</p>

<p>Let’s take a look at the read performance now, as shown in Fig. 15.</p>

<table align="center" style="float: right"><caption>Fig 15. Multiple read performance</caption><tr><td><img src="/img/wbm2axisp/reads.svg" alt="" width="360" /></td></tr></table>

<p>Fig. 15 also shows a series of 3 transactions.  As with Fig. 14 above, you may
assume that <code class="language-plaintext highlighter-rouge">ARREADY</code> is held high.  Again, the key characteristic of
a single beat, pipelined master is that the master is issuing new read
requests before the first response has been received.</p>

<p>Of course, the amount of latency shown in Fig. 15 is also ridiculously and
uncharacteristically low.  The typical
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> alone
will add another four clocks of latency to any design.  Still, this is
decently representative of how the protocol should work on a good day.</p>

<p>Suppose we try again, but this time we attempt to stress our core a bit.
In particular, let’s take a look at how fast we can issue four write requests
followed by four read requests.  Remember, we promised ourselves we’d flush
the pipeline between these requests too.  Worse, let’s insist that
our buffer fill up with all four values along the way, so that we have had
four values outstanding in each direction before returning.</p>

<p>This more complicated trace is shown in Fig. 16 below.</p>

<table align="center" style="float: none"><caption>Fig 16. Trace showing four writes followed by four reads</caption><tr><td><a href="/img/wbm2axisp/write-to-read.svg"><img src="/img/wbm2axisp/write-to-read.svg" alt="" width="780" /></a></td></tr></table>

<p>Again, the key characteristic in this trace of this class of
<a href="/doc/axi-spec.pdf">AXI</a> master is
that the master is capable of issuing multiple requests long before the
first request comes back.  In this case, the master allows four write burst
beats to be outstanding.  It then waits for the four write beats to be returned
before issuing five more read beats.  Even better, the latency shown in Fig. 16
is closer to what you are likely to see in reality, even if still a little
short.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Some time ago we discussed measuring <a href="/zipcpu/2019/02/09/cpu-blinky.html">how fast a CPU could toggle an external
I/O, and how this “blinky” test made tended to make a CPU look
slow</a>.  There
are three primary parts to the equation of how slow blinky appears to be.
The first key is the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master, and today we’ve seen how a high performance
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> master might issue
multiple commands to a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
slave without waiting for the first to return.  This was a key reason why the
<a href="/about/zipcpu.html">ZipCPU</a> was able to <a href="/zipcpu/2019/02/09/cpu-blinky.html">outperform both
ARM and Microblaze in that
test</a>.</p>

<p>The other two items are just as critical.  These are the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> and the slave.
Just as a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> master can be
written to only ever allow one burst to be outstanding at any given time, an
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> can also be
written this way as well.  While such
<a href="/blog/2019/07/17/crossbar.html">interconnects</a> can easily
be low-logic <a href="/blog/2019/07/17/crossbar.html">interconnects</a>,
they won’t permit high performance anywhere in your design.  Sure, you can
use them for sequencing or controlling high performance streams, but you won’t
get high performance access to your
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
if you are going through an
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> so conigured.</p>

<p>As for the last item, the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
slave, I don’t think it should come as a surprise to any one that a poor slave
implementation, such as <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">Xilinx’s AXI
GPIO</a>,
isn’t going to provide good performance.  Just for reference, here’s a trace
showing <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">that GPIO
slave’s</a>
throughput.</p>

<table align="center" style="float: none"><caption>Fig 17. AXI GPIO write performance</caption><tr><td><img src="/img/tweets/axi-gpio-writes.svg" alt="" width="780" /></td></tr></table>

<p>At one transaction every four clocks, it’s not very pretty.</p>

<p>Thankfully, if you’ve been reading <a href="https://zipcpu.com/">this
blog</a>, you already know <a href="/blog/2019/05/29/demoaxi.html">how to build a
high speed AXI slave component</a>
that can knock the socks off of <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">this GPIO
slave</a>.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Ho, every one that thirsteth, come ye to the waters, and he that hath no money; come ye, buy, and eat; yea, come, buy wine and milk without money and without price. (Is 55:1)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
