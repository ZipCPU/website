<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Locally resetting an AXI component</title>
  <meta name="description" content="Earlier this week, I came across an AXI component designed by a user whowas struggling to figure out why his component wasn’tworking.In the end the first ans...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2020/03/14/axi-reset.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Locally resetting an AXI component</h1>
    <p class="post-meta"><time datetime="2020-03-14T00:00:00-04:00" itemprop="datePublished">Mar 14, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Earlier this week, I came across an <a href="https://forums.xilinx.com/t5/PCIe-and-CPM/what-s-wrong-with-this-logic/m-p/1081578">AXI component designed by a user who
was struggling to figure out why his component wasn’t
working</a>.
In the end the first answer to why his core wasn’t working was that he was
neither
<a href="/blog/2018/08/22/what-is-simulation.html">simulating</a>, nor
<a href="/blog/2017/10/19/formal-intro.html">formally verifying</a>
his design.  The second answer was that he had a <a href="/blog/2017/10/20/cdc.html">clock domain crossing
issue</a> that wasn’t part of his
post.</p>

<p>Looking through his logic, however, I found a third reason why he
might be struggling–his reset logic.  This reset code contained the following
logic,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">input</span>	<span class="kt">wire</span>	<span class="n">LOCAL_RESET</span><span class="p">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">M_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARESETN</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">LOCAL_RESET</span> <span class="o">==</span> <span class="mb">1'b1</span><span class="p">)</span>
	<span class="n">axi_arvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">axi_arvalid</span> <span class="o">&amp;&amp;</span> <span class="cm">/* whatever else */</span><span class="p">)</span>
	<span class="c1">// rest of logic follows</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">M_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARESETN</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">LOCAL_RESET</span> <span class="o">==</span> <span class="mb">1'b1</span><span class="p">)</span>
	<span class="n">state</span> <span class="o">&lt;=</span> <span class="n">IDLE</span><span class="p">;</span>
<span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// State machine logic</span>
<span class="k">end</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">M_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARESETN</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">LOCAL_RESET</span> <span class="o">==</span> <span class="mb">1'b1</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">IDLE</span><span class="p">)</span>
	<span class="n">read_index</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="n">read_index</span> <span class="o">!=</span> <span class="n">MAX_INDEX</span><span class="p">)</span>
	<span class="n">read_index</span> <span class="o">&lt;=</span> <span class="n">read_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">M_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARESETN</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">LOCAL_RESET</span> <span class="o">==</span> <span class="mb">1'b1</span><span class="p">)</span>
	<span class="n">axi_rready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">else</span>
	<span class="c1">// rest of logic follows</span></code></pre></figure>

<p>The design also contained an associated slave, also containing a
<code class="language-plaintext highlighter-rouge">LOCAL_RESET</code> wire, although none of the logic within the slave
depended upon the same <code class="language-plaintext highlighter-rouge">LOCAL_RESET</code>.</p>

<p>It shouldn’t be too hard to come up with a scenario that will cause such
a design to read results into the wrong address, or worse to hang the rest
of the design by dropping <code class="language-plaintext highlighter-rouge">axi_rready</code> just before <code class="language-plaintext highlighter-rouge">M_AXI_RVALID</code> gets
set.</p>

<p>Although this didn’t turn out to be what the user was
struggling from in the end, it still brings up an interesting question: How
shall an AXI component be <em>locally</em> reset?  By <em>locally</em> reset, I’m referring
to resetting the component without pulling <code class="language-plaintext highlighter-rouge">S_AXI_ARESETN</code> low and resetting
every component on the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.</p>

<p>It’s not as simple as it might sound.</p>

<h2 id="locally-resetting-an-axi-slave-component">Locally resetting an AXI Slave component</h2>

<table align="center" style="float: right"><caption>Fig 1. Resetting an AXI slave</caption><tr><td><img src="/img/axi-reset/slave-reset.svg" alt="" width="280" /></td></tr></table>

<p>Resetting an AXI Slave is the easier type of component to reset.
The key to resetting a slave with an
<a href="/formal/2018/12/28/axilite.html">AXI-lite interface</a>
is to reset the registers within the design, rather than the entire design,
as shown in Fig. 1 on the right.</p>

<p>As an example, in our <a href="/blog/2020/03/08/easyaxil.html">example AXI slave
design</a>,
we included the following logic for updating an register in a design having
an <a href="/formal/2018/12/28/axilite.html">AXI-lite interface</a>:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">r0</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// ...</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axil_write_ready</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">case</span><span class="p">(</span><span class="n">awskd_addr</span><span class="p">)</span>
	<span class="mb">2'b00</span><span class="o">:</span> <span class="n">r0</span> <span class="o">&lt;=</span> <span class="n">wskd_r0</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="k">endcase</span>
<span class="k">end</span></code></pre></figure>

<p>This register logic is the only logic that needs to adjust in order
to implement a local reset for <a href="/blog/2020/03/08/easyaxil.html">an
AXI-Lite slave</a>.</p>

<p>First, we’d need a reset signal from somewhere.  Such a signal could come
from either an external input port (that was synchronous with the design clock),</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">input</span>	<span class="kt">wire</span>	<span class="n">LOCAL_RESET</span><span class="p">;</span></code></pre></figure>

<p>or it could come from one of the bus-accessible registers within the design,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">LOCAL_RESET</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="n">LOCAL_RESET</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">LOCAL_RESET</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// ...</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axil_write_ready</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">awskd_addr</span> <span class="o">==</span> <span class="n">RESET_ADDRESS</span><span class="p">)</span>
		<span class="n">LOCAL_RESET</span> <span class="o">&lt;=</span> <span class="n">wskd_data</span><span class="p">[</span><span class="n">RESET_BIT</span><span class="p">];</span>
<span class="k">end</span></code></pre></figure>

<p>However you create your local reset signal, once the <code class="language-plaintext highlighter-rouge">LOCAL_RESET</code> signal
is available, the <em>registers within the design</em> can be reset using it.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="n">LOCAL_RESET</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">r0</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// ...</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axil_write_ready</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">case</span><span class="p">(</span><span class="n">awskd_addr</span><span class="p">)</span>
	<span class="mb">2'b00</span><span class="o">:</span> <span class="n">r0</span> <span class="o">&lt;=</span> <span class="n">wskd_r0</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="k">endcase</span>
<span class="k">end</span></code></pre></figure>

<p>Notice that I’m not resetting any of the
<a href="/formal/2018/12/28/axilite.html">AXI signals</a>, but
just the various registers that would be set by them.  This is the key
to not hanging the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.</p>

<h4 id="returning-an-error-during-the-local-reset">Returning an error during the local reset</h4>

<p>If you want, you could also adjust the responses to various requests as well,
so that during a reset the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
would return an <a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
In this case, you’d change,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="n">S_AXI_BRESP</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span></code></pre></figure>

<p>into something where any write during a <code class="language-plaintext highlighter-rouge">LOCAL_RESET</code> would produce an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
The key to this transformation, however, is making certain that the
<code class="language-plaintext highlighter-rouge">S_AXI_BRESP</code> signal still only every changes when the outgoing transaction
isn’t stalled.  This is then as simple as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// Define the AXI response possibilities</span>
<span class="k">localparam</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OKAY</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">,</span>
			<span class="n">SLVERR</span> <span class="o">=</span> <span class="mb">2'b10</span><span class="p">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">)</span>
	<span class="n">S_AXI_BRESP</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">LOCAL_RESET</span><span class="p">)</span> <span class="o">?</span> <span class="n">SLVERR</span> <span class="o">:</span> <span class="n">OKAY</span><span class="p">;</span></code></pre></figure>

<p>A similar update to <code class="language-plaintext highlighter-rouge">S_AXI_RRESP</code> could accomplish the same effect there as
well.</p>

<p>The difficult part of this change, however, is that a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
will tend to cause any user program to crash.
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">Bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
handling is typically done by the operating system and, well, let me ask,
if you aren’t using an operating system then is your embedded software ready
to handle that challenge?</p>

<h4 id="retrofitting-an-existing-component">Retrofitting an existing component</h4>

<table align="center" style="float: left; padding: 15px"><caption>Fig 2. Using a firewall to locally reset an existing core</caption><tr><td><img src="/img/axi-reset/firewall-reset.svg" alt="" width="360" /></td></tr></table>

<p>But what if your <a href="/blog/2019/05/29/demoaxi.html">AXI slave component already
exists</a>?  In this case, you
might need to retrofit a slave core with a local reset option.  Pulling the
<code class="language-plaintext highlighter-rouge">S_AXI_ARESETN</code> line low of that component only might look like a tempting
option, but what would this do to any ongoing
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> transactions?  It would
hang the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>, bringing down
the rest of the design.
This is unacceptable.</p>

<p>However, if this is the sort of functionality you are looking for, just without
hanging the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>, then there is
a way to accomplish it.  Simply place an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">AXI
firewall</a>
between your component and the rest of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
and then adjust the reset line to the core below the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">firewall</a> as
you see fit.  Any ongoing slave transaction hiccups will be caught by the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">AXI
firewall</a>,
and used to prolong the reset of the component core–returning AXI <code class="language-plaintext highlighter-rouge">SLVERR</code>s
(a type of AXI <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>)
until the core is fully re-integrated back into your system.</p>

<h4 id="an-example">An Example</h4>

<p>Perhaps an example might clarify this whole idea.  I used the register based
reset approach when resetting the <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v">AXI-Lite version of my Wishbone
scope</a>.</p>

<p>If you aren’t familiar with the <a href="/blog/2017/07/08/getting-started-with-wbscope.html">(now possibly misnamed) Wishbone
Scope</a>,
it’s a basic <a href="/blog/2017/06/08/simple-scope.html">bus-based internal logic
analyzer</a>.  It’s a really
easy way to capture, record, and report back to you what’s going on within your
design with one caveat: <em>It will only work if the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> never hangs.</em></p>

<p>This is one of those times and reasons why I like
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>: If you
just drop the cycle line, then everything resets.  I can then go back into
a design and (usually) find out what’s going on if I have to.</p>

<p>Not so with AXI: the <a href="/doc/axi-spec.pdf">AXI bus protocol</a>
has no bus abort capability.  <a href="/formal/2019/09/06/axi-story.html">Any misbehaving AXI bus component will hang the
bus</a>.  This is why it’s
so important to
<a href="/formal/2018/12/28/axilite.html">formally verify</a>
your AXI components–<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a> just doesn’t tend to be
<a href="/blog/2017/10/19/formal-intro.html">thorough enough</a>
to check all the functionality of an AXI based interaction.  Formal methods,
on the other hand, will check <em>every</em> possibility.</p>

<table align="center" style="float: right"><caption>Fig 3. Crossing clock domains with a reset request</caption><tr><td><img src="/img/axi-reset/cdc-reset.svg" alt="" width="360" /></td></tr></table>

<p>So how does the reset work in my 
<a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v">AXI-Lite scope</a>?</p>

<p>Well, first, it’s not quite so simple as we described above.  The
<a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v">scope</a>
is designed to be able to (optionally) handle inputs coming from a second <a href="/blog/2017/10/20/cdc.html">clock
domain</a>–one associated with the
data source.  That means that the reset won’t be complete until it has crossed
from the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="/blog/2017/10/20/cdc.html">clock domain</a> to the data
<a href="/blog/2017/10/20/cdc.html">clock domain</a> and back again.</p>

<p>So let’s follow this through.  There are three parts to the internal reset
request logic.  First, if a reset has been requested, we clear it on any
completion–independent of any new request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">bus_clock</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// Reset logic</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bw_reset_complete</span><span class="p">)</span>
		<span class="c1">// Clear the reset on completion</span>
		<span class="n">bw_reset_request</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>This implements the “clear request” logic of Fig. 3, above and to the right.</p>

<p>Next, if a reset has been requested that hasn’t yet completed (logic above),
we keep the request going until it does complete.  This would be the case
in Fig. 3 between the reset request and the reset acknowledgment.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bw_reset_request</span><span class="p">)</span>
		<span class="c1">// While the reset is ongoing, keep it going until its</span>
		<span class="c1">// cleared</span>
		<span class="n">bw_reset_request</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Finally, the core is responsive to a reset request from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>–both from the 
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> reset wire
<code class="language-plaintext highlighter-rouge">!S_AXI_ARESETN</code> (called <code class="language-plaintext highlighter-rouge">i_reset</code> below) as well as from a particular write
to the control register.  Specifically, if there’s ever a write to the control
register of <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v">this
scope</a>,
and the reset bit within that write is low, then we begin a local reset cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span> <span class="o">||</span> <span class="p">(</span><span class="n">write_to_control</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_bus_data</span><span class="p">[</span><span class="n">RESET_BIT</span><span class="p">]))</span>
		<span class="c1">// Initiate a new reset request</span>
		<span class="c1">//    Note that we won't initiate a new reset request</span>
		<span class="c1">//    while one is already pending.  Once the pending</span>
		<span class="c1">//    one completes, we'll be in the reset state anyway</span>
		<span class="n">bw_reset_request</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>Why check for if the reset bit of the control word is low rather than high?  It
just makes working with the core easier.  Normally, writes to the control
word contain <a href="/blog/2017/06/08/simple-scope.html">how long you want to wait from trigger to
capture</a>.  This requires
resetting
<a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v">the core</a>,
so the reset request will naturally get set on any such write–even
without raising a bit to explicitly request it.</p>

<p>This reset logic then <a href="/blog/2017/10/20/cdc.html">crosses clock
domains</a> via a handshaking
protocol, shown in Fig. 3 above–one we’ve
<a href="/blog/2017/10/20/cdc.html">discussed the basics of before</a>.
It’s not fast, but it works.  All of the capture logic is then reset from
a reset signal in the data clock domain, <code class="language-plaintext highlighter-rouge">dw_reset</code>–that’s my equivalent
of the <code class="language-plaintext highlighter-rouge">LOCAL_RESET</code> signal we’ve been discussing above.</p>

<p>Once complete, the return signal, <code class="language-plaintext highlighter-rouge">bw_reset_complete</code>, is set and the
logic above clears.  Until the reset completes, any read from the control
register will return with the reset bit set–indicating that the reset
is ongoing.  This is useful for those cases where the data clock isn’t
running for some reason.  In those cases, if you come back and read from the
<a href="/blog/2017/06/08/simple-scope.html">scope</a>, using either
the CPU or the <a href="/blog/2017/06/16/dbg-bus-forest.html">debugging
bus</a>), you’ll quickly
notice that the <a href="/blog/2017/06/08/simple-scope.html">scope</a>
is still in reset–telling you exactly what’s going on.</p>

<p>What about the rest of the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="/blog/2020/03/08/easyaxil.html">logic</a>?</p>

<p>It doesn’t change.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
still operates like it normally would, unless or until you reset the entire
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>, which is just the way we
wanted <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v">this
core</a>
to work.  The approach is fairly easy to design and easy to implement, and
(so far) it’s worked quite well for me.</p>

<p>That handles <a href="/blog/2019/05/29/demoaxi.html">AXI slave
components</a>,
but how would you locally reset an AXI master?</p>

<h2 id="locally-resetting-an-axi-master-component">Locally resetting an AXI Master component</h2>

<table align="center" style="float: left; padding: 15px"><caption>Fig 4. Steps to resetting an AXI master</caption><tr><td><img src="/img/axi-reset/master-reset.svg" alt="" width="360" /></td></tr></table>

<p>Resetting an AXI master is a bit more challenging.  Basically, the master
has to wait for all outstanding transactions to complete in order to complete
a reset.  This requires something of a state machine.</p>

<p>Let’s walk through the steps of how this might work.</p>

<ol>
  <li>
    <p>First, a reset is requested, the design then transitions from any WORKING
state to an INRESET state in order to wait for things to settle out.</p>
  </li>
  <li>
    <p>While in the INRESET state, no additional AXI transactions are initiated.
Existing transactions are allowed to complete.  This step itself requires
a couple of sub-steps.</p>

    <ol>
      <li>
        <p><code class="language-plaintext highlighter-rouge">BREADY</code> and <code class="language-plaintext highlighter-rouge">RREADY</code> need to be set to one if they aren’t already</p>

        <p>I personally like to keep <code class="language-plaintext highlighter-rouge">BREADY</code> and <code class="language-plaintext highlighter-rouge">RREADY</code> high any
time a transaction is outstanding, and even if no transactions are
outstanding.  I consider this good practice, although I can <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixclk.v">imagine
reasons</a>
why a design might not be able to do this.</p>
      </li>
      <li>
        <p>As soon as <code class="language-plaintext highlighter-rouge">!AxVALID || AxREADY</code> is true on any of the address request
channels, the <code class="language-plaintext highlighter-rouge">AxVALID</code> line should to be dropped.  That way, no new
transaction requests are issued.</p>

        <p>This assumes that you don’t set <code class="language-plaintext highlighter-rouge">WVALID</code> high prior to its associated
<code class="language-plaintext highlighter-rouge">AWVALID</code> signal.  While the specification allows you to do this, it
doesn’t typically buy you any better performance since the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> won’t
know what to do with the data apart from the address
anyway.  Still, if you have chosen to allow <code class="language-plaintext highlighter-rouge">WVALID</code> to be set prior
to <code class="language-plaintext highlighter-rouge">AWVALID</code>, then you’ll need to make sure to flush the <code class="language-plaintext highlighter-rouge">AWVALID</code>
lines as well, just like we’re about to flush the <code class="language-plaintext highlighter-rouge">WVALID</code> signals below.</p>
      </li>
      <li>
        <p>As soon as <code class="language-plaintext highlighter-rouge">!WVALID || WREADY</code>, you will want to set <code class="language-plaintext highlighter-rouge">S_AXI_WSTRB</code>
to zero.  This will prevent your core from actually writing any more
values following the reset request–assuming this was what you wanted.</p>

        <p>You’ll also want to set <code class="language-plaintext highlighter-rouge">WVALID</code> to <code class="language-plaintext highlighter-rouge">1</code> as long as you have write
transactions outstanding that need to be completed.</p>
      </li>
      <li>
        <p>The write channel signaling is a bit trickier.  You will need to
complete any ongoing write operations.  My recommendation would be to
set <code class="language-plaintext highlighter-rouge">WVALID</code> to <code class="language-plaintext highlighter-rouge">1</code> as long as you have an outstanding
transaction to complete.  This works since you’re setting <code class="language-plaintext highlighter-rouge">WSTRB</code> to zero
at the same time, and so you don’t really care any more about <em>what</em>
data you are sending, just that the data transactions clear through the
system.</p>
      </li>
    </ol>

    <p>Together, these steps will keep you from starting any new transactions.</p>
  </li>
  <li>
    <p>While in the <code class="language-plaintext highlighter-rouge">INRESET</code> state, any and all existing transactions must be
allowed to complete.</p>

    <p>You were keeping track of how many bursts requests you’ve initiated and
how many expected responses are still outstanding, right?</p>

    <p>As long as transactions remain outstanding, you’ll need to stay in this
<code class="language-plaintext highlighter-rouge">INRESET</code> state.</p>
  </li>
  <li>
    <p>Once all transactions have completed, your core may then leave the reset
state and return to <code class="language-plaintext highlighter-rouge">IDLE</code> (or <code class="language-plaintext highlighter-rouge">WORKING</code>–depending upon your core’s
design requirements).</p>
  </li>
</ol>

<p>Shall we take a look at an example AXI master to see how this might be done?</p>

<h4 id="axi-master-example">AXI Master Example</h4>

<p>All three of my AXI DMA algorithms have some capability for aborting
transactions.  This includes <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">my AXI stream to memory
core</a>, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">my AXI
memory to stream
core</a>, and <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">my AXI
DMA core</a>.
Unlike the major vendor cores, these three are all open source.  Each contains
an <a href="/blog/2020/03/08/easyaxil.html">AXI-Lite control port</a>,
and a full memory mapped AXI4 master port.</p>

<table align="center" style="float: right"><caption>Fig 5. AXI Stream to Memory core components</caption><tr><td><img src="/img/axi-dma/s2mmblocks.svg" alt="" width="420" /></td></tr></table>

<p>Since each core contains the same basic reset logic within them, let’s just
look at the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM
core</a> as an
arbitrary example.  As illustrated in Fig. 5, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">this
core</a>
is responsible for accepting stream data, possibly synchronizing to the
nearest packet start, and then writing this stream data to memory at a user
defined location.</p>

<p>The <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM core</a>
core has an <a href="/formal/2018/12/28/axilite.html">AXI-lite
interface</a> for control.  If
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the core</a>
is busy, an abort command can be given to it through this interface which will
cause a form of reset.  Such an abort command will be issued if ever the
<code class="language-plaintext highlighter-rouge">ABORT_KEY</code> is written to the upper byte of the control register while <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the
core</a> is in
operation.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">w_cmd_abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">w_cmd_abort</span> <span class="o">=</span> <span class="p">(</span><span class="n">axil_write_ready</span> <span class="o">&amp;&amp;</span> <span class="n">awskd_addr</span> <span class="o">==</span> <span class="n">CMD_CONTROL</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">wskd_strb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">wskd_data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">==</span> <span class="n">ABORT_KEY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
		<span class="n">w_cmd_abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>This user-abort signal is then registered, and held high until
the user-commanded, local “reset” is complete and the design returns
to idle (i.e. <code class="language-plaintext highlighter-rouge">!r_busy</code>).</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">cmd_abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="n">cmd_abort</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
	<span class="n">cmd_abort</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span>
	<span class="n">cmd_abort</span> <span class="o">&lt;=</span> <span class="n">cmd_abort</span> <span class="o">||</span> <span class="n">w_cmd_abort</span><span class="p">;</span></code></pre></figure>

<p>There’s also a similar signal, <code class="language-plaintext highlighter-rouge">axi_abort_pending</code>.  This is set not only
based upon the user command, but it also gets set if
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the core</a>
ever encounters any <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">axi_abort_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span> <span class="o">||</span> <span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
	<span class="n">axi_abort_pending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">begin</span>
	<span class="c1">// Abort on any bus error</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BREADY</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">axi_abort_pending</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_abort</span><span class="p">)</span>
		<span class="n">axi_abort_pending</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>Once either of these signals are set, either <code class="language-plaintext highlighter-rouge">cmd_abort</code> or <code class="language-plaintext highlighter-rouge">axi_abort_pending</code>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the core</a>
begins a local reset sequence that will return it to its idle state.  This
includes aborting all current and ongoing transactions.</p>

<p>First, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the core</a>
needs to set <code class="language-plaintext highlighter-rouge">BREADY</code> to one.  <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">This particular
core</a> follows my
default philosophy of keeping <code class="language-plaintext highlighter-rouge">BREADY</code> high in the first place,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">BREADY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>so no additional action is required there.</p>

<p>Next, <code class="language-plaintext highlighter-rouge">AWVALID</code> needs to be dropped.  In <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">this particular
core</a>,
a combinatorial register is used to determine when to set <code class="language-plaintext highlighter-rouge">AWVALID</code> in the
first place.  This register is called <code class="language-plaintext highlighter-rouge">w_phantom_start</code>.  <code class="language-plaintext highlighter-rouge">w_phantom_start</code>
is always cleared in the case of any pending abort.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// We start again if there's more information to transfer</span>
	<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="o">!</span><span class="n">aw_none_remaining</span><span class="p">;</span>

	<span class="c1">// But not if the amount of information we need isn't (yet)</span>
	<span class="c1">// in the FIFO.</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_fill</span> <span class="o">&lt;</span> <span class="o">{{</span><span class="p">(</span><span class="n">LGFIFO</span><span class="o">-</span><span class="n">LGMAXBURST</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span> <span class="n">r_max_burst</span><span class="o">}</span><span class="p">)</span>
		<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// Insist on a minimum of one clock between burst starts,</span>
	<span class="c1">// since our burst length calculation takes a clock to do</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phantom_start</span><span class="p">)</span>
		<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// If we're still writing the last burst, then don't start</span>
	<span class="c1">// any new ones</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WLAST</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_WREADY</span><span class="p">))</span>
		<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// Finally, don't start any new bursts if we aren't already</span>
	<span class="c1">// busy transmitting, or if we are in the process of aborting</span>
	<span class="c1">// our transfer</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span> <span class="o">||</span> <span class="n">cmd_abort</span> <span class="o">||</span> <span class="n">axi_abort_pending</span><span class="p">)</span>
		<span class="n">w_phantom_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>This signal guarantees that <code class="language-plaintext highlighter-rouge">AWVALID</code> is returned to zero as soon as possible
following any abort request.  Notice, in the actual logic block that sets
<code class="language-plaintext highlighter-rouge">AWVALID</code> below, that this signal is only ever changed if
<code class="language-plaintext highlighter-rouge">!M_AXI_AWVALID || M_AXI_AWREADY</code>.  This is key to following the protocol and
you’ll see this pattern often.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">axi_awvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="n">axi_awvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_AWVALID</span> <span class="o">||</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span>
	<span class="n">axi_awvalid</span> <span class="o">&lt;=</span> <span class="n">w_phantom_start</span><span class="p">;</span></code></pre></figure>

<p>Clearing <code class="language-plaintext highlighter-rouge">WVALID</code> on a reset takes a bit more work.  Or rather, the logic for
<code class="language-plaintext highlighter-rouge">WVALID</code> doesn’t really change.  It still gets set at the beginning of every
burst, and remains set until the burst is complete.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">axi_wvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="n">axi_wvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WVALID</span> <span class="o">||</span> <span class="n">M_AXI_WREADY</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_WLAST</span><span class="p">)</span>
		<span class="n">axi_wvalid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">axi_wvalid</span> <span class="o">&lt;=</span> <span class="n">w_phantom_start</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>Admittedly, this arrangement is somewhat specific to how <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">this stream to
memory core</a> works.
In particular,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">this core</a>
only ever sets <code class="language-plaintext highlighter-rouge">WVALID</code> if it has enough information to hold it high until any
burst that it is a part of is complete.  This is part of my philosophy of
either using the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
or getting off the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
so someone else can use it.  While AXI doesn’t require this philosophy, this
design approach helps to minimize any required
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> resources, such as those
used by the <a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
and so it helps keep everything else working without getting slowed
down by <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">this core</a>
unless <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">this core</a>
actually needs
the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> to talk to
a peripheral.</p>

<p>The <code class="language-plaintext highlighter-rouge">WSTRB</code> signal similarly straightforward: anytime the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
isn’t stalled, <code class="language-plaintext highlighter-rouge">WSTRB</code> is adjusted.  If there’s no abort pending, <code class="language-plaintext highlighter-rouge">WSTRB</code>
is set to all ones.  (As currently written,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the core</a>
can only transfer aligned words of full size.  This may change in the future as
I have opportunity.)  Otherwise, we stop writing on either user abort or upon
receiving a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> as
soon as possible by setting <code class="language-plaintext highlighter-rouge">WSTRB</code> to zero.  As before, the
<code class="language-plaintext highlighter-rouge">!M_AXI_WVALID || M_AXI_WREADY</code> condition is key here to following protocol.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WVALID</span> <span class="o">||</span> <span class="n">M_AXI_WREADY</span><span class="p">)</span>
	<span class="n">axi_wstrb</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">axi_abort_pending</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:-</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>The last step is to know when we are done so we can know when to leave this
reset state.  This means that we need to know when there are no more requests
remaining to be made, and when the last outstanding request has been returned.
As we’ll see below, the return to idle logic has to be a part of the normal
return to idle logic–the task just returns to idle a bit earlier.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 6. The S2MM operation is like a double-hourglass</caption><tr><td><img src="/img/axi-reset/s2mm-hourglass.svg" alt="" width="360" /></td></tr></table>

<p>Getting there requires checking two counters.  You can think of this sort of
like the double hourglass shown in Fig. 6 on the left.  Initially, the first
counter is loaded by the user with the number of requests that need to be
made.  This is the <code class="language-plaintext highlighter-rouge">aw_requests_remaining</code> counter.  Then, as write address
burst requests get accepted by the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
the counter decrements and a second counter, <code class="language-plaintext highlighter-rouge">aw_bursts_outstanding</code>, gets
incremented.  (The units of the two counters aren’t quite the same–the first
counter counts beats, the second bursts–but we can ignore that for now.)
Finally, when a burst is complete, the <code class="language-plaintext highlighter-rouge">aw_bursts_outstanding</code> counter gets
decremented.  Once both counters reach zero, the operation is complete.</p>

<p>The way the local reset, a.k.a. abort, works is that it empties out the first
chamber of requests still to be issued, but then it lets the rest of the
operations proceed to completion.</p>

<p>Let’s look at this in more detail.</p>

<p>The first counter keeps track of the number of remaining bus word transactions.
When <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the core</a>,
isn’t busy, this number is set from the <a href="/blog/2020/03/08/easyaxil.html">AXI-Lite interface
registers</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">aw_none_remaining</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">initial</span>	<span class="n">aw_requests_remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">aw_requests_remaining</span> <span class="o">&lt;=</span> <span class="n">cmd_length_w</span><span class="p">;</span>
	<span class="n">aw_none_remaining</span>     <span class="o">&lt;=</span> <span class="n">zero_length</span><span class="p">;</span></code></pre></figure>

<p>It gets cleared on any local reset request, whether on a user abort or upon
receiving a returned
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd_abort</span> <span class="o">||</span> <span class="n">axi_abort_pending</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">aw_requests_remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">aw_none_remaining</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Finally, on the first beat of any <code class="language-plaintext highlighter-rouge">AWVALID</code>, possibly even before <code class="language-plaintext highlighter-rouge">AWREADY</code>,
we adjust the number of words remaining to be written.  That’s the meaning of
<code class="language-plaintext highlighter-rouge">phantom_start</code> below–it’s true on the first clock cycle of
any new burst write request.  Unlike <code class="language-plaintext highlighter-rouge">AWVALID</code>, <code class="language-plaintext highlighter-rouge">phantom_start</code> is only ever
high for the first cycle.  It’s like what the <code class="language-plaintext highlighter-rouge">AWVALID</code> signal would be if
<code class="language-plaintext highlighter-rouge">AWREADY</code> were always true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phantom_start</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">aw_requests_remaining</span>
		<span class="o">&lt;=</span> <span class="n">aw_requests_remaining</span> <span class="o">-</span> <span class="p">(</span><span class="n">M_AXI_AWLEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">aw_none_remaining</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">aw_requests_remaining</span> <span class="o">==</span> <span class="p">(</span><span class="n">M_AXI_AWLEN</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="k">end</span></code></pre></figure>

<p>You might also wish to notice the other flag associated with our counter:
<code class="language-plaintext highlighter-rouge">aw_none_remaining</code>.  This flag is equivalent to <code class="language-plaintext highlighter-rouge">aw_requests_remaining == 0</code>,
and it is used to <a href="/blog/2017/06/12/minimizing-luts.html">simplify the logic
following</a> so
I don’t have to check every bit of the counter in order to know if it’s zero.</p>

<p>We still need one other counter before we can know if we’ve completed our
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> transactions, and that’s
the counter that keeps track of the number of outstanding burst transactions.
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">This particular
core</a>
maintains both a counter and a flag for this purpose–just like we did
above.  The counter keeps track of the number of outstanding bursts, whereas
the flag keeps track of whether only a single burst is outstanding or not.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">aw_last_outstanding</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">initial</span>	<span class="n">aw_bursts_outstanding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">aw_bursts_outstanding</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// The counter</span>
	<span class="n">aw_last_outstanding</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// The flag</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">case</span> <span class="p">(</span><span class="o">{</span> <span class="n">phantom_start</span><span class="p">,</span>
			<span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BREADY</span> <span class="o">}</span><span class="p">)</span>
<span class="mb">2'b01</span><span class="o">:</span>	<span class="k">begin</span>
	<span class="n">aw_bursts_outstanding</span> <span class="o">&lt;=</span> <span class="n">aw_bursts_outstanding</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">aw_last_outstanding</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">aw_bursts_outstanding</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">end</span>
<span class="mb">2'b10</span><span class="o">:</span>	<span class="k">begin</span>
	<span class="n">aw_bursts_outstanding</span> <span class="o">&lt;=</span> <span class="n">aw_bursts_outstanding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">aw_last_outstanding</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">aw_bursts_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">end</span>
<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
<span class="k">endcase</span></code></pre></figure>

<p>Now that these two counters and their associated flags have been defined,
we finally have enough information to determine if all of our outstanding
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transactions have completed or not.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
	<span class="n">w_complete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span>
	<span class="c1">// We are complete if nothing more is to be requested,</span>
	<span class="n">w_complete</span> <span class="o">=</span> <span class="o">!</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">aw_none_remaining</span><span class="p">)</span>
		<span class="c1">// *and* the last burst response has now been returned</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">aw_last_outstanding</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span><span class="p">);</span></code></pre></figure>

<p>This <code class="language-plaintext highlighter-rouge">w_complete</code> flag is then used to send our state machine back to idle,
by clearing the <code class="language-plaintext highlighter-rouge">r_busy</code> flag.  Once cleared,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">the core</a>
has finished any user commanded reset, and can return to its idle state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r_busy</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">initial</span>	<span class="n">r_complete</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">r_busy</span>     <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">r_complete</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// Core is idle, waiting for a command to start</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w_cmd_start</span><span class="p">)</span>
		<span class="n">r_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="c1">// Any write to the control register will clear the</span>
	<span class="c1">// completion flag</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">axil_write_ready</span> <span class="o">&amp;&amp;</span> <span class="n">awskd_addr</span> <span class="o">==</span> <span class="n">CMD_CONTROL</span><span class="p">)</span>
		<span class="n">r_complete</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">w_complete</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// Clear busy once the transaction is complete</span>
	<span class="c1">//  This includes clearing busy on any error</span>
	<span class="n">r_complete</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">r_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>The key point here is that even though there are several steps required to
reset an AXI master, those steps actually fit in nicely with the logic of
building the AXI master in the first place.</p>

<p>A second key point is simply this: plan ahead for any local reset
functionality you may wish to build into your own design.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Knowing how to reset a single user core in the context of a larger
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
is an important part of building any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
component.  The task isn’t nearly as simple as it might sound, simply
because a local reset shouldn’t require a change in behavior from any of
the other cores attached to the same system
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.  Further, if you don’t do
it right, you risk locking up the entire system–something that is generally
considered quite bad.</p>

<p>One specific worry includes usage counters found within any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="/blog/2019/07/17/crossbar.html">interconnects</a>.
Such counters are required to keep track of the number of outstanding
transactions, so that the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
can know when to adjust any channel assignments
without risking returns getting sent to the wrong
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
masters.</p>

<p>The good news is that by following the steps outlined above, you can
rest assured that your core can still be reset separate from the rest of
the design–even in the presence of any ongoing
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> activity.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Therefore if any man be in Christ, he is a new creature: old things are passed away; behold, all things are become new. (2 Cor 5:17)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
