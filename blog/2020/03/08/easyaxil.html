<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Buidilng an AXI-Lite slave the easy way</title>
  <meta name="description" content="Since writing my first two articles on AXI-Lite, the first discussing howto verify the an AXI-Liteinterface and the secondhow to build an AXI-Liteslave, I’ve...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2020/03/08/easyaxil.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Buidilng an AXI-Lite slave the easy way</h1>
    <p class="post-meta"><time datetime="2020-03-08T00:00:00-05:00" itemprop="datePublished">Mar 8, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Since writing my first two articles on AXI-Lite, the <a href="/formal/2018/12/28/axilite.html">first discussing how
to verify the an AXI-Lite
interface</a> and the <a href="/blog/2019/01/12/demoaxilite.html">second
how to build an AXI-Lite
slave</a>, I’ve had the
opportunity to build not just one but several AXI-Lite slaves.
(<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">1</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">2</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilxbar.v">3</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsingle.v">4</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axildouble.v">5</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axlite2wbsp.v">6</a>, etc.)
The cool part is, I’ve come across some really easy ways to do it that I
thought might be worth sharing.</p>

<p>Before we start, one warning:</p>

<blockquote>
  <p>If you are interested in building an AXI-Lite slave the easy way,
<em>don’t start with vendor IP!</em>  It’s <a href="/formal/2019/09/06/axi-story.html">broken</a>.
<a href="/formal/2018/12/28/axilite.html">Xilinx’s AXI-Lite demo code
has been broken since at least
2016</a>.  They’ve promised
fixes in 2020, but I haven’t seen them yet.  <a href="https://github.com/ZipCPU/wb2axip/blob/master/doc/orconf2019.pdf">Intel’s designs are also
broken</a>
(as is their forum or I might’ve reported the bugs).</p>
</blockquote>

<p>No, the place to start is with a <a href="/formal/2018/12/28/axilite.html">formal property
file</a>.  From there, you can
either use a <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
or not, your choice, depending upon the performance you want from your AXI-lite
slave.  In both cases, though, we’re going to look today at how <em>easy</em> we can
make building an AXI-Lite slave.</p>

<table align="center" style="float: right"><caption>Fig 1. AXI Signals</caption><tr><td><img src="/img/easyaxil/axi-signals.png" alt="" width="375" /></td></tr></table>

<p>As you follow along below, consider the chart showing the various AXI signal
names shown in Fig. 1 on the right.  The chart is organized into columns by
channel: there’s the write address channel with signals prefixed by <code class="language-plaintext highlighter-rouge">AW</code>,
the write data channel with signals prefixed by <code class="language-plaintext highlighter-rouge">W</code>, the write return
channel with signals prefixed by <code class="language-plaintext highlighter-rouge">B</code>, the read address channel with signals
prefixed by <code class="language-plaintext highlighter-rouge">AR</code> and the read return channel with signals prefixed by <code class="language-plaintext highlighter-rouge">R</code>.
In our slave below, we’ll follow Xilinx’s example and add the additional
prefix <code class="language-plaintext highlighter-rouge">S_AXI_</code>.
The top row of this chart shows the pair of handshaking signals, <code class="language-plaintext highlighter-rouge">*VALID</code> and
<code class="language-plaintext highlighter-rouge">*READY</code>, required for controlling data flow on each channel.
The next row shows the AXI-Lite signals we’ll be working with today.  The
three rows below that show AXI signals that aren’t a part of the AXI-<em>lite</em>
protocol.</p>

<p>Our goal will be to control a set of internal registers to
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">our core</a>, while
also replying to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
via the various AXI-Lite signals shown in black in
Fig. 1.</p>

<h2 id="four-registers">Four Registers</h2>

<p>For the sake of today’s discussion, let’s allow our slave to have four
registers.  We’ll call them <code class="language-plaintext highlighter-rouge">r0, r1, r2</code> and <code class="language-plaintext highlighter-rouge">r3</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">;</span></code></pre></figure>

<p>Please, before we go further though, don’t embarrass me.  If you copy this logic
for your own designs (and I expect you might), <em>rename these registers!</em>  I’ve
just seen too many folks starting with <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/bench/formal/xlnxdemo.v">Xilinx’s AXI-Lite demonstration
design</a>
that then leave their registers named
stupid things like <code class="language-plaintext highlighter-rouge">slv_reg0</code>, <code class="language-plaintext highlighter-rouge">slv_reg1</code>, etc.  While that might be great for
a demonstration design, it’s completely inappropriate for any practical designs.
Indeed, if you look at <a href="https://github.com/ZipCPU/wb2axip">some of my own
examples</a>, you’ll see I’ve given <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">my own
registers names</a>
that match closer to their meaning.  For example, <code class="language-plaintext highlighter-rouge">cmd_abort</code> (user has
commanded an abort), <code class="language-plaintext highlighter-rouge">r_busy</code> (the core is busy working), <code class="language-plaintext highlighter-rouge">cmd_addr</code> (the
address to write to), <code class="language-plaintext highlighter-rouge">cmd_length_w</code> (length command, in words), <code class="language-plaintext highlighter-rouge">r_increment</code>
(whether or not to increment the address), etc.  Register values don’t
need to be 32-bits in length either.  In <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/rtl/axis2mm.v#L681-L694">one particular example, a register
word</a>
is composed of many little bits of information, <code class="language-plaintext highlighter-rouge">r_busy</code>, <code class="language-plaintext highlighter-rouge">r_err</code>, <code class="language-plaintext highlighter-rouge">r_complete</code>,
<code class="language-plaintext highlighter-rouge">r_continuous</code>, and more.  These fields are then
<a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/rtl/axis2mm.v#L681-L694">all concatenated together</a>
into a <code class="language-plaintext highlighter-rouge">w_status_word</code>.  For now, just do yourself tomorrow a favor today, by
making your code more readable than my example below.</p>

<p>The only reason why I’m using registers <code class="language-plaintext highlighter-rouge">r0</code>, <code class="language-plaintext highlighter-rouge">r1</code>, <code class="language-plaintext highlighter-rouge">r1</code> and <code class="language-plaintext highlighter-rouge">r3</code> is because
I’m’ trying to create a generic example that will be applicable for all
purposes.  (Yeah, I know, do as I say not as I do … but trust me on this one.)</p>

<p>Let’s give each of these four registers a default value of zero,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">i_reset</span> <span class="o">=</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">r0</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r1</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r3</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>and allow them to be written to any time the signal <code class="language-plaintext highlighter-rouge">axil_write_ready</code> is true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axil_write_ready</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">case</span><span class="p">(</span><span class="n">awskd_addr</span><span class="p">)</span>
		<span class="mb">2'b00</span><span class="o">:</span>	<span class="n">r0</span> <span class="o">&lt;=</span> <span class="n">wskd_data</span><span class="p">;</span>
		<span class="mb">2'b01</span><span class="o">:</span>	<span class="n">r1</span> <span class="o">&lt;=</span> <span class="n">wskd_data</span><span class="p">;</span>
		<span class="mb">2'b10</span><span class="o">:</span>	<span class="n">r2</span> <span class="o">&lt;=</span> <span class="n">wskd_data</span><span class="p">;</span>
		<span class="mb">2'b11</span><span class="o">:</span>	<span class="n">r3</span> <span class="o">&lt;=</span> <span class="n">wskd_data</span><span class="p">;</span>
		<span class="k">endcase</span>
	<span class="k">end</span></code></pre></figure>

<p>The registers you set in
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">your core</a>
may have some other default values.  <em>That’s okay</em>.</p>

<p>We’ll come back and discuss two separate ways of setting <code class="language-plaintext highlighter-rouge">axil_write_ready</code>
further down.  This will be the signal we use internally to determine
when and if we actually want to write to one of our registers.</p>

<p>For now, note that <code class="language-plaintext highlighter-rouge">wskd_data</code> is the data we wish to write to the register.
We’ll discuss how to set that later as well.  For example, it might either be
the output of a <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a>, or be the
same as <code class="language-plaintext highlighter-rouge">S_AXI_WDATA</code>–but we’ll get to that in a moment.  In a similar
fashion, <code class="language-plaintext highlighter-rouge">awskd_addr</code> is that portion of the write address that can be
used to distinguish between write registers.</p>

<p>You’ll might also note that we haven’t used the <a href="/zipcpu/2017/05/29/select-lines.html">write
strobes</a> yet,
<code class="language-plaintext highlighter-rouge">S_AXI_WSTRB</code>.  While I suppose we might ignore them, that’s probably not
the greatest idea, especially since <a href="/doc/axi-spec.pdf">the
specification</a> states explicitly that
a master wishing to abort a transaction should set <code class="language-plaintext highlighter-rouge">S_AXI_WSTRB</code> to zero.
Hence, our implementation should really support these strobe signals.</p>

<p>Sadly, the logic required to support a write strobe is … annoying.  <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/bench/formal/xlnxdemo.v#L309-L314">Inside
Xilinx’s demo, for example, you find all this Verilog code <em>per
register</em></a>:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">    <span class="k">if</span> <span class="p">(</span><span class="n">slv_reg_wren</span><span class="p">)</span>
      <span class="k">begin</span>
        <span class="k">case</span> <span class="p">(</span> <span class="n">axi_awaddr</span><span class="p">[</span><span class="n">ADDR_LSB</span><span class="o">+</span><span class="n">OPT_MEM_ADDR_BITS</span><span class="o">:</span><span class="n">ADDR_LSB</span><span class="p">]</span> <span class="p">)</span>
          <span class="mh">5'h00</span><span class="o">:</span>
            <span class="k">for</span> <span class="p">(</span> <span class="n">byte_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">byte_index</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">C_S_AXI_DATA_WIDTH</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">byte_index</span> <span class="o">=</span> <span class="n">byte_index</span><span class="o">+</span><span class="mi">1</span> <span class="p">)</span>
              <span class="k">if</span> <span class="p">(</span> <span class="n">S_AXI_WSTRB</span><span class="p">[</span><span class="n">byte_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="k">begin</span>
                <span class="c1">// Respective byte enables are asserted as per write strobes</span>
                <span class="c1">// Slave register 0</span>
                <span class="n">slv_reg0</span><span class="p">[(</span><span class="n">byte_index</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">+:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">S_AXI_WDATA</span><span class="p">[(</span><span class="n">byte_index</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">+:</span> <span class="mi">8</span><span class="p">];</span>
              <span class="k">end</span></code></pre></figure>

<p>This just <em>looks</em> complicated, and it’s certainly much harder to read.</p>

<p>Let’s clean that up instead, shall we?</p>

<p>Let’s instead create a Verilog function to apply our
<a href="/zipcpu/2017/05/29/select-lines.html">write strobes</a>
to a prior piece of data, producing a new piece of data.  Remember, if
<code class="language-plaintext highlighter-rouge">S_AXI_WSTRB[0]</code> is true, then we want to adjust bits <code class="language-plaintext highlighter-rouge">7:0</code>, if
<code class="language-plaintext highlighter-rouge">S_AXI_WSTRB[1]</code> is true, then we’d want to adjust bits <code class="language-plaintext highlighter-rouge">15:8</code>, and so on.  If
none of the strobes are true, then nothing should be changed.</p>

<p>This little function below captures all of that.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">function</span> <span class="p">[</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">apply_wstrb</span><span class="p">;</span>
		<span class="kt">input</span>	<span class="p">[</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">prior_data</span><span class="p">;</span>
		<span class="kt">input</span>	<span class="p">[</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">new_data</span><span class="p">;</span>
		<span class="kt">input</span>	<span class="p">[</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">wstrb</span><span class="p">;</span>

		<span class="kt">integer</span>	<span class="n">k</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">apply_wstrb</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="mi">8</span> <span class="o">+:</span> <span class="mi">8</span><span class="p">]</span>
				<span class="o">=</span> <span class="n">wstrb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">?</span> <span class="n">new_data</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="mi">8</span> <span class="o">+:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">:</span> <span class="n">prior_data</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="mi">8</span> <span class="o">+:</span> <span class="mi">8</span><span class="p">];</span>
		<span class="k">end</span>
	<span class="k">endfunction</span></code></pre></figure>

<p><a href="/formal/2019/11/18/genuctrlr.html">As I’ve mentioned before</a>,
I don’t typically use Verilog functions.  As with most things in hardware,
<a href="/blog/2017/09/18/clocks-for-sw-engineers.html">functions in hardware don’t do the same things that they do in
software</a>.
Just as loops in Verilog create more hardware, functions in Verilog specify
how to create more hardware.  Further, submodules can also be used for much the
same thing–so functions aren’t really all that useful in Verilog contexts.
They do have their place, and I think this one will help us quite nicely
while still keeping all of our logic within a single module.</p>

<p>Once we have a function for updating our register available to us, applying the
<a href="/zipcpu/2017/05/29/select-lines.html">write strobes</a> to a
lot of registers gets a whole lot easier.  Here, we’ll take a series of
32-bit registers, and apply the
<a href="/zipcpu/2017/05/29/select-lines.html">write strobes</a>
to each.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// apply_wstrb(old_data, new_data, write_strobes)</span>
	<span class="k">assign</span>	<span class="n">wskd_r0</span> <span class="o">=</span> <span class="n">apply_wstrb</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">wskd_data</span><span class="p">,</span> <span class="n">wskd_strb</span><span class="p">);</span>
	<span class="k">assign</span>	<span class="n">wskd_r1</span> <span class="o">=</span> <span class="n">apply_wstrb</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">wskd_data</span><span class="p">,</span> <span class="n">wskd_strb</span><span class="p">);</span>
	<span class="k">assign</span>	<span class="n">wskd_r2</span> <span class="o">=</span> <span class="n">apply_wstrb</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">wskd_data</span><span class="p">,</span> <span class="n">wskd_strb</span><span class="p">);</span>
	<span class="k">assign</span>	<span class="n">wskd_r3</span> <span class="o">=</span> <span class="n">apply_wstrb</span><span class="p">(</span><span class="n">r3</span><span class="p">,</span> <span class="n">wskd_data</span><span class="p">,</span> <span class="n">wskd_strb</span><span class="p">);</span></code></pre></figure>

<p>The resulting <code class="language-plaintext highlighter-rouge">wskd_rN</code> registers now contain what would be the result of
applying the write strobe to <code class="language-plaintext highlighter-rouge">rN</code> on every clock tick.  That means we can
now use <code class="language-plaintext highlighter-rouge">wskd_rN</code> instead of <code class="language-plaintext highlighter-rouge">wskd_data</code> when setting our registers below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">r0</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r1</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r3</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axil_write_ready</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">case</span><span class="p">(</span><span class="n">awskd_addr</span><span class="p">)</span>
		<span class="mb">2'b00</span><span class="o">:</span>	<span class="n">r0</span> <span class="o">&lt;=</span> <span class="n">wskd_r0</span><span class="p">;</span>
		<span class="mb">2'b01</span><span class="o">:</span>	<span class="n">r1</span> <span class="o">&lt;=</span> <span class="n">wskd_r1</span><span class="p">;</span>
		<span class="mb">2'b10</span><span class="o">:</span>	<span class="n">r2</span> <span class="o">&lt;=</span> <span class="n">wskd_r2</span><span class="p">;</span>
		<span class="mb">2'b11</span><span class="o">:</span>	<span class="n">r3</span> <span class="o">&lt;=</span> <span class="n">wskd_r3</span><span class="p">;</span>
		<span class="k">endcase</span>
	<span class="k">end</span></code></pre></figure>

<p>That’s a whole lot simpler to understand than <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/bench/formal/xlnxdemo.v#L305-L565">Xilinx’s demonstration
code</a>,
now isn’t it?  Admittedly, the comparison isn’t really all that fair, since <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/bench/formal/xlnxdemo.v">my
copy of Xilinx’s example</a>
implements 32 registers and the demonstration logic above only implements 4,
but I still think the example above is a lot easier to read.</p>

<p>You may even find that this structure is too complex for your needs.  Don’t
be afraid to split this logic block up into one block per register, such as
the code for <code class="language-plaintext highlighter-rouge">r0</code> below, if it’s appropriate to do so for your design.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">r0</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axil_write_ready</span> <span class="o">&amp;&amp;</span> <span class="n">awskd_addr</span> <span class="o">==</span> <span class="mb">2'b00</span><span class="p">)</span>
		<span class="n">r0</span> <span class="o">&lt;=</span> <span class="n">wskd_r0</span><span class="p">;</span></code></pre></figure>

<p>Sadly, this only <em>mostly</em> covers the task of setting registers.  You may still
have registers that can only be set if certain conditions hold.  For example,
<a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/rtl/axis2mm.v">in one of my own cores</a>,
I <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/rtl/axis2mm.v#L594-L634">set an <code class="language-plaintext highlighter-rouge">r_err</code> register</a>.
Since the register makes a good example of what could be done, and how
following the script above isn’t always the right thing to do, let’s take
a really quick look at how this <code class="language-plaintext highlighter-rouge">r_err</code> value was set.  First, the
register is cleared on any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">r_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
                <span class="n">r_err</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>Since this <code class="language-plaintext highlighter-rouge">r_err</code> register was drawn from a <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/rtl/axis2mm.v">stream data to memory copy
core</a>,
I wanted to know if the FIFO within was ever overrun–even when
<a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/rtl/axis2mm.v">the core</a>
isn’t busy.  Hence, we’ll set the error on any overflow.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">r_continuous</span> <span class="o">&amp;&amp;</span> <span class="n">overflow</span><span class="p">)</span>
			<span class="n">r_err</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>The next step is the hidden
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
write–matching our example code above: If <code class="language-plaintext highlighter-rouge">axil_write_ready</code>, the
write address matches the address of the control register, the <a href="/zipcpu/2017/05/29/select-lines.html">write
strobe</a>
data for the byte containing <code class="language-plaintext highlighter-rouge">r_err</code> is set, and the user writes a <code class="language-plaintext highlighter-rouge">1</code>
to that bit to clear the error, then the error flag can be cleared.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">axil_write_ready</span> <span class="o">&amp;&amp;</span> <span class="n">awskd_addr</span> <span class="o">==</span> <span class="n">CMD_CONTROL</span>
			<span class="o">&amp;&amp;</span> <span class="n">wskd_strb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">wskd_data</span><span class="p">[</span><span class="mi">30</span><span class="p">])</span>
			<span class="n">r_err</span>     <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_busy</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>Otherwise, if <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/rtl/axis2mm.v">the
core</a>
is actively copying data from a stream to memory, then any writes to the
<code class="language-plaintext highlighter-rouge">r_err</code> register are ignored.  Instead, the register is set if ever <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/rtl/axis2mm.v">the
core</a>
receives an <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
return,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BREADY</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">r_err</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>or if the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
is so slow that it can’t keep up with the stream and data gets dropped.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">overflow</span><span class="p">)</span>
			<span class="n">r_err</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>No, this isn’t part of today’s <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">easy AXI-Lite
core</a>.  I’m
just showing this tidbit of complex AXI-Lite logic to illustrate that this
approach to setting and adjusting registers can be much more complex than
we are showing here–and it’s not all that hard to do.  Indeed, today’s basic
“easy logic” lesson applies to equally to the more complex cores.</p>

<p>There’s one final step common to all
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
slave components: reading from the
registers.  Now that we’ve written to our registers above, we can now read
from them.  Today, we’ll read from the register indicated by <code class="language-plaintext highlighter-rouge">arskd_addr</code> any
time <code class="language-plaintext highlighter-rouge">axil_read_ready</code> is true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">case</span><span class="p">(</span><span class="n">arskd_addr</span><span class="p">)</span>
		<span class="mb">2'b00</span><span class="o">:</span>	<span class="n">axil_read_data</span>	<span class="o">&lt;=</span> <span class="n">r0</span><span class="p">;</span>
		<span class="mb">2'b01</span><span class="o">:</span>	<span class="n">axil_read_data</span>	<span class="o">&lt;=</span> <span class="n">r1</span><span class="p">;</span>
		<span class="mb">2'b10</span><span class="o">:</span>	<span class="n">axil_read_data</span>	<span class="o">&lt;=</span> <span class="n">r2</span><span class="p">;</span>
		<span class="mb">2'b11</span><span class="o">:</span>	<span class="n">axil_read_data</span>	<span class="o">&lt;=</span> <span class="n">r3</span><span class="p">;</span>
		<span class="k">endcase</span>
	<span class="k">end</span></code></pre></figure>

<p>Did you notice that we didn’t use our <code class="language-plaintext highlighter-rouge">axil_read_ready</code> signal at all?  It’s
not really required when reading.  Instead, we adjusted our outgoing read
data any time the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
allowed us to.</p>

<p>That’s not necessarily a low power solution.  Wires that toggle when they
don’t need to consume unnecessary power, so let’s adjust this logic again
so that the outgoing read data is zero any time we aren’t reading.  Further,
since not all designs need this sort of low-power treatment, we’ll create an
option, <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code>, which (if set) will then be used to control whether
or not the read data should be zero whenever there’s no data being read.</p>

<p>This adjusted logic starts off a touch different, since we now need to clear
our read data register on any reset–something we didn’t have to do before.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axil_read_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axil_read_data</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>After the reset, though, our logic looks familiar again.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">case</span><span class="p">(</span><span class="n">arskd_addr</span><span class="p">)</span>
		<span class="mb">2'b00</span><span class="o">:</span>	<span class="n">axil_read_data</span>	<span class="o">&lt;=</span> <span class="n">r0</span><span class="p">;</span>
		<span class="mb">2'b01</span><span class="o">:</span>	<span class="n">axil_read_data</span>	<span class="o">&lt;=</span> <span class="n">r1</span><span class="p">;</span>
		<span class="mb">2'b10</span><span class="o">:</span>	<span class="n">axil_read_data</span>	<span class="o">&lt;=</span> <span class="n">r2</span><span class="p">;</span>
		<span class="mb">2'b11</span><span class="o">:</span>	<span class="n">axil_read_data</span>	<span class="o">&lt;=</span> <span class="n">r3</span><span class="p">;</span>
		<span class="k">endcase</span></code></pre></figure>

<p>That is, it looks familiar until we get to the end.</p>

<p>Here, at the end, we’ll set our outgoing value to zero if ever <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code>
is true, and we aren’t currently reading (i.e. <code class="language-plaintext highlighter-rouge">!axil_read_ready</code>).  The
<code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> part of this is key.  Since it’s a 1-bit parameter, if the
parameter is ever set to zero, the synthesis tool will quietly remove this
logic from our design–making it a no-cost “feature” when it isn’t used.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">axil_read_ready</span><span class="p">)</span>
			<span class="n">axil_read_data</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>How much did this little <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> excursion cost us?  About 96 logic
elements out of a 51 element design.  How much did it gain us?  Well, the
juries still out on that one–I’m just adding in these tests to my cores now,
and I haven’t gotten to the point yet where I can verify that doing so is
valuable (or not).</p>

<p>We’ve now gotten to the point where we can write to and read from our four
registers, except that we didn’t really handle the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
signaling yet.  That’s next.</p>

<h2 id="common-signaling">Common Signaling</h2>

<table align="center" style="float: left; padding: 15px"><caption>Fig 2. Common responses</caption><tr><td><img src="/img/easyaxil/common-sigs.svg" alt="" width="375" /></td></tr></table>

<p>Let’s now turn our attention to that portion of a simple AXI-lite slave that
would be common between any of our implementations: <code class="language-plaintext highlighter-rouge">BVALID</code>, <code class="language-plaintext highlighter-rouge">BRESP</code>,
<code class="language-plaintext highlighter-rouge">RVALID</code>, <code class="language-plaintext highlighter-rouge">RRESP</code>, and <code class="language-plaintext highlighter-rouge">RDATA</code>.</p>

<p>The two <code class="language-plaintext highlighter-rouge">xRESP</code> signals are easy:  we’ll just leave them at <code class="language-plaintext highlighter-rouge">2'b00</code>, indicating
an <code class="language-plaintext highlighter-rouge">OKAY</code> response.  That means that there will never be any errors when
attempting to interact with this simple core.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">S_AXI_BRESP</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">S_AXI_RRESP</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span></code></pre></figure>

<p>From here, we’ll move on to the <code class="language-plaintext highlighter-rouge">BVALID</code> signal.  This signal needs to be
set following any successful write to <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">our
core</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axil_bvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axil_bvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axil_write_ready</span><span class="p">)</span>
		<span class="n">axil_bvalid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>and it needs to remain set until <code class="language-plaintext highlighter-rouge">S_AXI_BVALID &amp;&amp; S_AXI_BREADY</code> are both true
together.  We can simplify clearing this register to just checking if
<code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code>, which then gives us,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">)</span>
		<span class="n">axil_bvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">S_AXI_BVALID</span> <span class="o">=</span> <span class="n">axil_bvalid</span><span class="p">;</span></code></pre></figure>

<p>The read return handshaking logic is almost identical to the write logic.
There are only superficial changes here, so this should look really familiar
to what we just did above for the write return channel.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axil_read_valid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">axil_read_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axil_read_ready</span><span class="p">)</span>
		<span class="n">axil_read_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">)</span>
		<span class="n">axil_read_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">S_AXI_RVALID</span> <span class="o">=</span> <span class="n">axil_read_valid</span><span class="p">;</span>

	<span class="c1">// We accomplished all of our S_AXI_RDATA logic above, so we just</span>
	<span class="c1">// set the bus return signal, S_AXI_RDATA, to it here.</span>
	<span class="k">assign</span>	<span class="n">S_AXI_RDATA</span>  <span class="o">=</span> <span class="n">axil_read_data</span><span class="p">;</span></code></pre></figure>

<p>That’s all the easy work.  It’s also the signaling that would stay the
same no matter how you implemented the front-end of this <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">AXI-Lite
core</a>: with
or without <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s.
Now it’s time to dive into the part that would change depending upon how you
wanted to implement the front-end.</p>

<h2 id="without-skid-buffers">Without Skid Buffers</h2>

<table align="center" style="float: right"><caption>Fig 3. Ready generation</caption><tr><td><img src="/img/easyaxil/axready-sigs.svg" alt="" width="375" /></td></tr></table>

<p>Let’s take a look at how we might handle the incoming valid/ready handshaking.
Specifically, this includes how to handle <code class="language-plaintext highlighter-rouge">S_AXI_AWREADY</code>, <code class="language-plaintext highlighter-rouge">S_AXI_WREADY</code>,
and <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code>.  These are also the signals
<a href="/formal/2018/12/28/axilite.html">Xilinx messed up when they built their demonstration core.
interface</a></p>

<table align="center" style="float: left"><caption>Fig 4. Backpressure</caption><tr><td><img src="/img/easyaxil/backpressure.png" alt="" width="280" /></td></tr></table>

<p>The difficult part about these ready signals is backpressure.
If the master holds <code class="language-plaintext highlighter-rouge">BREADY</code> low, the slave must know to lower <code class="language-plaintext highlighter-rouge">AWREADY</code> and
<code class="language-plaintext highlighter-rouge">WREADY</code>.  This is also true if the master holds <code class="language-plaintext highlighter-rouge">RREADY</code> low, then the slave
needs to know to lower <code class="language-plaintext highlighter-rouge">ARREADY</code>.  Because these aren’t cases people normally
think of, these signals are easy to get wrong when testing via simulation alone.
It’s just not a case you might think of when writing your simulation scripts.</p>

<p>In general, there’s two ways to deal with the incoming channels–both with
and without <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s.
With <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s,
your slave will be able to achieve lower latency and higher throughput.
Without the <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s,
your slave will have less logic and only 50% throughput, but it will still
be a valid AXI-Lite slave.</p>

<p>In this section, we’ll examine how to handle these handshakes the easy
way–without using
any <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s.</p>

<p>Let’s start with the write side again.  We’ll follow <a href="/formal/2018/12/28/axilite.html">(and fix) Xilinx’s
example</a> here
and only raise <code class="language-plaintext highlighter-rouge">S_AXI_AWREADY</code> when both <code class="language-plaintext highlighter-rouge">S_AXI_AWVALID</code> and <code class="language-plaintext highlighter-rouge">S_AXI_WVALID</code>
are true.  This will synchronize the two channels together–an important part
of any AXI slave.</p>

<p>A first draft of this logic might look like,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axil_awready</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="n">axil_awready</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">S_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WVALID</span><span class="p">);</span></code></pre></figure>

<p>While this might work most of the time, it won’t work all the time.<br />
Indeed, if we were to leave this logic like this, then we’d be making the
same (rough) mistake that <a href="/formal/2018/12/28/axilite.html">Xilinx made with their
core</a>.  The problem is that
we didn’t check for backpressure.  So, let’s add that check in to our logic,
and make certain that <code class="language-plaintext highlighter-rouge">axil_awready</code> is low if ever the output channel
is stalled.  That is, we aren’t ready if ever <code class="language-plaintext highlighter-rouge">BVALID</code> is high while
<code class="language-plaintext highlighter-rouge">BREADY</code> is still low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="n">axil_awready</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">S_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WVALID</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">);</span></code></pre></figure>

<p>While this is closer to what we want, we’re still not there.
With this logic alone, it is still possible that <code class="language-plaintext highlighter-rouge">axil_awready</code> might be true
on the same cycle that <code class="language-plaintext highlighter-rouge">BVALID &amp;&amp; !BREADY</code> were also true.  (Remember,
<code class="language-plaintext highlighter-rouge">axil_awready</code> is <em>registered</em>, and so it has to be set one clock earlier!)
Were <code class="language-plaintext highlighter-rouge">axil_awready</code> to ever be true while <code class="language-plaintext highlighter-rouge">BVALID &amp;&amp; !BREADY</code>, a write
response would get lost and our
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
would hang–much like
<a href="/formal/2019/09/06/axi-story.html">Xilinx’s demo will hang</a>.</p>

<p>Let’s fix this by throttling our writes down to one write every other clock
cycle.  We’ll also clear <code class="language-plaintext highlighter-rouge">awready</code> following any reset for good measure.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axil_awready</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axil_awready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">axil_awready</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">axil_awready</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">S_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WVALID</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">);</span></code></pre></figure>

<p>We can now set both of our write ready signals to be equal to this one,
and know that they’ll be properly synchronized.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">S_AXI_AWREADY</span> <span class="o">=</span> <span class="n">axil_awready</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">S_AXI_WREADY</span>  <span class="o">=</span> <span class="n">axil_awready</span><span class="p">;</span></code></pre></figure>

<p>Next, in order to match our logic above and to be able to use the same
logic both with and without a
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
we’ll rename some of our signals
below–specifically <code class="language-plaintext highlighter-rouge">S_AXI_AWADDR</code>, <code class="language-plaintext highlighter-rouge">S_AXI_WDATA</code>, and <code class="language-plaintext highlighter-rouge">S_AXI_WSTRB</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span> 	<span class="n">awskd_addr</span> <span class="o">=</span> <span class="n">S_AXI_AWADDR</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">];</span>
	<span class="k">assign</span>	<span class="n">wskd_data</span>  <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">wskd_strb</span>  <span class="o">=</span> <span class="n">S_AXI_WSTRB</span><span class="p">;</span></code></pre></figure>

<p>Let me back up for a moment and discuss <code class="language-plaintext highlighter-rouge">ADDRLSB</code>.  This is <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/bench/formal/xlnxdemo.v#L129">another one of
those values Xilinx got wrong</a>.
It’s supposed to be equal to the lowest address bit of the word address.  So,
for a 32-bit word, this should be bit <code class="language-plaintext highlighter-rouge">2</code>–allowing bits <code class="language-plaintext highlighter-rouge">1:0</code> to be used to
specify which byte within the word a read is supposed to start from.</p>

<p><a href="/blog/2019/04/27/axi-addr.html">AXI</a> supports sub-word
accesses nicely <a href="/doc/axi-spec.pdf">via the <code class="language-plaintext highlighter-rouge">AxSIZE</code> signal</a>.
Using that signal, we might be able to tell if a read or write was for 8-bits
(<code class="language-plaintext highlighter-rouge">AxSIZE==3'b000</code>) or 16-bits (<code class="language-plaintext highlighter-rouge">AxSIZE==3'b001</code>) instead of all 32-bits
(<code class="language-plaintext highlighter-rouge">AxSIZE==3'b010</code>).  AXI-Lite doesn’t have this signal.  Instead, AXI-Lite only
has the <code class="language-plaintext highlighter-rouge">WSTRB</code> signal and even that only applies to writes.  In other words,
these sub-32-bit address bits really aren’t that useful for us, so we can
simply drop them.</p>

<p>How many bits should be dropped?  Given that AXI-Lite is only ever a 32-bit
data width, the answer is an easy 2-bits.  But what if you wanted a 16-bit
data width, or a 64-bit width?  Then you might consider writing <a href="https://github.com/ZipCPU/wb2axip/blob/53dafe2d54e7a72304afe36e73875a940a351b70/bench/formal/xlnxdemo.v#L129">something like
Xilinx tried</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="n">ADDRLSB</span> <span class="o">=</span> <span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">/</span><span class="mi">32</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>The only problem is that I’ve seen this code copied into
<a href="/blog/2019/05/29/demoaxi.html">AXI (full) cores</a>.  That’s
right, into cores that don’t have a fixed 32-bit width where this calculation
doesn’t match reality.  (In one particular example, some one used this
calculation on a 128-bit bus, only to struggle with the fact that his core
only ever wrote every other word …)  The correct setting for <code class="language-plaintext highlighter-rouge">ADDRLSB</code>
should be,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="n">ADDRLSB</span> <span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">;</span></code></pre></figure>

<p>This will then evaluate to <code class="language-plaintext highlighter-rouge">2</code> for a 32’bit
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>, as we would want.</p>

<p>The address bits above the <code class="language-plaintext highlighter-rouge">ADDRLSB</code> bit, bits <code class="language-plaintext highlighter-rouge">C_AXI_ADDR_WIDTH-1:ADDRLSB</code>,
can now be used to specify which <em>word</em> we wish to transfer–whether
<code class="language-plaintext highlighter-rouge">r0</code>, <code class="language-plaintext highlighter-rouge">r1</code>, <code class="language-plaintext highlighter-rouge">r2</code>, or <code class="language-plaintext highlighter-rouge">r3</code>.  These will be the address bits we focus on.</p>

<p>Finally, we need to create a signal to indicate that a value is ready to
be written, <code class="language-plaintext highlighter-rouge">axil_write_ready</code>.  The easy answer here is to use <code class="language-plaintext highlighter-rouge">axil_awready</code>,
the same signal we are using to accept the write request into our core.
This can then be used by all of our write logic above to tell
us when to write a new value to one of our registers.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">axil_write_ready</span> <span class="o">=</span> <span class="n">axil_awready</span><span class="p">;</span></code></pre></figure>

<p>Sometime after Vivado 2016.3, Xilinx fixed the write bug in their AXI-Lite
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">demonstration
core</a>.
(As of this writing, they have yet to fix the read bug.)
<a href="https://github.com/ZipCPU/wb2axip/blob/master/doc/orconf2019.pdf">Their updated core can handle one write every three
clocks</a>.
You’ll find that logic above is much simpler, and it will even handle one write
every two clocks–a nice throughput improvement–as shown in Fig. 5 below.</p>

<table align="center" style="float: none"><caption>Fig 5. 50% Write throughput</caption><tr><td><img src="/img/easyaxil/writereg-stalled.svg" alt="" width="780" /></td></tr></table>

<p>Simplicity is a good thing.</p>

<p>Reads are even easier to accomplish that writes.  In this case, we can just
set <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> to be the complement of <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code>.  This allows us
to hold <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> high until a read request comes in, and then
immediately drop it until the read response has gone out.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">axil_arready</span> <span class="o">=</span> <span class="o">!</span><span class="n">S_AXI_RVALID</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">S_AXI_ARREADY</span> <span class="o">=</span> <span class="n">axil_arready</span><span class="p">;</span></code></pre></figure>

<p>The neat part about complementing logic like this on a LUT-based architecture,
is that the complement can often (not always) be folded into the LUT that would
read this signal, and so this becomes a zero cost signal.</p>

<p>You can see how well we can handle reads in Fig. 6 below.</p>

<table align="center" style="float: none"><caption>Fig 6. 50% Read throughput</caption><tr><td><img src="/img/easyaxil/readreg-stalled.svg" alt="" width="780" /></td></tr></table>

<p>Finally, we’ll read from <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">this IP
core</a>
any time <code class="language-plaintext highlighter-rouge">S_AXI_ARVALID &amp;&amp; S_AXI_ARREADY</code>
are true, and we’ll read from an address given in <code class="language-plaintext highlighter-rouge">S_AXI_ARADDR</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">axil_read_ready</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARREADY</span><span class="p">);</span>

	<span class="k">assign</span>	<span class="n">arskd_addr</span> <span class="o">=</span> <span class="n">S_AXI_ARADDR</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">];</span></code></pre></figure>

<p>That’s about as simple as AXI-Lite logic can be made to be.  It’s also only
51 LUTs, vs 69 for <a href="/formal/2019/09/06/axi-story.html">Xilinx’s
(broken)</a>
<a href="/formal/2018/12/28/axilite.html">AXI-Lite demo</a>
(adjusted for four registers each).</p>

<h2 id="with-skid-buffers">With Skid Buffers</h2>

<table align="center" style="float: right"><caption>Fig 7. Skid Buffer</caption><tr><td><img src="/img/skidbuffer/skidbuffer-blockdiag.svg" alt="" width="375" /></td></tr></table>

<p>The problem with the <em>really</em> simple  AXI-Lite logic above is simply throughput
performance.  The most it will ever perform is one transfer every other clock
tick.  If you want performance from an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">AXI-Lite
core</a>,
you’ll want to add
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s
to your design.</p>

<p>You should also realize, however, that you’ll be fighting an uphill battle.
Xilinx’s infrastructure isn’t built for AXI-Lite performance.  Just fixing your
AXI-Lite core won’t fix their crippling AXI to AXI-Lite bridge, but I still do
it as a matter of pride in my own workmanship.  That said, there are <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">AXI to
AXI-Lite bridges</a>
that will preserve the 100% throughput of AXI, and there are <a href="/blog/2019/07/17/crossbar.html">AXI-Lite
crossbars</a> if these are
things you are interested in.  You just have to know to <a href="https://github.com/ZipCPU/wb2axip">where to look for
and find them</a>.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 8. Buffer all three incoming channels</caption><tr><td><img src="/img/easyaxil/skidslave.svg" alt="" width="375" /></td></tr></table>

<p>A <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
is a really simple piece of logic that converts a combinatorial ready signal
to a registered one, as shown in Fig. 7 above.</p>

<p>The key to getting high performance from any AXI slave is to place a
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
on all the incoming channels, <code class="language-plaintext highlighter-rouge">AW</code>, <code class="language-plaintext highlighter-rouge">W</code>, and <code class="language-plaintext highlighter-rouge">R</code>, as shown in Fig. 8 on the
left.  As you may recall from <a href="/blog/2019/05/22/skidbuffer.html">our earlier
skid buffer discussion</a>,
this allows the various <code class="language-plaintext highlighter-rouge">READY</code> signals generated by
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">our core</a>
to be registered, even though the ready logic we need is combinatorial.</p>

<p>Here’s how easy this gets.  First, place a
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
on both the <code class="language-plaintext highlighter-rouge">AW</code> and <code class="language-plaintext highlighter-rouge">W</code> channels.  They’ll need to have an appropriate
width for the write address, write data, and write strobes.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">wire</span>	<span class="n">awskd_valid</span><span class="p">,</span> <span class="n">wskd_valid</span><span class="p">;</span>

	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">OPT_OUTREG</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			<span class="p">.</span><span class="n">DW</span><span class="p">(</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="n">ADDRLSB</span><span class="p">))</span>
	<span class="n">axilawskid</span><span class="p">(</span><span class="c1">//</span>
		<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span> <span class="p">.</span><span class="n">i_reset</span><span class="p">(</span><span class="n">i_reset</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_valid</span><span class="p">(</span><span class="n">S_AXI_AWVALID</span><span class="p">),</span> <span class="p">.</span><span class="n">o_ready</span><span class="p">(</span><span class="n">S_AXI_AWREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_data</span><span class="p">(</span><span class="n">S_AXI_AWADDR</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]),</span>
		<span class="p">.</span><span class="n">o_valid</span><span class="p">(</span><span class="n">awskd_valid</span><span class="p">),</span> <span class="p">.</span><span class="n">i_ready</span><span class="p">(</span><span class="n">axil_write_ready</span><span class="p">),</span>
		<span class="p">.</span><span class="n">o_data</span><span class="p">(</span><span class="n">awskd_addr</span><span class="p">));</span></code></pre></figure>

<p>Since we have two channels, and two sets of handshaking signals (one for
each channel), we’ll need two
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">OPT_OUTREG</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			<span class="p">.</span><span class="n">DW</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">+</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">/</span><span class="mi">8</span><span class="p">))</span>
	<span class="n">axilwskid</span><span class="p">(</span><span class="c1">//</span>
		<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span> <span class="p">.</span><span class="n">i_reset</span><span class="p">(</span><span class="n">i_reset</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_valid</span><span class="p">(</span><span class="n">S_AXI_WVALID</span><span class="p">),</span> <span class="p">.</span><span class="n">o_ready</span><span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_data</span><span class="p">(</span><span class="o">{</span> <span class="n">S_AXI_WDATA</span><span class="p">,</span> <span class="n">S_AXI_WSTRB</span> <span class="o">}</span><span class="p">),</span>
		<span class="p">.</span><span class="n">o_valid</span><span class="p">(</span><span class="n">wskd_valid</span><span class="p">),</span> <span class="p">.</span><span class="n">i_ready</span><span class="p">(</span><span class="n">axil_write_ready</span><span class="p">),</span>
		<span class="p">.</span><span class="n">o_data</span><span class="p">(</span><span class="o">{</span> <span class="n">wskd_data</span><span class="p">,</span> <span class="n">wskd_strb</span> <span class="o">}</span><span class="p">));</span></code></pre></figure>

<p>Then we’ll accept a write request (and unstall the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s above)
any time there’s both a write address and write data available.
That is, unless the outgoing interface is stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">axil_write_ready</span> <span class="o">=</span> <span class="n">awskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">wskd_valid</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">);</span></code></pre></figure>

<p>It’s that simple.</p>

<p>Now we can just repeat the process for the read channel.  First, we’ll add the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">wire</span>	<span class="n">arskd_valid</span><span class="p">;</span>

	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">OPT_OUTREG</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">.</span><span class="n">DW</span><span class="p">(</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="n">ADDRLSB</span><span class="p">))</span>
	<span class="n">axilarskid</span><span class="p">(</span><span class="c1">//</span>
		<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span> <span class="p">.</span><span class="n">i_reset</span><span class="p">(</span><span class="n">i_reset</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_valid</span><span class="p">(</span><span class="n">S_AXI_ARVALID</span><span class="p">),</span> <span class="p">.</span><span class="n">o_ready</span><span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_data</span><span class="p">(</span><span class="n">S_AXI_ARADDR</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDRLSB</span><span class="p">]),</span>
		<span class="p">.</span><span class="n">o_valid</span><span class="p">(</span><span class="n">arskd_valid</span><span class="p">),</span> <span class="p">.</span><span class="n">i_ready</span><span class="p">(</span><span class="n">axil_read_ready</span><span class="p">),</span>
		<span class="p">.</span><span class="n">o_data</span><span class="p">(</span><span class="n">arskd_addr</span><span class="p">));</span></code></pre></figure>

<p>Then we accept a read request any time one is present, <em>and</em> the outgoing
<code class="language-plaintext highlighter-rouge">R</code> channel isn’t stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">axil_read_ready</span> <span class="o">=</span> <span class="n">arskd_valid</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">axil_read_valid</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">);</span></code></pre></figure>

<p>Here in this context, the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s seem like
less work than without.  This isn’t quite the case.  The reality is instead
that the <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s
hide the complexity of the AXI channel signaling within them making things
look simple here.  As a result, instead of <code class="language-plaintext highlighter-rouge">51</code> logic elements, we’ll now be
using closer to <code class="language-plaintext highlighter-rouge">114</code>.  It’s still small beans, but it is over twice the size
of what
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">the core</a>
was before.</p>

<p>How well does
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">this core</a>
perform with the 
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s
attached?  Check out the write  performance in Fig. 9, where 4 write beats
are accomplished in 9 clocks periods in spite of three stall clocks and
the write data being misaligned by a clock period.</p>

<table align="center" style="float: none"><caption>Fig 9. 100% Write throughput</caption><tr><td><img src="/img/easyaxil/writeskd-stalled.svg" alt="" width="780" /></td></tr></table>

<p>If you look carefully at Fig. 9 above, you’ll notice that certain values
disappear for a time.  For example, the <code class="language-plaintext highlighter-rouge">A0</code> (white) value vanished for a
clock period before the white <code class="language-plaintext highlighter-rouge">BVALID</code> response was generated.  Similarly,
the brown <code class="language-plaintext highlighter-rouge">A2</code> and <code class="language-plaintext highlighter-rouge">D2</code> values vanished while the yellow <code class="language-plaintext highlighter-rouge">BVALID</code> output
was stalled.  Those values were maintained for us within the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s–making
sure that we didn’t lose them in spite of the fact that the various
interfaces have stalled.</p>

<p>The read performance, shown in Fig. 10, is also similar in that 4 read
requests are returned in 8 clock periods in spite of 3 stall cycles.</p>

<table align="center" style="float: none"><caption>Fig 10. 100% Read throughput</caption><tr><td><img src="/img/easyaxil/readskd-stalled.svg" alt="" width="780" /></td></tr></table>

<p>The write performance would have been as fast as this read performance, if I
had chosen to issue the write address and write data to
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">the core</a>
on the same clock cycle–something the master could easily choose to do.</p>

<h2 id="formal-properties">Formal Properties</h2>

<p>How about verifying
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">this core</a>?</p>

<p>We’ll, there’s the easy way to make certain we are following AXI-Lite
signaling: just connect the <a href="/formal/2018/12/28/axilite.html">formal AXI-Lite property
file</a> to
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">your core</a>
and be done!</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">F_AXIL_LGDEPTH</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="n">F_AXIL_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">faxil_rd_outstanding</span><span class="p">,</span>
					<span class="n">faxil_wr_outstanding</span><span class="p">,</span>
					<span class="n">faxil_awr_outstanding</span><span class="p">;</span>

	<span class="n">faxil_slave</span> <span class="p">#(</span>
		<span class="p">.</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">),</span>
		<span class="p">.</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="p">(</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="p">),</span>
		<span class="p">.</span><span class="n">F_LGDEPTH</span><span class="p">(</span><span class="n">F_AXIL_LGDEPTH</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="c1">// See the property file for a description of</span>
		<span class="c1">// these parameters--what they are, how they work,</span>
		<span class="c1">// and what they do.</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">F_AXI_MAXWAIT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
		<span class="p">.</span><span class="n">F_AXI_MAXDELAY</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
		<span class="p">.</span><span class="n">F_AXI_MAXRSTALL</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
		<span class="p">.</span><span class="n">F_OPT_COVER_BURST</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
	<span class="p">)</span> <span class="n">faxil</span><span class="p">(</span>
		<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span> <span class="p">.</span><span class="n">i_axi_reset_n</span><span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_awvalid</span><span class="p">(</span><span class="n">S_AXI_AWVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awready</span><span class="p">(</span><span class="n">S_AXI_AWREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awaddr</span><span class="p">(</span> <span class="n">S_AXI_AWADDR</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awcache</span><span class="p">(</span><span class="mh">4'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awprot</span><span class="p">(</span> <span class="n">S_AXI_AWPROT</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_wvalid</span><span class="p">(</span><span class="n">S_AXI_WVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wready</span><span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wdata</span><span class="p">(</span> <span class="n">S_AXI_WDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wstrb</span><span class="p">(</span> <span class="n">S_AXI_WSTRB</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_bvalid</span><span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bready</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bresp</span><span class="p">(</span> <span class="n">S_AXI_BRESP</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_arvalid</span><span class="p">(</span><span class="n">S_AXI_ARVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arready</span><span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_araddr</span><span class="p">(</span> <span class="n">S_AXI_ARADDR</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arcache</span><span class="p">(</span><span class="mh">4'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arprot</span><span class="p">(</span> <span class="n">S_AXI_ARPROT</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_rvalid</span><span class="p">(</span><span class="n">S_AXI_RVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rready</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rdata</span><span class="p">(</span> <span class="n">S_AXI_RDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rresp</span><span class="p">(</span> <span class="n">S_AXI_RRESP</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">f_axi_rd_outstanding</span><span class="p">(</span><span class="n">faxil_rd_outstanding</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_axi_wr_outstanding</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_axi_awr_outstanding</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span><span class="p">)</span>
		<span class="p">);</span></code></pre></figure>

<p>You should now be able to pass a bounded model check of any length.</p>

<p>How about an <a href="/blog/2018/03/10/induction-exercise.html">unbounded model
check</a>?</p>

<p>In this case, all we need to do is to correlate the three counters,
1) the number of write address requests outstanding, <code class="language-plaintext highlighter-rouge">faxil_awr_outstanding</code>,
2) the number of write data requests outstanding, <code class="language-plaintext highlighter-rouge">faxil_wr_outstanding</code>, and
3) the number of read requests outstanding, <code class="language-plaintext highlighter-rouge">faxil_rd_outstanding</code>,
against what our logic expects.</p>

<p>For example, if we aren’t using the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>s,
there should never be more than one item outstanding.  (We don’t have storage
for more …)  Not only that, but any time <code class="language-plaintext highlighter-rouge">BVALID</code> is true there should be
exactly one write address or write data item outstanding.  The same is true
for <code class="language-plaintext highlighter-rouge">RVALID</code>, making the proof easy.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_SKIDBUFFER</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">==</span> <span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span> <span class="o">==</span> <span class="n">faxil_wr_outstanding</span><span class="p">);</span>

		<span class="k">assert</span><span class="p">(</span><span class="n">faxil_rd_outstanding</span> <span class="o">==</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span></code></pre></figure>

<p>The proof is a bit harder for the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
case.  In this case, we need to count what’s in the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
against our number of counts.  Hence, if the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
ever drops the outgoing ready signal, then there’s an item sitting in the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
waiting to be accepted by
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">our core</a>.
(Feel free to check out Figs. 9 and 10 above to see this in action.)
We can count these extra items with something like
<code class="language-plaintext highlighter-rouge">(S_AXI_AWREADY ? 0:1)</code>–knowing that <code class="language-plaintext highlighter-rouge">AWREADY</code> will only ever be low if
there’s something in the buffer.  Other than that change,
the counter checks should look the same.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span><span class="o">==</span> <span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
			<span class="o">+</span><span class="p">(</span><span class="n">S_AXI_AWREADY</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">==</span> <span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
			<span class="o">+</span><span class="p">(</span><span class="n">S_AXI_WREADY</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>

		<span class="k">assert</span><span class="p">(</span><span class="n">faxil_rd_outstanding</span> <span class="o">==</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
			<span class="o">+</span><span class="p">(</span><span class="n">S_AXI_ARREADY</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>At this point, we’ve proven that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
works.  We haven’t really proven that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">our core</a>
works, so you might want to consider adding some logic
to check that the design actually reads from your registers as you might like.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_past_valid</span> <span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">S_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="n">axil_read_ready</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_RVALID</span><span class="p">);</span>
		<span class="k">case</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">arskd_addr</span><span class="p">))</span>
		<span class="mi">0</span><span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_RDATA</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r0</span><span class="p">));</span>
		<span class="mi">1</span><span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_RDATA</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r1</span><span class="p">));</span>
		<span class="mi">2</span><span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_RDATA</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r2</span><span class="p">));</span>
		<span class="mi">3</span><span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_RDATA</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r3</span><span class="p">));</span>
		<span class="k">endcase</span>
	<span class="k">end</span></code></pre></figure>

<p>Finally, there’s one last check.  That is, we wanted to make certain that
<code class="language-plaintext highlighter-rouge">RDATA</code> was zero if there was nothing to return–but only if <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code>
was set.  This is easily checked and verified.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_RVALID</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_RDATA</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>I’ve put the whole proof together into <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/easyaxil.sby">five
parts</a>:
Two verify that the AXI-lite signaling is handled properly first without
and then with the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.
The next two double check that we can actually write four values to
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">the core</a>,
and read four values from it–letting the solver pick
which four values.  This was the purpose of the <code class="language-plaintext highlighter-rouge">F_OPT_COVER_BURST</code> option
above–specifying that we wanted to be able to check how fast four
values might be returned.  The last part checks <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>It’s unfortunate that the <a href="/formal/2019/09/06/axi-story.html">vendor AXI-Lite examples are so
broken</a>,
because building and verifying that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">this slave</a>
was <a href="/formal/2018/12/28/axilite.html">protocol compliant</a>
wasn’t really all that hard to do.  The trickiest parts involved handling
any potential backpressure and guaranteeing that all outgoing signals were
properly registered.</p>

<p>I realize I haven’t really used all of the <a href="/formal/2018/12/28/axilite.html">AXI-Lite
signals</a> in
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">this example</a>.
For example, we haven’t used the low order address bits nor wave we used the
various <code class="language-plaintext highlighter-rouge">AxPROT</code> signals.  The reason why not is simply because we didn’t
need to.  Indeed, there’s a strong argument to be made that AXI is <a href="https://www.reddit.com/r/FPGA/comments/egkrce/is_axi_too_complicated/">way more
complicated than it needs to
be</a>–but
we can leave that discussion for another day.</p>

<p>Until then, feel free to modify <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">this
core</a>
for your own purposes.  Don’t forget to check out how easy it is to
formally verify that it works along the way.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Lo, this only have I found, that God hath made man upright; but they have sought out many inventions. (Eccl 7:29)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
