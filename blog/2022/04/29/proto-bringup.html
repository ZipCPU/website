<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Bringing up a new piece of hardware -- what can go wrong?</title>
  <meta name="description" content="For those who wonder what a “day in the life of” a digital design engineermight be like, let me offer the following account of “bringup week.”This is the wee...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2022/04/29/proto-bringup.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Bringing up a new piece of hardware -- what can go wrong?</h1>
    <p class="post-meta"><time datetime="2022-04-29T00:00:00-04:00" itemprop="datePublished">Apr 29, 2022</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>For those who wonder what a “day in the life of” a digital design engineer
might be like, let me offer the following account of “bringup week.”
This is the week the team assembled, with all of their various parts and
pieces, to put a hardware design together for the first time.</p>

<p>I’m getting ahead of myself, though, so let me back up a bit.</p>

<p>As background, I’ve had the wonderful fortune and opportunity to help build a
<a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a>
system.  Since I’m just a one-man shop, I’m only working on a portion of this
system.  My portion is simply the FPGA portion with some demonstration software
thrown in for good effect.  Others had developed and assembled the circuit
boards, someone else had developed the actual
<a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> circuitry, and another team had
designed and built the
<a href="https://en.wikipedia.org/wiki/Transducer">transducers</a>
which would go in the water and couple the physical pressure waves with
electrical signals.  The digital board used to control this initial bringup
effort was <a href="https://digilent.com/shop/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">Digilent’s Nexys Video
board</a>–a
very capable board for many reasons.</p>

<p>My job in this design was primarily two-fold: 1) command the
<a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> transmitter, and 2) capture
and save <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a>
samples from the receiver.  That was, and still is, the primary task.</p>

<p>As with any hardware project, there are several steps towards a working piece
of hardware.  The first couple of steps take place on paper.  Then there’s
an initial prototype design, where the parts and pieces get assembled together
in order to test the concepts first placed on paper.  Just before this
step, I had picked up a <a href="https://digilent.com/shop/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">Nexys Video
board</a>
to test partial designs on.  This is where I’ll pick up the story today–with
the testing of this prototype design.  Later, we’ll actually turn the component
designs that formed this prototype into design components for a fully
functioning <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> system, with all of
the ultimate functionality we are going to give it.  But for now, we’re just
testing our concepts with a basic prototype board.</p>

<p>Thankfully, most of the critical digital work was already done.  I’d been
working on the transmitter for over a year, and I was confident it would work.
How could it not?  I mean, the transmitter design logic was really simple.  All
I needed to do was to generate various tones,
<a href="https://en.wikipedia.org/wiki/Chirp">chirps</a>,
<a href="https://en.wikipedia.org/wiki/Phase-shift_keying#Binary_phase-shift_keying_(BPSK)">BPSK</a>
and/or <a href="https://en.wikipedia.org/wiki/Frequency-shift_keying">BFSK</a>
waveforms.  It was all very basic stuff.  I say I was working on it for a year,
but the original design was done in a day or two and I’ve only been tweaking
it since then.  As for the receiver, I was just planning on porting a receiver
design from another project where it had already demonstrated the ability to
work quite well.</p>

<p>Sounds pretty low key, right?  I mean, all the stuff this project required was
either really simple or had already worked before on another project.  No
problem!</p>

<p>Unfortunately, there were a couple big secondary tasks that didn’t come from
other projects–not all of them explicitly written down.  Worse, some of these
were added into the requirements at a late stage of the game.  Let’s go over
a quick list of what new digital pieces were part of this design:</p>

<ol>
  <li>Gigabit Ethernet</li>
</ol>

<table align="center" style="float: right"><caption>Fig. 1, This system is going to get wet</caption><tr><td><img src="/img/netbus/sysdesign.svg" alt="" width="420" /></td></tr></table>

<p>Here’s the reality: we’re building a
   <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> device.  It’s going
   to get wet.  That’s just the nature of this business.  To make sure things
   can work in water, our plan is to seal all of the electronics into an
   air-tight can.  Sealing that can will require a special technician, so
   … once sealed it’s not likely that I’ll see my FPGA board
   again.  At that point, I’ll have only one interface available to my
   FPGA–and indeed to the entire device: a Gigabit Ethernet (GbE).</p>

<p>That’s it.</p>

<p>Think about this for a moment.  There will be no JTAG port access to plug
   Vivado in to.  There will be no serial port for debugging.  There will only
   be GbE.</p>

<p>That means that any design problems, updates, or upgrades, must all be
   handled via GbE.  Might you need an <a href="/blog/2017/06/08/simple-scope.html">internal logic
   analyzer</a>?  You’ll need
   to configure it, read from it, and process it over GbE.  Want to update the
   design?  You’ll need to write a new design to flash and then command the
   FPGA to reconfigure itself all over GbE.</p>

<p>This sort of thing is often and typically handled via a
   <a href="/about/zipcpu.html">CPU</a>.  What happens,
   however, when you need to update that CPU’s software?  Similarly, what
   happens when the CPU software fails and needs to be debugged?  All of that
   will need to be handled over the network.</p>

<p>For these reasons, I chose to handle several networking protocols in
   digital logic apart from the <a href="/about/zipcpu.html">CPU</a>–so
   I could have some confidence that they would continue to work even while
   the <a href="/about/zipcpu.html">CPU</a> was halted or being debugged.
   These protocols included the <a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">Address Resolution Protocol
   (ARP)</a> and the
   <a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">Internet Control Message Protocol (ICMP, or
   “ping”)</a>,
   as well as the data packet protocol sending out the
   <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> data and a debug protocol I
   built specifically for the purpose of being able to read and write
   addresses in the design across GbE without needing
   the <a href="/about/zipcpu.html">CPU</a>.  That way, the network can
   be used to <a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">halt the CPU, read its registers, update its software, and
   more</a>.</p>

<p>The good news is that I’d done projects with GbE before.  The bad news is
   that this project will likely push the GbE to over 50% capacity.  My
   previous approach to GbE was crippingly slow, and could never handle such
   rates.  As a result, I rewrote much of it to handle AXI stream inputs and
   outputs so the hardware could do most of the network work automatically.</p>

<p>Hence, while the <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> transmit
   and receive logic might be reused, the network logic contained a massive
   rewrite and a lot of new logic.  The one good news to this new portion of the
   requirement is that we were only bringing up a prototype.  The prototype
   wasn’t going to be sealed in a bottle, and so I <a href="/blog/2017/06/05/wb-bridge-overview.html">still had the serial port
   and more available to
   me</a>–with the
   understanding that future versions would remove this and any other excess
   interfaces.</p>

<ol start="2">
  <li>
    <p>Time Synchronization</p>

    <p>Eventually, we’ll need to coordinate multiple of these
<a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> devices together.  That means
they’ll all need to send their transmit pulses at the same time, and they’ll
all need to sample the return waveforms at the same time.</p>

    <p>Oh, and did I mention that any synchronization would need to take place over
GbE?</p>

    <p>As a bonus, I’m trying to figure out how I might synchronize these devices
to GPS, but … I’m not there yet.  Of course, there’s no GPS in the water,
so the synchronization would have to come from above.  The big difference
would be that GPS allows you to do absolute time synchronization, vs the
simpler relative time synchronization task of running multiple co-located
devices.</p>

    <p>Oh, and just to add into the mix: there’s no room in the one control cable
containing the GbE connection to add specialized timing signals or even
a common clock.  It’s all GbE.</p>

    <p>This logic is also new.</p>
  </li>
  <li>
    <p>Audio</p>

    <p>Somewhere along here, I must’ve decided that my task was too easy, and
so I pointed out to other members of the team that the FPGA development
board we were using for the prototype bringup had audio ports on it and
asked if we could use them.</p>

    <p>Well, okay, the story is a bit longer.  The challenge with any test is that
you need test equipment.  How shall we know, for example, how much power
the device is putting in the water if we can’t measure it?  Measuring
something like that requires a calibrated measurement device and I
volunteered the FPGA as a way of reading from this calibrated device.</p>
  </li>
</ol>

<table align="center" style="float: left; padding: 20px"><caption>Fig. 2, Knowing how much power is in the water requires an independent, calibrated measurement</caption><tr><td><img src="/img/proto-bringup/microphone.svg" alt="" width="420" /></td></tr></table>

<p>I mean, why not use the I2S controller I’d built years earlier (and never
   tested) to listen to this calibrated device?  The controller was already
   on board, it just needed to be read.  Even better, if the FPGA read from
   the calibrated device, then we could have common time stamps between our
   transmitter and the calibrated receiver.</p>

<p>The other half of this measurement is the question of, how can you tell how
   good your receiver is?  This requires having a known source that can
   transmit a known waveform, which can then be heard using the
   <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> device under test.
   Basically, you need to be able to broadcast a waveform at a known volume
   and then receive at the same time.  You can then take that received waveform,
   correlate it with the transmitted waveform, and get a measure of how much
   power you were able to receive.  If you know how much power was actually
   in the water, you should then be able to estimate how much of that power
   you were able to successfully capture.</p>

<p>While we’re at it, why not just grab “sounds” from locations within the
   device to allow your “ear” to do some debugging?</p>

<table align="center" style="float: right"><caption>Fig. 3, Audio Feedback Sources</caption><tr><td><img src="/img/proto-bringup/audio-out.svg" alt="" width="420" /></td></tr></table>

<p>This is all well and good.  My problem was that none of this was part of my
   original assignment.</p>

<p>An ugly corollary to the above problem statement is that I set up the audio
   device for 96k samples per second.  The
   <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a>,
   however, was sampling at a much higher frequency.  How than shall I take the
   <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a>,
   sampling rate and downsample it to the audio rate?  Several of these
   audio sources needed resamplers, as shown in Fig. 3 above.  Those also
   needed to be designed and tested.</p>

<ol start="4">
  <li>
    <p>Video</p>

    <p>One of the hassles of our setup was that viewing the data was a challenge.
By design, the prototype <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a>
device would digitize sound waves from the
water, assemble them into packets, and then blast those packets over the
network.  I then needed to write software to capture these packets and to
write them to a file.  The plan was then to read this file into
<a href="https://www.gnu.org/software/octave">Octave</a> for analysis.</p>
  </li>
</ol>

<table align="center" style="float: left; padding: 20px"><caption>Fig. 4, A Simulated Falling Raster</caption><tr><td><img src="/img/proto-bringup/gfx-raster.png" alt="" width="401" /></td></tr></table>

<p>The problem with this setup is that you don’t get any immediate feedback
   regarding what’s in the water.  It takes time to capture packets, more time
   to read them into <a href="https://www.gnu.org/software/octave">Octave</a>, and even
   more time to then display these packets.  Was there something that could
   be done in real time?</p>

<p>Well, yes.  The <a href="https://digilent.com/shop/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">Nexys Video development board</a>
   we were using for this prototype also has an HDMI video output port.  Why
   not use that to generate some canned displays?  As it turns out, simple
   <a href="https://github.com/ZipCPU/vgasim/blob/dev/rtl/gfx/vid_histogram.v">histograms</a>,
   <a href="https://github.com/ZipCPU/vgasim/blob/dev/rtl/gfx/vid_histogram.v">plots</a>,
   and even <a href="https://github.com/ZipCPU/vgasim/blob/dev/rtl/gfx/vid_waterfall.v">falling
   rasters</a>
   aren’t all that hard to build.  Why not add these to the mix?</p>

<p>Fig. 4, for example, shows a falling raster.  Recent time is at the top,
   and it scrolls down from above.  Frequency goes from left to right, and the
   energy at any particular frequency is shown coming out of the page.  (I.e.
   black has no energy, white has the most.)</p>

<p>In this case, the signal shown is a test signal for which I manually
   varied the frequency during a
   <a href="/blog/2018/08/22/what-is-simulation.html">simulated</a>
   test-run.</p>

<table align="center" style="float: right"><caption>Fig. 5, A simulated split window, containing a spectrogram and a falling raster</caption><tr><td><img src="/img/proto-bringup/gfx-split-trace.png" alt="" width="401" /></td></tr></table>

<p>Fig. 5 is very similar, save that we’ve now split the screen in half using
   a <a href="https://github.com/ZipCPU/vgasim/blob/dev/rtl/gfx/vid_empty.v">blank video
   generator</a>,
   plus two <a href="https://github.com/ZipCPU/vgasim/blob/dev/rtl/axisvoverlay.v">AXI video stream
   overlays</a>
   in order to generate a split video.  The top half shows a
   <a href="https://github.com/ZipCPU/vgasim/blob/dev/rtl/gfx/vid_trace.v">trace</a> of
   the <a href="/dsp/2018/10/02/fft.html">Fourier transform</a>
   of the input signal, whereas the bottom half shows a <a href="https://github.com/ZipCPU/vgasim/blob/dev/rtl/gfx/vid_waterfall.v">falling
   raster</a>
   again.  Where the two meet, you can see the current
   <a href="/dsp/2018/10/02/fft.html">Fourier transform</a>
   and a horizontal line showing that
   <a href="https://en.wikipedia.org/wiki/Spectrogram">spectrogram</a>
   coming out of the screen.</p>

<p>So far, all this capability sounds wonderful!</p>

<p>That is, until it has to be made to work.</p>

<p>Remember, the most expensive part of digital logic (FPGA) design is not
the design itself, but rather the verification of that design.  Not only that,
I had now permitted some major scope creep into the project.  Neither audio
nor video were ever <em>required</em> portions of the project.  While I had done HDMI
video before, I hadn’t done I2S audio nor had I ever configured the I2S chip
I had using I2C before.  (Remember <a href="/blog/2021/11/15/ultimate-i2c.html">my proposal for an ultimate I2C
controller</a>?
This would be the first test of <a href="https://github.com/ZipCPU/wbi2c/blob/master/rtl/wbi2ccpu.v">that
controller</a>.)</p>

<p>All this meant that there needed to be just that much more testing prior to
bringup.</p>

<h2 id="programmatics">Programmatics</h2>

<p>Just to add to the stress of the entire project, let me point out a very
simple reality:  It takes time to coordinate team activities.  Put another
way, if you want a design to work across the boundaries of multiple engineering
teams, then you really need to get the engineers responsible for each portion
of the design together into the same room and lock them in there until it works.
That means there needs to be a time and date on a schedule for the meeting.
Travel arrangements need to be made.  This all needs to be done in advance,
and .. it takes a lot of work to rearrange things if need be.  No one wants
to be the one individual responsible for telling the rest of the team that
they have some problem or other and every one else will need to reschedule.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig. 6, Test Readiness Review</caption><tr><td><img src="/img/proto-bringup/trr.svg" alt="" width="420" /></td></tr></table>

<p>On a larger project, we might have coordinated a “Test Readiness Review”, so
that everyone would be on the record stating that their portion of the project
was sufficiently working that the project was now ready for test.  In our
case, the analog engineer didn’t feel like he could debug his side of the board
until he had access to a working digital design–forcing us to come together
perhaps earlier than we might have otherwise.</p>

<p>Either way, once we put this bringup week on the calendar, it was then
going to happen whether I was ready for it or not.</p>

<p>In my case, I felt like I was ready: I could
<a href="/blog/2018/08/22/what-is-simulation.html">simulate</a>
the device and see the critical portions of the design working nicely through
all of the
<a href="/blog/2018/08/22/what-is-simulation.html">simulated</a>
digital hoops I had laid out for it.</p>

<p>Still, there was always the worst case scenario: What if my
<a href="/blog/2018/08/22/what-is-simulation.html">simulations</a>
were insufficient, or some hardware piece didn’t work like I had expected?  What
if I arrived at the test site and my stuff didn’t work?  The last thing I
wanted was to sit in a room full of engineers with everyone staring at me
and asking me why my portion of the design, the digital logic, wasn’t working.</p>

<h2 id="preparation">Preparation</h2>

<p>Let’s just remember, though, I figured this task would be relatively simple: I
already had the transmitter and receiver built, and the receiver had been used
in another project.  So … I allocated myself about two weeks to do my final
preparations.</p>

<p>I suppose it’s not quite so bad as that.  That’s just what it felt like towards
the end.  Looking over my git logs, I had the major portions of the design built
and verified two months before bringup.  They all built.  They were all lint
clean via <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>.</p>

<p>My big problem, however, is that I didn’t have a large
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
infrastructure.  I had a long list of things that should’ve been tested in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
but for which I didn’t really have a good model for.  For example, <a href="https://github.com/ZipCPU/wbi2c/bench/cpp/i2csim.cpp">my I2C
model</a> didn’t match
that of the Audio chip I was going to control.  Neither did I have a network
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
model (at first).  I certainly didn’t have a model for the
<a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> transmitter, and no method other
than formal methods to verify it.</p>

<p>Still, I was confident things would work–perhaps naively so.</p>

<p>However, when I started building my design with Vivado I was quickly reminded
of some of the limitations of
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>’s
lint capabilities.  Sure, they’ve gotten <em>a lot better</em> since <a href="/blog/2017/07/17/debugging-dbgbus.html">I last grumped
about them</a>, but
Vivado still catches more wires that should be registers and registers that
should be wires than
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
does.  (I know,
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a> is
an <em>open source</em> project–I should submit a patch to fix these issues.
I’ll just be honest and say that I haven’t done so–yet.)</p>

<table align="center" style="float: right"><caption>Fig. 7, Clocks in the design</caption><tr><td><img src="/img/proto-bringup/clocks.svg" alt="" width="240" /></td></tr></table>

<p>Then there was timing.  Sadly, this design has way too many clocks in it.
The SPI based A/D runs off of a 200MHz clock.  The network runs off of two
separate 125MHz clocks–one for transmit and one for receive.  I would combine
these two clocks, but there’s always the possibility that the network might not
come up in GbE mode.  In that case, the receive clock will run at either 2.5MHz
(10T) or 25MHz (100T), whereas the transmit clock will remain at 125MHz.  The
audio runs off of a 24.5MHz clock.  The rest of the design runs off of the
100MHz clock used by the DDR3 memory and exported by the MIG.  That meant
that, just to get the design to synthesize, I needed to write a lot of timing
exceptions everywhere something
<a href="/blog/2017/10/20/cdc.html">crossed clock domains</a>.
Although tedious, the good news is that I found some places where I didn’t
realize I was <a href="/blog/2017/10/20/cdc.html">crossed clock
domains</a>, and all of those needed
to be fixed.</p>

<p>One problem I had early on in when trying to implement my design centered
around how to delay the network clock by 90 degrees from the data.  My plan
was to, and indeed <a href="https://github.com/ZipCPU/videozip/blob/7e86624a623c38a2fd36fdffc6ec56c693c2ec37/rtl/toplevel.v#L351-L356">my previous implementations of this interface
did</a>, <a href="https://github.com/ZipCPU/videozip/blob/7e86624a623c38a2fd36fdffc6ec56c693c2ec37/rtl/toplevel.v#L356">output a clock using a hardware
ODDR element</a>, and to drive that element with <a href="https://github.com/ZipCPU/videozip/blob/7e86624a623c38a2fd36fdffc6ec56c693c2ec37/rtl/toplevel.v#L567">a clock
that was 90 degrees delayed from my data
clock</a>.
As long as the two logic levels leading into this ODDR element were constant
this shouldn’t be a problem, right?</p>

<p>Well, not quite.</p>

<p>There was always the possibility that the transmitter might need to run at
a lower network speed than GbE, and then these values would need to toggle
to generate a slower speed clock.  But, my patience was thin, I just wanted
it to work–not necessarily to work right.  Unfortunately, Vivado gave me
no end of grief trying to get timing closure using this method.  In the end, I
tore up that approach and simply output both clock and data using a 4x OSERDES.
That way I could guarantee the phase relationship and clock crossings myself,
and also guarantee that the network interface was done “right”.  (Incidentally,
I’ve also now verified–by accident–that the slower speed transmit mode works
as designed.)</p>

<p>I was now ready to place the design on the board.</p>

<p>The first test?
<a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a> and
<a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP (ping)</a>.
Why?  Because if I ever need to debug a network connection, the first thing I
always try is to <a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a>
the device on the other end.  When you run
<a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a>
on your local network, the first thing your computer will do is to broadcast an
<a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a>
request.  Once it gets the response,
and only then, will the actual
<a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a>
packet get sent.</p>

<p>Neither worked.</p>

<p>I still remember that cold, depressed feeling as I stared at the board and
wondered to myself, now what?</p>

<p>Unfortunately, I hadn’t put any debugging infrastructure into any of the new
components of the design.  I just … never thought things wouldn’t work.
(You’d think I’d know better by now …)  So my first step was to instrument
as much of the network design as I could with <a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone
scopes</a>.
I started with the end points, and then worked my way towards the packet
processors in the middle.  Every step got a scope.  It got to the point where
I could touch any point in the packet processing chain to see what was going on.</p>

<p>Shall we look over some of the errors I found?  Here was one: my packet miss
counter wasn’t counting up the number of missed packets.  See the bug?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_wb_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_net_reset_n</span><span class="p">)</span>	<span class="c1">// See the bug?</span>
		<span class="n">counter_rx_miss</span> <span class="o">&lt;=</span> <span class="mh">32'h0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rx_miss_stb</span><span class="p">)</span>
		<span class="n">counter_rx_miss</span> <span class="o">&lt;=</span> <span class="n">counter_rx_miss</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>If you missed it, just remember that <code class="language-plaintext highlighter-rouge">_n</code> is the suffix I use for negative
logic.  The counter should be cleared on reset, and the test for that should’ve
been for <code class="language-plaintext highlighter-rouge">!o_net_reset_n</code>.</p>

<p>This wasn’t the only place where I got reset polarities mixed up.  In
a design filled with “working” and “formally verified” modules, you’d expect
some bugs due to integration.  Here was one of those bugs:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">pkt2stream</span>
	<span class="n">icmp_stream</span> <span class="p">(</span>
		<span class="p">.</span><span class="n">S_AXI_ACLK</span><span class="p">(</span><span class="n">i_net_rx_clk</span><span class="p">),</span> <span class="p">.</span><span class="n">S_AXI_ARESETN</span><span class="p">(</span><span class="n">rx_reset</span><span class="p">),</span><span class="c1">//Same bug</span>
		<span class="c1">// ...</span></code></pre></figure>

<p>Incidentally, this was the exact same bug.  <code class="language-plaintext highlighter-rouge">rx_reset</code> was active high, whereas
<code class="language-plaintext highlighter-rouge">S_AXI_ARESETN</code> is active low.  Not only that, I found this same bug in a
couple of submodules of the same network control module.</p>

<p>Here’s another bug I found.  Again, this is the sort of bug you might expect
when integrating various “working” components together.  In this case, I
was using <a href="/blog/2022/02/23/axis-abort.html">abortable AXI
Streams</a>, and needed a way
to convert these streams to normal AXI streams that couldn’t be aborted and
that could be written to memory if desired.  (There’d be no room for TLAST in
memory …)  My method of handling this was to start each “packet” with a
length word, followed by the packet payload.  The bug?  Well, the
converter to AXI Stream calculated the length word based upon the length
of the packet itself, whereas the bridge from a regular AXI Stream to an
<a href="/blog/2022/02/23/axis-abort.html">abortable AXI stream</a>
included the four bytes of the length word in its length count.</p>

<table align="center" style="float: none"><caption>Fig. 7, Converting between AXI Stream types</caption><tr><td><img src="/img/proto-bringup/pktlength.svg" alt="" width="760" /></td></tr></table>

<p>Apparently, there was enough time separating when I wrote these two components
that I forgot which format I was using.  Then, to add insult to injury,
neither of the two components using this format described the format properly
in their comments.  Had they done so, the issue would’ve been easier to debug.</p>

<p>Lesson learned: Document all interface formats.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig. 8, Selecting from among many packet sources</caption><tr><td><img src="/img/proto-bringup/txmux.svg" alt="" width="480" /></td></tr></table>

<p>I also found a <a href="/blog/2021/08/28/axi-rules.html">basic AXI
handshaking</a> bug in the
packet merge utility.  This utility, shown in Fig. 8, is responsible for
granting channel access to one (and only one) packet source when that source
wishes to send a packet.  In my case, there were several possible packet
sources: the
<a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a> processor, the
<a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>
processor, the debug protocol handler, and the receive data processor.
(Eventually, the list will include the network time handler and CPU packet
handling as well.)  In this case, the bug involved moving a data item forward
in an AXI Stream when the slave was valid, rather than waiting for the slave
to be valid <em>and</em> ready.  The result was an extra word at the beginning of
every packet.</p>

<p>Incidentally, this is one of those places where formal verification is no
more complex than a counter: You count the number of stream words from a given
stream’s packet input going into the mux, and you count the number of words
coming out.  Verify that the same number of words going in matches the number
of words coming out.  If you want to get fancy, you can even declare that
word #XYZ (let the solver pick this) must have some solver chosen value,
and then verify the same on the output.  Still, the formal proof is quite easy
to do.  … You just have to do it.</p>

<p>During this whole process, I used <a href="https://www.wireshark.org">Wireshark</a>
heavily to debug any errors.
<a href="https://www.wireshark.org">Wireshark</a> could tell me, for example, if an
<a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a>
request was getting a response or not, or if that response had the correct
format, or if not what part of the packet was in error.
(<a href="https://www.wireshark.org">Wireshark</a> was
also telling me that I was blasting packets of what looked like random data
across the network–but we’ll get to that nasty bug soon enough.)  If you
ever find yourself doing network debugging, I highly recommend having
<a href="https://www.wireshark.org">Wireshark</a> running during your debug sessions.  The
information it provides is just that valuable.</p>

<p>Once I had
<a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a> and
<a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>
working, as well as seeing my receive data packets
properly transmitted, I figured my task was done.  I took a break and rested
for the weekend.  It wasn’t until the next week when I tried looking at the
output of my <a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a>
command, and thus discovering that
[ping](https://en.wikipedia.org/wiki/Ping_(networking_utility) didn’t
think it was getting a response, that I dug even further down to discover that
my <a href="https://en.wikipedia.org/wiki/IPv4">IP</a>
<a href="https://en.wikipedia.org/wiki/Internet_checksum">checksums</a>
were all wrong.</p>

<p>Lesson learned: <a href="https://www.wireshark.org">Wireshark</a> doesn’t automatically
check <a href="https://en.wikipedia.org/wiki/IPv4">IP</a> or
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
<a href="https://en.wikipedia.org/wiki/Internet_checksum">checksums</a>.
That functionality needs to be enabled.</p>

<p>Oops.</p>

<p>As it turns out, I had built my <a href="https://en.wikipedia.org/wiki/Internet_checksum">IP
checksum</a> logic based upon my
memory of how the <a href="https://en.wikipedia.org/wiki/Internet_checksum">checksum</a>
was supposed to work from the last time I had built
<a href="https://en.wikipedia.org/wiki/IPv4">IP</a> packets.  Apparently, I had forgotten
that the <a href="https://en.wikipedia.org/wiki/Internet_checksum">checksum</a>
needs to be inverted before use.</p>

<table align="center" style="float: right"><caption>Fig. 9, Packet Checks in the Network Simulator</caption><tr><td><img src="/img/proto-bringup/netsim-checks.svg" alt="" width="420" /></td></tr></table>

<p>By this point, I had also finally bit the bullet: I now had a GbE network
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a> model.
This model would send random
<a href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP</a> and
<a href="https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol">ICMP</a>
requests, and validate their responses.  It checked
<a href="https://en.wikipedia.org/wiki/IPv4">IP</a> and
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
<a href="https://en.wikipedia.org/wiki/Internet_checksum">checksums</a>.  It would also
validate <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
packets.  Even better, I could send requests to my design via
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
on the local host, and the network model would then forward those requests
into the design and then forward any responses back.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig. 10, Network Packet Simulator</caption><tr><td><img src="/img/proto-bringup/netsim.svg" alt="" width="420" /></td></tr></table>

<p>This <a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
capability was very helpful, and I’m not sure I would’ve found
any of my remaining bugs without it.</p>

<p>Another ugly bug I wasn’t expecting was associated with adding packet
headers and so forth to the design.  In this design, the network engine
accepts an AXI stream packet.  That packet starts with the Ethernet destination
and an EtherType (skipping the Ethernet source MAC), followed by any ethernet
payload.  Incidentally, this format helps keep all the AXI stream words
formatted nicely on 32-bit boundaries–but that’s another story.</p>

<table align="center" style="float: right"><caption>Fig. 11, Network Core processing steps</caption><tr><td><img src="/img/proto-bringup/netcore.svg" alt="" width="320" /></td></tr></table>

<p>It then <a href="https://github.com/ZipCPU/videozip/blob/enet/rtl/ethernet/addemac.v">fills out the rest of the Ethernet
header</a>,
<a href="https://github.com/ZipCPU/videozip/blob/enet/rtl/ethernet/addepad.v">expands the packet to the minimum
size</a>
(64 bytes), and <a href="https://github.com/ZipCPU/videozip/blob/enet/rtl/ethernet/addecrc.v">adds a
CRC</a>.
All of this extra “adding” process, however, takes cycles, and I wasn’t
insisting on any dead time between packets to make sure these cycles were
available.  Rather, I had set the TREADY value associated with the incoming
network packet stream to be a constant one.</p>

<p>Frankly, I never saw that one coming.  Because I unconditionally set
<code class="language-plaintext highlighter-rouge">TREADY=1</code>, the network processing modules weren’t getting properly reset
between packets and so independent packets were getting merged together.
This wasn’t a problem with the previous design from which this one was drawn,
since the previous design used a different handshake to start packet
transmission.</p>

<p>Still, I figured I was at least close to ready.</p>

<p>I even had the network debugging port up and running.  This port was a
modified version of my <a href="/blog/2017/06/05/wb-bridge-overview.html">serial port “debugging
bus”</a>, save that
it had been modified to run “reliably” over
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>.
Using this port, I could send commands to the device to read or write to any
address found within my FPGA design.
The basic protocol was that the external computer would send a packet to the
FPGA requesting a bus transaction, and then wait for the FPGA’s response.  Every
packet was given a response.  If there was ever no response, the request would
timeout and then get repeated.  As a result, no more than one request would
ever be in flight at any given time–although there might be multiple copies of
that one request and its response in flight.  To handle that, if the FPGA
received duplicate packets, it would only run the bus requests once for the
first packet request, and then simply repeat the response it had generated
for that request on any subsequent requests.  No, the protocol wasn’t very
efficient networkwise, but it was <em>MUCH</em> faster than the serial port it was
replacing.</p>

<p>Now that I had all of this working, it was time to start staging for the trip.</p>

<h2 id="staging">Staging</h2>

<p>“Staging” is my word for separating all of the hardware that will be traveling
with me from my fixed development environment.  My desktop would not be
traveling with me, so I needed to bring a laptop–and a newly purchased one
at that.  That laptop would be a special project laptop.  It needed to have
Linux installed, Vivado, Verilator, GtkWave, Icarus Verilog, zip-gcc and
… all my favorite development toys.  Once I had all these installed, I
cleared off a table and started setting up my traveling equipment.</p>

<p>Of course, once I put it all together, nothing worked.</p>

<p>Sound familiar?</p>

<p>This time, it took me almost a whole day to chase down the problem.  (I hadn’t
allocated time for this extra day …)  Apparently, that brand new laptop I had
just bought for this trip and this project came with a bad Ethernet port.
(Or had I broken it somehow?  I’ll never know …)</p>

<p>The problem with this was, I had assumed everyone else’s hardware “just
worked.” Had I suspected the laptop might have a bad Ethernet port, I
might’ve saved myself a half day or more by trying my USB to Ethernet
dongle earlier.</p>

<p>Instead, I turned to my <a href="https://github.com/ZipCPU/videozip/blob/dev/rtl/enetctrl.v">(working) MDIO
controller</a>
for the first time only to discover … it wasn’t working.  I couldn’t figure
out what had happened.  I knew the design worked before the last time I used
it, but somehow it wasn’t working today.  In particular, the bits returned
were off by one, and the last bit wasn’t trustworthy.  In hindsight, looking
over the design with <a href="https://www.atlassian.com/git/tutorials/gitk">gitk</a>, it
looks like I had tweaked this design since copying it from the
<a href="https://github.com/ZipCPU/videozip/blob/enet/rtl/enetctrl.v">“working” project</a>
and … not validated it since.  Those “tweaks” were what wasn’t working.</p>

<p>At this point, though, I was less than a two days out.  It was now Wednesday,
the <a href="https://www.amtrak.com/auto-train">train</a> left on Friday, and I had only
just gotten my tests running again in this staging area.  Then, when I went to
double check everything again, I discovered that … the
<a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a>
data packets weren’t getting through anymore.</p>

<p>At this point, I was out of time.  I had a critical capability that wasn’t
working, but it was now time to pack up all my hardware for the train.
(I swear it was working earlier!  What happened?)</p>

<table align="center" style="float: right"><caption>Fig. 12, Amtrak's Auto Train</caption><tr><td><img src="/img/proto-bringup/auto-train.svg" alt="" width="360" /></td></tr></table>

<h2 id="the-train">The Train</h2>

<p>Let me set the stage a bit more for what happened next.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a> data processing in this
system takes place in several steps:</p>

<ol>
  <li>
    <p>All of the digitizers for the various sensors sample their data from an
SPI based A/D concurrently.</p>
  </li>
  <li>
    <p>That data is then serialized, and organized into blocks of 24 samples,
with 24-bits per sample.</p>
  </li>
  <li>
    <p>Each block is then examined to calculate an appropriate block exponent.</p>
  </li>
  <li>
    <p>The samples are then compressed into 16, 20, 24, or 32-bits per sample.</p>

    <p>Okay, so stuffing 24-bits into 32-bits isn’t much of a compression, but it
does make it easier to examine what’s going on when staring at a hex dump
of the packet.</p>
  </li>
  <li>
    <p>Finally, the samples and exponents are assembled together into packets of
32-bit words.  The packets contain configuration information, the time
stamp of the first sample, possibly some non-acoustic data, and then
transmit information is appended to the end of the packet.</p>

    <p>This takes place in a module I called <code class="language-plaintext highlighter-rouge">rx_genpkt</code>.  By the time I got on
the train, this module had just recently been formally verified (we’ll
discuss that with Fig. 13 below), and no longer showed any signs of being
broken in either
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
or hardware.</p>
  </li>
  <li>
    <p>Ethernet, <a href="https://en.wikipedia.org/wiki/IPv4">IPv4</a>, and
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> headers are
then added to the sample packet, containing the length of the packet,
<a href="https://en.wikipedia.org/wiki/IPv4">IP</a> and
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
<a href="https://en.wikipedia.org/wiki/Internet_checksum">checksums</a>,
and so forth.</p>

    <p>This takes place in a module I called <em>pkt2udp</em>, the one module I knew
was broken when I got on the train.</p>
  </li>
  <li>
    <p>The packet then gets multiplexed between the
<a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a>
sensor data source and a second (microphone) data source–following Fig. 2
shown above.</p>
  </li>
  <li>
    <p>It then crosses from the 100MHz to the 125MHz clock domain.</p>

    <p>This clock domain crossing component is really nothing more than a
<a href="/blog/2018/07/06/afifo.html">traditional asynchronous
FIFO</a>.
The “packet” getting placed into this FIFO consisted of a 4-byte header
containing the packet’s length, followed by a payload containing as many
words as were required to capture the rest of the number of bytes requested
in the header.</p>
  </li>
  <li>
    <p>Once in the 125MHz domain, the length word is stripped from the packet,
and the packet payload is then broken down from 32-bit words to 8-bit
octets.</p>

    <p>The 32-bit word size turns out to be convenient for both assembling the
packet, as well as making sure that packet generated using a 100MHz clock
can keep the network busy on every clock cycle of a 125MHz clock.</p>
  </li>
  <li>
    <p>Finally, the packet goes through an arbiter that selects one packet request
   at a time, from among several potential packet sources, to forward to the
   network core.</p>
  </li>
  <li>
    <p>The network core then adds a MAC address.  (See Fig. 11)</p>
  </li>
  <li>
    <p>The network core then pads the packet to a minimum of 64 bytes</p>
  </li>
  <li>
    <p>A CRC is then added to the end of the packet, and</p>
  </li>
  <li>
    <p>A preamble is added to the beginning of the packet.</p>
  </li>
  <li>
    <p>The packet then travels the network.</p>
  </li>
</ol>

<p>In general, there’s one module for each of these steps, and most of these
modules have been formally verified.  There were two notable exceptions to this
rule.</p>

<p>The first exception was that the initial packet assembly, where we added
configuration information and timestamps.  Just before I left, I had narrowed
down a bug to this logic, as shown in Fig. 13 below.</p>

<table align="center" style="float: none"><caption>Fig. 13, Chasing bugs in hardware</caption><tr><td><img src="/img/proto-bringup/bugchasing.svg" alt="" width="780" /></td></tr></table>

<p>At the time, this packet assembly logic wasn’t located in a separate module but
rather in a module containing other modules.  As such, it hadn’t been formally
verified.  Just before leaving, I had traced a nasty bug to this module,
as shown in Fig. 13 above.  That was enough to split the remaining processing
logic into a separate module for formal verification.  Once separated, this
processing module then became easy to verify.</p>

<p>Unfortunately, the bugs in the RxCHAIN weren’t the last bugs in the system.
Another bug appeared in <code class="language-plaintext highlighter-rouge">pkt2udp</code>.  Once I had formally verified (and fixed)
the receive chain, this <code class="language-plaintext highlighter-rouge">pkt2udp</code> module was the only one left in the chain
that hadn’t been formally verified.</p>

<p>What did <code class="language-plaintext highlighter-rouge">pkt2udp</code> do?  This was the component responsible for turning a
sensor data packet into a
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> packet.</p>

<p>Frankly, I didn’t trust this module at all.  It felt like I kept tracing bugs
into the module, but could never find their cause.</p>

<table align="center" style="float: none"><caption>Fig. 14, The Circular Buffer</caption><tr><td><img src="/img/proto-bringup/linked-list.svg" alt="" width="480" /></td></tr></table>

<p>For some more background, understand that this component’s operation centered
around the circular buffer, shown in Fig. 14 above.  (A ping-pong buffer pair
would’ve been easier to verify.)  Within this buffer, the first 32-bit word of
every packet in the buffer was to contain the length of the packet that would
follow.</p>

<p>Writing to this buffer meant:</p>

<ol>
  <li>
    <p>Clearing the packet length field.  This was usually done as part of
writing the previous packet to memory, but on reset it might need to
be cleared manually.</p>
  </li>
  <li>
    <p>Write data into the buffer, counting how much data gets inserted</p>
  </li>
  <li>
    <p><a href="/blog/2022/02/23/axis-abort.html">Abort (drop)</a>
the packet if 1) the source
<a href="/blog/2022/02/23/axis-abort.html">aborts</a>
aborts, or 2) if the one packet uses (or will use) the entire memory buffer.</p>
  </li>
  <li>
    <p>Once the packet is complete, write a zero to the field following.  This
will become the length field of the next packet.</p>
  </li>
  <li>
    <p>Then go back and write the finished packet length into the buffer</p>
  </li>
  <li>
    <p>Finally, move the write-packet boundary forward in the buffer.  Our packet
has now been committed to the output stream.  It now has a reserved location
in RAM.  It won’t be dropped from this point forward.</p>
  </li>
</ol>

<p>The key to all this processing is the length field.  A zero length means there
is no packet present.  Once a packet was committed, the length of that
(now committed) packet would be updated in memory once we guaranteed that the
next packet’s length field was set to zero.</p>

<p>If at any time during this process there wasn’t enough room in the buffer for
the packet, the packet needed to be
<a href="/blog/2022/02/23/axis-abort.html">dropped</a>.  There were two
parts to this.  First, if the packet filled the entire memory and there still
wasn’t enough memory to finish the packet, then the packet would be
<a href="/blog/2022/02/23/axis-abort.html">dropped</a> internally.
The source would never be the wiser.  This keeps the routine from locking up
on an over-long packet.  Second, the incoming packet would stall if the
writer ever ran out of memory between the write and read pointers.  If it
stalled for too long, the packet source might also <a href="/blog/2022/02/23/axis-abort.html">abort the
packet</a>–once it couldn’t
stall any longer.  (Remember, data is coming in at a constant rate.  It must
either go somewhere, or get dropped if the system can’t handle it.  You cannot
stall indefinitely, neither can we allow partially completed packets to move
forward.)</p>

<p>The read side of this process was simple enough as well: You’d read from the
first word where the last packet left off.  While that word read zero,
the reader would stay put and just keep reading that length word.  Once the
length word became non-zero, the reader would start reading the packet out,
by reading and then forwarding the packet’s data.</p>

<p>I’m sure most of you will recognize this structure as a basic
<a href="https://en.wikipedia.org/wiki/Linked_list">linked list</a>.  The
biggest differences between this
<a href="https://en.wikipedia.org/wiki/Linked_list">linked list</a>
and the ones you find more often in software are 1) the wrapping memory, and
the fact that the “pointers” in this case were lengths, rather than true
pointers, and 2) in hardware, you have to deal with timing and timing cycles.
These are minor differences, though: it’s still a basic
<a href="https://en.wikipedia.org/wiki/Linked_list">linked list</a>:
the first word in a packet gives the packet’s length, and therefore points
to the first word, the length word, in the next packet.</p>

<p>Indeed, the operation of this IP is all quite straight-forward, but I had
no end of trouble with this design.  It got so bad at one point that I even
(gasp!) built a Verilog
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
to bench test it.  That bench test was
<em>really</em> hard to get right, too.  I spent a half day toggling between
assuming that the reader would accept packets out at full speed, or that it
would accept them at quarter speed, only able to get one of the two speeds
working depending on how I set the <em>M_AXIN_READY</em> input.  While I eventually
found that bug, it wasn’t really enough.</p>

<p>What the design needed was to be formally verified.</p>

<p>Why wasn’t it formally verified?  How was it that I had gone so long without
formally verifying this critical component?</p>

<p>The simple answer is that I couldn’t figure out how to go about formally
verifying a
<a href="https://en.wikipedia.org/wiki/Linked_list">linked list</a>.</p>

<p>As a result, I was now on an <a href="https://www.amtrak.com/auto-train">Amtrak train</a>
headed for hardware bringup with a known bug in my digital logic design.  Using
my own <a href="/blog/2017/06/08/simple-scope.html">internal logic
analyzer</a>,
I had caught this bug in hardware just before leaving.  What I discovered 
is illustrated in Fig. 15 below.</p>

<table align="center" style="float: none"><caption>Fig. 15, The linked list, now corrupted</caption><tr><td><img src="/img/proto-bringup/broken-links.svg" alt="" width="480" /></td></tr></table>

<p>I should point out that I only discovered this via <a href="/blog/2017/06/08/simple-scope.html">the internal
logic analyzer</a>.  I’m
not sure I would’ve known where to look without it.  While the <a href="/blog/2017/06/08/simple-scope.html">internal logic
analyzer</a> told me where
the design was stuck, however, it didn’t tell me how it got stuck in the first
place.</p>

<p>Here at least I knew that, due
to some unknown condition, the read pointer would be reading a zero
length packet somewhere in memory (meaning that there was no packet present),
all while the write half of the module was working on a packet elsewhere.
The design would be locked up, never to go again.  However, while I could
discover this much using <a href="/blog/2017/07/08/getting-started-with-wbscope.html">my
scope</a>,
I couldn’t figure out <em>how</em> the design ever got into this configuration.
<em>This wasn’t supposed to happen!</em>.</p>

<p>Therefore, on the train, I decided to try the following approach to formally
verifying this linked list chain:</p>

<ol>
  <li>
    <p>I would allow the formal tool to select two arbitrary memory locations.</p>
  </li>
  <li>
    <p>I would start tracking these two locations as soon as the first location
pointed to the second one.  If it never pointed at the second location,
I’d never track what happened next.</p>

    <p>A formal-only state machine’s state register would note that I was
tracking a packet existing between these two pointer addresses.</p>
  </li>
  <li>
    <p>I then tracked these two addresses, and their values, until the read
pointer pointed at the first of these two locations, so that it would
start reading out the packet.  Frankly, I didn’t need to go farther: I
had the read tracking logic working in my formal proof already.  I just
needed to get to this point where I could guarantee that the read pointer
would be given the right data.</p>
  </li>
  <li>
    <p>I also formally verified particular properties of these two locations:
1) The first address, plus the length contained at that address, had to point
at the second address.  2) The writer could be active starting at the second
address, but never between the two.  2) The packet length was at least a
minimum packet length, and always less than the full memory size, and so on.</p>
  </li>
  <li>
    <p>For all other linked list pointer-pairs within the design that the formal
tool might encounter, I <em>assumed</em> these properties.</p>
  </li>
</ol>

<p>Once I had this plan in mind, I was then able to formally verify the packet to
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
module.  What I discovered was a strange corner case: If
the source <a href="/blog/2022/02/23/axis-abort.html">aborted</a>
the packet just at the exact same clock cycle that the
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
packet assembler completed it, a zero length word would be written to the
packet’s length word, and the writer would move on to the next packet.</p>

<p>Just to see what’s going on, here’s what the original packet assembly
logic looked like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">case</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="c1">// ... assemble the parts and pieces of the packet together</span>
		<span class="k">endcase</span>

		<span class="c1">// On either an external or internal abort ...</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_AXIN_ABORT</span> <span class="o">||</span> <span class="n">abort_packet</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// Write the null pointer back to the first address</span>
			<span class="c1">// of memory</span>
			<span class="n">mem_wr</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span> <span class="c1">// Write to memory</span>
			<span class="n">mem_waddr</span> <span class="o">&lt;=</span> <span class="n">next_start_of_packet</span><span class="p">;</span>
			<span class="n">mem_wdata</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">state</span> <span class="o">&lt;=</span> <span class="n">S_IDLE</span><span class="p">;</span>
		<span class="k">end</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RESETN</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// Reset stuffs</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>The problem here is, what happens if the packet is already fully assembled
when the <a href="/blog/2022/02/23/axis-abort.html">abort</a>
signal is received?  We were then going to write the length
of this packet and set the packet start address to the next start of packet
address.  The <a href="/blog/2022/02/23/axis-abort.html">abort</a>
condition would override that write, causing us to write
a null pointer which would then cause the reader to freeze waiting.</p>

<p>And here’s the corrected condition:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">case</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="c1">// ... assemble the parts and pieces of the packet together</span>
		<span class="k">endcase</span>

		<span class="c1">// On either an external or internal abort ...</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">S_AXIN_ABORT</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">&lt;=</span> <span class="n">S_PAYLOAD</span><span class="p">)</span> <span class="o">||</span> <span class="n">abort_packet</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// ...</span></code></pre></figure>

<p>Notice how, this time, the packet is only
<a href="/blog/2022/02/23/axis-abort.html">aborted</a>
if it hasn’t been completed.  That is, we don’t
<a href="/blog/2022/02/23/axis-abort.html">abort</a>
after we’ve received the full <em>payload</em> of the packet.  Once the payload has
been completed, we do nothing more with the
<a href="/blog/2022/02/23/axis-abort.html">abort</a> logic.</p>

<p>In the end, it only took between 4-6 hrs on the train to fully verify this
packet to <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
bridge.  That’s 4-6 hrs compared to the last several weeks where
I was dealing with this bug on and off depending on the conditions within the
design, depending on when the hardware switched from 10Mb mode to 1GbE mode,
and so forth.  Worse, during those weeks, I could never quite pin the bug
down to one module, so it really required formally verifying everything else
to get to the point where I could isolate this bug to this module.</p>

<p>Now, at least, I had found the bug.  Even better, I now had confidence that
this last unverified portion of my design would work as intended.  I just had
nowhere to assemble the hardware to test it until the team was assembled
on Monday morning.</p>

<h2 id="bringup-bugs-found">Bringup Bugs Found</h2>

<p>So, once Monday morning came around, I joined the team at the test site.
I plugged in the hardware and my newly verified packet to
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
converter “just worked” like a champ.</p>

<p>Instead, I had two other bugs to deal with.  (These weren’t the first bugs
of the day, either–those were in the circuitry elsewhere and not my digital
logic.)</p>

<p>The first was associated with a weird corner case.  The network hardware is
designed to start up in 10Mb Ethernet mode.  It then senses whether or not the
cable is capable of 100Mb or 1Gb Ethernet.  Once that sensing is complete, the
network hardware will switch modes.  My design, however, only checks and
changes speed between packets.</p>

<p>What happens, then, when the <a href="https://en.wikipedia.org/wiki/Sonar">SONAR</a>
receiver starts assembling data into packets
and then attempts to blast so much data across the network that there’s never
a rest between packets for the network controller to use to change speed in?</p>

<p>What happens is that the network controller gets so stuck that the debugging
packets can’t get through.  Without the debugging packets, it was impossible
to send (via the network debugging port) a command to halt the packet
generation.  It’s a classic chicken-and-egg problem.</p>

<p>For the time being, I could get around this bug easily enough by turning the
receive data handling off (via
<a href="/blog/2017/06/05/wb-bridge-overview.html">UART</a>),
letting the network adjust, and then
turning it back on again.  By the Tuesday morning (Day #2) I had a more
permanent fix for this in place, whereby the data packet generation wouldn’t
start until the network was in high speed 1Gb/s mode.  Indeed, after the
second morning, I never needed the <a href="/blog/2017/06/05/wb-bridge-overview.html">UART debug bus backup
port</a>
again–it was all network control after that.</p>

<p>It was the second problem that was more of a hassle that first day.</p>

<p>For background, remember that this is the first time my FPGA logic was
connected to hardware on this project.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig. 16, SPI Controller Self-Test Setup</caption><tr><td><img src="/img/proto-bringup/miso.svg" alt="" width="360" /></td></tr></table>

<p>When the receive processing logic was first checked out years ago,
I had two potential test sources, as shown in Fig. 16.</p>

<p>The first was an emulated A/D inside my design, which I could use as a source
if I needed one and had no hardware.  This emulated A/D consisted of a series of
<a href="/dsp/2017/08/30/cordic.html">CORDICs</a>, each generating
a sine wave at a different frequency and amplitude, but all of them phase
aligned.  The result was then
encoded appropriately to match what the A/D output would be–it became the
“MISO” input from an emulated A/D.  As a result, if you ever plotted the
receive waveform from this artificial test source, you’d see some easily
recognizable signals.</p>

<p>For this project, however, I had decided that the emulated source was probably
overkill.</p>

<p>Instead, I used the second test source configuration in the A/D controller.
This test source would replace whatever was actually read by the A/D with a
counter and the channel number.  I could then follow this incrementing counter
through my processing chain to make certain that no data was ever dropped.
This project now marked the second time I’d used this counter approach.  The
first time, on the original receiver project, I <em>automatically</em> verified that
there were never any breaks in the counter when the results were finally
received by the software processor.  This time, however, I just looked at a
couple of packets in hex, by eye, to verify there were no packet breaks.</p>

<p>So, now, with the whole team assembled, we connected a signal generator to the
A/D input.  The <a href="/dsp/2019/12/21/histogram.html">histogram</a>
of the output looked wonderful, so I figured everything was good–up until we
all looked at the waveform.  Instead of a sine wave, we got something like
Fig. 17.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig. 17, Corrupted Sinewave</caption><tr><td><img src="/img/proto-bringup/corrupted-sinewav.png" alt="" width="640" /></td></tr></table>

<p>In this figure, you’ll notice discontinuities in the sine wave.  As a
hypothesis test, I’ve placed vertical bars every 18 samples.  You’ll notice
that these vertical bars land right on those discontinuities–every 18 samples.</p>

<p>At one point, we tried increasing the amplitude.  We got something worse,
as shown in Fig. 18.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig. 18, The corruption only gets worse as the volume goes up</caption><tr><td><img src="/img/proto-bringup/corrupted-capture.png" alt="" width="640" /></td></tr></table>

<p>Let’s start with what we know.  Sudden breaks in what should be a smooth
waveform sound like samples that are getting dropped somewhere.
So, I checked for lost samples.  I turned on the counter injection at the
source, as shown in Fig. 16, and then had my packet software dump the data in
hex so I could check for lost samples.</p>

<p>There were no lost samples.</p>

<p>I was confused.  That first day of testing ended in frustration.</p>

<p>On my way out the door, however, another teammate suggested based upon the
frequency we were measuring that I was dropping exactly 6 of every 24 samples.
As it turned out, that was just the help I needed to find the bug.</p>

<p>Surprise!  The dropped samples bug wasn’t in my hardware at all.</p>

<p>The network packets were arriving at their destination without error, and
without any dropped packets.  I had verified by eye that nothing was getting
dropped.  That wasn’t the bug.</p>

<p>No, the bug was in my latest rewrite of the packet handling <em>software</em>, the
same software that both collected packets and converted them to a text file
so that <a href="https://www.gnu.org/software/octave">Octave</a>
could ingest them.  As of the latest <code class="language-plaintext highlighter-rouge">rx_genpkt</code> rewrite, I had run out of
meta-data room to stuff the number of samples per packet in the header.
Instead, the software would simply know this value as a shared
constant.  My problem was, when re-writing this software, I looked up the
packet size from a <a href="/blog/2017/07/31/vcd.html">VCD</a>
trace, shown in <a href="https://gtkwave.sourceforge.net">GTKWave</a>, and generated via
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
just to be sure I got it right.  I read
that there were 0x18 samples per packet, and then wrote the software to read
out 18 samples per packet–dropping six samples from every data packet in the
process.  (Did you notice the accidental hexadecimal to decimal unit change?)</p>

<p>That fixed the discontinuities in Fig. 17.  What about the additional
discontinuities in Fig. 18?
Those discontinuities came because, surprise, surprise, I was now using Xilinx
hardware instead of ~ALtera~ Intel hardware.  I had also changed the front end.
The receive wavefoms were running though some IDDR elements and there was an
additional delay in when the MISO were returned to my controller.  As a
result, I was sampling the bits from the A/D on the wrong clock cycle.  This
was easily found (and fixed) using my <a href="/blog/2017/06/08/simple-scope.html">internal
logic analyzer</a>.
I’m not sure how I would’ve found this delay otherwise.</p>

<p>Needless to say, by Tuesday morning I had a parameter in the design allowing
me to adjust the capture delay by eye, and I was able to adjust it so
that it now captured in the center of the bit.</p>

<p>Fig’s 17 and 18 show one more bug in them, most obvious in Fig. 17: the
sine wave wasn’t uniformly smooth between its positive and negative half
sides.  This one wasn’t my fault.  Instead, we traced it to a mis-configuration
in the function generator we were using to generate the sinewave in the first
place.  We had it set to clip the negative half of the waveform–although
this was more obvious when we ran a triangle wave through the system (not shown
above).</p>

<p>These three bugs ended up being my last show stopping bug for the week.  The
rest of the week everything I had written “just worked” like I wanted.
(Don’t worry, we’re not superhumans, we still had other bugs to chase down …
there just weren’t any more of them in the digital logic.  Or, to be more
exact, there weren’t any more bugs in the digital logic <em>that any one else
noticed</em>.)</p>

<h2 id="sudden-new-capabilities">Sudden New Capabilities</h2>

<p>There’s one more story worth telling from this week.</p>

<p>As I’m sure you can imagine, this being the first time the team was assembled,
things didn’t go as smoothly as everyone had planned.  I wasn’t the only
engineer in the team with faults that needed to be chased down.  In particular,
we were chasing down some hardware faults in the transmitter on Thursday.
Things weren’t working, and we weren’t certain why.</p>

<p>The team then asked me if it would be possible to transmit from only one of
the transmitters on this device.</p>

<p>That wasn’t a request I was expecting.  Nowhere in the requirements did it
say that I needed to be able to transmit onto a selectable subset of the
<a href="https://en.wikipedia.org/wiki/Transducer">transducers</a>
controlled by the device.</p>

<p>In general, adding a capability like this sounds pretty easy.  All you need
to do is to take the output data and mask it with a register telling you
which transmitters are “on” and which ones are not.  The fix, in Verilog,
was just about as simple as inserting the following lines of logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">for</span><span class="p">(</span><span class="n">gk</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">gk</span><span class="o">&lt;</span><span class="n">NUM_SONAR_ELEMENTS</span><span class="p">;</span> <span class="n">gk</span><span class="o">=</span><span class="n">gk</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">ADD_ENABLES</span>

		<span class="k">initial</span>	<span class="n">o_tx_control</span><span class="p">[</span><span class="n">gk</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// This is an FPGA, initial works</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_enabled</span><span class="p">[</span><span class="n">gk</span><span class="p">])</span>
			<span class="n">o_tx_control</span><span class="p">[</span><span class="n">gk</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">o_tx_control</span><span class="p">[</span><span class="n">gk</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">int_tx_control</span><span class="p">[</span><span class="n">gk</span><span class="p">];</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>That was the easy part.</p>

<p>Now let’s put this problem into a broader context: This design has a
<a href="/about/zipcpu.html">ZipCPU</a>, memory,
many controllers,
<a href="/blog/2017/06/08/simple-scope.html">scopes</a>,
etc.  Every peripheral within the design has its own <a href="/zipcpu/2019/09/03/address-assignment.html">address
assignments</a>.
There’s also an
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>, the
responsible for routing requests from their sources to the peripherals being
referenced.  Putting something new like this together will require allocating
a new address for a new peripheral register.  That peripheral will then need
to be added to the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>, the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
will need to be reconfigured for the <a href="/zipcpu/2019/09/03/address-assignment.html">new address
map</a>, and
then all the software will need to be adjusted for any addresses that had to
change during this process and so on.</p>

<p>That’s a lot of work.</p>

<p>Oh, and did I mention I wasn’t using Vivado’s IP integrator?  Nor was I using
their AXI <a href="/blog/2019/07/17/crossbar.html">interconnect</a>?
(I was using <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.
I could’ve used AXI, I just chose not to.)</p>

<p>Using <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>, we had all this work
done in less than a half an hour.  When you consider that Vivado took about
half of that time for synthesis and implementation (I wasn’t counting at the
time), this may be even more impressive.</p>

<h2 id="audio-and-video">Audio and Video</h2>

<p>In the end, neither the brand new audio nor the video capabilities were tested
during this bringup week.  That’s kind of a shame, so I figured I’d at least
discuss some pictures of what the video might look like in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.</p>

<p>Fig. 4, back in the beginning of the article, shows one such falling raster.
In this figure, frequency goes from left to right, and the displayed image
scrolls from the top down.  The source is an artificially
generated test tone, generated internal to the system.  At several points
during the
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
I adjusted the tone’s frequency, and you can see these adjustments in the image.</p>

<p>Similarly, Fig. 5 shows a split screen, with a trace on top and the falling
raster below.  Note how the frequency axes are identical, so that the trace
sits nicely on top of the raster, with the raster showing how the trace had
adjusted over time.</p>

<p>I suppose it’s a good thing the video outputs didn’t get tested.  They didn’t
work in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
until the end of the week.  Below, for example, is a bug
that locked up the Video source selector.  (Remember, I had five video sources,
each generating video signals, and so I need a selector in the system somewhere
to select between which one would be displayed.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID</span> <span class="o">||</span> <span class="p">(</span><span class="n">HLAST</span> <span class="o">&amp;&amp;</span> <span class="n">VLAST</span><span class="p">))</span></code></pre></figure>

<p>This was just a <a href="/blog/2021/08/28/axi-rules.html">basic AXI
bug</a>.  The correct
condition should have read:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID</span> <span class="o">||</span> <span class="n">READY</span><span class="p">)</span></code></pre></figure>

<p>This is just a <a href="/blog/2021/08/28/axi-rules.html">basic AXI stream handling
rule</a>.  I should’ve known
better, and so I’m kicking myself for having made it.  The good news, of
course, is that this bug was easily found with just a touch of formal methods.</p>

<p>Perhaps I’ll have a chance to show off these (now working) video capabilities
during our next hardware test.</p>

<h2 id="conclusions">Conclusions</h2>

<p>So, what can we learn from the week and the preparation leading up to it?
Let’s see if we can draw some conclusions.</p>

<ol>
  <li>
    <p>Expect failures–even in hardware.  Plan for them.  Give yourself time,
ahead of time, to find and fix failures.</p>

    <p>While it sounds weird, I like to put it as, “Fail early, fail often.”</p>
  </li>
  <li>
    <p><a href="/blog/2018/08/22/what-is-simulation.html">Simulate</a> all
major interfaces!  I lost a lot of preparation time believing that my
network interfaces “just worked”, simply because I hadn’t bit the bullet and
built a proper network
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
model first.  Once I had that model, debugging the network got easy, and
my bug-to-fix times got a lot faster.</p>
  </li>
  <li>
    <p>For all of my simulation work using the packet to
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> converter,
nothing managed to catch the actual bugs I was encountering in hardware.
I would’ve had to trigger the 
<a href="/blog/2022/02/23/axis-abort.html">abort</a> on just the
right input sample to trigger this, and I had no idea (before finding the
bug using formal methods) how I might’ve set up the simulation to stimulate
the bug.</p>
  </li>
  <li>
    <p>It’s a lot easier to find bugs using formal methods than it is to <a href="/blog/2017/06/02/design-process.html">find
them in hardware</a>.</p>
  </li>
  <li>
    <p>Frankly, if it’s not been formally verified, I don’t trust it.  Remember
Fig. 13?  The last two items in that processing chain to get formally
verified were the last two items with bugs in them.  Of those two, the one
item that was the hardest to formally verify turned out to be the last item
in the design with a difficult bug to chase down.  Once formally verified,
however, it worked like a charm.</p>

    <p>This isn’t to say that every formally verified module <a href="/formal/2020/06/12/four-keys.html">worked the first
time</a>.  Rather, not
every formal proof I ran was sufficient to guarantee proper functionality
the first time.  The proofs got better the longer I worked with each of the
individual components of the design.</p>
  </li>
  <li>
    <p>Yes, it is possible to formally verify a linked list.  I wish I had
formally verified the <em>pkt2udp</em> module earlier–it would’ve saved me a lot
of head scratching during the weeks leading up to my travels.</p>
  </li>
  <li>
    <p>Document your interfaces!</p>
  </li>
  <li>
    <p>The sooner you move to the “staging” area, the sooner you can debug your
chosen travel hardware.</p>
  </li>
  <li>
    <p>Plan early on for how you will debug a design.  Adding the (unused) Audio
and Video capability into the design late in the game took a lot of my
time and – we never got to testing either of those interfaces.  (We
might’ve started testing with them sooner, if I arrived with more confidence
in their functionality–but that’s another story.)</p>
  </li>
  <li>
    <p>With a little focus, you can get a lot of work done on <a href="https://www.amtrak.com/auto-train">Amtrak’s auto
   train</a>, while still bringing whatever
   hardware you might need.</p>
  </li>
  <li>
    <p>While I didn’t discuss this one above, here was another lesson learned: If
   you have a complicated condition, and two or more things depend upon it,
   create a common signal to capture that condition for both pieces of logic.
   In my case, I had a condition for when a received packet should be generated.
   That condition was repeated in two different locations of the same module.
   Among other things, it checked how much space was available in the buffer.
   I then updated the condition to help guarantee sufficient space was
   available, but only updated it in one location–not both.</p>
  </li>
</ol>

<p>This was the bug in Fig. 13, and one I found when I finally formally
   verified the data packet generator.</p>

<ol>
  <li>
    <p>Looking over all the bugs I found, I seem to have traced several to the
   boundaries between formally verified components–at a place where things
   weren’t verified.  I’ll have to think about this some more.</p>
  </li>
  <li>
    <p>Finally, while I can be critical of others making basic mistakes, I made
   plenty myself.  I think the worst one I found was checking for
   <code class="language-plaintext highlighter-rouge">!VALID || VALID</code> when what I wanted to be checking for was
   <code class="language-plaintext highlighter-rouge">!VALID || READY</code>.</p>
  </li>
</ol>

<p>Let me leave you with a final thought from the first verses of Psalm one,
a Psalm I’ve started to make a habit of reciting to myself on trips like
this one:</p>

<blockquote>
  <p>Blessed is the man that walketh not in the counsel of the ungodly, nor
  standeth in the way of sinners, nor sitteth in the seat of the scornful. 
But his delight is in the law of the LORD; and in his law doth he meditate
  day and night. 
And he shall be like a tree planted by the rivers of water, that bringeth
  forth his fruit in his season; his leaf also shall not wither; and
  whatsoever he doeth shall prosper.</p>

  <p><a href="https://www.blueletterbible.org/kjv/psa/1">Ps 1:1-3</a></p>
</blockquote>

<p>May God bless you all.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And unto Adam he said, Because thou hast hearkened unto the voice of thy wife, and hast eaten of the tree, of which I commanded thee, saying, Thou shalt not eat of it: cursed is the ground for thy sake; in sorrow shalt thou eat of it all the days of thy life (Gen 3:17)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
