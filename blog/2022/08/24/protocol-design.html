<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Protocol Design for Network Debugging</title>
  <meta name="description" content="What do you do when you needTCP,but don’t have it?">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2022/08/24/protocol-design.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Protocol Design for Network Debugging</h1>
    <p class="post-meta"><time datetime="2022-08-24T00:00:00-04:00" itemprop="datePublished">Aug 24, 2022</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>What do you do when you need
<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>,
but don’t have it?</p>

<p>Let me back up and set the stage a bit more.  I’m working with what will be
an underwater design, as shown in Fig. 1.</p>

<table align="center" style="float: none"><caption>Fig 1. Controlling an Underwater FPGA</caption><tr><td><img src="/img/netbus/sysdesign.svg" alt="" width="780" /></td></tr></table>

<p>For those who haven’t figured it out, this will (eventually) form the basis of
a SONAR device.</p>

<p>At first, this problem seems simple enough: there will be an FPGA device
controlled via a network port.  Easy, got it.  Better yet, what’s the easiest
network protocol to use?
<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>.  Open
Source <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>,
software stacks aren’t all that hard to write, and I know there are several
open source stacks that are easy enough to use.  (No, I’ve never written one
myself …)</p>

<p>But, let’s dig a little deeper: I want to be able to control and debug the
<a href="/about/zipcpu.html">CPU</a>
via the same network port.  That means I’ll want to be able to <a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">stop the CPU,
read its registers, adjust the contents in RAM, and then restart it
again</a> all
over the network.  Put another way, if the CPU software won’t be running at
all times, then I can’t implement
<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>
in software and still debug the CPU using the same
<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>
stack.  Worse, what if the FPGA firmware can’t be trusted?
Now things are getting a bit more challenging.  How shall a piece of broken
FPGA firmware be updated without using software on the FPGA board?</p>

<p>This, then, is where this problem starts.</p>

<p>At the most basic level, any FPGA design can be halted and updated via the JTAG
port.  Most vendor designs will allow for that.  However, in this design, that
JTAG port will be quite literally underwater.  The only way to access it will
be to bring the entire unit back out of the water, to dry off the chassis the
FPGA board sits within, and then to uncap the JTAG port and access it.  This
is the insurance policy for the project–guaranteeing that the chassis the
hardware sits within will not need to be opened except in extreme circumstances.</p>

<table align="center" style="float: right"><caption>Fig 2. Reconfiguring a running FPGA</caption><tr><td><img src="/img/netbus/reconfig-plan.svg" alt="" width="360" /></td></tr></table>

<p>That’s not, however, going to be the normal mode of operation.  Normally, upon
application of power, this design will need to automatically start up and then
do something to allow itself to be updated.  This can be done via an
Internal Configuration and Access Port (ICAP) found within the FPGA itself.
If a second design configuration can be written to the
<a href="/blog/2019/03/27/qflexpress.html">flash</a>,
the ICAP port can then be told to tell the FPGA to reconfigure itself from
this second configuration location.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 3. Basic outline of a UART protocol to control a Wishbone Bus</caption><tr><td><img src="/img/wb-uart-ovw.svg" alt="" width="360" /></td></tr></table>

<p>Normally, I handle this sort of problem within my designs using a <a href="/formal/2019/02/21/txuart.html">serial
port</a>
together with what I call a “debugging bus”: a protocol, running over
that <a href="/formal/2019/02/21/txuart.html">serial port</a>,
that allows me to read from or write to any address on the bus within the FPGA.
<a href="/blog/2017/06/05/wb-bridge-overview.html">We’ve discussed this protocol
before</a>, and for
reference you can see the basic components of this protocol in Fig. 3 on the
left: Commands are grouped into words, decompressed, placed into a FIFO, and
then those commands are used to control the bus.  Bus returns then come back.
Reset acknowledgments and interrupts get added to the return stream, which is
then compressed and split back into bytes before being returned across the
<a href="/formal/2019/02/21/txuart.html">serial port</a>.
In general, this works great, and I’ve used this approach for years.
Even better, having full bus access makes it really easy to debug the FPGA–as
long as you can guarantee that neither the debugging bus protocol nor the bus
itself will fail on you.</p>

<p>That’s great for a
<a href="/formal/2019/02/21/txuart.html">serial port</a> protocol,
where character’s aren’t (generally) lost and where messages don’t
accidentally get repeated.</p>

<p>But what about a network protocol?</p>

<p>Today’s discussion, then, will discuss a network protocol which can be used
to do this same thing, but with an interface simple enough that it can be
implemented in an FPGA.</p>

<h2 id="understanding-the-problem">Understanding the Problem</h2>

<p>Let’s back up, therefore, and take a moment to understand the goal and purpose
of this protocol together with some of what makes the networking environment
unique.  This will lead us to an understanding of some of the problems
involved that will need to be handled by this protocol.</p>

<h3 id="all-network-traffic-takes-place-in-packets">All network traffic takes place in packets</h3>

<p>The first rule of networks is that all communication takes place in packets.
Even better, since we’ll be using Ethernet, <a href="https://en.wikipedia.org/wiki/Ethernet_frame">every Ethernet
packet</a>
ends in a four byte <a href="https://en.wikipedia.org/wiki/Frame_check_sequence">Frame Check
Sequence</a>
based upon a <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Cyclic Redundancy Check
(CRC)</a>.  These four
bytes are produced by a function applied to the contents of the packet.  Then,
on reception, the receiving end can also calculate the same function.  If the
result matches the four-byte frame check sequence found in the packet, then
you can have some strong assurance that the packet was received across the
interface without error.</p>

<h3 id="packets-may-be-lost">Packets may be lost</h3>

<p>Here’s our first problem: if something goes wrong on the network–perhaps
there’s too much congestion somewhere, perhaps the FPGA is still responding to
some other packet, then a packet may be dropped.  Indeed, <a href="/blog/2022/02/23/axis-abort.html">we discussed this
sort of idea</a> quite
recently.  In network implementations, dropped packets are considered a
“normal” phenomena, and any protocol working across the network needs to be
able to recover from a lost packet.</p>

<p>Think this through a bit, since this can be a real problem.  What happens if
the bus within the FPGA locks up because some peripheral isn’t responding?
In the worst case, all following packets will be lost–to include any
packets telling the FPGA to reset itself.  This is a real possibility that
we’ll need to consider as things go on.</p>

<h3 id="packets-may-be-repeated">Packets may be repeated</h3>

<p>The next problem is that packets may be repeated.</p>

<p>At first, I simply poo-pood this idea.  This would never happen in any of <em>my</em>
implementations, I told myself, because nothing in the network stack will ever
repeat a packet.</p>

<p>Then I got to thinking some more about this.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 4. Request/Reply protocol</caption><tr><td><img src="/img/netbus/reqreply.svg" alt="" width="360" /></td></tr></table>

<p>Imagine you have two computers talking to each other, and one computer (the
client) makes a request of the second (the server/FPGA).  If the request gets
dropped, how shall the first computer (the client) know it was dropped except
if it doesn’t get any response?  Worse, if the client doesn’t get any response,
does that mean 1) the server didn’t get the request, or 2) that the server did
get and process the request and the client just didn’t get the reply?  All the
client can do at this point is to just re-send and re-send its packet until
it eventually gets a reply.</p>

<p>Voila, repeated packets.  We’ll need to handle these somehow.</p>

<p>Now lets make matters even worse: some requests, such as commanding the
<a href="/blog/2019/03/27/qflexpress.html">flash</a>
device to erase a sector or to program a page, aren’t things you want to do
twice.  Any network based debugging protocol will therefore, of a necessity,
need to be able to properly handle duplicated packets.</p>

<h3 id="packets-may-arrive-out-of-order">Packets may arrive out of order</h3>

<p>Just to make things worse, not only may packets get dropped or repeated, they
might also arrive out of order.</p>

<h3 id="udpip-is-a-fairly-simple-protocol">UDP/IP is a fairly simple protocol</h3>

<p>One of the easiest protocols to implement in an FPGA is
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a>.  1) <a href="https://github.com/ZipCPU/zipversa/blob/6828a9e4ebe9032dbea6a51f1223b30a0fb980d7/sw/host/udpsocket.cpp#L130-L136">It’s easy
enough to program most computers to send UDP
packets</a>,
and 2) <a href="https://github.com/ZipCPU/zipversa/blob/6828a9e4ebe9032dbea6a51f1223b30a0fb980d7/sw/host/udpsocket.cpp#L156-L187">receiving UDP packets is relatively easy as
well</a>.
Even better, if implemented well, the <em>internet</em>
(the <a href="https://en.wikipedia.org/wiki/IPv4">IP</a> part) has some remarkable
capabilities to it: I might even be able to access this piece of underwater
hardware from the other side of the world if necessary.  On the FPGA side,
there are some challenges involved in implementing
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a>,
but the result is still fairly easy to accomplish.  Some of these challenges
include:</p>

<ol>
  <li>
    <p>The FPGA needs to know the Ethernet MAC address, IP address, and destination
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> port to send the
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a> packet to.</p>

    <p>These can often be copied from the source addresses found in the request,
so that’s not a big problem.</p>
  </li>
  <li>
    <p>Both <a href="https://en.wikipedia.org/wiki/IPv4">IP</a>
and <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
headers need to know the length of the rest of the
packet–possibly even before the rest of the packet has been formed.</p>
  </li>
  <li>
    <p>If <a href="https://en.wikipedia.org/wiki/IPv4">IP</a> header
and <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> payload
<a href="https://en.wikipedia.org/wiki/IPv4_header_checksum">checksums</a> are
implemented, these are also placed <em>prior</em> to the packet data.</p>
  </li>
</ol>

<p>This sort of necessitates that a packet be formed first and placed into
a temporary buffer, before being forwarded downstream.  Still, this is quite
doable.</p>

<p>The problem with <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a>,
however, is that it offers no protection against the problems listed above:
packets may still be dropped, duplicated, or arrive out of order.</p>

<h3 id="ip-packets-may-be-fragmented">IP packets may be fragmented</h3>

<p>If a packet is too big for some portion of the network, then whatever
intermediate node recognizes this is supposed to be able to split the packet
into multiple sub-packets (fragments).  These packets will then be reassembled
on the far end.</p>

<h3 id="tcpip-requires-memory">TCP/IP requires memory</h3>

<p>I’ve used <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a>
in the past.  In general, it’s always been one of my favorite
protocols to work with: it’s easy and reliable.  However, I’ve never had to
implement it before, neither have I ever tried to implement it on an FPGA.
When digging into what it would take to implement the
<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a>
within an FPGA, it doesn’t take long to learn that each connection will require
some amount of memory to work properly–perhaps as much as 64kB per connection.</p>

<ul>
  <li>
    <p>The connection setup defines the maximum and required sizes of this window</p>
  </li>
  <li>
    <p>Packet data includes where in the stream the data comes from</p>
  </li>
  <li>
    <p>Acknowledgments include the latest received stream position</p>
  </li>
</ul>

<p>Further, <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a>
removes packet boundaries in favor of transmitting stream positions.  In many
ways, though,
<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a>
might be the ideal way of encapsulating what was once a
<a href="/formal/2019/02/21/txuart.html">serial port</a> stream.</p>

<p>Others have made this protocol work on an FPGA, so I know it can be done.
In my review, however, I ended up balking at the idea of implementing my own
<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a>
protocol handling stack within FPGA logic.  (I’ll probabbly still place an
implemention of the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>/<a href="https://en.wikipedia.org/wiki/IPv4">IP</a>
stack within the
<a href="/about/zipcpu.html">CPU</a>
software before I’m done …)</p>

<h3 id="gbe-is-fast">GbE is fast</h3>

<p>From my experience, and with the boards I have, a
<a href="/formal/2019/02/21/txuart.html">serial port</a>
can typically achieve speeds somewhere between about 100kB/s (1MBaud) and
400kB/s (4MBaud).  Gigabit Ethernet, on the otherhand, can transfer data at
125MB/s.  That’s probably faster than I need for this part of the project.
The biggest impact this is likely to have, though, is that it might keep my
compression algorithm from working–since that algorithm only tries to
compress a response value as long as the return pipeline is stalled.  If the
link is so fast that it never stalls, then it might make sense to
remove the <a href="/formal/2019/02/21/txuart.html">serial port</a>
compression from this network re-implementation.</p>

<h3 id="the-goal">The Goal</h3>

<p>Just to make it clear, my goal is to be able to control the bus within an
FPGA design from a network interface.  This means I want to be able to read
from and write both peripheral registers as well as
<a href="/zipcpu/2018/07/13/memories.html">memory</a> and
<a href="/blog/2019/03/27/qflexpress.html">flash</a>.
Using this capability, I want to be able to do things like:</p>

<ol>
  <li>
    <p>Reading, erasing, programming, and verifying <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a> contents</p>
  </li>
  <li>
    <p>Issuing a warm boot request, so that the FPGA will reload itself from
a secondary location</p>
  </li>
  <li>
    <p>Configuring any application specific hardware from an external host.</p>

    <p>As one example, I’m hoping to control an <a href="https://www.analog.com/en/products/adau1761.html">ADAU1761 audio
chip</a>
on a <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications">Nexys Video board</a>.
The network bus should be able to turn this chip on, adjust which
channel(s) are selected, and any gain associated with the individual
channels.</p>

    <p>I expect to use a separate protocol to handle the return audio from such
a controller.  For now, I just want a dependable network protocol I can use
to guarantee my ability to configure this controller across the network in
the first place.</p>

    <p>This is a test-only capability, to allow an operator to “hear” any
internal signals while the device is still on the bench.  Once the device
is sealed up, similar circuitry within the device will be used to route
from among multiple potential signal sources and sinks to their ultimate
destinations.</p>
  </li>
  <li>
    <p>Without access to JTAG, I won’t have any vendor tools available for internal
logic analysis in order to diagnose any faults.  Instead, I’ll be using my
own <a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone
scope</a>
across this network protocol.</p>

    <p>This also means that I’ll want to assume only a bare minimum of design
functionality here.  What happens, for example, if I need to debug the
DDR3 SDRAM protocol?  In that case, I would need to be able to operate
this bus without access to any but internal FPGA memory.</p>
  </li>
  <li>
    <p><a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">Rebooting, pausing, stepping, and stopping or starting the CPU within the
design</a>.</p>
  </li>
  <li>
    <p><a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">Examining CPU
registers</a>
when the <a href="/about/zipcpu.html">CPU</a>
is halted, and perhaps adjusting their contents if necessary.</p>
  </li>
</ol>

<p>That’s my goal, and you now know the problems associated with working with the
network.  Now, knowing this information, what can we do in order to generate
some form of protocol that we can use?</p>

<h2 id="generating-a-protocol">Generating a Protocol</h2>

<p>Let’s take a moment to walk through the design of this new protocol, and the
various choices I made along the way to deal with the problems listed above.</p>

<table align="center" style="float: right"><caption>Fig 5. Encapsulating the former serial port protocol</caption><tr><td><img src="/img/netbus/netb-encapsulation.svg" alt="" width="240" /></td></tr></table>

<p>My first draft of this protocol, the draft I’ll be discussing today, simply
involved packetizing the requests I would’ve sent over the
<a href="/formal/2019/02/21/txuart.html">serial port</a> in the
first place.  That means these debugging bus packets simply include an
additional header on top of the headers already existing, together with a
set of bytes which would’ve normally been sent across a <a href="/formal/2019/02/21/txuart.html">serial
port</a>.  We’ll call this
the “NetBus header” and “serial port debugging bus payload” or just “payload”
for short.</p>

<p>My second (rather arbitrary) choice was to insist that all protocol
interactions take place in two parts: 1) the support software sends a request,
and 2) the FPGA returns a reply.  Moreover, as I alluded to above, <em>every</em>
request was to receive a reply.  Should a reply not be returned, that would
mean that either the FPGA either didn’t receive the request or that the
response hadn’t been received.  This also meant that the FPGA would never
initiate a transaction on its own, it would only ever respond to requests.</p>

<p>Incidentally, this also solves the problems associated with out of order
packets: if only one request is ever outstanding at a time, then there will
never be two or more packets to get reversed.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 6. Eight GPIO bits</caption><tr><td><img src="/img/netbus/gpio.svg" alt="" width="360" /></td></tr></table>

<p>One of the neat features of my serial port protocol was that it had a special
means of communicating
<a href="/zipcpu/2019/04/02/icontrol.html">interrupts</a> to the host
computer.  At one time I used this feature with my <a href="/blog/2019/03/27/qflexpress.html">original flash
controller</a>
to notify any programming software of the end of a write transaction.  This
was cool, but … perhaps we could expand upon it?  For example, it’d be nice
to get some status bits from the controller.  Such status bits might include
answers to questions like: Has the buffer within the controller ever suffered
from an overrun?  Has the controller received any bus error responses?  Is this
the first packet following a reset?  All of this together necessitated a set of
general purpose I/O bits that could be controlled via this protocol.  So far,
I’ve settled upon four of the eight bits shown in Fig. 6.  These would be
sticky bits when set, and only cleared upon a write from the external host.
Another four bits remain available for … whatever purpose.</p>

<p>I created this capability with two parts: a mask and a value.  That way,
any GPIO bit could be updated whose mask bit was set to the value it was set
to, allowing independent control of each of these bits.  Further, by setting
the mask to zero, the FPGA would simply ignore these bits.  Indeed, this I/O
part of the protocol is very similar to <a href="/zipcpu/2019/02/09/cpu-blinky.html">one we’ve discussed
before</a>.</p>

<p>My third choice was to place a stream packet ID number into the header of the
packet.  The FPGA can then use this ID to identify and handle repeated packets.
This way, should the FPGA ever detect a second request with the same frame
number, then it would simply repeat the response to the prior packet with
that frame number.</p>

<p>One stream ID was designated as special: ID=0.  This indicated a “Sync” packet
in this protocol.  This would be the ID I would use when initiating a
communication with the device.  I could then use this packet to record and set
the Ethernet MAC, IP address, and UDP port of the source, as well as to
reset the state of the internal compression engine to something that could
be known within the client program.  This way, upon starting a client program,
the client could quickly synchronize the two compression engines.</p>

<p>Further, the design should handle packets with an empty payload, as sort of a
“keep-alive” packet.</p>

<h3 id="request-packet-format">Request Packet Format</h3>

<p>These choices led me to the packet design for request packets shown in Fig. 7.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 7. Host to FPGA Packets</caption><tr><td><img src="/img/netbus/host-to-fpga.svg" alt="" width="760" /></td></tr></table>

<p>In general, the host only added four bytes to any payload.  The first two were
the packet ID.  This ID could be anything, with zero having the special meaning
discussed above, and the second requirement being that ID’s shouldn’t be
repeated in succession.</p>

<h3 id="reply-packet-format">Reply Packet Format</h3>

<p>The reverse link is very similar, if not almost identical.  There are only
a couple of differences.</p>

<table align="center" style="float: right"><caption>Fig 8. FPGA to Host Reply Packets</caption><tr><td><img src="/img/netbus/fpga-to-host.svg" alt="" width="760" /></td></tr></table>

<p>For example, all replies will include the host packet’s ID number so the host
can know which request is being replied to.  This will allow the host to
remove duplicate packets from the return stream.</p>

<p>Further, all replies will include sixteen general purpose I/O bits.  Eight of
these, <code class="language-plaintext highlighter-rouge">i_gpio</code>, are input bits collected from somewhere in the system–such as
the <a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>
bit.  Indeed, we discussed four of these bits above, while the other four
remain uncommitted.  The other eight bits, <code class="language-plaintext highlighter-rouge">o_gpio</code>, are a simply a
reflection of the current settings as generated by the last packet sent by the
host controller.</p>

<p>The next word, however, is generated within the FPGA logic.  The first
16-bit field of this word is the prior packet ID from the previous packet.  This
was chosen so that, in high speed situations, I might send two packets to the
FPGA and then have some assurance the FPGA had received both in case the
first response was dropped.  The next sixteen bits are simply a one-up packet
counter from the FPGA.  This counter would be increased on any sends or
re-sends, allowing the host to identify where, if at all, packets get lost
in this system.  Is it between the host and the FPGA, or on the return trip
from the FPGA to the host?</p>

<h3 id="building-the-clients-state-machine">Building the Client’s State Machine</h3>

<p>Before concluding, let’s take a quick look at what the host control
software would look like for this.  We’ll base this look upon a
<a href="https://github.com/ZipCPU/zipversa/blob/6828a9e4ebe9032dbea6a51f1223b30a0fb980d7/sw/host/udpsocket.cpp#L130-L136">UDPSOCKET</a>
implementation that encapsulates any issues of issuing packets to or receiving
packets from the O/S.</p>

<p>A couple of other fields will allow us to keep a copy of the last
received packet, or the packet we are getting ready to send.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">NETBUS</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="n">m_rdbuf</span><span class="p">[</span><span class="n">RDBUFLN</span><span class="p">],</span> <span class="n">m_pkt</span><span class="p">[</span><span class="n">TXBUFLEN</span><span class="p">];</span>
	<span class="n">UDPSOCKET</span>	<span class="o">*</span><span class="n">m_udp</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">m_rxlen</span><span class="p">,</span> <span class="n">m_frameid</span><span class="p">;</span>
	<span class="c1">// ...</span>
<span class="p">};</span></code></pre></figure>

<p>The first step, therefore, in communicating with this new FPGA protocol is
to establish a connection.  This is done by sending a sync packet.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>	<span class="n">NETBUS</span><span class="o">::</span><span class="n">sync</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">nrd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// Make up to MAXTRIES attempts to synchronize</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">tries</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="n">MAXTRIES</span> <span class="o">&amp;&amp;</span> <span class="n">nrd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tries</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Try sending a sync packet</span>

		<span class="c1">// Clear the 4-byte header, then send a packet of 4bytes only</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="n">m_pkt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="c1">// Turn this into a UDP packet and send it</span>
		<span class="n">m_udp</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">m_pkt</span><span class="p">);</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">m_udp-&gt;write</code> will call the system to actually send this across a UDP
port we’ve connected ourselves to.</p>

<p>The purpose of the for loop is so that, in the case that we don’t get any
response, we can try sending up to MAXTRIES of these packets.</p>

<p>The next step is to look for the return packet.  We’ll wait <code class="language-plaintext highlighter-rouge">PKT_TIMEOUT</code>
milliseconds for this return–using the poll() system call to implement this
timeout.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">nrd</span> <span class="o">=</span> <span class="n">m_udp</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">RDBUFLN</span><span class="p">,</span> <span class="n">m_rdbuf</span><span class="p">,</span> <span class="n">PKT_TIMEOUT</span><span class="p">);</span></code></pre></figure>

<p>Now that we have a return packet, let’s look for and assemble the packet ID.
If this ID is not zero, then this isn’t a response to our sync request.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">rxframe</span> <span class="o">=</span> <span class="p">((</span><span class="n">m_rdbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">m_rdbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nrd</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rxframe</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// This is a return from another request</span>
			<span class="c1">// Ignore it.</span>
			<span class="n">nrd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span></code></pre></figure>

<p>If after <code class="language-plaintext highlighter-rouge">MAXTRIES</code> attempts we still don’t get a response, we’ll throw a
bus error so that the system can deal with this further up in the chain.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="err">}</span> <span class="k">if</span> <span class="p">(</span><span class="n">nrd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">throw</span> <span class="nf">BUSERR</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>Otherwise, if we do have a good packet, we can look through the <code class="language-plaintext highlighter-rouge">i_gpio</code> values
and record or process them as necessary.  For example, this is where we’d
mark that we’d received an interrupt of some type.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_rxlen</span> <span class="o">=</span> <span class="n">nrd</span><span class="p">;</span>	<span class="c1">// Mark how long the packet is that's in our buffer</span>
	<span class="n">handle_gpio_returns</span><span class="p">();</span>
<span class="err">}</span></code></pre></figure>

<p>Sending data to the device is very similar.  First, you’d generate a packet
header.  Here we choose to use a pseudorandom number algorithm, although you
can use roughly any algorithm you want–as long as it doesn’t generate a
zero packet ID.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">char</span> <span class="err">\</span><span class="o">*</span><span class="n">NETBUS</span><span class="o">::</span><span class="n">begin</span><span class="err">\</span><span class="n">_packet</span><span class="p">(</span><span class="k">const</span> <span class="n">NETBUS</span><span class="o">::</span><span class="n">BUSW</span> <span class="n">address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_frameid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="c1">// Last packet was a sync packet</span>
		<span class="n">m_frameid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// Following a sync, the first ID == 1</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_frameid</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">m_frameid</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_frameid</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">RANDOMIZER_COEFFICIENTS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">m_frameid</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_frameid</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">m_pkt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_frameid</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">;</span>
	<span class="n">m_pkt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_frameid</span>     <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">;</span>
	<span class="n">m_pkt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_pkt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Following the header, we’ll encode the address of the subsequent transaction.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">// Return a pointer to the packet following the</span>
	<span class="c1">// address</span>
	<span class="k">return</span> <span class="nf">encode_address</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="err">}</span></code></pre></figure>

<p>At this point, we can fill our packet with data to be written to the device.</p>

<p>Once done, we’ll try writing this data to the device <code class="language-plaintext highlighter-rouge">MAXTRIES</code> times, or
until we get a response.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">tries</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="n">MAXTRIES</span><span class="p">;</span> <span class="n">tries</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Send the request packet</span>
		<span class="n">m_udp</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">pktlen</span><span class="p">,</span> <span class="n">m_pkt</span><span class="p">);</span>

		<span class="c1">// Try reading a packet</span>
		<span class="n">readpkt</span><span class="p">(</span><span class="n">PKT_TIMEOUT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_rxlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="c1">// We were successful!</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="c1">// Otherwise we repeat</span>
	<span class="p">}</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_rxlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">throw</span> <span class="nf">BUSERR</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

	<span class="c1">// Search the returned packet for evidence of a bus error.  If we</span>
	<span class="c1">// get a bus error, we'll throw an exception as above.</span>
	<span class="c1">// ...</span>
<span class="err">}</span></code></pre></figure>

<p>We’ll then repeat this process until all of the data we need sent has been
sent.</p>

<p>As you can see, the protocol is pretty simple from a software standpoint to
get working reliably.</p>

<h2 id="conclusions">Conclusions</h2>

<p>It works.</p>

<p>That’s all that matters, right?</p>

<p>Well, not quite.  In reality, this is just my first draft of a packet protocol
of this type.  For example, I haven’t implemented IP defragmentation.  (Nor
am I really planning on doing so in the FPGA hardware.)  Neither have I
implemented <a href="https://en.wikipedia.org/wiki/IPv4">IP</a> support beyond version 4,
or impemented any header option support.  Similarly, I haven’t implemented any
support for zero length packets beyond the original sync packets.</p>

<p>You can see a list of potential improvements I’ve been considering in Fig. 9.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 9. Potential upgrades to this protocol</caption><tr><td><img src="/img/netbus/upgrades.svg" alt="" width="360" /></td></tr></table>

<p>For perspective, I rewrote my original <a href="/blog/2017/06/05/wb-bridge-overview.html">serial port bus
protocol</a> about
three times before finally I arrived at something I liked.  Each version was
then better than the previous one.  Indeed, even now I have a fourth version of
that <a href="/blog/2017/06/05/wb-bridge-overview.html">serial port protocol</a>
that I’m slowly testing.  However, since this fourth version can only get
about a 10% speed improvement over the current version for the same baud
speed, it hasn’t gotten a lot of priority.  Put simply, the speed of the
<a href="/formal/2019/02/21/txuart.html">serial port</a>
isn’t really slowing me down significantly.</p>

<table align="center" style="float: right"><caption>Fig 10. Learning and rebuilding is to be expected</caption><tr><td><img src="/img/netbus/reproofs.svg" alt="" width="360" /></td></tr></table>

<p>That in itself is a lesson in any endeavor, and one I learned when working on
my Ph.D.  I like to sum it up with this advice to students, “Fail early. Fail
often. Plan for failure.”  Or, alternatively, “Success is measured by the
number of failures that it takes to achieve it.”  (These quotes are my own …)
Given that the best design is never the first one, you should plan on
rebuilding any design once or twice before it will become the best design
that you want to use and reuse over and over again.</p>

<p>From a more business perspective, I might argue the advice would be to put
lots of energy into <a href="/blog/2020/01/13/reuse.html">anything you intend to use more than
once</a>.</p>

<p>From all these perspectives, this is only a first design and draft of such
a protocol.  I expect it to get better over time.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Can two walk together, except they be agreed? Amos 3:3</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
