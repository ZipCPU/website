<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Is formal really all that hard?</title>
  <meta name="description" content="I spent the first week of March, 2018, atDVConin San Francisco, talking to vendors and asking questions regardingFormal Verification.">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zipcpu.com/blog/2018/03/14/is-formal-hard.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="http://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Is formal really all that hard?</h1>
    <p class="post-meta"><time datetime="2018-03-14T00:00:00-04:00" itemprop="datePublished">Mar 14, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I spent the first week of March, 2018, at
<a href="https://dvcon.org">DVCon</a>
in San Francisco, talking to vendors and asking questions regarding
<a href="/blog/2017/10/19/formal-intro.html">Formal Verification</a>.</p>

<p>Many vendors offered Verification IP (VIP) modules that you could use in
<a href="/blog/2017/06/21/looking-at-verilator.html">simulation</a>
to know that your interface matched the specification.  These models would
attach to your design, allowing you to then run tests on your design.  When/if
your design didn’t match what the protocol required, these commercial
VIP modules would issue an error.</p>

<p>Indeed, it seems like the primary method of <em>proving</em> that an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC design</a>
would work prior to tape out is to feed the simulated design with random data
and requests, over and over again, in order to get the design to fail.  Several
presentations discussed how to do this.  Hardware was advertised that could
help to make this happen.  While I’ll admit that the level of effort discussed
and presented goes well beyond my simple <a href="/blog/2017/10/19/formal-intro.html">scripted test bench
failures</a>,
it still only provides a small stochastic confidence that the design would work.</p>

<p>What a difference from
<a href="/blog/2017/10/19/formal-intro.html">formal</a>!</p>

<table align="center" style="float: none"><tr><td><img src="/img/v-method.svg" alt="" width="600" /></td></tr></table>

<p>When using
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>,
<em>every</em> path through the your logic is tested to determine if the design
works.  <em>Every path</em>.</p>

<p>This led me to wandering through the exhibit hall, asking vendor after vendor
if they had any <em>formal</em> VIP.  Perhaps 5-10% of the VIP available was available
for proving something
<a href="/blog/2017/10/19/formal-intro.html">formally</a>.
While the reasons were mixed, the general consensus was that
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
was more difficult to use, and so there wasn’t the same market for it.  One
vendor even declared that his tools were faster, better, and cheaper than
<a href="/blog/2017/10/19/formal-intro.html">formal</a>,
although less than
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
in capability.</p>

<p>What??  Really?  Is
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
really all that difficult to use?</p>

<p>Let’s look at a simple example or two.  Then, we can discuss how I go about
getting started with
<a href="/blog/2017/10/19/formal-intro.html">formal</a> on any new
design, and what designs I apply
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a> to.
Finally, we’ll attempt to address the question of whether
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
really are all that hard.</p>

<h2 id="cover">Cover</h2>

<p>Just one simple <code class="highlighter-rouge">cover</code> statement can have an amazing impact on a new design.
As an example, in a <a href="https://github.com/ZipCPU/tinyzip">recent design</a>
I was working on for the
<a href="https://tinyfpga.com">TinyFPGA</a>, a project I am calling
<a href="https://github.com/ZipCPU/tinyzip">TinyZip</a>, I simply inserted</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	cover(o_wb_ack);</code></pre></figure>

<p>into the <a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">new/updated dual
I/O</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
controller.
(I was starting with
<a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v">this QSPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller.)
If you aren’t familiar with a <code class="highlighter-rouge">cover</code> statement, you can consider
it a challenge to the
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
<a href="http://www.clifford.at/yosys">tools</a> to find some way to make the predicate
inside of the <code class="highlighter-rouge">cover</code> statement–in this case <code class="highlighter-rouge">o_wb_ack</code>–true.  To do this,
the <a href="/blog/2017/10/19/formal-intro.html">formal</a>
<a href="http://www.clifford.at/yosys">tools</a> needed to trace <a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">my
design</a>
through the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
bring-up, the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus request</a>, the address
passing to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
and the return value.</p>

<p><em>No extra logic was required!</em></p>

<p>I didn’t need to <a href="/blog/2017/06/21/looking-at-verilator.html">build a
simulation</a>,
to tell the simulator to tick the clock,
tell it how many clocks to tick, feed it with just the right input along
the way–none of that.  With one line I had an example
trace through the important parts of my code.</p>

<p>Was that all that hard?</p>

<p>Ok, so it wasn’t perfect: the bus wires were being driven incoherently.
However, with some additional assumptions, such as those <a href="/zipcpu/2017/11/07/wb-formal.html">we discussed for the
Wishbone Bus</a>, the traces
greatly improved.  (No, the
<a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">controller</a>
isn’t finished yet …)  Later, I added another cover statement to make
certain I could keep <a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">the
design</a>
loaded with one request after another.</p>

<h2 id="state-machines">State Machines</h2>

<p>Many of my designs use state machines that don’t completely cover
all of the states bits available.  For example, the “lite” versions of
<a href="https://github.com/ZipCPU/wbuart32">my serial port modules</a>
only use states 0-8 and 15.  What if the design entered into any other
state?  Would such be possible?  With just a simple assertion,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	assert((state &lt;= 8)||(state == 15));</code></pre></figure>

<p>I can then use
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
to tell me if my state machine will ever get out of bounds.  Indeed, this
concept is so useful, it’s worth discussing further in the next section.</p>

<h2 id="dependent-logic">Dependent logic</h2>

<p><a href="/blog/2017/10/19/formal-intro.html">Formal methods</a> are
also <em>very</em> useful for making sure that dependencies between logic elements
are captured.  Hence, if you have two variables, <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> that <em>must</em>
have a dependent relationship,
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a> are
very useful for making sure that dependent relationship is maintained.</p>

<p>For example, many designs depend upon a state machine that transitions at a
speed much slower than the system clock.  My own <a href="https://github.com/ZipCPU/wbuart32">UART
implementation</a> makes a great example
of this.  In this design, as with many similar ones, there is often a counter
used to determine <em>when</em> the next state change will be.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
if (counter != 0)
	counter &lt;= counter - 1'b1;
else if (state_change) // &amp;&amp; counter == 0
	counter &lt;= NEW_VALUE-1'b1;</code></pre></figure>

<p>The problem with this approach is that within the state machine logic, I would
need to place tests for whether or not <code class="highlighter-rouge">counter == 0</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
if (i_reset)
	state  == reset_state;
else if (counter == 0)
begin
	case(state)
	STATE_ONE:
		// ...
	end case
end</code></pre></figure>

<p>This test for zero can make the <a href="/blog/2017/06/12/minimizing-luts.html">state transition logic unnecessarily
complex</a>,
so I’ll often calculate it the clock prior with something like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	zclk &lt;= (counter == 1)||((counter == 0)&amp;&amp;(!state_change));</code></pre></figure>

<p>To determine if I got the logic right, I only need to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a> that:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	assert(zclk == (counter == 0));</code></pre></figure>

<p>When the
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
proof passes, I’ll know that these two dependent registers, <code class="highlighter-rouge">zclk</code> and
<code class="highlighter-rouge">counter</code>, are guaranteed to maintain their dependent relationship.
Hence, I can rely upon this dependency always being true within my
code–as I intended.</p>

<p>Certainly other internal code dependencies can exist as well–often more
complex than this one.  For example, a packet index or address might need
to be zero any time the network is idle.  As I recognize that I have such
a dependency when writing my own code, I’ll often quickly write an
assertion to capture it.  Indeed, I do this so often that I’ll discuss
how to go about this in the next section.</p>

<h2 id="while-writing-code">While writing code</h2>

<table align="center" style="float: right"><tr><td><img src="/img/files-formal.svg" alt="" width="180" /></td></tr></table>

<p>Often, when I write RTL, I’ll come across a situation where I recognize some
dependency within my code that must be hold true.  Rather than write a fully
defensive piece of code that handles any potential internal failure, it
is often effective (and easier) to write a quick assertion to remind myself
to come back later and place this into the list of <a href="/blog/2017/10/19/formal-intro.html">formal
properties</a>
at the end of the module.</p>

<p>Making sure I remember all of these dependencies later can be a hassle.</p>

<p>Here’s a method I’ve found useful for that purpose.</p>

<p>As I’m working on creating a module,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">//
// All files start with a (legalese) comment block
//
module name(/* portlist */);
	//
	// Module code is indented by one tab
	//</code></pre></figure>

<p>I’ll add any
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
in line as I’m writing–but with the caveat that these ad-hoc properties
are not indented like the rest of the code.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">// Properties that need to be moved around later are not indented
// This helps me remember, when I see something that doesn't line
// up, that this property needs to be moved to another location.
always @(posedge i_clk)
	assume(!i_reset);</code></pre></figure>

<p>My development will then continue, returning to my original indentation
scheme.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	//
	// Further module code (now indented again) may follow
	//</code></pre></figure>

<p>Then, some time later, I’ll collect these ad-hoc <a href="/blog/2017/10/19/formal-intro.html">assumtions and
assertions</a>
into a section at the end of the module together with the rest of its
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`ifdef	FORMAL
	// Here's where the formal properties will eventually be placed:
	// between `ifdef FORMAL and it's associated `endif.
`endif</code></pre></figure>

<p>For example, a
<a href="https://github.com/ZipCPU/wbuart32">UART</a> baud counter should never count
higher than one baud interval.  Hence, as I’m putting my
<a href="https://github.com/ZipCPU/wbuart32">UART</a>
component design together, I’ll place an assertion to this effect into my code.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	assert(baud_counter &lt; ONE_BAUD);</code></pre></figure>

<p>Some of my code, such as the <a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">dual I/O flash
controller</a>
I mentioned above, depends upon the ability to peek at a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus request</a>
at certain times before accepting it.  This requirement is easily captured by
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
if ((f_past_valid)&amp;&amp;($past(request))&amp;&amp;(!$past(accepted)))
	assert(request_details == $past(request_details));</code></pre></figure>

<p>Once I realize this, usually while building the code, I’ll just write it in
as I discussed above.  <a href="/blog/2017/10/19/formal-intro.html">Asserts and
assumptions</a>
like this alone have helped me flush out many
<a href="/blog/2017/08/14/strategies-for-pipelining.html">pipeline</a>
bugs!</p>

<p>Knowing that I intend to use
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
to verify a design helps to encourage me to write properties within my
code as I write my code–even though I’ll place those at the end of the
file later.</p>

<h2 id="some-modules-are-just-too-critical-not-to-use-formal">Some modules are just too critical not to use formal</h2>

<p>Some interfaces I deal with are just <em>too critical</em> not to use
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
to prove a design component before introducing it to hardware.
For example, just one misbehaving <a href="/zipcpu/2017/11/07/wb-formal.html">bus
component</a>
and the whole design will come crashing down.</p>

<p>Remember how this happened to me in my first <a href="/blog/2018/02/09/first-cyclonev.html">Cyclone-V
project</a>?  Before I
got the <a href="/blog/2017/10/19/formal-intro.html">formal</a>
properties of the <a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon
bus</a>
just right, I had to deal with several cases of hardware lockup.
It would seem as though a
<a href="/blog/2018/02/09/first-cyclonev.html">Cyclone-V</a>
can’t recover if my own logic fails to lower the wait request line, or
equivalently if it returns random bus responses that don’t follow requests).
In my case, only cycling power ever rescued my design, leaving me wondering
what had happened.</p>

<p>If you’ve been reading this blog for a while, you may now recognize this
purpose in the <a href="/zipcpu/2017/11/07/wb-formal.html">formal WB properties
post</a>.
Bus control logic is just <em>too sensitive</em> to mess up.  All it takes
is one master missing a response to a request and your design may be locked
up until a hard reset.</p>

<p>Cache controllers are another example, as they can be a <em>real pain</em> to get
right.  Worse, all it takes is one <a href="/zipcpu/2017/12/18/ugliest-bug.html">ugly caching
error</a> and you may be
<a href="/blog/2017/05/19/fpga-hell.html">spending days (or weeks)</a>
looking in the wrong place to find the bug.</p>

<p>My recommendation, therefore, would be that you consider this principle for
any portion of your design that, if it fails, will cause the whole design to
fail while leaving you in <a href="/blog/2017/05/19/fpga-hell.html">FPGA
Hell</a>.
<a href="/blog/2017/10/19/formal-intro.html">Formally verify</a>
those components early in your design cycle, before ever placing them onto
real hardware.  Then verify them again any time you change them.</p>

<h2 id="some-simple-contracts">Some simple contracts</h2>

<p>I’ve recently started looking at the designs I’m building as providing a
service, and so when I start building the design I’ll often create a <em>contract</em>
to describe the service that must be provided.  These <em>contracts</em> are usually
just a couple of lines of <a href="/blog/2017/10/19/formal-intro.html">formal
properties</a>
that describe outputs in relationship to the designs inputs.
Such design contracts are often so fundamental that if the contract holds,
the design will be 80% verified (or better).</p>

<p>Consider, for a moment, some simple peripherals from the standpoint of a
“contract”.</p>

<ul>
  <li>
    <p><a href="/zipcpu/2017/11/07/wb-formal.html">Bus requests should always be followed by a bus
response</a>.  There should be
no more responses than there are requests.</p>
  </li>
  <li>
    <p>A <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v">cache</a>
should always return the value that would be found in memory at the
given address, whether it needs to read from memory to get it or instead if
it is already in the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v">cache</a>.</p>
  </li>
  <li>
    <p>Reads from a memory controller
(<a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM</a>,
<a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">flash</a>,
etc.) should always return the value that exists in the memory at that
location, and writes should change the memory.</p>
  </li>
  <li>
    <p>An <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v">MMU</a>
should act as a bus bridge, between one set of addresses (the virtual ones)
and another (the physical ones), while creating page misses for anything
that doesn’t match.</p>
  </li>
</ul>

<p>The neat thing about these contracts is that they can help me prove that an
item works–to include passing the
<a href="https://en.wikipedia.org/wiki/Mathematical_induction">induction</a>
<a href="/blog/2018/03/10/induction-exercise.html">step</a>.
Specifically, until the contract can be proven, the
<a href="https://en.wikipedia.org/wiki/Mathematical_induction">induction</a>
solver will keep presenting me with traces I need to examine.  This helps me
know how many properties I need to write.</p>

<p>If the Lord wills, I’m hoping to blog about this concept soon with respect to a
second <a href="/about/zipcpu.html">ZipCPU</a>
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch module</a>,
showing how a contract can be written using a couple free variables.</p>

<h2 id="why-do-people-think-formal-is-hard">Why do people think formal is hard?</h2>

<p>After hearing that 
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
was too hard, I tried to gather all of the excuses I heard
to see if there might be some merit to any of them.</p>

<ol>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Mathematical_induction">Induction</a>
is harder than Bounded Model Checking (BMC)</p>

    <p>Many of the simple examples I gave above would be perfect for bounded
proofs.  These proofs are only applicable for the first N steps (i.e
the bound) following a reset.  Bounded proofs are much easier than the
full proofs, simply because in the case of a full proof you need to
find <em>ALL</em> the <a href="/blog/2018/03/10/induction-exercise.html">internal
dependencies</a>.
within your design and make them known to the
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
engine via additional properties–whether they be assumptions or assertions.
This can be a pain, and so I can understand that you might not wish to use
<a href="https://en.wikipedia.org/wiki/Mathematical_induction">induction</a>
at first.  Even in this case, though, the bounded model check is still
valuable–just not nearly as valuable as the full proof with
<a href="https://en.wikipedia.org/wiki/Mathematical_induction">induction</a>.</p>
  </li>
  <li>
    <p>Some modules are just too complex to prove using
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a></p>

    <p>This isn’t an excuse, nor should it be.  It is just a reality.</p>

    <p>While I’ve been able to <a href="/zipcpu/2018/01/22/formal-progress.html">prove all of the leaf
modules</a> of the
<a href="/about/zipcpu.v">ZipCPU</a>,
the complexity of the <a href="/about/zipcpu.v">CPU</a> as a whole
has caused me to pause before diving into it.  While I think I <em>can</em>
<a href="/blog/2017/10/19/formal-intro.html">formally prove</a>
that it works, the sheer complexity has caused me to pause.</p>
  </li>
  <li>
    <p>The full System Verilog Assertions syntax can be confusing</p>

    <p>If you’ve looked at the articles I’ve written so far regarding
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>,
you may notice that I haven’t used the full System Verilog Assertion (SVA)
syntax.  This is for two reasons.</p>

    <p>First, the open source
<a href="http://www.clifford.at/yosys">yosys</a>
synthesis tool that I’m using to get access to
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
without re-mortgaging my home doesn’t understand this syntax (yet).
Indeed, I’ve managed to <a href="/blog/2017/10/19/formal-intro.html">formally
verify</a>
many designs with only the subset that
<a href="http://www.clifford.at/yosys">yosys</a>
supports.  Since
<a href="http://www.clifford.at/yosys">yosys</a>
is the tool I can afford, it’s the tool I’ve been using.</p>

    <p>Second, I’m in the process of building a class in
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>.
This class includes a section on how to use the full SVA syntax: properties,
sequences, clocking blocks, bind statements, and more.  Since I’ve now
been introduced to the full SVA syntax, my initial impressions are that
it is very expressive, terse and compact, and as a result it is confusing
to those who are not familiar with them.  On the other hand, the
<code class="highlighter-rouge">assert</code> and <code class="highlighter-rouge">assume</code> statements I’ve used within always or initial blocks
have been expressive enough for me, and simpler to understand.</p>

    <p>It just happens that this simpler subset is also the set that
<a href="http://www.clifford.at/yosys">yosys</a>
currently supports.</p>
  </li>
  <li>
    <p>It can be really difficult to sell
<em><a href="/blog/2017/10/19/formal-intro.html">formal</a></em>
Verification IP, simply because
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
verification is a form of
<a href="https://en.wikipedia.org/wiki/White_box_testing"><em>white</em> box testing</a></p>

    <table align="center" style="float: right"><caption>Fig 3. Just attaching VIP to a formal design doesn't usually work</caption><tr><td><img src="/img/files-vip-unlinked.svg" alt="" width="360" /></td></tr></table>
  </li>
</ol>

<p style="list-style-type: none;">What I mean by this is that attaching any vendor
   supplied Verification IP module to your design isn’t as simple as just
   instantiating the two components within the same design.  The
   <a href="/blog/2017/10/19/formal-intro.html">formal methods</a>,
   and <a href="https://en.wikipedia.org/wiki/Mathematical_induction">induction</a>
   in particular, won’t work if you just plug and play related design pieces
   together such as Fig 3. attempts to show.  This makes it more difficult
   to sell, purchase, or use vendor provided Verification IP with
   <a href="/blog/2017/10/19/formal-intro.html">formal</a>.</p>

<p>In order to connect an external set of
   <a href="/blog/2017/10/19/formal-intro.html">formal</a> properties,
   such as those from a piece of vendor supplied Verification IP, to the
   <a href="/blog/2017/10/19/formal-intro.html">formal</a> properties
   within your own design–relevant portions of the design need to be
   constrained to be properly dependent with the VIP.
   Success in this fashion is far more intrusive, and not nearly as simple
   as just purchasing someone else’s IP.</p>

<table align="center" style="float: none"><caption>Fig 4. Passing Induction requires component state to interact</caption><tr><td><img src="/img/files-vip-linked.svg" alt="" width="360" /></td></tr></table>

<p>Perhaps a good example of this is my
   <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v">bus
   arbiter</a>.
   Internal to the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone formal
   property</a>
   <a href="https://github.com/ZipCPU/zipcpu/tree/master/rtl/ex">IP modules</a>
   are the counters necessary to insure that slaves will only respond
   to outstanding requests.  This
   requires counting the number of requests, the number of acknowledgments,
   and then making certain that there are never more acknowledgments than
   requests.  When I then try to use these properties within the bus
   <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v">arbiter</a>
   to pass
   <a href="https://en.wikipedia.org/wiki/Mathematical_induction">induction</a>,
   the
   <a href="/blog/2017/10/19/formal-intro.html">formal</a> engine
   may set these counters to <a href="/blog/2018/03/10/induction-exercise.html">any initial value it
   wants</a>.  However,
   the arbiter
   is designed so that only one master can ever have access to the bus at a
   time.  This means that the counters for the two slave inputs and the master
   output must be kept in sync.  Doing this requires knowledge of the counters
   within the
   <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> propert
   <a href="https://github.com/ZipCPU/zipcpu/tree/master/rtl/ex">module</a>,
   enough so that I can assert that when one bus source has access to the bus,
   the other sources number of outstanding requests must remain at zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
if (r_a_owner)
begin
	// If A owns the bus

	// B must have no outstanding requests, nor may it
	// have received any acknowledgements
	assert(f_b_nreqs == 0);
	assert(f_b_nacks == 0);

	// The total number of outstanding requests must equal
	// the number of outstanding requests A is expecting
	assert(f_a_outsanding == f_outstanding);
end else begin
	// Else B must own the bus
	// Same properties as before, just reversed
	assert(f_a_nreqs == 0);
	assert(f_a_nacks == 0);
	assert(f_b_outsanding == f_outstanding);
end</code></pre></figure>

<table align="center" style="float: none"><caption>Fig. Here's how I ended up attaching WB properties to a simple design</caption><tr><td><img src="/img/files-wb-properties.svg" alt="" width="480" /></td></tr></table>

<p>If you fail to do this, your design <a href="/blog/2018/03/10/induction-exercise.html">won’t be able
   to pass</a>
   <a href="https://en.wikipedia.org/wiki/Mathematical_induction">induction</a>.</p>

<p>Even if your design doesn’t pass
   <a href="https://en.wikipedia.org/wiki/Mathematical_induction">induction</a>,
   (most big chip maker designs don’t) your <a href="/blog/2017/10/19/formal-intro.html">formal
   properties</a>
   may still be good enough to accomplish some purposes, since you can still
   find lots of bugs via a simple Bounded Model Check.  You just can’t <em>prove</em>
   that your design will maintain those properties for all time.</p>

<p>Does it take a genius?  Not really.  Indeed, from my own experience,
it just takes someone smart enough to write Verilog RTL in the first place.</p>

<h2 id="formal-isnt-perfect">Formal isn’t perfect</h2>

<p>My thesis today is just that
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
isn’t really any more difficult than normal RTL coding.  Not only that, it fits
nicely into the RTL coding process and even adds to it.  Now that I’ve used it
for a while, and now that I’ve found as many errors as I have using
<a href="/blog/2017/10/19/formal-intro.html">formal</a>,
I’m convinced from my own experience that it’s not really that hard.  Indeed,
if I had the choice today, I would find it difficult to start a project
<em>without</em> the help
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
provide.</p>

<p>While I was at the
<a href="https://dvcon.org">DVCon</a> conference, I heard two fascinating comments
regarding how valuable <a href="/blog/2017/10/19/formal-intro.html">formal
methods</a> are,
and many fascinating anecdotes.  The first comment I scribbled down was
that, “Without <a href="/blog/2017/10/19/formal-intro.html">formal</a>,
70% of the bugs in a design are found after the module is turned in.  With
<a href="/blog/2017/10/19/formal-intro.html">formal</a>,
80% of the bugs in a design are found before the module is turned in.”
No, I’m not sure any more where these numbers came from, so if I can find the
study I’d love to share it with you.  The
second comment was from one of the panelists who noted that a rough 80% of a
verification engineer’s time is spent fixing the <em>silly</em> bugs.  The
implication in this statement was that, had only
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
been used, the verification engineer wouldn’t need to be spending his time
fixing the stupid mistakes.</p>

<p><a href="/blog/2017/10/19/formal-intro.html">Formal methods</a>
aren’t perfect.  By that I mean that, in my own experience, I’ve still had
to chase down bugs that “passed” a formal proof.
These include problems with not constraining my design enough, with adding
careless assumptions, and even misunderstood requirements.</p>

<p>However, I find 
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
easier to use than the alternative, and I also feel like I am finding more
bugs by using them as part of my design process.  As a result, I now use
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
first, and then continue with simulation when I’m done.</p>

<p>So why do people think
<a href="/blog/2017/10/19/formal-intro.html">formal</a> is all that
difficult?  My best guess is that
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
appear difficult to those who have not tried them, and additionally to those
selling Verification IP.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Behold, I am the LORD, the God of all flesh: is there any thing too hard for me?  (Jeremiah 32:27)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
