<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Taking a look at the TinyFPGA BX</title>
  <meta name="description" content="Fig 1. The TinyFPGA BX">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2018/10/05/tinyfpga.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Taking a look at the TinyFPGA BX</h1>
    <p class="post-meta"><time datetime="2018-10-05T00:00:00-04:00" itemprop="datePublished">Oct 5, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. The TinyFPGA BX</caption><tr><td><img src="/img/TinyFPGA-BX.png" alt="" width="202" /></td></tr></table>

<p>Some time ago, I wrote a <a href="/blog/2017/12/16/max1k.html">review of the MAX-1000 FPGA board</a> sold by
<a href="https://www.trenz-electronic.de/en">Trenz</a>.  Today, I’d like to share my thoughts on another small <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
development board: the <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA BX</a> board.</p>

<p>If you’ve paid attention to the boards I like to purchase, I have a particular
love for the smaller <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> boards.  Examples include the
<a href="http://www.xess.com/shop/product/xula2-lx25">XuLA2-LX25</a>,
<a href="http://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module">CMod S6</a>,
and the <a href="/blog/2017/12/16/max1k.html">MAX-1000</a>.
These boards have all pin-holes for connections, running around the edges of
the board.  As a result, they either have very few peripherals, or these
boards are rife with possibilities and just waiting for a fun electronics
project.  Your choice.</p>

<p>That said, this is probably a character flaw on my own part, because I’ve
never been comfortable with a soldering iron.  In reality, I shouldn’t be
so concerned.  At the extremely low cost of these small boards–and
particularly the <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA
BX</a>, I can afford a soldering failure,
or two, or perhaps even twenty, and I would quickly learn to be a better
engineer as a result.</p>

<p>But let’s dig into the <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA BX</a>, and
see what we can do with something like this special board.</p>

<h2 id="tinyfpga-bx">TinyFPGA BX</h2>

<p>The <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA BX</a> is a bare bones
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
board.  And, when I say bare bones, that’s
exactly what you have.  The board contains:</p>

<ol>
  <li>
    <p>An <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/20005625B.pdf">ultra low power 16MHz clock MEMs
oscillator</a>,</p>
  </li>
  <li>
    <p>A <a href="http://www.adestotech.com/wp-content/uploads/DS-AT25SF081_45.pdf">1MB SPI flash, capable of QSPI
mode</a>,</p>
  </li>
  <li>
    <p>A power LED and a user controlled LED, and</p>
  </li>
  <li>
    <p>A reset button to reload the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> from <a href="/blog/2018/08/16/spiflash.html">flash</a>.</p>
  </li>
  <li>
    <p>A USB connection for programming the board</p>
  </li>
  <li>
    <p>An iCE40 LP8k FPGA.  This FPGA has 7680 4-LUTs, and is supported by a fully
open source toolchain consisting of <a href="http://www.clifford.at/yosys">Yosys</a>, <a href="http://www.clifford.at/icestorm">ice-storm</a>, and now <a href="https://github.com/YosysHQ/nextpnr">NextPNR</a>.</p>

    <p>This iCE40 also has 16kB of block RAM.</p>

    <p>When I tried to place the <a href="/about/zipcpu.html">ZipCPU</a> on this board, I quickly discovered I’d
never be able to use all of that blockRAM for <a href="/about/zipcpu.html">my CPU</a>.  Since the <a href="/about/zipcpu.html">ZipCPU</a>
uses block RAM for more than one purpose (RAM, CPU registers, serial port
FIFO, etc.), this effectively limited the size of the block
RAM device available for the <a href="/about/zipcpu.html">ZipCPU</a> to 8kB.</p>
  </li>
</ol>

<p>That’s it.</p>

<p>Oh, I almost forgot, one of the great strengths of the board is that it has
24 digital I/O’s with which you can do whatever with.  These I/O’s are brought
out to pins on the edge of the board.  Indeed, the strength of the board, as
in other boards of this minimalist variety, lies in what you can do with these
I/O’s.</p>

<p>What really sets the <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA BX</a> apart,
though, is how it handles the USB port.</p>

<h2 id="tinyfpga-usb">TinyFPGA USB</h2>

<p>Most of the programmable <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> boards I have include an <a href="http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf">FTDI
FT2232H</a>
chip connected to the USB port.  This chip contains all the hardware necessary
to both program the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>, and to connect a basic serial port from your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> design to your host computer.</p>

<p>Not so with the <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA BX</a>.  This is perhaps the biggest thing that sets the
<a href="https://tinyfpga.com">TinyFPGA</a> apart from other <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> solutions: <em>it has no auxilliary chip for
dealing with the USB</em>.</p>

<p>Instead, the <a href="https://tinyfpga.com">TinyFPGA</a> requires <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> design logic to communicate over the USB
port–if at all.</p>

<p>I’ll be honest, before I discovered the <a href="https://tinyfpga.com">TinyFPGA</a>, I thought it was impossible
to program an <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> to communicate over the USB in a raw fashion like that.
The <a href="https://tinyfpga.com">TinyFPGA BX</a> proves me wrong.</p>

<p>Here’s how this works:</p>

<ol>
  <li>
    <p>When you power up the <a href="https://tinyfpga.com">TinyFPGA</a>, it immediately loads
an initial “<a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a>”
design onto the board–much like a lot of microcontrollers, such as the PIC.
This is not your user design.  Instead, this is a design that will either
load your design, or communicate with the board over USB, and so allow you
to write a user design to the
<a href="/blog/2018/08/16/spiflash.html">flash</a>.</p>

    <p>Fig 2. on the right shows the basic
<a href="/blog/2018/08/16/spiflash.html">flash</a> memory segregation.
The first 165kB is used by this USB enabled boot-loader, the next 165kB
is used  by the user design, and the rest of the flash is available to your
design.</p>
  </li>
</ol>

<table align="center" style="float: right"><caption>Fig 2. Flash Memory by the Section</caption><tr><td><img src="/img/tinyfpga-flash-layout.svg" alt="" width="240" /></td></tr></table>

<ol start="2">
  <li>
    <p>Using the <a href="https://github.com/tinyfpga/TinyFPGA-B-Series/tree/master/programmer">TinyFPGA BX python
tools</a>,
you can communicate with this <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a>
and load your design into the next 165kB of
<a href="/blog/2018/08/16/spiflash.html">flash</a> memory.</p>
  </li>
  <li>
    <p>Then, when you are ready and with the <a href="https://tinyfpga.com">TinyFPGA</a>
plugged in, a USB command can be sent to the
<a href="https://tinyfpga.com">TinyFPGA</a> to cause it to switch to the user design.
This uses the iCE40 WARMBOOT primitive to cause the iCE40 to load a
new design from a non-zero address within <a href="/blog/2018/08/16/spiflash.html">flash</a> memory.</p>

    <p>Once complete, your user design starts running.  If your design doesn’t
have USB capability within it, then you won’t have USB connectivity again
until you restart the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>
  </li>
  <li>
    <p>Ever after, the <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> will load your design after waiting a second or
two on startup.</p>
  </li>
  <li>
    <p>To return to the <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> mode, you either need to press the reset button,
pull power from the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>, or
issue your own command to the WARMBOOT
primitive from within your own design to cause the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> to
reload itself from the zero address.</p>
  </li>
</ol>

<p>All of this is to say that the <a href="https://tinyfpga.com">TinyFPGA</a> doesn’t really
provide the same functionality that the <a href="http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf">FTDI
chip</a>
did.  Under this design concept, you cannot load a design onto the
<a href="https://tinyfpga.com">TinyFPGA</a> without also loading it onto the
<a href="/blog/2018/08/16/spiflash.html">flash</a> first.
There is no usable JTAG port to directly load the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> apart from
loading it into the <a href="/blog/2018/08/16/spiflash.html">flash</a>,
or to debug the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
using vendor tools.  Further, if you want a USB console port to your board,
then you may need to design and and add it yourself.</p>

<p>It’s a pretty neat design concept.  Better yet, it’s all open source!  You can
look up how the <a href="https://tinyfpga.com">TinyFPGA</a> <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">does
it</a>, and then modify
<a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">that design</a>
for your own purposes.</p>

<h2 id="practical-consequences">Practical Consequences</h2>

<p>There are, however, some practical consequences of both the design concept
and the hardware on the board.</p>

<ol>
  <li>
    <p>Because loading your design onto the board requires a design already loaded
onto the board, you’ll need to be careful not to erase, overwrite, or
otherwise damage the
<a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> design.</p>

    <p>If you do, you haven’t quite bricked your board.  However, you will then
be stuck trying to reload the <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> design back onto the board using
the SPI pads (not pins, nor pin holes, but pads) on the back of the board.</p>

    <p>While this may sound scary, the reality is that if you are going to be
soldering or otherwise wiring this board into your own project somewhere,
then you already have the skills to do this–even if it is a hassle.
Indeed, if you look at the underside of the board, you’ll be able to see
small pin-prick indents in the pads there, showing you where pins were used
to connect to the design to load the <a href="/blog/2018/08/16/spiflash.html">flash</a> initially.</p>

    <p>If this is still more than you bargained for, then <a href="https://www.tindie.com">Tindie</a> sells a <a href="https://www.tindie.com/products/loglow/tinyfpga-bx-breakout-revision-a">breakout
board</a>
for the <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA BX</a> for only $11 that should give you access to these
SPI pins for this purpose as well.</p>
  </li>
  <li>
    <p>If you want to USB enable your own design, there are some consequences.
First, the USB <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> requires about 1k LUTs out of a board containing
only 7.6k LUTs in the first place.  Placing this <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a>, or other USB
design, into your <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> design will limit what you can do with your own
design.</p>
  </li>
  <li>
    <p>The really ugly part of this setup is that neither
<a href="https://github.com/YosysHQ/nextpnr">nextpnr</a> nor
<a href="https://github.com/YosysHQ/arachne-pnr">arachne-pnr</a>
support multiple clock timing-driven placement (yet), nor does the
<a href="https://github.com/cliffordwolf/icestorm/tree/main/icetime">icetime timing checker</a> within the
<a href="http://www.clifford.at/icestorm">icestorm toolkit</a>.  Think this through.
The USB design used by the bootloader runs at 48MHz.  It is very much wed
to this speed, and it would be difficult to change it.  If your user design
doesn’t run at 48MHz, you’ll be stuck either using the proprietary
tool-chain or waiting for dual-clock support in
<a href="https://github.com/YosysHQ/nextpnr">nextpnr</a>.
(<a href="https://github.com/YosysHQ/arachne-pnr">Arachne-pnr</a>, though maintained,
is no longer under active development.)</p>

    <p>Just to give you a feel for timing, my own
<a href="/about/zipcpu.html">ZipCPU</a> runs at 100MHz on a Xilinx
Artix-7.  <a href="https://github.com/ZipCPU/xulalx25soc">It runs at 80MHz on a
Spartan 6</a>.  <a href="https://github.com/ZipCPU/icozip">It runs at 50MHz on
an iCE40 HX8k</a>.  <a href="https://github.com/ZipCPU/tinyzip">It runs at 25 MHz on
the iCE40 LP8k</a> found within the
<a href="https://tinyfpga.com/bx/guide.html">TinyFPGA BX</a>.
(<a href="https://github.com/cliffordwolf/icestorm/tree/main/icetime">icetime</a>
gives the design a 30MHz maximum clock speed.)  Without being able to route
my design for two separate clocks, my design will not have USB support.</p>

    <p>Or would they?  The ice40 boards do have an <code class="language-plaintext highlighter-rouge">SB_IO</code> primitive that provides
support for a DDR capability …</p>
  </li>
</ol>

<p>What does this mean for me?</p>

<p>First, the small block RAM space on the chip is too small to hold the
<a href="https://sourceware.org/newlib">newlib</a> C-library.  Hence, if I want to run
<a href="https://en.wikipedia.org/wiki/&quot;Hello,_World!&quot;_program">Hello World</a> I’ll need
to store as much library code as I can in the
<a href="/blog/2018/08/16/spiflash.html">flash</a>.  I’ll need to be
extra careful that, in this process, I don’t affect the
<a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a>.  In addition, 
<a href="https://en.wikipedia.org/wiki/&quot;Hello,_World!&quot;_program">Hello World</a>
will need 2 wires dedicated to my <a href="https://store.digilentinc.com/pmod-usbuart-usb-to-uart-interface/">USB-UART PMod</a>, just so I can see the result
and interact with my design–assuming that I can’t get a USB console to work.</p>

<p>I’m also very thankful that the <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA
BX</a> (now) supports all the wires
necessary for <a href="/blog/2018/08/16/spiflash.html">QSPI flash</a>!
That will help to help keep the <a href="/zipcpu/2018/03/21/dblfetch.html">CPU speed up
there</a>, in spite
of the non-pipelined CPU configuration (the only one that would fit).</p>

<h2 id="tinyfpga-and-fpga-hell">TinyFPGA and FPGA Hell</h2>

<p>The <a href="https://tinyfpga.com">TinyFPGA</a> <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> has a USB protocol driver.  This was one of the things
that surprised me and caught my attention when I first discovered this board.
In particular, I was curious to know how Luke Valenty built it.  The USB
specification is rather large and complex.  I had to ask: What design method
did Valenty use to get this interaction up and running?</p>

<p>So I asked.  Valenty was more than happy to share how he had (or rather hadn’t)
avoided <a href="/fpga-hell.html">FPGA Hell</a> during his design
process.</p>

<p><strong>Me</strong>: I notice the <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA BX</a>
design includes a USB capability.  Can you tell my readers anything about
how you went about building it?</p>

<p><strong>Valenty</strong>:</p>

<blockquote>
  <p>Most <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> boards use a dedicated USB interface chip to enable programming
and communication between the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> and a host computer.  The most popular
choice is an <a href="http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf">FTDI chip</a>.
This chip costs as much as the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> itself!  I
had a goal of developing a small and cost-effective <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> board and I
really wanted to deliver.  I have a lot of experience with USB, so I
decided to implement the USB interface fully on the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> itself.
The ICE40 FPGAs have a multiboot capability that allows for multiple
configuration bitstreams to be stored in the
<a href="/blog/2018/08/16/spiflash.html">SPI flash</a> and loaded at will
by the design.  This allowed me to develop a USB <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> in a similar
way that microcontrollers can bootload themselves over serial or  USB
interfaces.</p>

  <p>The plan was to test the design on the <a href="https://tinyfpga.com">TinyFPGA</a> hardware against a real
USB host.  I had no testbench for simulation nor did I have any 
<a href="/formal/2018/04/23/invariant.html">formal assertions or assumptions</a>.  This was a terrible idea and I
spent a lot of time debugging issues on real hardware and implementing
workarounds in the original programmer software.</p>
</blockquote>

<p><strong>Me</strong>: I’m not a board designer myself, so I have the advantage of examining a
  canned <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> design for the board I’m working with before I ever start.
  Even better, I can return to that design if I think there might be a
  hardware problem with the board I am working with.</p>

<p>As a board supplier, can you share anything about what it took to get a
  first initial design running on the board?</p>

<p><strong>Valenty</strong>:</p>

<blockquote>
  <p>Because I didn’t have any simulation or <a href="/blog/2017/10/19/formal-intro.html">formal verification</a> environment,
I had to do all my testing and debugging on the real hardware.  This
involved running tests on the board while connected to a USB host and
spying out internal signals to extenal pins so I can capture them on my
logic analyzer.  Debugging issues required me to make educated guesses
about what signals might help me to debug an issue and rerunning the test multiple times while capturing different groups of signals until the issue could be identified and fixed.</p>

  <p>This was a long turnaround between seeing an issue, root-causing it, and
verifying a fix.  It took quite some time and long nights to get the
<a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> working reliably on all platforms.</p>
</blockquote>

<p><strong>Me</strong>: Did you ever find yourself stuck in <a href="/fpga-hell.html">FPGA
  Hell</a> while designing and
  building the <a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a>?</p>

<p><strong>Valenty</strong>:</p>

<blockquote>
  <p>Yes, in fact, any time I go back to the
<a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> I have
to be very careful how I make changes.  I have since added a simulation
test bench and suite of tests, but making changes is still quite difficult.</p>
</blockquote>

<p><strong>Me</strong>: Did you use any simulation or <a href="/blog/2017/10/19/formal-intro.html">formal verification</a> techniques?</p>

<p><strong>Valenty</strong>:</p>

<blockquote>
  <p>Nope, and this was a major folly.</p>
</blockquote>

<p><strong>Me</strong>: Would you recommend this approach to others?</p>

<p><strong>Valenty</strong>:</p>

<blockquote>
  <p>This is pretty much the worst way to go about developing a digital design.
In the end I was able to get the
<a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> to work
very well, but I spent a substantial amount of time working through issues
that would have been trivial to find with a simulation testbench and/or
with <a href="/blog/2017/10/19/formal-intro.html">formal verification</a> techniques.</p>

  <p>I am currently working on a rewrite of the USB core and
<a href="https://github.com/tinyfpga/TinyFPGA-Bootloader">bootloader</a> using
<a href="http://m-labs.hk/migen/index.html">Migen</a> and a unit test methodology.
The design is broken down into small
and simple components that are then unit tested individually to ensure
they behave as expected.  This process is proving to be far easier, less
time-consuming, and is creating a more robust design.  If
<a href="http://m-labs.hk/migen/index.html">Migen</a> ever
gets support for <a href="/formal/2018/04/23/invariant.html">formal assertions and assumptions</a> I would be very
interested in trying them out.</p>
</blockquote>

<p><strong>Me</strong>: Finally, what do you see as the biggest selling point of the
  <a href="https://tinyfpga.com">TinyFPGA</a> over and above other
  <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
  boards that may be out there today?</p>

<blockquote>
  <p>The <a href="https://tinyfpga.com/bx/guide.html">TinyFPGA BX</a> board is great to
me because it’s completely open and very small.  You have a lot of freedom
to use the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
in any way in which you feel without paying extra money for components or
peripherals you are not using.  It’s a great way to create new and unique
projects that take advantage of the power of
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.  The
<a href="https://tinyfpga.com">TinyFPGA</a> <a href="https://discourse.tinyfpga.com">Discourse server</a>
has some excellent examples of projects the community has come up with:
<a href="https://discourse.tinyfpga.com/c/tinyfpga-projects">link</a></p>
</blockquote>

<p>Thank you!</p>

<h2 id="using-the-tinyfgpa">Using the TinyFGPA</h2>

<p>I hope I haven’t given you the wrong idea about the
<a href="https://tinyfpga.com">TinyFPGA</a> above.  It is designed to be a very minimalist
iCE40 FPGA board.  It fills that role quite nicely.  Even better,
it is supported by an entirely open source <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> tool chain.</p>

<p>If this is your first project, then do be prepared to do some hand wiring
to connect your favorite devices/peripherals to the board.</p>

<p>Others have already been very successful with this board.  These users have
proved that you can play pong, pac man, or even space invaders on the board.
Still others have ported the picoSoC project including a picoRV RISC-V CPU to
the board.  In other words, it’s not so spare that you can’t do anything with
it, but it might test your creativity.  Hopefully that’s why you are in the
market for a board like this in the first place.</p>

<p>Me?  Well, it shouldn’t surprise you to know that I’m more interested in
placing a <a href="/about/zipcpu.html">ZipCPU</a> onto the board.</p>

<p>Will the <a href="/about/zipcpu.html">ZipCPU</a> fit?  Yes.  With a
special hardware multiply unit, the normal divide unit, together with the
<a href="/zipcpu/2018/03/21/dblfetch.html">pipelined fetch unit</a>
and compressed instruction support, a <a href="https://github.com/ZipCPU/tinyzip">minimum ZipCPU
build</a> uses 5437 logic elements out of 7680,
or about 70%.  Yes, I rewrote both the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/slowmpy.v">multiply</a>
and <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a> units
to get the <a href="/blog/2017/06/12/minimizing-luts.html">logic
count</a> this low.  I
could go lower if I wanted by removing some of these extra features.  My goal,
however, was to leave enough room at the end so that I could incorporate a USB
based serial port.  Sadly, I might end up waiting a while on that.</p>

<p>Perhaps I’ll just <a href="https://store.digilentinc.com/pmod-gps-gps-receiver">GPS enable my
device</a> instead.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Seest thou a man diligent in his busines?  He shall stand before kings; he shall not stand before mean men.  (Prov 22:29)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
