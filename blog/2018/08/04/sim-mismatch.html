<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Reasons why Synthesis might not match Simulation</title>
  <meta name="description" content="When I first learned digital design, I never simulated any of my designs:I just placed them directly onto the hardware and debugged them there.">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2018/08/04/sim-mismatch.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Reasons why Synthesis might not match Simulation</h1>
    <p class="post-meta"><time datetime="2018-08-04T00:00:00-04:00" itemprop="datePublished">Aug 4, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>When I first learned digital design, I never simulated any of my designs:
I just placed them directly onto the hardware and debugged them there.</p>

<p>I’ve since become convinced in using simulation for several reasons: simulation
can be faster than synthesizing a design.  Indeed, any time I run
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>
I can find many syntax errors in my design before Vivado fully starts up and
shows me one bug.  But that’s just synthesis.  For small designs, simulation
is still faster.  Of course, ultimately, the hardware is always faster–but 
in the time it takes to get there, you might manage to get an answer via
simulation.</p>

<p>The second reason why I like simulation is that a simulation generated trace
will contain <em>every wire</em> within the design.  For this reason, when something
doesn’t work in hardware, I’ll almost always return to simulation and try to do
the same thing in simulation to see if I can come across the same bug.  That
allows me to be able to turn around quickly and find the bug.</p>

<p>Or … not so quickly.  On one recent design, I read the entire 16MB from a
SPI flash memory, only to have the design fail when reading the last word
from the flash.  Not knowing where to start, I started with simulation–but
then had to trim down the trace before filling up every bit in my computers
disk drive.</p>

<p>But what happens when you cannot simulate the problem?  When your design
works perfectly in simulation, but fails on the hardware?</p>

<p>I’ll admit this happened to me recently as well.  I think it happens to
everyone at some point.</p>

<p>Therefore, to help keep you from
<a href="/blog/2017/05/19/fpga-hell.html">FPGA Hell</a>, I <a href="https://www.reddit.com/r/FPGA/comments/8g26i1/reasons_why_simulation_doesnt_match_synthesis/">asked on
Reddit</a>
for a list of things that might cause your simulation not to match reality.
When I asked, I thought I knew most of the reasons.  To my surprise, the kind
<a href="https://www.reddit.com/r/FPGA">Reddit readers</a> were glad to share with me
many more reasons why simulation might not match actual hardware performance.</p>

<p>Let me try to list and explain the reasons I’ve found here, and see if I managed
to (finally) get all of the reasons given to me on
<a href="https://www.reddit.com/r/FPGA/comments/8g26i1/reasons_why_simulation_doesnt_match_synthesis/">Reddit</a>.</p>

<h2 id="timing">Timing</h2>

<p>Digital designs don’t work if the time between clock pulses isn’t sufficient
for all of the logic to take place between when one
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip flop</a> 
sets its value and the next one needs the value to be held constant.  This
is often the meaning of the word
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations">“timing”</a> 
in this context.  Here are some reasons why
a design might fail associated with this design problem.</p>

<ul>
  <li>
    <p>Design failed to pass timing, yet was used anyway</p>

    <p>Following place and route, you need to check whether the resulting design
ensured that all the setup and hold requirements for all of the <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip
flops</a> 
within (or external to) your design were met.  Usually the tools will do this
for you automatically.  However, if you fail to check this
result and use the design anyway … then it is likely to have some problems.
Worse, the behavior you see might masquerade as a completely different
problem.</p>

    <p>For this reason, whenever I have a design that doesn’t work, I first
double check the timing report.</p>
  </li>
  <li>
    <p>The timing checker wasn’t given the right clock rate</p>

    <p>If you tell the timing checker you either have no clock in your design
(yes, I did this once), or if you give it the wrong frequency, your
design may appear to pass the timing check–even though the check
 is invalid.</p>
  </li>
  <li>
    <p>Using delays in test bench design</p>

    <p>This is one reason why I avoid the “#” syntax in Verilog, such as
<code class="language-plaintext highlighter-rouge">a &lt;= #2 b;</code>.  Just because you
tell the Verilog simulator that something will happen “2.5ns” later,
doesn’t mean it will achieve that “2.5ns” result in hardware.  Worse,
these statements are often ignored by the synthesizer. Hence, if you use
them, don’t use them on code you intend to place on actual hardware.</p>
  </li>
  <li>
    <p>Just being wrong about the clock frequency on the board</p>

    <p>This is subtly different from giving the timing analyzer the wrong rate.
For example, if you think your clock rate is 100MHz, and get your design
to pass the timing check for 100Mhz, even though the clock rate is really
50MHz, any logic that depends upon this number is not likely to work.</p>
  </li>
</ul>

<h2 id="metastability"><a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">Metastability</a></h2>

<p>We’ve discussed <a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a> a couple of times on this blog–mostly associated
with <a href="/blog/2017/10/20/cdc.html">crossing clock domains</a>.
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">Metastability</a> is caused when a signal input to
a <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip flop</a> 
is changing right as the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip flop</a>s
clock arrives.  In that case, the design might have a value that is
neither “1” nor “0”, causing unpredictable results in subsequent logic.
Because <a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a> is only caused if the signal changes right at the
clock edge, it is a rare event–but often not rare enough.  Either way,
the simulator will rarely if ever notice it.</p>

<p>Here are some examples of things that might cause <a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>.</p>

<ul>
  <li>
    <p>No synchronization of async signal</p>

    <p>Inputs to a design may be asynchronous.  A good example is a button press,
or a serial port input.  Such inputs need to be
<a href="/blog/2017/10/20/cdc.html">synchronized</a> before
use!  This is actually a common problem among beginners–they’ll use a value
without
<a href="/blog/2017/10/20/cdc.html">synchronizing</a>
it, ignorant that this might cause problems.</p>
  </li>
  <li>
    <p>Improperly managed <a href="/blog/2017/10/20/cdc.html">clock domain crossing</a></p>

    <p>This is another classic problem.  When you cross from one <a href="/blog/2017/10/20/cdc.html">clock
domain</a>
to another, you need to manage the clock crossing with either a
<a href="/blog/2017/10/20/cdc.html">synchronizer</a>
or an <a href="/blog/2018/07/06/afifo.html">asynchronous
FIFO</a>–which will use
<a href="/blog/2017/10/20/cdc.html">synchronizers</a>
internally.</p>
  </li>
  <li>
    <p>Any time a register is clocked by two different clocks in the same process</p>

    <p>I haven’t personally come across this one, but imagine a process that is
sensitive to <code class="language-plaintext highlighter-rouge">@(posedge i_clk, negedge i_reset, posedge something_else)</code>.
This can be a recipe for a <a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a> disaster.</p>

    <p>You can read how we handled this with the <a href="/formal/2018/04/12/areset.html">asynchronous reset</a> here.
However, I tend to try to avoid this situation by just not writing code
of this type.  This was one of those reasons why I <a href="/blog/2017/08/21/rules-for-newbies.html">recommended to
beginners</a>
that only <em>clock</em> edges should ever be in the sensitivity list.</p>
  </li>
  <li>
    <p>Timing errors due to incorrect multipath constraints that are not checked
in simulation</p>

    <p>When <a href="/blog/2017/10/20/cdc.html">crossing clock domains</a>,
it’s not exactly clear upon which edge of the
next clock a particular signal will arrive.  Hence, if you have a
signal defined in one
<a href="/blog/2017/10/20/cdc.html">clock domain</a>,
yet crossing into another in order to
be the input of two separate pieces of logic, you’ll be surprised that
in the real hardware, the two pieces of logic might not do the same
thing.</p>
  </li>
</ul>

<p>Let’s illustrate this last problem with an example.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">test</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">,</span> <span class="n">i_clk_b</span><span class="p">,</span> <span class="n">i_ina</span><span class="p">,</span> <span class="n">o_outb</span><span class="p">);</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="n">i_clk_a</span><span class="p">,</span> <span class="n">i_clk_b</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="n">i_ina</span><span class="p">;</span>
	<span class="kt">output</span>	<span class="kt">wire</span>	<span class="n">o_outb</span><span class="p">;</span>

	<span class="c1">// Here's our first synchronizer</span>
	<span class="kt">reg</span>	<span class="n">threesync</span><span class="p">,</span> <span class="n">threein</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">threein</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">threesync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk_b</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">threein</span><span class="p">,</span> <span class="n">threesync</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">threesync</span><span class="p">,</span> <span class="n">i_ina</span> <span class="o">}</span><span class="p">;</span>

	<span class="c1">// Here's some logic dependent upon its result</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">bythrees</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">bythrees</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk_b</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">threein</span><span class="p">)</span>
		<span class="n">bythrees</span> <span class="o">&lt;=</span> <span class="n">bythrees</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>

	<span class="c1">// That's the first path, now let's look at the second path</span>
	<span class="c1">// It starts with a separate synchronizer</span>
	<span class="kt">reg</span>	<span class="n">fivesync</span><span class="p">,</span> <span class="n">fivein</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">fivein</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">fivesync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk_b</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">fivein</span><span class="p">,</span> <span class="n">fivesync</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">fivesync</span><span class="p">,</span> <span class="n">i_ina</span> <span class="o">}</span><span class="p">;</span>

	
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">byfives</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">byfives</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk_b</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fivein</span><span class="p">)</span>
		<span class="n">byfives</span> <span class="o">&lt;=</span> <span class="n">byfives</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">o_outb</span> <span class="o">=</span> <span class="n">byfives</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">bythrees</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span></code></pre></figure>

<p>Now, let’s assume that <code class="language-plaintext highlighter-rouge">i_ina</code> is some logic that is set on <code class="language-plaintext highlighter-rouge">i_clk_a</code>’s
positive edge.  You’d expect <code class="language-plaintext highlighter-rouge">o_outb</code> to be zero at all times, right?  (Both
registers will toggle the lowest bit on any <code class="language-plaintext highlighter-rouge">i_ina</code> input.  You
might be surprised by the hardware when it isn’t.</p>

<h2 id="blocking-vs-non-blocking-assignments">Blocking vs Non-blocking assignments</h2>

<p>Every now and again I need to remind myself why blocking assignments are so bad.
A blocking assignment sets the value of a register immediately, whereas a
non-blocking assignment waits until the clock tick to set the value with it’s
new result.</p>

<p>So, tell me, what would happen in the following code,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>

<span class="k">initial</span>	<span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">b</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span></code></pre></figure>

<p>After the first clock tick, what will the value of <code class="language-plaintext highlighter-rouge">b</code> be?  Will it be five,
or will it be ten?</p>

<p>In hardware the result will always be five.  In simulation, the answer is … it
depends.  Specifically, it depends upon which of the two always blocks the
simulator decides to evaluate first.</p>

<h2 id="poor-simulation-model">Poor simulation model</h2>

<p>This one seems to hit the beginner the first time he uses simulation, when the
inputs to his simulation don’t quite match how the real hardware acts.
You can read <a href="/blog/2017/06/10/lost-college-student.html">one students
account</a>
of how this problem bit him here on this site.</p>

<ul>
  <li>
    <p>Buttons may be the most classic example</p>

    <p>Buttons tend to be the first thing a beginner works with.  They are easy and
simple to work with, and seem to impact your design in a very reliable way.</p>

    <p>The beginner quickly learns about buttons, and the next step is a counter.
He wants to know if his counter is working, so he creates an example piece
of code much like the following.  (We’ll assume he gets the synchronizer
right, although this does tend to be rare.)</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">btnled</span><span class="p">(</span><span class="kt">input</span> <span class="n">i_clk</span><span class="p">,</span> <span class="n">i_btn</span><span class="p">,</span> <span class="n">o_led</span><span class="p">);</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="n">i_clk</span><span class="p">,</span> <span class="n">i_btn</span><span class="p">;</span>
	<span class="kt">output</span>	<span class="kt">reg</span>	<span class="n">o_led</span><span class="p">;</span>

	<span class="c1">// Let's synchronize the button, to avoid two issues</span>
	<span class="kt">reg</span>	<span class="n">syncd</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">syncd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">last</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">last</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">syncd</span><span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">value</span><span class="p">,</span> <span class="n">syncd</span><span class="p">,</span> <span class="n">i_btn</span> <span class="o">}</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">value</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">last</span><span class="p">))</span> <span class="c1">// i.e. the button was just pressed</span>
		<span class="n">o_led</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">o_led</span><span class="p">;</span></code></pre></figure>

<p>This beginner will be surprised when his LED doesn’t necessarily toggle on every
button press.  The problem?  Buttons bounce!  Feel free to take a look at <a href="/blog/2017/08/02/debounce-teaser.html">this
article</a> for an
illustration of the problem.</p>

<ul>
  <li>
    <p>I’ve also personally struggled with Xilinx’s ICAPE2 interface</p>

    <p>Yes, I know Xilinx described the interface in their <a href="https://www.xilinx.com/support/documentation/user_guides/ug470_7Series_Config.pdf">Configuration
user’s guide</a>.
But how often have you misunderstood the specification and built your
simulation component to simulate the wrong interface?</p>
  </li>
  <li>
    <p>My own I2C story</p>

    <p>Buried within the repository for my <a href="https://github.com/ZipCPU/wbscope">wishbone
scope</a>, is an
<a href="https://github.com/ZipCPU/wbscope/tree/master/doc/examples/hdmi-eddc">article</a>
about how I once seriously misunderstood the <a href="https://www.i2c-bus.org/specification">I2C
specification</a>.  I built a simulation
model for the wrong specification, and managed to get my design to work with
it.  When I moved to hardware, … it didn’t match like I thought it should.</p>

    <p>That’s all fixed now, though.  You should find
<a href="https://github.com/ZipCPU/wbi2c">my simulation model</a> for
<a href="https://www.i2c-bus.org/specification">I2C</a> fully working … now.</p>
  </li>
  <li>
    <p>Example: a vendor model for an SDRAM didn’t perform under burst access
like the hardware did</p>

    <p>This one hasn’t happened to me yet.  Yet.  However, it follows the same
basic idea.  You have a design that matches a simulation specification,
but that simulation was only partially accurate.  Perhaps it didn’t implement
every mode of the device.</p>

    <p>Either way, you’ll be surprised when your design doesn’t work, and then stuck
debugging your design in hardware–assuming you didn’t immediately get stuck
in <a href="/blog/2017/05/19/fpga-hell.html">FPGA Hell</a>.</p>
  </li>
</ul>

<h2 id="asynchronous-reset-triggered-by-spurious-rf">Asynchronous Reset triggered by spurious RF</h2>

<p>I wouldn’t have believed this one myself if I hadn’t come across it while
browsing Xilinx’s forums.  You can read <a href="https://forums.xilinx.com/t5/PLD-Blog-Archived/That-Dangerous-Asynchronous-Reset/ba-p/12856">the article I found
here</a>.
The basic sum of it is that the reset wire can act as a high frequency antenna,
and so send spurious reset signals through your design.  Ouch.</p>

<p>This just happens to be one more reason to use a synchronous reset within
an <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> design.</p>

<h2 id="failure-to-start-the-design-in-a-known-configuration">Failure to start the design in a known configuration</h2>

<p>Over the years I’ve discovered that values not initialized on a Xilinx device
default to all ones.  They may start out as something different in simulation.
For example, I had one simulation environment that would initialize all values
to zero.  Indeed, the formal tools based upon
<a href="http://www.clifford.at/yosys">Yosys</a>
assume all unspecified memory has an initial value of zero.</p>

<p>This problem also highlights one of the <a href="/blog/2017/10/13/fpga-v-asic.html">differences between FPGA development
and ASIC development</a>:
ASIC designs need that initial reset to set their values.  They have no
problems setting all RAM values to zero or one.  <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>’s on the other hand
truly honor the <code class="language-plaintext highlighter-rouge">initial</code> conditions given in the design.</p>

<ul>
  <li>
    <p>Failure to set initial values for registered outputs</p>

    <p>This is pretty much what I just described: when you don’t give your design
an initial value, it will still start with an initial value–it just might
not be the one you are intending.</p>
  </li>
  <li>
    <p>Failure to match reset values to initial values</p>

    <p>Would it surprise you if I told you this was one of the most common, and
yet simple, bugs I find with formal tools?  It’s so common that I’ve gotten
into a rut testing for it.</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="n">f_past_valid</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">f_past_valid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">f_past_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">||</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="c1">// For each input constrained by an initial or a reset</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">some_input</span> <span class="o">==</span> <span class="n">its_initial_value</span><span class="p">);</span>
		<span class="c1">// .. Repeat as necessary</span>

		<span class="c1">// Likewise for each local register or output</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">some_register</span> <span class="o">==</span> <span class="n">its_initial_value</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Perhaps you’ll find this pattern useful in your own designs as well–it helps
to guarantee that both the reset and the initial value do the same thing.</p>

<p>As another example, on some designs I’ll assume it starts with a reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="k">assume</span><span class="p">(</span><span class="n">i_reset</span><span class="p">);</span></code></pre></figure>

<h2 id="insufficient-test-bench-cases">Insufficient test bench cases</h2>

<p>Sadly, this one was common for me–especially before I started using formal
verification.  Perhaps you may remember the <a href="/blog/2017/10/19/formal-intro.html">problem I had with the test bench
for my initial FIFO
implementation</a>? 
Sure, I had built a test bench for my <a href="/blog/2017/07/29/fifo.html">FIFO</a>, it just didn’t quite test all of
the possible paths through my <a href="/blog/2017/07/29/fifo.html">FIFO</a>’s logic.</p>

<p>This hit me hard with my <a href="/zipcpu/2017/12/28/ugliest-bug.html">first I-cache
design</a> as well.
Sure, the design worked in my simulation test bench. It just didn’t when
one day when I placed it onto the hardware.  It wasn’t the first day I had
placed the cache into hardware either–it had worked before.  What was the
problem?  That is <a href="/zipcpu/2017/12/28/ugliest-bug.html">a
story</a>
in itself.</p>

<p>Perhaps I just don’t have the imagination to think of every way a design
component might be accessed–correctly or incorrectly in order to truly test
every path through a design.</p>

<p>In many ways this isn’t really a failure of simulation to match the
synthesized design in hardware, rather it’s a failure to completely test the
design in simulation.  As a result, the solution is to go back and to
simulate the design in the same way it just failed on the hardware (assuming
you can), and to see if you can try to find the bug.</p>

<p>An even better solution is to turn to formal methods …</p>

<p>I found myself in just this situation this last week: after reading 128MB
less the last four bytes from a flash device, the reader received a bus
timeout error on the very last word.  No, I hadn’t simulated that test
case because … well, who wants to <em>simulate</em> reading 128MB from
a flash device over a slow debugging bus?  That said, it was the only way
I found the problem.  (The bug was mis-configured bus arbiter.  Yes, the
arbiter itself had been formally verified.  It wasn’t the arbiter’s fault, 
from that perspective, I had just hooked it up wrong and never verified the
parent module.)</p>

<h2 id="symbols-left-out-of-the-sensitivity-list">Symbols left out of the sensitivity list</h2>

<p>I don’t normally use sensitivity lists, but let’s see if we can build an
example of this problem.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="k">else</span>
	<span class="n">b</span> <span class="o">=</span> <span class="o">!</span><span class="n">c</span><span class="p">;</span></code></pre></figure>

<p>See the problem?  If <code class="language-plaintext highlighter-rouge">a</code> changes, <code class="language-plaintext highlighter-rouge">b</code> will also change.  However, the simulator
won’t adjust the value of <code class="language-plaintext highlighter-rouge">b</code> if <code class="language-plaintext highlighter-rouge">c</code> changes–even though the value of <code class="language-plaintext highlighter-rouge">b</code> will
change in hardware upon any change of <code class="language-plaintext highlighter-rouge">c</code>.</p>

<h2 id="latches">Latches</h2>

<p>Remember the latch we placed into our <a href="/formal/2018/05/31/clkswitch.html">clock
switch</a> design?  Here’s
what one <a href="https://www.reddit.com/r/FPGA">Reddit</a> user wrote about latches:</p>

<blockquote>
  <p>Latches.  Definitely more of a problem only beginners will run into but
still good to be aware of.  Depending on synthesis settings it may fail
or it may just produce warnings but this was the most common problem I
helped students with when I was a TA for our intro to digital logic class.</p>
</blockquote>

<p>Not familiar with a latch?  Here’s an example:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
	<span class="n">B</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span></code></pre></figure>

<p>Notice how <code class="language-plaintext highlighter-rouge">B</code> isn’t being set on a clock, yet it’s required to hold its
value if <code class="language-plaintext highlighter-rouge">!A</code> is true.  This is a latch.</p>

<p>A latch is what the synthesis tools will infer anytime you don’t set the
value of a combinational result for all combinations.  The rule of thumb I’ve
been taught to make sure you avoid this is to always set the value at the
beginning of the block–then the value is set no matter how ugly the following
logic gets.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">B</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="n">B</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>Another user recommended I beware of the <code class="language-plaintext highlighter-rouge">full_case</code> and <code class="language-plaintext highlighter-rouge">parallel_case</code>
directives.  I’d never heard of these before!  However, you can read more
about misusing these directives <a href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase.pdf">here</a>.</p>

<h2 id="forgetting-to-assign-pin-locations">Forgetting to assign pin locations</h2>

<p>What happens if you don’t assign an output pin to a physical location?  Some
tools will pick a location for you.  How much do you want to bet that they
don’t pick the right location?</p>

<p>A related bug is not forgetting the pin assignment, but rather assigning
the wrong pin to your logic.</p>

<p>The solution?  Always double and triple check your pin assignments.  The master
<code class="language-plaintext highlighter-rouge">xdc</code>, <code class="language-plaintext highlighter-rouge">ucf</code>, <code class="language-plaintext highlighter-rouge">pcf</code> or whatever file is very likely going to need to be changed
for your design from the one given you by the manufacturer of the board.</p>

<h2 id="comparing-with-x-values">Comparing with ‘X’ values</h2>

<p>(False in simulation, might be true in H/W)</p>

<p>I’m told that the ARM development team once got themselves caught in an ugly
way with this bug.  According to the story, that happened some time ago, but
since then the story has become ingrained into their culture: don’t use
<code class="language-plaintext highlighter-rouge">x</code> assignments!</p>

<p>Why not?  Well, a <code class="language-plaintext highlighter-rouge">1'bx</code> value has a different meaning between synthesis and
simulation.  In synthesis, <code class="language-plaintext highlighter-rouge">1'bx</code> is a don’t care–the synthesis tool is allowed
to set the value to whatever it would wish.  In simulation, <code class="language-plaintext highlighter-rouge">1'bx</code> is a
specific value that a register might contain.
(<a href="https://www.veripool.org/wiki/verilator">Verilator</a> doesn’t support <code class="language-plaintext highlighter-rouge">1'bx</code>,
so I don’t use them often.)</p>

<p>What happens when <code class="language-plaintext highlighter-rouge">a=1'bx</code> and <code class="language-plaintext highlighter-rouge">b=1'b0</code>?  <code class="language-plaintext highlighter-rouge">a==b</code> will be false in simulation.
Worse, <code class="language-plaintext highlighter-rouge">a != b</code> will also be false in simulation.  However,
in hardware the result will be tested based upon the actual achieved
voltage value, whether it be a <code class="language-plaintext highlighter-rouge">1</code> or a <code class="language-plaintext highlighter-rouge">0</code>.
See the different result?  Avoid setting any values to <code class="language-plaintext highlighter-rouge">1'bx</code> to keep yourself
from this bug.</p>

<p>You can read more about the problems with <code class="language-plaintext highlighter-rouge">x</code> values
<a href="https://www.researchgate.net/publication/240753489_The_Dangers_of_living_with_an_X_bugs_hidden_in_your_Verilog">here</a>.</p>

<h2 id="tool-problem">Tool problem</h2>

<p>Yes, it is possible that the tools might not work for you.  There are bugs
within most if not all tool suites, they just tend to take a special design
to trigger.  Don’t believe me?  Read the forum posts associated with each
vendor’s tool suite.  Sometimes bugs get fixed.  Sometimes the fixes create
other bugs.  At other times, they are reported and the vendor does nothing.</p>

<h2 id="asynchronous-systems">Asynchronous Systems</h2>

<p>I don’t usually design asynchronous systems, although I have done so once or
twice.  What happens when you need the asynchronous system to operate in an
ordered fashion?</p>

<p>Here’s what one
<a href="https://www.reddit.com/r/FPGA">Reddit</a> user wrote:</p>

<blockquote>
  <p>When you design asynchronous systems with matched delay elements between
each sequential stages.  In that case, logic delay is part of the system
behaviour.  The alternative to synthesis is to use a not synthesizable model
for delay chains based on « transport … after » statements.  Although
I must say, synthesis of asynchronous system is also a pain.</p>
</blockquote>

<h2 id="generics">Generics</h2>

<p>Here’s one I’ve struggled with personally: using one set of top level generic
values (VHDL term for what would be called a <code class="language-plaintext highlighter-rouge">parameter</code> in Verilog) for
simulation, and another for synthesis.</p>

<p>I worry about this one when using formal methods especially.  Sometimes the
design is just too complicated to fully verify–a 12x12 multiply might be such
an example, or a <a href="/dsp/2017/11/10/delayw.html">delay</a>
by 2047 time-steps.  So I’ll limit the design, using a Verilog parameter
(VHDL generic) to a smaller/simpler design that I can then prove–for example,
a delay by 7 time-steps instead of 2047.  I try to
convince myself that the proof will be equivalent, but … will it be?</p>

<h2 id="using-different-source-files-for-simulation-and-synthesis">Using different source files for simulation and synthesis</h2>

<p>I do this all the time.  I simulate the <code class="language-plaintext highlighter-rouge">main</code> module, which is a subset of the
<code class="language-plaintext highlighter-rouge">toplevel</code> module.  I place into my <code class="language-plaintext highlighter-rouge">toplevel</code> all of the hardware specific
items that <a href="https://www.veripool.org/wiki/verilator">Verilator</a>
can’t simulate.</p>

<p>What happens when one of my bugs is in that top level?
You can read about my struggles with that
<a href="/blog/2017/09/14/even-i-get-stuck.html">here</a>.</p>

<p>This is why you want to do everything you can to make certain that the
design you simulate is also the same design you intend to synthesize.</p>

<h2 id="block-rams-with-other-than-power-of-two-sizes">Block RAM’s with other than power of two sizes</h2>

<p>I try to only ever use block RAM’s with a power of two size.  I often forget
why.</p>

<p>Once when I used a non-power of two block RAM, I wrote to an address that wasn’t
in the RAM and crashed <a href="https://www.veripool.org/wiki/verilator">Verilator</a>.
Why?  <a href="https://www.veripool.org/wiki/verilator">Verilator</a> only allocated,
in C++, the number of elements I told it were in the array.</p>

<p>Even if you don’t write beyond the array, you might read and get a different
answer than you were expecting from simulation alone.</p>

<h2 id="vhdl-specific">VHDL Specific</h2>

<p>If you know me, you’ll know I don’t work in VHDL.  Others who do were kind
enough to offer my the following examples specific to VHDL.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">clk'event and clk == '1'</code> doesn’t behave the same between synthesis and
 simulation.  Always use <code class="language-plaintext highlighter-rouge">rising_edge(clk)</code> instead.  (This is another one
 of those issues where <code class="language-plaintext highlighter-rouge">clk</code> might be neither <code class="language-plaintext highlighter-rouge">0</code> nor <code class="language-plaintext highlighter-rouge">1</code>, such as the <code class="language-plaintext highlighter-rouge">1b'x</code>
 example we discussed above.)</p>
  </li>
  <li>
    <p>Forgetting to add <code class="language-plaintext highlighter-rouge">if rising_edge(clk)</code> in a clocked process.  I think this
would then fit under both the latch example above as well as the signals
left out of the sensitivity list.  Feel free to correct me here if I am wrong.</p>
  </li>
  <li>
    <p>Comparisons with a null range vector is “true” in Aldec and “false” in
Synplify (null ranges often occur with extensive us of generics.)</p>
  </li>
  <li>
    <p>Any time a different architecture is used between synthesis and simulation</p>
  </li>
</ul>

<p>Sense a reoccurring theme?</p>

<h2 id="verilog">Verilog</h2>

<p>I’ve been surprised as I’ve worked with Verilog to discover the system model
for a verilator based design is specified to be the same as if all the
files were concatenated together before synthesis, and then that single
concatenated file is synthesized.  A <code class="language-plaintext highlighter-rouge">define</code> in one module can therefore
impact another–the modules are no longer independent.  If multiple files
define the same value differently, and then the order of the files changes
between simulation and synthesis … then you’ll
get different results between the two.</p>

<p>This was not something I was expecting, and I was a bit surprised to learn it.
Once it was explained to me, it made sense, but it sure seems like a backwards
way to do things–especially for someone like me who was first trained in <code class="language-plaintext highlighter-rouge">C</code>.</p>

<h2 id="systemverilog">SystemVerilog</h2>

<p>One user wrote the following:</p>

<blockquote>
  <p>I’ve found when using some of the more new SystemVerilog features
[that] simulation and synthesis can differ.  I read about unions in
Vivado being an issue here.</p>

  <p>Personally using unpacked arrays and passing them between modules and
accidentally writing something like this:</p>
</blockquote>

<figure class="highlight"><pre><code class="language-text" data-lang="text">moduleA has output logic bus [3:0]
moduleB has input bus[4]
// connection between them was logic[3:0]</code></pre></figure>

<blockquote>
  <p>Modelsim and Quartus produced different results</p>
</blockquote>

<p>Since I don’t use any of SystemVerilog’s special features beyond the
formal properties we’ve already discussed on this blog, I haven’t come across
this one personally yet.  For those who do use SystemVerilog, look out for
this bug!</p>

<h2 id="hardware-failures">Hardware Failures</h2>

<p>Here’s a set of problems most software engineers will be surprised by: hardware
failures.  Why do I say it that way?  Because with all my own years of working
on software, I could reliably depend upon the fact that the hardware always
worked–unless in very rare cases it didn’t.  Sherlock Holmes’ logic makes the
most sense here, “Once you eliminate the impossible, whatever remains, no
matter how improbable, must be the truth.”  (Arthur Conan Doyle)</p>

<p>That said, here are two hardware problems I’ve suffered from.</p>

<ul>
  <li>
    <p>Noisy or insufficient power supply</p>

    <p>In one RF design, the noisy power supply crept through the device into the
powered antenna and … well, the result wasn’t the pretty sampled data
I was expecting.</p>

    <p>In another design, this one for motors, the design failed because the motor
PMod required more power than the board could supply.  In that case, the
FPGA was powered from a Raspberry Pi and the power supply just didn’t cut
it for what we needed.</p>
  </li>
  <li>
    <p>PLL’s haven’t converged</p>

    <p>Remember when I <a href="/blog/2017/09/14/even-i-get-stuck.html">wrote about this
earlier</a>?</p>

    <p>At one time I assumed that PLL’s will <em>always</em> converge.
Then I tried to a design for the iCE40 that used a PLL.  No, I didn’t use
<code class="language-plaintext highlighter-rouge">icepll</code>–I should have.  Instead, I just assumed that the PLL converged.
For the life of me, I couldn’t figure out why my design wasn’t working.
I spent months scratching my head until some friends at Digilent
were kind enough to provide me with one of their <a href="https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator/">Digital
Discovery</a>’s.
Yes, it took that external logic analyzer for me to figure out what the
problem was.</p>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>You may want to keep this list in your back pocket, and remember these reasons
the next time your design doesn’t work.  Some of these reasons require good
desk checking: check your pin outs, double check your timing, etc.  Other
items require an external scope, such as the PLL that hadn’t converged.
Still others need a good internal scope, such as when the simulation model
doesn’t quite match how the hardware actually works.  Finally, it might also
be that you haven’t fully simulated the design.</p>

<p>The bottom line is that hardware design isn’t like software design.  There are
a lot more things that can go wrong, and figuring out the problem can require
more sleuthing than you plan upon.</p>

<p>This is also why I like working with hardware.  Sure, it’s a greater challenge,
but so too is the joy and excitement when everything works as designed on the
hardware.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>There is a path which no fowl knoweth, and which the vulture's eye hath not seen (Job 28:7)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
