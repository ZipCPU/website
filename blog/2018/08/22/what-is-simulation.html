<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>RE: Building a simulation for my design?  What does that mean?</title>
  <meta name="description" content="Recently, a student wrote to me:">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2018/08/22/what-is-simulation.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">RE: Building a simulation for my design?  What does that mean?</h1>
    <p class="post-meta"><time datetime="2018-08-22T00:00:00-04:00" itemprop="datePublished">Aug 22, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Recently, a student wrote to me:</p>

<blockquote>
  <p>Hello.  I am a student taking my first digital design course, and I stumbled
upon your website.  Specifically, <a href="/blog/2017/06/02/design-process.html">this
article</a>.</p>

  <p>What exactly is meant here when you talk about building a simulation for
your design?</p>

  <p>(I’ll keep the student’s name anonymous.)</p>
</blockquote>

<table align="center" style="float: right"><caption>Fig 1: Typical Student Design Process</caption><tr><td><img src="/img/student-design-process.svg" alt="" width="180" /></td></tr></table>

<p>He’s specifically talking about
<a href="/blog/2017/06/02/design-process.html">an article</a>
where I discuss the student design process, as shown in Fig 1. on the right.
If you haven’t read
<a href="/blog/2017/06/02/design-process.html">that article</a>,
I would commend it to you.</p>

<p><a href="/blog/2017/06/02/design-process.html">The article</a>
recommends having a valid/working <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a> before ever moving
to hardware.  It also recommends using some form of
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a> and/or
<a href="/blog/2017/06/08/simple-scope.html">internal logic analyzer</a>
for debugging designs that have moved to hardware.  About the time the article
was written, I was mentoring another college student who had been
struggling through to build a design of his own.  When he came across
<a href="/blog/2017/06/02/design-process.html">this article</a>,
he was kind enough to respond with <a href="/blog/2017/06/10/lost-college-student.html">his own
experiences</a>.</p>

<p>Sadly, <a href="/blog/2017/06/10/lost-college-student.html">this
experience</a>
of frustration is common.  It is so common, that I coined the phrase
“<a href="/blog/2017/05/19/fpga-hell.html">FPGA Hell</a>” to describe it,
and then <a href="/fpga-hell.html">dedicated my blog</a> to keeping
students out of <a href="/blog/2017/05/19/fpga-hell.html">FPGA
Hell</a>.  Much to
my surprise, I’ve since spoken with many professionals who have been
interested in these topics as well.  Apparently,
<a href="/blog/2017/05/19/fpga-hell.html">FPGA Hell</a>
in the business (i.e.
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>)
world can easily translate into <a href="/blog/2017/10/13/fpga-v-asic.html">millions of lost
dollars</a>–and often
lost jobs as well.</p>

<p>But let me come back to the original question: what do I mean when I talk about
<a href="/blog/2017/06/23/my-dbg-philosophy.html">building a simulation for a
design</a>?  There
are two types of <a href="https://en.wikipedia.org/wiki/Simulation">simulations</a>
I have used in my designs.</p>

<ol>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Simulation">Simulation</a> in this context can
reference a quick bench test of a module, that attempts to verify the module
logic works.</p>

    <p>I used to do this with my components a lot.  I don’t do this as much any
more.  Why not?  My own efforts just weren’t very effective at finding bugs.</p>

    <p>That said, this remains my approach when <a href="/dsp/2017/07/24/dsp-debugging.html">debugging any DSP
design</a>.</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Simulation">It</a> can also refer to an
integrated test of the entire design and all of its pieces, together with
<a href="https://en.wikipedia.org/wiki/Co-simulation">co-simulations</a> of all of the
attached pieces of hardware.  I do this before moving to actual hardware.</p>

    <p>I continue this practice religiously, and every system level project I have
has a full simulation capability.  Depending on the project this simulation
can either be found in the <code class="language-plaintext highlighter-rouge">bench/cpp</code> directory or a similar <code class="language-plaintext highlighter-rouge">sim/verilated</code>
directory.</p>
  </li>
</ol>

<p>I’ve discussed <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a> many
times over on <a href="">the blog</a>, providing both
examples of <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a>, and
discussing how I put <a href="https://en.wikipedia.org/wiki/Simulation">simulations</a>
together.  For example:</p>

<ul>
  <li>
    <p>I use <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
for all of my simulating needs.  We’ve discussed how to build a
<a href="/blog/2017/06/21/looking-at-verilator.html">verilator</a>-based
bench test already on this blog.</p>
  </li>
  <li>
    <p>We’ve also discussed <a href="/dsp/2017/11/04/genfil-tb.html">how to test a DSP filter
design</a> using
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
as well.</p>
  </li>
  <li>
    <p>The same applies to testing a
<a href="/dsp/2017/10/02/cordic-tb.html">CORDIC</a>
algorithm that can evaluate sine and cosine functions.</p>
  </li>
  <li>
    <p>Did I mention discussing how to build a simulation for a
<a href="/dsp/2017/12/14/logic-pll.html">logic PLL</a>?</p>
  </li>
  <li>
    <p><a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
allows me to integrate C++ <a href="https://en.wikipedia.org/wiki/Co-simulation">co-simulation</a>
code into my designs.  (<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
is not necessarily unique in this fashion, there are other approaches, however
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
is most definitely my chosen approach.)  Examples include:</p>

    <p>– A <a href="https://github.com/ZipCPU/wbuart32">serial port</a> that you can connect
 to using <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP/IP</a>, such as <code class="language-plaintext highlighter-rouge">telnet localhost &lt;port #&gt;</code>.  You can read about an example using this approach <a href="/blog/2017/06/26/dbgbus-verilator.html">here</a>.</p>

    <p>– A <a href="https://github.com/ZipCPU/icozip">parallel port</a> that takes the place
 of the serial port in my design for the <a href="http://www.icoboard.org">ICO Board</a></p>

    <p>– A <a href="https://github.com/ZipCPU/vgasim">VGA simulator</a>: includes both
 <a href="https://github.com/ZipCPU/vgasim/blob/master/bench/cpp">source</a> (i.e. a camera)
 and <a href="https://github.com/ZipCPU/vgasim/blob/master/bench/cpp">sink</a> (i.e. a window
 on your screen)
 <a href="https://en.wikipedia.org/wiki/Co-simulation">co-simulators</a>.</p>

    <p>– An <a href="https://github.com/ZipCPU/wbpmic">A/D simulator</a> for <a href="http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain">this
 microphone</a> PMod.</p>

    <p>– A <a href="https://opencores.org/project/qspiflash">flash simulator</a>.  This has
 been so useful, I’ve reused it just about all of my
 <a href="/about/zipcpu.html">ZipCPU</a> projects</p>

    <p>– A <a href="https://github.com/ZipCPU/sdspi">SD-Card simulator (SPI mode only)</a>.
 When I finally get to implementing Linux on the
 <a href="/about/zipcpu.html">ZipCPU</a>, being able to simulate an
 SD card capability will be very important.</p>

    <p>– An <a href="https://github.com/ZipCPU/wbi2c">I2C simulator</a>.  This was a necessary
 part of my (still incomplete) <a href="https://github.com/ZipCPU/videozip">HDMI
 design</a>, since modern monitors are
 supposed to respond to a query and reply with the video formats they support.
 (The I2C part of the design works.)</p>

    <p>– <a href="https://github.com/ZipCPU/openarty">One of my designs</a> even includes a
 <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/gpsclock_tb.v">GPS PPS signal
 simulator</a>,
 for testing my <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/gpsclock.v">GPS time-tracking
 algorithm(s)</a>.</p>
  </li>
  <li>
    <p>I am a firm believer in building a
<a href="https://en.wikipedia.org/wiki/Simulation">simulation</a> that you can interact
with using <a href="/blog/2017/06/17/why-network-debugging.html">a TCP/IP network
port</a>.
This allows you to test/verify interacting with a design using your
production software.</p>
  </li>
  <li>
    <p>In <a href="/zipcpu/2018/02/12/zbasic-intro.html">one blog post</a>
I discuss how to run the <a href="/about/zipcpu.html">ZipCPU</a>
in an environment using a simulated serial port.</p>

    <p><a href="/zipcpu/2018/02/12/zbasic-intro.html">This blog post</a>
also includes instructions for playing
<a href="https://github.com/ZipCPU/tttt">4x4x4 Tic-Tac-Toe</a> on the
<a href="/about/zipcpu.html">ZipCPU</a>–<em>running in simulation only</em>.
If you’ve never tried <a href="https://github.com/ZipCPU/tttt">4x4x4 Tic-Tac-Toe</a>, I
challenge you to try to beat the computer at the game.  It’s not unbeatable,
but the artificial intelligence used by that design is pretty good.</p>
  </li>
  <li>
    <p>The <a href="https://github.com/ZipCPU/vgasim">VGA Simulation</a> project contains
code for two <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a>
components within it.  (Both are
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
based).</p>
  </li>
</ul>

<table align="center" style="float: right"><caption>Fig 2: VGA Simulation, displays on a window of your screen</caption><tr><td><img src="/img/vgasim.png" alt="" width="360" /></td></tr></table>

<ol>
  <li>The <a href="https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/main_tb.cpp">main_tb</a>
  simulator simulates an <a href="https://github.com/ZipCPU/vgasim/blob/master/rtl/wbvgaframe.v">RTL
  design</a>
  that <a href="https://github.com/ZipCPU/vgasim/blob/master/rtl/imgfifo.v">reads from a frame
  buffer</a> in
  <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/rtl/memdev.v">memory</a>
  and draws the contents of that frame buffer to the screen.</li>
</ol>

<p>You can see an example of the window this draws on my screen in Fig 2 on the
  right.</p>

<p>The importance of having such a video <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a> capability can not be
  understated.  It is not that uncommon to have a bug in the graphics
  produced by a video-enabled design.  Just because you can see that bug on
  the screen doesn’t mean you can then find it within your design.</p>

<p>By being able to run the design in a desktop application (i.e. in a
  <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
  <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a>)
  that recreates all of your logic, and saves every signal to a <a href="/blog/2017/07/31/vcd.html">trace
  file</a>
  that can later be examined, finding and fixing bugs doesn’t become easy,
  <em>it becomes possible</em>.</p>

<table align="center" style="float: left"><caption>Fig 3: Creating a simulated video input</caption><tr><td><img src="/img/camsim.png" alt="" width="360" /></td></tr></table>

<ol start="2">
  <li>The other video <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a> is one I call
   <a href="https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/simcheck.cpp">simcheck</a>.
   This <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a> reads the 640x480 pixels at the top left of your screen,
   and creates Verilog signals from that portion of the screen that can then
   be ingested into your design.  (The frame size is configurable, as is the
   rest of the <a href="https://en.wikipedia.org/wiki/XFree86_Modeline">mode line</a>.)</li>
</ol>

<p>If you just route these values into the other video
   <a href="https://en.wikipedia.org/wiki/Co-simulation">simulator</a>,
   you can see the video output within a window on your desktop, as shown in
   Fig 3 on the left.  If you place that window near the same upper-left corner
   of your screen, you’ll get a cool recursive effect–also shown in Fig 3 on
   the left.</p>

<p>Perhaps the best way I could describe all of this would be to point out a
<a href="https://github.com/ZipCPU/fftdemo">spectrogram</a> design I recently built.
The <a href="https://github.com/ZipCPU/fftdemo/blob/master/bench/cpp/main_tb.cpp">simulation for this
demo</a>
includes the <a href="https://github.com/ZipCPU/wbpmic">A/D simulator</a> I mentioned
above, as well as the <a href="https://github.com/ZipCPU/vgasim">VGA output simulator</a>.
Using this
<a href="https://github.com/ZipCPU/fftdemo/blob/master/bench/cpp/main_tb.cpp">simulation</a>,
I can capture any
<a href="/blog/2017/07/31/vcd.html">trace</a>,
and see every bit of logic flowing through my design
as it reads from a (simulated) A/D device, <a href="https://github.com/ZipCPU/fftdemo/blob/master/rtl/subfildown.v">filters and downsamples</a> the signal,
takes a <a href="https://github.com/ZipCPU/dblclockfft">Fourier transform</a>,
and then plots the result onto a window of my screen in a scrolling fashion.</p>

<p>If I want, I can then even test other signal processing approaches, such as the
one shown below in Fig 4.</p>

<table align="center" style="float: none"><caption>Fig 4: High Resolution FFT Window Processing</caption><tr><td><img src="/img/tweets/fq-swepttone.png" alt="" width="640" /></td></tr></table>

<p>This is what I mean by <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a>:
being able to repeat and test the entire design using software alone.</p>

<p>Further, all of these <a href="https://en.wikipedia.org/wiki/Simulation">simulation</a>
components are available for student use (and more):
they are (mostly) licensed under
<a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GPLv3</a>.
(Some are licensed under LGPLv3.)  If your instructor/advisor allows you to,
please feel free to try them and use them in one of your own projects.</p>

<h2 id="formal-verification">Formal Verification</h2>

<p>Since writing the original article on <a href="/blog/2017/06/02/design-process.html">The Actual Design
Process</a>, I’ve come
across a new technique so powerful when it comes to finding bugs that my
own practices have since changed and changed significantly.  Instead of
<a href="/blog/2017/06/23/my-dbg-philosophy.html">first simulating any design
components</a>, I now
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
every design component.  I use this new technique in place of bench testing:
it takes less work to do, finds bugs faster, and doesn’t require searching
through GB of
<a href="/blog/2017/07/31/vcd.html">traces</a> to find any bugs.</p>

<p>Why did I change?  I changed because none of my bench tests ever <a href="/blog/2017/10/19/formal-intro.html">tested
enough of the design space</a>.
This meant that I would then integrate design
components together that I <em>thought</em> were working, only to <a href="/zipcpu/2017/12/28/ugliest-bug.html">later discover the
design as a whole wasn’t working</a>.</p>

<p>Perhaps this would be during an integrated
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>-enabled
<a href="https://en.wikipedia.org/wiki/Simulation">simulation</a>.  However, in that
environment, I’d find myself searching through 1-10GB
<a href="/blog/2017/07/31/vcd.html">trace</a> files trying to find a
needle (the bug) in a haystack (the
<a href="/blog/2017/07/31/vcd.html">trace</a>).
Worse, I might’ve tried to place the design onto an 
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
where I no longer have the same visibility into the design in order to
investigate any bugs.</p>

<p>On the other hand, when using a
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
approach, such as the one enabled by
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>,
I’d find (and fix) many more bugs than I would’ve ever dreamed of testing while
trying to drive a simulation bench/test.  Even better, I can normally find
these bugs with between only 10-150 time-steps, and <a href="/blog/2017/07/31/vcd.html">trace
files</a> less than 100kB in size.</p>

<p>Having used
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>,
do I still use
<a href="https://en.wikipedia.org/wiki/Simulation">simulation</a>?  Absolutely!
Although I’ve <a href="/formal/2018/04/23/invariant.html">discussed how to formally verify the aggregation of multiple
design components</a>,
I have yet to learn how to do this reliably and in general with large
system level designs.</p>

<p>That said, if you’ve never tried <a href="/blog/2017/10/19/formal-intro.html">formal
methods</a>,
then let me invite you to try out
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>.
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a> is a free and
open-source program that can be used to formally verify a Verilog design.
Not only are there <a href="https://github.com/YosysHQ/SymbiYosys/tree/master/docs/examples">several example
designs</a>,
in the <a href="https://github.com/YosysHQ/SymbiYosys">SymbiYosys repository</a>,
but you can also find examples in many of <a href="https://github.com/ZipCPU">my own
repositories</a>.  Look in the <code class="language-plaintext highlighter-rouge">bench/formal</code>
subdirectory for any
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
scripts–those are the files that end in .sby.</p>

<p>Thank you for that excellent question!</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Thou therefore which teachest another, teachest thou not thyself?  thou that preachest a man should not steal, dost thou steal? (Rom 2:21)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
