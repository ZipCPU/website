<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>How to build a SPI Flash Controller for an FPGA</title>
  <meta name="description" content="Fig 1. The ICO board">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2018/08/16/spiflash.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">How to build a SPI Flash Controller for an FPGA</h1>
    <p class="post-meta"><time datetime="2018-08-16T00:00:00-04:00" itemprop="datePublished">Aug 16, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. The ICO board</caption><tr><td><img src="/img/icoBoard.Vorne.1.1.jpg" alt="Picture of an ICO Board" width="360" /></td></tr></table>

<p>Perhaps <a href="/formal/2018/07/21/zipcpu-icoboard.html">you may
remember</a> that
I’ve been working to port the <a href="/about/zipcpu.html">ZipCPU</a>
to an <a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> HX8k
platform: the <a href="http://www.icoboard.org">ICO board</a>.  I like to boast that the
<a href="/about/zipcpu.html">ZipCPU</a> was designed for low logic
applications, and the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> is certainly a
low logic chip.  While the <a href="/about/zipcpu.html">ZipCPU</a>
isn’t the <em>smallest</em> processor out there, there are some forth processors
that are much smaller, it does fit nicely with room to spare on the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> 8k.</p>

<p>However, if you want a design that starts immediately upon power up, or if you
want more memory than is available in 8kB of block RAM or (in this case) even
in 128kB of <a href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a>,
then you need access to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>.
Why?  First, <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a> is
non-volatile, so anything that reads from it can do so immediately upon
power up.  Second, most
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>’s <em>need</em> a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip to store their design
within, so <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips are a
common addition on <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> boards.  Third,
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
is fairly cheap: a single 16MB
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip can sell for as little as $1 on
<a href="https://www.digikey.com">Digikey</a>.  Given that my
<a href="/about/zipcpu.html">ZipCPU</a> design logic for the
<a href="http://www.icoboard.org">ICO board</a> only requires about
132kB of memory, that leaves me with <em>lots</em> of memory to play with … if I
just had a simple <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
controller.</p>

<p>I also had another reason for this project as well: I wanted to learn about
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog sequences</a>,
and whether or not they could be used to <a href="/blog/2017/10/19/formal-intro.html">formally
verify</a> a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>.
Yes, I had access to the full commercial (<a href="http://www.verific.com">Verific</a>
enabled) version of <a href="http://www.clifford.at/yosys">yosys</a>
to do this.  But I wanted to see how useful this full version would be when
it came to designing a new/better <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller.</p>

<p>So let’s see what it takes.</p>

<h2 id="lessons-learned-from-other-flash-controllers">Lessons learned from other flash controllers</h2>

<p>When I start any new design, my first step is to download the
<a href="https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view">schematic</a>
for the board that I have, and data sheets for all of the parts.  In this case, 
the <a href="http://icoboard.org">ICO board</a> has a <a href="http://www.cypress.com/file/177961/download">Cypress S25FL127S 128 Mbit
(16MByte) chip</a>
connected to the <a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
I then spend some time reading the specifications and studying the
<a href="https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view">schematic</a>
before building anything.</p>

<p>In this case, by the time I came to
<a href="http://icoboard.org">this board</a>’s
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
I had already built several
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
controllers before.</p>

<table align="center" style="float: left"><caption>Fig 2. A Basys3 board</caption><tr><td><img src="/img/Basys3.png" alt="Picture of an Basys3 Board" width="360" /></td></tr></table>

<ol>
  <li>
    <p>The first <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller
I ever built was for the <a href="https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/">Basys-3 board</a>.
This board had a
<a href="http://www.cypress.com/file/196861/download">Spansion S25FL032P</a> 4MB
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
Since it was my first <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://opencores.org/project/qspiflash">controller</a> design, my goal was
to design something that could do everything:</p>

    <p>– It could read the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
   at both high (QSPI) and low
   (<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>) speeds</p>

    <p>– It could read the
   <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>’s internal
   configuration register in order to determine if the QSPI
   mode was even enabled</p>

    <p>– It could both erase and program the
   <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a></p>

    <p>– It could be used for reading the vendor identification words back from
   the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, and</p>

    <p>– It could be used for reading the status register and/or writing the
   configuration register of the
   <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

    <p><a href="https://opencores.org/project/qspiflash">This</a> was a great general
purpose <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller,
and I’ve used it many times since.  However, all of this extra logic has
consequences when you want to place your design on a small board.  How bad?
<a href="https://opencores.org/project/qspiflash">It</a> consumed about 1263
of the 7680 cells on an
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>,
or about 16% of the entire
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> logic.</p>

    <p>The other problem I had with this design was when I tried to place it onto
the Spartan 6/LX4 of the <a href="https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module">CMod
S6</a>.
Sure, there was plenty of room for the
<a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v">controller</a>
and the <a href="/blog/2017/06/05/wb-bridge-overview.html">debugging
bus</a>
I was using at the time–there just wasn’t much room for anything else.</p>
  </li>
</ol>

<table align="center" style="float: right"><caption>Fig 3. An Arty-A7 Board</caption><tr><td><img src="/img/arty-board.png" alt="Picture of an Arty Board" width="360" /></td></tr></table>

<ol start="2">
  <li>
    <p>Sometime later I decided I wanted to build a <em>high speed</em>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller, so that I
could push <a href="https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists">Digilent’s Arty</a>
up to a system clock rate of 200MHz.  Why 200MHz?
Because I had mistakenly thought this was the clock speed I’d need to use
to interact with the <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>
on board.  When I realized I <a href="https://opencores.org/project/wbddr3">couldn’t
interact</a> with the
<a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">SDRAM</a>
any faster than about 82MHz, I abandoned <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">this
controller</a>
and never used for any other projects.</p>

    <p>Still, if the <a href="http://opencores.org/project/qspiflash">last controller</a>
was full featured,
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">this one</a>
was even more so.
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">It</a>
not only allowed you to read and write any of several configuration
registers, it would also allow you to read and write the one-time
programmable (OTP) ROM.  Further, since I wanted this to run at 200MHz,
there was a lot of
<a href="/blog/2017/08/14/strategies-for-pipelining.html">pipelining</a>
(and extra latency) to <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">this controller</a>.</p>

    <p>In hind sight, <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">this controller</a>
was a boat anchor.  It’s bloated with features I never used and as a result
was way too big for the job.</p>
  </li>
</ol>

<table align="center" style="float: left"><caption>Fig 4. A Cmod S6 board</caption><tr><td><img src="/img/cmods6.png" alt="Picture of a CMod S6" width="360" /></td></tr></table>

<ol start="3">
  <li>
    <p>However, when I needed to upgrade the
<a href="/about/zipcpu.html">ZipCPU</a> in my
<a href="https://github.com/ZipCPU/s6soc">S6SoC design</a> so that
it would support 8-bit bytes (the
<a href="/about/zipcpu.html">ZipCPU</a> was originally a 32-bit byte
architecture), I needed to find <a href="/blog/2017/06/12/minimizing-luts.html">spare
LUTs</a>
anywhere I could.  2,400 6-LUTs isn’t a lot of room for a multi-processing
<a href="/about/zipcpu.html">CPU</a>, and so I had to strip
everything out that I could.</p>

    <p>The first thing to go was everything but the read capability from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/wbsqspiflash.v">controller</a>.
That removed 30% of the logic in the controller.</p>

    <p>It wasn’t enough.</p>

    <p>Then I stepped back and realized that I would only ever run the
<a href="/about/zipcpu.html">ZipCPU</a>
from an already programmed
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, and that all I ever
<em>really</em> needed from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
was the ability to read from it.  I didn’t need to be able to read
the status register, the configuation register, the vendor’s ID, or anything
else: I just needed to read the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>.</p>

    <p>I also needed speed.</p>

    <p>So I created a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
<a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v">controller</a>
that used the Spartan 6’s DDR capability so that it could read
from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> at the system
clock speed.  This
provided a rough 2x improvement in speed.  Further, the rewrite to create
this capability, and this capability alone dropped the
<a href="/blog/2017/06/12/minimizing-luts.html">number of LUTs</a>
used by the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> from
(roughly) 569 down to about 100 or so.</p>

    <p>(These numbers are approximate because
<a href="http://www.clifford.at/yosys">yosys</a> doesn’t yet pack
<a href="https://www.xilinx.com">Xilinx</a>
LUT’s together, but they do give an idea of usage.)</p>

    <p>Since <a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v">this
controller</a>
offered only a read capability and nothing more, I
called it my <a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v"><code class="highlighter-rouge">qflashxpress</code></a> controller.</p>
  </li>
</ol>

<table align="center" style="float: right"><caption>Fig 5. A TinyFPGA Bx</caption><tr><td><img src="/img/TinyFPGA-BX.png" alt="Picture of a TinyFPGA BX baord" width="120" /></td></tr></table>

<ol start="4">
  <li>
    <p>I recently started working on a fourth
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">controller</a>
modeled after this last one, but using the Dual SPI read mode of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  <a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">This
controller</a>
is designed to support the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>
on the <a href="https://tinyfpga.com">TinyFPGA BX</a>.  However, on my pre-production
version of the <a href="https://tinyfpga.com">TinyFPGA BX</a>, only the MISO and MOSI
lines are connected to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, so the best/fastest I
could ever do is Dual SPI which would only allow me to read/write two
bits at a time.  (I have been assured that this has been fixed for the
production versions.)</p>

    <p>Unlike the previous <a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v">qflashxpress
controller</a>,
I wanted the erase/program capability back.  Rather
then teach the HDL controller all of the necessary states associated with
erasing and reprogramming a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, I initially created
a bit banging port that could override the natural logic of the port.</p>

    <p>The more I thought this through, though, the more I realized that bit banging
over the <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus</a>
would be horrendously inefficient.  Better yet, the
code already had the capability to send data to and receive data from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, why not just
adjust the configuration access so that it can command an 8-bit transfer?</p>
  </li>
</ol>

<p>That leads me to the basic <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
I want to discuss today.</p>

<p>Why do I need a new <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>?
For a couple of reasons.  The first and perhaps more important is
the reality of how the <a href="http://www.icoboard.org">ICO board</a> was wired.</p>

<table align="center" style="float: none"><caption>Fig 6. ICO Board hardware overview</caption><tr><td><img src="/img/ico-hwoverview.svg" alt="Overview of the ICO board's hardware architecture" width="640" /></td></tr></table>

<p>In order to make certain that both the <a href="https://www.raspberrypi.org">Raspberry
Pi</a> <em>and</em> the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> could
control the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory, the
memory was routed through a
<a href="https://www.latticesemi.com/Products/FPGAandCPLD/MachXO2">MachXO2</a> chip
as a traffic controller.  However, the
<a href="https://www.latticesemi.com/Products/FPGAandCPLD/MachXO2">MachXO2</a> as wired
has no capability of dynamically controlling pin direction–the pins can only
ever go one way–either master in and slave out (MISO), or master out and
slave in (MOSI).  In other words,
any <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">flash controller</a>
for the <a href="http://www.icoboard.org">ICO board</a> can only ever use the traditional
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> mode, and
thus any DSPI or QSPI enabled controller will only consume excess and unused
logic in an already tight space.</p>

<p>All this is to say that this is my now a fifth generation
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
for me.  I’ve also learned along the way what’s important in a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>:</p>

<ol>
  <li>
    <p>First and foremost, the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>:
must be able to read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  It must do this
function well and fast, since this is its purpose for being.  As you’ll
see, with no other logic this will cost us 147 of the 7680 cells on the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>.</p>

    <p>If I wanted, I could stop here.  Nothing more is really required.</p>
  </li>
  <li>
    <p>Second, as an optional performance improvement, it should be able to read
data from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> in
long strings of uninterrupted transactions.
Adding this logic to the controller will eventually cost us another 88
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> logic
cells.</p>
  </li>
  <li>
    <p>Third, as a second optional enhancement, it needs to support a single
configuration register providing access to the rest of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>’s
capabilities without burdening the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
with unnecessary features.  This final feature will cost an additional
38 logic cells, bringing our entire total up to 273 logic cells out of
7680, or about 3% of the entire design.</p>

    <p>This is a reasonable usage number for our purposes.</p>
  </li>
</ol>

<p>That’s <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">the controller</a>
we’ll examine today.</p>

<h2 id="basic-spi">Basic SPI</h2>

<p>If you are not familiar with the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">Serial Peripheral Interconnect
(SPI)</a> means
of communicating between digital components, then let me recommend the
<a href="https://www.fpga4fun.com/SPI.html">SPI article on fpga4fun.com</a>.  It’s short,
and it explains a lot of good details about the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI
protocol</a>
that you might find valuable.  In sum, it describes what can be a shared bus,
with typically a single master and many slaves, operating over a
synchronous (i.e. clocked) interface.</p>

<table align="center" style="float: none"><caption>Fig 7. A basic SPI transaction</caption><tr><td><img src="/img/spi-raw.svg" alt="Wiring diagram showing a SPI transaction" width="780" /></td></tr></table>

<p>The basic wires associated with this interface are:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">CS_n</code>, a ‘negative logic’ chip select sometimes called <code class="highlighter-rouge">SS</code> for the “slave
select” line.  This is the one line that is unique to each bus slave.
It is used to create a capability whereby multiple chips can have access to
the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
bus at the same time.  The “master” simply selects the one chip it is
interested in.  The other chips are then required to place their output
pin into a high impedance state and to ignore any transactions for which
they are not selected.</p>

    <p>This means that anytime <code class="highlighter-rouge">CS_n</code> is high, the chip of interest is not selected
and all of other wires are “don’t cares”.</p>

    <p>The <code class="highlighter-rouge">CS_n</code> signal is also be used for synchronization.  Pulling this wire
low (active) signals to the slave the beginning of a transaction, and
hence the slave knows which bit is the “first” bit of the transaction packet.</p>

    <p>Today, we’ll be focusing on the interaction associated with a single chip.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">SCK</code> is the serial clock.  Since this is a clocked interface, <code class="highlighter-rouge">SCK</code> provides
that clock.  The
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol allows for several definitions of how this clock needs to be
implemented, so check the chip you wish to interface with to double check
for example the polarity and phase of the clock signal that it is expecting.</p>

    <p>For our implementation below, we’ll insist that <code class="highlighter-rouge">SCK</code> be high any time
<code class="highlighter-rouge">CS_n</code> is inactive, even though technically this is a “don’t care” signal
in such cases.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">MOSI</code>.  I pronounce this wire as “MOH-see”, although it’s technically the
acronymn, “Master Out Slave In”.  Some chips will call this wire SDI for
Slave Data In or even just SI for Slave Input.  This is the one wire
running from the master to all of the
slaves containing information coming from the master.</p>

    <p>As with the clock, pay attention to your chips specification of this signal.
We’ll treat this signal today as a signal that can only change on the
negative edge of <code class="highlighter-rouge">SCK</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">MISO</code>, or “MEE-soh” as I like to pronounce it, is the “Master In, Slave Out”
wire–a single wire interface shared among all
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
slaves and containing the data being returned from the selected slave device.
Some chips will call this wire SDO for Slave Data Out, or even SO for Slave
Output.  All of these terms refer to the same basic wire.</p>

    <p>Check the specification of the chip you are working with for details on this
signal, but from my experience this signal tends to change some number of <code class="highlighter-rouge">ns</code>
following the last negative <code class="highlighter-rouge">SCK</code> edge.  It should be stable whenever <code class="highlighter-rouge">SCK</code>
is high, as long as you don’t make <code class="highlighter-rouge">SCK</code> run too fast,
so you can read it any time <code class="highlighter-rouge">SCK</code> is high.</p>
  </li>
</ul>

<p>These are the basic signals we’ll be working with.</p>

<p>A <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> doesn’t typically use the
full interface capabilities, however.  Instead, every
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol I’ve read about has actually been a
<a href="https://en.wikipedia.org/wiki/Simplex_communication">Simplex</a>,
or one-way, protocol.  The basic
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
transaction involves sending an 8-bit command, followed by any command specific
arguments (if any–depends upon the command), after which the slave will
return some kind of response.  In no part of this process are both <code class="highlighter-rouge">MISO</code> and
<code class="highlighter-rouge">MOSI</code> lines containing valid data going in opposite directions at the same
time.
Either the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
is sending data to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip,
or the data is going in the reverse direction.</p>

<table align="center" style="float: none"><caption>Fig 8. SPI for Flash is a Simplex Protocol</caption><tr><td><img src="/img/spi-simplex.svg" alt="Wiring diagram, showing a simplex SPI transaction--MISO is unsed during command, MOSI is unused during a response" width="780" /></td></tr></table>

<p>If you examine the
<a href="http://www.cypress.com/file/177961/download">specification</a>
for the <a href="http://www.cypress.com/file/177961/download">Cypress Flash</a>
device on the
<a href="http://www.icoboard.org">ICO board</a>, and look closely through it, you’ll
quickly discover that all transactions are composed of sequences of octets
(8-bits)–just like we discussed above.  This is common among
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> based
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips.</p>

<p>Those first 8-bits of the transaction, though, are the important ones.  Hence
the <a href="http://www.cypress.com/file/177961/download">spec</a>
outlines all the different commands that can be started from any 8-bit
value.  The command set is rather long, though, stretching across both
page 109 and 110–so I’ll only reference it here.  Further, there’s a whole
chapter devoted to walking through each of the commands in detail.</p>

<table align="center" style="float: right"><caption>Fig 9. Basic Flash I/O chip pins</caption><tr><td><img src="/img/spix-io-pins.svg" alt="" width="420" /></td></tr></table>

<p>This <a href="https://en.wikipedia.org/wiki/Simplex_communication">simplex</a>
command response protocol also allows particular bastardizations of the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol whereby the <code class="highlighter-rouge">MISO</code> and <code class="highlighter-rouge">MOSI</code> lines are re-purposed into bi-directional
wires: the master might send on both bits during the argument period of the
command, and then receive on both bits during the response period.  This is
called “Dual SPI” mode, or DSPI for short.  Many
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chips (including <a href="http://www.cypress.com/file/177961/download">this one</a>)
also have two other wires, a negative logic reset/hold pin and a negative logic
write protect pin.  These can also be re-purposed into further bidirectional
data wires, creating a four-wire bidirectional data bus for even faster
communication.  This four wire mode is often called “Quad SPI”, or QSPI
for short.</p>

<p>Today, we’ll be looking at two basic capabilities, both within the basic
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> protocol.
The first capability will send a <em>read</em> command to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
and then read data back in the response.  This will be our basic read
capability.  The second will send an arbitrary 8-bit command to the flash,
and then maintain the <code class="highlighter-rouge">CS_n</code> pin low and the <code class="highlighter-rouge">SCK</code> pin stable (and high) until
either another command is received, or our
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
is explicitly told to adjust them again.</p>

<h3 id="read-only">Read only</h3>

<p>If you look through the command table on <a href="http://www.cypress.com/file/177961/download">page 109 of the specification for
this chip</a>, you’ll notice several
commands that can be used to read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  There’s the <code class="highlighter-rouge">READ</code>
command which tops out at a maximum <code class="highlighter-rouge">SCK</code> clock rate of <code class="highlighter-rouge">50MHz</code>, the
<code class="highlighter-rouge">FAST_READ</code>, topping out at 108MHz, the <code class="highlighter-rouge">DOR</code> or dual read output, and the
<code class="highlighter-rouge">QOR</code> or quad read output.  There are also some faster read commands, such as
the <code class="highlighter-rouge">DIOR</code> or dual I/O read and the <code class="highlighter-rouge">QIOR</code> or quad I/O read.  There are also
4-byte address commands, although they are not required on this <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>From my own experience, I have found that the reads delivering 4-bits at a
time are the fastest, especially when you can start the transaction immediately
with the address in what is sometimes called
<a href="https://en.wikipedia.org/wiki/Execute_in_place">XIP</a> mode–but we’ll have
to leave that discussion for another day, since the
<a href="http://www.icoboard.org">ICO board</a> layout doesn’t support these
high speed access modes.</p>

<p>So let’s return to the basic <code class="highlighter-rouge">READ</code> command.  This command starts from
the device in its idle or default state, requires the controller to send an
8-bit <code class="highlighter-rouge">READ</code> command to the device (<code class="highlighter-rouge">8'h03</code>), followed by a 3-byte (24-bit)
address.  Once done, the device will return bytes to us in sequence from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, starting at the
address we give it and incrementing by one for each byte read.</p>

<p>The <a href="http://www.cypress.com/file/177961/download">spec</a> shows a picture of
this operation for us, which I’ve copied below into Fig 10.</p>

<table align="center" style="float: none"><caption>Fig 10. The basic command to read from flash</caption><tr><td><img src="/img/spi-spec.png" alt="" width="799" /></td></tr></table>

<p>Unlike many of the other things we’ve discussed, a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> interaction is very
much an organized interaction over many clock cycles.
Let’s copy our interaction into
<a href="https://www.wavedrom.com/editor.html">wavedrom</a> where we can edit it, and
then take another look again.</p>

<table align="center" style="float: none"><caption>Fig 11. Beginning our transaction design</caption><tr><td><img src="/img/spi-bare.svg" alt="" width="780" /></td></tr></table>

<p>This now becomes our goal–the specification our component must match.</p>

<p>One key point in this picture is the clock rate.  The device will limit our
maximum <code class="highlighter-rouge">SCK</code> rate to 50MHz when using the basic read command, <code class="highlighter-rouge">8'h03</code>.  Given that my goal system clock rate for <a href="https://github.com/ZipCPU/icozip">this
design</a> is 50MHz as well, this will work well.</p>

<p>But how to get an <code class="highlighter-rouge">SCK</code>	of 50MHz from a 50MHz system clock?  To do this, <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">we’ll
use</a>
a <code class="highlighter-rouge">DDR</code> output function of the <code class="highlighter-rouge">SB_IO</code> primitive provided by the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>.
That will allow us to run all of our logic at full speed,
even though this clock signal will toggle twice as fast as our logic.</p>

<p>Before moving forward, let’s add one more design requirement to the
waveform file in Fig 11:  Our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
must also interact with a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
bus</a>.  Let’s think about
how we’ll do this for a moment.  Ideally, the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
will need to accept a request from the bus, and then immediately
start the read transaction with the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip.  Once done, the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
will need to return a response, <code class="highlighter-rouge">o_wb_ack</code> and
<code class="highlighter-rouge">o_wb_data</code>, to the same bus.  All in all, this should look something like
Fig 12 below.  In between the request and the acknowledgment, the <code class="highlighter-rouge">o_wb_stall</code>
signal should be high.</p>

<table align="center" style="float: none"><caption>Fig 12. Bus read transaction</caption><tr><td><img src="/img/spi-read.svg" alt="" width="780" /></td></tr></table>

<p>Notice also that I added two other control wires to this picture: <code class="highlighter-rouge">ack_delay</code>
is an internal counter, and <code class="highlighter-rouge">o_spi_sck</code> is an output from our
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to the <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">DDR output
module</a>.</p>

<p>The <code class="highlighter-rouge">ack_delay</code> counter will be used to keep track of where
we are in the sequence.  This is shown at the bottom of Fig 12 above.  Once
<code class="highlighter-rouge">ack_delay</code> hits zero, we should be done with our transaction.  If you look
in the sequence above, you’ll notice that the same clock <code class="highlighter-rouge">ack_delay</code> hits
zero is also the clock <code class="highlighter-rouge">o_wb_ack</code> is high, <code class="highlighter-rouge">o_wb_data</code> is valid, <code class="highlighter-rouge">o_wb_stall</code>
returns to zero, and <code class="highlighter-rouge">CS_n</code> returns high.</p>

<p>The <code class="highlighter-rouge">o_spi_sck</code> signal also needs a bit more explanation.  This isn’t the
actual <code class="highlighter-rouge">SCK</code> signal going to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip, but rather
a signal to the <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">DDR output
module</a>
telling it to toggle the clock.  You may notice that this signal is set
immediately after the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
strobe (request) signal is accepted (i.e. strobe is high and stall is low).
However, the <code class="highlighter-rouge">SCK</code> signal doesn’t start toggling for another clock period
after setting this <code class="highlighter-rouge">o_spi_sck</code> signal high.  (This was unexpected, and so
we’ll discuss this again in our testing section below.  This one clock change
forced me to delay all of the other signals by one clock, as already shown in
Fig 12 above.</p>

<p>For now, though, let’s return to that <code class="highlighter-rouge">ack_delay</code> signal and just point out that
we’ll be using this signal internally to control a basic state machine.</p>

<p>We’ll start our state machine with a “bus request”: a request to read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.  That will look
something like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">wire	bus_request;
assign	bus_request = (i_wb_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(!i_wb_we);</code></pre></figure>

<p>We can then use this <code class="highlighter-rouge">bus_request</code> signal to start our <code class="highlighter-rouge">ack_delay</code> counter.
Once started, <code class="highlighter-rouge">ack_delay</code> will just count down to zero, when we will
acknowledge the bus request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">initial	ack_delay = 0;
always @(posedge i_clk)
if (bus_request)
	ack_delay &lt;= 6'd65;
else if (ack_delay &gt; 0)
	ack_delay &lt;= ack_delay - 1'b0;</code></pre></figure>

<p>The second piece of circuitry we’ll want is a shift register controlling the
<code class="highlighter-rouge">MOSI</code> values that we send to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
interface.  This will include both our command, <code class="highlighter-rouge">8'h03</code>, and the address we
wish to read from, <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">i_wb_address,</span><span class="w"> </span><span class="err">2'b0</span><span class="w"> </span><span class="p">}</span></code>.  (The last two bits are zero,
because the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
address is a word address, not a byte address.) Since we know the address at
time zero when the <code class="highlighter-rouge">bus_request</code> is made, this can be as simple as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
if (bus_request)
	// Here's the data stream we wish to send
	wdata_pipe   &lt;= { 1'b0, 8'h03, i_wb_address };
else
	wdata_pipe &lt;= { wdata_pipe[31:0], 1'b0 };

assign	o_spi_mosi = wdata_pipe[32];</code></pre></figure>

<p>Note the extra zero bit out front.  This is due to the extra clock it takes to
start the DDR <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
<code class="highlighter-rouge">SCK</code> signal that we mentioned above, and diagrammed in Fig 12.</p>

<p>All that remains is to set the rest of our signals based upon this counter,
using Fig. 12 above as a guide.  Remember, signals that are set on the
positive edge of a clock need to be set one clock before they are to be valid.
Hence, if you want to set the <code class="highlighter-rouge">CS_n</code> signal high so that it is
high when <code class="highlighter-rouge">ack_delay</code> returns to zero, you’ll want to set it that way when
<code class="highlighter-rouge">ack_delay</code> is <code class="highlighter-rouge">7'd1</code>.</p>

<p>First, upon a bus request, we would get things started.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
if (bus_request)
begin
	o_spi_cs_n &lt;= 1'b0;
	o_spi_sck  &lt;= 1'b1;

	o_wb_ack   &lt;= 1'b0;
	o_wb_stall &lt;= 1'b1;</code></pre></figure>

<p>Then, while things are running, we update any signals.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">end else if (ack_delay &gt; 1)
begin
	o_spi_cs_n &lt;= 1'b0;
	o_spi_sck  &lt;= (ack_delay &gt; 2);

	o_wb_ack   &lt;= 1'b0;
	o_wb_stall &lt;= 1'b1;
	o_wb_data  &lt;= { o_wb_data[30:0], i_spi_miso };</code></pre></figure>

<p>Once we get to the end, we’ll need to shut down our interface and return
an acknowledgment and our data.  We can also turn the stall signal off
at this time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">end else if (ack_delay == 1)
begin
	// Turn off the interface
	o_spi_cs_n &lt;= 1'b1;
	o_spi_sck  &lt;= 1'b0;

	o_wb_ack   &lt;= 1'b1;
	o_wb_stall &lt;= 1'b0;
	o_wb_data  &lt;= { o_wb_data[30:0], i_spi_miso };</code></pre></figure>

<p>Finally, if <code class="highlighter-rouge">ack_delay==0</code> and there’s no <code class="highlighter-rouge">bus_request</code>, then we just want
our interface to remain idle.  We’ll also quietly ignore any write requests
from the bus, acknowledging them immediately while we are idle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">end else begin
	// Interface is idle
	o_spi_cs_n &lt;= 1'b1;
	o_spi_sck  &lt;= 1'b0;

	o_wb_ack   &lt;= (i_wb_stb)&amp;&amp;(i_wb_we);
	o_wb_stall &lt;= 1'b0;
end</code></pre></figure>

<p>This is our primary capability.  We could ideally stop here if all you wanted
was a simple <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to only read from your <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<h3 id="second-piped-reads-as-well">Second: Piped reads as well</h3>

<p>One problem with stopping here, though, is that this approach to reading from a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory is <em>painfully</em>
slow–especially for a
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core CPU</a>
when its speed is limited by the speed it can read instructions from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
If you just count clock cycles, then the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
as is takes 66 cycles per
read.  This will limit any
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s speed to
66 <a href="https://en.wikipedia.org/wiki/Cycles_per_instruction">cycles per instruction
(CPI)</a>.  While this
may be faster than your average snail, I’d like <a href="/about/zipcpu.html">my
CPU</a> to run a bit faster.</p>

<p>If you remember our <a href="/zipcpu/2018/03/21/dblfetch.html">discussion about pipelining a
prefetch</a>, then
you’ll remember how I managed to keep a rolling
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
going in the presence of a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
device.  That would increase the speed of a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> bound
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
from 66
<a href="https://en.wikipedia.org/wiki/Cycles_per_instruction">CPI</a>
(minimum) up to 33 
<a href="https://en.wikipedia.org/wiki/Cycles_per_instruction">CPI</a>.  It’s
still a snail’s pace, but a factor of two better is still a factor of two.</p>

<p>How might we do this?</p>

<p>The first step is to go back to the
<a href="http://www.cypress.com/file/177961/download">specfication</a> for our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip, and then to
remember that once the read is started the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> will just keep producing
subsequent bytes.  This is what we’d like to capitalize on.  We could do this
if we just kept the transaction going for another 32-bit word, but only
if there was a request for the next word from the bus.  We’ll have to test
for that in a moment.</p>

<p>We’ll start this modified design by returning to our timing diagram.
Specifically, we’d like to be able to accept a request for the next
address just in time so that we don’t lose any clock cycles in our
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
transaction.  Hence, if we were just about at the end of one transaction,
then we should be able to extend it by one more transaction, as shown in Fig. 13
below.</p>

<table align="center" style="float: none"><caption>Fig 13. Pipelined read transaction</caption><tr><td><img src="/img/spi-pipe.svg" alt="" width="780" /></td></tr></table>

<p>Notice a couple key points here.  First, the <code class="highlighter-rouge">ack_delay</code> line never hits
zero–it just immediately goes into the next word.  The <code class="highlighter-rouge">o_wb_ack</code> and
<code class="highlighter-rouge">o_wb_data</code> lines maintain their requirement, they are to be valid one
clock after <code class="highlighter-rouge">ack_delay==1</code>.  Indeed, in many
ways, this looks identical to what we had before with the exception that
following a <code class="highlighter-rouge">bus_request</code> for the next word we go immediately into reading it
instead of sending a new address.</p>

<p>Our first problem in this picture is the stall line–it needs to be low one
clock early, or when <code class="highlighter-rouge">ack_delay==1</code>, and not when <code class="highlighter-rouge">ack_delay</code> returns to zero.
The only thing is, we can’t do this at all times, but <em>only</em> when
the address requested is for the next word, <em>only</em> when this is a read request.</p>

<p>That’s going to require some extra logic.</p>

<p>It also requires a little bit of trickery that doesn’t quite follow the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/doc/wbspec_b4.pdf">specification</a>:
we’ll take a peek at any pending transaction on one clock and set a flag
based upon it,
then we’ll check that flag and drop <code class="highlighter-rouge">o_wb_stall</code> if necessary on the
following clock.  This new flag, <code class="highlighter-rouge">next_request</code> is shown at the bottom of
Fig. 13 above.</p>

<p>So here’s the extra logic.  First, we’ll capture the next address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	reg	[21:0]	next_addr;

	always @(posedge i_clk)
	if ((i_wb_stb)&amp;&amp;(!o_wb_stall))
		next_addr &lt;= i_wb_addr + 1'b1;</code></pre></figure>

<p>Then, we’ll put our <code class="highlighter-rouge">next_request</code> flag together.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assign	next_request = (i_wb_stb)&amp;&amp;(!i_wb_we)&amp;&amp;(i_wb_addr == next_addr);</code></pre></figure>

<p>Now we can come back and review our basic signals from before.</p>

<p>The <code class="highlighter-rouge">MOSI</code> signal is a don’t care, so we can keep our <code class="highlighter-rouge">wdata_pipe</code> logic
simple.</p>

<p>The logic for <code class="highlighter-rouge">CS_n</code> doesn’t change either–it’s set to zero on any bus
request, and this pipe request (once the stall is lowered) is just another
bus request.</p>

<p>The <code class="highlighter-rouge">ack_delay</code> logic does need to be adjusted, but this is minor.  Specifically, if there’s a <code class="highlighter-rouge">bus_request</code> where <code class="highlighter-rouge">CS_n</code> is already low, then only set
<code class="highlighter-rouge">ack_delay</code> to 32 instead of <code class="highlighter-rouge">65</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	ack_delay = 0;
	always @(posedge i_clk)
	if (bus_request)
		ack_delay &lt;= (o_spi_cs_n) ? 7'd65 : 7'd32;
	else if (ack_delay != 0)
		ack_delay &lt;= ack_delay - 1'b1;</code></pre></figure>

<p>The <code class="highlighter-rouge">SCK</code> and <code class="highlighter-rouge">o_wb_stall</code> signals are a touch more difficult.  First, the
<code class="highlighter-rouge">SCK</code> signal needs to remain high one clock longer if <code class="highlighter-rouge">next_request</code> is high.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	o_spi_sck = 1'b0;
	always @(posedge i_clk)
	if (i_reset)
		o_spi_sck &lt;= 1'b0;
	else if (bus_request)
		o_spi_sck &lt;= 1'b1;
	else if (ack_delay &gt; 2)
		o_spi_sck &lt;= 1'b1;
	//
	// NEW LOGIC: keep the clock going if there's a second request
	// coming.
	else if ((next_request)&amp;&amp;(ack_delay == 2))
		o_spi_sck &lt;= 1'b1;
	else
		o_spi_sck &lt;= 1'b0;</code></pre></figure>

<p>Second, and really this is the key piece of logic on which all the others
depend, the stall line needs to be lowered
so the request can be accepted in time to start the new transaction without
any delayed cycles.  This pins the stall low clock period to be the same 
clock period where <code class="highlighter-rouge">ack_delay</code> is one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	o_wb_stall = 1'b0;
	always @(posedge i_clk)
	if (bus_request)
		o_wb_stall &lt;= 1'b1;
	//
	// NEW LOGIC: Drop the stall line if a request for the
	// next address is pending.  The stall line will be
	// low in this case when ack_delay == 1.
	//
	else if ((next_request)&amp;&amp;(ack_delay == 2))
		o_wb_stall &lt;= 1'b0;
	else
		o_wb_stall &lt;= (ack_delay &gt; 1);</code></pre></figure>

<p>Notice how these changes are fairly minor, but yet they can speed up a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
<a href="/zipcpu/2018/03/21/dblfetch.html">instruction fetch by a factor of
two</a> (… but only if the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
doesn’t use the bus for data, doesn’t branch, doesn’t … etc).  There are
some <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> speed
details in there that I’m glossing over.  Still, we haven’t changed our
logic all that much to get this additional capability.</p>

<p>At this point, we could stop again.  We’d now have a faster <code class="highlighter-rouge">ROM</code>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> device.  The 
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> would need to be written
using some other configuration, but we’d be able to read it in high speed.</p>

<p>But, couldn’t we get the ability to read and write the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> for just a little bit more
work?  That’s the purpose of the configuration port that we’ll discuss next.</p>

<h3 id="third-configuration-port">Third: Configuration port</h3>

<p>Can we add a configuration port capability to this 
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>?
Specifically, it would be nice to have access to all of those other commands
outlined in the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="http://www.cypress.com/file/177961/download">specfication</a>.</p>

<p>Let’s use a separate
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
port for this purpose.  By that I mean, let’s create a separate strobe signal,
<code class="highlighter-rouge">i_cfg_stb</code>,
but otherwise share all of the signals between these two ports.  The <a href="/blog/2017/06/22/simple-wb-interconnect.html">bus
interconnect</a>
can then set this new strobe signal, <code class="highlighter-rouge">i_cfg_stb</code>, to indicate
a request on this new port.</p>

<p>Unlike the primary <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
bus</a>,
we’ll make this one so that you can both write and then read
from this port.  Write’s will send 8-bits to the device over the <code class="highlighter-rouge">MOSI</code> line,
and reads will read the 8-bits returned in the <code class="highlighter-rouge">MISO</code> line.  In order to
allow longer interactions, extending beyond a single 8-bit transaction,
we’ll allocate bit <code class="highlighter-rouge">i_wb_data[8]</code> and use it to control the <code class="highlighter-rouge">CS_n</code> bit.</p>

<p>Fig. 14 below shows this concept of this protocol.</p>

<table align="center" style="float: none"><caption>Fig 14. Configuration port transaction</caption><tr><td><img src="/img/spi-cmd.svg" alt="A direct SPI command, bypassing the controller" width="780" /></td></tr></table>

<p>Writes with <code class="highlighter-rouge">i_wb_data[8]</code> low will cause 8-bits to be sent, reads will
return the response.  Writes with <code class="highlighter-rouge">i_wb_data[8]</code> set will return the
device to the mode where we can read data again.</p>

<p>Were we building <em>only</em> this interface, the logic would look <em>very</em> similar to
just the logic necessary to implement Fig. 14 above.  We’d start with an
<code class="highlighter-rouge">user_request</code> signal, capturing the write request on this configuration
channel.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	wire	user_request = (i_cfg_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(i_wb_we)
				&amp;&amp;(!i_wb_ata[8]);</code></pre></figure>

<p>Then we could just walk through our basic signals again.</p>

<p>We’d start with the <code class="highlighter-rouge">MOSI</code> signal.  This was based upon a <code class="highlighter-rouge">wdata_pipe</code>
shift register before.  We can do this again now.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	wdata_pipe = 0;
	always @(posedge i_clk)
	if (user_request)
		wdata_pipe &lt;= { 1'b0, i_wb_data[7:0], 24'h0 };
	else
		wdata_pipe &lt;= { wdata_pipe[31:0], 1'b0 };

	assign	o_spi_mosi = wdata_pipe[32];</code></pre></figure>

<p>We can keep our <code class="highlighter-rouge">ack_delay</code> state variable as well.  Only now, we’ll start it
from <code class="highlighter-rouge">7'd9</code> instead of <code class="highlighter-rouge">7'd65</code>, but the rest of the logic is nearly identical.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	ack_delay = 0;
	always @(posedge i_clk)
	if (user_request)
		ack_delay &lt;= 7'd9;
	else if (ack_delay != 0)
		ack_delay &lt;= ack_delay - 1'b1;</code></pre></figure>

<p>Amazingly, the rest of the logic is the same as it was before, save for
some new checks for <code class="highlighter-rouge">(user_request)</code> instead of <code class="highlighter-rouge">(bus_request)</code> to know when
to start a transaction.</p>

<p>This is why I like this particular approach over and above the bit-banging
approach I had tried on the fourth attempt I wrote about above–you can
share most of the configuration port logic with the regular read logic we
presented above.</p>

<h2 id="examining-the-controllers-verilog-code">Examining the Controller’s Verilog Code</h2>

<p>We’ve now walked through a description of how the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
interaction works, together with three separate interactions we want to
accomplish.  At this point, you know the basics, and you’ve seen some
useful code snippets.  The problem is we’ve ignored several key details
of this implementation along the way:</p>

<ul>
  <li>
    <p>Resets</p>

    <p>Our <a href="/zipcpu/2017/11/07/wb-formal.html">formal property list for the
Wishbone bus</a>
requires the implementation of a reset signal.</p>
  </li>
  <li>
    <p>Aborts</p>

    <p>Similarly, the <a href="/zipcpu/2017/11/07/wb-formal.html">formal properties for the
Wishbone</a>
bus require us to support the case where the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> (or other bus
master) suddenly aborts the 
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
transaction.</p>

    <p>I’ve come across two approaches to this requirement.  One is to continue the
transaction anyway, and just not to acknowledge the result at the end.
The second approach, which we’ll use here, is to actually terminate the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
transaction.</p>
  </li>
  <li>
    <p>All Acknowledgments</p>

    <p>A third problem we have is that we’ve only discussed how to respond to three
of four possible requests.  We’ve discussed how to respond to a bus read,
and to reads from and writes to the configuration port.  What about
writes to the read port?  Or reads from the configuration port when
the port isn’t in the configuration mode?  (i.e. when <code class="highlighter-rouge">CS_n</code> remains high)</p>

    <p>Some controllers would issue
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a> for the unsupported
transactions shown in Fig. 15 below.  However, in my search for low logic
and simple controllers, I tend to <a href="/zipcpu/2017/11/07/wb-formal.html">return acknowledgments
instead</a>–even when a
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a> might make more sense.
We can argue over whether or not this is the best choice, but today’s
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
doesn’t issue any
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a>.</p>
  </li>
</ul>

<table align="center" style="float: right"><caption>Fig 15. Request Combinations</caption><tr><td><img src="/img/spix-ack.svg" alt="Chart showing the different types of transactions" width="480" /></td></tr></table>

<p>Actually, I’m personally kind of conflicted over whether or not this was the
  right implementation choice, so I’ll listen to anyone with an opinion on the
  issue.</p>

<p>Specifically, we’ll simply acknowledge an illegal operation, even
  if it means returning potentially bad data.  In Fig. 15 above, I called
  these “Empty ACK”s.</p>

<ul>
  <li>
    <p>Options</p>

    <p>Because I know that different designs will have different needs, I’m also
going to implement our extensions as part of two options controlled by
one bit parameters: if <code class="highlighter-rouge">OPT_PIPE</code> is set to <code class="highlighter-rouge">1'b1</code>, the core will support
pipelined reads.  Similarly, if the <code class="highlighter-rouge">OPT_CFG</code> parameter is set to <code class="highlighter-rouge">1'b1</code>
the core will support the configuration port.</p>

    <p>Perhaps I should also create an <code class="highlighter-rouge">OPT_ERROR</code> that can be set if I want this
core to return a
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a>
for the unsupported cases in Fig. 15.  That would certainly be an option.</p>
  </li>
</ul>

<p>There’s one last difference you’ll see in the code below.  That is that I like
to split up my always blocks so that they only define the logic for one
register at a time.
This has two purposes.  First, it helps to minimize the gate count.  Wires
that don’t depend upon lots of nested if’s don’t need to have that nested
if logic required by other signals encumbering them.  Second, it keeps me
from the <a href="http://www.clifford.at/papers/2017/togglemux/dac2017_paper.pdf">issue associated with ‘x’, or don’t care,
values</a>.</p>

<p>Do I find this multiple always block approach more confusing?  Yes.  However,
the <a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
help to keep me out of trouble, and catch any cases I might be missing.</p>

<p>That said, let’s walk through <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">the
code</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">module	spixpress(i_clk, i_reset,
		i_wb_cyc, i_wb_stb, i_cfg_stb, i_wb_we, i_wb_addr, i_wb_data,
			o_wb_stall, o_wb_ack, o_wb_data,
		o_spi_cs_n, o_spi_sck, o_spi_mosi, i_spi_miso);
	//
	// OPT_PIPE allows successive, sequential, transactions to
	// incrementing addresses without requiring a new address to be sent.
	//
	// Random access performance:	65+64(N-1)
	// Performance when pipelined:	65+32(N-1)
	//
	parameter [0:0]	OPT_PIPE = 1'b1;
	//
	// OPT_CFG creates a configuration register that can be accessed through
	// i_cfg_stb when the core isn't busy.  Using this configuration
	// register, it is possible to send arbitrary commands to the flash,
	// and hence to erase or program the flash.  Since the access is
	// arbitrary, other flash features are supported as well such as
	// programming or reading the one-time-programmable memory or more.
	parameter [0:0]	OPT_CFG  = 1'b1;</code></pre></figure>

<p>You may remember the <code class="highlighter-rouge">bus_request</code>, <code class="highlighter-rouge">next_request</code>, and <code class="highlighter-rouge">user_request</code> (i.e.
the configuration port request) from our discussions above.  Here are those
definitions now.  The big differences here from the logic I presented above
are the <code class="highlighter-rouge">OPT_PIPE</code> and <code class="highlighter-rouge">OPT_CFG</code> parameters.  The synthesis tool will use
these one-bit logic values to trim logic below, starting with this logic here
in case either of these two options are not defined.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assign	bus_request  = (i_wb_stb)&amp;&amp;(!o_wb_stall)
					&amp;&amp;(!i_wb_we)&amp;&amp;(!cfg_user_mode);
	assign	next_request = (OPT_PIPE)&amp;&amp;(i_wb_stb)&amp;&amp;(!i_wb_we)
					&amp;&amp;(!cfg_user_mode)
					&amp;&amp;(i_wb_addr == next_addr);
	assign	user_request = (OPT_CFG)&amp;&amp;(i_cfg_stb)&amp;&amp;(!o_wb_stall)
					&amp;&amp;(i_wb_we)&amp;&amp;(!i_wb_data[8]);</code></pre></figure>

<p>One requirement we shall place upon the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
is that the two ports are to have different addresses on the same bus.  In
other words, <code class="highlighter-rouge">i_wb_stb</code> may be high or <code class="highlighter-rouge">i_cfg_stb</code>, but never both on the
same clock.</p>

<p>We’ll start building our logic with the state variable that will drive
everything else, <code class="highlighter-rouge">ack_delay</code>.  This logic is just as we discussed above,
save that we’ve now merged all three modes together, and added support for
resets and <a href="/zipcpu/2017/11/07/wb-formal.html">bus
aborts</a> that would bring us
back to an idle state early.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	ack_delay = 0;
	always @(posedge i_clk)
	if ((i_reset)||(!i_wb_cyc))
		ack_delay &lt;= 0;
	else if (bus_request)
		ack_delay &lt;= ((o_spi_cs_n)||(!OPT_PIPE)) ? 7'd65 : 7'd32;
	else if (user_request)
		ack_delay &lt;= 7'd9;
	else if (ack_delay != 0)
		ack_delay &lt;= ack_delay - 1'b1;</code></pre></figure>

<p>The simplest wire to control in this design is the <code class="highlighter-rouge">MOSI</code> wire.  This follows
from the <code class="highlighter-rouge">wdata_pipe</code> discussion above, only we’ve now combined the two types
of bus requests together.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	wdata_pipe = 0;
	always @(posedge i_clk)
	if (!o_wb_stall)
		wdata_pipe[23:0] &lt;= { i_wb_addr[21:0], 2'b00 };
	else
		wdata_pipe[23:0] &lt;= { wdata_pipe[22:0], 1'b0 };

	always @(posedge i_clk)
	if (((!OPT_CFG)||(i_wb_stb))&amp;&amp;(!o_wb_stall)) // (bus_request)
		wdata_pipe[32:24] &lt;= { 1'b0, 8'h03 };
	else if ((OPT_CFG)&amp;&amp;(!o_wb_stall)) // (user_request)
		wdata_pipe[32:24] &lt;= { 1'b0, i_wb_data[7:0] };
	else
		wdata_pipe[32:24] &lt;= { wdata_pipe[31:23] };

	assign	o_spi_mosi = wdata_pipe[32];</code></pre></figure>

<p>Notice the two extra bits at the end of <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">i_wb_addr[21:0],</span><span class="w"> </span><span class="err">2'b00</span><span class="w"> </span><span class="p">}</span></code>.
These will be pruned by the optimizer within the <a href="http://www.clifford.at/yosys">synthesis
tool</a>.
I’ve kept them in there to keep the bottom bits of shift register byte aligned,
although they could easily be pruned here.  The top zero bit of
<code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">1'b0,</span><span class="w"> </span><span class="err">8'h03</span><span class="w"> </span><span class="p">}</span></code> follows from the reality that it will cost a one
clock delay to get the <code class="highlighter-rouge">SCK</code> to start toggling after we set <code class="highlighter-rouge">o_spi_sck</code>.</p>

<p>The other thing to notice about the <code class="highlighter-rouge">wdata_pipe</code> logic is that I’ve split
it into two blocks.  This is for exactly those same reasons I was describing
above.  Bits <code class="highlighter-rouge">[23:0]</code> depend only upon the address, and then only upon a read
request.  Once set and the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
turns busy, these become a shift register that shifts left.
Bits <code class="highlighter-rouge">[32:24]</code> are similarly a shift register when busy, but when upon
a regular bus request these are the read command.  Otherwise on a configuration
port write, these bits are set to the bottom 8-bits from the data bus.</p>

<p>Turning to the bus acknowledgment signal, <code class="highlighter-rouge">o_wb_ack</code>, this is
just set any time the <code class="highlighter-rouge">ack_delay</code> transitions to zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	o_wb_ack = 0;
	always @(posedge i_clk)
	if (i_reset)
		o_wb_ack &lt;= 0;
	else if (ack_delay == 1)
		o_wb_ack &lt;= (i_wb_cyc);</code></pre></figure>

<p>Well, not quite.  We needed to support
<a href="/zipcpu/2017/11/07/wb-formal.html">bus aborts</a>, so
<code class="highlighter-rouge">o_wb_ack</code> is set to zero if the cycle line was dropped.</p>

<p>Even that’s not it.  We still need to acknowledge anything that will not
set the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
port in motion.  That’s the rest of the <code class="highlighter-rouge">o_wb_ack</code> logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	else if ((i_wb_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(!bus_request))
		o_wb_ack &lt;= 1'b1;
	else if ((OPT_CFG)&amp;&amp;(i_cfg_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(!user_request))
		o_wb_ack &lt;= 1'b1;
	else
		o_wb_ack &lt;= 0;</code></pre></figure>

<p>If the configuration port parameter, <code class="highlighter-rouge">OPT_CFG</code>, is set then we’ll need to
keep track of whether or not the port is forcing the <code class="highlighter-rouge">CS_n</code> line low.  We’ll
call this the <code class="highlighter-rouge">cfg_user_mode</code> and use a register of the same name to keep
track of whether or not we need to hold <code class="highlighter-rouge">CS_n</code> low while waiting for the
next transaction.  This idea of holding <code class="highlighter-rouge">CS_n</code> low was shown on the right
edge of Fig 14 above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	cfg_user_mode = 0;
	always @(posedge i_clk)
	if (i_reset)
		cfg_user_mode &lt;= 0;
	else if ((OPT_CFG)&amp;&amp;(i_cfg_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(i_wb_we))
		cfg_user_mode &lt;= !i_wb_data[8];</code></pre></figure>

<p>One variable we didn’t discuss above was the <code class="highlighter-rouge">actual_sck</code> register defined
below.  This register’s purpose is to unwind the delay associated with the
<code class="highlighter-rouge">SCK</code> <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">DDR
implementation</a>,
which causes <code class="highlighter-rouge">SCK</code> one cycle after we set <code class="highlighter-rouge">o_spi_sck</code> high.  This register
is an important part of knowing when to shift a new bit into <code class="highlighter-rouge">o_wb_data</code> next.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	actual_sck = 1'b0;
	always @(posedge i_clk)
	if ((i_reset)||(!i_wb_cyc))
		actual_sck &lt;= 1'b0;
	else
		actual_sck &lt;= o_spi_sck;</code></pre></figure>

<p>We need <code class="highlighter-rouge">actual_sck</code> to tell us when to update the outgoing data register,
<code class="highlighter-rouge">o_wb_data</code>, with a new <code class="highlighter-rouge">i_spi_miso</code> value.  Basically, anytime <code class="highlighter-rouge">actual_sck</code>
is high, we’ll clock in a new <code class="highlighter-rouge">i_spi_miso</code> bit on the right, pushing everything
left.  If <code class="highlighter-rouge">cfg_user_mode</code> is high, we’ll also clear the high 24-bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if (actual_sck)
	begin
		if (cfg_user_mode)
			o_wb_data &lt;= { 24'h0, o_wb_data[6:0], i_spi_miso };
		else
			o_wb_data &lt;= { o_wb_data[30:0], i_spi_miso };
	end else if (cfg_user_mode)
		o_wb_data &lt;= { 24'h0, o_wb_data[7:0] };</code></pre></figure>

<p>Let’s return to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
port again for a bit.  Here’s the logic for the <code class="highlighter-rouge">CS_n</code> signal.  Note the
few differences.  First, we set (inactivate) <code class="highlighter-rouge">CS_n</code> on any reset or bus
idle (or abort), save when <code class="highlighter-rouge">cfg_user_mode</code> is true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	o_spi_cs_n = 1'b1;
	always @(posedge i_clk)
	if (i_reset)
		o_spi_cs_n &lt;= 1'b1;
	else if ((!i_wb_cyc)&amp;&amp;(!cfg_user_mode))
		o_spi_cs_n &lt;= 1'b1;</code></pre></figure>

<p>Otherwise, the rest is just about as it was, save for the extra configuration
mode logic: clearing <code class="highlighter-rouge">o_cs_n</code> and holding it clear while <code class="highlighter-rouge">cfg_user_mode</code> is
high, until it is released by the next configuration register write–following
Fig. 14 above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	else if (bus_request)
		o_spi_cs_n &lt;= 1'b0;
	else if ((OPT_CFG)&amp;&amp;(i_cfg_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(i_wb_we))
		o_spi_cs_n &lt;= i_wb_data[8];
	else if (cfg_user_mode)
		o_spi_cs_n &lt;= 1'b0;
	else if ((ack_delay == 1)&amp;&amp;(!cfg_user_mode))
		o_spi_cs_n &lt;= 1'b1;</code></pre></figure>

<p>The <code class="highlighter-rouge">o_spi_sck</code> signal is mostly just the merge of the logic above.
Differences include the reset and <a href="/zipcpu/2017/11/07/wb-formal.html">bus
abort</a>
logic.  Other than that, we set <code class="highlighter-rouge">o_spi_sck</code> on any request, and clear it once
the <code class="highlighter-rouge">ack_delay</code> register has counted down to one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	o_spi_sck = 1'b0;
	always @(posedge i_clk)
	if (i_reset)
		o_spi_sck &lt;= 1'b0;
	else if ((bus_request)||(user_request))
		o_spi_sck &lt;= 1'b1;
	else if ((i_wb_cyc)&amp;&amp;(ack_delay &gt; 2)) // Bus abort check
		o_spi_sck &lt;= 1'b1;
	else if ((next_request)&amp;&amp;(ack_delay == 2))
		o_spi_sck &lt;= 1'b1;
	else
		o_spi_sck &lt;= 1'b0;</code></pre></figure>

<p>Notice that in the case of a pipelined read, the case where we don’t want
to clear <code class="highlighter-rouge">o_spi_sck</code> on clock one, <code class="highlighter-rouge">bus_request</code> will be true.  Hence we only
need to check for <code class="highlighter-rouge">ack_delay &gt; 2</code> and <code class="highlighter-rouge">ack_delay == 2</code>.</p>

<p>That brings us back to the bus, and to the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
stall signal, <code class="highlighter-rouge">o_wb_stall</code>.  If there’s no ongoing bus cycle, we’ll set
the stall line to zero.  Likewise, on any <code class="highlighter-rouge">bus_request</code> or configuration port
<code class="highlighter-rouge">user_request</code>, the stall line goes high while we respond to the request.
Finally, when <code class="highlighter-rouge">ack_delay</code> gets to zero, <code class="highlighter-rouge">o_wb_stall</code> must also return to zero.</p>

<p>That’s our logic below, save only for the special exemption when there’s a
request for the next address in memory, in order to support pipelined read requests.
That was the “New logic” we presented and discussed above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	o_wb_stall = 1'b0;
	always @(posedge i_clk)
	if ((i_reset)||(!i_wb_cyc))
		o_wb_stall &lt;= 1'b0;
	else if ((bus_request)||(user_request))
		o_wb_stall &lt;= 1'b1;
	else if ((next_request)&amp;&amp;(ack_delay == 2))
		o_wb_stall &lt;= 1'b0;
	else
		o_wb_stall &lt;= (ack_delay &gt; 1);</code></pre></figure>

<p>Finally, our <code class="highlighter-rouge">next_addr</code> logic below is identical to what we presented above,
save that this time we’ve used the <code class="highlighter-rouge">OPT_PIPE</code> flag to guarantee that this
<code class="highlighter-rouge">next_addr</code> calculation will only create logic when <code class="highlighter-rouge">OPT_PIPE</code> is non-zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	generate if (OPT_PIPE)
	begin
		reg	[21:0]	r_next_addr;
		always @(posedge i_clk)
		if (!o_wb_stall)
			r_next_addr &lt;= i_wb_addr + 1'b1;

		assign	next_addr = r_next_addr;

	end else begin

		assign next_addr = 0;

	end endgenerate</code></pre></figure>

<p>That’s <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">our flash
controller</a>!</p>

<p>The big remaining question remaining, though, is whether or not
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this core</a>
will work in practice and on my <a href="http://www.icoboard.org">ICO Board</a>.  So,
let’s turn our attention from creating this
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to verifying it.</p>

<h2 id="formally-verifying-the-flash">Formally Verifying the flash</h2>

<p>Normally when I get to this section of a post, I walk through the
verification of a core in the order the logic exists within a core.</p>

<p>I’m going to try a bit of a different order today.</p>

<p>Let’s instead work through this core in the order that I would build the
properties within the file.  I’ll try to follow the spirit of the
<em>formal driven development</em> concept I <a href="/formal/2018/07/14/dev-cycle.html">shared
earlier</a>.  This means
that I will start with a <code class="highlighter-rouge">cover()</code> statement (or four), then add the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus properties</a>
to the core, some ad-hoc properties, and then finally the <em>contract</em> the
core is supposed to meet.  Actually, I normally place the contract earlier
in the process, before the ad-hoc properties, but we’ll put the contract at
the end today because that’s where the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
will be found and therefore that was the last part I verified.</p>

<h3 id="step-one-covering-the-results">Step one: Covering the results</h3>

<p>The first formal property I like to start with these days whenever I build
a new IP core is a <code class="highlighter-rouge">cover()</code> statement.  For bus
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slaves</a>, this
usually takes the form of,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
		cover(o_wb_ack);</code></pre></figure>

<p>For many peripherals, this will exercise all of the logic in the core and
then present create a <a href="/blog/2017/07/31/vcd.html">trace</a>
at the end of the logic flow.  This 
<a href="/blog/2017/07/31/vcd.html">trace</a>
will show you an example of how the internal logic functions (or doesn’t).</p>

<p>In this case, that simple <code class="highlighter-rouge">cover()</code> statement doesn’t work like I want.
Instead of giving me a <a href="/blog/2017/07/31/vcd.html">trace</a>
through all of the logic in the core, it just immediately returns one of the
empty acknowledgments.</p>

<p>That’s not very useful.</p>

<p>Hence, to get a <a href="/blog/2017/07/31/vcd.html">trace</a> covering
both a bus request and a configuration write command, I set two flags,
<code class="highlighter-rouge">pending_bus_request</code> and <code class="highlighter-rouge">pending_user_request</code>, to record when such a
request has been made.  In order to keep this logic from impacting any other
part of the proof, I place it in a generated section depending upon a formal
option cover parameter, <code class="highlighter-rouge">F_OPT_COVER</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	generate if (F_OPT_COVER)
	begin

		always @(posedge i_clk)
			cover(o_wb_ack&amp;&amp;(!$past(bus_request))
				&amp;&amp;(!$past(user_request)));

		reg	f_pending_user_request, f_pending_bus_request;

		// Pending bus (read) request
		//
		initial	f_pending_bus_request = 1'b0;
		always @(posedge i_clk)
		if ((i_reset)||(!i_wb_cyc))
			f_pending_bus_request &lt;= 1'b0;
		else if (bus_request)
			f_pending_bus_request &lt;= 1'b1;
		else if (o_wb_ack)
			f_pending_bus_request &lt;= 1'b0;

		always @(posedge i_clk)
			cover((o_wb_ack)&amp;&amp;(f_pending_bus_request));</code></pre></figure>

<p>That captures a <a href="/blog/2017/07/31/vcd.html">trace</a> of <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a>
illustrating a read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.  You can see
this <a href="/blog/2017/07/31/vcd.html">trace</a> below in Fig 16.</p>

<table align="center" style="float: none"><caption>Fig 16. Request Combinations</caption><tr><td><img src="/img/spix-trace-read.png" alt="Trace of a SPI read transaction" width="780" /></td></tr></table>

<p>Fig 16 should look very much like our design requirement trace from Fig 12
above.</p>

<p>Now for the configuration port.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		initial	f_pending_user_request = 1'b0;
		always @(posedge i_clk)
		if ((i_reset)||(!i_wb_cyc))
			f_pending_user_request &lt;= 1'b0;
		else if (user_request)
			f_pending_user_request &lt;= 1'b1;
		else if (o_wb_ack)
			f_pending_user_request &lt;= 1'b0;

		// The actual cover statement for the user request
		always @(posedge i_clk)
			cover((o_wb_ack)&amp;&amp;(f_pending_user_request));</code></pre></figure>

<p>The configuration <a href="/blog/2017/07/31/vcd.html">trace</a>
this generates is shown below in Fig 17.</p>

<table align="center" style="float: none"><caption>Fig 17. Request Combinations</caption><tr><td><img src="/img/spix-trace-cfg.png" alt="Trace of a configuration port request" width="780" /></td></tr></table>

<p>Keep in mind, I’m able to acquire and examining these
<a href="/blog/2017/07/31/vcd.html">traces</a> <em>without writing any
simulation code</em>.  That comes later, in a discussion we’ll need to save for
another day.</p>

<p>Finally, to capture the pipelined read request, we’ll cover the entrance
into the pipeline read mode, just like we traced out in Fig. 13 above.
For this purpose, we can just <code class="highlighter-rouge">cover()</code> the lowered stall line when <code class="highlighter-rouge">ack_delay</code>
is one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		if (OPT_PIPE)
		begin
			always @(posedge i_clk)
				cover((f_pending_bus_request)
					&amp;&amp;(ack_delay == 7'h1)
					&amp;&amp;(bus_request)&amp;&amp;(o_spi_sck));</code></pre></figure>

<p>The only problem is, the formal tools failed to find
<em>any</em> <a href="/blog/2017/07/31/vcd.html">trace</a> that would
make this <code class="highlighter-rouge">cover()</code> statement true.  To debug that failed <code class="highlighter-rouge">cover()</code> statement,
I backed up a step, and tried to <code class="highlighter-rouge">cover()</code> the prior clock cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			always @(posedge i_clk)
				cover((next_request)&amp;&amp;(f_pending_bus_request)
						&amp;&amp;(ack_delay == 7'h2));
		end
	end endgenerate</code></pre></figure>

<p>Eventually I get the <a href="/blog/2017/07/31/vcd.html">trace</a> in
Fig 18 from the first of these two <code class="highlighter-rouge">cover()</code> statements.</p>

<table align="center" style="float: none"><caption>Fig 18. Request Combinations</caption><tr><td><img src="/img/spix-trace-pipe.png" alt="Trace showing the entrance to a pipelined read" width="780" /></td></tr></table>

<p>This is also my general approach for those times where I am struggling to
get a <code class="highlighter-rouge">cover()</code> statement to produce a
<a href="/blog/2017/07/31/vcd.html">trace</a>: I back up a
step, add an additional <code class="highlighter-rouge">cover()</code> statement, and then repeat the process
until I find the bug–just like I showed here.  <code class="highlighter-rouge">assert()</code> statements can help
this process as well.</p>

<p>Fig 18 also illustrates one of the problems with <code class="highlighter-rouge">cover()</code> statements: the tool
is free to cover your logic any way it pleases.  In this case, it covered the
entrance into the pipelined read, and then immediately issued a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus abort</a>
by dropping the <code class="highlighter-rouge">i_wb_cyc</code> line.  While legal, it’s hardly satisfying.</p>

<p>We could add some assumptions to keep this from taking place.  That’s part of
the purpose of the <code class="highlighter-rouge">F_OPT_COVER</code> generate block–to be able to add any
assumptions necessary for getting the
<a href="/blog/2017/07/31/vcd.html">traces</a> you want.  For example,
we could add an assumption that there would never be any
<a href="/zipcpu/2017/11/07/wb-formal.html">bus abort</a>s during
pipelined reads.  However, this <code class="highlighter-rouge">cover()</code> has accomplished my purpose as
it is: it has proven that a pipelined read request will bring the core
back into the regular read logic as desired.  Therefore, I’ll leave any
further work with assumptions as a exercise for the student.</p>

<p>This <a href="/formal/2018/07/14/dev-cycle.html">helps me create an initial
draft</a>
of this
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller
core</a>.
Well, not quite.  I’ll describe a missing piece in the next section.</p>

<h3 id="step-one-reset-and-bus-interaction">Step one: Reset and bus interaction</h3>

<p>One of the problems with the <code class="highlighter-rouge">cover()</code> statements in the last section is that,
when unconstrained, the incoming bus request doesn’t act like a bus request
should.  Bus requests may be made, stalled, and then new requests will be made
even though the prior request hasn’t gone been accepted into the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>.
Similarly, the strobe line might be high, even though the bus cycle line is low.
For these reasons, we need to bring in some <a href="/zipcpu/2017/11/07/wb-formal.html">properties describing our
bus</a>.  Let’s do that in
this section, starting with the <code class="highlighter-rouge">i_reset</code> signal the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus properties depend upon</a>.</p>

<p>Reset logic uses the <code class="highlighter-rouge">$past()</code> operator.  This operator will only work right
if the <code class="highlighter-rouge">$past()</code> time doesn’t occur before time began with the <code class="highlighter-rouge">initial</code>
statements.  Hence, we’ll create an <code class="highlighter-rouge">f_past_valid</code> register to tell us when
we can use the <code class="highlighter-rouge">$past()</code> operator successfully.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	reg	f_past_valid;

	initial	f_past_valid = 1'b0;
	always @(posedge i_clk)
		f_past_valid &lt;= 1'b1;</code></pre></figure>

<p>We want to <code class="highlighter-rouge">assume()</code> that our design starts with the <code class="highlighter-rouge">i_reset</code> line high.
This means we want to assume <code class="highlighter-rouge">i_reset</code> in both the initial state, and anytime
<code class="highlighter-rouge">f_past_valid</code> is false.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	assume(i_reset);

	always @(*)
	if (!f_past_valid)
		assume(i_reset);</code></pre></figure>

<p>Now for a fun trick: I’d like to insure that any register responsive to an
<code class="highlighter-rouge">i_reset</code> signal is also properly initialized to the same value.  Checking
for <code class="highlighter-rouge">!f_past_valid</code> tells us if we are in the initial state, whereas
<code class="highlighter-rouge">$past(i_reset)</code> checks whether or not our design just followed an
<code class="highlighter-rouge">i_reset</code> signal.  By placing the asserted values below, that guarantees them
to be the same under both circumstances.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((!f_past_valid)||($past(i_reset)))
	begin
		assert(o_spi_cs_n == 1'b1);
		assert(o_spi_sck  == 1'b0);
		//
		assert(ack_delay    ==  0);
		assert(cfg_user_mode == 0);
		assert(o_wb_stall == 1'b0);
		assert(o_wb_ack   == 1'b0);
	end</code></pre></figure>

<p>Now we can start to get the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a> to act like
a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a> should.</p>

<p>To do this, we’ll reference a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
bus</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_slave.v">property
file</a> from the
<a href="/about/zipcpu.html">ZipCPU</a>
repository.  This core needs a bit of configuration, so let’s configure its
parameters:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">AW</code>: Our address bus has 22 bits, sufficient to handle a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
of 16MB of memory.  (Remember the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
address</a> is a <em>word</em>
address, and not an 8-bit octet address.)</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">F_MAX_STALL</code>: Our design may stall the bus no more than 66 clock cycles,
 one more than the length of one non-pipelined bus read.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">F_MAX_ACK_DELAY</code>: Similarly, it may take at most 66 cycles for an
acknowledgment to be returned upon any request.</p>

    <p>This is a bit of overkill for both <code class="highlighter-rouge">F_MAX_STALL</code> and <code class="highlighter-rouge">F_MAX_ACK_DELAY</code>
by one cycle, but it gives us a little wiggle room in case our design changes
in the future.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">F_LGDEPTH</code>: Since both counters require 7-bits, and since we’ll never have
 more than <code class="highlighter-rouge">2^7</code> or 128 requests outstanding, we’ll set the log (based two)
of the pipeline depth to 7.  This also determines the number of bits in our
counters: <code class="highlighter-rouge">f_nreqs</code>, the number of requests that have been made,
<code class="highlighter-rouge">f_nacks</code>, the number of acknowledgments that have been returned,
and <code class="highlighter-rouge">f_outstanding</code>, the number of currently outstanding transactions.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">F_MAX_REQUESTS</code> describes the maximum number of requests that can be made
in any transaction.  This creates an assertion that
<code class="highlighter-rouge">f_nreqs &lt; F_MAX_REQUESTS</code>.  While this is great for our non-pipelined mode,
in the pipelined mode it is possible to make request upon request.  Hence,
we’ll set this to one for the non-pipelined mode, and to zero if we are
running in a pipelined mode.</p>
  </li>
</ul>

<p>That’s enough configuration to include this property set in our design.  We’ll
make one other adjustment here: we’ll <code class="highlighter-rouge">OR</code> the <code class="highlighter-rouge">i_wb_stb</code> and <code class="highlighter-rouge">i_cfg_stb</code>
together to create one unified <a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a> port.  This saves us from including two
separate property files to describe each of the two
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slaves</a>, but it’ll give us a bit of hassle that we’ll have to clean up in a moment.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	localparam	F_LGDEPTH = 7;
	wire	[F_LGDEPTH-1:0]	f_nreqs, f_nacks, f_outstanding;

	fwb_slave #( .AW(22), .F_MAX_STALL(7'd66), .F_MAX_ACK_DELAY(7'd66),
			.F_LGDEPTH(F_LGDEPTH),
			.F_MAX_REQUESTS((OPT_PIPE) ? 0 : 1'b1),
			.F_OPT_MINCLOCK_DELAY(1'b1)
		) slavei(i_clk, (i_reset),
		i_wb_cyc, (i_wb_stb)||(i_cfg_stb), i_wb_we,
			i_wb_addr, i_wb_data, 4'hf,
			o_wb_ack, o_wb_stall, o_wb_data, 1'b0,
			f_nreqs, f_nacks, f_outstanding);</code></pre></figure>

<p>Our first clean up assumption is to require that only one <code class="highlighter-rouge">i_*_stb</code> signal
will ever be active at any given time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
		assume((!i_cfg_stb)||(!i_wb_stb));</code></pre></figure>

<p>Second, we’ll require that any time either of <code class="highlighter-rouge">i_wb_stb</code> or <code class="highlighter-rouge">i_cfg_stb</code> is
active, <em>and</em> the bus is stalled, that the same strobe signal remains active
on the next clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(i_reset))&amp;&amp;(i_wb_cyc)
		&amp;&amp;(($past(i_wb_stb))||($past(i_cfg_stb)))&amp;&amp;($past(o_wb_stall)))
		assume({i_wb_stb,i_cfg_stb}==$past({i_wb_stb,i_cfg_stb}));</code></pre></figure>

<p>In hindsight, this just makes sense.  In reality, I didn’t put this assumption
into place until I saw this rule violated in one of my early <code class="highlighter-rouge">cover()</code>
<a href="/blog/2017/07/31/vcd.html">traces</a>.</p>

<p>Now that we’ve added our
<a href="/zipcpu/2017/11/07/wb-formal.html">bus properties</a>,
the bus starts to act right in the
<a href="/blog/2017/07/31/vcd.html">traces</a>
generated by our <code class="highlighter-rouge">cover()</code> statements.  The design just doesn’t pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
yet.  For that, we’ll need to add some ad-hoc assertions in the next section.</p>

<h3 id="step-two-ad-hoc-immediate-assertions">Step two: Ad-hoc Immediate assertions</h3>

<p>Often I separate formal properties into two types: there’s the primary
type based upon the outputs of the core that’s designed to determine whether
the core functions as intended.  We’ll call this the <em>contract</em> that the
core needs to fulfill.  Other properties are more ad-hoc.  They
wouldn’t be needed, save for the reality that
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
starts with unconstrained values within the core.  We’ll express how
this core needs to operate, it’s <em>contract</em> if you will, using <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog
sequences</a>
in the next section.  For the purpose of this section, let’s just constrain
the design to make certain it doesn’t enter into any illegal states during
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<p>We’ll start out with some assertions regarding our
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone properties</a>.
Specifically, we need to ensure that the counters within the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone property
module</a>
match our current understanding of our state.  Further, since a pipelined
operation can go on forever, we’ll only examine the number of outstanding
transactions kept in the <code class="highlighter-rouge">f_outstanding</code> value returned from the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone property</a> set.</p>

<p>For our first test, we’ll insist that we never have more than one outstanding
request.  That is unless we are in a pipelined read operation, where there
would be one cycle where the number of outstanding transactions would be two
instead of one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
	if (OPT_PIPE)
		assert(f_outstanding &lt;= 2);
	else
		assert(f_outstanding &lt;= 1);</code></pre></figure>

<p>In a similar fashion, any time <code class="highlighter-rouge">ack_delay</code> is zero then we aren’t in an
extended transaction.  Such a time step must either include the <code class="highlighter-rouge">o_wb_ack</code>
from a just-ended transaction or the number of outstanding transactions
must be zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if (ack_delay == 0)
		assert((o_wb_ack)||(f_outstanding == 0));</code></pre></figure>

<p>Unfortunately, without anything more, we may get a
<a href="/blog/2017/07/31/vcd.html">trace</a> from the tools
that has <code class="highlighter-rouge">o_wb_ack</code> on for a very long time, yet <code class="highlighter-rouge">f_outstanding</code> is some value
inconsistent with our design.  For example, the core could be responding to one
empty acknowledgment request after another while <code class="highlighter-rouge">f_outstanding ==2</code>.<br />
Of course the core would never get into this situation, but we need to
communicate that to the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
engine.</p>

<p>In the first case, following any non-pipelined <code class="highlighter-rouge">i_wb_stb</code> request, there should
then be only one request outstanding.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!i_reset)&amp;&amp;(i_wb_cyc))
	begin
		if (((!OPT_PIPE)||($past(o_spi_cs_n)))
			&amp;&amp;($past(i_wb_stb))&amp;&amp;(!$past(o_wb_stall))&amp;&amp;(i_wb_cyc))
			assert(f_outstanding == 1);</code></pre></figure>

<p>Likewise in the middle of any request, there should only be one bus request
outstanding.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		if (ack_delay &gt; 0)
			assert((o_wb_ack)||(f_outstanding == 1));
	end

&lt;figure class="highlight"&gt;&lt;pre&gt;&lt;code class="language-verilog" data-lang="verilog"&gt;If there are ever two acknowledgments back to back, they can only be the
empty acknowledgments we discussed earlier.  Hence, we should only have the
last request outstanding or no requests outstanding.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(o_wb_ack)&amp;&amp;($past(o_wb_ack)))
		assert(f_outstanding &lt;= 1);</code></pre></figure>

<p>There is only one time we should ever have two requests outstanding: that is
when we just accepted a request for a pipelined interaction and <code class="highlighter-rouge">OPT_PIPE</code> is
true.  On that same clock, the acknowledgment line should be high, <code class="highlighter-rouge">o_spi_cs_n</code>
should be active (low), and <code class="highlighter-rouge">ack_delay</code> should be 32.  Under no other
circumstances should there ever be two requests outstanding.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if (f_outstanding == 2)
		assert((OPT_PIPE)&amp;&amp;(o_wb_ack)&amp;&amp;(!o_spi_cs_n)&amp;&amp;(o_spi_sck)
			&amp;&amp;(ack_delay==7'd32));</code></pre></figure>

<p>Following any bus strobe that is neither a <code class="highlighter-rouge">bus_request</code> nor a <code class="highlighter-rouge">user_request</code>
of the configuration port, there should immediately be an acknowledgment
on the next clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(i_wb_stb))&amp;&amp;(!$past(o_wb_stall)))
	begin
		if ((i_wb_cyc)&amp;&amp;(!i_reset)
				&amp;&amp;(!$past(user_request))&amp;&amp;(!$past(bus_request)))
			assert((o_wb_ack)&amp;&amp;(f_outstanding == 1));
	end</code></pre></figure>

<p>That’s the last of the assertions necessary to make certain the formal
properties for <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a>
properly integrate with the properties from our
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone property set</a>.</p>

<p>Now let’s make some assertions of the 
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol next.</p>

<p>If you’ve taken my course in formal verification, you may remember that I
usually spend some time discussing how to properly describe a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol interaction in the multi-clock section.  This is not necessary
here.  Not only is everything synchronous, but the 
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> interaction
of interest isn’t slow enough to make any of those multiclock property
descriptions, <code class="highlighter-rouge">$rose()</code>, <code class="highlighter-rouge">$fell()</code>, or <code class="highlighter-rouge">$stable()</code>, all that useful here.</p>

<p>Still, we can describe some useful parts of the interaction here.</p>

<p>For example, we’ve chosen to leave the clock idle unless <code class="highlighter-rouge">o_spi_cs_n</code> is low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
	if (o_spi_cs_n)
		assert(!o_spi_sck);</code></pre></figure>

<p>While I suppose we could just leave the clock running, that would break some
other things–notably the configuration port.</p>

<p>Similarly, any time <code class="highlighter-rouge">ack_delay</code> is other than zero, the <code class="highlighter-rouge">SCK</code> line should be
high.  This would reference either <code class="highlighter-rouge">o_spi_sck</code> going to the <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">output DDR
module</a>,
or our local version of whether or <code class="highlighter-rouge">SCK</code> is really ticking in <code class="highlighter-rouge">actual_sck</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
		assert((o_spi_sck||actual_sck) == (ack_delay &gt; 0));</code></pre></figure>

<p>Anytime <code class="highlighter-rouge">ack_delay</code> is zero, we are not in the middle of any transactions.
Hence, <code class="highlighter-rouge">o_wb_stall</code> should also be zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
	if (ack_delay == 0)
		assert(!o_wb_stall);</code></pre></figure>

<p>Likewise, if the <code class="highlighter-rouge">ack_delay</code> is ever greater than one, then the bus should
be stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	else if (ack_delay &gt; 1)
		assert(o_wb_stall);</code></pre></figure>

<p>Indeed, with one exception any time <code class="highlighter-rouge">ack_delay</code> is greater than zero the bus
should be stalled.  The one exception is just before a pipelined transaction.
Hence, if <code class="highlighter-rouge">ack_delay</code> is one and pipelined reads are disabled, or equivalently
if we are in the <code class="highlighter-rouge">cfg_user_mode</code>, then the interface should be stalled
when <code class="highlighter-rouge">ack_delay</code> is one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	else if ((!OPT_PIPE)&amp;&amp;(ack_delay == 1))
		assert(o_wb_stall);</code></pre></figure>

<p>Just to constrain the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
engine further, the <code class="highlighter-rouge">ack_delay</code> should always be less than or equal to <code class="highlighter-rouge">65</code>.
Although we know this to be true already, the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
engine can do some weird things if you don’t limit values like this properly.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
		assert(ack_delay &lt;= 7'd65);</code></pre></figure>

<p>In a similar fashion, if <code class="highlighter-rouge">cfg_user_mode</code> is ever true, then the
<code class="highlighter-rouge">ack_delay</code> must be less than or equal to <code class="highlighter-rouge">9</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
	if (cfg_user_mode)
		assert(ack_delay &lt;= 7'd9);</code></pre></figure>

<p>Our final ad-hoc assertion will be that <code class="highlighter-rouge">o_spi_cs_n</code> is only ever active
(low) if either we are in the <code class="highlighter-rouge">cfg_user_mode</code> or if <code class="highlighter-rouge">ack_delay &gt; 0</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
		assert(o_spi_cs_n != ((cfg_user_mode)||(ack_delay &gt; 0)));</code></pre></figure>

<p>These simple assertions above will keep us in the valid operating range of <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a>.
Now we just need to convince ourselves that this core actually works and does
what it is supposed to do.  To do that, we’ll try out some of the <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System
Verilog
sequences</a>
available to the <a href="http://www.verific.com">Verific-enabled</a> version of
<a href="http://www.clifford.at/yosys">yosys</a>.</p>

<h3 id="step-three-sequence-assertions">Step three: Sequence Assertions</h3>

<p>If you recall from the beginning of this article, one of the reasons for
this project was to see if a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
would be a good test of <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog
sequences</a>.
In particular, I’ve been looking for some of the use cases that highlight
the utility of <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System
Verilog’s
sequences</a>.</p>

<p>Prior to this project, I had only tested
<a href="http://www.clifford.at/yosys">yosys</a>’s ability to handle
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog
sequences</a>
with FIFOs and a <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">UART
transmitter</a>.
Since starting this project, I have now tested and tried
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">them</a>
out with a <a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smpladc.v">SPI-based ADC</a>,
and the <a href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/sramdev.v">controller</a>
for this same <a href="https://github.com/ZipCPU/icozip">ICOZip Project</a>.
While I like the expressiveness of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog
sequence</a>
language, I’m also glad I learned how to do
<a href="/blog/2017/10/19/formal-intro.html">formal verification with immediate assertions only</a> first.  <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">Sequence</a>
are not nearly as simple or as easy to work with as the immediate assertions
we’ve been working with, and the background I gained in immediate assertions
helped me a lot while learning
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>.</p>

<p>We’ll split the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
discussion here into two parts.  The first part, contained in this section,
will be about guaranteeing that our <code class="highlighter-rouge">ack_delay</code> based state machine works as
desired.  In the next section, will dig in a bit further and verify that what
gets returned to the bus is actually what we read from the device.  Once we’re
done, we’ll move on to how I tested <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a>
on the actual hardware of the <a href="http://www.icoboard.org">ICO board</a>.</p>

<p>In many ways, it might make the most sense to read this section from the
bottom up, rather than the top down, because in order to finally express
what we want to at the end, we have to build a lot of infrastructure to get
there.  Hence, if you want to see where we are going, skip to the end of
this section and look over the assertions found there.</p>

<p>That said, let’s start with two variables these
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
will use.  In particular, we want some values that are guaranteed to stay
constant throughout the duration of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>–values
the <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
can reference, and that won’t change.  We’ll create two here, one to capture
the last address requested of the bus, and a second to capture what would be
the next address after that.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`ifdef	VERIFIC
	reg	[21:0]	f_last_addr, f_next_addr;

	always @(posedge i_clk)
	if (bus_request)
		f_last_addr &lt;= i_wb_addr[21:0];

	always @(*)
		f_next_addr &lt;= f_last_addr + 1'b1;</code></pre></figure>

<p>Our first assertion is something simple: Any request, other than a
<code class="highlighter-rouge">user_request</code> (i.e. a write) of the configuration port or a normal
<code class="highlighter-rouge">bus_request</code> (i.e. a read) should be acknowledged on the next clock, without
stalling the bus.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assert property (@(posedge i_clk)
		disable iff ((i_reset)||(!i_wb_cyc))
		((i_wb_stb)||(i_cfg_stb))&amp;&amp;(!o_wb_stall)
				&amp;&amp;(!user_request)&amp;&amp;(!bus_request)
		|=&gt; (o_wb_ack)&amp;&amp;(!o_wb_stall));</code></pre></figure>

<p>If this form of an assertion is new to you, then don’t let it be.  We’ve been
discussing this basic assertion for some time, only we’ve described it in
a different fashion.  Instead of,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assert property (@(posedge i_clk)
		A |=&gt; B);</code></pre></figure>

<p>we’ve been writing</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(A)))
		assert(B);</code></pre></figure>

<p>The two are really just two forms of the same thing.  Personally, I like the
new form.  It seems simpler and cleaner.</p>

<p>What about the <code class="highlighter-rouge">disable iff</code> statement?  That just disables the assertion
on any of the clocks that it would be applied to.  Hence,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assert property (@(posedge i_clk)
		disable iff (C)
		A |=&gt; B);</code></pre></figure>

<p>is the same as</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(A))&amp;&amp;(!$past(C))&amp;&amp;(!C))
		assert(B);</code></pre></figure>

<p>There’s another new form as well.  Instead of writing,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
	if (A)
		assert(B);</code></pre></figure>

<p>we could equivalently write</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assert property (@(posedge i_clk)
		A |-&gt; B);</code></pre></figure>

<p>Both of these newer forms, however, currently require the
<a href="http://www.verific.com">Verific enabled</a>
version of <a href="http://www.clifford.at/yosys">yosys</a>.</p>

<p>Using this newer form, I can express</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assert property (@(posedge i_clk)
		(i_wb_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(!o_spi_cs_n)&amp;&amp;(!i_wb_we)
			&amp;&amp;(!cfg_user_mode)
		|-&gt; (OPT_PIPE)&amp;&amp;(i_wb_addr == f_next_addr)
		);</code></pre></figure>

<p>That is to say, if we ever accept a new <code class="highlighter-rouge">bus_request</code> while <code class="highlighter-rouge">o_spi_cs_n</code>
is active (low), then <code class="highlighter-rouge">OPT_PIPE</code> must be valid and this new request
address <em>must</em> be for the next address in the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>Those two assertions should get your feet wet.  Now let’s try our first
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.
If you’ve never used them,
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
are neither assertions nor assumptions.  Instead, they can be used to describe
a <em><a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a></em>
of states that can then be used within an assertion, assumption, or even
a cover property.</p>

<p>For this first sequence, let’s describe the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
read command where we send a <code class="highlighter-rouge">8'h03</code> to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
device.  This sequence starts with an idle cycle with <code class="highlighter-rouge">o_spi_cs_n</code> active
and <code class="highlighter-rouge">o_spi_sck</code> true, but <code class="highlighter-rouge">actual_sck</code> hasn’t been set yet.</p>

<p>We’ll start this description by naming our
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>,
<code class="highlighter-rouge">READ_COMMAND</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	sequence READ_COMMAND;
		// Send command 8'h03</code></pre></figure>

<p>Then we’ll describe that first state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		(f_last_addr == $past(i_wb_addr))
				&amp;&amp;(!o_spi_cs_n)&amp;&amp;(o_spi_sck)&amp;&amp;(!o_spi_mosi)
				&amp;&amp;(!actual_sck)</code></pre></figure>

<p>On the next clock, we get into sending the actual command contained in the
<code class="highlighter-rouge">o_spi_mosi</code> output values.  To express that this will start on the next
clock, we’ll use the <code class="highlighter-rouge">##1</code> expression.  This portion of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>,
however, will take us a whole 8 clocks.  During all of those 8 clocks,
we’ll want to assert that the <code class="highlighter-rouge">f_last_addr</code> value stays constant, that
<code class="highlighter-rouge">o_spi_cs_n</code> stays active, and that <code class="highlighter-rouge">o_spi_sck</code> remains true.  Hence,
<em>throughout</em> these next 8-clocks, these must hold.  That’s the purpose of
the <em>throughout</em> statement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		##1 ( ((f_last_addr == $past(f_last_addr))
			&amp;&amp;(!o_spi_cs_n)&amp;&amp;(o_spi_sck)&amp;&amp;(actual_sck)) throughout</code></pre></figure>

<p>Now we can work our way through each of those individual 8 clocks.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">				(!o_spi_mosi)&amp;&amp;(ack_delay==7'd64)&amp;&amp;(actual_sck)
				##1 (!o_spi_mosi)&amp;&amp;(ack_delay==7'd63)
				##1 (!o_spi_mosi)&amp;&amp;(ack_delay==7'd62)
				##1 (!o_spi_mosi)&amp;&amp;(ack_delay==7'd61)
				##1 (!o_spi_mosi)&amp;&amp;(ack_delay==7'd60)
				##1 (!o_spi_mosi)&amp;&amp;(ack_delay==7'd59)
				##1 ( o_spi_mosi)&amp;&amp;(ack_delay==7'd58)
				##1 ( o_spi_mosi)&amp;&amp;(ack_delay==7'd57));
	endsequence</code></pre></figure>

<p>In this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
description, I’ve tried to constrain and describe every register that’s a part
of state associated with sending this command.  Further, since the <code class="highlighter-rouge">o_spi_mosi</code>
and <code class="highlighter-rouge">ack_delay</code> values changed during these 8-clocks, I didn’t lump them
together with the other predicates that needed to be true <code class="highlighter-rouge">throughout</code>
all eight of these cycles.</p>

<p>The next
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
is the one where we send the address we want to read from to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  Since the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>
is word based, and the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is byte based, we’ll add
two zero’s at the end of this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.
The format itself should look very similar to the
format of the last one: we’ll start by naming the 
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	sequence	SEND_ADDRESS;</code></pre></figure>

<p>then we’ll define those properties that must hold throughout the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		(((f_last_addr == $past(f_last_addr))&amp;&amp;(!o_spi_cs_n)&amp;&amp;(o_spi_sck)
			&amp;&amp;(actual_sck))
		throughout</code></pre></figure>

<p>finally, we’ll step through each of the clock cycles within the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			(o_spi_mosi == f_last_addr[21])&amp;&amp;(ack_delay==7'd56)
			##1 (o_spi_mosi == f_last_addr[20])&amp;&amp;(ack_delay==7'd55)
			##1 (o_spi_mosi == f_last_addr[19])&amp;&amp;(ack_delay==7'd54)
			##1 (o_spi_mosi == f_last_addr[18])&amp;&amp;(ack_delay==7'd53)
			##1 (o_spi_mosi == f_last_addr[17])&amp;&amp;(ack_delay==7'd52)
			##1 (o_spi_mosi == f_last_addr[16])&amp;&amp;(ack_delay==7'd51)
			##1 (o_spi_mosi == f_last_addr[15])&amp;&amp;(ack_delay==7'd50)
			##1 (o_spi_mosi == f_last_addr[14])&amp;&amp;(ack_delay==7'd49)
			##1 (o_spi_mosi == f_last_addr[13])&amp;&amp;(ack_delay==7'd48)
			##1 (o_spi_mosi == f_last_addr[12])&amp;&amp;(ack_delay==7'd47)
			##1 (o_spi_mosi == f_last_addr[11])&amp;&amp;(ack_delay==7'd46)
			##1 (o_spi_mosi == f_last_addr[10])&amp;&amp;(ack_delay==7'd45)
			##1 (o_spi_mosi == f_last_addr[ 9])&amp;&amp;(ack_delay==7'd44)
			##1 (o_spi_mosi == f_last_addr[ 8])&amp;&amp;(ack_delay==7'd43)
			##1 (o_spi_mosi == f_last_addr[ 7])&amp;&amp;(ack_delay==7'd42)
			##1 (o_spi_mosi == f_last_addr[ 6])&amp;&amp;(ack_delay==7'd41)
			##1 (o_spi_mosi == f_last_addr[ 5])&amp;&amp;(ack_delay==7'd40)
			##1 (o_spi_mosi == f_last_addr[ 4])&amp;&amp;(ack_delay==7'd39)
			##1 (o_spi_mosi == f_last_addr[ 3])&amp;&amp;(ack_delay==7'd38)
			##1 (o_spi_mosi == f_last_addr[ 2])&amp;&amp;(ack_delay==7'd37)
			##1 (o_spi_mosi == f_last_addr[ 1])&amp;&amp;(ack_delay==7'd36)
			##1 (o_spi_mosi == f_last_addr[ 0])&amp;&amp;(ack_delay==7'd35)</code></pre></figure>

<p>Don’t forget the two zero bits at the end of the address!</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			##1 (o_spi_mosi == 1'b0)&amp;&amp;(ack_delay==7'd34)
			##1 (o_spi_mosi == 1'b0)&amp;&amp;(ack_delay==7'd33));
	endsequence</code></pre></figure>

<p>We can now define a third
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>:
the one where we actually read the data from the device.  This has the exact
same form as before, only we’re going to introduce  new expression, the <code class="highlighter-rouge">[*8]</code>
or <code class="highlighter-rouge">[*7]</code>.  This means that we want to repeat the given state by that many
clocks.  I’m going to use this to help keep <code class="highlighter-rouge">ack_delay</code> bounded–at least
bounded enough that the formal tools properly recognize after more than eight
clocks which state of this sequence is taking place, should they decide
to try to start in the middle of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.</p>

<p>As before, we start with the name of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
followed by the properties that will hold <code class="highlighter-rouge">throughout</code> the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	sequence	READ_DATA;
		(((o_wb_stall)&amp;&amp;(!o_spi_cs_n)&amp;&amp;(o_spi_sck)
			&amp;&amp;(o_wb_data == $past({o_wb_data[30:0], i_spi_miso})))
		throughout</code></pre></figure>

<p>The first clock period, however, will be replicated 8 times.  It will primarily
just constrain <code class="highlighter-rouge">ack_delay</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		(ack_delay &lt;= 7'd32)&amp;&amp;(ack_delay &gt;= 7'd25) [*8]</code></pre></figure>

<p>And so on, repeating each clock period 8 times until the last.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		##1 (ack_delay &lt;= 7'd24)&amp;&amp;(ack_delay &gt;= 7'd17) [*8]
		##1 (ack_delay &lt;= 7'd16)&amp;&amp;(ack_delay &gt;=  7'd9) [*8]
		##1 (ack_delay &lt;=  7'd8)&amp;&amp;(ack_delay &gt;=  7'd2) [*7])</code></pre></figure>

<p>Watch the parentheses, because that last line also ends the <code class="highlighter-rouge">throughout</code>
statement that we started with, even though the we’re not done defining
this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
yet.</p>

<p>We’ve broken the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
at this point because the next period is special.
That’s the only period where the our signals might change in order to support
a pipelined interaction.  In this case, the stall line might be low if
<code class="highlighter-rouge">OPT_PIPE</code> is also true, otherwise we remain stalled like we were in the
last clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		##1 ((!o_spi_cs_n)&amp;&amp;(actual_sck)&amp;&amp;(ack_delay == 7'd1)
			&amp;&amp;(((OPT_PIPE)&amp;&amp;(i_wb_stb)&amp;&amp;(!i_wb_we)&amp;&amp;(o_spi_sck))
				||((o_wb_stall)&amp;&amp;(!o_spi_sck)))
			&amp;&amp;(o_wb_data == $past({o_wb_data[30:0], i_spi_miso})))</code></pre></figure>

<p>Finally, we’ll end this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
describing a read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
with a bus acknowledgment, and a guarantee if <code class="highlighter-rouge">OPT_PIPE</code> isn’t true
that the bus has returned to idle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		##1 (o_wb_ack)
			&amp;&amp;(o_wb_data == $past({o_wb_data[30:0], i_spi_miso}))
			&amp;&amp;((OPT_PIPE)||((o_spi_cs_n)
					&amp;&amp;(!o_spi_sck)&amp;&amp;(!actual_sck)));
	endsequence</code></pre></figure>

<p>What can you do with all these
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
we’ve just defined?  You can string them together within an assertion!</p>

<p>The following assertion asserts that, following any read request from the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>,
the device will send the <code class="highlighter-rouge">READ_COMMAND</code>, the address (<code class="highlighter-rouge">SEND_ADDRESS</code>), and
then read the data (<code class="highlighter-rouge">READ_DATA</code>) from the device.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assert property (@(posedge i_clk)
		disable iff ((i_reset)||(!i_wb_cyc))
		(i_wb_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(!i_wb_we)&amp;&amp;(o_spi_cs_n)
			&amp;&amp;(!cfg_user_mode)
		// Send command 8'h03
		|=&gt; READ_COMMAND
		// Send the requested address
		##1 ((f_last_addr == $past(f_last_addr)) throughout
				SEND_ADDRESS)
		// Clock in 32-bits of data
		##1 READ_DATA);</code></pre></figure>

<p>Not bad, huh?</p>

<p>This gets us most of the way there.  However, a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
is a type of memory, and there are
<a href="/zipcpu/2018/07/13/memories.html">particular properties</a>
you want to formally verify with respect to any
<a href="/zipcpu/2018/07/13/memories.html">memory</a>
interaction.  That will be our next section.</p>

<h3 id="step-four-known-addressdata-assertions">Step four: Known Address/Data Assertions</h3>

<p>The rule for formally verifying
<a href="/zipcpu/2018/07/13/memories.html">memories</a> is that
you want to <em>assume</em> any time you read from an arbitrary address, that
you get a known arbitrary value in response.  The second part is to <em>assert</em>
that whenever you return the result of the read to the bus, you also return the
arbitrarily chosen value.</p>

<p>I initially created those rules here in
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
logic.  One property assumed known data would be read from <code class="highlighter-rouge">i_spi_miso</code>
following a request from that known address, and the second property asserted
that the same known data would be returned in <code class="highlighter-rouge">o_wb_data</code> once <code class="highlighter-rouge">o_wb_ack</code> was
set.</p>

<p>I’ve since torn that work up.  It turns out that there’s an easier way
to do the same thing when you are using
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>.
We’ll still allow the formal tool to pick an arbitrary data value, but we can
do this without the heavy weight of the formal
<a href="/zipcpu/2018/07/13/memories.html">memories</a> rule.
In particular, we don’t need the arbitrary address, just the data.</p>

<p>Here’s how we’ll do it: we’ll create a rule that whenever the arbitrary data is
read, regardless of what address it is read from, that value read from the
device is returned to the bus.</p>

<p>We’ll start at the top by assuming a constant 32-bit value.  The formal solver
will get to pick any value it wants for these 32-bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	(* anyconst *) wire	[31:0]	f_data;</code></pre></figure>

<p>Next, we’ll define a
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
where an arbitrary octet, <code class="highlighter-rouge">B</code>, is received from the interface.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	sequence	DATA_BYTE(local input [7:0] B);
		(i_spi_miso == B[7])
		##1 (i_spi_miso == B[6])
		##1 (i_spi_miso == B[5])
		##1 (i_spi_miso == B[4])
		##1 (i_spi_miso == B[3])
		##1 (i_spi_miso == B[2])
		##1 (i_spi_miso == B[1])
		##1 (i_spi_miso == B[0]);
	endsequence</code></pre></figure>

<p>Did you notice that this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
accepted an 8-bit parameter?  Neat!</p>

<p>Now, if we string four of these 
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
together, then we can describe receiving an arbitrary value on the <code class="highlighter-rouge">i_spi_miso</code>
wire.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	sequence	THIS_DATA;
			DATA_BYTE(f_data[31:24])
			##1 DATA_BYTE(f_data[23:16])
			##1 DATA_BYTE(f_data[15: 8])
			##1 DATA_BYTE(f_data[ 7: 0]);
	endsequence</code></pre></figure>

<p>Note that this only works because <code class="highlighter-rouge">f_data</code> is constant, since the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
will reference the current value of <code class="highlighter-rouge">f_data</code>, rather than the value
when the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
is activated.</p>

<p>Now, here’s the trick: <code class="highlighter-rouge">THIS_DATA</code> is a
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
containing a description of our known data being received.  While this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
is being received, <code class="highlighter-rouge">ack_delay</code> will go from <code class="highlighter-rouge">7'd32</code> down to <code class="highlighter-rouge">7'd1</code>.  Once
<code class="highlighter-rouge">ack_delay</code> hits zero, or goes around again, there should also be an
acknowledgment.  So, let’s add to that assertion that the outgoing data also
matches the received data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assert property (@(posedge i_clk)
		(THIS_DATA and ((!i_reset)&amp;&amp;(i_wb_cyc)
			throughout
		((ack_delay == 7'd32)
			##1 (ack_delay == $past(ack_delay)-1) [*31])))
		|=&gt; (o_wb_ack)&amp;&amp;(o_wb_data == f_data));</code></pre></figure>

<p>Did you see how this accomplishes both sides of the
<a href="/zipcpu/2018/07/13/memories.html">memory proof</a>
requirement?  Because we placed the
<a href="/zipcpu/2018/07/13/memories.html">known data</a>
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
before the non-overlapping implication operator, <code class="highlighter-rouge">|=&gt;</code>, the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
acted as an assumption.  As a result, we now know that no matter what
value is received, the proper value will be returned.</p>

<p>I then applied the same basic approach to the configuration port.  However,
in the interests of space in an already long article, I’ll let you peruse it
if you are interested.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	generate if (OPT_CFG)
	begin
		// Configuration writes
		assert property (@(posedge i_clk)
			disable iff ((i_reset)||(!i_wb_cyc))
			((i_cfg_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(i_wb_we)&amp;&amp;(i_wb_data[8]))
			|=&gt; ((!cfg_user_mode)&amp;&amp;(o_spi_cs_n)&amp;&amp;(!o_spi_sck))
				&amp;&amp;(o_wb_ack)&amp;&amp;(!o_wb_stall));

		reg	[7:0]	f_wr_data;
		always @(posedge i_clk)
		if (user_request)
			f_wr_data &lt;= i_wb_data[7:0];

		assert property (@(posedge i_clk)
			disable iff ((i_reset)||(!i_wb_cyc))
			((i_cfg_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(i_wb_we)&amp;&amp;(!i_wb_data[8]))
			|=&gt; (((cfg_user_mode)&amp;&amp;(!o_spi_cs_n)&amp;&amp;(o_spi_sck)
				&amp;&amp;(o_wb_stall)) throughout
				(!o_spi_mosi)&amp;&amp;(ack_delay==7'd9)
				##1 (o_spi_mosi == f_wr_data[7])
							&amp;&amp;(ack_delay==7'd8)
				##1 (o_spi_mosi == f_wr_data[6])
							&amp;&amp;(ack_delay==7'd7)
				##1 (o_spi_mosi == f_wr_data[5])
							&amp;&amp;(ack_delay==7'd6)
				##1 (o_spi_mosi == f_wr_data[4])
							&amp;&amp;(ack_delay==7'd5)
				##1 (o_spi_mosi == f_wr_data[3])
							&amp;&amp;(ack_delay==7'd4)
				##1 (o_spi_mosi == f_wr_data[2])
							&amp;&amp;(ack_delay==7'd3)
				##1 (o_spi_mosi == f_wr_data[1])
							&amp;&amp;(ack_delay==7'd2))
			##1 ((cfg_user_mode)&amp;&amp;(!o_spi_cs_n)&amp;&amp;(!o_spi_sck)
				&amp;&amp;(actual_sck)&amp;&amp;(o_wb_stall)
				&amp;&amp;(o_spi_mosi == f_wr_data[0])
							&amp;&amp;(ack_delay==7'd1))
			##1 (o_wb_ack)&amp;&amp;(!o_wb_stall)&amp;&amp;(cfg_user_mode)
				&amp;&amp;(!o_spi_sck)&amp;&amp;(!actual_sck)&amp;&amp;(!o_wb_stall));

		// And then configuration reads.  First the write needs to
		// charge the o_wb_data buffer
		assert property (@(posedge i_clk)
			disable iff ((i_reset)||(!i_wb_cyc))
			((i_cfg_stb)&amp;&amp;(!o_wb_stall)&amp;&amp;(i_wb_we)&amp;&amp;(!i_wb_data[8]))
			##2 DATA_BYTE(f_data[7:0])
			|=&gt; (o_wb_ack)&amp;&amp;(o_wb_data == { 24'h0, f_data[7:0] })
				&amp;&amp;(cfg_user_mode)&amp;&amp;(!o_wb_stall));

		// Then it needs to stay constant until another SPI
		// command
		assert property (@(posedge i_clk)
			disable iff (i_reset)
			($past(!o_spi_sck))&amp;&amp;(!o_spi_sck)&amp;&amp;(cfg_user_mode)
			|=&gt; $stable(o_wb_data)&amp;&amp;(o_wb_data[31:8]==0));

	end endgenerate</code></pre></figure>

<h2 id="how-to-test-it">How to test it?</h2>

<p>Now that we’ve built <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">our
controller</a>,
how shall we test it to know that it works?</p>

<p>Hopefully you’ve been around long enough to remember all of our work building
a <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">basic debugging bus</a>,
following the <a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">initial vision I presented for controlling FPGA
logic</a>.
With just a little effort, we can connect a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
and our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to this <a href="/blog/2017/06/28/dbgbus-goal.html">debugging bus</a>,
and then see how our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> interacts
with the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<table align="center" style="float: right"><caption>Fig 19. Digilent's Digital Discovery 2</caption><tr><td><img src="/img/digital-discovery-top-130.png" alt="A Picture of Digilent's Digital Discovery 2 logic analyzer" width="280" /></td></tr></table>

<p>For <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this particular core</a>,
I didn’t start my debugging with the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>.
I started instead with a <a href="https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator">Digilent Digital
Discovery 2</a>.
Why?  Two reasons: 1. I had it <a href="/blog/2017/09/14/even-i-get-stuck.html">available to
me</a>
and on my desk, and 2. I was concerned about the timing of the clock pulses.
Sure enough, the 
<a href="https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator">DD</a>
revealed that the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>
<code class="highlighter-rouge">SB_IO</code> primitive in DDR mode delayed the <code class="highlighter-rouge">SCK</code> by one clock more than I was
expecting.  (The code above has been fixed to accommodate this.)  This sent
me back through the entire design to do some massive updates:
all other signals needed to be delayed by one and the <code class="highlighter-rouge">o_spi_sck</code> signal
needed to return to zero one cycle earlier.  Indeed, there were several head
scratching moments at this point in order to get the timing right.</p>

<p>We’ve <a href="/blog/2017/07/08/getting-started-with-wbscope.html">discussed hooking
up</a> the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
to a design before.  I’ll just touch on a couple of pieces briefly here.
First, you need to decide which 32-bits you want to capture and select a
relevant trigger.  I personally like to place the trigger in the MSB of this
word–it makes it easier to switch to a <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc">compressed wishbone
scope</a> later if I
need to.   In my case, I ultimately chose the following wires to capture:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assign	spixpress_debug = { (!o_spi_cs_n), wb_cyc,
				(wb_stb)&amp;&amp;(flash_sel),
				(wb_stb)&amp;&amp;(flash_cfg_sel), wb_we,
				flash_stall,flash_ack, wb_data[8:0],
				flash_data[8:0],
				3'h0,
				o_spi_cs_n, o_spi_sck, o_spi_mosi, i_spi_miso };</code></pre></figure>

<p>That gives me access to all of the critical
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
wires, as well as the entire
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
interface.</p>

<p>The majority of the connections required to connect this to the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
bus were made by <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>–allowing
me to remove the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
later if I so wish by just removing the <a href="https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt">scope’s AutoFPGA configuration file’s
name</a>
from the <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> command line.
Among other changes, this places the following additional code into the <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/main.v">main
design file</a> of
<a href="https://github.com/ZipCPU/icozip">this design</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	wbscope #(.LGMEM(7), .SYNCHRONOUS(1), .HOLDOFFBITS(8))
		spixscopei(i_clk, 1'b1, (!o_spi_cs_n), spixpress_debug,
			i_clk, wb_cyc, (wb_stb)&amp;&amp;(spixscope_sel),
			wb_we, wb_addr[0], wb_data,
			spixscope_ack, spixscope_stall, spixscope_data,
			spixscope_int);</code></pre></figure>

<p>The <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> <a href="https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt">configuration
file</a>
also places a <code class="highlighter-rouge">#define</code> into the
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/regdefs.h"><code class="highlighter-rouge">regdefs.h</code></a>
file, defining <code class="highlighter-rouge">R_SPIXSCOPE</code> to have the address of the control
register for the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>.</p>

<p>You can see the entire <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt">configuration file</a>
for this debugging scope
<a href="https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt">here</a>.
Adding this to the <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> command line
in the <a href="https://github.com/ZipCPU/icozip/tree/master/rtl/auto-data">auto-data</a>/<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/auto-data/Makefile">Makefile</a>
will add this to the design, and removing it from the command line will remove
this component and <a href="/zipcpu/2017/10/05/autofpga-intro.html">all of its
dependencies</a>
from the design as well.  There’s also a <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/spixscope.cpp">software
component</a>
to this
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>’s
setup as well, found in the <a href="https://github.com/ZipCPU/icozip/tree/master/sw/host">sw/host
directory</a>
of <a href="https://github.com/ZipCPU/icozip">the project</a>—but we’ve discussed <a href="/blog/2017/07/08/getting-started-with-wbscope.html">how
to build those
before</a>.</p>

<h3 id="test-one-using-wbregs-to-read-a-known-value-from-the-flash">Test one: Using wbregs to read a known value from the flash</h3>

<p>The next step, and really the first true test, is an important one when
designing for an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>:
you want to make certain you can read back a <em>known piece of data</em> from the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.  While
there may be other uses for the vendor identification protocol within the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> specification, I find that
using it as a test read from the device is the most useful.  In particular, if
I read that ID from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
I can quickly determine if I managed to get the sequencing right between all of
the various signals.</p>

<p>Looking over the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="http://www.cypress.com/file/177961/download">specfication</a>,
you’ll see that sending a <code class="highlighter-rouge">0x9f</code> to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip will request this identification value.  Ever after until the chip select
is deactivated, the incoming data to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is ignored, and the
outgoing data from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
will be this known identification sequence–just as we showed in Fig. 14 above.</p>

<p>Most of my designs contain a command-line driven
<a href="https://en.wikipedia.org/wiki/PEEK_and_POKE">peek and poke</a>
capability <a href="/blog/2017/06/16/dbg-bus-forest.html">I call
<code class="highlighter-rouge">wbregs</code></a>.
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/wbregs.cpp">This command</a>,
found in almost all of <a href="/projects.html">my system-level
projects</a>, allows you to read or
write addresses within the device’s internal
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>,
<a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">just the same as though those commands were issued
internally</a> from a source within the design.</p>

<p>In <a href="https://github.com/ZipCPU/icozip">this project</a>, which needs to support
software on both the <a href="https://www.raspberrypi.org">Raspberry
Pi</a> and on whatever <a href="/blog/2017/06/17/why-network-debugging.html">host machine might connect
to it</a>, the
project will build one of two versions of this
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/wbregs.cpp"><code class="highlighter-rouge">wbregs</code></a>
program.  The first is <code class="highlighter-rouge">arm-wbregs</code> for running on the
<a href="https://www.raspberrypi.org">Pi</a>, whereas the second is <code class="highlighter-rouge">pc-wbregs</code> for
running on whatever other host platform might connect with the
<a href="https://www.raspberrypi.org">Pi</a> over a <a href="/blog/2017/06/17/why-network-debugging.html">TCP/IP
connection</a>.</p>

<p>Let’s run this <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> manufacture
identification test using <code class="highlighter-rouge">pc-wbregs</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ ./pc-wbregs flashcfg 0x0100
00200000 (FLASHCFG)-&gt; 00000100
$ ./pc-wbregs flashcfg 0x09f
00200000 (FLASHCFG)-&gt; 0000009f
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000001
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000020
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000018
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [...M] 0000004d
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000001
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000080
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [...1] 00000031
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [...0] 00000030
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000083
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 000000ff</code></pre></figure>

<p>If you watched the lower octet of the results, you’ll see that we just
read the ID string: <code class="highlighter-rouge">01:20:18:4d:01:80:31:30:83</code>.  While that works for
debugging by hand, it’s somewhat hard to read and we can do this better.  So
let’s tighten this up a bit, by switching our development to C++.</p>

<h3 id="test-two-accessing-the-flash-from-within-a-c-program">Test two: Accessing the flash from within a C++ program</h3>

<p>I thought it might be fun to show how easy this is to do via C++ when using
the <a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">debugging bus concept</a>.
When using the <a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus
interface</a>,
all it takes is a call to the <code class="highlighter-rouge">m_fpga-&gt;readio(addr);</code> method to read from the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>, or
likewise a <code class="highlighter-rouge">m_fpga-&gt;writeio(addr,value);</code> call to write a value to the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.  In our
case, we have a configuration register at address <code class="highlighter-rouge">R_FLASHCFG</code> that we wish
to read from or write to, so an example of reading from this register would
look like,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">val</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">);</span></code></pre></figure>

<p>Looking at the relevant portion of <code class="highlighter-rouge">flashid.cpp</code>, it starts with clearing
the trigger for the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
(if present).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#ifdef	R_SPIXSCOPE
</span>	<span class="c1">// Start up the scope at the beginning, in case anything goes wrong
</span>	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_SPIXSCOPE</span><span class="p">,</span> <span class="mi">124</span><span class="p">);</span>
<span class="cp">#endif</span></code></pre></figure>

<p>This will cause the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
to trigger on the lowering of the <code class="highlighter-rouge">CS_n</code> line, and then to wait another
124 clocks before it <a href="/blog/2017/06/08/simple-scope.html">freezes its buffer and stops
collecting</a>.</p>

<p>The next step is to issue the <code class="highlighter-rouge">READID</code> command (<code class="highlighter-rouge">0x9f</code>) to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="mh">0x09f</span><span class="p">);</span></code></pre></figure>

<p>This will send a <code class="highlighter-rouge">0x9f</code> to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, and leave the chip select
active–just the way we designed <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a> to
behave above.</p>

<p>We can now read the actual identification bytes.  Even
though our goal is to <em>read</em>, because of how we built the interface we’ll
need to write to the register first in order to clock the data out out of the
device.  The information we write isn’t relevant, so we can just
write a zero, and later read from the register.</p>

<p>The following does exactly that, but with perhaps a little more flair.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="mh">0x000</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"ID:"</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">id</span><span class="p">;</span>

		<span class="c1">// Read and print the last byte read
</span>		<span class="n">id</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%c%02x"</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="sc">' '</span><span class="o">:</span><span class="sc">':'</span><span class="p">,</span> <span class="n">id</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
		<span class="c1">// and clock in the next byte across the SPI interface
</span>		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="mh">0x000</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span></code></pre></figure>

<p>Finally, now that we are all done, we’ll want to return the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> to its
default state, allowing regular reads to be made again.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span></code></pre></figure>

<p>What happens when we run this program?</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>./pc-flashid 
ID: 01:20:18:4d:01:80:31:30:83:ff:ff:ff</code></pre></figure>

<p>This is essentially the same thing we did before with <code class="highlighter-rouge">pc-wbregs</code>, only now
done from within C++.  That looks prettier now, doesn’t it?</p>

<p>If you look this value up in the
<a href="http://www.cypress.com/file/177961/download">flash specification</a>,
you can verify that these are indeed the right values we should expect.
Therefore, we’ve now finished test number two.</p>

<h3 id="test-three-copying-the-memory-out-of-the-flash">Test three: Copying the memory out of the flash</h3>

<p>For our next test, let’s try reading from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>We could use <code class="highlighter-rouge">wbregs</code> again to read a word from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  Here we read the
first word from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>./pc-wbregs flash
01000000 <span class="o">(</span>   FLASH<span class="o">)</span> : <span class="o">[</span>....] ff0000ff</code></pre></figure>

<p>This looks like a synchronization word.  Indeed, it matches the first word
in our binary design file, suggesting this might also be the first word of the
binary that came shipped with our <a href="http://www.icoboard.org">ICO board</a>.</p>

<p>So … let’s read out the entire design!</p>

<p>We’ll do that with a program I call
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/dumpflash.cpp"><code class="highlighter-rouge">dumpflash</code></a>.
It’s usually the first program I run on any board I purchase, so that I never
lose the original manufacture provided pre-loaded design image.  The relevant
line to read the entire <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
found within
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/dumpflash.cpp">`dumpflash.cpp</a>,
is simply</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readi</span><span class="p">(</span><span class="n">DUMPMEM</span><span class="p">,</span> <span class="n">BUFLN</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span></code></pre></figure>

<p>That’s it!  By the time that command returns, and it will take a while since
it’s reading the <em>ENTIRE</em> <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>, the <code class="highlighter-rouge">DUMPMEM</code> buffer
will contain all of the contents from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>Not all of these contents are relevant.</p>

<p>When a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is erased, all of
the bits within it are set to ones.  Usually, upon delivery, this is how a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
comes from the manufacturer with one exception: the board manufacturer has
usually placed an initial load into the beginning of the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>.  For this reason, we can
trim any all one’s words from the end of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> image.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">sz</span> <span class="o">=</span> <span class="n">BUFLN</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">((</span><span class="n">sz</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">))</span>
		<span class="n">sz</span><span class="o">--</span><span class="p">;</span>
	<span class="n">sz</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Once done, we can write the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> contents to an external file.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s">"w"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"ERR: Could not write %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fwrite</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span></code></pre></figure>

<p>That was easier than you might have expected, now, wasn’t it?  See how powerful
the <a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus
concept</a> is?</p>

<p>Just as a foot note, be aware that this data may be byte swapped at this
point.  The
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a> 
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">implementation I’ve
created</a>
is <a href="https://en.wikipedia.org/wiki/Endianness">big endian</a>,
even though most computers these days are <a href="https://en.wikipedia.org/wiki/Endianness">little
endian</a>.</p>

<h3 id="test-four-writing-to-the-flash">Test four: Writing to the flash</h3>

<p>Each of the projects I have containing a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a> also contains a <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">flash
driver</a>
host software component.  This makes writing to the 
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> fairly simple.</p>

<p>The <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.h">C++ interface</a>
to this <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">device driver</a>
is primarily a simple <code class="highlighter-rouge">write</code> function.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">FLASHDRVR</span> <span class="p">{</span>
	<span class="c1">// ...
</span>	<span class="n">FLASHDRVR</span><span class="p">(</span><span class="n">DEVBUS</span> <span class="o">*</span><span class="n">fpga</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_fpga</span><span class="p">(</span><span class="n">fpga</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_debug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
	<span class="c1">// ...
</span>	<span class="n">bool</span>	<span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">verify</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure>

<p>By calling this function with the address within the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
that you wish to write to, together with the length of the data and a pointer
to that same data, the <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">device
driver</a>
will first check what is currently written on the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
erase if necessary, and then write the new values to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>That function calls two other functions that need to work in order to be able
to program and reprogram the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  The
first is the <code class="highlighter-rouge">erase_sector</code> function, and the second the <code class="highlighter-rouge">page_program</code>
function.  Sector in this context is 4kB
of <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>,
aligned on a 4kB boundary.  A page is similar: it references
256 bytes of memory, aligned on a 256 byte boundary.</p>

<p>Erasing a sector requires a couple steps.  First, a command needs to sent to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
to enable write mode.  This is a simple <code class="highlighter-rouge">8'h06</code> command that needs to be sent
to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
It’s a straight forward use of the configuration port.  We’ll start by
clearing the configuration mode by writing <code class="highlighter-rouge">9'100</code> to the interface, just out
of an abundance of caution to make certain <code class="highlighter-rouge">o_spi_cs_n</code> is high (inactive).
We’ll then write the <code class="highlighter-rouge">8'h06</code> write enable command, <code class="highlighter-rouge">F_WREN</code>, and tell
the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to end the transaction by lowering <code class="highlighter-rouge">o_spi_cs_n</code> again.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">// Write enable
</span>	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_WREN</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span></code></pre></figure>

<p>We can now issue the sector erase command, <code class="highlighter-rouge">F_SE</code> or <code class="highlighter-rouge">0x0d8</code>.  This command
is followed by a three byte argument containing the
address of the 4kB segment that we wish to erase.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_SE</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span>    <span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span></code></pre></figure>

<p>We’ll then wait for this operation to complete by calling <code class="highlighter-rouge">flwait()</code>.
This function simply sends the “read-status register” command, <code class="highlighter-rouge">F_RDSR1=0x05</code>,
to the flash.  Ever after, every time 8-clocks are sent to the flash an
updated status register will be returned.  Once the low order bit, <code class="highlighter-rouge">WIP=1</code>,
is clear, the flash has finished erasing our sector.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>	<span class="n">FLASHDRVR</span><span class="o">::</span><span class="n">flwait</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">const</span>	<span class="kt">int</span>	<span class="n">WIP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// Write in progress bit
</span>	<span class="n">DEVBUS</span><span class="o">::</span><span class="n">BUSW</span>	<span class="n">sr</span><span class="p">;</span>

	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_RDSR1</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_EMPTY</span><span class="p">);</span>
		<span class="n">sr</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">sr</span><span class="o">&amp;</span><span class="n">WIP</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Erasing a sector turns all the bits in that sector to <code class="highlighter-rouge">1</code>.  This really isn’t
what we want to do end the end.  We want our data written to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
regardless of whether it consists of <code class="highlighter-rouge">1</code>’s or <code class="highlighter-rouge">0</code>’s, and we want the <code class="highlighter-rouge">1</code>’s
and <code class="highlighter-rouge">0</code>’s put in the right place.  The difference is associated with how
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is built.  The only way to turn a bit from a <code class="highlighter-rouge">0</code> to a <code class="highlighter-rouge">1</code> is to first erase a large block of <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>.  In this case, we erased
a 4kB sector.  Some
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips allow erasing smaller
portions of memory called subsectors.</p>

<p>One problem that results from erasing
4kB at a time in order to write to <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a> is that of collateral
damage: it is possible that by erasing a sector, some other valuable
information in that sector will get erased.  This <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">flash
driver</a>
handles that problem by assuming that you will be smart enough
not to do that.  (You will, right?)  If you write to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
using <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">this
driver</a>,
starting from a sector boundary and ending on a sector boundary then you will
have no problems.</p>

<p>The second step of writing information to a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is to <em>program</em> the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.  Programming the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> turns user specified bits
to <code class="highlighter-rouge">0</code>.  It cannot return bits to <code class="highlighter-rouge">1</code>, it can only turn them from <code class="highlighter-rouge">1</code> to <code class="highlighter-rouge">0</code>.</p>

<p>Programming the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is, in many ways, very similar to the erase cycle presented above.  It starts with sending a
write enable command to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Write enable
</span>		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_WREN</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span></code></pre></figure>

<p>followed by a “page program” command, <code class="highlighter-rouge">F_PP = 0x02</code> to actually write
the page of <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Issue the command
</span>		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_PP</span><span class="p">);</span></code></pre></figure>

<p>Like the erase command, the page program command needs the address of where
to begin programming.  This is passed as a three byte argument following
the 8-bit command word.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// The address
</span>		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span>    <span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span></code></pre></figure>

<p>The third step is to write the data, byte by byte, to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
controller, and hence to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Write the page data itself
</span>		<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
	<span class="o">//</span> <span class="p">...</span></code></pre></figure>

<p>Once this programming request closes, the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
will become busy again.  As with the erase, we’ll call the <code class="highlighter-rouge">flwait()</code>
function to wait for the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> to complete.</p>

<p>Now, using the
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/zipload.cpp">zipload</a>
program, we can load a <a href="/about/zipcpu.html">ZipCPU</a> executable program onto the 
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, to see if it runs.</p>

<p>I’ll skip to the end at this point and just say that the interface works.
You can now run the <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/sw/board/cputest.c">CPUTEST</a> on the
<a href="http://www.icoboard.org">ICO board</a>.  <a href="https://github.com/ZipCPU/zipcpu/blob/master/sw/board/hello.c">Hello
World</a> 
works too!</p>

<p>If you’d like more instructions, feel free to check out the
<a href="https://github.com/ZipCPU/icozip">README</a>
to the <a href="https://github.com/ZipCPU/icozip">icozip project</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Okay, so what have we done here?</p>

<ol>
  <li>
    <p>We learned about basic
  <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
  interactions.</p>
  </li>
  <li>
    <p>We’ve built a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to get fast access to reading from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
quick access to continued readings, and we even created a configuration port
for issuing arbitrary commands to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>
  </li>
  <li>
    <p>We demonstrated how a <code class="highlighter-rouge">cover()</code> statement can make building a new core
easier.</p>
  </li>
  <li>
    <p>We learned about System Verilog
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>,
and saw how they could simplify properties describing interactions that take
place over several clock cycles.</p>
  </li>
  <li>
    <p>We looked at how the
<a href="/zipcpu/2018/07/13/memories.html">memory properties</a>
for reading the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
could be written with just a single assertion.</p>
  </li>
  <li>
    <p>We then saw how powerful the
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>
was in order to know if this device driver worked or not.</p>
  </li>
  <li>
    <p>Finally, I pointed you to instructions for running one of two demonstration
programs on the <a href="/about/zipcpu.html">ZipCPU</a> on the
<a href="http://www.icoboard.org">ICO board</a>.</p>
  </li>
</ol>

<p>That’s a lot of ground in one post!  However, notice how it was necessary to
make it from design to demonstration to know that the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
fully worked.</p>

<p>While this may be a first <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>,
I wouldn’t recommend stopping here.  Most <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
chips</a> offer DSPI or QSPI support,
and even then there’s an <a href="https://en.wikipedia.org/wiki/Execute_in_place">eXecute In Place
(XIP)</a> option on top of that.
Usually, for a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller,
<a href="https://en.wikipedia.org/wiki/Execute_in_place">XIP</a> means that you don’t
need to re-issue the command–you can just issue the address and start reading.
However, these are topics we may return to on another day, but until then I
would encourage you to look into on your own should you be so interested.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For I am  the LORD, I change not; therefore ye sons of Jacob are not consumed. (Malachi 3:6)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
