<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>How to build a SPI Flash Controller for an FPGA</title>
  <meta name="description" content="Fig 1. The ICO board">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2018/08/16/spiflash.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">How to build a SPI Flash Controller for an FPGA</h1>
    <p class="post-meta"><time datetime="2018-08-16T00:00:00-04:00" itemprop="datePublished">Aug 16, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. The ICO board</caption><tr><td><img src="/img/icoBoard.Vorne.1.1.jpg" alt="Picture of an ICO Board" width="360" /></td></tr></table>

<p>Perhaps <a href="/formal/2018/07/21/zipcpu-icoboard.html">you may
remember</a> that
I’ve been working to port the <a href="/about/zipcpu.html">ZipCPU</a>
to an <a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> HX8k
platform: the <a href="http://www.icoboard.org">ICO board</a>.  I like to boast that the
<a href="/about/zipcpu.html">ZipCPU</a> was designed for low logic
applications, and the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> is certainly a
low logic chip.  While the <a href="/about/zipcpu.html">ZipCPU</a>
isn’t the <em>smallest</em> processor out there, there are some forth processors
that are much smaller, it does fit nicely with room to spare on the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> 8k.</p>

<p>However, if you want a design that starts immediately upon power up, or if you
want more memory than is available in 8kB of block RAM or (in this case) even
in 128kB of <a href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a>,
then you need access to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>.
Why?  First, <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a> is
non-volatile, so anything that reads from it can do so immediately upon
power up.  Second, most
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>’s <em>need</em> a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip to store their design
within, so <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips are a
common addition on <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> boards.  Third,
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
is fairly cheap: a single 16MB
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip can sell for as little as $1 on
<a href="https://www.digikey.com">Digikey</a>.  Given that my
<a href="/about/zipcpu.html">ZipCPU</a> design logic for the
<a href="http://www.icoboard.org">ICO board</a> only requires about
132kB of memory, that leaves me with <em>lots</em> of memory to play with … if I
just had a simple <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
controller.</p>

<p>I also had another reason for this project as well: I wanted to learn about
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog sequences</a>,
and whether or not they could be used to <a href="/blog/2017/10/19/formal-intro.html">formally
verify</a> a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>.
Yes, I had access to the full commercial (<a href="http://www.verific.com">Verific</a>
enabled) version of <a href="http://www.clifford.at/yosys">yosys</a>
to do this.  But I wanted to see how useful this full version would be when
it came to designing a new/better <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller.</p>

<p>So let’s see what it takes.</p>

<h2 id="lessons-learned-from-other-flash-controllers">Lessons learned from other flash controllers</h2>

<p>When I start any new design, my first step is to download the
<a href="https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view">schematic</a>
for the board that I have, and data sheets for all of the parts.  In this case, 
the <a href="http://icoboard.org">ICO board</a> has a <a href="http://www.cypress.com/file/177961/download">Cypress S25FL127S 128 Mbit
(16MByte) chip</a>
connected to the <a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
I then spend some time reading the specifications and studying the
<a href="https://drive.google.com/file/d/0By-zY9AlHqXIcXZ6ZWdBR2dPXzg/view">schematic</a>
before building anything.</p>

<p>In this case, by the time I came to
<a href="http://icoboard.org">this board</a>’s
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
I had already built several
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
controllers before.</p>

<table align="center" style="float: left"><caption>Fig 2. A Basys3 board</caption><tr><td><img src="/img/Basys3.png" alt="Picture of an Basys3 Board" width="360" /></td></tr></table>

<ol>
  <li>
    <p>The first <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller
I ever built was for the <a href="https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/">Basys-3 board</a>.
This board had a
<a href="http://www.cypress.com/file/196861/download">Spansion S25FL032P</a> 4MB
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
Since it was my first <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://opencores.org/project/qspiflash">controller</a> design, my goal was
to design something that could do everything:</p>

    <p>– It could read the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
   at both high (QSPI) and low
   (<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>) speeds</p>

    <p>– It could read the
   <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>’s internal
   configuration register in order to determine if the QSPI
   mode was even enabled</p>

    <p>– It could both erase and program the
   <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a></p>

    <p>– It could be used for reading the vendor identification words back from
   the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, and</p>

    <p>– It could be used for reading the status register and/or writing the
   configuration register of the
   <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

    <p><a href="https://opencores.org/project/qspiflash">This</a> was a great general
purpose <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller,
and I’ve used it many times since.  However, all of this extra logic has
consequences when you want to place your design on a small board.  How bad?
<a href="https://opencores.org/project/qspiflash">It</a> consumed about 1263
of the 7680 cells on an
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>,
or about 16% of the entire
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> logic.</p>

    <p>The other problem I had with this design was when I tried to place it onto
the Spartan 6/LX4 of the <a href="https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module">CMod
S6</a>.
Sure, there was plenty of room for the
<a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v">controller</a>
and the <a href="/blog/2017/06/05/wb-bridge-overview.html">debugging
bus</a>
I was using at the time–there just wasn’t much room for anything else.</p>
  </li>
</ol>

<table align="center" style="float: right"><caption>Fig 3. An Arty-A7 Board</caption><tr><td><img src="/img/arty-board.png" alt="Picture of an Arty Board" width="360" /></td></tr></table>

<ol start="2">
  <li>
    <p>Sometime later I decided I wanted to build a <em>high speed</em>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller, so that I
could push <a href="https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists">Digilent’s Arty</a>
up to a system clock rate of 200MHz.  Why 200MHz?
Because I had mistakenly thought this was the clock speed I’d need to use
to interact with the <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>
on board.  When I realized I <a href="https://opencores.org/project/wbddr3">couldn’t
interact</a> with the
<a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">SDRAM</a>
any faster than about 82MHz, I abandoned <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">this
controller</a>
and never used for any other projects.</p>

    <p>Still, if the <a href="http://opencores.org/project/qspiflash">last controller</a>
was full featured,
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">this one</a>
was even more so.
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">It</a>
not only allowed you to read and write any of several configuration
registers, it would also allow you to read and write the one-time
programmable (OTP) ROM.  Further, since I wanted this to run at 200MHz,
there was a lot of
<a href="/blog/2017/08/14/strategies-for-pipelining.html">pipelining</a>
(and extra latency) to <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">this controller</a>.</p>

    <p>In hind sight, <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/eqspiflash.v">this controller</a>
was a boat anchor.  It’s bloated with features I never used and as a result
was way too big for the job.</p>
  </li>
</ol>

<table align="center" style="float: left"><caption>Fig 4. A Cmod S6 board</caption><tr><td><img src="/img/cmods6.png" alt="Picture of a CMod S6" width="360" /></td></tr></table>

<ol start="3">
  <li>
    <p>However, when I needed to upgrade the
<a href="/about/zipcpu.html">ZipCPU</a> in my
<a href="https://github.com/ZipCPU/s6soc">S6SoC design</a> so that
it would support 8-bit bytes (the
<a href="/about/zipcpu.html">ZipCPU</a> was originally a 32-bit byte
architecture), I needed to find <a href="/blog/2017/06/12/minimizing-luts.html">spare
LUTs</a>
anywhere I could.  2,400 6-LUTs isn’t a lot of room for a multi-processing
<a href="/about/zipcpu.html">CPU</a>, and so I had to strip
everything out that I could.</p>

    <p>The first thing to go was everything but the read capability from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/wbqspiflash.v">controller</a>.
That removed 30% of the logic in the controller.</p>

    <p>It wasn’t enough.</p>

    <p>Then I stepped back and realized that I would only ever run the
<a href="/about/zipcpu.html">ZipCPU</a>
from an already programmed
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, and that all I ever
<em>really</em> needed from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
was the ability to read from it.  I didn’t need to be able to read
the status register, the configuation register, the vendor’s ID, or anything
else: I just needed to read the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>.</p>

    <p>I also needed speed.</p>

    <p>So I created a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
<a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v">controller</a>
that used the Spartan 6’s DDR capability so that it could read
from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> at the system
clock speed.  This
provided a rough 2x improvement in speed.  Further, the rewrite to create
this capability, and this capability alone dropped the
<a href="/blog/2017/06/12/minimizing-luts.html">number of LUTs</a>
used by the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> from
(roughly) 569 down to about 100 or so.</p>

    <p>(These numbers are approximate because
<a href="http://www.clifford.at/yosys">yosys</a> doesn’t yet pack
<a href="https://www.xilinx.com">Xilinx</a>
LUT’s together, but they do give an idea of usage.)</p>

    <p>Since <a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v">this
controller</a>
offered only a read capability and nothing more, I
called it my <a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v"><code class="language-plaintext highlighter-rouge">qflashxpress</code></a> controller.</p>
  </li>
</ol>

<table align="center" style="float: right"><caption>Fig 5. A TinyFPGA Bx</caption><tr><td><img src="/img/TinyFPGA-BX.png" alt="Picture of a TinyFPGA BX baord" width="120" /></td></tr></table>

<ol start="4">
  <li>
    <p>I recently started working on a fourth
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">controller</a>
modeled after this last one, but using the Dual SPI read mode of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  <a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/dualflexpress.v">This
controller</a>
is designed to support the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>
on the <a href="https://tinyfpga.com">TinyFPGA BX</a>.  However, on my pre-production
version of the <a href="https://tinyfpga.com">TinyFPGA BX</a>, only the MISO and MOSI
lines are connected to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, so the best/fastest I
could ever do is Dual SPI which would only allow me to read/write two
bits at a time.  (I have been assured that this has been fixed for the
production versions.)</p>

    <p>Unlike the previous <a href="https://github.com/ZipCPU/s6soc/blob/master/rtl/qflashxpress.v">qflashxpress
controller</a>,
I wanted the erase/program capability back.  Rather
then teach the HDL controller all of the necessary states associated with
erasing and reprogramming a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, I initially created
a bit banging port that could override the natural logic of the port.</p>

    <p>The more I thought this through, though, the more I realized that bit banging
over the <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus</a>
would be horrendously inefficient.  Better yet, the
code already had the capability to send data to and receive data from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, why not just
adjust the configuration access so that it can command an 8-bit transfer?</p>
  </li>
</ol>

<p>That leads me to the basic <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
I want to discuss today.</p>

<p>Why do I need a new <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>?
For a couple of reasons.  The first and perhaps more important is
the reality of how the <a href="http://www.icoboard.org">ICO board</a> was wired.</p>

<table align="center" style="float: none"><caption>Fig 6. ICO Board hardware overview</caption><tr><td><img src="/img/ico-hwoverview.svg" alt="Overview of the ICO board's hardware architecture" width="640" /></td></tr></table>

<p>In order to make certain that both the <a href="https://www.raspberrypi.org">Raspberry
Pi</a> <em>and</em> the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> could
control the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory, the
memory was routed through a
<a href="https://www.latticesemi.com/Products/FPGAandCPLD/MachXO2">MachXO2</a> chip
as a traffic controller.  However, the
<a href="https://www.latticesemi.com/Products/FPGAandCPLD/MachXO2">MachXO2</a> as wired
has no capability of dynamically controlling pin direction–the pins can only
ever go one way–either master in and slave out (MISO), or master out and
slave in (MOSI).  In other words,
any <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">flash controller</a>
for the <a href="http://www.icoboard.org">ICO board</a> can only ever use the traditional
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> mode, and
thus any DSPI or QSPI enabled controller will only consume excess and unused
logic in an already tight space.</p>

<p>All this is to say that this is my now a fifth generation
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
for me.  I’ve also learned along the way what’s important in a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>:</p>

<ol>
  <li>
    <p>First and foremost, the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>:
must be able to read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  It must do this
function well and fast, since this is its purpose for being.  As you’ll
see, with no other logic this will cost us 147 of the 7680 cells on the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>.</p>

    <p>If I wanted, I could stop here.  Nothing more is really required.</p>
  </li>
  <li>
    <p>Second, as an optional performance improvement, it should be able to read
data from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> in
long strings of uninterrupted transactions.
Adding this logic to the controller will eventually cost us another 88
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a> logic
cells.</p>
  </li>
  <li>
    <p>Third, as a second optional enhancement, it needs to support a single
configuration register providing access to the rest of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>’s
capabilities without burdening the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
with unnecessary features.  This final feature will cost an additional
38 logic cells, bringing our entire total up to 273 logic cells out of
7680, or about 3% of the entire design.</p>

    <p>This is a reasonable usage number for our purposes.</p>
  </li>
</ol>

<p>That’s <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">the controller</a>
we’ll examine today.</p>

<h2 id="basic-spi">Basic SPI</h2>

<p>If you are not familiar with the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">Serial Peripheral Interconnect
(SPI)</a> means
of communicating between digital components, then let me recommend the
<a href="https://www.fpga4fun.com/SPI.html">SPI article on fpga4fun.com</a>.  It’s short,
and it explains a lot of good details about the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI
protocol</a>
that you might find valuable.  In sum, it describes what can be a shared bus,
with typically a single master and many slaves, operating over a
synchronous (i.e. clocked) interface.</p>

<table align="center" style="float: none"><caption>Fig 7. A basic SPI transaction</caption><tr><td><img src="/img/spi-raw.svg" alt="Wiring diagram showing a SPI transaction" width="780" /></td></tr></table>

<p>The basic wires associated with this interface are:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CS_n</code>, a ‘negative logic’ chip select sometimes called <code class="language-plaintext highlighter-rouge">SS</code> for the “slave
select” line.  This is the one line that is unique to each bus slave.
It is used to create a capability whereby multiple chips can have access to
the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
bus at the same time.  The “master” simply selects the one chip it is
interested in.  The other chips are then required to place their output
pin into a high impedance state and to ignore any transactions for which
they are not selected.</p>

    <p>This means that anytime <code class="language-plaintext highlighter-rouge">CS_n</code> is high, the chip of interest is not selected
and all of other wires are “don’t cares”.</p>

    <p>The <code class="language-plaintext highlighter-rouge">CS_n</code> signal is also be used for synchronization.  Pulling this wire
low (active) signals to the slave the beginning of a transaction, and
hence the slave knows which bit is the “first” bit of the transaction packet.</p>

    <p>Today, we’ll be focusing on the interaction associated with a single chip.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SCK</code> is the serial clock.  Since this is a clocked interface, <code class="language-plaintext highlighter-rouge">SCK</code> provides
that clock.  The
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol allows for several definitions of how this clock needs to be
implemented, so check the chip you wish to interface with to double check
for example the polarity and phase of the clock signal that it is expecting.</p>

    <p>For our implementation below, we’ll insist that <code class="language-plaintext highlighter-rouge">SCK</code> be high any time
<code class="language-plaintext highlighter-rouge">CS_n</code> is inactive, even though technically this is a “don’t care” signal
in such cases.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MOSI</code>.  I pronounce this wire as “MOH-see”, although it’s technically the
acronymn, “Master Out Slave In”.  Some chips will call this wire SDI for
Slave Data In or even just SI for Slave Input.  This is the one wire
running from the master to all of the
slaves containing information coming from the master.</p>

    <p>As with the clock, pay attention to your chips specification of this signal.
We’ll treat this signal today as a signal that can only change on the
negative edge of <code class="language-plaintext highlighter-rouge">SCK</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">MISO</code>, or “MEE-soh” as I like to pronounce it, is the “Master In, Slave Out”
wire–a single wire interface shared among all
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
slaves and containing the data being returned from the selected slave device.
Some chips will call this wire SDO for Slave Data Out, or even SO for Slave
Output.  All of these terms refer to the same basic wire.</p>

    <p>Check the specification of the chip you are working with for details on this
signal, but from my experience this signal tends to change some number of <code class="language-plaintext highlighter-rouge">ns</code>
following the last negative <code class="language-plaintext highlighter-rouge">SCK</code> edge.  It should be stable whenever <code class="language-plaintext highlighter-rouge">SCK</code>
is high, as long as you don’t make <code class="language-plaintext highlighter-rouge">SCK</code> run too fast,
so you can read it any time <code class="language-plaintext highlighter-rouge">SCK</code> is high.</p>
  </li>
</ul>

<p>These are the basic signals we’ll be working with.</p>

<p>A <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> doesn’t typically use the
full interface capabilities, however.  Instead, every
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol I’ve read about has actually been a
<a href="https://en.wikipedia.org/wiki/Simplex_communication">Simplex</a>,
or one-way, protocol.  The basic
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
transaction involves sending an 8-bit command, followed by any command specific
arguments (if any–depends upon the command), after which the slave will
return some kind of response.  In no part of this process are both <code class="language-plaintext highlighter-rouge">MISO</code> and
<code class="language-plaintext highlighter-rouge">MOSI</code> lines containing valid data going in opposite directions at the same
time.
Either the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
is sending data to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip,
or the data is going in the reverse direction.</p>

<table align="center" style="float: none"><caption>Fig 8. SPI for Flash is a Simplex Protocol</caption><tr><td><img src="/img/spix/spi-simplex.svg" alt="Wiring diagram, showing a simplex SPI transaction--MISO is unsed during command, MOSI is unused during a response" width="780" /></td></tr></table>

<p>If you examine the
<a href="http://www.cypress.com/file/177961/download">specification</a>
for the <a href="http://www.cypress.com/file/177961/download">Cypress Flash</a>
device on the
<a href="http://www.icoboard.org">ICO board</a>, and look closely through it, you’ll
quickly discover that all transactions are composed of sequences of octets
(8-bits)–just like we discussed above.  This is common among
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> based
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips.</p>

<p>Those first 8-bits of the transaction, though, are the important ones.  Hence
the <a href="http://www.cypress.com/file/177961/download">spec</a>
outlines all the different commands that can be started from any 8-bit
value.  The command set is rather long, though, stretching across both
page 109 and 110–so I’ll only reference it here.  Further, there’s a whole
chapter devoted to walking through each of the commands in detail.</p>

<table align="center" style="float: right"><caption>Fig 9. Basic Flash I/O chip pins</caption><tr><td><img src="/img/spix/spix-io-pins.svg" alt="" width="420" /></td></tr></table>

<p>This <a href="https://en.wikipedia.org/wiki/Simplex_communication">simplex</a>
command response protocol also allows particular bastardizations of the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol whereby the <code class="language-plaintext highlighter-rouge">MISO</code> and <code class="language-plaintext highlighter-rouge">MOSI</code> lines are re-purposed into bi-directional
wires: the master might send on both bits during the argument period of the
command, and then receive on both bits during the response period.  This is
called “Dual SPI” mode, or DSPI for short.  Many
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chips (including <a href="http://www.cypress.com/file/177961/download">this one</a>)
also have two other wires, a negative logic reset/hold pin and a negative logic
write protect pin.  These can also be re-purposed into further bidirectional
data wires, creating a four-wire bidirectional data bus for even faster
communication.  This four wire mode is often called “Quad SPI”, or QSPI
for short.</p>

<p>Today, we’ll be looking at two basic capabilities, both within the basic
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> protocol.
The first capability will send a <em>read</em> command to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
and then read data back in the response.  This will be our basic read
capability.  The second will send an arbitrary 8-bit command to the flash,
and then maintain the <code class="language-plaintext highlighter-rouge">CS_n</code> pin low and the <code class="language-plaintext highlighter-rouge">SCK</code> pin stable (and high) until
either another command is received, or our
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
is explicitly told to adjust them again.</p>

<h3 id="read-only">Read only</h3>

<p>If you look through the command table on <a href="http://www.cypress.com/file/177961/download">page 109 of the specification for
this chip</a>, you’ll notice several
commands that can be used to read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  There’s the <code class="language-plaintext highlighter-rouge">READ</code>
command which tops out at a maximum <code class="language-plaintext highlighter-rouge">SCK</code> clock rate of <code class="language-plaintext highlighter-rouge">50MHz</code>, the
<code class="language-plaintext highlighter-rouge">FAST_READ</code>, topping out at 108MHz, the <code class="language-plaintext highlighter-rouge">DOR</code> or dual read output, and the
<code class="language-plaintext highlighter-rouge">QOR</code> or quad read output.  There are also some faster read commands, such as
the <code class="language-plaintext highlighter-rouge">DIOR</code> or dual I/O read and the <code class="language-plaintext highlighter-rouge">QIOR</code> or quad I/O read.  There are also
4-byte address commands, although they are not required on this <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>From my own experience, I have found that the reads delivering 4-bits at a
time are the fastest, especially when you can start the transaction immediately
with the address in what is sometimes called
<a href="https://en.wikipedia.org/wiki/Execute_in_place">XIP</a> mode–but we’ll have
to leave that discussion for another day, since the
<a href="http://www.icoboard.org">ICO board</a> layout doesn’t support these
high speed access modes.</p>

<p>So let’s return to the basic <code class="language-plaintext highlighter-rouge">READ</code> command.  This command starts from
the device in its idle or default state, requires the controller to send an
8-bit <code class="language-plaintext highlighter-rouge">READ</code> command to the device (<code class="language-plaintext highlighter-rouge">8'h03</code>), followed by a 3-byte (24-bit)
address.  Once done, the device will return bytes to us in sequence from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, starting at the
address we give it and incrementing by one for each byte read.</p>

<p>The <a href="http://www.cypress.com/file/177961/download">spec</a> shows a picture of
this operation for us, which I’ve copied below into Fig 10.</p>

<table align="center" style="float: none"><caption>Fig 10. The basic command to read from flash</caption><tr><td><img src="/img/spix/spi-spec.png" alt="" width="799" /></td></tr></table>

<p>Unlike many of the other things we’ve discussed, a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> interaction is very
much an organized interaction over many clock cycles.
Let’s copy our interaction into
<a href="https://www.wavedrom.com/editor.html">wavedrom</a> where we can edit it, and
then take another look again.</p>

<table align="center" style="float: none"><caption>Fig 11. Beginning our transaction design</caption><tr><td><img src="/img/spix/spi-bare.svg" alt="" width="780" /></td></tr></table>

<p>This now becomes our goal–the specification our component must match.</p>

<p>One key point in this picture is the clock rate.  The device will limit our
maximum <code class="language-plaintext highlighter-rouge">SCK</code> rate to 50MHz when using the basic read command, <code class="language-plaintext highlighter-rouge">8'h03</code>.  Given that my goal system clock rate for <a href="https://github.com/ZipCPU/icozip">this
design</a> is 50MHz as well, this will work well.</p>

<p>But how to get an <code class="language-plaintext highlighter-rouge">SCK</code>	of 50MHz from a 50MHz system clock?  To do this, <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">we’ll
use</a>
a <code class="language-plaintext highlighter-rouge">DDR</code> output function of the <code class="language-plaintext highlighter-rouge">SB_IO</code> primitive provided by the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>.
That will allow us to run all of our logic at full speed,
even though this clock signal will toggle twice as fast as our logic.</p>

<p>Before moving forward, let’s add one more design requirement to the
waveform file in Fig 11:  Our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
must also interact with a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
bus</a>.  Let’s think about
how we’ll do this for a moment.  Ideally, the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
will need to accept a request from the bus, and then immediately
start the read transaction with the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip.  Once done, the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
will need to return a response, <code class="language-plaintext highlighter-rouge">o_wb_ack</code> and
<code class="language-plaintext highlighter-rouge">o_wb_data</code>, to the same bus.  All in all, this should look something like
Fig 12 below.  In between the request and the acknowledgment, the <code class="language-plaintext highlighter-rouge">o_wb_stall</code>
signal should be high.</p>

<table align="center" style="float: none"><caption>Fig 12. Bus read transaction</caption><tr><td><img src="/img/spix/spi-read.svg" alt="" width="780" /></td></tr></table>

<p>Notice also that I added two other control wires to this picture: <code class="language-plaintext highlighter-rouge">ack_delay</code>
is an internal counter, and <code class="language-plaintext highlighter-rouge">o_spi_sck</code> is an output from our
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to the <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">DDR output
module</a>.</p>

<p>The <code class="language-plaintext highlighter-rouge">ack_delay</code> counter will be used to keep track of where
we are in the sequence.  This is shown at the bottom of Fig 12 above.  Once
<code class="language-plaintext highlighter-rouge">ack_delay</code> hits zero, we should be done with our transaction.  If you look
in the sequence above, you’ll notice that the same clock <code class="language-plaintext highlighter-rouge">ack_delay</code> hits
zero is also the clock <code class="language-plaintext highlighter-rouge">o_wb_ack</code> is high, <code class="language-plaintext highlighter-rouge">o_wb_data</code> is valid, <code class="language-plaintext highlighter-rouge">o_wb_stall</code>
returns to zero, and <code class="language-plaintext highlighter-rouge">CS_n</code> returns high.</p>

<p>The <code class="language-plaintext highlighter-rouge">o_spi_sck</code> signal also needs a bit more explanation.  This isn’t the
actual <code class="language-plaintext highlighter-rouge">SCK</code> signal going to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip, but rather
a signal to the <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">DDR output
module</a>
telling it to toggle the clock.  You may notice that this signal is set
immediately after the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
strobe (request) signal is accepted (i.e. strobe is high and stall is low).
However, the <code class="language-plaintext highlighter-rouge">SCK</code> signal doesn’t start toggling for another clock period
after setting this <code class="language-plaintext highlighter-rouge">o_spi_sck</code> signal high.  (This was unexpected, and so
we’ll discuss this again in our testing section below.  This one clock change
forced me to delay all of the other signals by one clock, as already shown in
Fig 12 above.</p>

<p>For now, though, let’s return to that <code class="language-plaintext highlighter-rouge">ack_delay</code> signal and just point out that
we’ll be using this signal internally to control a basic state machine.</p>

<p>We’ll start our state machine with a “bus request”: a request to read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.  That will look
something like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">wire</span>	<span class="n">bus_request</span><span class="p">;</span>
<span class="k">assign</span>	<span class="n">bus_request</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">);</span></code></pre></figure>

<p>We can then use this <code class="language-plaintext highlighter-rouge">bus_request</code> signal to start our <code class="language-plaintext highlighter-rouge">ack_delay</code> counter.
Once started, <code class="language-plaintext highlighter-rouge">ack_delay</code> will just count down to zero, when we will
acknowledge the bus request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">ack_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
	<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="mi">6'd65</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="n">ack_delay</span> <span class="o">-</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>The second piece of circuitry we’ll want is a shift register controlling the
<code class="language-plaintext highlighter-rouge">MOSI</code> values that we send to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
interface.  This will include both our command, <code class="language-plaintext highlighter-rouge">8'h03</code>, and the address we
wish to read from, <code class="language-plaintext highlighter-rouge">{ i_wb_address, 2'b0 }</code>.  (The last two bits are zero,
because the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
address is a word address, not a byte address.) Since we know the address at
time zero when the <code class="language-plaintext highlighter-rouge">bus_request</code> is made, this can be as simple as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
	<span class="c1">// Here's the data stream we wish to send</span>
	<span class="n">wdata_pipe</span>   <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="mh">8'h03</span><span class="p">,</span> <span class="n">i_wb_address</span> <span class="o">}</span><span class="p">;</span>
<span class="k">else</span>
	<span class="n">wdata_pipe</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="mb">1'b0</span> <span class="o">}</span><span class="p">;</span>

<span class="k">assign</span>	<span class="n">o_spi_mosi</span> <span class="o">=</span> <span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span></code></pre></figure>

<p>Note the extra zero bit out front.  This is due to the extra clock it takes to
start the DDR <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
<code class="language-plaintext highlighter-rouge">SCK</code> signal that we mentioned above, and diagrammed in Fig 12.</p>

<p>All that remains is to set the rest of our signals based upon this counter,
using Fig. 12 above as a guide.  Remember, signals that are set on the
positive edge of a clock need to be set one clock before they are to be valid.
Hence, if you want to set the <code class="language-plaintext highlighter-rouge">CS_n</code> signal high so that it is
high when <code class="language-plaintext highlighter-rouge">ack_delay</code> returns to zero, you’ll want to set it that way when
<code class="language-plaintext highlighter-rouge">ack_delay</code> is <code class="language-plaintext highlighter-rouge">7'd1</code>.</p>

<p>First, upon a bus request, we would get things started.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="n">o_spi_sck</span>  <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="n">o_wb_ack</span>   <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Then, while things are running, we update any signals.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="n">o_spi_sck</span>  <span class="o">&lt;=</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">o_wb_ack</span>   <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="n">o_wb_data</span>  <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="mi">30</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">i_spi_miso</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Once we get to the end, we’ll need to shut down our interface and return
an acknowledgment and our data.  We can also turn the stall signal off
at this time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// Turn off the interface</span>
	<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="n">o_spi_sck</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

	<span class="n">o_wb_ack</span>   <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="n">o_wb_data</span>  <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="mi">30</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">i_spi_miso</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Finally, if <code class="language-plaintext highlighter-rouge">ack_delay==0</code> and there’s no <code class="language-plaintext highlighter-rouge">bus_request</code>, then we just want
our interface to remain idle.  We’ll also quietly ignore any write requests
from the bus, acknowledging them immediately while we are idle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
	<span class="c1">// Interface is idle</span>
	<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="n">o_spi_sck</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

	<span class="n">o_wb_ack</span>   <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">);</span>
	<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>This is our primary capability.  We could ideally stop here if all you wanted
was a simple <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to only read from your <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<h3 id="second-piped-reads-as-well">Second: Piped reads as well</h3>

<p>One problem with stopping here, though, is that this approach to reading from a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory is <em>painfully</em>
slow–especially for a
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core CPU</a>
when its speed is limited by the speed it can read instructions from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
If you just count clock cycles, then the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
as is takes 66 cycles per
read.  This will limit any
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s speed to
66 <a href="https://en.wikipedia.org/wiki/Cycles_per_instruction">cycles per instruction
(CPI)</a>.  While this
may be faster than your average snail, I’d like <a href="/about/zipcpu.html">my
CPU</a> to run a bit faster.</p>

<p>If you remember our <a href="/zipcpu/2018/03/21/dblfetch.html">discussion about pipelining a
prefetch</a>, then
you’ll remember how I managed to keep a rolling
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
going in the presence of a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
device.  That would increase the speed of a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> bound
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
from 66
<a href="https://en.wikipedia.org/wiki/Cycles_per_instruction">CPI</a>
(minimum) up to 33 
<a href="https://en.wikipedia.org/wiki/Cycles_per_instruction">CPI</a>.  It’s
still a snail’s pace, but a factor of two better is still a factor of two.</p>

<p>How might we do this?</p>

<p>The first step is to go back to the
<a href="http://www.cypress.com/file/177961/download">specfication</a> for our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip, and then to
remember that once the read is started the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> will just keep producing
subsequent bytes.  This is what we’d like to capitalize on.  We could do this
if we just kept the transaction going for another 32-bit word, but only
if there was a request for the next word from the bus.  We’ll have to test
for that in a moment.</p>

<p>We’ll start this modified design by returning to our timing diagram.
Specifically, we’d like to be able to accept a request for the next
address just in time so that we don’t lose any clock cycles in our
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
transaction.  Hence, if we were just about at the end of one transaction,
then we should be able to extend it by one more transaction, as shown in Fig. 13
below.</p>

<table align="center" style="float: none"><caption>Fig 13. Pipelined read transaction</caption><tr><td><img src="/img/spix/spi-pipe.svg" alt="" width="780" /></td></tr></table>

<p>Notice a couple key points here.  First, the <code class="language-plaintext highlighter-rouge">ack_delay</code> line never hits
zero–it just immediately goes into the next word.  The <code class="language-plaintext highlighter-rouge">o_wb_ack</code> and
<code class="language-plaintext highlighter-rouge">o_wb_data</code> lines maintain their requirement, they are to be valid one
clock after <code class="language-plaintext highlighter-rouge">ack_delay==1</code>.  Indeed, in many
ways, this looks identical to what we had before with the exception that
following a <code class="language-plaintext highlighter-rouge">bus_request</code> for the next word we go immediately into reading it
instead of sending a new address.</p>

<p>Our first problem in this picture is the stall line–it needs to be low one
clock early, or when <code class="language-plaintext highlighter-rouge">ack_delay==1</code>, and not when <code class="language-plaintext highlighter-rouge">ack_delay</code> returns to zero.
The only thing is, we can’t do this at all times, but <em>only</em> when
the address requested is for the next word, <em>only</em> when this is a read request.</p>

<p>That’s going to require some extra logic.</p>

<p>It also requires a little bit of trickery that doesn’t quite follow the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/doc/wbspec_b4.pdf">specification</a>:
we’ll take a peek at any pending transaction on one clock and set a flag
based upon it,
then we’ll check that flag and drop <code class="language-plaintext highlighter-rouge">o_wb_stall</code> if necessary on the
following clock.  This new flag, <code class="language-plaintext highlighter-rouge">next_request</code> is shown at the bottom of
Fig. 13 above.</p>

<p>So here’s the extra logic.  First, we’ll capture the next address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">21</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">next_addr</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">))</span>
		<span class="n">next_addr</span> <span class="o">&lt;=</span> <span class="n">i_wb_addr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Then, we’ll put our <code class="language-plaintext highlighter-rouge">next_request</code> flag together.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">next_request</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_addr</span> <span class="o">==</span> <span class="n">next_addr</span><span class="p">);</span></code></pre></figure>

<p>Now we can come back and review our basic signals from before.</p>

<p>The <code class="language-plaintext highlighter-rouge">MOSI</code> signal is a don’t care, so we can keep our <code class="language-plaintext highlighter-rouge">wdata_pipe</code> logic
simple.</p>

<p>The logic for <code class="language-plaintext highlighter-rouge">CS_n</code> doesn’t change either–it’s set to zero on any bus
request, and this pipe request (once the stall is lowered) is just another
bus request.</p>

<p>The <code class="language-plaintext highlighter-rouge">ack_delay</code> logic does need to be adjusted, but this is minor.  Specifically, if there’s a <code class="language-plaintext highlighter-rouge">bus_request</code> where <code class="language-plaintext highlighter-rouge">CS_n</code> is already low, then only set
<code class="language-plaintext highlighter-rouge">ack_delay</code> to 32 instead of <code class="language-plaintext highlighter-rouge">65</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">ack_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">o_spi_cs_n</span><span class="p">)</span> <span class="o">?</span> <span class="mi">7'd65</span> <span class="o">:</span> <span class="mi">7'd32</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="n">ack_delay</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">SCK</code> and <code class="language-plaintext highlighter-rouge">o_wb_stall</code> signals are a touch more difficult.  First, the
<code class="language-plaintext highlighter-rouge">SCK</code> signal needs to remain high one clock longer if <code class="language-plaintext highlighter-rouge">next_request</code> is high.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_spi_sck</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="c1">// NEW LOGIC: keep the clock going if there's a second request</span>
	<span class="c1">// coming.</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">next_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Second, and really this is the key piece of logic on which all the others
depend, the stall line needs to be lowered
so the request can be accepted in time to start the new transaction without
any delayed cycles.  This pins the stall low clock period to be the same 
clock period where <code class="language-plaintext highlighter-rouge">ack_delay</code> is one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="c1">// NEW LOGIC: Drop the stall line if a request for the</span>
	<span class="c1">// next address is pending.  The stall line will be</span>
	<span class="c1">// low in this case when ack_delay == 1.</span>
	<span class="c1">//</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">next_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>Notice how these changes are fairly minor, but yet they can speed up a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
<a href="/zipcpu/2018/03/21/dblfetch.html">instruction fetch by a factor of
two</a> (… but only if the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
doesn’t use the bus for data, doesn’t branch, doesn’t … etc).  There are
some <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> speed
details in there that I’m glossing over.  Still, we haven’t changed our
logic all that much to get this additional capability.</p>

<p>At this point, we could stop again.  We’d now have a faster <code class="language-plaintext highlighter-rouge">ROM</code>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> device.  The 
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> would need to be written
using some other configuration, but we’d be able to read it in high speed.</p>

<p>But, couldn’t we get the ability to read and write the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> for just a little bit more
work?  That’s the purpose of the configuration port that we’ll discuss next.</p>

<h3 id="third-configuration-port">Third: Configuration port</h3>

<p>Can we add a configuration port capability to this 
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>?
Specifically, it would be nice to have access to all of those other commands
outlined in the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="http://www.cypress.com/file/177961/download">specfication</a>.</p>

<p>Let’s use a separate
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
port for this purpose.  By that I mean, let’s create a separate strobe signal,
<code class="language-plaintext highlighter-rouge">i_cfg_stb</code>,
but otherwise share all of the signals between these two ports.  The <a href="/blog/2017/06/22/simple-wb-interconnect.html">bus
interconnect</a>
can then set this new strobe signal, <code class="language-plaintext highlighter-rouge">i_cfg_stb</code>, to indicate
a request on this new port.</p>

<p>Unlike the primary <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
bus</a>,
we’ll make this one so that you can both write and then read
from this port.  Write’s will send 8-bits to the device over the <code class="language-plaintext highlighter-rouge">MOSI</code> line,
and reads will read the 8-bits returned in the <code class="language-plaintext highlighter-rouge">MISO</code> line.  In order to
allow longer interactions, extending beyond a single 8-bit transaction,
we’ll allocate bit <code class="language-plaintext highlighter-rouge">i_wb_data[8]</code> and use it to control the <code class="language-plaintext highlighter-rouge">CS_n</code> bit.</p>

<p>Fig. 14 below shows this concept of this protocol.</p>

<table align="center" style="float: none"><caption>Fig 14. Configuration port transaction</caption><tr><td><img src="/img/spix/spi-cmd.svg" alt="A direct SPI command, bypassing the controller" width="780" /></td></tr></table>

<p>Writes with <code class="language-plaintext highlighter-rouge">i_wb_data[8]</code> low will cause 8-bits to be sent, reads will
return the response.  Writes with <code class="language-plaintext highlighter-rouge">i_wb_data[8]</code> set will return the
device to the mode where we can read data again.</p>

<p>Were we building <em>only</em> this interface, the logic would look <em>very</em> similar to
just the logic necessary to implement Fig. 14 above.  We’d start with an
<code class="language-plaintext highlighter-rouge">user_request</code> signal, capturing the write request on this configuration
channel.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">wire</span>	<span class="n">user_request</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_ata</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span></code></pre></figure>

<p>Then we could just walk through our basic signals again.</p>

<p>We’d start with the <code class="language-plaintext highlighter-rouge">MOSI</code> signal.  This was based upon a <code class="language-plaintext highlighter-rouge">wdata_pipe</code>
shift register before.  We can do this again now.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">wdata_pipe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_request</span><span class="p">)</span>
		<span class="n">wdata_pipe</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="mh">24'h0</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wdata_pipe</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="mb">1'b0</span> <span class="o">}</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">o_spi_mosi</span> <span class="o">=</span> <span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span></code></pre></figure>

<p>We can keep our <code class="language-plaintext highlighter-rouge">ack_delay</code> state variable as well.  Only now, we’ll start it
from <code class="language-plaintext highlighter-rouge">7'd9</code> instead of <code class="language-plaintext highlighter-rouge">7'd65</code>, but the rest of the logic is nearly identical.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">ack_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user_request</span><span class="p">)</span>
		<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="mi">7'd9</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="n">ack_delay</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Amazingly, the rest of the logic is the same as it was before, save for
some new checks for <code class="language-plaintext highlighter-rouge">(user_request)</code> instead of <code class="language-plaintext highlighter-rouge">(bus_request)</code> to know when
to start a transaction.</p>

<p>This is why I like this particular approach over and above the bit-banging
approach I had tried on the fourth attempt I wrote about above–you can
share most of the configuration port logic with the regular read logic we
presented above.</p>

<h2 id="examining-the-controllers-verilog-code">Examining the Controller’s Verilog Code</h2>

<p>We’ve now walked through a description of how the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
interaction works, together with three separate interactions we want to
accomplish.  At this point, you know the basics, and you’ve seen some
useful code snippets.  The problem is we’ve ignored several key details
of this implementation along the way:</p>

<ul>
  <li>
    <p>Resets</p>

    <p>Our <a href="/zipcpu/2017/11/07/wb-formal.html">formal property list for the
Wishbone bus</a>
requires the implementation of a reset signal.</p>
  </li>
  <li>
    <p>Aborts</p>

    <p>Similarly, the <a href="/zipcpu/2017/11/07/wb-formal.html">formal properties for the
Wishbone</a>
bus require us to support the case where the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> (or other bus
master) suddenly aborts the 
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
transaction.</p>

    <p>I’ve come across two approaches to this requirement.  One is to continue the
transaction anyway, and just not to acknowledge the result at the end.
The second approach, which we’ll use here, is to actually terminate the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
transaction.</p>
  </li>
  <li>
    <p>All Acknowledgments</p>

    <p>A third problem we have is that we’ve only discussed how to respond to three
of four possible requests.  We’ve discussed how to respond to a bus read,
and to reads from and writes to the configuration port.  What about
writes to the read port?  Or reads from the configuration port when
the port isn’t in the configuration mode?  (i.e. when <code class="language-plaintext highlighter-rouge">CS_n</code> remains high)</p>

    <p>Some controllers would issue
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a> for the unsupported
transactions shown in Fig. 15 below.  However, in my search for low logic
and simple controllers, I tend to <a href="/zipcpu/2017/11/07/wb-formal.html">return acknowledgments
instead</a>–even when a
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a> might make more sense.
We can argue over whether or not this is the best choice, but today’s
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
doesn’t issue any
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a>.</p>
  </li>
</ul>

<table align="center" style="float: right"><caption>Fig 15. Request Combinations</caption><tr><td><img src="/img/spix/spix-ack.svg" alt="Chart showing the different types of transactions" width="480" /></td></tr></table>

<p>Actually, I’m personally kind of conflicted over whether or not this was the
  right implementation choice, so I’ll listen to anyone with an opinion on the
  issue.</p>

<p>Specifically, we’ll simply acknowledge an illegal operation, even
  if it means returning potentially bad data.  In Fig. 15 above, I called
  these “Empty ACK”s.</p>

<ul>
  <li>
    <p>Options</p>

    <p>Because I know that different designs will have different needs, I’m also
going to implement our extensions as part of two options controlled by
one bit parameters: if <code class="language-plaintext highlighter-rouge">OPT_PIPE</code> is set to <code class="language-plaintext highlighter-rouge">1'b1</code>, the core will support
pipelined reads.  Similarly, if the <code class="language-plaintext highlighter-rouge">OPT_CFG</code> parameter is set to <code class="language-plaintext highlighter-rouge">1'b1</code>
the core will support the configuration port.</p>

    <p>Perhaps I should also create an <code class="language-plaintext highlighter-rouge">OPT_ERROR</code> that can be set if I want this
core to return a
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a>
for the unsupported cases in Fig. 15.  That would certainly be an option.</p>
  </li>
</ul>

<p>There’s one last difference you’ll see in the code below.  That is that I like
to split up my always blocks so that they only define the logic for one
register at a time.
This has two purposes.  First, it helps to minimize the gate count.  Wires
that don’t depend upon lots of nested if’s don’t need to have that nested
if logic required by other signals encumbering them.  Second, it keeps me
from the <a href="http://www.clifford.at/papers/2017/togglemux/dac2017_paper.pdf">issue associated with ‘x’, or don’t care,
values</a>.</p>

<p>Do I find this multiple always block approach more confusing?  Yes.  However,
the <a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
help to keep me out of trouble, and catch any cases I might be missing.</p>

<p>That said, let’s walk through <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">the
code</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">spixpress</span><span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="n">i_reset</span><span class="p">,</span>
		<span class="n">i_wb_cyc</span><span class="p">,</span> <span class="n">i_wb_stb</span><span class="p">,</span> <span class="n">i_cfg_stb</span><span class="p">,</span> <span class="n">i_wb_we</span><span class="p">,</span> <span class="n">i_wb_addr</span><span class="p">,</span> <span class="n">i_wb_data</span><span class="p">,</span>
			<span class="n">o_wb_stall</span><span class="p">,</span> <span class="n">o_wb_ack</span><span class="p">,</span> <span class="n">o_wb_data</span><span class="p">,</span>
		<span class="n">o_spi_cs_n</span><span class="p">,</span> <span class="n">o_spi_sck</span><span class="p">,</span> <span class="n">o_spi_mosi</span><span class="p">,</span> <span class="n">i_spi_miso</span><span class="p">);</span>
	<span class="c1">//</span>
	<span class="c1">// OPT_PIPE allows successive, sequential, transactions to</span>
	<span class="c1">// incrementing addresses without requiring a new address to be sent.</span>
	<span class="c1">//</span>
	<span class="c1">// Random access performance:	65+64(N-1)</span>
	<span class="c1">// Performance when pipelined:	65+32(N-1)</span>
	<span class="c1">//</span>
	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_PIPE</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="c1">// OPT_CFG creates a configuration register that can be accessed through</span>
	<span class="c1">// i_cfg_stb when the core isn't busy.  Using this configuration</span>
	<span class="c1">// register, it is possible to send arbitrary commands to the flash,</span>
	<span class="c1">// and hence to erase or program the flash.  Since the access is</span>
	<span class="c1">// arbitrary, other flash features are supported as well such as</span>
	<span class="c1">// programming or reading the one-time-programmable memory or more.</span>
	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_CFG</span>  <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>You may remember the <code class="language-plaintext highlighter-rouge">bus_request</code>, <code class="language-plaintext highlighter-rouge">next_request</code>, and <code class="language-plaintext highlighter-rouge">user_request</code> (i.e.
the configuration port request) from our discussions above.  Here are those
definitions now.  The big differences here from the logic I presented above
are the <code class="language-plaintext highlighter-rouge">OPT_PIPE</code> and <code class="language-plaintext highlighter-rouge">OPT_CFG</code> parameters.  The synthesis tool will use
these one-bit logic values to trim logic below, starting with this logic here
in case either of these two options are not defined.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">bus_request</span>  <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">cfg_user_mode</span><span class="p">);</span>
	<span class="k">assign</span>	<span class="n">next_request</span> <span class="o">=</span> <span class="p">(</span><span class="n">OPT_PIPE</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">cfg_user_mode</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_addr</span> <span class="o">==</span> <span class="n">next_addr</span><span class="p">);</span>
	<span class="k">assign</span>	<span class="n">user_request</span> <span class="o">=</span> <span class="p">(</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span></code></pre></figure>

<p>One requirement we shall place upon the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
is that the two ports are to have different addresses on the same bus.  In
other words, <code class="language-plaintext highlighter-rouge">i_wb_stb</code> may be high or <code class="language-plaintext highlighter-rouge">i_cfg_stb</code>, but never both on the
same clock.</p>

<p>We’ll start building our logic with the state variable that will drive
everything else, <code class="language-plaintext highlighter-rouge">ack_delay</code>.  This logic is just as we discussed above,
save that we’ve now merged all three modes together, and added support for
resets and <a href="/zipcpu/2017/11/07/wb-formal.html">bus
aborts</a> that would bring us
back to an idle state early.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">ack_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
		<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">OPT_PIPE</span><span class="p">))</span> <span class="o">?</span> <span class="mi">7'd65</span> <span class="o">:</span> <span class="mi">7'd32</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">user_request</span><span class="p">)</span>
		<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="mi">7'd9</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="n">ack_delay</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>The simplest wire to control in this design is the <code class="language-plaintext highlighter-rouge">MOSI</code> wire.  This follows
from the <code class="language-plaintext highlighter-rouge">wdata_pipe</code> discussion above, only we’ve now combined the two types
of bus requests together.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">wdata_pipe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
		<span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">i_wb_addr</span><span class="p">[</span><span class="mi">21</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="mb">2'b00</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">22</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="mb">1'b0</span> <span class="o">}</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(((</span><span class="o">!</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">))</span> <span class="c1">// (bus_request)</span>
		<span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">32</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="mh">8'h03</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">))</span> <span class="c1">// (user_request)</span>
		<span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">32</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">32</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">23</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">o_spi_mosi</span> <span class="o">=</span> <span class="n">wdata_pipe</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span></code></pre></figure>

<p>Notice the two extra bits at the end of <code class="language-plaintext highlighter-rouge">{ i_wb_addr[21:0], 2'b00 }</code>.
These will be pruned by the optimizer within the <a href="http://www.clifford.at/yosys">synthesis
tool</a>.
I’ve kept them in there to keep the bottom bits of shift register byte aligned,
although they could easily be pruned here.  The top zero bit of
<code class="language-plaintext highlighter-rouge">{ 1'b0, 8'h03 }</code> follows from the reality that it will cost a one
clock delay to get the <code class="language-plaintext highlighter-rouge">SCK</code> to start toggling after we set <code class="language-plaintext highlighter-rouge">o_spi_sck</code>.</p>

<p>The other thing to notice about the <code class="language-plaintext highlighter-rouge">wdata_pipe</code> logic is that I’ve split
it into two blocks.  This is for exactly those same reasons I was describing
above.  Bits <code class="language-plaintext highlighter-rouge">[23:0]</code> depend only upon the address, and then only upon a read
request.  Once set and the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
turns busy, these become a shift register that shifts left.
Bits <code class="language-plaintext highlighter-rouge">[32:24]</code> are similarly a shift register when busy, but when upon
a regular bus request these are the read command.  Otherwise on a configuration
port write, these bits are set to the bottom 8-bits from the data bus.</p>

<p>Turning to the bus acknowledgment signal, <code class="language-plaintext highlighter-rouge">o_wb_ack</code>, this is
just set any time the <code class="language-plaintext highlighter-rouge">ack_delay</code> transitions to zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">);</span></code></pre></figure>

<p>Well, not quite.  We needed to support
<a href="/zipcpu/2017/11/07/wb-formal.html">bus aborts</a>, so
<code class="language-plaintext highlighter-rouge">o_wb_ack</code> is set to zero if the cycle line was dropped.</p>

<p>Even that’s not it.  We still need to acknowledge anything that will not
set the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
port in motion.  That’s the rest of the <code class="language-plaintext highlighter-rouge">o_wb_ack</code> logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">bus_request</span><span class="p">))</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">user_request</span><span class="p">))</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>If the configuration port parameter, <code class="language-plaintext highlighter-rouge">OPT_CFG</code>, is set then we’ll need to
keep track of whether or not the port is forcing the <code class="language-plaintext highlighter-rouge">CS_n</code> line low.  We’ll
call this the <code class="language-plaintext highlighter-rouge">cfg_user_mode</code> and use a register of the same name to keep
track of whether or not we need to hold <code class="language-plaintext highlighter-rouge">CS_n</code> low while waiting for the
next transaction.  This idea of holding <code class="language-plaintext highlighter-rouge">CS_n</code> low was shown on the right
edge of Fig 14 above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">cfg_user_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">cfg_user_mode</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="n">cfg_user_mode</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span></code></pre></figure>

<p>One variable we didn’t discuss above was the <code class="language-plaintext highlighter-rouge">actual_sck</code> register defined
below.  This register’s purpose is to unwind the delay associated with the
<code class="language-plaintext highlighter-rouge">SCK</code> <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">DDR
implementation</a>,
which causes <code class="language-plaintext highlighter-rouge">SCK</code> one cycle after we set <code class="language-plaintext highlighter-rouge">o_spi_sck</code> high.  This register
is an important part of knowing when to shift a new bit into <code class="language-plaintext highlighter-rouge">o_wb_data</code> next.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">actual_sck</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
		<span class="n">actual_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">actual_sck</span> <span class="o">&lt;=</span> <span class="n">o_spi_sck</span><span class="p">;</span></code></pre></figure>

<p>We need <code class="language-plaintext highlighter-rouge">actual_sck</code> to tell us when to update the outgoing data register,
<code class="language-plaintext highlighter-rouge">o_wb_data</code>, with a new <code class="language-plaintext highlighter-rouge">i_spi_miso</code> value.  Basically, anytime <code class="language-plaintext highlighter-rouge">actual_sck</code>
is high, we’ll clock in a new <code class="language-plaintext highlighter-rouge">i_spi_miso</code> bit on the right, pushing everything
left.  If <code class="language-plaintext highlighter-rouge">cfg_user_mode</code> is high, we’ll also clear the high 24-bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">actual_sck</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg_user_mode</span><span class="p">)</span>
			<span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mh">24'h0</span><span class="p">,</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">i_spi_miso</span> <span class="o">}</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="mi">30</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">i_spi_miso</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfg_user_mode</span><span class="p">)</span>
		<span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mh">24'h0</span><span class="p">,</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Let’s return to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
port again for a bit.  Here’s the logic for the <code class="language-plaintext highlighter-rouge">CS_n</code> signal.  Note the
few differences.  First, we set (inactivate) <code class="language-plaintext highlighter-rouge">CS_n</code> on any reset or bus
idle (or abort), save when <code class="language-plaintext highlighter-rouge">cfg_user_mode</code> is true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_spi_cs_n</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">cfg_user_mode</span><span class="p">))</span>
		<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Otherwise, the rest is just about as it was, save for the extra configuration
mode logic: clearing <code class="language-plaintext highlighter-rouge">o_cs_n</code> and holding it clear while <code class="language-plaintext highlighter-rouge">cfg_user_mode</code> is
high, until it is released by the next configuration register write–following
Fig. 14 above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfg_user_mode</span><span class="p">)</span>
		<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">cfg_user_mode</span><span class="p">))</span>
		<span class="n">o_spi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">o_spi_sck</code> signal is mostly just the merge of the logic above.
Differences include the reset and <a href="/zipcpu/2017/11/07/wb-formal.html">bus
abort</a>
logic.  Other than that, we set <code class="language-plaintext highlighter-rouge">o_spi_sck</code> on any request, and clear it once
the <code class="language-plaintext highlighter-rouge">ack_delay</code> register has counted down to one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_spi_sck</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">bus_request</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">user_request</span><span class="p">))</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// Bus abort check</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">next_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_spi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Notice that in the case of a pipelined read, the case where we don’t want
to clear <code class="language-plaintext highlighter-rouge">o_spi_sck</code> on clock one, <code class="language-plaintext highlighter-rouge">bus_request</code> will be true.  Hence we only
need to check for <code class="language-plaintext highlighter-rouge">ack_delay &gt; 2</code> and <code class="language-plaintext highlighter-rouge">ack_delay == 2</code>.</p>

<p>That brings us back to the bus, and to the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
stall signal, <code class="language-plaintext highlighter-rouge">o_wb_stall</code>.  If there’s no ongoing bus cycle, we’ll set
the stall line to zero.  Likewise, on any <code class="language-plaintext highlighter-rouge">bus_request</code> or configuration port
<code class="language-plaintext highlighter-rouge">user_request</code>, the stall line goes high while we respond to the request.
Finally, when <code class="language-plaintext highlighter-rouge">ack_delay</code> gets to zero, <code class="language-plaintext highlighter-rouge">o_wb_stall</code> must also return to zero.</p>

<p>That’s our logic below, save only for the special exemption when there’s a
request for the next address in memory, in order to support pipelined read requests.
That was the “New logic” we presented and discussed above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">bus_request</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">user_request</span><span class="p">))</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">next_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>Finally, our <code class="language-plaintext highlighter-rouge">next_addr</code> logic below is identical to what we presented above,
save that this time we’ve used the <code class="language-plaintext highlighter-rouge">OPT_PIPE</code> flag to guarantee that this
<code class="language-plaintext highlighter-rouge">next_addr</code> calculation will only create logic when <code class="language-plaintext highlighter-rouge">OPT_PIPE</code> is non-zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_PIPE</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="kt">reg</span>	<span class="p">[</span><span class="mi">21</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">r_next_addr</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
			<span class="n">r_next_addr</span> <span class="o">&lt;=</span> <span class="n">i_wb_addr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">next_addr</span> <span class="o">=</span> <span class="n">r_next_addr</span><span class="p">;</span>

	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>

		<span class="k">assign</span> <span class="n">next_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>That’s <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">our flash
controller</a>!</p>

<p>The big remaining question remaining, though, is whether or not
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this core</a>
will work in practice and on my <a href="http://www.icoboard.org">ICO Board</a>.  So,
let’s turn our attention from creating this
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to verifying it.</p>

<h2 id="formally-verifying-the-flash">Formally Verifying the flash</h2>

<p>Normally when I get to this section of a post, I walk through the
verification of a core in the order the logic exists within a core.</p>

<p>I’m going to try a bit of a different order today.</p>

<p>Let’s instead work through this core in the order that I would build the
properties within the file.  I’ll try to follow the spirit of the
<em>formal driven development</em> concept I <a href="/formal/2018/07/14/dev-cycle.html">shared
earlier</a>.  This means
that I will start with a <code class="language-plaintext highlighter-rouge">cover()</code> statement (or four), then add the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus properties</a>
to the core, some ad-hoc properties, and then finally the <em>contract</em> the
core is supposed to meet.  Actually, I normally place the contract earlier
in the process, before the ad-hoc properties, but we’ll put the contract at
the end today because that’s where the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
will be found and therefore that was the last part I verified.</p>

<h3 id="step-one-covering-the-results">Step one: Covering the results</h3>

<p>The first formal property I like to start with these days whenever I build
a new IP core is a <code class="language-plaintext highlighter-rouge">cover()</code> statement.  For bus
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slaves</a>, this
usually takes the form of,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">o_wb_ack</span><span class="p">);</span></code></pre></figure>

<p>For many peripherals, this will exercise all of the logic in the core and
then present create a <a href="/blog/2017/07/31/vcd.html">trace</a>
at the end of the logic flow.  This 
<a href="/blog/2017/07/31/vcd.html">trace</a>
will show you an example of how the internal logic functions (or doesn’t).</p>

<p>In this case, that simple <code class="language-plaintext highlighter-rouge">cover()</code> statement doesn’t work like I want.
Instead of giving me a <a href="/blog/2017/07/31/vcd.html">trace</a>
through all of the logic in the core, it just immediately returns one of the
empty acknowledgments.</p>

<p>That’s not very useful.</p>

<p>Hence, to get a <a href="/blog/2017/07/31/vcd.html">trace</a> covering
both a bus request and a configuration write command, I set two flags,
<code class="language-plaintext highlighter-rouge">pending_bus_request</code> and <code class="language-plaintext highlighter-rouge">pending_user_request</code>, to record when such a
request has been made.  In order to keep this logic from impacting any other
part of the proof, I place it in a generated section depending upon a formal
option cover parameter, <code class="language-plaintext highlighter-rouge">F_OPT_COVER</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_OPT_COVER</span><span class="p">)</span>
	<span class="k">begin</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">cover</span><span class="p">(</span><span class="n">o_wb_ack</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">bus_request</span><span class="p">))</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">user_request</span><span class="p">)));</span>

		<span class="kt">reg</span>	<span class="n">f_pending_user_request</span><span class="p">,</span> <span class="n">f_pending_bus_request</span><span class="p">;</span>

		<span class="c1">// Pending bus (read) request</span>
		<span class="c1">//</span>
		<span class="k">initial</span>	<span class="n">f_pending_bus_request</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
			<span class="n">f_pending_bus_request</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
			<span class="n">f_pending_bus_request</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span>
			<span class="n">f_pending_bus_request</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">cover</span><span class="p">((</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_pending_bus_request</span><span class="p">));</span></code></pre></figure>

<p>That captures a <a href="/blog/2017/07/31/vcd.html">trace</a> of <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a>
illustrating a read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.  You can see
this <a href="/blog/2017/07/31/vcd.html">trace</a> below in Fig 16.</p>

<table align="center" style="float: none"><caption>Fig 16. Cover trace of the basic read operation</caption><tr><td><img src="/img/spix/spix-trace-read.png" alt="Trace of a SPI read transaction" width="780" /></td></tr></table>

<p>Fig 16 should look very much like our design requirement trace from Fig 12
above.</p>

<p>Now for the configuration port.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">f_pending_user_request</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
			<span class="n">f_pending_user_request</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">user_request</span><span class="p">)</span>
			<span class="n">f_pending_user_request</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span>
			<span class="n">f_pending_user_request</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

		<span class="c1">// The actual cover statement for the user request</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">cover</span><span class="p">((</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_pending_user_request</span><span class="p">));</span></code></pre></figure>

<p>The configuration <a href="/blog/2017/07/31/vcd.html">trace</a>
this generates is shown below in Fig 17.</p>

<table align="center" style="float: none"><caption>Fig 17. Cover trace of a configuration port operation</caption><tr><td><img src="/img/spix/spix-trace-cfg.png" alt="Trace of a configuration port request" width="780" /></td></tr></table>

<p>Keep in mind, I’m able to acquire and examining these
<a href="/blog/2017/07/31/vcd.html">traces</a> <em>without writing any
simulation code</em>.  That comes later, in a discussion we’ll need to save for
another day.</p>

<p>Finally, to capture the pipelined read request, we’ll cover the entrance
into the pipeline read mode, just like we traced out in Fig. 13 above.
For this purpose, we can just <code class="language-plaintext highlighter-rouge">cover()</code> the lowered stall line when <code class="language-plaintext highlighter-rouge">ack_delay</code>
is one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_PIPE</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
				<span class="k">cover</span><span class="p">((</span><span class="n">f_pending_bus_request</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mh">7'h1</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">bus_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_sck</span><span class="p">));</span></code></pre></figure>

<p>The only problem is, the formal tools failed to find
<em>any</em> <a href="/blog/2017/07/31/vcd.html">trace</a> that would
make this <code class="language-plaintext highlighter-rouge">cover()</code> statement true.  To debug that failed <code class="language-plaintext highlighter-rouge">cover()</code> statement,
I backed up a step, and tried to <code class="language-plaintext highlighter-rouge">cover()</code> the prior clock cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
				<span class="k">cover</span><span class="p">((</span><span class="n">next_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_pending_bus_request</span><span class="p">)</span>
						<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mh">7'h2</span><span class="p">));</span>
		<span class="k">end</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Eventually I get the <a href="/blog/2017/07/31/vcd.html">trace</a> in
Fig 18 from the first of these two <code class="language-plaintext highlighter-rouge">cover()</code> statements.</p>

<table align="center" style="float: none"><caption>Fig 18. Cover trace showing the entrance of a pipelined read request</caption><tr><td><img src="/img/spix/spix-trace-pipe.png" alt="Trace showing the entrance to a pipelined read" width="780" /></td></tr></table>

<p>This is also my general approach for those times where I am struggling to
get a <code class="language-plaintext highlighter-rouge">cover()</code> statement to produce a
<a href="/blog/2017/07/31/vcd.html">trace</a>: I back up a
step, add an additional <code class="language-plaintext highlighter-rouge">cover()</code> statement, and then repeat the process
until I find the bug–just like I showed here.  <code class="language-plaintext highlighter-rouge">assert()</code> statements can help
this process as well.</p>

<p>Fig 18 also illustrates one of the problems with <code class="language-plaintext highlighter-rouge">cover()</code> statements: the tool
is free to cover your logic any way it pleases.  In this case, it covered the
entrance into the pipelined read, and then immediately issued a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus abort</a>
by dropping the <code class="language-plaintext highlighter-rouge">i_wb_cyc</code> line.  While legal, it’s hardly satisfying.</p>

<p>We could add some assumptions to keep this from taking place.  That’s part of
the purpose of the <code class="language-plaintext highlighter-rouge">F_OPT_COVER</code> generate block–to be able to add any
assumptions necessary for getting the
<a href="/blog/2017/07/31/vcd.html">traces</a> you want.  For example,
we could add an assumption that there would never be any
<a href="/zipcpu/2017/11/07/wb-formal.html">bus abort</a>s during
pipelined reads.  However, this <code class="language-plaintext highlighter-rouge">cover()</code> has accomplished my purpose as
it is: it has proven that a pipelined read request will bring the core
back into the regular read logic as desired.  Therefore, I’ll leave any
further work with assumptions as a exercise for the student.</p>

<p>This <a href="/formal/2018/07/14/dev-cycle.html">helps me create an initial
draft</a>
of this
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller
core</a>.
Well, not quite.  I’ll describe a missing piece in the next section.</p>

<h3 id="step-one-reset-and-bus-interaction">Step one: Reset and bus interaction</h3>

<p>One of the problems with the <code class="language-plaintext highlighter-rouge">cover()</code> statements in the last section is that,
when unconstrained, the incoming bus request doesn’t act like a bus request
should.  Bus requests may be made, stalled, and then new requests will be made
even though the prior request hasn’t gone been accepted into the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>.
Similarly, the strobe line might be high, even though the bus cycle line is low.
For these reasons, we need to bring in some <a href="/zipcpu/2017/11/07/wb-formal.html">properties describing our
bus</a>.  Let’s do that in
this section, starting with the <code class="language-plaintext highlighter-rouge">i_reset</code> signal the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus properties depend upon</a>.</p>

<p>Reset logic uses the <code class="language-plaintext highlighter-rouge">$past()</code> operator.  This operator will only work right
if the <code class="language-plaintext highlighter-rouge">$past()</code> time doesn’t occur before time began with the <code class="language-plaintext highlighter-rouge">initial</code>
statements.  Hence, we’ll create an <code class="language-plaintext highlighter-rouge">f_past_valid</code> register to tell us when
we can use the <code class="language-plaintext highlighter-rouge">$past()</code> operator successfully.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="n">f_past_valid</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">f_past_valid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">f_past_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>We want to <code class="language-plaintext highlighter-rouge">assume()</code> that our design starts with the <code class="language-plaintext highlighter-rouge">i_reset</code> line high.
This means we want to assume <code class="language-plaintext highlighter-rouge">i_reset</code> in both the initial state, and anytime
<code class="language-plaintext highlighter-rouge">f_past_valid</code> is false.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="k">assume</span><span class="p">(</span><span class="n">i_reset</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_reset</span><span class="p">);</span></code></pre></figure>

<p>Now for a fun trick: I’d like to insure that any register responsive to an
<code class="language-plaintext highlighter-rouge">i_reset</code> signal is also properly initialized to the same value.  Checking
for <code class="language-plaintext highlighter-rouge">!f_past_valid</code> tells us if we are in the initial state, whereas
<code class="language-plaintext highlighter-rouge">$past(i_reset)</code> checks whether or not our design just followed an
<code class="language-plaintext highlighter-rouge">i_reset</code> signal.  By placing the asserted values below, that guarantees them
to be the same under both circumstances.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">||</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_spi_cs_n</span> <span class="o">==</span> <span class="mb">1'b1</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_spi_sck</span>  <span class="o">==</span> <span class="mb">1'b0</span><span class="p">);</span>
		<span class="c1">//</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">ack_delay</span>    <span class="o">==</span>  <span class="mi">0</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">cfg_user_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_stall</span> <span class="o">==</span> <span class="mb">1'b0</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_ack</span>   <span class="o">==</span> <span class="mb">1'b0</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Now we can start to get the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a> to act like
a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a> should.</p>

<p>To do this, we’ll reference a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
bus</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_slave.v">property
file</a> from the
<a href="/about/zipcpu.html">ZipCPU</a>
repository.  This core needs a bit of configuration, so let’s configure its
parameters:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">AW</code>: Our address bus has 22 bits, sufficient to handle a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
of 16MB of memory.  (Remember the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
address</a> is a <em>word</em>
address, and not an 8-bit octet address.)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">F_MAX_STALL</code>: Our design may stall the bus no more than 66 clock cycles,
 one more than the length of one non-pipelined bus read.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">F_MAX_ACK_DELAY</code>: Similarly, it may take at most 66 cycles for an
acknowledgment to be returned upon any request.</p>

    <p>This is a bit of overkill for both <code class="language-plaintext highlighter-rouge">F_MAX_STALL</code> and <code class="language-plaintext highlighter-rouge">F_MAX_ACK_DELAY</code>
by one cycle, but it gives us a little wiggle room in case our design changes
in the future.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">F_LGDEPTH</code>: Since both counters require 7-bits, and since we’ll never have
 more than <code class="language-plaintext highlighter-rouge">2^7</code> or 128 requests outstanding, we’ll set the log (based two)
of the pipeline depth to 7.  This also determines the number of bits in our
counters: <code class="language-plaintext highlighter-rouge">f_nreqs</code>, the number of requests that have been made,
<code class="language-plaintext highlighter-rouge">f_nacks</code>, the number of acknowledgments that have been returned,
and <code class="language-plaintext highlighter-rouge">f_outstanding</code>, the number of currently outstanding transactions.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">F_MAX_REQUESTS</code> describes the maximum number of requests that can be made
in any transaction.  This creates an assertion that
<code class="language-plaintext highlighter-rouge">f_nreqs &lt; F_MAX_REQUESTS</code>.  While this is great for our non-pipelined mode,
in the pipelined mode it is possible to make request upon request.  Hence,
we’ll set this to one for the non-pipelined mode, and to zero if we are
running in a pipelined mode.</p>
  </li>
</ul>

<p>That’s enough configuration to include this property set in our design.  We’ll
make one other adjustment here: we’ll <code class="language-plaintext highlighter-rouge">OR</code> the <code class="language-plaintext highlighter-rouge">i_wb_stb</code> and <code class="language-plaintext highlighter-rouge">i_cfg_stb</code>
together to create one unified <a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a> port.  This saves us from including two
separate property files to describe each of the two
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slaves</a>, but it’ll give us a bit of hassle that we’ll have to clean up in a moment.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">F_LGDEPTH</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_nreqs</span><span class="p">,</span> <span class="n">f_nacks</span><span class="p">,</span> <span class="n">f_outstanding</span><span class="p">;</span>

	<span class="n">fwb_slave</span> <span class="p">#(</span> <span class="p">.</span><span class="n">AW</span><span class="p">(</span><span class="mi">22</span><span class="p">),</span> <span class="p">.</span><span class="n">F_MAX_STALL</span><span class="p">(</span><span class="mi">7'd66</span><span class="p">),</span> <span class="p">.</span><span class="n">F_MAX_ACK_DELAY</span><span class="p">(</span><span class="mi">7'd66</span><span class="p">),</span>
			<span class="p">.</span><span class="n">F_LGDEPTH</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="p">),</span>
			<span class="p">.</span><span class="n">F_MAX_REQUESTS</span><span class="p">((</span><span class="n">OPT_PIPE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mb">1'b1</span><span class="p">),</span>
			<span class="p">.</span><span class="n">F_OPT_MINCLOCK_DELAY</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">)</span>
		<span class="p">)</span> <span class="n">slavei</span><span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">),</span>
		<span class="n">i_wb_cyc</span><span class="p">,</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">),</span> <span class="n">i_wb_we</span><span class="p">,</span>
			<span class="n">i_wb_addr</span><span class="p">,</span> <span class="n">i_wb_data</span><span class="p">,</span> <span class="mh">4'hf</span><span class="p">,</span>
			<span class="n">o_wb_ack</span><span class="p">,</span> <span class="n">o_wb_stall</span><span class="p">,</span> <span class="n">o_wb_data</span><span class="p">,</span> <span class="mb">1'b0</span><span class="p">,</span>
			<span class="n">f_nreqs</span><span class="p">,</span> <span class="n">f_nacks</span><span class="p">,</span> <span class="n">f_outstanding</span><span class="p">);</span></code></pre></figure>

<p>Our first clean up assumption is to require that only one <code class="language-plaintext highlighter-rouge">i_*_stb</code> signal
will ever be active at any given time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">((</span><span class="o">!</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stb</span><span class="p">));</span></code></pre></figure>

<p>Second, we’ll require that any time either of <code class="language-plaintext highlighter-rouge">i_wb_stb</code> or <code class="language-plaintext highlighter-rouge">i_cfg_stb</code> is
active, <em>and</em> the bus is stalled, that the same strobe signal remains active
on the next clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span><span class="o">||</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)))</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">{</span><span class="n">i_wb_stb</span><span class="p">,</span><span class="n">i_cfg_stb</span><span class="o">}==</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="o">{</span><span class="n">i_wb_stb</span><span class="p">,</span><span class="n">i_cfg_stb</span><span class="o">}</span><span class="p">));</span></code></pre></figure>

<p>In hindsight, this just makes sense.  In reality, I didn’t put this assumption
into place until I saw this rule violated in one of my early <code class="language-plaintext highlighter-rouge">cover()</code>
<a href="/blog/2017/07/31/vcd.html">traces</a>.</p>

<p>Now that we’ve added our
<a href="/zipcpu/2017/11/07/wb-formal.html">bus properties</a>,
the bus starts to act right in the
<a href="/blog/2017/07/31/vcd.html">traces</a>
generated by our <code class="language-plaintext highlighter-rouge">cover()</code> statements.  The design just doesn’t pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
yet.  For that, we’ll need to add some ad-hoc assertions in the next section.</p>

<h3 id="step-two-ad-hoc-immediate-assertions">Step two: Ad-hoc Immediate assertions</h3>

<p>Often I separate formal properties into two types: there’s the primary
type based upon the outputs of the core that’s designed to determine whether
the core functions as intended.  We’ll call this the <em>contract</em> that the
core needs to fulfill.  Other properties are more ad-hoc.  They
wouldn’t be needed, save for the reality that
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
starts with unconstrained values within the core.  We’ll express how
this core needs to operate, it’s <em>contract</em> if you will, using <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog
sequences</a>
in the next section.  For the purpose of this section, let’s just constrain
the design to make certain it doesn’t enter into any illegal states during
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<p>We’ll start out with some assertions regarding our
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone properties</a>.
Specifically, we need to ensure that the counters within the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone property
module</a>
match our current understanding of our state.  Further, since a pipelined
operation can go on forever, we’ll only examine the number of outstanding
transactions kept in the <code class="language-plaintext highlighter-rouge">f_outstanding</code> value returned from the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone property</a> set.</p>

<p>For our first test, we’ll insist that we never have more than one outstanding
request.  That is unless we are in a pipelined read operation, where there
would be one cycle where the number of outstanding transactions would be two
instead of one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_PIPE</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>In a similar fashion, any time <code class="language-plaintext highlighter-rouge">ack_delay</code> is zero then we aren’t in an
extended transaction.  Such a time step must either include the <code class="language-plaintext highlighter-rouge">o_wb_ack</code>
from a just-ended transaction or the number of outstanding transactions
must be zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">((</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span></code></pre></figure>

<p>Unfortunately, without anything more, we may get a
<a href="/blog/2017/07/31/vcd.html">trace</a> from the tools
that has <code class="language-plaintext highlighter-rouge">o_wb_ack</code> on for a very long time, yet <code class="language-plaintext highlighter-rouge">f_outstanding</code> is some value
inconsistent with our design.  For example, the core could be responding to one
empty acknowledgment request after another while <code class="language-plaintext highlighter-rouge">f_outstanding ==2</code>.<br />
Of course the core would never get into this situation, but we need to
communicate that to the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
engine.</p>

<p>In the first case, following any non-pipelined <code class="language-plaintext highlighter-rouge">i_wb_stb</code> request, there should
then be only one request outstanding.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(((</span><span class="o">!</span><span class="n">OPT_PIPE</span><span class="p">)</span><span class="o">||</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">o_spi_cs_n</span><span class="p">)))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">))</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>Likewise in the middle of any request, there should only be one bus request
outstanding.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">((</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">==</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>If there are ever two acknowledgments back to back, they can only be the
empty acknowledgments we discussed earlier.  Hence, we should only have the
last request outstanding or no requests outstanding.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>There is only one time we should ever have two requests outstanding: that is
when we just accepted a request for a pipelined interaction and <code class="language-plaintext highlighter-rouge">OPT_PIPE</code> is
true.  On that same clock, the acknowledgment line should be high, <code class="language-plaintext highlighter-rouge">o_spi_cs_n</code>
should be active (low), and <code class="language-plaintext highlighter-rouge">ack_delay</code> should be 32.  Under no other
circumstances should there ever be two requests outstanding.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_outstanding</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">((</span><span class="n">OPT_PIPE</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_sck</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd32</span><span class="p">));</span></code></pre></figure>

<p>Following any bus strobe that is neither a <code class="language-plaintext highlighter-rouge">bus_request</code> nor a <code class="language-plaintext highlighter-rouge">user_request</code>
of the configuration port, there should immediately be an acknowledgment
on the next clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">user_request</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">bus_request</span><span class="p">)))</span>
			<span class="k">assert</span><span class="p">((</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">==</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>That’s the last of the assertions necessary to make certain the formal
properties for <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a>
properly integrate with the properties from our
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone property set</a>.</p>

<p>Now let’s make some assertions of the 
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol next.</p>

<p>If you’ve taken my course in formal verification, you may remember that I
usually spend some time discussing how to properly describe a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
protocol interaction in the multi-clock section.  This is not necessary
here.  Not only is everything synchronous, but the 
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> interaction
of interest isn’t slow enough to make any of those multiclock property
descriptions, <code class="language-plaintext highlighter-rouge">$rose()</code>, <code class="language-plaintext highlighter-rouge">$fell()</code>, or <code class="language-plaintext highlighter-rouge">$stable()</code>, all that useful here.</p>

<p>Still, we can describe some useful parts of the interaction here.</p>

<p>For example, we’ve chosen to leave the clock idle unless <code class="language-plaintext highlighter-rouge">o_spi_cs_n</code> is low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_spi_cs_n</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_sck</span><span class="p">);</span></code></pre></figure>

<p>While I suppose we could just leave the clock running, that would break some
other things–notably the configuration port.</p>

<p>Similarly, any time <code class="language-plaintext highlighter-rouge">ack_delay</code> is other than zero, the <code class="language-plaintext highlighter-rouge">SCK</code> line should be
high.  This would reference either <code class="language-plaintext highlighter-rouge">o_spi_sck</code> going to the <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/oclkddr.v">output DDR
module</a>,
or our local version of whether or <code class="language-plaintext highlighter-rouge">SCK</code> is really ticking in <code class="language-plaintext highlighter-rouge">actual_sck</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">((</span><span class="n">o_spi_sck</span><span class="o">||</span><span class="n">actual_sck</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">));</span></code></pre></figure>

<p>Anytime <code class="language-plaintext highlighter-rouge">ack_delay</code> is zero, we are not in the middle of any transactions.
Hence, <code class="language-plaintext highlighter-rouge">o_wb_stall</code> should also be zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">);</span></code></pre></figure>

<p>Likewise, if the <code class="language-plaintext highlighter-rouge">ack_delay</code> is ever greater than one, then the bus should
be stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">);</span></code></pre></figure>

<p>Indeed, with one exception any time <code class="language-plaintext highlighter-rouge">ack_delay</code> is greater than zero the bus
should be stalled.  The one exception is just before a pipelined transaction.
Hence, if <code class="language-plaintext highlighter-rouge">ack_delay</code> is one and pipelined reads are disabled, or equivalently
if we are in the <code class="language-plaintext highlighter-rouge">cfg_user_mode</code>, then the interface should be stalled
when <code class="language-plaintext highlighter-rouge">ack_delay</code> is one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">OPT_PIPE</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">);</span></code></pre></figure>

<p>Just to constrain the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
engine further, the <code class="language-plaintext highlighter-rouge">ack_delay</code> should always be less than or equal to <code class="language-plaintext highlighter-rouge">65</code>.
Although we know this to be true already, the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
engine can do some weird things if you don’t limit values like this properly.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="mi">7'd65</span><span class="p">);</span></code></pre></figure>

<p>In a similar fashion, if <code class="language-plaintext highlighter-rouge">cfg_user_mode</code> is ever true, then the
<code class="language-plaintext highlighter-rouge">ack_delay</code> must be less than or equal to <code class="language-plaintext highlighter-rouge">9</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfg_user_mode</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="mi">7'd9</span><span class="p">);</span></code></pre></figure>

<p>Our final ad-hoc assertion will be that <code class="language-plaintext highlighter-rouge">o_spi_cs_n</code> is only ever active
(low) if either we are in the <code class="language-plaintext highlighter-rouge">cfg_user_mode</code> or if <code class="language-plaintext highlighter-rouge">ack_delay &gt; 0</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_spi_cs_n</span> <span class="o">!=</span> <span class="p">((</span><span class="n">cfg_user_mode</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)));</span></code></pre></figure>

<p>These simple assertions above will keep us in the valid operating range of <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a>.
Now we just need to convince ourselves that this core actually works and does
what it is supposed to do.  To do that, we’ll try out some of the <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System
Verilog
sequences</a>
available to the <a href="http://www.verific.com">Verific-enabled</a> version of
<a href="http://www.clifford.at/yosys">yosys</a>.</p>

<h3 id="step-three-sequence-assertions">Step three: Sequence Assertions</h3>

<p>If you recall from the beginning of this article, one of the reasons for
this project was to see if a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
would be a good test of <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog
sequences</a>.
In particular, I’ve been looking for some of the use cases that highlight
the utility of <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System
Verilog’s
sequences</a>.</p>

<p>Prior to this project, I had only tested
<a href="http://www.clifford.at/yosys">yosys</a>’s ability to handle
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog
sequences</a>
with FIFOs and a <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">UART
transmitter</a>.
Since starting this project, I have now tested and tried
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">them</a>
out with a <a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smpladc.v">SPI-based ADC</a>,
and the <a href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/sramdev.v">controller</a>
for this same <a href="https://github.com/ZipCPU/icozip">ICOZip Project</a>.
While I like the expressiveness of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">System Verilog
sequence</a>
language, I’m also glad I learned how to do
<a href="/blog/2017/10/19/formal-intro.html">formal verification with immediate assertions only</a> first.  <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">Sequence</a>
are not nearly as simple or as easy to work with as the immediate assertions
we’ve been working with, and the background I gained in immediate assertions
helped me a lot while learning
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>.</p>

<p>We’ll split the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
discussion here into two parts.  The first part, contained in this section,
will be about guaranteeing that our <code class="language-plaintext highlighter-rouge">ack_delay</code> based state machine works as
desired.  In the next section, will dig in a bit further and verify that what
gets returned to the bus is actually what we read from the device.  Once we’re
done, we’ll move on to how I tested <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a>
on the actual hardware of the <a href="http://www.icoboard.org">ICO board</a>.</p>

<p>In many ways, it might make the most sense to read this section from the
bottom up, rather than the top down, because in order to finally express
what we want to at the end, we have to build a lot of infrastructure to get
there.  Hence, if you want to see where we are going, skip to the end of
this section and look over the assertions found there.</p>

<p>That said, let’s start with two variables these
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
will use.  In particular, we want some values that are guaranteed to stay
constant throughout the duration of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>–values
the <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
can reference, and that won’t change.  We’ll create two here, one to capture
the last address requested of the bus, and a second to capture what would be
the next address after that.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">VERIFIC</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">21</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_last_addr</span><span class="p">,</span> <span class="n">f_next_addr</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">f_last_addr</span> <span class="o">&lt;=</span> <span class="n">i_wb_addr</span><span class="p">[</span><span class="mi">21</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_next_addr</span> <span class="o">&lt;=</span> <span class="n">f_last_addr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Our first assertion is something simple: Any request, other than a
<code class="language-plaintext highlighter-rouge">user_request</code> (i.e. a write) of the configuration port or a normal
<code class="language-plaintext highlighter-rouge">bus_request</code> (i.e. a read) should be acknowledged on the next clock, without
stalling the bus.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="kt">disable</span> <span class="k">iff</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
		<span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">user_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="o">|=&gt;</span> <span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">));</span></code></pre></figure>

<p>If this form of an assertion is new to you, then don’t let it be.  We’ve been
discussing this basic assertion for some time, only we’ve described it in
a different fashion.  Instead of,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">A</span> <span class="o">|=&gt;</span> <span class="n">B</span><span class="p">);</span></code></pre></figure>

<p>we’ve been writing</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">B</span><span class="p">);</span></code></pre></figure>

<p>The two are really just two forms of the same thing.  Personally, I like the
new form.  It seems simpler and cleaner.</p>

<p>What about the <code class="language-plaintext highlighter-rouge">disable iff</code> statement?  That just disables the assertion
on any of the clocks that it would be applied to.  Hence,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="kt">disable</span> <span class="k">iff</span> <span class="p">(</span><span class="n">C</span><span class="p">)</span>
		<span class="n">A</span> <span class="o">|=&gt;</span> <span class="n">B</span><span class="p">);</span></code></pre></figure>

<p>is the same as</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">A</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">C</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">C</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">B</span><span class="p">);</span></code></pre></figure>

<p>There’s another new form as well.  Instead of writing,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">B</span><span class="p">);</span></code></pre></figure>

<p>we could equivalently write</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">A</span> <span class="o">|-&gt;</span> <span class="n">B</span><span class="p">);</span></code></pre></figure>

<p>Both of these newer forms, however, currently require the
<a href="http://www.verific.com">Verific enabled</a>
version of <a href="http://www.clifford.at/yosys">yosys</a>.</p>

<p>Using this newer form, I can express</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">cfg_user_mode</span><span class="p">)</span>
		<span class="o">|-&gt;</span> <span class="p">(</span><span class="n">OPT_PIPE</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_addr</span> <span class="o">==</span> <span class="n">f_next_addr</span><span class="p">)</span>
		<span class="p">);</span></code></pre></figure>

<p>That is to say, if we ever accept a new <code class="language-plaintext highlighter-rouge">bus_request</code> while <code class="language-plaintext highlighter-rouge">o_spi_cs_n</code>
is active (low), then <code class="language-plaintext highlighter-rouge">OPT_PIPE</code> must be valid and this new request
address <em>must</em> be for the next address in the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>Those two assertions should get your feet wet.  Now let’s try our first
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.
If you’ve never used them,
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
are neither assertions nor assumptions.  Instead, they can be used to describe
a <em><a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a></em>
of states that can then be used within an assertion, assumption, or even
a cover property.</p>

<p>For this first sequence, let’s describe the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
read command where we send a <code class="language-plaintext highlighter-rouge">8'h03</code> to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
device.  This sequence starts with an idle cycle with <code class="language-plaintext highlighter-rouge">o_spi_cs_n</code> active
and <code class="language-plaintext highlighter-rouge">o_spi_sck</code> true, but <code class="language-plaintext highlighter-rouge">actual_sck</code> hasn’t been set yet.</p>

<p>We’ll start this description by naming our
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>,
<code class="language-plaintext highlighter-rouge">READ_COMMAND</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">sequence</span> <span class="n">READ_COMMAND</span><span class="p">;</span>
		<span class="c1">// Send command 8'h03</span></code></pre></figure>

<p>Then we’ll describe that first state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="p">(</span><span class="n">f_last_addr</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_addr</span><span class="p">))</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_mosi</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">actual_sck</span><span class="p">)</span></code></pre></figure>

<p>On the next clock, we get into sending the actual command contained in the
<code class="language-plaintext highlighter-rouge">o_spi_mosi</code> output values.  To express that this will start on the next
clock, we’ll use the <code class="language-plaintext highlighter-rouge">##1</code> expression.  This portion of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>,
however, will take us a whole 8 clocks.  During all of those 8 clocks,
we’ll want to assert that the <code class="language-plaintext highlighter-rouge">f_last_addr</code> value stays constant, that
<code class="language-plaintext highlighter-rouge">o_spi_cs_n</code> stays active, and that <code class="language-plaintext highlighter-rouge">o_spi_sck</code> remains true.  Hence,
<em>throughout</em> these next 8-clocks, these must hold.  That’s the purpose of
the <em>throughout</em> statement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span> <span class="p">((</span><span class="n">f_last_addr</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">f_last_addr</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">actual_sck</span><span class="p">))</span> <span class="k">throughout</span></code></pre></figure>

<p>Now we can work our way through each of those individual 8 clocks.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">				<span class="p">(</span><span class="o">!</span><span class="n">o_spi_mosi</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd64</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">actual_sck</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="o">!</span><span class="n">o_spi_mosi</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd63</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="o">!</span><span class="n">o_spi_mosi</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd62</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="o">!</span><span class="n">o_spi_mosi</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd61</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="o">!</span><span class="n">o_spi_mosi</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd60</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="o">!</span><span class="n">o_spi_mosi</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd59</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span> <span class="n">o_spi_mosi</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd58</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span> <span class="n">o_spi_mosi</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd57</span><span class="p">));</span>
	<span class="k">endsequence</span></code></pre></figure>

<p>In this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
description, I’ve tried to constrain and describe every register that’s a part
of state associated with sending this command.  Further, since the <code class="language-plaintext highlighter-rouge">o_spi_mosi</code>
and <code class="language-plaintext highlighter-rouge">ack_delay</code> values changed during these 8-clocks, I didn’t lump them
together with the other predicates that needed to be true <code class="language-plaintext highlighter-rouge">throughout</code>
all eight of these cycles.</p>

<p>The next
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
is the one where we send the address we want to read from to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  Since the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>
is word based, and the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is byte based, we’ll add
two zero’s at the end of this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.
The format itself should look very similar to the
format of the last one: we’ll start by naming the 
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">sequence</span>	<span class="n">SEND_ADDRESS</span><span class="p">;</span></code></pre></figure>

<p>then we’ll define those properties that must hold throughout the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="p">(((</span><span class="n">f_last_addr</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">f_last_addr</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_sck</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">actual_sck</span><span class="p">))</span>
		<span class="k">throughout</span></code></pre></figure>

<p>finally, we’ll step through each of the clock cycles within the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">21</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd56</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">20</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd55</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">19</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd54</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">18</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd53</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">17</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd52</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd51</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">15</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd50</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">14</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd49</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">13</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd48</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd47</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd46</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd45</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">9</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd44</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">8</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd43</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">7</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd42</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">6</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd41</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">5</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd40</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">4</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd39</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">3</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd38</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">2</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd37</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">1</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd36</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_last_addr</span><span class="p">[</span> <span class="mi">0</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd35</span><span class="p">)</span></code></pre></figure>

<p>Don’t forget the two zero bits at the end of the address!</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="mb">1'b0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd34</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="mb">1'b0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd33</span><span class="p">));</span>
	<span class="k">endsequence</span></code></pre></figure>

<p>We can now define a third
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>:
the one where we actually read the data from the device.  This has the exact
same form as before, only we’re going to introduce  new expression, the <code class="language-plaintext highlighter-rouge">[*8]</code>
or <code class="language-plaintext highlighter-rouge">[*7]</code>.  This means that we want to repeat the given state by that many
clocks.  I’m going to use this to help keep <code class="language-plaintext highlighter-rouge">ack_delay</code> bounded–at least
bounded enough that the formal tools properly recognize after more than eight
clocks which state of this sequence is taking place, should they decide
to try to start in the middle of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.</p>

<p>As before, we start with the name of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
followed by the properties that will hold <code class="language-plaintext highlighter-rouge">throughout</code> the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">sequence</span>	<span class="n">READ_DATA</span><span class="p">;</span>
		<span class="p">(((</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_sck</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_data</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="o">{</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">30</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">i_spi_miso</span><span class="o">}</span><span class="p">)))</span>
		<span class="k">throughout</span></code></pre></figure>

<p>The first clock period, however, will be replicated 8 times.  It will primarily
just constrain <code class="language-plaintext highlighter-rouge">ack_delay</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="p">(</span><span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="mi">7'd32</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;=</span> <span class="mi">7'd25</span><span class="p">)</span> <span class="p">[</span><span class="o">*</span><span class="mi">8</span><span class="p">]</span></code></pre></figure>

<p>And so on, repeating each clock period 8 times until the last.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="mi">7'd24</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;=</span> <span class="mi">7'd17</span><span class="p">)</span> <span class="p">[</span><span class="o">*</span><span class="mi">8</span><span class="p">]</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&lt;=</span> <span class="mi">7'd16</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;=</span>  <span class="mi">7'd9</span><span class="p">)</span> <span class="p">[</span><span class="o">*</span><span class="mi">8</span><span class="p">]</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">&lt;=</span>  <span class="mi">7'd8</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">&gt;=</span>  <span class="mi">7'd2</span><span class="p">)</span> <span class="p">[</span><span class="o">*</span><span class="mi">7</span><span class="p">])</span></code></pre></figure>

<p>Watch the parentheses, because that last line also ends the <code class="language-plaintext highlighter-rouge">throughout</code>
statement that we started with, even though the we’re not done defining
this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
yet.</p>

<p>We’ve broken the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
at this point because the next period is special.
That’s the only period where the our signals might change in order to support
a pipelined interaction.  In this case, the stall line might be low if
<code class="language-plaintext highlighter-rouge">OPT_PIPE</code> is also true, otherwise we remain stalled like we were in the
last clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="p">##</span><span class="mi">1</span> <span class="p">((</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">actual_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">7'd1</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(((</span><span class="n">OPT_PIPE</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_sck</span><span class="p">))</span>
				<span class="o">||</span><span class="p">((</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_sck</span><span class="p">)))</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_data</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="o">{</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">30</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">i_spi_miso</span><span class="o">}</span><span class="p">)))</span></code></pre></figure>

<p>Finally, we’ll end this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
describing a read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
with a bus acknowledgment, and a guarantee if <code class="language-plaintext highlighter-rouge">OPT_PIPE</code> isn’t true
that the bus has returned to idle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_data</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="o">{</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">30</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">i_spi_miso</span><span class="o">}</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">((</span><span class="n">OPT_PIPE</span><span class="p">)</span><span class="o">||</span><span class="p">((</span><span class="n">o_spi_cs_n</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">actual_sck</span><span class="p">)));</span>
	<span class="k">endsequence</span></code></pre></figure>

<p>What can you do with all these
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
we’ve just defined?  You can string them together within an assertion!</p>

<p>The following assertion asserts that, following any read request from the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>,
the device will send the <code class="language-plaintext highlighter-rouge">READ_COMMAND</code>, the address (<code class="language-plaintext highlighter-rouge">SEND_ADDRESS</code>), and
then read the data (<code class="language-plaintext highlighter-rouge">READ_DATA</code>) from the device.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="kt">disable</span> <span class="k">iff</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
		<span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_cs_n</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">cfg_user_mode</span><span class="p">)</span>
		<span class="c1">// Send command 8'h03</span>
		<span class="o">|=&gt;</span> <span class="n">READ_COMMAND</span>
		<span class="c1">// Send the requested address</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">((</span><span class="n">f_last_addr</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">f_last_addr</span><span class="p">))</span> <span class="k">throughout</span>
				<span class="n">SEND_ADDRESS</span><span class="p">)</span>
		<span class="c1">// Clock in 32-bits of data</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">READ_DATA</span><span class="p">);</span></code></pre></figure>

<p>Not bad, huh?</p>

<p>This gets us most of the way there.  However, a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
is a type of memory, and there are
<a href="/zipcpu/2018/07/13/memories.html">particular properties</a>
you want to formally verify with respect to any
<a href="/zipcpu/2018/07/13/memories.html">memory</a>
interaction.  That will be our next section.</p>

<h3 id="step-four-known-addressdata-assertions">Step four: Known Address/Data Assertions</h3>

<p>The rule for formally verifying
<a href="/zipcpu/2018/07/13/memories.html">memories</a> is that
you want to <em>assume</em> any time you read from an arbitrary address, that
you get a known arbitrary value in response.  The second part is to <em>assert</em>
that whenever you return the result of the read to the bus, you also return the
arbitrarily chosen value.</p>

<p>I initially created those rules here in
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
logic.  One property assumed known data would be read from <code class="language-plaintext highlighter-rouge">i_spi_miso</code>
following a request from that known address, and the second property asserted
that the same known data would be returned in <code class="language-plaintext highlighter-rouge">o_wb_data</code> once <code class="language-plaintext highlighter-rouge">o_wb_ack</code> was
set.</p>

<p>I’ve since torn that work up.  It turns out that there’s an easier way
to do the same thing when you are using
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>.
We’ll still allow the formal tool to pick an arbitrary data value, but we can
do this without the heavy weight of the formal
<a href="/zipcpu/2018/07/13/memories.html">memories</a> rule.
In particular, we don’t need the arbitrary address, just the data.</p>

<p>Here’s how we’ll do it: we’ll create a rule that whenever the arbitrary data is
read, regardless of what address it is read from, that value read from the
device is returned to the bus.</p>

<p>We’ll start at the top by assuming a constant 32-bit value.  The formal solver
will get to pick any value it wants for these 32-bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="p">(</span><span class="o">*</span> <span class="n">anyconst</span> <span class="o">*</span><span class="p">)</span> <span class="kt">wire</span>	<span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_data</span><span class="p">;</span></code></pre></figure>

<p>Next, we’ll define a
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
where an arbitrary octet, <code class="language-plaintext highlighter-rouge">B</code>, is received from the interface.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">sequence</span>	<span class="n">DATA_BYTE</span><span class="p">(</span><span class="k">local</span> <span class="kt">input</span> <span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">B</span><span class="p">);</span>
		<span class="p">(</span><span class="n">i_spi_miso</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">i_spi_miso</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">i_spi_miso</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">i_spi_miso</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">i_spi_miso</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">i_spi_miso</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">i_spi_miso</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">i_spi_miso</span> <span class="o">==</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">endsequence</span></code></pre></figure>

<p>Did you notice that this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
accepted an 8-bit parameter?  Neat!</p>

<p>Now, if we string four of these 
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
together, then we can describe receiving an arbitrary value on the <code class="language-plaintext highlighter-rouge">i_spi_miso</code>
wire.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">sequence</span>	<span class="n">THIS_DATA</span><span class="p">;</span>
			<span class="n">DATA_BYTE</span><span class="p">(</span><span class="n">f_data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">])</span>
			<span class="p">##</span><span class="mi">1</span> <span class="n">DATA_BYTE</span><span class="p">(</span><span class="n">f_data</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">])</span>
			<span class="p">##</span><span class="mi">1</span> <span class="n">DATA_BYTE</span><span class="p">(</span><span class="n">f_data</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">])</span>
			<span class="p">##</span><span class="mi">1</span> <span class="n">DATA_BYTE</span><span class="p">(</span><span class="n">f_data</span><span class="p">[</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">]);</span>
	<span class="k">endsequence</span></code></pre></figure>

<p>Note that this only works because <code class="language-plaintext highlighter-rouge">f_data</code> is constant, since the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
will reference the current value of <code class="language-plaintext highlighter-rouge">f_data</code>, rather than the value
when the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
is activated.</p>

<p>Now, here’s the trick: <code class="language-plaintext highlighter-rouge">THIS_DATA</code> is a
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
containing a description of our known data being received.  While this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
is being received, <code class="language-plaintext highlighter-rouge">ack_delay</code> will go from <code class="language-plaintext highlighter-rouge">7'd32</code> down to <code class="language-plaintext highlighter-rouge">7'd1</code>.  Once
<code class="language-plaintext highlighter-rouge">ack_delay</code> hits zero, or goes around again, there should also be an
acknowledgment.  So, let’s add to that assertion that the outgoing data also
matches the received data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="p">(</span><span class="n">THIS_DATA</span> <span class="kt">and</span> <span class="p">((</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">)</span>
			<span class="k">throughout</span>
		<span class="p">((</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="mi">7'd32</span><span class="p">)</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">ack_delay</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">ack_delay</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="o">*</span><span class="mi">31</span><span class="p">])))</span>
		<span class="o">|=&gt;</span> <span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_data</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">));</span></code></pre></figure>

<p>Did you see how this accomplishes both sides of the
<a href="/zipcpu/2018/07/13/memories.html">memory proof</a>
requirement?  Because we placed the
<a href="/zipcpu/2018/07/13/memories.html">known data</a>
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
before the non-overlapping implication operator, <code class="language-plaintext highlighter-rouge">|=&gt;</code>, the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
acted as an assumption.  As a result, we now know that no matter what
value is received, the proper value will be returned.</p>

<p>I then applied the same basic approach to the configuration port.  However,
in the interests of space in an already long article, I’ll let you peruse it
if you are interested.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_CFG</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Configuration writes</span>
		<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="kt">disable</span> <span class="k">iff</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
			<span class="p">((</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span>
			<span class="o">|=&gt;</span> <span class="p">((</span><span class="o">!</span><span class="n">cfg_user_mode</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_sck</span><span class="p">))</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">));</span>

		<span class="kt">reg</span>	<span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_wr_data</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">user_request</span><span class="p">)</span>
			<span class="n">f_wr_data</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>

		<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="kt">disable</span> <span class="k">iff</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
			<span class="p">((</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span>
			<span class="o">|=&gt;</span> <span class="p">(((</span><span class="n">cfg_user_mode</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_sck</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">))</span> <span class="k">throughout</span>
				<span class="p">(</span><span class="o">!</span><span class="n">o_spi_mosi</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd9</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_wr_data</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
							<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd8</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_wr_data</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
							<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd7</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_wr_data</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
							<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd6</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_wr_data</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
							<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd5</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_wr_data</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
							<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd4</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_wr_data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
							<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd3</span><span class="p">)</span>
				<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_wr_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
							<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd2</span><span class="p">))</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">((</span><span class="n">cfg_user_mode</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_sck</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">actual_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_spi_mosi</span> <span class="o">==</span> <span class="n">f_wr_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
							<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ack_delay</span><span class="o">==</span><span class="mi">7'd1</span><span class="p">))</span>
			<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">cfg_user_mode</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">actual_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">));</span>

		<span class="c1">// And then configuration reads.  First the write needs to</span>
		<span class="c1">// charge the o_wb_data buffer</span>
		<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="kt">disable</span> <span class="k">iff</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
			<span class="p">((</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span>
			<span class="p">##</span><span class="mi">2</span> <span class="n">DATA_BYTE</span><span class="p">(</span><span class="n">f_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
			<span class="o">|=&gt;</span> <span class="p">(</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_data</span> <span class="o">==</span> <span class="o">{</span> <span class="mh">24'h0</span><span class="p">,</span> <span class="n">f_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">cfg_user_mode</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">));</span>

		<span class="c1">// Then it needs to stay constant until another SPI</span>
		<span class="c1">// command</span>
		<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="kt">disable</span> <span class="k">iff</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_sck</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_spi_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">cfg_user_mode</span><span class="p">)</span>
			<span class="o">|=&gt;</span> <span class="p">$</span><span class="nb">stable</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">8</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">));</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<h2 id="how-to-test-it">How to test it?</h2>

<p>Now that we’ve built <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">our
controller</a>,
how shall we test it to know that it works?</p>

<p>Hopefully you’ve been around long enough to remember all of our work building
a <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">basic debugging bus</a>,
following the <a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">initial vision I presented for controlling FPGA
logic</a>.
With just a little effort, we can connect a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
and our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to this <a href="/blog/2017/06/28/dbgbus-goal.html">debugging bus</a>,
and then see how our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> interacts
with the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<table align="center" style="float: right"><caption>Fig 19. Digilent's Digital Discovery 2</caption><tr><td><img src="/img/digital-discovery-top-130.png" alt="A Picture of Digilent's Digital Discovery 2 logic analyzer" width="280" /></td></tr></table>

<p>For <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this particular core</a>,
I didn’t start my debugging with the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>.
I started instead with a <a href="https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator">Digilent Digital
Discovery 2</a>.
Why?  Two reasons: 1. I had it <a href="/blog/2017/09/14/even-i-get-stuck.html">available to
me</a>
and on my desk, and 2. I was concerned about the timing of the clock pulses.
Sure enough, the 
<a href="https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator">DD</a>
revealed that the
<a href="http://www.latticesemi.com/Products/FPGAandCPLD/iCE40">iCE40</a>
<code class="language-plaintext highlighter-rouge">SB_IO</code> primitive in DDR mode delayed the <code class="language-plaintext highlighter-rouge">SCK</code> by one clock more than I was
expecting.  (The code above has been fixed to accommodate this.)  This sent
me back through the entire design to do some massive updates:
all other signals needed to be delayed by one and the <code class="language-plaintext highlighter-rouge">o_spi_sck</code> signal
needed to return to zero one cycle earlier.  Indeed, there were several head
scratching moments at this point in order to get the timing right.</p>

<p>We’ve <a href="/blog/2017/07/08/getting-started-with-wbscope.html">discussed hooking
up</a> the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
to a design before.  I’ll just touch on a couple of pieces briefly here.
First, you need to decide which 32-bits you want to capture and select a
relevant trigger.  I personally like to place the trigger in the MSB of this
word–it makes it easier to switch to a <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v">compressed wishbone
scope</a> later if I
need to.   In my case, I ultimately chose the following wires to capture:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">spixpress_debug</span> <span class="o">=</span> <span class="o">{</span> <span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">),</span> <span class="n">wb_cyc</span><span class="p">,</span>
				<span class="p">(</span><span class="n">wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">flash_sel</span><span class="p">),</span>
				<span class="p">(</span><span class="n">wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">flash_cfg_sel</span><span class="p">),</span> <span class="n">wb_we</span><span class="p">,</span>
				<span class="n">flash_stall</span><span class="p">,</span><span class="n">flash_ack</span><span class="p">,</span> <span class="n">wb_data</span><span class="p">[</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">flash_data</span><span class="p">[</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span>
				<span class="mh">3'h0</span><span class="p">,</span>
				<span class="n">o_spi_cs_n</span><span class="p">,</span> <span class="n">o_spi_sck</span><span class="p">,</span> <span class="n">o_spi_mosi</span><span class="p">,</span> <span class="n">i_spi_miso</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>That gives me access to all of the critical
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
wires, as well as the entire
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
interface.</p>

<p>The majority of the connections required to connect this to the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
bus were made by <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>–allowing
me to remove the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
later if I so wish by just removing the <a href="https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt">scope’s AutoFPGA configuration file’s
name</a>
from the <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> command line.
Among other changes, this places the following additional code into the <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/main.v">main
design file</a> of
<a href="https://github.com/ZipCPU/icozip">this design</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">wbscope</span> <span class="p">#(.</span><span class="n">LGMEM</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="p">.</span><span class="n">SYNCHRONOUS</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">.</span><span class="n">HOLDOFFBITS</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
		<span class="n">spixscopei</span><span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="mb">1'b1</span><span class="p">,</span> <span class="p">(</span><span class="o">!</span><span class="n">o_spi_cs_n</span><span class="p">),</span> <span class="n">spixpress_debug</span><span class="p">,</span>
			<span class="n">i_clk</span><span class="p">,</span> <span class="n">wb_cyc</span><span class="p">,</span> <span class="p">(</span><span class="n">wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">spixscope_sel</span><span class="p">),</span>
			<span class="n">wb_we</span><span class="p">,</span> <span class="n">wb_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wb_data</span><span class="p">,</span>
			<span class="n">spixscope_ack</span><span class="p">,</span> <span class="n">spixscope_stall</span><span class="p">,</span> <span class="n">spixscope_data</span><span class="p">,</span>
			<span class="n">spixscope_int</span><span class="p">);</span></code></pre></figure>

<p>The <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> <a href="https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt">configuration
file</a>
also places a <code class="language-plaintext highlighter-rouge">#define</code> into the
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/regdefs.h"><code class="language-plaintext highlighter-rouge">regdefs.h</code></a>
file, defining <code class="language-plaintext highlighter-rouge">R_SPIXSCOPE</code> to have the address of the control
register for the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>.</p>

<p>You can see the entire <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt">configuration file</a>
for this debugging scope
<a href="https://github.com/ZipCPU/icozip/blob/master/auto-data/spixscope.txt">here</a>.
Adding this to the <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> command line
in the <a href="https://github.com/ZipCPU/icozip/tree/master/rtl/auto-data">auto-data</a>/<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/auto-data/Makefile">Makefile</a>
will add this to the design, and removing it from the command line will remove
this component and <a href="/zipcpu/2017/10/05/autofpga-intro.html">all of its
dependencies</a>
from the design as well.  There’s also a <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/spixscope.cpp">software
component</a>
to this
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>’s
setup as well, found in the <a href="https://github.com/ZipCPU/icozip/tree/master/sw/host">sw/host
directory</a>
of <a href="https://github.com/ZipCPU/icozip">the project</a>—but we’ve discussed <a href="/blog/2017/07/08/getting-started-with-wbscope.html">how
to build those
before</a>.</p>

<h3 id="test-one-using-wbregs-to-read-a-known-value-from-the-flash">Test one: Using wbregs to read a known value from the flash</h3>

<p>The next step, and really the first true test, is an important one when
designing for an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>:
you want to make certain you can read back a <em>known piece of data</em> from the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.  While
there may be other uses for the vendor identification protocol within the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> specification, I find that
using it as a test read from the device is the most useful.  In particular, if
I read that ID from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
I can quickly determine if I managed to get the sequencing right between all of
the various signals.</p>

<p>Looking over the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="http://www.cypress.com/file/177961/download">specfication</a>,
you’ll see that sending a <code class="language-plaintext highlighter-rouge">0x9f</code> to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip will request this identification value.  Ever after until the chip select
is deactivated, the incoming data to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is ignored, and the
outgoing data from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
will be this known identification sequence–just as we showed in Fig. 14 above.</p>

<p>Most of my designs contain a command-line driven
<a href="https://en.wikipedia.org/wiki/PEEK_and_POKE">peek and poke</a>
capability <a href="/blog/2017/06/16/dbg-bus-forest.html">I call
<code class="language-plaintext highlighter-rouge">wbregs</code></a>.
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/wbregs.cpp">This command</a>,
found in almost all of <a href="/projects.html">my system-level
projects</a>, allows you to read or
write addresses within the device’s internal
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>,
<a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">just the same as though those commands were issued
internally</a> from a source within the design.</p>

<p>In <a href="https://github.com/ZipCPU/icozip">this project</a>, which needs to support
software on both the <a href="https://www.raspberrypi.org">Raspberry
Pi</a> and on whatever <a href="/blog/2017/06/17/why-network-debugging.html">host machine might connect
to it</a>, the
project will build one of two versions of this
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/wbregs.cpp"><code class="language-plaintext highlighter-rouge">wbregs</code></a>
program.  The first is <code class="language-plaintext highlighter-rouge">arm-wbregs</code> for running on the
<a href="https://www.raspberrypi.org">Pi</a>, whereas the second is <code class="language-plaintext highlighter-rouge">pc-wbregs</code> for
running on whatever other host platform might connect with the
<a href="https://www.raspberrypi.org">Pi</a> over a <a href="/blog/2017/06/17/why-network-debugging.html">TCP/IP
connection</a>.</p>

<p>Let’s run this <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> manufacture
identification test using <code class="language-plaintext highlighter-rouge">pc-wbregs</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ ./pc-wbregs flashcfg 0x0100
00200000 (FLASHCFG)-&gt; 00000100
$ ./pc-wbregs flashcfg 0x09f
00200000 (FLASHCFG)-&gt; 0000009f
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000001
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000020
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000018
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [...M] 0000004d
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000001
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000080
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [...1] 00000031
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [...0] 00000030
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 00000083
$ ./pc-wbregs flashcfg 0x000 ; ./pc-wbregs flashcfg
00200000 (FLASHCFG)-&gt; 00000000
00200000 (FLASHCFG) : [....] 000000ff</code></pre></figure>

<p>If you watched the lower octet of the results, you’ll see that we just
read the ID string: <code class="language-plaintext highlighter-rouge">01:20:18:4d:01:80:31:30:83</code>.  While that works for
debugging by hand, it’s somewhat hard to read and we can do this better.  So
let’s tighten this up a bit, by switching our development to C++.</p>

<h3 id="test-two-accessing-the-flash-from-within-a-c-program">Test two: Accessing the flash from within a C++ program</h3>

<p>I thought it might be fun to show how easy this is to do via C++ when using
the <a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">debugging bus concept</a>.
When using the <a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus
interface</a>,
all it takes is a call to the <code class="language-plaintext highlighter-rouge">m_fpga-&gt;readio(addr);</code> method to read from the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>, or
likewise a <code class="language-plaintext highlighter-rouge">m_fpga-&gt;writeio(addr,value);</code> call to write a value to the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.  In our
case, we have a configuration register at address <code class="language-plaintext highlighter-rouge">R_FLASHCFG</code> that we wish
to read from or write to, so an example of reading from this register would
look like,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">val</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">);</span></code></pre></figure>

<p>Looking at the relevant portion of <code class="language-plaintext highlighter-rouge">flashid.cpp</code>, it starts with clearing
the trigger for the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
(if present).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#ifdef	R_SPIXSCOPE
</span>	<span class="c1">// Start up the scope at the beginning, in case anything goes wrong</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_SPIXSCOPE</span><span class="p">,</span> <span class="mi">124</span><span class="p">);</span>
<span class="cp">#endif</span></code></pre></figure>

<p>This will cause the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
to trigger on the lowering of the <code class="language-plaintext highlighter-rouge">CS_n</code> line, and then to wait another
124 clocks before it <a href="/blog/2017/06/08/simple-scope.html">freezes its buffer and stops
collecting</a>.</p>

<p>The next step is to issue the <code class="language-plaintext highlighter-rouge">READID</code> command (<code class="language-plaintext highlighter-rouge">0x9f</code>) to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="mh">0x09f</span><span class="p">);</span></code></pre></figure>

<p>This will send a <code class="language-plaintext highlighter-rouge">0x9f</code> to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, and leave the chip select
active–just the way we designed <a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">this
core</a> to
behave above.</p>

<p>We can now read the actual identification bytes.  Even
though our goal is to <em>read</em>, because of how we built the interface we’ll
need to write to the register first in order to clock the data out out of the
device.  The information we write isn’t relevant, so we can just
write a zero, and later read from the register.</p>

<p>The following does exactly that, but with perhaps a little more flair.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="mh">0x000</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"ID:"</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">id</span><span class="p">;</span>

		<span class="c1">// Read and print the last byte read</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%c%02x"</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="sc">' '</span><span class="o">:</span><span class="sc">':'</span><span class="p">,</span> <span class="n">id</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
		<span class="c1">// and clock in the next byte across the SPI interface</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="mh">0x000</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span></code></pre></figure>

<p>Finally, now that we are all done, we’ll want to return the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> to its
default state, allowing regular reads to be made again.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span></code></pre></figure>

<p>What happens when we run this program?</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./pc-flashid 
ID: 01:20:18:4d:01:80:31:30:83:ff:ff:ff</code></pre></figure>

<p>This is essentially the same thing we did before with <code class="language-plaintext highlighter-rouge">pc-wbregs</code>, only now
done from within C++.  That looks prettier now, doesn’t it?</p>

<p>If you look this value up in the
<a href="http://www.cypress.com/file/177961/download">flash specification</a>,
you can verify that these are indeed the right values we should expect.
Therefore, we’ve now finished test number two.</p>

<h3 id="test-three-copying-the-memory-out-of-the-flash">Test three: Copying the memory out of the flash</h3>

<p>For our next test, let’s try reading from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>We could use <code class="language-plaintext highlighter-rouge">wbregs</code> again to read a word from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  Here we read the
first word from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./pc-wbregs flash
01000000 <span class="o">(</span>   FLASH<span class="o">)</span> : <span class="o">[</span>....] ff0000ff</code></pre></figure>

<p>This looks like a synchronization word.  Indeed, it matches the first word
in our binary design file, suggesting this might also be the first word of the
binary that came shipped with our <a href="http://www.icoboard.org">ICO board</a>.</p>

<p>So … let’s read out the entire design!</p>

<p>We’ll do that with a program I call
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/dumpflash.cpp"><code class="language-plaintext highlighter-rouge">dumpflash</code></a>.
It’s usually the first program I run on any board I purchase, so that I never
lose the original manufacture provided pre-loaded design image.  The relevant
line to read the entire <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
found within
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/dumpflash.cpp">`dumpflash.cpp</a>,
is simply</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readi</span><span class="p">(</span><span class="n">DUMPMEM</span><span class="p">,</span> <span class="n">BUFLN</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span></code></pre></figure>

<p>That’s it!  By the time that command returns, and it will take a while since
it’s reading the <em>ENTIRE</em> <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>, the <code class="language-plaintext highlighter-rouge">DUMPMEM</code> buffer
will contain all of the contents from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>Not all of these contents are relevant.</p>

<p>When a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is erased, all of
the bits within it are set to ones.  Usually, upon delivery, this is how a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
comes from the manufacturer with one exception: the board manufacturer has
usually placed an initial load into the beginning of the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>.  For this reason, we can
trim any all one’s words from the end of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> image.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">sz</span> <span class="o">=</span> <span class="n">BUFLN</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span><span class="p">((</span><span class="n">sz</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">))</span>
		<span class="n">sz</span><span class="o">--</span><span class="p">;</span>
	<span class="n">sz</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Once done, we can write the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> contents to an external file.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s">"w"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"ERR: Could not write %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fname</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fwrite</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span></code></pre></figure>

<p>That was easier than you might have expected, now, wasn’t it?  See how powerful
the <a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus
concept</a> is?</p>

<p>Just as a foot note, be aware that this data may be byte swapped at this
point.  The
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a> 
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">implementation I’ve
created</a>
is <a href="https://en.wikipedia.org/wiki/Endianness">big endian</a>,
even though most computers these days are <a href="https://en.wikipedia.org/wiki/Endianness">little
endian</a>.</p>

<h3 id="test-four-writing-to-the-flash">Test four: Writing to the flash</h3>

<p>Each of the projects I have containing a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a> also contains a <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">flash
driver</a>
host software component.  This makes writing to the 
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> fairly simple.</p>

<p>The <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.h">C++ interface</a>
to this <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">device driver</a>
is primarily a simple <code class="language-plaintext highlighter-rouge">write</code> function.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">FLASHDRVR</span> <span class="p">{</span>
	<span class="c1">// ...</span>
	<span class="n">FLASHDRVR</span><span class="p">(</span><span class="n">DEVBUS</span> <span class="o">*</span><span class="n">fpga</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_fpga</span><span class="p">(</span><span class="n">fpga</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_debug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
	<span class="c1">// ...</span>
	<span class="kt">bool</span>	<span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">verify</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure>

<p>By calling this function with the address within the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
that you wish to write to, together with the length of the data and a pointer
to that same data, the <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">device
driver</a>
will first check what is currently written on the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
erase if necessary, and then write the new values to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>That function calls two other functions that need to work in order to be able
to program and reprogram the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  The
first is the <code class="language-plaintext highlighter-rouge">erase_sector</code> function, and the second the <code class="language-plaintext highlighter-rouge">page_program</code>
function.  Sector in this context is 4kB
of <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>,
aligned on a 4kB boundary.  A page is similar: it references
256 bytes of memory, aligned on a 256 byte boundary.</p>

<p>Erasing a sector requires a couple steps.  First, a command needs to sent to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
to enable write mode.  This is a simple <code class="language-plaintext highlighter-rouge">8'h06</code> command that needs to be sent
to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
It’s a straight forward use of the configuration port.  We’ll start by
clearing the configuration mode by writing <code class="language-plaintext highlighter-rouge">9'100</code> to the interface, just out
of an abundance of caution to make certain <code class="language-plaintext highlighter-rouge">o_spi_cs_n</code> is high (inactive).
We’ll then write the <code class="language-plaintext highlighter-rouge">8'h06</code> write enable command, <code class="language-plaintext highlighter-rouge">F_WREN</code>, and tell
the
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to end the transaction by lowering <code class="language-plaintext highlighter-rouge">o_spi_cs_n</code> again.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">// Write enable</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_WREN</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span></code></pre></figure>

<p>We can now issue the sector erase command, <code class="language-plaintext highlighter-rouge">F_SE</code> or <code class="language-plaintext highlighter-rouge">0x0d8</code>.  This command
is followed by a three byte argument containing the
address of the 4kB segment that we wish to erase.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_SE</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span>    <span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span></code></pre></figure>

<p>We’ll then wait for this operation to complete by calling <code class="language-plaintext highlighter-rouge">flwait()</code>.
This function simply sends the “read-status register” command, <code class="language-plaintext highlighter-rouge">F_RDSR1=0x05</code>,
to the flash.  Ever after, every time 8-clocks are sent to the flash an
updated status register will be returned.  Once the low order bit, <code class="language-plaintext highlighter-rouge">WIP=1</code>,
is clear, the flash has finished erasing our sector.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>	<span class="n">FLASHDRVR</span><span class="o">::</span><span class="n">flwait</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">const</span>	<span class="kt">int</span>	<span class="n">WIP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// Write in progress bit</span>
	<span class="n">DEVBUS</span><span class="o">::</span><span class="n">BUSW</span>	<span class="n">sr</span><span class="p">;</span>

	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_RDSR1</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_EMPTY</span><span class="p">);</span>
		<span class="n">sr</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">sr</span><span class="o">&amp;</span><span class="n">WIP</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Erasing a sector turns all the bits in that sector to <code class="language-plaintext highlighter-rouge">1</code>.  This really isn’t
what we want to do end the end.  We want our data written to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
regardless of whether it consists of <code class="language-plaintext highlighter-rouge">1</code>’s or <code class="language-plaintext highlighter-rouge">0</code>’s, and we want the <code class="language-plaintext highlighter-rouge">1</code>’s
and <code class="language-plaintext highlighter-rouge">0</code>’s put in the right place.  The difference is associated with how
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is built.  The only way to turn a bit from a <code class="language-plaintext highlighter-rouge">0</code> to a <code class="language-plaintext highlighter-rouge">1</code> is to first erase a large block of <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>.  In this case, we erased
a 4kB sector.  Some
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips allow erasing smaller
portions of memory called subsectors.</p>

<p>One problem that results from erasing
4kB at a time in order to write to <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a> is that of collateral
damage: it is possible that by erasing a sector, some other valuable
information in that sector will get erased.  This <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">flash
driver</a>
handles that problem by assuming that you will be smart enough
not to do that.  (You will, right?)  If you write to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
using <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/flashdrvr.cpp">this
driver</a>,
starting from a sector boundary and ending on a sector boundary then you will
have no problems.</p>

<p>The second step of writing information to a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is to <em>program</em> the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.  Programming the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> turns user specified bits
to <code class="language-plaintext highlighter-rouge">0</code>.  It cannot return bits to <code class="language-plaintext highlighter-rouge">1</code>, it can only turn them from <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>Programming the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is, in many ways, very similar to the erase cycle presented above.  It starts with sending a
write enable command to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Write enable</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_WREN</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span></code></pre></figure>

<p>followed by a “page program” command, <code class="language-plaintext highlighter-rouge">F_PP = 0x02</code> to actually write
the page of <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Issue the command</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_PP</span><span class="p">);</span></code></pre></figure>

<p>Like the erase command, the page program command needs the address of where
to begin programming.  This is passed as a three byte argument following
the 8-bit command word.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// The address</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="p">(</span><span class="n">flashaddr</span>    <span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">);</span></code></pre></figure>

<p>The third step is to write the data, byte by byte, to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
controller, and hence to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Write the page data itself</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">);</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
	<span class="c1">// ...</span></code></pre></figure>

<p>Once this programming request closes, the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
will become busy again.  As with the erase, we’ll call the <code class="language-plaintext highlighter-rouge">flwait()</code>
function to wait for the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> to complete.</p>

<p>Now, using the
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/zipload.cpp">zipload</a>
program, we can load a <a href="/about/zipcpu.html">ZipCPU</a> executable program onto the 
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, to see if it runs.</p>

<p>I’ll skip to the end at this point and just say that the interface works.
You can now run the <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/sw/board/cputest.c">CPUTEST</a> on the
<a href="http://www.icoboard.org">ICO board</a>.  <a href="https://github.com/ZipCPU/icozip/blob/master/sw/board/hello.c">Hello
World</a> 
works too!</p>

<p>If you’d like more instructions, feel free to check out the
<a href="https://github.com/ZipCPU/icozip">README</a>
to the <a href="https://github.com/ZipCPU/icozip">icozip project</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Okay, so what have we done here?</p>

<ol>
  <li>
    <p>We learned about basic
  <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
  interactions.</p>
  </li>
  <li>
    <p>We’ve built a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
to get fast access to reading from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
quick access to continued readings, and we even created a configuration port
for issuing arbitrary commands to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>
  </li>
  <li>
    <p>We demonstrated how a <code class="language-plaintext highlighter-rouge">cover()</code> statement can make building a new core
easier.</p>
  </li>
  <li>
    <p>We learned about System Verilog
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>,
and saw how they could simplify properties describing interactions that take
place over several clock cycles.</p>
  </li>
  <li>
    <p>We looked at how the
<a href="/zipcpu/2018/07/13/memories.html">memory properties</a>
for reading the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
could be written with just a single assertion.</p>
  </li>
  <li>
    <p>We then saw how powerful the
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>
was in order to know if this device driver worked or not.</p>
  </li>
  <li>
    <p>Finally, I pointed you to instructions for running one of two demonstration
programs on the <a href="/about/zipcpu.html">ZipCPU</a> on the
<a href="http://www.icoboard.org">ICO board</a>.</p>
  </li>
</ol>

<p>That’s a lot of ground in one post!  However, notice how it was necessary to
make it from design to demonstration to know that the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>
fully worked.</p>

<p>While this may be a first <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/spixpress.v">controller</a>,
I wouldn’t recommend stopping here.  Most <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
chips</a> offer DSPI or QSPI support,
and even then there’s an <a href="https://en.wikipedia.org/wiki/Execute_in_place">eXecute In Place
(XIP)</a> option on top of that.
Usually, for a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller,
<a href="https://en.wikipedia.org/wiki/Execute_in_place">XIP</a> means that you don’t
need to re-issue the command–you can just issue the address and start reading.
However, these are topics we may return to on another day, but until then I
would encourage you to look into on your own should you be so interested.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For I am  the LORD, I change not; therefore ye sons of Jacob are not consumed. (Malachi 3:6)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
