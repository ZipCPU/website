<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Accessing the registers of a SoC+FPGA</title>
  <meta name="description" content="Fig 1. A DE-10 Nano">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2018/11/03/soc-fpga.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Accessing the registers of a SoC+FPGA</h1>
    <p class="post-meta"><time datetime="2018-11-03T00:00:00-04:00" itemprop="datePublished">Nov 3, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. A DE-10 Nano</caption><tr><td><img src="/img/de10-deskpic.jpg" alt="" width="480" /></td></tr></table>

<p>Some time ago, <a href="/blog/2018/02/09/first-cyclonev.html">I wrote about my experiences with Terasic’s
DE10-Nano</a>, a design
based around Intel (formerly Altera)’s <a href="https://www.intel.com/content/www/us/en/products/programmable/soc/cyclone-v.html">SoC+FPGA
Cyclone-V</a>
design.  If you’ve never worked with designs like this, the terminology
typically separates the SoC
(i.e. an <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>) from the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
with the terms Processing System (PS, or
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>)
and the Programming Logic (PL, or
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>).</p>

<p>These combined SoC+FPGA designs are an attempt to gain the best of both
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
and <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
worlds.  By combining the two together, the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
can control the logic taking place on the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
This control includes being able to load designs onto the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
from the <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
and to then control those designs from the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> using
<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory-mapped I/O register</a>.
The <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
is in an ideal position to control peripherals and their timing in detail.  The
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
is also in an ideal position to be a data accelerator.
Both of these applications require that the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
be able to communicate with the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
at high speed.</p>

<table align="center" style="float: left; padding: 24px"><caption>Fig 2. Communications channels between ARM and FPGA</caption><tr><td><img src="/img/socfpga-axi-interconnects.svg" alt="" width="360" /></td></tr></table>
<p>The <a href="https://www.intel.com/content/www/us/en/products/programmable/soc/cyclone-v.html">Cyclone-V</a>
chip on the <a href="https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;No=1046">DE-10</a>,
like other SoC+FPGA designs, has a high speed data path directly from the
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
to the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
and again in the reverse direction as shown in Fig 2.
These will form the topic of this article.</p>

<p>Today, I’d like to focus on the
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
side of this connection–the side where the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> is
controlled by a <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
We’ll ignore, and postpone for a later day, all of the details
associated with building the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
half of this connection, and focus solely on the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
side of this connection.  For now, I’ll only say of that connection that
I <em>highly</em> recommend you
<a href="/formal/2018/04/23/invariant.html">formally verify</a> the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
side since it can be <em>so</em> difficult to debug.</p>

<p>Further, I’m going to walk through two examples that can be used
for this purpose.  The first should work well on any generic <a href="https://en.wikipedia.org/wiki/Microcontroller">microcontroller</a>
with no <a href="https://en.wikipedia.org/wiki/Memory_management_unit">memory management unit
(MMU)</a> support,
and the second should work not only for the
<a href="https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;No=1046">DE-10</a>,
but also for any <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>
memory mapped interface including
<a href="https://www.xilinx.com/products/silicon-devices/soc/zynq-7000.html">Zynq</a>
designs, the
<a href="https://www.raspberrypi.org">Raspberry Pi</a>,
the <a href="https://beagleboard.org/bone">Beagle Bone</a>, and even other
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
based <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory-mapped I/O
register</a> designs.</p>

<p>I should pause to note that there’s a discussion to be had regarding whether
or not this code should be done within user space at all rather than in the
<a href="https://en.wikipedia.org/wiki/Operating_System">Operating System</a>.
There are strong arguments for both, so I’ll just leave that
discussion for another day.</p>

<p>So, without further ado, shall we discuss how to get access to fixed-address
registers from within a design?</p>

<h2 id="fixed-addressing">Fixed Addressing</h2>

<table align="center" style="float: right"><caption>Fig 3. Fixed address</caption><tr><td><img src="/img/socfpga-paddr.svg" alt="" width="240" /></td></tr></table>

<p>For your simpler non-<a href="https://en.wikipedia.org/wiki/Linux">Linux</a>
<a href="https://en.wikipedia.org/wiki/Microcontroller">microcontroller</a>
based designs, the interface is very straightforward and simple, though it
requires knowing about a part of the C language that isn’t usually used
outside of hardware programming: the
<a href="http://www.drdobbs.com/cpp/volatile-the-mutithreaded-programmers-b/184403766/"><code class="language-plaintext highlighter-rouge">volatile</code></a>
keyword.</p>

<p>Suppose you have an interface at a known address, <code class="language-plaintext highlighter-rouge">0xc045010</code>, shown as the
“user pointer” in Fig 3. on the right.  Let’s pretend
that it’s a reference to a device controller that occupies four 32-bit words
in our address space.  A good example of this might be the
<a href="https://github.com/ZipCPU/wbuart32">WBUART</a> serial port.  That peripheral has
four word-length registers controlling it.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span>  <span class="nc">WBUART_S</span> <span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">u_setup</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">u_fifo</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">u_rx</span><span class="p">,</span> <span class="n">u_tx</span><span class="p">;</span>
<span class="p">}</span> <span class="n">WBUART</span><span class="p">;</span></code></pre></figure>

<p>You’d like to be able to read from these registers within your own code.
To do that, you need a pointer to them.  The way to create a pointer
to a fixed address in C++ is,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="k">volatile</span> <span class="n">WBUART</span> <span class="o">*</span><span class="k">const</span> <span class="n">uart</span> <span class="o">=</span> <span class="p">(</span><span class="n">WBUART</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xc045010</span><span class="p">;</span></code></pre></figure>

<p>Let’s parse this line.</p>

<p>At the most basic level, we have just described a pointer to a
<a href="https://github.com/ZipCPU/wbuart32"><code class="language-plaintext highlighter-rouge">WBUART</code></a>
structure in memory, and we’ve named this pointer <code class="language-plaintext highlighter-rouge">uart</code> and given
it an initial address of <code class="language-plaintext highlighter-rouge">0xc045010</code> to point at.</p>

<p>Peeling the onion back one further, the <code class="language-plaintext highlighter-rouge">const</code> dictates that this pointer
references a constant location in the address space.  It cannot
change.  This is appropriate if ever the device in question will always have
the same address space location.  Hence, we have a <code class="language-plaintext highlighter-rouge">WBUART *const uart</code>.  In
this declaration, order matters.  <code class="language-plaintext highlighter-rouge">const WBUART *uart</code> would have declared a
pointer to a constant <code class="language-plaintext highlighter-rouge">WBUART uart</code> structure.  That’s not what we want.  We
want <em>constant pointer</em> to a structure of elements that isn’t necessarily
constant.</p>

<p>The next part of this definition is the
<a href="http://www.drdobbs.com/cpp/volatile-the-mutithreaded-programmers-b/184403766/"><code class="language-plaintext highlighter-rouge">volatile</code></a>
part.  This instructs the compiler that the value at this location in memory
might change apart from the program it is compiling changing it.</p>

<p>To explain this, imagine you want to transmit a character.  In the
<a href="https://github.com/ZipCPU/wbuart32"><code class="language-plaintext highlighter-rouge">WBUART</code></a>
interface, the <code class="language-plaintext highlighter-rouge">0x0100</code> bit of the transmit register returns a status field
indicating whether or not the register is busy.  If this bit is set, the
transmitter is busy or the transmit queue is non-empty.  If this bit is clear,
then the interface is idle.  For this task, let’s wait until the interface
is idle and then write a byte out of the serial port.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>	<span class="nf">txchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Wait for the transmit port to become available</span>
	<span class="k">while</span><span class="p">(</span><span class="n">uart</span><span class="o">-&gt;</span><span class="n">u_tx</span> <span class="o">&amp;</span> <span class="mh">0x0100</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="c1">// Send the character out the transmitter</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">u_tx</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>This sort of loop, waiting for something to happen, is called
<a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">polling</a>.
It is one of several ways to wait for an event within a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
In this case, we are waiting for the
<a href="https://github.com/ZipCPU/wbuart32"><code class="language-plaintext highlighter-rouge">WBUART</code></a>
transmitter to become idle.</p>

<p>A compiler might look at this code an notice that nothing within this
function is modifying <code class="language-plaintext highlighter-rouge">uart-&gt;u_tx</code>.  It might then consider itself justified
in treating this value as a constant, and pulling it out of the loop.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>	<span class="nf">txchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">v</span><span class="p">;</span>
	<span class="n">v</span> <span class="o">=</span> <span class="n">uart</span><span class="o">-&gt;</span><span class="n">u_tx</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0x0100</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="c1">// Send the character out the transmitter</span>
	<span class="n">uart</span><span class="o">-&gt;</span><span class="n">u_tx</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>This “optimized” implementation will only read from the peripheral register
once, and then either hang forever (if the interface is initially busy),
or move in.  This is clearly not what we want, since with this “optimized”
implementation we’ll never know when <code class="language-plaintext highlighter-rouge">uart-&gt;u_tx</code> changes!</p>

<p>From the compiler’s standpoint, this optimization makes sense: you read the
value, and it doesn’t see anything changing it, so it only reads the value
from memory once.</p>

<p>The compiler needs to be told that this value can change for reasons other
than the instructions it can examine within your code.  This is the purpose
of the
<a href="http://www.drdobbs.com/cpp/volatile-the-mutithreaded-programmers-b/184403766/"><code class="language-plaintext highlighter-rouge">volatile</code></a>
keyword in our definition above.</p>

<p>What about the <code class="language-plaintext highlighter-rouge">static</code> term?  This tells the compiler that only the code in
the current file will reference this value.  This keeps the compiler from
placing this constant value in global memory somewhere.  The address can
then be compiled into the object code as a fixed immediate value.</p>

<p>For designing interfaces to match most simple SoC design components, this is
enough.  If on the other hand the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
has a <a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>, like most
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
and
<a href="https://en.wikipedia.org/wiki/X86">x86</a> processors
(and more), then the fixed address may not be accessable to the program,
or it may be accessable at a different <a href="https://en.wikipedia.org/wiki/Virtual_address_space">virtual
address</a>.  In these cases,
the above approach will not work and you will need to get some help from the
<a href="https://en.wikipedia.org/wiki/Operating_System">Operating System</a>.</p>

<h2 id="dealing-with-the-mmu---designing-the-interface">Dealing with the MMU - Designing the Interface</h2>

<p>Declaring a constant pointer value, such as we did in the last section, isn’t
sufficient to access memory in a system that permits a <a href="https://en.wikipedia.org/wiki/Virtual_address_space">virtual address
space</a>.
In that case, every process might reference the same
<a href="https://en.wikipedia.org/wiki/Physical_address">physical address</a>
using
a different pointer value (<a href="https://en.wikipedia.org/wiki/Virtual_address_space">virtual
address</a>).<br />
The trick in this case is
determining how to get a <a href="https://en.wikipedia.org/wiki/Virtual_address_space">virtual
address</a>
that will map to the
<a href="https://en.wikipedia.org/wiki/Physical_address">physical addresses</a> of the
<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">peripheral registers</a>
in question.</p>

<table align="center" style="float: left; padding: 24x"><caption>Fig 4. I/O operations</caption><tr><td><img src="/img/socfpga-operations.svg" alt="" width="360" /></td></tr></table>

<p>When <a href="/blog/2017/06/29/sw-dbg-interface.html">we built our debugging
bus</a>, we used the
routines <code class="language-plaintext highlighter-rouge">readio(addr)</code> and <code class="language-plaintext highlighter-rouge">writeio(addr,value)</code> to access registers within
a traditional
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
see Fig 4.  To read a register, one might write:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">value</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span></code></pre></figure>

<p>In a similar fashion, you could write to a register controlled by a <a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">debugging
bus</a>
by writing,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span></code></pre></figure>

<p>I’m going to try to maintain this interface (somewhat), although that’s
really more than is required when interacting with a SoC+FPGA.</p>

<p>In the Intel SoC+FPGA design, there are a couple of memory regions that can
be mapped like this.  For the purpose of this example, let’s focus on the
light-weight interface, although aside from changing a couple of constants
in the design below, the result would be the same for any other shared
memory region, such as the heavy weight interface or the fixed
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
internal peripheral registers.</p>

<p>So let’s design the C++ header file necessary to work with such an interface.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#ifndef	LWMAP_H
#define	LWMAP_H
</span>
<span class="cp">#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;
#include "hps.h"</span></code></pre></figure>

<p>We’ll call our interface <code class="language-plaintext highlighter-rouge">LWMAP</code>, since it is going to map the lightweight
memory region of the
<a href="https://www.intel.com/content/www/us/en/products/programmable/soc/cyclone-v.html">Cyclone-V SoC</a>
on the
<a href="https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;No=1046">DE-10 Nano</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">LWMAP</span> <span class="p">{</span>
	<span class="kt">int</span>		<span class="n">m_fd</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">m_base</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">m_offset</span><span class="p">;</span></code></pre></figure>

<p>We can look up in the
<a href="https://www.intel.com/content/www/us/en/products/programmable/soc/cyclone-v.html">Cyclone-V</a>
<a href="https://www.intel.com/content/www/us/en/programmable/documentation/sfo1410143707420.html">device handbook</a>, HPS-FPGA Bridges chapter,
the region of
<a href="https://en.wikipedia.org/wiki/Physical_address">physical addresses</a>
assigned to this lightweight
<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory map</a>.
This region ranges from <code class="language-plaintext highlighter-rouge">0xff200000</code> to <code class="language-plaintext highlighter-rouge">0xff400000</code>.  It references an
area within the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
side of the design that the SoC portion of the chip can interact
with.  We’ll label the first address of this range the <code class="language-plaintext highlighter-rouge">LW_REGS_BASE</code> address,
and the number of addresses within this range the <code class="language-plaintext highlighter-rouge">LW_REGS_SPAN</code>.  We’ll also
define a third value, <code class="language-plaintext highlighter-rouge">LW_REGS_MASK</code>, that we can use to force an address to
be in this range–even if it is outside of the range.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">static</span> <span class="k">const</span>	<span class="kt">uint32_t</span>	<span class="n">LW_REGS_BASE</span> <span class="o">=</span> <span class="mh">0xff200000</span><span class="p">,</span>
					<span class="n">LW_REGS_SPAN</span> <span class="o">=</span> <span class="mh">0x00200000</span><span class="p">,</span>
					<span class="n">LW_REGS_MASK</span> <span class="o">=</span> <span class="n">LW_REGS_SPAN</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>The next step will be to get a pointer that we can then later use to address
the <a href="https://en.wikipedia.org/wiki/Physical_address">physical address</a> range.
We’ll place this pointer into the <code class="language-plaintext highlighter-rouge">m_base</code> value above, and we’ll do it when
we instantiate or LWMAP object.  We’ll come back to the details of this in
a moment, since in many ways these details are the critical piece of this
whole post.</p>

<table align="center" style="float: right"><caption>Fig 5. Fixed address terms</caption><tr><td><img src="/img/socfpga-terms.svg" alt="" width="360" /></td></tr></table>
<p>We’ll use the name <code class="language-plaintext highlighter-rouge">APPCODE_BASE</code> to reference the location of our user
peripherals within the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
address space.  In general <code class="language-plaintext highlighter-rouge">APPCODE_BASE</code> will
lie between <code class="language-plaintext highlighter-rouge">LW_REGS_BASE</code> and <code class="language-plaintext highlighter-rouge">LW_REGS_BASE+LW_REGS_SPAN</code>.  This is one
of those values provided to my design from the <a href="https://www.intel.com/content/www/us/en/programmable/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html">Intel Platform
Designer</a>.
Since I chose the name AppCode for my design, short for the very generic
“application code”, the name of my application design is <code class="language-plaintext highlighter-rouge">APPCODE_BASE</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="nl">public:</span>
	<span class="n">LWMAP</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">APPCODE_BASE</span><span class="p">);</span>
	<span class="o">~</span><span class="n">LWMAP</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span></code></pre></figure>

<p>Our first function will be to write to this <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped I/O
region</a>.
Given an address within this space and a value, let’s write the value to our
address.  Since <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> generates octet
addresses, we’ll need to shift our address right by two in order to get the
address of 32-bit word.  (<a href="https://gcc.gnu.org">GCC</a> will optimize this
away.)</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">writeio</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">av</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">m_offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LW_REGS_MASK</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">;</span>
		<span class="n">m_base</span><span class="p">[</span><span class="n">av</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>The process of reading from a register within this <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped I/O
region</a> is nearly identical.
However, instead of writing <code class="language-plaintext highlighter-rouge">value</code> to the register, we’ll just return the
value at that address.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">uint32_t</span>	<span class="nf">readio</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">av</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span> <span class="o">+</span> <span class="n">m_offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LW_REGS_MASK</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">m_base</span><span class="p">[</span><span class="n">av</span><span class="p">];</span>
	<span class="p">}</span></code></pre></figure>

<p>It might be nice to just simply write <code class="language-plaintext highlighter-rouge">pic_value = lwmap[R_PIC]</code>.  This
requires a fairly trivial overload of the <code class="language-plaintext highlighter-rouge">[]</code> operator.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">uint32_t</span>	<span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">readio</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<p>Sadly, these <code class="language-plaintext highlighter-rouge">writeio</code> and <code class="language-plaintext highlighter-rouge">readio</code> operations are only so useful.  In many
ways they don’t feal like the natural way of accessing an interface.  For this
purpose, <code class="language-plaintext highlighter-rouge">lea(addr)</code> calculates and returns the effective address of <code class="language-plaintext highlighter-rouge">addr</code> so
it can be used without <code class="language-plaintext highlighter-rouge">writeio</code> and <code class="language-plaintext highlighter-rouge">readio</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="o">*</span><span class="nf">lea</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span>	<span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">m_base</span> <span class="o">+</span> <span class="n">APPCODE_BASE</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">base</span> <span class="o">+</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="err">}</span><span class="p">;</span>

<span class="cp">#endif	// LWMAP_H</span></code></pre></figure>

<p>How would we use this interface?  In just about the same way we did before
when we were working with the <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging
bus</a>.
First, at the beginning of any application, we’d create an object
of class <code class="language-plaintext highlighter-rouge">LWMAP</code>.  Then we could repeatedly read a register
from the interface.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">LWMAP</span>	<span class="o">*</span><span class="n">gbl_lwmap</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">gbl_lwmap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LWMAP</span><span class="p">();</span>

	<span class="p">...</span> <span class="n">other</span> <span class="n">main</span> <span class="n">functions</span>

	<span class="k">delete</span>	<span class="n">gbl_lwmap</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>	<span class="nf">txuart</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// While busy</span>
	<span class="k">while</span><span class="p">(</span><span class="n">gbl_lwmap</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_UART_TX</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0100</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="n">gbl_lwmap</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_UART_TX</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Of course, if we wanted to use the <code class="language-plaintext highlighter-rouge">lea</code> approach, we could simplify this code
further.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>	<span class="nf">txuart</span><span class="p">(</span><span class="kt">int</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">volatile</span>	<span class="o">*</span><span class="n">uart_tx</span> <span class="o">=</span> <span class="n">gbl_lwmap</span><span class="o">-&gt;</span><span class="n">lea</span><span class="p">(</span><span class="n">R_UART_TX</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">uart_tx</span> <span class="o">&amp;</span> <span class="mh">0x0100</span><span class="p">)</span>
		<span class="p">;</span>

	<span class="o">*</span><span class="n">uart_tx</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">R_UART_TX</code> peripheral register is used here for illustration
purposes only.  Your design may, or may not, have an <code class="language-plaintext highlighter-rouge">R_UART_TX</code> register
depending on whether or not you put one in there.</p>

<p>Of these two approaches, <code class="language-plaintext highlighter-rouge">readio(addr)</code> vs using <code class="language-plaintext highlighter-rouge">lea(addr)</code>, I’m torn between
which I like more.  The <code class="language-plaintext highlighter-rouge">lea(addr)</code> approach is simpler to read, while the
<code class="language-plaintext highlighter-rouge">readio(addr)</code> is easier to use if you want to run your software on a design
within a Verilator simulation.</p>

<p>This is what we want to accomplish: the ability to read or write
<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped I/O</a>
registers from within a process running in a
<a href="https://en.wikipedia.org/wiki/Virtual_address_space">virtual address space</a>.
The only question remaining is, how do we set this up in the first place?
That’s the topic of the next section.</p>

<h2 id="implementing-the-interface">Implementing the interface</h2>

<p>The secret sauce to making this entire design work lies in the
<code class="language-plaintext highlighter-rouge">LWMAP</code> constructor that we just glossed over above.  Let’s take a moment
to look through and understand it now.</p>

<p>We’ll skip past some useful header includes.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;assert.h&gt;
</span>
<span class="cp">#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
</span><span class="c1">// hps.h is built by Intel's sopc-create-header-files program</span>
<span class="c1">// It defines some of our constants for us.  You may or may not</span>
<span class="c1">// need it in your design.</span>
<span class="cp">#include "hps.h"
#include &lt;time.h&gt;
</span>
<span class="cp">#include "lwmap.h"</span></code></pre></figure>

<p>With that out of the way, we can build our constructor method.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">LWMAP</span><span class="o">::</span><span class="n">LWMAP</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">m_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span></code></pre></figure>

<p>This constructor will depend upon the <code class="language-plaintext highlighter-rouge">/dev/mem</code> interface within the
<a href="https://en.wikipedia.org/wiki/Linux">Linux</a> system.  This interface will
give us access to the <a href="https://en.wikipedia.org/wiki/Physical_address">raw physical address
space</a>.  Hence,
we’ll start by opening it.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">m_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span> <span class="s">"/dev/mem"</span><span class="p">,</span> <span class="p">(</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_SYNC</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span> <span class="s">"ERROR: could not open </span><span class="se">\"</span><span class="s">/dev/mem</span><span class="se">\"</span><span class="s">, "</span> <span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<table align="center" style="float: right"><caption>Fig 5. Accessing a memory mapped peripheral using a virtual address</caption><tr><td><img src="/img/socfpga-vaddr.svg" alt="" width="320" /></td></tr></table>

<p>Our next and critical step will be to map this “file”, that is the
<a href="https://en.wikipedia.org/wiki/Physical_address">physical address space</a>
device of the system, into a region of memory within our
process.  In our case, that memory starts at <code class="language-plaintext highlighter-rouge">LW_REGS_BASE</code>
and continues for <code class="language-plaintext highlighter-rouge">LW_REGS_SPAN</code> addresses.  We’re creating a shared memory
map, so other processes can use this memory as well (watch out for
<a href="https://en.wikipedia.org/wiki/Concurrent_computing">concurrency issues</a>!),
and we’re mapping our file (i.e. the memory) based upon the file descriptor
<code class="language-plaintext highlighter-rouge">m_fd</code>.</p>

<p>This is done with the <a href="https://en.wikipedia.org/wiki/Mmap"><code class="language-plaintext highlighter-rouge">mmap</code> system call</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">LW_REGS_SPAN</span><span class="p">,</span>
		<span class="p">(</span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">),</span>
		<span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">m_fd</span><span class="p">,</span> <span class="n">LW_REGS_BASE</span><span class="p">);</span></code></pre></figure>

<p>This gives us an address, <code class="language-plaintext highlighter-rouge">m_base</code>, that we can then use to reference the
<code class="language-plaintext highlighter-rouge">LW_REGS_BASE</code> <a href="https://en.wikipedia.org/wiki/Physical_address">physical
address</a>.
Offsets from that address, up to <code class="language-plaintext highlighter-rouge">LW_REGS_SPAN</code> in
distance, will continue to map to this space.</p>

<p>The last step is to check for errors, and exit if this operation failed.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">if</span><span class="p">(</span> <span class="n">m_base</span> <span class="o">==</span> <span class="n">MAP_FAILED</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">perror</span><span class="p">(</span> <span class="s">"ERROR: mmap() failed, "</span> <span class="p">);</span>
		<span class="n">close</span><span class="p">(</span> <span class="n">m_fd</span> <span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="err">}</span></code></pre></figure>

<p>Once you are all done with this interface and no longer need access to any
of the peripheral registers from within your application, you can release
the <a href="https://en.wikipedia.org/wiki/Mmap">memory mapped region</a>.
and close the file descriptor.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">LWMAP</span><span class="o">::~</span><span class="n">LWMAP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">munmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">m_base</span><span class="p">,</span> <span class="n">LW_REGS_SPAN</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="n">perror</span><span class="p">(</span> <span class="s">"ERROR: munmap() failed, "</span> <span class="p">);</span>
	<span class="n">close</span><span class="p">(</span> <span class="n">m_fd</span> <span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>That’s the basic concept: <a href="https://en.wikipedia.org/wiki/Mmap">map</a> a
<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">peripheral</a>
residing at a <a href="https://en.wikipedia.org/wiki/Physical_address">physical address</a>
onto a <a href="https://en.wikipedia.org/wiki/Virtual_address_space">virtual page</a>
within your processes address space, and then access it like
you would any other variable.  Writes to that address will write to the
peripheral, and reads will read from it.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Normally, I focus on
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
issues when designing in Verilog.  Today’s post has been a bit different.  It
represents the other half of the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>+<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
processing world.  If you want to access an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
core via a <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory-mapped I/O
register</a> from C or C++,
you’ll need one of the techniques mentioned above.</p>

<p>While I’d like to say that this process is simply and easy, I originally learned
it by word of mouth, and then later struggled to find this information when
I looked for it.  Since this information is so important for
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>+<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
designs, I’ve chosen to include it here.</p>

<p>Before we leave this topic, though, let me just ask: Did you catch the
reference to how software could be written to run on both the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
connected to the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
as well as from
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>?
That will be important if you ever need to work with a design like this.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Salt is good: but if the salt have lost his savour, wherewith shall it be seasoned?  It is neither fit for the land, nor yet for the dunghill; but men cast it out. He that hath ears to hear, let him hear.  (Luke 14:34-35)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
