<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Breaking all the rules to create an arbitrary clock signal</title>
  <meta name="description" content="Have you ever needed a clock speed that wasn’t easy to generate?What if you wanted to build and run your ownPLL?Within an FPGA??">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2019/06/28/genclk.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/#training">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Breaking all the rules to create an arbitrary clock signal</h1>
    <p class="post-meta"><time datetime="2019-06-28T00:00:00-04:00" itemprop="datePublished">Jun 28, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Have you ever needed a clock speed that wasn’t easy to generate?
What if you wanted to build and run your own
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>?
Within an FPGA??</p>

<p>As an example, many of my favorite FPGA boards have 100MHz clocks coming into
them.  What if you wanted to output an audio signal via
<a href="https://en.wikipedia.org/wiki/I2S">I2S</a> at 48kHz?  48kHz is a common
audio sample rate associated with broadcast audio, sort of like
<a href="https://en.wikipedia.org/wiki/44,100_Hz">44.1kHz</a> is associated with <a href="https://en.wikipedia.org/wiki/Compact_Disc_Digital_Audio">CD
audio</a>.  I have an
<a href="https://www.analog.com/media/en/technical-documentation/data-sheets/ADAU1761.pdf">ADAU1761 24-bit Audio Codec</a>
available to me on my <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications">Nexys Video
board</a>,
so I should be able to use it to generate quality sound.  This
chip, however, requires an incoming clock signal of 49.152MHz in order to
produce samples at 48kHz.  Any suggestions on how you might multiply a
100MHz signal up to somewhere between 800 and 1600 MHz, and then divide it
down in order to get 49.152MHz?</p>

<p>There’s no way to do it.</p>

<p>Worse, what if you had to create a clock that <em>tracked</em> the audio sample rate
of an incoming signal–but only when it was present?</p>

<p>As another example, I can use a <a href="https://store.digilentinc.com/pmod-gps-gps-receiver">PMod
GPS</a> to measure the
clock rate of the board I’m using.  I should be possible to use this signal
to create a true 49.152MHz clock–true enough to be used as an audio frequency
standard.</p>

<p>That’s audio, but what about video?  Another common example of when you might
need to create a clock at an arbitrary frequency would be when trying to
generate a <a href="http://monitorinsider.com/cable_bandwidth.html">pixel clock for
video</a>.  With modern monitors,
the video driver is expected to query what video modes the monitor is capable
of accepting via an <a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID
protocol</a>
transaction (a form of <a href="https://www.i2c-bus.org">I2C bus</a>.  The video driver
is then expected to generate a pixel clock based upon what the monitor is
capable of receiving.  Without external clock generation hardware, how
can you create an arbitrary pixel clock?</p>

<p>Yes, I know you can often get away with being “close enough” in many of these
examples.  For example, if you wanted to feed a monitor wanting a 25.172MHz
pixel clock you might still be able to drive it with a 25MHz pixel clock
instead.  (I’ve done it.)  But what about 88.75MHz?  How might you generate
that signal?</p>

<p>Given that there’s a reason to need something like this, let’s discuss today
how you might generate a clock at an arbitrary frequency when using an FPGA.</p>

<h2 id="breaking-all-the-rules">Breaking all the rules</h2>

<p>In order to generate a clock at an arbitrary rate, we’re going to need to
<em>break all of the rules</em>.  Specifically, I wrote in my <a href="/blog/2017/08/21/rules-for-newbies.html">rules for new FPGA
designers</a>:
<em>never use a logic generated clock</em>.</p>

<blockquote>
  <ul>
    <li>
      <p>Build your design with only one clock.</p>
    </li>
    <li>
      <p>Do <em>not</em> transition on the positive (rising) edge of anything other than
your system clock.</p>
    </li>
  </ul>
</blockquote>

<p>I discourage anyone from using a logic generated clock for a few basic reasons:</p>

<ul>
  <li>
    <p>Logic generated clocks tend not to be placed onto the system clock backbone</p>

    <p>This will cause significant skew in your clock from one end of the chip to
another.  This skew can easily be bad enough to make your design fail for
seemingly inexplicable reasons.</p>
  </li>
  <li>
    <p>Beginners tend not to realize that you still need to use a proper <a href="/blog/2017/10/20/cdc.html">clock
domain crossing</a> from the
clock domain that generated the clock and the generated clock domain.</p>
  </li>
  <li>
    <p>Most FPGA tool chains don’t know how to handle logic clocks, assuming that
they are recognized at all.</p>

    <p>This leads to logic that isn’t properly constrained to guarantee operation
at the clock rate of interest.</p>
  </li>
  <li>
    <p>If your clock isn’t generated via a
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>,
there might be glitches on it</p>
  </li>
</ul>

<p>My rule has always been: Clocks should only ever be created or adjusted within
an FPGA using a hardware device clock management resource, such as a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>.</p>

<p>Today, we’re going to break this rule.</p>

<p>We also want to break it “safely”, so that this step won’t keep our logic
from acting “normally”.</p>

<p>To do this, I built and experimented with the architecture shown in Fig. 1
below.</p>

<table align="center" style="float: none"><caption>Fig 1. Arbitrary clock generation, hardware setup</caption><tr><td><img src="/img/genclk/blockdiag-basic.svg" alt="" width="720" /></td></tr></table>

<p>Let’s walk through the steps of how this might work.</p>

<p>The first step is to generate a new clock.  I used a <a href="/blog/2017/06/02/generating-timing.html">basic fractional clock
divider</a>
for this purpose.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">counter</span> <span class="o">+</span> <span class="n">i_delay</span><span class="o">;</span>

	<span class="k">assign</span>	<span class="n">o_clk</span> <span class="o">=</span> <span class="n">counter</span><span class="p">[</span><span class="n">MSB</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Well, not quite, but that’s the basics of the ideal initially.  We’ll come
back and improve upon this in a moment.</p>

<p>There are several problems with using a <a href="/blog/2017/06/02/generating-timing.html">basic fractional clock divider
divider</a>
such as this
one.  One of the worst problems is the phase noise.  Imagine you wanted to
divide your clock by three.  You would add to your counter some number on
every clock tick in an effort to get a divide by three.  If your clock
was <code class="highlighter-rouge">N</code> bits wide, then clearly after <code class="highlighter-rouge">2^N</code> clock ticks, this pseudo clock
generator would have wrapped some integer number of times.  If we make this
integer close to <code class="highlighter-rouge">2^N/3</code>, we can get close to a division by three.</p>

<p>Perhaps a picture would help.  Suppose we used a <code class="highlighter-rouge">4</code> bit counter, to which
we add a delay value of <code class="highlighter-rouge">5</code> to it–in order to get close to 1/3, while also
picking off the top bit for our new clock.  If you plotted this out, you might
see a trace similar to Fig. 2 below.</p>

<table align="center" style="float: none"><caption>Fig 2. A Fractionally Generated Clock Signal</caption><tr><td><img src="/img/genclk/trace.svg" alt="" width="720" /></td></tr></table>

<p>If you ignore the fact, for a moment, that this may be about the ugliest clock
signal you’ve ever seen, you’ll notice that this clock signal is high for
five periods out of 16, which is a rough divide by three.</p>

<p>If we add more bits to our counter and step, we’ll be able to represent more
frequencies For example, if we had used a <code class="highlighter-rouge">32</code>-bit counter, we might step
by <code class="highlighter-rouge">32'h55555555</code>.  No, that’s still not quite <code class="highlighter-rouge">1/3</code>rd, but its much closer
than we were before.</p>

<p>While that’s better, the clock still looks awful–it just looks awful about
a frequency closer to the one we want.</p>

<p>We need a way to clean this up.</p>

<p>Enter the reason for using an <code class="highlighter-rouge">OSERDES</code> in Fig. 1.  By using an <code class="highlighter-rouge">OSERDES</code>, we
can get closer to the clean clock we wanted.  For example, the same clock from
Fig. 2 above, now upsampled by a factor of 8, would produce a waveform looking
closer to Fig. 3 below.</p>

<table align="center" style="float: none"><caption>Fig 3. Upsampling the fractionally generated clock</caption><tr><td><a href="/img/genclk/hires-trace.png"><img src="/img/genclk/hires-trace.png" alt="" width="720" /></a></td></tr></table>

<p>That is starting to look like a clock signal.</p>

<p>Of course, we’ll still have jitter on even this upsampled clock signal.  While
our upsampling helped, it could only do so much.  We’ll always have a signal
that’s going to be within a “sample” of the right value.  This rounding to the
nearest sample will always create phase noise on our clock.  Fixing this is
the purpose of the <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
in Fig. 1 above.</p>

<p>That leaves only a couple of key details remaining.</p>

<p>For example, why did we leave the FPGA on a clock capable pin only to
immediately come back in again?  I did this for a couple
of reasons.  First, we needed the OSERDES, that 8:1 serializer, in order
to create the cleaner clock signal.  <code class="highlighter-rouge">OSERDES</code> components are only
found connected to the I/O pins going directly off-chip.  Second, many FPGA’s
require that you must enter the chip from a clock-capable pin in order to get
into the clock infrastructure within the FPGA.  Doing otherwise will result
in a design error on many architectures.</p>

<p>The last question is, what clock rate do we tell the tools this input has since
we can vary it as often as we want?  For this, we’ll use the maximum clock
rate it can have.  I’ll leave the decision of what this maximum rate is to you.
I’ve used 200MHz, 100MHz, and 50MHz successfully.</p>

<p>Finally, let’s return to our reasons never to use a logic generated clock.
Have we dealt with all of the reasons “why not” so that we now can?</p>

<ul>
  <li>
    <p>Logic generated clocks tend not to be placed onto the system clock backbone</p>

    <p>By starting with a clock capable pin, we go directly into the clock
infrastructure on the chip.</p>
  </li>
  <li>
    <p>Beginners tend not to realize that you still need to use a proper <a href="/blog/2017/10/20/cdc.html">clock
domain crossing</a> from the
clock domain that generated the clock and the generated clock domain.</p>

    <p>We’ll be smart and use proper
<a href="/blog/2017/10/20/cdc.html">clock domain crossing</a>
techniques, right?</p>
  </li>
  <li>
    <p>Most FPGA tool chains don’t know how to handle logic generated clocks</p>

    <p>In this case, the tools will treat this as an externally generated clock,
at the maximum rate it can produce, so we’re good here too.</p>
  </li>
  <li>
    <p>If your clock isn’t generated via a
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>,
there might be glitches on it</p>

    <p>We’ve solved this by generating our clock using (several)
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s,
and the OSERDES helps as well.</p>
  </li>
</ul>

<p>Really, the only issue left is whether or not this clock will be “clean enough”.
For that, we’ll need to build it and test it.</p>

<h2 id="building-the-81-fractional-divider">Building the 8:1 Fractional Divider</h2>

<p>Building this divider is <em>really</em> easy.  It’s basically,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">UPSAMPLE</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>

	<span class="kt">reg</span>	<span class="p">[</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">counter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="p">(</span><span class="n">UPSAMPLE</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>     <span class="n">i_delay</span><span class="o">;</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i_delay</span><span class="o">;</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">i_delay</span><span class="o">;</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">i_delay</span><span class="o">;</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">i_delay</span><span class="o">;</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">i_delay</span><span class="o">;</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">*</span> <span class="n">i_delay</span><span class="o">;</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">i_delay</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Notice that each of these counters is created by adding an offset to a single
counter, <code class="highlighter-rouge">counter[0]</code>.  That keeps them all synchronized with each other.</p>

<p>Finally, the MSB from each counter is used as the outgoing clock signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">o_word</span> <span class="o">&lt;=</span> <span class="o">{</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">,</span> <span class="n">counter</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">,</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">,</span> <span class="n">counter</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">,</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">,</span> <span class="n">counter</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">,</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">,</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="o">};</span></code></pre></figure>

<p>There’s really not much more to it than that.  We’ll still do a walk through
the actual code below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">genclk</span><span class="p">(</span><span class="n">i_clk</span><span class="o">,</span> <span class="n">i_delay</span><span class="o">,</span> <span class="n">o_word</span><span class="o">,</span> <span class="n">o_stb</span><span class="p">)</span><span class="o">;</span>
	<span class="k">parameter</span>	<span class="n">BW</span><span class="o">=</span><span class="mi">32</span><span class="o">;</span>		<span class="c1">// The bus width
</span>	<span class="k">localparam</span>	<span class="n">UPSAMPLE</span><span class="o">=</span><span class="mi">8</span><span class="o">;</span>	<span class="c1">// Upsample factor
</span>	<span class="kt">input</span>	<span class="kt">wire</span>				<span class="n">i_clk</span><span class="o">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_delay</span><span class="o">;</span>
	<span class="kt">output</span>	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">UPSAMPLE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">o_word</span><span class="o">;</span></code></pre></figure>

<p>One of the things we haven’t discussed is how you might synchronize this clock
with operations carried out on the current clock.  For this, I’ve envisioned
using a strobe signal, <code class="highlighter-rouge">o_stb</code> shown below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">output</span>	<span class="kt">reg</span>				<span class="n">o_stb</span><span class="o">;</span>

	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">counter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="p">(</span><span class="n">UPSAMPLE</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">;</span></code></pre></figure>

<p>This is how I would normally handle generating an internal signal at a different
rate–something I could use without ever needing a
<a href="/blog/2017/10/20/cdc.html">clock domain crossing</a>.</p>

<p>While there will be a fairly uncontrolled delay between <code class="highlighter-rouge">o_stb</code> and the
outgoing clock, <code class="highlighter-rouge">o_stb</code> will at least maintain the proper clock to clock
relationship.</p>

<p>Coming back to the basic implementation above, perhaps you’ve noticed that
the big problem with this implementation is the requirement for the
multipliers.  Let’s see if we can get rid of them.  Multiplication by 1, 2,
4, and 8 is easy–they can be accomplished with a simple left shift.  What about
multiplication by <code class="highlighter-rouge">3</code>, <code class="highlighter-rouge">5</code>, or <code class="highlighter-rouge">7</code>?  Those will be harder.  Six is easy, though,
if we can already multiply by three.</p>

<p>In this case, we’ll cheat since all of these values can be created with
some creative addition–sparing us the multiply.</p>

<p>Multiplying <code class="highlighter-rouge">i_delay</code> times three, for example, is just a matter of adding it
to itself times two.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">times_three</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">i_delay</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">1'b0</span> <span class="o">}</span> <span class="o">+</span> <span class="n">i_delay</span><span class="o">;</span></code></pre></figure>

<p>Multiplying <code class="highlighter-rouge">i_delay</code> times five is the same as adding it to a copy of itself
times four.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">times_five</span>  <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">i_delay</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">2'b0</span> <span class="o">}</span> <span class="o">+</span> <span class="n">i_delay</span><span class="o">;</span></code></pre></figure>

<p>For seven, we can subtract <code class="highlighter-rouge">i_delay</code> from <code class="highlighter-rouge">i_delay</code> times eight.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">times_seven</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">i_delay</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">3'b0</span> <span class="o">}</span> <span class="o">-</span> <span class="n">i_delay</span><span class="o">;</span></code></pre></figure>

<p>Of course, it will take a clock in order for these values to be valid.  To
keep things consistent, let’s also delay <code class="highlighter-rouge">i_delay</code> by one clock tick as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">r_delay</span> <span class="o">&lt;=</span> <span class="n">i_delay</span><span class="o">;</span></code></pre></figure>

<p>The rest is just book keeping.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>	<span class="c1">// Times one
</span>		<span class="n">counter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r_delay</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>	<span class="c1">// Times two
</span>		<span class="n">counter</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">{</span> <span class="n">r_delay</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">1'b0</span> <span class="o">};</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span> <span class="c1">// Times three
</span>		<span class="n">counter</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">times_three</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span> <span class="c1">// Times four
</span>		<span class="n">counter</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">{</span> <span class="n">r_delay</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">2'b0</span> <span class="o">};</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span> <span class="c1">// Times five
</span>		<span class="n">counter</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">times_five</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">{</span> <span class="n">times_three</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">1'b0</span> <span class="o">};</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">counter</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">times_seven</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span> <span class="c1">// Times eight---and generating the next clk wrd
</span>		<span class="o">{</span> <span class="n">o_stb</span><span class="o">,</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span>  <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="o">{</span> <span class="n">r_delay</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mh">3'h0</span> <span class="o">};</span></code></pre></figure>

<p>Our final result is just the collection of all of the most-significant bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">o_word</span> <span class="o">&lt;=</span> <span class="o">{</span>	<span class="c1">// High order bit is "first"
</span>			<span class="n">counter</span><span class="p">[</span><span class="mi">1</span><span class="p">][(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">,</span>	<span class="c1">// First bit
</span>			<span class="n">counter</span><span class="p">[</span><span class="mi">2</span><span class="p">][(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">,</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">3</span><span class="p">][(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">,</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">4</span><span class="p">][(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">,</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">5</span><span class="p">][(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">,</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">6</span><span class="p">][(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">,</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">7</span><span class="p">][(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">,</span>
			<span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">][(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>	<span class="c1">// Last bit in order
</span>		<span class="o">};</span>
<span class="k">endmodule</span></code></pre></figure>

<p>How wide should <code class="highlighter-rouge">BW</code> be?  I’ve chosen to make it 32-bits wide.  Why?  Well,
because my Wishbone bus implementation is 32-bits wide.  It’s kind of an
arbitrary choice.  You’ll get more frequency accuracy (relative to the
system clock) the more bits you have, although I tend to think <code class="highlighter-rouge">32</code> bits
is enough.  With a 32-bit counter, you can
generate an arbitrary clock with frequency control in steps of
<code class="highlighter-rouge">SYS_CLOCK_FREQUENCY / 2^32</code>, or about <code class="highlighter-rouge">23 mHz</code> for a system clock of 100MHz.
(Yes, that is <em>milli</em>Hertz!) I figure that’s good enough.</p>

<h2 id="xilinx-specific-io">Xilinx Specific I/O</h2>

<p>In general, I try to keep this blog hardware agnostic, while just discussing
Verilog design and verification.  This particular design, however, needs some
help from the hardware, so let’s take a look at how we might handle the
I/O architecture for a Xilinx 7-series device.</p>

<p>The <a href="/blog/zipcpu/2017/10/06/autofpga-dataword.html">first rule is to separate anything that is vendor specific into its
own section of the
design</a>.
This will allow us to keep using
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
on the rest of the design.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">xgenclk</span><span class="p">(</span><span class="n">i_clk</span><span class="o">,</span> <span class="n">i_hsclk</span><span class="o">,</span> <span class="n">i_word</span><span class="o">,</span> <span class="n">io_pin</span><span class="o">,</span> <span class="n">o_clk</span><span class="o">,</span> <span class="n">o_locked</span><span class="p">)</span><span class="o">;</span>
	<span class="k">parameter</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">USE_PLL</span><span class="o">=</span><span class="mb">1'b1</span><span class="o">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_clk</span><span class="o">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>		<span class="n">i_hsclk</span><span class="o">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_word</span><span class="o">;</span>
	<span class="kt">inout</span>	<span class="kt">wire</span>		<span class="n">io_pin</span><span class="o">;</span>
	<span class="kt">output</span>	<span class="kt">wire</span>		<span class="n">o_clk</span><span class="o">;</span>
	<span class="kt">output</span>	<span class="kt">reg</span>		<span class="n">o_locked</span><span class="o">;</span>

	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">ignored_data</span><span class="o">;</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">slave_to_master</span><span class="o">;</span>

	<span class="kt">wire</span>	<span class="n">pll_input</span><span class="o">,</span> <span class="n">w_pin</span><span class="o">,</span> <span class="n">high_z</span><span class="o">;</span> <span class="o">//</span> <span class="n">fb_port</span><span class="o">;</span></code></pre></figure>

<p>Note the <code class="highlighter-rouge">USE_PLL</code> parameter above.  Since this clock generator can generate
anything up to the system clock rate in sub Hz resolution, it can generate
clocks so slow that Xilinx’s
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s
can’t lock
onto them.  For this reason, I have a flag to select whether or not to use a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
or not.  I suppose it’s not strictly necessary, but there will be a bit
of jitter on the resulting clock.</p>

<p>The <code class="highlighter-rouge">OSERDESE2</code> itself is something of a black box, present only on Xilinx
7-series parts.  If you are working on another part, check your documentation.
You’re likely to find other <code class="highlighter-rouge">SERDES</code> capabilities on other FPGAs, although 
they are likely to go by different names and have different interfaces.
Most of the setup below is fairly boiler plate.  (You’ll find other <code class="highlighter-rouge">SERDES</code>
capabilities on other FPGAs.) Even so, it’s possible to get it wrong.  Perhaps
you remember when <a href="/blog/2017/09/14/even-i-get-stuck.html">I was struggling to get this design to
work</a>?</p>

<p>Sadly, the only way I know how to debug output primitives like this <code class="highlighter-rouge">OSERDESE2</code>
is to read the fine manual, use an oscilloscope, read the manual again, fiddle
with the setup, check the oscilloscope, read the manual some more, and finally
fiddle with the setup until it works.  There is one other way that I know of,
and that is to find an online example (such as this one) and to compare it
to your design to see what you might be missing.</p>

<p>So let’s look at how this is configured.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Verilator lint_off PINCONNECTEMPTY
</span>	<span class="n">OSERDESE2</span>	<span class="p">#(</span></code></pre></figure>

<p>The first noteworthy item is that <code class="highlighter-rouge">OSERDESE2</code> needs to be set up for <code class="highlighter-rouge">DDR</code>
output mode.  While we might use <code class="highlighter-rouge">SDR</code> mode, we’d be limited to a high speed
clock of only <code class="highlighter-rouge">600MHz</code>, whereas when using the <code class="highlighter-rouge">DDR</code> mode you can go up to
<code class="highlighter-rouge">950MHz</code>.</p>

<p>This also means that our high-speed clock, <code class="highlighter-rouge">i_hsclk</code>, need only be 4x the
speed of the our system clock.  Of course, the two clocks, <code class="highlighter-rouge">i_hsclk</code>, and
<code class="highlighter-rouge">i_clk</code>, must also be generated by the same
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>.
This creates a bit of a hassle
when working with Xilinx’s Memory Interface Generator (MIG) generated cores,
since they produce a system clock for you to use and applying any
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
to this clock will require a
<a href="/blog/2017/10/20/cdc.html">clock domain crossing</a> to
move between the MIG clock and the newly generated one.  This is in spite of
the reality that the MIG uses an internally generated <code class="highlighter-rouge">4x</code> clock that would
be perfect for our purposes here–it’s just not an output of the MIG core.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="o">.</span><span class="n">DATA_RATE_OQ</span><span class="p">(</span><span class="s">"DDR"</span><span class="p">)</span><span class="o">,</span> <span class="c1">// DDR goes up to 950MHz, SDR only to 600
</span>		<span class="o">.</span><span class="n">DATA_RATE_TQ</span><span class="p">(</span><span class="s">"SDR"</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">DATA_WIDTH</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">SERDES_MODE</span><span class="p">(</span><span class="s">"MASTER"</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">TRISTATE_WIDTH</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>	<span class="c1">// Really ... this is unused
</span>		<span class="p">)</span> <span class="n">lowserdes</span><span class="p">(</span>
			<span class="o">.</span><span class="n">OCE</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">)</span><span class="o">,</span>
			<span class="o">.</span><span class="n">TCE</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">)</span><span class="o">,</span>	<span class="o">.</span><span class="n">TFB</span><span class="p">()</span><span class="o">,</span> <span class="o">.</span><span class="n">TQ</span><span class="p">(</span><span class="n">high_z</span><span class="p">)</span><span class="o">,</span>
			<span class="o">.</span><span class="n">CLK</span><span class="p">(</span><span class="n">i_hsclk</span><span class="p">)</span><span class="o">,</span>	<span class="c1">// HS clock
</span>			<span class="o">.</span><span class="n">CLKDIV</span><span class="p">(</span><span class="n">i_clk</span><span class="p">)</span><span class="o">,</span>	<span class="c1">// Divided clock input (lowspeed clock)
</span>			<span class="o">.</span><span class="n">OQ</span><span class="p">(</span><span class="n">w_pin</span><span class="p">)</span><span class="o">,</span>	<span class="c1">// Data path to IOB *only*
</span>			<span class="o">.</span><span class="n">OFB</span><span class="p">()</span><span class="o">,</span>	<span class="o">//</span> <span class="n">Data</span> <span class="n">path</span> <span class="kt">output</span> <span class="n">feedback</span> <span class="n">to</span> <span class="n">ISERDESE2</span> <span class="kt">or</span> <span class="n">ODELAYE2</span></code></pre></figure>

<p>The next big confusing question is over which bit gets transmitted first.  I’ll
admit, I got this wrong at first.  The fact that the Xilinx xSERDESE2
components swap which bit is first between them only makes things more
confusing.  I was able to generate the following ordering using an Oscilloscope.
In this case, <code class="highlighter-rouge">D1</code> goes “first”, then <code class="highlighter-rouge">D2</code>, etc.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="o">.</span><span class="n">D1</span><span class="p">(</span><span class="n">i_word</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span><span class="o">,</span>
			<span class="o">.</span><span class="n">D2</span><span class="p">(</span><span class="n">i_word</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span><span class="o">,</span>
			<span class="o">.</span><span class="n">D3</span><span class="p">(</span><span class="n">i_word</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="o">,</span>
			<span class="o">.</span><span class="n">D4</span><span class="p">(</span><span class="n">i_word</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">,</span>
			<span class="o">.</span><span class="n">D5</span><span class="p">(</span><span class="n">i_word</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">,</span>
			<span class="o">.</span><span class="n">D6</span><span class="p">(</span><span class="n">i_word</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">,</span>
			<span class="o">.</span><span class="n">D7</span><span class="p">(</span><span class="n">i_word</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">,</span>
			<span class="o">.</span><span class="n">D8</span><span class="p">(</span><span class="n">i_word</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">,</span>
			<span class="o">.</span><span class="n">RST</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">)</span><span class="o">,</span>
			<span class="o">.</span><span class="n">TBYTEIN</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">)</span><span class="o">,</span> <span class="o">.</span><span class="n">TBYTEOUT</span><span class="p">()</span><span class="o">,</span>
			<span class="o">.</span><span class="n">T1</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">)</span><span class="o">,</span> <span class="o">.</span><span class="n">T2</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">)</span><span class="o">,</span> <span class="o">.</span><span class="n">T3</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">)</span><span class="o">,</span> <span class="o">.</span><span class="n">T4</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">)</span><span class="o">,</span>
			<span class="o">.</span><span class="n">SHIFTIN1</span><span class="p">()</span><span class="o">,</span> <span class="o">.</span><span class="n">SHIFTIN2</span><span class="p">()</span><span class="o">,</span>
			<span class="o">.</span><span class="n">SHIFTOUT1</span><span class="p">()</span><span class="o">,</span> <span class="o">.</span><span class="n">SHIFTOUT2</span><span class="p">()</span>
		<span class="p">)</span><span class="o">;</span>
	<span class="o">//</span> <span class="n">Verilator</span> <span class="n">lint_on</span>  <span class="n">PINCONNECTEMPTY</span></code></pre></figure>

<p>Yes, many of these pins are not used.  I’ve kept these unused pins within my
own code more to remind myself of them than anything else.</p>

<p>What about that <code class="highlighter-rouge">// Verilator lint_on  PINCONNECTEMPTY</code> comment?  Yes, I have
tried to
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilate</a>
this code.  No, I don’t have a
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
model for an <code class="highlighter-rouge">OSERDESE2</code>, but I was hoping to use
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>’s
linting capabilities to find bugs when things weren’t going well.</p>

<p>The last item to notice of this <code class="highlighter-rouge">OSERDESE2</code> configuration is that the output
is placed into a <code class="highlighter-rouge">w_pin</code> wire.  This wire now needs to be placed through a
bi-directional I/O buffer, while holding the high-impedence flag, <code class="highlighter-rouge">T</code>, low.
This makes certain that the output of this pin will always come back in on
the input.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">IOBUF</span>	<span class="n">genclkio</span><span class="p">(</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">w_pin</span><span class="p">)</span><span class="o">,</span> <span class="o">.</span><span class="n">IO</span><span class="p">(</span><span class="n">io_pin</span><span class="p">)</span><span class="o">,</span> <span class="o">.</span><span class="n">O</span><span class="p">(</span><span class="n">pll_input</span><span class="p">)</span><span class="o">,</span> <span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>Finally, we can use a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
clock resource to clean up any mess we’ve left behind.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">USE_PLL</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="kt">wire</span>	<span class="n">pll_fb</span><span class="o">,</span> <span class="n">pll_fb_unbuffered</span><span class="o">,</span> <span class="n">pll_locked</span><span class="o">,</span> <span class="n">pll_output</span><span class="o">;</span>

		<span class="c1">// Verilator lint_off  PINCONNECTEMPTY
</span>		<span class="n">PLLE2_BASE</span>	<span class="p">#(</span>
				<span class="o">.</span><span class="n">BANDWIDTH</span><span class="p">(</span><span class="s">"LOW"</span><span class="p">)</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKFBOUT_MULT</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="o">,</span>	<span class="c1">// 800 MHz
</span>				<span class="o">.</span><span class="n">CLKFBOUT_PHASE</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKIN1_PERIOD</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">,</span>	<span class="c1">//  40 MHz
</span>				<span class="o">.</span><span class="n">CLKOUT0_DIVIDE</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">,</span>
				<span class="o">.</span><span class="n">REF_JITTER1</span><span class="p">(</span><span class="mf">0.19</span><span class="p">)</span>	<span class="c1">// Sim only parameter
</span>				<span class="p">)</span> <span class="n">pll</span> <span class="p">(</span>
				<span class="c1">// .CLKOUT5_DIVIDE(1),
</span>				<span class="o">.</span><span class="n">CLKFBIN</span><span class="p">(</span><span class="n">pll_fb</span><span class="p">)</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKFBOUT</span><span class="p">(</span><span class="n">pll_fb</span><span class="p">)</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKIN1</span><span class="p">(</span><span class="n">pll_input</span><span class="p">)</span><span class="o">,</span>
				<span class="c1">// .CLKIN1(io_pin),
</span>				<span class="o">.</span><span class="n">LOCKED</span><span class="p">(</span><span class="n">pll_locked</span><span class="p">)</span><span class="o">,</span>
				<span class="o">.</span><span class="n">PWRDWN</span><span class="p">(</span><span class="o">!</span><span class="n">r_ce</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">,</span>
				<span class="o">.</span><span class="n">RST</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">)</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKOUT0</span><span class="p">(</span><span class="n">pll_output</span><span class="p">)</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKOUT1</span><span class="p">()</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKOUT2</span><span class="p">()</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKOUT3</span><span class="p">()</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKOUT4</span><span class="p">()</span><span class="o">,</span>
				<span class="o">.</span><span class="n">CLKOUT5</span><span class="p">())</span><span class="o">;</span>
		<span class="c1">// Verilator lint_on  PINCONNECTEMPTY
</span>	
		
		<span class="n">BUFG</span> <span class="n">pllbuf</span><span class="p">(</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">pll_output</span><span class="p">)</span><span class="o">,</span> <span class="o">.</span><span class="n">O</span><span class="p">(</span><span class="n">o_clk</span><span class="p">))</span><span class="o">;</span>
	
		<span class="kt">reg</span>	<span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">r_locked</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="n">r_locked</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">r_locked</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="n">pll_locked</span> <span class="o">};</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="n">o_locked</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r_locked</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">2</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>Success for my experiments with this core was indicated when this
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
locked.  I used that as a binary indicator that the quality of result was
“good enough”.</p>

<p>Finally, if the clock frequency needs to be so low that we cannot use the
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>,
then we’ll just place the I/O pin as in input directly into a clock buffer
and move on.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">o_locked</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="n">BUFG</span> <span class="n">clkbuf</span><span class="p">(</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">io_pin</span><span class="p">)</span><span class="o">,</span> <span class="o">.</span><span class="n">O</span><span class="p">(</span><span class="n">o_clk</span><span class="p">))</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span>
	
<span class="k">endmodule</span></code></pre></figure>

<p>I might come back and update this core later to optionally remove the
<code class="highlighter-rouge">BUFG</code> elements with a parameter setting.  These elements are important in
order to place your newly generated clock into the clock circuitry of the FPGA.
Without them, you should be able to skip the
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
and instead go into a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
you configure external to this module.</p>

<h2 id="conclusion">Conclusion</h2>

<p>No, this design has never been <a href="/blog/2017/10/19/formal-intro.html">formally
verified</a>.  Sorry.
Were I to run this through the
<a href="/blog/2017/10/19/formal-intro.html">formal tools</a>,
I’m sure I would discover the lack of a whole lot of initial statements–but
this will still work without those.  It will just have a bit of a glitch on
start-up.</p>

<p>Instead, this design was verified using a <a href="https://store.digilentinc.com/digital-discovery-portable-logic-analyzer-and-digital-pattern-generator">Digital Discovery logic
analyzer</a>,
a <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications">Nexys Video board</a>,
and a lot of patience.  Further, the “clock capable pin”
that I used was the output bit used to control the fan.
(My board has a heat sink and no no fan, so this pin is otherwise unused.)</p>

<p>A better test might’ve measured the quality of this clock using dedicated
clock measurement hardware.  I haven’t done this.  I only know that I can
generate a clock within an FPGA and then run this same clock through a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>.
The <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
locks, and I can then use the new clock within my design.</p>

<p>I personally draw two conclusions from this work:</p>

<ol>
  <li>
    <p>Sometimes you need to use an oscilloscope.</p>
  </li>
  <li>
    <p>Sometimes you can break all the rules–and still get away with it.</p>
  </li>
</ol>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Whoso keepeth the commandment shall feel no evil thing: and a wise man's heart discerneth both time and judgment. (Eccl 8:5)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
