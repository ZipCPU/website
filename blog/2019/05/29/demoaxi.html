<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building the perfect AXI4 slave</title>
  <meta name="description" content="I’ve now already shared the story of the contract I was on some time ago,where I failed to achieve the performance I promised because I placed toomany bus br...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2019/05/29/demoaxi.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building the perfect AXI4 slave</h1>
    <p class="post-meta"><time datetime="2019-05-29T00:00:00-04:00" itemprop="datePublished">May 29, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I’ve now already shared the story of the contract I was on some time ago,
where <a href="/blog/2019/04/27/axi-addr.html">I failed to achieve the performance I promised because I placed too
many bus bridges</a>
between the <a href="/blog/2018/02/09/first-cyclonev.html">ARM and the
FPGA</a>
that shared the same die.</p>

<table align="center" style="float: none"><caption>Fig 1. Too many bus transformations</caption><tr><td><img src="/img/axiaddr/axiaddr-too-many-bridges.svg" alt="" width="780" /></td></tr></table>

<p>The easy way around this problem would be to design an
<a href="/doc/axi-spec.pdf">AXI interface</a>
to my data FIFO.  At the time of the project,
<a href="/doc/axi-spec.pdf">AXI</a>
was too complicated for me to understand.  I had tried to build an
<a href="/doc/axi-spec.pdf">AXI</a>
slave controller several times over, and failed every time.</p>

<table align="center" style="float: none"><caption>Fig 2. Reading from a data FIFO</caption><tr><td><img src="/img/axiaddr/axiaddr-dsp2net.svg" alt="" width="780" /></td></tr></table>

<p>I recently returned to the task, but this time using <a href="/blog/2017/10/19/formal-intro.html">formal
methods</a>.
My first step was to build a formal property file to describe an
<a href="/doc/axi-spec.pdf">AXI4</a>
interaction, similar to the <a href="/formal/2018/12/28/axilite.html">one we built for AXI-lite
together</a>.  I
learned several things along the way, too:</p>

<ul>
  <li>
    <p>According to the <a href="/doc/axi-spec.pdf">AXI specification</a>,
“On master and slave interfaces there must be no combinatorial paths
between input and output signals.”</p>

    <table align="center" style="float: none"><caption>Fig 3. Reading from a data FIFO</caption><tr><td><img src="/img/tweets/axi-spec-registered.png" alt="" width="614" /></td></tr></table>

    <p>If you aren’t <a href="https://twitter.com/ZipCPU">following me on twitter</a>,
then <a href="https://twitter.com/zipcpu/status/1130436872021434368">you’ve missed the discussion regarding the meaning of this
sentence</a>.
I have taken it to mean that all
<a href="/doc/axi-spec.pdf">AXI4</a>
signals must be registered.  Others have
since pointed out that this reading is probably too strict.  Perhaps a better
reading is just that “combinatorial paths between input and output
signals” are disallowed.</p>

    <p>Since I already started with the interpretation that all
<a href="/doc/axi-spec.pdf">AXI</a> signals must
be registered, I’ll stick with it here.  Indeed, registering all I/O’s is not
a bad thing as <a href="https://twitter.com/elaforest">Eric LaForest</a>
of <a href="http://fpgacpu.ca/gateforge/index.html">GateForge Consulting</a>
<a href="https://twitter.com/elaforest/status/1130667685984055296">wrote</a>,</p>

    <blockquote>
      <p>Although having a combinatorial path will work (I have seen it on some
Xilinx AXI IP), the resulting round-trip time on a ready/valid handshake
worsens designs: Shaving a cycle here is not worth the reduced Fmax and
harder P&amp;R.</p>
    </blockquote>

    <p>So there are good reasons to do this, even if I was mistaken that the
<a href="/doc/axi-spec.pdf">specification</a> required it.</p>

    <p>This is then unlike the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
designs I’ve done where the stall signal isn’t supposed to be registered.
This also means that it will be really hard to touch any
<a href="/doc/axi-spec.pdf">AXI</a> signal
without losing a clock due to delay.</p>
  </li>
  <li>
    <p>I also discovered the problem I had been suffering from: write transactions
don’t return one <code class="language-plaintext highlighter-rouge">BVALID</code> per element written, but rather one <code class="language-plaintext highlighter-rouge">BVALID</code>
response per <em>burst</em> transaction.  In other words, for every
<code class="language-plaintext highlighter-rouge">AWVALID &amp; AWREADY</code> or equivalently for every <code class="language-plaintext highlighter-rouge">WVALID &amp; WREADY &amp; WLAST</code>
there should be one <code class="language-plaintext highlighter-rouge">BVALID</code>.  I had thought, erroneously, that it was
supposed to be one <code class="language-plaintext highlighter-rouge">BVALID</code> per <code class="language-plaintext highlighter-rouge">WVALID &amp; WREADY</code>.</p>

    <p>This <code class="language-plaintext highlighter-rouge">BVALID</code> behavior is very different from write-acknowledgments under
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.
It’s also different from the <a href="/doc/axi-spec.pdf">AXI</a>
read channel.  In the case of the read channel, there is one
<code class="language-plaintext highlighter-rouge">RVALID &amp; RREADY</code> for every requested beat in any transaction.</p>
  </li>
  <li>
    <p>I’ve also discovered that in spite of all of
<a href="https://www.xilinx.com">Xilinx</a>’s training material,
<a href="/formal/2019/05/13/axifull.html">their own example core can’t handle high
throughput</a>: 1) reads take
a minimum of two clocks per beat of data, 2) the core will crash if multiple
subsequent requests are made, 3) it can’t handle any significant
back pressure, and 4) their core won’t handle reads and writes at the
same time.</p>

    <p>This is crazy poor performance.</p>

    <p>We’ll do better today.</p>
  </li>
  <li>
    <p>I’ve also read several other blog articles about how to build
<a href="/doc/axi-spec.pdf">AXI</a> slaves.
Most of these articles focus on building a state machine to handle one
transaction at a time.  While this kind of performance might be better
than <a href="https://www.xilinx.com">Xilinx</a>’s, designing an
<a href="/doc/axi-spec.pdf">AXI</a> slave from a
state-machine standpoint tends to introduce unnecessary stall
signals.  My application needed throughput.</p>
  </li>
</ul>

<p>I needed to do better.  I needed something that worked, and worked well.</p>

<p>So let’s take a look today at <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">what I managed to come up
with</a> and why.</p>

<h2 id="goals">Goals</h2>

<table align="center" style="float: right"><tr><td><img src="/img/demofull/demofull-design-goals.svg" alt="" width="360" /></td></tr></table>

<p>I had four primary goals in this exercise.  The first was that <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">my new AXI
slave core</a>
needed to be <a href="/doc/axi-spec.pdf">AXI</a>
compliant.  Realistically, that should be a given.  However, we’ve already
discussed how even <a href="/formal/2019/05/13/axifull.html">Xilinx’s example code wasn’t truly AXI
compliant</a>,
so I needed something new.  My next goal was that <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this new
core</a>
had to have maximum throughput.  This second goal was so important to me that
my third and fourth goals were identical: I wanted throughput!</p>

<p>High throughput!</p>

<p>For me, high throughput means that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">the core</a>
can handle one data beat per clock in both directions at the same time.
Further, I also wanted to make certain that this <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">high
throughput core</a>
would never stall any input requests unless it was already processing
a transaction on the same channel.</p>

<p>Is it possible?</p>

<p>Somewhere around the bottom of my page of goals, I actually had another
interface goal.  <a href="/blog/2019/01/12/demoaxilite.html">My previous example/demonstration AXI-lite
core</a> wasn’t very easy
to integrate into other parts of my design.  Instead, I wanted something that
was easier to integrate with other logic.  So, for this design, I wanted to use
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this AXI core</a>
as a bridge to a simpler interface that would be kept in another file–the
one that actually had my logic within it.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig. 4: Bridging to a Simpler Interface</caption><tr><td><img src="/img/demofull/demofull-simple-interface.svg" alt="" width="480" /></td></tr></table>

<p>That meant I needed an interface that looked like Fig. 4.</p>

<p>This interface was designed to support a very simple slave that could
handle every bus transaction in a single clock cycle, but had no capability
of stalling.</p>

<p>How does this simplify the logic of the downstream non-AXI slave?
Consider the simplest slave write logic I can think of,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_we</span><span class="p">)</span>
	<span class="n">mem</span><span class="p">[</span><span class="n">i_waddr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wdata</span><span class="p">;</span></code></pre></figure>

<p>and similarly for a read,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_rd</span><span class="p">)</span>
	<span class="n">o_rdata</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">i_raddr</span><span class="p">];</span></code></pre></figure>

<p>Could this get any simpler?</p>

<p>Indeed, there’s a <em>large</em> class of slaves that could handle an interface
like this.  Some examples include my <a href="https://github.com/ZipCPU/sdspi">SD card
controller</a>, <a href="https://github.com/ZipCPU/wbpwmaudio">PWM
audio controller</a>,
<a href="/zipcpu/2019/02/09/cpu-blinky.html">GPIO controller</a>,
<a href="https://github.com/ZipCPU/wbi2c">I2C controller</a>, <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/spio.v">button/switch
controller</a>,
<a href="https://github.com/ZipCPU/rtcclock">real-time clock</a>,
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt controller</a>,
<a href="/zipcpu/2018/04/17/ziptimer.html">ZipTimer</a>,
and much more.</p>

<p>However, most buses include <a href="/zipcpu/2017/05/29/select-lines.html">write
strobes</a> as well and
<a href="/doc/axi-spec.pdf">AXI</a>
is no different.  It would be a shame not to support them.  So we’ll add
support for the <a href="/zipcpu/2017/05/29/select-lines.html">write
strobes</a>
to our slave interface as well.  To support these, the slave will need to
update its logic to look something like the following.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_we</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">C_S_AXI_DATA_WIDTH</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_wstrb</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
			<span class="n">mem</span><span class="p">[</span><span class="n">i_waddr</span><span class="p">][</span><span class="n">k</span><span class="o">*</span><span class="mi">8</span><span class="o">+:</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wdata</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="mi">8</span><span class="o">+:</span><span class="mi">8</span><span class="p">]</span>
	<span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Not all slave devices support
<a href="/zipcpu/2017/05/29/select-lines.html">write strobes</a>,
but we’ll leave that decision up to the downstream implementation and simply
include them here.</p>

<p>Of course, the illustration above only demonstrates this interface applied to
a <a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.
In actuality, I’d would expect to drive a series of control register
and/or buffers instead of this example <a href="/zipcpu/2018/07/13/memories.html">block
RAM</a>,
but that’s a discussion to be had whenever we build whatever interface we’ll
connect this to.</p>

<p>What <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this core</a>
doesn’t support are stalls on the downstream interface, nor does it support
responses that take longer than a single cycle to determine.  Those extra
features would require <a href="/blog/2017/07/29/fifo.html">FIFO</a>
support within the channel, and that’s going to be part of a different
development, perhaps even an
<a href="/doc/axi-spec.pdf">AXI</a>
to <a href="/formal/2018/12/28/axilite.html">AXI-lite</a> implementation.</p>

<p>So how shall we design this <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">high speed AXI slave
core</a>?</p>

<h2 id="designing-the-waveform">Designing the waveform</h2>

<p>As <a href="/formal/2018/12/28/axilite.html">we’ve discussed before</a>,
<a href="/doc/axi-spec.pdf">AXI</a>
consists of five channels implementing between
them both a write interface (3 channels) and a read interface.  Unlike
the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>,
the logic for the two interfaces can be written and processed separately.
For now, we’ll start by looking at the read interface, just because it’s
the simpler of the two.</p>

<table align="center" style="float: right"><caption>Fig 5. Basic AXI read transaction</caption><tr><td><a href="/img/demofull/demofull-rd-basic.svg"><img src="/img/demofull/demofull-rd-basic.svg" alt="" width="480" /></a></td></tr></table>

<p>Fig. 5 on the right shows an example of a single basic
<a href="/doc/axi-spec.pdf">AXI</a> read transaction
that we can use for discussion.</p>

<p>The first key requirement of any high performance
<a href="/doc/axi-spec.pdf">AXI</a> slave is that
the <code class="language-plaintext highlighter-rouge">ARREADY</code> line must be high when the slave isn’t busy.
This keeps us from suffering from a stall signal when a read request is made.
Indeed, the <a href="/doc/axi-spec.pdf">AXI specification</a>
recommends leaving <code class="language-plaintext highlighter-rouge">ARREADY</code> (and <code class="language-plaintext highlighter-rouge">AWREADY</code>) high while waiting for a
request.  This will also be our first departure from <a href="/formal/2019/05/13/axifull.html">Xilinx’s demo AXI
implementation</a>.</p>

<p>The transaction then starts with the request on the read address channel,
as indicated by <code class="language-plaintext highlighter-rouge">ARVALID</code>.  This will tell us the address
we want to read, <code class="language-plaintext highlighter-rouge">ARADDR</code>, and the number of items to be read, <code class="language-plaintext highlighter-rouge">ARLEN+1</code>.
Each of these items will take at least a separate clock period, and so
they are often called “beats”.  Further, since combinatorial paths are
forbidden between inputs and outputs, we can’t start responding before
the next clock.  However, we can respond as early as the next clock
tick.  Then, after <code class="language-plaintext highlighter-rouge">S_AXI_ARLEN</code> clock ticks, we’ll set <code class="language-plaintext highlighter-rouge">S_AXI_RLAST</code>
and return our last item.</p>

<p>Don’t miss this key fact: <em>there are <code class="language-plaintext highlighter-rouge">ARLEN+1</code> beats in a read transaction,
and likewise <code class="language-plaintext highlighter-rouge">AWLEN+1</code> beats in a write transaction</em>.  It’s not <code class="language-plaintext highlighter-rouge">ARLEN</code> or
<code class="language-plaintext highlighter-rouge">AWLEN</code>.  That extra <code class="language-plaintext highlighter-rouge">+1</code> is important, and <a href="https://twitter.com/zipcpu/status/1129083967242723329">more than one individual
missed this key detail on one of my weekly formal verification
quizes</a>.</p>

<p>If we drew this read transaction out into a state machine diagram, we
might get something looking like Fig. 6 below.</p>

<table align="center" style="float: none"><caption>Fig 6. An Initial Read Finite State Machine</caption><tr><td><a href="/img/demofull/demofull-rd-fsm-initial.svg"><img src="/img/demofull/demofull-rd-fsm-initial.svg" alt="" width="640" /></a></td></tr></table>

<p>In this diagram, the read channel starts in the idle state where the <code class="language-plaintext highlighter-rouge">R</code>
in the bottom corner of the <code class="language-plaintext highlighter-rouge">Idle</code> box indicates that <code class="language-plaintext highlighter-rouge">ARREADY</code> is true.  Upon
receiving a burst read request, we’d move to either the middle state, <code class="language-plaintext highlighter-rouge">Mid</code>,
or the end state, <code class="language-plaintext highlighter-rouge">End</code>, depending upon whether or not
<code class="language-plaintext highlighter-rouge">ARLEN==0</code>.  In both of these states, the <code class="language-plaintext highlighter-rouge">V</code> in the lower right corner
indicates that <code class="language-plaintext highlighter-rouge">RVALID</code> is true.  From the middle state, once the next to
the last item has been transferred, we’d move to the end state where <code class="language-plaintext highlighter-rouge">L</code>
indicates that <code class="language-plaintext highlighter-rouge">RLAST</code> is also true.  From the final ending state we can
return to idle.  Further, the design cannot advance from either the middle
or the ending state unless <code class="language-plaintext highlighter-rouge">RREADY</code> is also high as noted by the <code class="language-plaintext highlighter-rouge">R</code> on
the transition.</p>

<p>The neat thing about this design, as I’ve just outlined by the notes in the
corners of the states, is that the
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite state machine (FSM)</a>
signals <em>are</em> the <a href="/doc/axi-spec.pdf">AXI</a> output signals.
(See <a href="/tutorial/">my tutorial</a> if you would like more
information on <a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite state
machines</a>.)
This allows us to register the output signals without needing a separate
set of state registers.  Likewise the incoming signals from the
<a href="/doc/axi-spec.pdf">AXI</a> master are shown on the transitions.</p>

<p>Now let’s see if we can pack these operations together so that we can
do a read with 100% return path utilization.  What might that look like?</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 7. Two burst reads, back to back</caption><tr><td><a href="/img/demofull/demofull-rd-double.svg"><img src="/img/demofull/demofull-rd-double.svg" alt="" width="480" /></a></td></tr></table>

<p>It would look like two of these read bursts jammed together until their
various data beats are just touching with no overlaps, just like Fig. 7
on the left.</p>

<p>From an <a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>
point of view, 100% throughput requires a couple of changes.
First, we’ll need to be able to loop from the end state back to the end
state any time we receive a request where <code class="language-plaintext highlighter-rouge">ARLEN==0</code>, and <code class="language-plaintext highlighter-rouge">RREADY</code> is set.</p>

<p>This risks the problem of what to do if the <code class="language-plaintext highlighter-rouge">RREADY</code> input from the master
isn’t set, since we can’t change our <code class="language-plaintext highlighter-rouge">ARREADY</code> signal <em>after</em> we notice
<code class="language-plaintext highlighter-rouge">RREADY</code> is low without making an output, <code class="language-plaintext highlighter-rouge">ARREADY</code> combinatorially dependent
upon an input, <code class="language-plaintext highlighter-rouge">RREADY</code>.  In order to solve this problem, we’ll create a holding
state where <code class="language-plaintext highlighter-rouge">RVALID</code> is high but <code class="language-plaintext highlighter-rouge">ARREADY</code> is low in order to deal with
this possibility.  Other than this new <code class="language-plaintext highlighter-rouge">Hold</code> state, our updated
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>
diagram in Fig. 8 is (roughly) the same as Fig. 6 above.</p>

<table align="center" style="float: none"><caption>Fig 8. The Read Finite State Machine</caption><tr><td><a href="/img/demofull/demofull-rd-fsm.svg"><img src="/img/demofull/demofull-rd-fsm.svg" alt="" width="420" /></a></td></tr></table>

<p>We’ll know we’ve been successful if we can get our design to pass a cover
check describing this transaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">cover</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="kt">disable</span> <span class="k">iff</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="c1">// Accept a burst request for 4 beats</span>
		<span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARREADY</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">S_AXI_ARLEN</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="c1">// The first three beats</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RREADY</span> <span class="p">[</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span>
		<span class="c1">// The last read beat, where we accept the next request</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARREADY</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">S_AXI_ARLEN</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RLAST</span>
		<span class="c1">// The next three beats of data, and</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RREADY</span> <span class="p">[</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span>
		<span class="c1">// The final beat of the transaction</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RLAST</span>
		<span class="c1">// The return to idle</span>
		<span class="p">##</span><span class="mi">1</span> <span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_ARVALID</span><span class="p">);</span></code></pre></figure>

<p>For those not familiar with the <a href="http://www.asic-world.com/systemverilog/assertions4.html">SystemVerilog Assertion (SVA)
notation</a>, this
states that we want to find some way to make the given sequence pass–to
<code class="language-plaintext highlighter-rouge">cover()</code> it as it’s called.  The <code class="language-plaintext highlighter-rouge">disable iff (!S_AXI_ARESETN)</code> on the
second line means that if, at any time during
the following sequence, <code class="language-plaintext highlighter-rouge">S_AXI_ARESETN</code> becomes active (low), then the sequence
is disabled and any result doesn’t count.  Following the <code class="language-plaintext highlighter-rouge">disable iff</code> you
have a series of expressions, looking like <code class="language-plaintext highlighter-rouge">A ##1 B ##1 C</code> etc.
This means that we want to see a clock cycle when <code class="language-plaintext highlighter-rouge">A</code> is true, followed by
one when <code class="language-plaintext highlighter-rouge">B</code> is true, followed by one where <code class="language-plaintext highlighter-rouge">C</code> is true.  But what about that
strange <code class="language-plaintext highlighter-rouge">[*3]</code>, as in <code class="language-plaintext highlighter-rouge">A ##1 B [*3] ##1 C</code>?  That refers to a repetition of <code class="language-plaintext highlighter-rouge">B</code>.
In this case, <code class="language-plaintext highlighter-rouge">B</code> gets repeated <code class="language-plaintext highlighter-rouge">3</code> times before <code class="language-plaintext highlighter-rouge">C</code> becomes true on the next
clock.  So we’re asking the tool to find a time when <code class="language-plaintext highlighter-rouge">A</code> is true, then <code class="language-plaintext highlighter-rouge">B</code> is
true starting on the next cycle but for three separate clocks, and finally <code class="language-plaintext highlighter-rouge">C</code>
is true.</p>

<p>That should very much match our diagram in Fig. 7 above.  Hence, when we can
make this cover statement true, while still matching all of the
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
required by the bus, then we’ll know we can run at high speed.</p>

<p>Even better, we can trace these steps through the states and transitions in our
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>
diagram, shown in Fig. 8 above.  Did you notice that the cover
statement didn’t check that the design could properly enter (and leave)
every state?  Indeed, this cover statement is now starting to appear
inadequate.  A better cover statement should check every state and transition.</p>

<p>We may have to come back to that later.</p>

<p>We could also trust the <a href="/formal/2018/12/28/axilite.html">formal property
checker</a>
to check all of these paths instead.</p>

<p>For now, let’s turn our attention to the write channel.  A basic
<a href="/doc/axi-spec.pdf">AXI</a>
write transaction looks like Fig. 9 on the right.</p>

<table align="center" style="float: right"><caption>Fig 9. A basic write transaction</caption><tr><td><a href="/img/demofull/demofull-wr-basic.svg"><img src="/img/demofull/demofull-wr-basic.svg" alt="" width="480" /></a></td></tr></table>

<p>There are four important sections of logic in this figure.  First, when the
design is idle we’ll want <code class="language-plaintext highlighter-rouge">AWREADY</code> to be high.  That way we won’t need to wait
an extra cycle after <code class="language-plaintext highlighter-rouge">AWVALID</code> goes high before <code class="language-plaintext highlighter-rouge">AWREADY &amp; AWVALID</code> are high
together like <a href="/formal/2019/05/13/axifull.html">Xilinx’s design
did</a>.  Second, there’s the
write address transaction, where <code class="language-plaintext highlighter-rouge">AWVALID &amp; AWREADY</code>.  Third, there’s a series
of “beats” where <code class="language-plaintext highlighter-rouge">WVALID</code> is true and valid data are sent across the channel.
Finally, <code class="language-plaintext highlighter-rouge">BVALID</code> is set to true on the clock cycle after
<code class="language-plaintext highlighter-rouge">WVALID &amp; WREADY &amp; WLAST</code>.</p>

<p>You may notice from Fig. 9 that I’ve kept the <code class="language-plaintext highlighter-rouge">WREADY</code> line low until after
<code class="language-plaintext highlighter-rouge">AWVALID &amp; AWREADY</code>.  That just simplified the design below.  If I need to
press for lower latency later, I may need to come back and adjust this later.</p>

<p>If you were to place these states into an initial
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>,
you might get something looking like Fig. 10 below.</p>

<table align="center" style="float: none"><caption>Fig 10. Initial Write FSM</caption><tr><td><a href="/img/demofull/demofull-wr-fsm-initial.svg"><img src="/img/demofull/demofull-wr-fsm-initial.svg" alt="" width="540" /></a></td></tr></table>

<p>In this figure, you can see all of the four stages of the transaction we just
discussed above.  Sadly, however, this
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>,
diagram is far from complete.</p>

<p>Let’s work through some of the problems.  First, my entire goal was
throughput.  Fig. 9 illustrates a transaction that takes <code class="language-plaintext highlighter-rouge">N+2</code> clock periods,
and our state machine in Fig. 10 doesn’t allow back to back transactions.  So
let’s start adding some more states and transitions.</p>

<ol>
  <li>In order to avoid stalls, we’ll need to make sure to raise <code class="language-plaintext highlighter-rouge">AWREADY</code> on the
same clock that <code class="language-plaintext highlighter-rouge">WVALID &amp; WLAST</code> is true.  Worse, in order to register
everything, we’ll need to set <code class="language-plaintext highlighter-rouge">AWREADY</code> on the clock before
<code class="language-plaintext highlighter-rouge">WVALID &amp; WLAST</code> are true.</li>
</ol>

<table align="center" style="float: left; padding: 15px"><caption>Fig 11. Registered to Combinatorial Skid buffer</caption><tr><td><a href="/img/skidbuffer/skidbuffer-blockdiag.svg"><img src="/img/skidbuffer/skidbuffer-blockdiag.svg" alt="" width="360" /></a></td></tr></table>

<p>What should we do, though, if <code class="language-plaintext highlighter-rouge">AWREADY &amp; WREADY &amp; !WVALID</code>?</p>

<p>To solve this problem, I chose to use a <a href="/blog/2019/05/22/skidbuffer.html">skid
   buffer</a>.  The
   <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
   shown in Fig. 11 on the left,
   will take a registered interface and produce a combinatorial interface.</p>

<ol start="2">
  <li>
    <p>That still leaves us with the condition where we’ll need to transition
from <code class="language-plaintext highlighter-rouge">AWVALID &amp; WVALID &amp; WLAST</code> to <code class="language-plaintext highlighter-rouge">WVALID &amp; WREADY &amp; BVALID</code> (and possibly
<code class="language-plaintext highlighter-rouge">WLAST</code>).  This will require two more states, one for
<code class="language-plaintext highlighter-rouge">WREADY &amp; BVALID</code> and another for <code class="language-plaintext highlighter-rouge">WREADY &amp; WLAST &amp; BVALID</code>.</p>

    <p>This last state, however, gives us another problem.  What happens when
<code class="language-plaintext highlighter-rouge">WVALID &amp; !BREADY</code>?  In that case, we’ll need to store our new response
in a skid buffer, drop <code class="language-plaintext highlighter-rouge">AWREADY</code>, and wait for <code class="language-plaintext highlighter-rouge">BREADY</code>.</p>
  </li>
</ol>

<p>I then tried to diagram out this state machine for you, to help you understand
all the various parts and pieces of such a transaction.  What I came up with
was Fig. 12 below.</p>

<table align="center" style="float: none"><caption>Fig 12. Full write FSM diagram</caption><tr><td><a href="/img/demofull/demofull-wr-fsm.svg"><img src="/img/demofull/demofull-wr-fsm.svg" alt="" width="480" /></a></td></tr></table>

<p>Sadly, it’s not very understandable, much less complete.  Even worse,
this state diagram wasn’t helping me.  Instead, I gave up in frustration.
There are just too many states and transitions to make this understandable,
much less correct.</p>

<p>It’s certainly not simple enough to understand from examination.</p>

<p>So, let me let you in on a secret: I didn’t use a state diagram to build <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this
core</a>.</p>

<p>What??  Why not?</p>

<p>Because, in my mind, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this
core</a> was never
an <a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>.  It didn’t
have the typical <a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>
structure.  In my mind, it was always a series of <a href="/blog/2017/08/14/strategies-for-pipelining.html">pipeline
stages</a>,
together with the logic necessary to handle the transitions from one stage
to the next.  As I designed <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this
core</a>,
I envisioned three write stages, separated by a clock, as shown in
Fig. 13 below.</p>

<table align="center" style="float: none"><caption>Fig 13. The three write stages</caption><tr><td><a href="/img/demofull/demofull-wr-pipeline.svg"><img src="/img/demofull/demofull-wr-pipeline.svg" alt="" width="720" /></a></td></tr></table>

<p>The first stage was the <code class="language-plaintext highlighter-rouge">AW*</code> stage where the <code class="language-plaintext highlighter-rouge">AW*</code> signals would (or wouldn’t)
be valid.  In Fig. 13, you can see how this stage will either take a clock
cycle or not, as provided by the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.
The second stage was the
<code class="language-plaintext highlighter-rouge">WREADY</code> stage, ending in the <code class="language-plaintext highlighter-rouge">r_bvalid</code> internal
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.
Timing was driven by this write-data stage, and no more than one request was
ever allowed to be within it.  Once <code class="language-plaintext highlighter-rouge">WVALID &amp; WLAST</code> were true, the response
would either go into the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
called <code class="language-plaintext highlighter-rouge">r_bvalid</code> in Fig. 13, or directly to the <code class="language-plaintext highlighter-rouge">BVALID</code> output stage.
Further, a request could always be accepted any time:</p>

<ol>
  <li>
    <p>If both <code class="language-plaintext highlighter-rouge">WREADY</code> and <code class="language-plaintext highlighter-rouge">r_bvalid</code> stages were empty, a request could always
be accepted.</p>
  </li>
  <li>
    <p>Otherwise, accepting a request required several other conditions to be
true together:</p>

    <p>a. Either <code class="language-plaintext highlighter-rouge">BVALID</code> was false, or <code class="language-plaintext highlighter-rouge">BREADY</code> was true, indicating that nothing
   was blocking at the final stage, and …</p>

    <p>b. If something was in the <code class="language-plaintext highlighter-rouge">S_AXI_WREADY</code> stage, versus in the <code class="language-plaintext highlighter-rouge">r_bvalid</code>
   <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
   then <code class="language-plaintext highlighter-rouge">WVALID &amp;&amp; WLAST</code> must both be before accepting a new request.</p>

    <p>Note that, in this design, <code class="language-plaintext highlighter-rouge">r_bvalid</code> will never be true unless
<code class="language-plaintext highlighter-rouge">BVALID</code> is also true.  This is a common
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
property, but we can still use a <a href="/blog/2017/10/19/formal-intro.html">formal
assertion</a>
if we aren’t confident this will be true.</p>
  </li>
</ol>

<p>So, instead of using the
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>
in Fig. 12 that left me more confused, I chose
to focus instead on a signal trace diagram to understand what needed to be
done.  My goal, as you recall, was to pack all of these parts and pieces
of a write transaction together as tightly as possible, so that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this core</a>
could
support <code class="language-plaintext highlighter-rouge">WVALID</code> being true without interruption across multiple bursts.  The
result should look something like Fig. 14 on the left.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 14. Two burst write transactions, back to back</caption><tr><td><a href="/img/demofull/demofull-wr-double.svg"><img src="/img/demofull/demofull-wr-double.svg" alt="" width="540" /></a></td></tr></table>

<p>Building <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this
design</a>
required two tricks.  The first we’ve already discussed,
and that’s the two <a href="/blog/2019/05/22/skidbuffer.html">skid
buffers</a>–both on the
<code class="language-plaintext highlighter-rouge">AW*</code> request side and again on the <code class="language-plaintext highlighter-rouge">BVALID</code> side.</p>

<p>The second trick, which has already separated our approach today from many
other approaches to building an <a href="/doc/axi-spec.pdf">AXI</a>
slave, is that we’ve chosen to use the various output signals in place of
any separate <a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>
state.  This will keep us from making the <a href="/formal/2019/05/13/axifull.html">same mistakes Xilinx
made</a>, when their logic
checked for <code class="language-plaintext highlighter-rouge">AxVALID &amp; AxREADY &amp; something_else</code>.</p>

<p>Above all else, we’re going to lean very heavily on the
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
<a href="/doc/axi-spec.pdf">AXI</a>
properties to convince ourselves that this works.</p>

<h2 id="the-skid-buffers">The Skid Buffers</h2>

<p>The key to high throughput when using the
<a href="/doc/axi-spec.pdf">AXI bus</a>
is really the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffers</a>.
If you are going to do anything with
<a href="/doc/axi-spec.pdf">AXI</a>,
whether the full
<a href="/doc/axi-spec.pdf">AXI</a> standard,
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite</a>,
or even <a href="/doc/axi-stream.pdf">AXI stream</a>, you <em>need</em> to
understand <a href="/blog/2019/05/22/skidbuffer.html">skid buffers</a>.</p>

<p>Why are
<a href="/blog/2019/05/22/skidbuffer.html">skid buffers</a>
so important?  Because unlike
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>,
<a href="/doc/axi-spec.pdf">AXI</a> output signals must not depend upon
any combinatorial paths from the inputs according to the
<a href="/doc/axi-spec.pdf">specification</a>.  This is great for
maintaining high speed signaling when using high fanout signals, but it
becomes a challenge for the designer and they can be an ugly challenge
as well for the engineer who wants to verify his design with
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<p>I’ve now discussed
<a href="/blog/2019/05/22/skidbuffer.html">skid buffers</a>
on <a href="https://zipcpu.com/">this blog</a>
several times.  First, under the name of
<a href="/blog/2017/08/14/strategies-for-pipelining.html">“double buffers” when discussing pipeline
strategies</a>,
and then again when we discussed <a href="/blog/2019/01/12/demoaxilite.html">building a functioning AXI-lite
slave</a>.
More recently, I devoted <a href="/blog/2019/05/22/skidbuffer.html">a whole article to the
topic</a>.
<a href="http://fpgacpu.ca">Eric LaForest</a> also has posted a <a href="http://fpgacpu.ca/fpga/skid_buffer.html">wonderful article
describing them under the name
“skid buffers”</a>.</p>

<p>For these reasons, I won’t discuss
<a href="/blog/2019/05/22/skidbuffer.html">skid buffers</a>
further here, but I will encourage you to go back and examine one or more of
these articles before reading further.</p>

<h2 id="the-write-channel">The write channel</h2>

<p>Are you ready to dive into the code?</p>

<p>The first thing I do when building something to process
<a href="/doc/axi-spec.pdf">AXI</a>
signals is to rename the parameters
<a href="https://www.xilinx.com">Xilinx</a> provides.  This isn’t because I dislike their
naming convention, on the contrary, I like it: with the exception of the <code class="language-plaintext highlighter-rouge">_S_</code>
their convention is quite descriptive.  I understand therefore that
<code class="language-plaintext highlighter-rouge">C_S_AXI_ADDR_WIDTH</code> is the number of address bits associated with the
<a href="/doc/axi-spec.pdf">AXI</a>
<em>slave</em> port to my design.  It’s just that using this long identifier means
that either I need to extend the width of my text editor and thus lose the
monitor size gains of the last decade, or I need to abbreviate these values.</p>

<p>Here are my chosen abbreviations: <code class="language-plaintext highlighter-rouge">AW</code> for address width, <code class="language-plaintext highlighter-rouge">DW</code> for data width,
and <code class="language-plaintext highlighter-rouge">IW</code> for transaction ID width.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">AW</span> <span class="o">=</span> <span class="n">C_S_AXI_ADDR_WIDTH</span><span class="p">;</span>
	<span class="k">localparam</span>	<span class="n">DW</span> <span class="o">=</span> <span class="n">C_S_AXI_DATA_WIDTH</span><span class="p">;</span>
	<span class="k">localparam</span>	<span class="n">IW</span> <span class="o">=</span> <span class="n">C_S_AXI_ID_WIDTH</span><span class="p">;</span>
	<span class="k">localparam</span>	<span class="n">LSB</span> <span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">C_S_AXI_DATA_WIDTH</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">;</span></code></pre></figure>

<p>These shorthand parameters are defined as <code class="language-plaintext highlighter-rouge">localparam</code>s, so Vivado
should still be able to recognize this file.</p>

<p>Further, you may remember that
<a href="/blog/2019/04/27/axi-addr.html">AXI addresses</a>
are not like
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a> addresses.  In
<a href="/doc/axi-spec.pdf">AXI</a>,
the address doesn’t reference a <em>word</em> of memory, but rather an <a href="https://en.wikipedia.org/wiki/Octet_(computing)">octet
of memory</a>.  This means
that there will almost always be some number of low order address bits that
aren’t really necessary to any word-level transaction.  This is the purpose
of the <code class="language-plaintext highlighter-rouge">LSB</code> short-hand above.  When we send our address
to our downstream non-AXI port, we’ll only send the <code class="language-plaintext highlighter-rouge">[AW-1:LSB]</code> bits to
simplify the processing there.  Sub-word handling by the external slave
will be done using the <code class="language-plaintext highlighter-rouge">o_wstrb</code> signals.</p>

<p>The next step is to handle the incoming write address
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.
I’m going to use the <code class="language-plaintext highlighter-rouge">m_aw</code> prefix to reference the values coming out of
and going into this <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a>.  The <code class="language-plaintext highlighter-rouge">S_AXI_AW*</code>
signals going into the <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a> will maintain
their names, and denote a separate stage of processing.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">////////////////////////////////////////////////////////////////////////</span>
	<span class="c1">//</span>
	<span class="c1">// Skid buffer</span>
	<span class="c1">//</span>
	<span class="c1">// ...</span>
	<span class="c1">//</span>
	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">DW</span><span class="p">(</span><span class="n">AW</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">8</span><span class="o">+</span><span class="n">IW</span><span class="p">))</span>
		<span class="n">awbuf</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">,</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">,</span>
		<span class="n">S_AXI_AWVALID</span><span class="p">,</span> <span class="n">S_AXI_AWREADY</span><span class="p">,</span>
			<span class="o">{</span> <span class="n">S_AXI_AWADDR</span><span class="p">,</span> <span class="n">S_AXI_AWBURST</span><span class="p">,</span> <span class="n">S_AXI_AWSIZE</span><span class="p">,</span>
					<span class="n">S_AXI_AWLEN</span><span class="p">,</span> <span class="n">S_AXI_AWID</span> <span class="o">}</span><span class="p">,</span>
		<span class="n">m_awvalid</span><span class="p">,</span> <span class="n">m_awready</span><span class="p">,</span>
			<span class="o">{</span> <span class="n">m_awaddr</span><span class="p">,</span> <span class="n">m_awburst</span><span class="p">,</span> <span class="n">m_awsize</span><span class="p">,</span> <span class="n">m_awlen</span><span class="p">,</span> <span class="n">m_awid</span> <span class="o">}</span><span class="p">);</span></code></pre></figure>

<p>These <code class="language-plaintext highlighter-rouge">m_aw*</code> signals are the equivalent of their <code class="language-plaintext highlighter-rouge">S_AXI_AW*</code> counterparts,
with the exception being that <code class="language-plaintext highlighter-rouge">m_awready</code> is combinatorially determined.
Similarly, there’s combinatorial logic within the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
to generate the other <code class="language-plaintext highlighter-rouge">m_aw*</code> signals.  That way this
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
won’t cost us any clock delays.</p>

<p>The next piece of logic is, in many ways, the key to understanding the write
logic.  This is where we’ll control the ready lines for both the write address
and the write data channel.</p>

<p>As mentioned above, we’ll idle with <code class="language-plaintext highlighter-rouge">AWREADY</code> high and <code class="language-plaintext highlighter-rouge">WREADY</code> low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_awready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">axi_wready</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">axi_awready</span>  <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">axi_wready</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Following Xilinx’s convention, I’m using the <code class="language-plaintext highlighter-rouge">axi_*</code> as a prefix to
describe registered values that will then drive the outgoing <code class="language-plaintext highlighter-rouge">S_AXI_*</code>
signals.  The exception to this rule is <code class="language-plaintext highlighter-rouge">axi_awready</code>.</p>

<p><code class="language-plaintext highlighter-rouge">axi_awready</code> will be the <em>registered</em> component of the ready signal,
<code class="language-plaintext highlighter-rouge">m_awready</code>, going into the combinatorial side of the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
above.  Therefore, imagine, as you go through this, that we are setting
<code class="language-plaintext highlighter-rouge">m_awready</code> anytime we set <code class="language-plaintext highlighter-rouge">axi_awready</code>, but remember that we may also
override this registered value to set <code class="language-plaintext highlighter-rouge">m_awready</code> high when accepting
subsequent packed bursts across the channel.</p>

<p>From there, the basic starting logic is simple: once <code class="language-plaintext highlighter-rouge">m_awvalid</code> and <code class="language-plaintext highlighter-rouge">m_awready</code>
are true, move to the write data stage of our burst processor.  That means
we’ll drop <code class="language-plaintext highlighter-rouge">axi_awready</code> until the the packet clears the <code class="language-plaintext highlighter-rouge">S_AXI_WREADY</code> stage.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_awvalid</span> <span class="o">&amp;&amp;</span> <span class="n">m_awready</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">axi_wready</span>  <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Do you remember the <a href="/formal/2019/04/16/axi-mistakes.html">post about the most common AXI
mistake</a>?
It’s a <a href="/formal/2019/04/16/axi-mistakes.html">common mistake</a>
to check for anything other than <code class="language-plaintext highlighter-rouge">*valid</code> and <code class="language-plaintext highlighter-rouge">*ready</code> at the step above.
Were we to do that, we might miss and therefore drop an incoming request.</p>

<p>Next, <code class="language-plaintext highlighter-rouge">axi_awready</code> is set so we can accept another packet if this is the
last data value in the burst and if there’s an open position in our outgoing
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.
We don’t need to check for two positions, just one.  However,
<code class="language-plaintext highlighter-rouge">WVALID &amp; WREADY &amp; WLAST</code> will consume one of the two positions.
Similarly, we’ll drop <code class="language-plaintext highlighter-rouge">axi_wready</code> and leave this processing stage once we
the last data value is accepted.</p>

<p>This gets a bit more interesting, though, in the next step.  The <code class="language-plaintext highlighter-rouge">if</code> below
only looks like it is checking for <code class="language-plaintext highlighter-rouge">S_AXI_WVALID &amp; S_AXI_WREADY</code>.  Remember,
this is the second <code class="language-plaintext highlighter-rouge">if</code> in a cascaded <code class="language-plaintext highlighter-rouge">if</code> block.  Therefore, we are now
checking <code class="language-plaintext highlighter-rouge">S_AXI_WVALID &amp;&amp; S_AXI_WREADY</code> <em>and</em>
<code class="language-plaintext highlighter-rouge">!m_awvalid || !m_awready</code>.  How is this not violating <a href="/formal/2019/04/16/axi-mistakes.html">the basic rule of AXI
handshaking</a>?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">S_AXI_WLAST</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">);</span>
		<span class="n">axi_wready</span>  <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_WLAST</span><span class="p">);</span></code></pre></figure>

<p>Originally, when I wrote this code, it didn’t violate the rule because I
guaranteed that <code class="language-plaintext highlighter-rouge">S_AXI_AWREADY</code> would be false during the data stage of this
transaction.  That was arranged by the code above.  This worked well, but it
cost me a clock of throughput on every burst.</p>

<p>Now, and we’ll get to this in a moment, there’s the possibility that
<code class="language-plaintext highlighter-rouge">m_awready</code> might be true when <code class="language-plaintext highlighter-rouge">S_AXI_WVALID &amp;&amp; S_AXI_WREADY</code>.  In particular,
it may be true when <code class="language-plaintext highlighter-rouge">WVALID &amp; WREADY &amp; WLAST</code>, and so we’d be ready at that
time to accept another burst.  Hence, I’m not violating the rule, rather
I’m combining two possibilities in the first part of this cascaded if.</p>

<p>We can now move on to the rest of this key logic block.  At this point, though,
most of the critical work has been done.  All that’s left is to make
cerain that <code class="language-plaintext highlighter-rouge">axi_awready</code>, once lowered to deal with the write data, is
properly raised again once done.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">axi_awready</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">)</span>
			<span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_bvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_BREADY</span><span class="p">)</span>
			<span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Specifically, we’ll want to keep <code class="language-plaintext highlighter-rouge">axi_awready</code> clear as long as we are in the
write data stage (the <code class="language-plaintext highlighter-rouge">S_AXI_WREADY</code> stage) of our processing or if the
outgoing <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
is full, i.e. <code class="language-plaintext highlighter-rouge">r_bvalid</code> is true.  <code class="language-plaintext highlighter-rouge">r_bvalid</code> will only be true, however, if
then the outgoing <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a> is stalled.
Remember, if the outgoing
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
is full, that is if the internal buffer within it has valid data within it,
then the <code class="language-plaintext highlighter-rouge">S_AXI_BVALID</code> signal at the output must also be true, so we
don’t need to check for it here.</p>

<p>In all other cases, we’ll clear the stall condition so we can accept another
write address request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span>
			<span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>We’ll also need to copy and cache the values we’ll need to calculate
subsequent <a href="/blog/2019/04/27/axi-addr.html">write
addresses</a> within
the burst: the burst type, virtual bus width, <code class="language-plaintext highlighter-rouge">wsize</code>, and the burst length.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_awready</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">waddr</span>    <span class="o">&lt;=</span> <span class="n">m_awaddr</span><span class="p">;</span>
		<span class="n">wburst</span>   <span class="o">&lt;=</span> <span class="n">m_awburst</span><span class="p">;</span>
		<span class="n">wsize</span>    <span class="o">&lt;=</span> <span class="n">m_awsize</span><span class="p">;</span>
		<span class="n">wlen</span>     <span class="o">&lt;=</span> <span class="n">m_awlen</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WVALID</span><span class="p">)</span>
		<span class="n">waddr</span> <span class="o">&lt;=</span> <span class="n">next_wr_addr</span><span class="p">;</span></code></pre></figure>

<p>In this logic, <code class="language-plaintext highlighter-rouge">next_wr_addr</code> is created  by applying our
<a href="/blog/2019/04/27/axi-addr.html">AXI address logic to the current write address
to get the next address</a>.</p>

<p>The <a href="/blog/2019/04/27/axi-addr.html">write address
calculation</a>
itself now becomes really simple, given the <code class="language-plaintext highlighter-rouge">axi_addr</code>
module <a href="/blog/2019/04/27/axi-addr.html">we built earlier</a>.
On <code class="language-plaintext highlighter-rouge">m_awvalid &amp; m_awready</code>, we set <code class="language-plaintext highlighter-rouge">waddr</code> according to the incoming address.
Then, on every accepted write value, it gets set to <code class="language-plaintext highlighter-rouge">next_wr_addr</code> above.</p>

<p>All that’s left is to call <code class="language-plaintext highlighter-rouge">axi_addr</code> to get that next write address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">axi_addr</span> <span class="p">#(.</span><span class="n">AW</span><span class="p">(</span><span class="n">AW</span><span class="p">),</span> <span class="p">.</span><span class="n">DW</span><span class="p">(</span><span class="n">DW</span><span class="p">))</span>
		<span class="n">get_next_wr_addr</span><span class="p">(</span><span class="n">waddr</span><span class="p">,</span> <span class="n">wsize</span><span class="p">,</span> <span class="n">wburst</span><span class="p">,</span> <span class="n">wlen</span><span class="p">,</span>
			<span class="n">next_wr_addr</span><span class="p">);</span></code></pre></figure>

<p>Before we move on to the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
for the return channel, let’s not forget to write this
<a href="/doc/axi-spec.pdf">AXI</a> data to our external slave interface.
The neat thing about this is that, by this point in our processing, 
this last bit is easy.  We can just set these outputs to the
<a href="/doc/axi-spec.pdf">AXI</a> inputs and our registered address,
<code class="language-plaintext highlighter-rouge">waddr</code>, and use one little piece of combinatorial logic, <code class="language-plaintext highlighter-rouge">WVALID &amp; WREADY</code>,
to indicate that it is time to write.</p>

<p>This should give our external AXI-unaware slave component plenty of slack to
actually process this request.  Indeed, by this point, we’ve removed all of the
<a href="/doc/axi-spec.pdf">AXI</a>
complexity from what this external core needs to process.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_we</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WREADY</span><span class="p">);</span>
		<span class="n">o_waddr</span> <span class="o">=</span> <span class="n">waddr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">LSB</span><span class="p">];</span>
		<span class="n">o_wdata</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">;</span>
		<span class="n">o_wstrb</span> <span class="o">=</span> <span class="n">S_AXI_WSTRB</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>It’s now time to start looking at the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
for the return response.</p>

<p>Unlike the earlier
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
I share the <code class="language-plaintext highlighter-rouge">r_bid</code> signal with the <code class="language-plaintext highlighter-rouge">S_AXI_WREADY</code> stage, which forces this
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
to have a bit of a different structure–enough so that I’ve written this
write return <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
into the module’s logic rather than referencing a submodule.</p>

<p>The critical part of this
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
is the valid signal, indicating whether or not something is within it.
In this case, we’re calling this signal <code class="language-plaintext highlighter-rouge">r_bvalid</code>.
As might be expected, <code class="language-plaintext highlighter-rouge">r_bvalid</code> is cleared on any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_bvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">r_bvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">r_bvalid</code> is set, however, if two conditions are true, as shown in
Fig. 13 above.  To follow, consider that any time
<code class="language-plaintext highlighter-rouge">WVALID &amp; WREADY &amp; WLAST</code> we want to set the outgoing <code class="language-plaintext highlighter-rouge">BVALID</code>.  The only time
when we cannot set <code class="language-plaintext highlighter-rouge">BVALID</code> is if <code class="language-plaintext highlighter-rouge">BVALID</code> is already set, but <code class="language-plaintext highlighter-rouge">BREADY</code> is
clear (indicating a stall condition).  In that case, we still need to note
that we are ready for a second response somewhere else–i.e. in the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.  Hence, the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
is only activated any time a value would be placed into the outgoing
position, but when the outgoing position is already full and stalled..</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WREADY</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WLAST</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_BREADY</span><span class="p">))</span>
		<span class="n">r_bvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Once the stall is clear, the contents of the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.
will always move forward to the outgoing position, so we can then clear the
internal valid line, <code class="language-plaintext highlighter-rouge">r_bvalid</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">)</span>
		<span class="n">r_bvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>I broke the basic mold of the <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a>
with the transaction ID.  We need to record the transaction ID anytime
<code class="language-plaintext highlighter-rouge">m_awvalid &amp; m_awready</code> are both true.  Since we are guaranteeing that there
will always be a place for any accepted write transaction in either the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a> at the end
or the return response position, we can then just copy the ID from <code class="language-plaintext highlighter-rouge">m_awid</code>
to the <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>’s
data store.  If the <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a>
isn’t valid yet, its data is at least still allocated as part of our scheme
to keep from needing to drop <code class="language-plaintext highlighter-rouge">WREADY</code> mid-transaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_awready</span><span class="p">)</span>
			<span class="n">r_bid</span>    <span class="o">&lt;=</span> <span class="n">m_awid</span><span class="p">;</span></code></pre></figure>

<p>We can even simplify this somewhat by only checking <code class="language-plaintext highlighter-rouge">m_awready</code> instead of both
<code class="language-plaintext highlighter-rouge">m_awready</code> and <code class="language-plaintext highlighter-rouge">m_awvalid</code>.</p>

<p>Next, anytime the return transaction position is idle we can forward this
transaction identifier to our return register, <code class="language-plaintext highlighter-rouge">axi_bid</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">)</span>
			<span class="n">axi_bid</span> <span class="o">&lt;=</span> <span class="n">r_bid</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>This is one of those cases where the logic cannot be simplified further.
(I know, I tried.)  What we want is to forward to the outgoing response
position any time <code class="language-plaintext highlighter-rouge">!(S_AXI_BVALID &amp;&amp; !S_AXI_BREADY)</code>.  If we only check for
<code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code>, however, the bus master isn’t required to keep this ready
while waiting for a response.  We might find that <code class="language-plaintext highlighter-rouge">BID</code> then never gets set
properly.</p>

<p>You may also note that this handling of the <code class="language-plaintext highlighter-rouge">ID</code> requires a minimum of two
three clock periods.  On the first clock, <code class="language-plaintext highlighter-rouge">m_awvalid &amp; m_awready</code> will be
true qualifying <code class="language-plaintext highlighter-rouge">m_awid</code>.  On the second clock period, <code class="language-plaintext highlighter-rouge">r_bid</code> will contain
the current transaction ID.  This is also the earliest
period where <code class="language-plaintext highlighter-rouge">WREADY</code> will be true for this transaction.  It may also be
the last period of the transaction, were <code class="language-plaintext highlighter-rouge">WVALID &amp; WLAST</code> to be true as well.
Then, on the third clock period, <code class="language-plaintext highlighter-rouge">axi_bid</code> would contain the correct
write burst identifier.</p>

<p>Now that we have the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
in please, we can discuss the return <code class="language-plaintext highlighter-rouge">BVALID</code> signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_bvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_bvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>We’ll want to set this signal true any time <code class="language-plaintext highlighter-rouge">WVALID &amp; WREADY &amp; WLAST</code>.
If <code class="language-plaintext highlighter-rouge">BVALID</code> were already true, then setting it again–even if the
channel were stalled–won’t hurt.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WREADY</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WLAST</span><span class="p">)</span>
		<span class="n">axi_bvalid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Otherwise, any time <code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code> is true, we can move the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
valid signal, <code class="language-plaintext highlighter-rouge">r_bvalid</code>, into the output position.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">)</span>
		<span class="n">axi_bvalid</span> <span class="o">&lt;=</span> <span class="n">r_bvalid</span><span class="p">;</span></code></pre></figure>

<p>That leaves one big piece of write logic we haven’t yet addressed, <code class="language-plaintext highlighter-rouge">m_awready</code>.
As I mentioned above, this piece of logic is built combinatorially off of
the <code class="language-plaintext highlighter-rouge">axi_awready</code> register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">m_awready</span> <span class="o">=</span> <span class="n">axi_awready</span><span class="p">;</span></code></pre></figure>

<p>The one piece of combinatorial logic is required in order to be able to
accept a new write address on the last clock cycle of the write data–especially
because we can only do so if there is, or is about to be, an open position
in the outgoing
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.</p>

<p>First, we know that if <code class="language-plaintext highlighter-rouge">WREADY</code> is true, then there’s at least one position
in the <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>–the
one for the write data once it completes.  That was
one of the design rules we’ve chosen–one I tried to illustrate in Fig. 13
above.</p>

<p>We’ll now need to make certain, if we set the ready line for the write address
channel, that a second output position is also available.  Since our outgoing
buffer only holds only one position and that’s already taken,
the final outgoing <code class="language-plaintext highlighter-rouge">BVALID</code> position must be clear or clearing in order to
accept a new transaction.  Hence, we’ll need to check that the
current write transaction can fit in the <code class="language-plaintext highlighter-rouge">S_AXI_BVALID</code> output stage on the
next cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WREADY</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WLAST</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">))</span>
			<span class="n">m_awready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>All that’s left of the write channel side is to clean up.  Specifically,
following Xilinx’s convention, we’ve set register values <code class="language-plaintext highlighter-rouge">axi_*</code> but the
actual I/O values are named <code class="language-plaintext highlighter-rouge">S_AXI_*</code>.  We’ll need to copy our values to
the actual I/O ones.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">S_AXI_WREADY</span>  <span class="o">=</span> <span class="n">axi_wready</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">S_AXI_BVALID</span>  <span class="o">=</span> <span class="n">axi_bvalid</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">S_AXI_BID</span>     <span class="o">=</span> <span class="n">axi_bid</span><span class="p">;</span></code></pre></figure>

<p>We also need to set the <code class="language-plaintext highlighter-rouge">BRESP</code> return code.</p>

<p><a href="/doc/axi-spec.pdf">AXI</a>
offers four return code possibilities: OKAY, EXOKAY, SLVERR, and DECERR.
Since this simple slave doesn’t produce any errors, neither SLVERR nor DECERR
make sense to return.  EXOKAY is only allowed if this slave supports exclusive
access, which we don’t.</p>

<p>The <a href="/doc/axi-spec.pdf">AXI</a>
exclusive access protocol is rather complex.  It involves a first
request to read a value with <code class="language-plaintext highlighter-rouge">ARLOCK</code> set.  If the slave responds with <code class="language-plaintext highlighter-rouge">EXOKAY</code>,
the slave then needs to record the
<a href="/blog/2019/04/27/axi-addr.html">address details</a>
of the transaction.  If
at some time later, the same register is written to with <code class="language-plaintext highlighter-rouge">AWLOCK</code> high and
no intervening writes, then the slave may return <code class="language-plaintext highlighter-rouge">EXOKAY</code> and adjust the
register.  If the slave returns <code class="language-plaintext highlighter-rouge">OKAY</code> instead, the register is not allowed to
be modified.</p>

<p>Since we aren’t supporting this exclusive access portion of the protocol,
we’ll set the <code class="language-plaintext highlighter-rouge">BRESP</code> to <code class="language-plaintext highlighter-rouge">2'b00</code> to indicate an <code class="language-plaintext highlighter-rouge">OKAY</code> response.  I may need
to come back and add exclusive access support later, but that will be as part
of a separate blog article.</p>

<p>Therefore, since this doesn’t produce any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>,
nor does it support exclusive access, 2’b00 will always be the correct
response.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">S_AXI_BRESP</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>That’s the write channel, and a high speed one at that!  Remember, we managed
to get 100% throughput (one write burst per clock) once fully loaded.  That’s
a bit of performance <a href="/formal/2019/05/13/axifull.html">Xilinx’s demo code never
achieved</a>.</p>

<p>If this is performance you want in your design, you can find <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this AXI slave
core here</a>.</p>

<h2 id="the-read-channel">The Read Channel</h2>

<p>Our basic approach to handling any read request will be to aggressively
read any time and as often as we can, pushing as much logic to the left
in this operation as we can.  That also means we’ll issue a slave read
request <em>on the same clock that <code class="language-plaintext highlighter-rouge">S_AXI_ARVALID</code> is true</em>.</p>

<p>We’ll start with <code class="language-plaintext highlighter-rouge">axi_arready</code>.  As with the write address ready, this one
also idles high.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">axi_arready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Then on any request, we’ll drop <code class="language-plaintext highlighter-rouge">ARREADY</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARREADY</span><span class="p">)</span>
		<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Well, not quite.  If we did that, then we would require a minimum of two
clocks for every one-burst read: One clock for <code class="language-plaintext highlighter-rouge">ARVALID &amp; ARREADY</code> and a second
where <code class="language-plaintext highlighter-rouge">!ARREADY</code>.  This would prevent us from being able to do back-to-back
reads for short bursts.</p>

<p>So let’s adjust this so that on any read address request, we drop <code class="language-plaintext highlighter-rouge">ARREADY</code>
if and only if <code class="language-plaintext highlighter-rouge">o_rd</code>, our outgoing sub-slave read signal, is also true.
This sub-slave read signal is a combinatorial signal that will only be true
if the outgoing read data channel isn’t stalled.  To support burst
transactions, we’ll need to only let <code class="language-plaintext highlighter-rouge">ARREADY</code> stay high if the burst
length is one, or equivalently if <code class="language-plaintext highlighter-rouge">ARLEN==0</code>.  Remember, in
<a href="/doc/axi-spec.pdf">AXI</a>,
the burst length is always one more than <code class="language-plaintext highlighter-rouge">AxLEN</code>, so we’ll go high
immediately on any single item burst request where <code class="language-plaintext highlighter-rouge">o_rd</code> is also high.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARREADY</span><span class="p">)</span>
		<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">S_AXI_ARLEN</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_rd</span><span class="p">);</span></code></pre></figure>

<p>Finally, any time the output channel is not stalled, we can check whether we
are about to place the last value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">axi_arready</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RVALID</span><span class="p">))</span>
			<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">axi_rlen</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>This really doesn’t make much sense without knowing what <code class="language-plaintext highlighter-rouge">axi_rlen</code> is.
<code class="language-plaintext highlighter-rouge">axi_rlen</code> is the name of a counter I’m using to store the number of items
currently remaining in this burst.  It is initially set to <code class="language-plaintext highlighter-rouge">AXI_ARLEN+1</code>.
Ever after, on any read, <code class="language-plaintext highlighter-rouge">axi_rlen</code> is decremented.  Once <code class="language-plaintext highlighter-rouge">axi_rlen</code> reaches
zero, the read is complete and <code class="language-plaintext highlighter-rouge">AXI_RVALID</code> should be low.</p>

<p>That’s why we can check for <code class="language-plaintext highlighter-rouge">axi_rlen == 2</code> above.  If <code class="language-plaintext highlighter-rouge">axi_rlen == 2</code>, then
on the next cycle, <code class="language-plaintext highlighter-rouge">axi_rlen</code> will be one and <code class="language-plaintext highlighter-rouge">RLAST</code> will then be set.  We
then need to be able to accept a new read request, as shown in Fig. 7 above,
or we won’t be able to continue our high speed transaction.</p>

<p>Here’s what the logic for <code class="language-plaintext highlighter-rouge">axi_rlen</code> looks like.  Because we are using this
to know our position in a read burst, it must idle at zero.  That way
<code class="language-plaintext highlighter-rouge">axi_rlen == 0</code> can also be used as an indication that we are no longer within
a burst.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_rlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_rlen</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>On any read request, we’ll set <code class="language-plaintext highlighter-rouge">axi_rlen</code> to the number of items remaining to
be returned, or <code class="language-plaintext highlighter-rouge">S_AXI_ARLEN+1</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARREADY</span><span class="p">)</span>
		<span class="n">axi_rlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">S_AXI_ARLEN</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>Well, that’s the basic idea.  That’s not quite it though.  The problem is
that, if there’s already an item stalled in the return channel path, then
we still need to return that item too.  We’ll
therefore merge that last value, the one that is waiting for <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code>,
into our “to-be-returned” <code class="language-plaintext highlighter-rouge">axi_rlen</code> counter.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARREADY</span><span class="p">)</span>
		<span class="n">axi_rlen</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">S_AXI_ARLEN</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
				<span class="o">+</span> <span class="p">((</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_RREADY</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>This works because the value that’s stalled in the return position has already
been read.  It won’t get updated by this new read address request.</p>

<p>Any time a read value is returned, we’ll then simply decrement our counter.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RVALID</span><span class="p">)</span>
		<span class="n">axi_rlen</span> <span class="o">&lt;=</span> <span class="n">axi_rlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Notice that we didn’t check whether <code class="language-plaintext highlighter-rouge">axi_rlen</code> was greater than zero or not.
<code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> is equivalent to <code class="language-plaintext highlighter-rouge">axi_rlen &gt; 0</code>, and a basic assertion (below)
proves that to be the case.  Hence we only need to check <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code>.</p>

<p>How about our <a href="/blog/2019/04/27/axi-addr.html">read address</a>?</p>

<p>This one’s a little tricky.  Because we stuffed our first read operation into
the same clock cycle as <code class="language-plaintext highlighter-rouge">ARVALID &amp; ARREADY</code>, the
<a href="/blog/2019/04/27/axi-addr.html">address</a>
we record needs to be not the address given, but rather the
<a href="/blog/2019/04/27/axi-addr.html">next address</a>–assuming
we read on the same cycle.  This also means that the values we feed to our
<a href="/blog/2019/04/27/axi-addr.html"><code class="language-plaintext highlighter-rouge">axi_addr</code> next-address
module</a> will need to
depend upon whether the read address is sourced from
<code class="language-plaintext highlighter-rouge">ARADDR</code> or <code class="language-plaintext highlighter-rouge">raddr</code> below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Calculate the next read address</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_rd</span><span class="p">)</span>
		<span class="n">raddr</span> <span class="o">&lt;=</span> <span class="n">next_rd_addr</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">)</span>
		<span class="n">raddr</span> <span class="o">&lt;=</span> <span class="n">S_AXI_ARADDR</span><span class="p">;</span></code></pre></figure>

<p>Actually <a href="/blog/2019/04/27/axi-addr.html">calculating the next address requires registering and keeping track
of several values from the AXI address
packet</a>:
the burst type, the transfer size per beat, and the total number of  beats.
While we’re at it, we’ll copy the read ID as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">rburst</span>   <span class="o">&lt;=</span> <span class="n">S_AXI_ARBURST</span><span class="p">;</span>
		<span class="n">rsize</span>    <span class="o">&lt;=</span> <span class="n">S_AXI_ARSIZE</span><span class="p">;</span>
		<span class="n">rlen</span>     <span class="o">&lt;=</span> <span class="n">S_AXI_ARLEN</span><span class="p">;</span>
		<span class="n">rid</span>      <span class="o">&lt;=</span> <span class="n">S_AXI_ARID</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Once we have all these values, we can then <a href="/blog/2019/04/27/axi-addr.html">calculate the next read
address</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">axi_addr</span> <span class="p">#(.</span><span class="n">AW</span><span class="p">(</span><span class="n">AW</span><span class="p">),</span> <span class="p">.</span><span class="n">DW</span><span class="p">(</span><span class="n">DW</span><span class="p">))</span>
		<span class="n">get_next_rd_addr</span><span class="p">((</span><span class="n">S_AXI_ARREADY</span> <span class="o">?</span> <span class="n">S_AXI_ARADDR</span> <span class="o">:</span> <span class="n">raddr</span><span class="p">),</span>
				<span class="p">(</span><span class="n">S_AXI_ARREADY</span>  <span class="o">?</span> <span class="n">S_AXI_ARSIZE</span> <span class="o">:</span> <span class="n">rsize</span><span class="p">),</span>
				<span class="p">(</span><span class="n">S_AXI_ARBURST</span>  <span class="o">?</span> <span class="n">S_AXI_ARBURST</span><span class="o">:</span> <span class="n">rburst</span><span class="p">),</span>
				<span class="p">(</span><span class="n">S_AXI_ARLEN</span>    <span class="o">?</span> <span class="n">S_AXI_ARLEN</span>  <span class="o">:</span> <span class="n">rlen</span><span class="p">),</span>
				<span class="n">next_rd_addr</span><span class="p">);</span></code></pre></figure>

<p>This may be one of the more delicate parts of this operation.  A quick
<a href="http://www.clifford.at/yosys">yosys</a> check,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% yosys <span class="nt">-p</span> <span class="s1">'read -sv axi_addr; synth_xilinx; show'</span></code></pre></figure>

<p>reveals an image showing that the logic is four levels deep.  Adding this
address check, therefore, might make it difficult to meet timing.  That means
that I might need to revisit this step later if/when I ever run into timing
problems here.</p>

<p>By the way, if you’ve never tried the
<a href="http://www.clifford.at/yosys/cmd_show.html">yosys <code class="language-plaintext highlighter-rouge">show</code> command</a>,
it can be very instructive to see and learn how
<a href="http://www.clifford.at/yosys">yosys</a>
is choosing to synthesize your code.</p>

<p>But I digress.</p>

<p>Now that we know
<a href="/blog/2019/04/27/axi-addr.html">the address</a>,
we’re able to drive the read ports of our (simplified) external slave.  These
include <code class="language-plaintext highlighter-rouge">o_rd</code>, the flag that indicates when to read, and
<code class="language-plaintext highlighter-rouge">o_raddr</code> to indicate the address to read from.</p>

<p>We’ll want to read on the same clock as any incoming request, or equivalently
any time <code class="language-plaintext highlighter-rouge">ARREADY</code> is false, indicating that we are still working through
the middle of a burst.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_rd</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_AXI_ARVALID</span> <span class="o">||</span> <span class="o">!</span><span class="n">S_AXI_ARREADY</span><span class="p">);</span></code></pre></figure>

<p>However, if the read return channel is ever stalled, such as when
<code class="language-plaintext highlighter-rouge">!S_AXI_RVALID || S_AXI_RREADY</code> then we cannot perform our read lest
we cause our outgoing data to change before it has been accepted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_RREADY</span><span class="p">)</span>
			<span class="n">o_rd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>We’ve also discussed generating the read address above.  On any given clock
cycle, this address will be given by <code class="language-plaintext highlighter-rouge">raddr</code> if we are in the middle of a
burst, such as when <code class="language-plaintext highlighter-rouge">!S_AXI_ARREADY</code>, and then by <code class="language-plaintext highlighter-rouge">S_AXI_ARADDR</code> on the first
beat of any burst.  We can use <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> to tell the difference between
these two choices.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">o_raddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_AXI_ARREADY</span> <span class="o">?</span> <span class="n">S_AXI_ARADDR</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">LSB</span><span class="p">]</span> <span class="o">:</span> <span class="n">raddr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">LSB</span><span class="p">]);</span>
	<span class="k">end</span></code></pre></figure>

<p>Notice also that we’ve used <code class="language-plaintext highlighter-rouge">LSB</code> above to drop the subword addressing.
I’ve done this for the simple reason that I don’t have any modules that
would use the subword address.</p>

<p>That gets us past accepting the read request from the address channel,
storing the details of that request and updating those details from one beat
to the next.  We’ve also issued the read request from our external peripheral.
We just haven’t set the read output return values yet.</p>

<p>Let’s do that now.</p>

<p>Typically, the most difficult part of any of these channels is either the valid
or the ready signal–whichever one you have control over, whether master or
slave.  These signals are just the type of signals that you can’t afford to
mess up.  If you mess up the data, the bus will still work.  If you mess up
the response, your program might fail but the bus won’t lock up.  On the other
hand, if you mess up the valid/ready signals, the return ID signal, or even
the last signal, you might well lock everything up hard.</p>

<p>So let’s keep this simple.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_rvalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Any time we read from memory, we’ll set the outgoing valid signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o_rd</span><span class="p">)</span>
		<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Keep in mind, this isn’t quite as simple as it looks since we’ve already put
a some combinatorial logic into the <code class="language-plaintext highlighter-rouge">o_rd</code> signal.  One of the critical pieces
of logic there is the piece that forces <code class="language-plaintext highlighter-rouge">o_rd</code> to be zero any time the bus is
stalled.</p>

<p>Next, if <code class="language-plaintext highlighter-rouge">o_rd</code> is low, then we can clear the return valid signal any time
<code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> is true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">)</span>
		<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Let’s now turn our attention to the return ID signal next.  This particular
signal can <em>only</em> change if the return channel isn’t stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>In that case, the new ID can either be the ID from a newly accepted burst,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARREADY</span><span class="p">)</span>
			<span class="n">axi_rid</span> <span class="o">&lt;=</span> <span class="n">S_AXI_ARID</span><span class="p">;</span></code></pre></figure>

<p>or alternatively the ID we saved in our buffer when the new burst was
accepted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span>
			<span class="n">axi_rid</span> <span class="o">&lt;=</span> <span class="n">rid</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>In many ways, the <code class="language-plaintext highlighter-rouge">RLAST</code> signal uses the same logic as the return ID.  As
with the ID signal, it cannot change if the return channel is stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">axi_rlast</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>The return channel will be stalled anytime <code class="language-plaintext highlighter-rouge">RVALID &amp;&amp; !RREADY</code>.  The
above expression is just this stall logic negated according to <a href="https://en.wikipedia.org/wiki/De_Morgan's_laws">De Morgen’s
laws</a>.</p>

<p>If the return channel is not stalled, then we have a couple of cases to deal
with.  The first is if we just accepted a request, indicated by
<code class="language-plaintext highlighter-rouge">ARVALID &amp; ARREADY</code>.  In that case, we’ll set <code class="language-plaintext highlighter-rouge">axi_rlast</code> if the burst
only had a single beat to it.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARREADY</span><span class="p">)</span>
			<span class="n">axi_rlast</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">S_AXI_ARLEN</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>Otherwise we need to set <code class="language-plaintext highlighter-rouge">axi_rlast</code> so that <code class="language-plaintext highlighter-rouge">axi_rlast == (axi_rlen == 1)</code>.
Ideally, we’d just set <code class="language-plaintext highlighter-rouge">axi_rlast &lt;= (axi_rlen == 1)</code> but this ignores the
possibility of <code class="language-plaintext highlighter-rouge">axi_rlen</code> changing on this clock as well due to a return
value being accepted.  Hence, we set <code class="language-plaintext highlighter-rouge">axi_rlast</code> if <code class="language-plaintext highlighter-rouge">axi_rlen</code> is about
to become one, or if the interface is stalled then we simply set it based
upon the current value of <code class="language-plaintext highlighter-rouge">axi_rlen</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span><span class="p">)</span>
			<span class="n">axi_rlast</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">axi_rlen</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">axi_rlast</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">axi_rlen</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>As for setting <code class="language-plaintext highlighter-rouge">RDATA</code>, the external sub-slave did that for us.  Remember
how we insisted that it have the following read logic?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_rd</span><span class="p">)</span>
	<span class="n">o_rdata</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">i_raddr</span><span class="p">];</span></code></pre></figure>

<p>Notice here that the <code class="language-plaintext highlighter-rouge">i_rd</code> signal is key!  This allows us to just set the
<code class="language-plaintext highlighter-rouge">RDATA</code> output combinatorially based upon this <code class="language-plaintext highlighter-rouge">i_rdata</code> input.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">axi_rdata</span> <span class="o">=</span> <span class="n">i_rdata</span><span class="p">;</span></code></pre></figure>

<p>If the slave were to set <code class="language-plaintext highlighter-rouge">o_rdata</code> on any other criteria, then it might
possibly change <code class="language-plaintext highlighter-rouge">RDATA</code> while the output channel was stalled, as indicated
by <code class="language-plaintext highlighter-rouge">S_AXI_RVALID &amp; S_AXI_RREADY</code>.  This would be a protocol violation, so it
is important that the slave only set <code class="language-plaintext highlighter-rouge">RDATA</code> whenever the <code class="language-plaintext highlighter-rouge">o_rd</code> is also
true.</p>

<p>The rest of the design simply involves setting our various output signals to
their internally registered counterparts.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">//</span>
	<span class="k">assign</span>	<span class="n">S_AXI_ARREADY</span> <span class="o">=</span> <span class="n">axi_arready</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">S_AXI_RVALID</span>  <span class="o">=</span> <span class="n">axi_rvalid</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">S_AXI_RID</span>     <span class="o">=</span> <span class="n">axi_rid</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">S_AXI_RDATA</span>   <span class="o">=</span> <span class="n">axi_rdata</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">S_AXI_RRESP</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">S_AXI_RLAST</span>   <span class="o">=</span> <span class="n">axi_rlast</span><span class="p">;</span>
	<span class="c1">//</span></code></pre></figure>

<p>That’s all it takes to create a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">high throughput AXI slave
design</a>.
Feel free to check it out
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">here</a>.</p>

<p>Well, yes, but the key question is, does it work?
We’ve already seen that there were <a href="/formal/2019/05/13/axifull.html">both several bugs in Xilinx’s design,
as well as noting that it couldn’t handle any significant
throughput</a>.  How
can we be sure that this design is any better?</p>

<p>For that we’ll turn to <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>.</p>

<h2 id="formal-verification">Formal Verification</h2>

<p>The majority of the
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
work we need will be done by a formal property checker.  That will
make a lot of this verification work easy.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="c1">// ...</span>
	<span class="n">faxi_slave</span>	<span class="p">#(</span>
		<span class="p">.</span><span class="n">F_AXI_MAXSTALL</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
		<span class="p">.</span><span class="n">C_AXI_ID_WIDTH</span><span class="p">(</span><span class="n">C_S_AXI_ID_WIDTH</span><span class="p">),</span>
		<span class="p">.</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">(</span><span class="n">C_S_AXI_DATA_WIDTH</span><span class="p">),</span>
		<span class="p">.</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="p">(</span><span class="n">C_S_AXI_ADDR_WIDTH</span><span class="p">),</span>
		<span class="p">.</span><span class="n">F_LGDEPTH</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="p">))</span>
		<span class="n">f_slave</span><span class="p">(</span>
		<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_reset_n</span><span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="c1">// Address write channel</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_awvalid</span><span class="p">(</span><span class="n">m_awvalid</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awready</span><span class="p">(</span><span class="n">m_awready</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awid</span><span class="p">(</span>   <span class="n">m_awid</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awaddr</span><span class="p">(</span> <span class="n">m_awaddr</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awlen</span><span class="p">(</span>  <span class="n">m_awlen</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awsize</span><span class="p">(</span> <span class="n">m_awsize</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awburst</span><span class="p">(</span><span class="n">m_awburst</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awlock</span><span class="p">(</span> <span class="mb">1'b0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awcache</span><span class="p">(</span><span class="mh">4'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awprot</span><span class="p">(</span> <span class="mh">3'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awqos</span><span class="p">(</span>  <span class="mh">4'h0</span><span class="p">),</span>
	<span class="c1">//</span>
	<span class="c1">//</span>
		<span class="c1">//</span>
		<span class="c1">// Write Data Channel</span>
		<span class="c1">//</span>
		<span class="c1">// Write Data</span>
		<span class="p">.</span><span class="n">i_axi_wdata</span><span class="p">(</span><span class="n">S_AXI_WDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wstrb</span><span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wlast</span><span class="p">(</span><span class="n">S_AXI_WLAST</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wvalid</span><span class="p">(</span><span class="n">S_AXI_WVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wready</span><span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">),</span>
	<span class="c1">//</span>
	<span class="c1">//</span>
		<span class="c1">// Response ID tag. This signal is the ID tag of the</span>
		<span class="c1">// write response.</span>
		<span class="p">.</span><span class="n">i_axi_bvalid</span><span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bready</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bid</span><span class="p">(</span>   <span class="n">S_AXI_BID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bresp</span><span class="p">(</span> <span class="n">S_AXI_BRESP</span><span class="p">),</span>
	<span class="c1">//</span>
	<span class="c1">//</span>
		<span class="c1">//</span>
		<span class="c1">// Read address channel</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_arvalid</span><span class="p">(</span><span class="n">S_AXI_ARVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arready</span><span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arid</span><span class="p">(</span>   <span class="n">S_AXI_ARID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_araddr</span><span class="p">(</span> <span class="n">S_AXI_ARADDR</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arlen</span><span class="p">(</span>  <span class="n">S_AXI_ARLEN</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arsize</span><span class="p">(</span> <span class="n">S_AXI_ARSIZE</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arburst</span><span class="p">(</span><span class="n">S_AXI_ARBURST</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arlock</span><span class="p">(</span> <span class="n">S_AXI_ARLOCK</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arcache</span><span class="p">(</span><span class="n">S_AXI_ARCACHE</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arprot</span><span class="p">(</span> <span class="n">S_AXI_ARPROT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arqos</span><span class="p">(</span>  <span class="n">S_AXI_ARQOS</span><span class="p">),</span>
	<span class="c1">//</span>
	<span class="c1">//</span>
		<span class="c1">//</span>
		<span class="c1">// Read data return channel</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_rvalid</span><span class="p">(</span><span class="n">S_AXI_RVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rready</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rid</span><span class="p">(</span><span class="n">S_AXI_RID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rdata</span><span class="p">(</span><span class="n">S_AXI_RDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rresp</span><span class="p">(</span><span class="n">S_AXI_RRESP</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rlast</span><span class="p">(</span><span class="n">S_AXI_RLAST</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="c1">// Formal outputs</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">f_axi_awr_nbursts</span><span class="p">(</span><span class="n">f_axi_awr_nbursts</span><span class="p">),</span>
		<span class="c1">// ...</span>
		<span class="p">.</span><span class="n">f_axi_rd_nbursts</span><span class="p">(</span><span class="n">f_axi_rd_nbursts</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_axi_rd_outstanding</span><span class="p">(</span><span class="n">f_axi_rd_outstanding</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="c1">// ...</span>
		<span class="p">.</span><span class="n">f_axi_wr_addr</span><span class="p">(</span><span class="n">f_axi_wr_addr</span><span class="p">)</span>
		<span class="c1">// ...</span>
	<span class="p">);</span></code></pre></figure>

<p>Including the property file by itself is usually enough to find errors
within the design.  Indeed, just adding the property file alone to someone
else’s core, with whatever strange logic within it that I’m not familiar with,
has been all I’ve done to find most of the errors I’ve shared on
<a href="https://twitter.com/ZipCPU">twitter</a>.</p>

<p>It’s not enough to <em>prove</em> that the design has no errors.</p>

<p>For that, we need to turn to
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.
Further, when using
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
we need to add constraints to tie the state found within the
formal property file to the state of our design.</p>

<p>The following are several examples of the properties I’ve used to do this.</p>

<p>We’ll start with the write side.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">////////////////////////////////////////////////////////////////////////</span>
	<span class="c1">//</span>
	<span class="c1">// Write induction properties</span>
	<span class="c1">//</span>
	<span class="c1">////////////////////////////////////////////////////////////////////////</span>
	<span class="c1">//</span>
	<span class="c1">//</span></code></pre></figure>

<p>The formal property file counts the number of outstanding address write
requests.  In the case of this design, there will never be more than
two outstanding burst writes.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_awr_nbursts</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">);</span></code></pre></figure>

<p>Now let’s look at each of those three possibilities, whether zero, one,
or two outstanding write bursts.</p>

<p>If there are two outstanding requests, then one of them must be in the
return position, <code class="language-plaintext highlighter-rouge">S_AXI_BVALID</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_axi_awr_nbursts</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">r_bvalid</span> <span class="o">||</span> <span class="n">S_AXI_WREADY</span><span class="p">));</span></code></pre></figure>

<p>On the other hand, if only one request is outstanding, then it must be in
either the return <code class="language-plaintext highlighter-rouge">BVALID</code> pipeline stage or in the <code class="language-plaintext highlighter-rouge">WREADY</code> accepting
data pipeline stage.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f_axi_awr_nbursts</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">^</span> <span class="n">S_AXI_WREADY</span><span class="p">);</span></code></pre></figure>

<p>Finally, if nothing is outstanding on the write channel, then neither <code class="language-plaintext highlighter-rouge">BVALID</code>
nor <code class="language-plaintext highlighter-rouge">WREADY</code> should be true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_WREADY</span><span class="p">);</span></code></pre></figure>

<p>This same logic is then repeated to check burst IDs.
We’ll skip that here and move on.</p>

<p>I mentioned above that any time a value was in the outgoing write
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
that is any time <code class="language-plaintext highlighter-rouge">r_bvalid</code> was true, then <code class="language-plaintext highlighter-rouge">BVALID</code> must also be true.
Let’s double check that here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r_bvalid</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">);</span></code></pre></figure>

<p>We’ll also need to check the <code class="language-plaintext highlighter-rouge">axi_awready</code> signal.  As you may recall, this
was the registered component of <code class="language-plaintext highlighter-rouge">m_awready</code>, the incoming
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
read signal.  Specifically, we want to make absolute certain that we’ll
be ready to read any new write address any time there’s nothing in the
write data stage, where <code class="language-plaintext highlighter-rouge">S_AXI_WREADY</code>, or in the outgoing <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a>,
as marked by <code class="language-plaintext highlighter-rouge">r_bvalid</code>.  Indeed, this property is so strong, it’s a two
sided implication that we’ll want to check both ways.  For that reason,
I’m using an equality assertion to check it below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">axi_awready</span> <span class="o">==</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_WREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r_bvalid</span><span class="p">));</span></code></pre></figure>

<p>One of the neat parts of the
<a href="/doc/axi-spec.pdf">AXI</a>
formal property set is that one of the outputs
from it is the current write address.  You can use this to double check
your own address computation.  We’ll do that here, and so double check that
our outgoing address truly does match the address it should be.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_wr_addr</span>  <span class="o">==</span> <span class="n">waddr</span><span class="p">);</span>
		<span class="c1">// ...</span>
	<span class="k">end</span></code></pre></figure>

<p>With that, we can now turn our attention to verifying the read side.  As
before, we’ll focus on those properties that are necessary to validate that
this works when using
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
since the basic <a href="/doc/axi-spec.pdf">AXI</a>
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
properties will take care of the rest.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">////////////////////////////////////////////////////////////////////////</span>
	<span class="c1">//</span>
	<span class="c1">// Read induction properties</span>
	<span class="c1">//</span>
	<span class="c1">////////////////////////////////////////////////////////////////////////</span>
	<span class="c1">//</span>
	<span class="c1">//</span></code></pre></figure>

<p>As with the write half, there will never be more than two outstanding read
requests when using this core.  Within the formal property set, there’s a
counter capturing the number of read bursts–just like the counter for writes
above.  Here, we’ll just double check that this number is never out of bounds
with the logic above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_rd_nbursts</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">);</span></code></pre></figure>

<p>Now we have to define what that means within our core.  In this case, and
for this core, if the number of outstanding bursts is ever more than one,
then there must be a value in the output position waiting to be returned.
Not only that, it must be the last item from the previous burst.  Further,
our <code class="language-plaintext highlighter-rouge">ARREADY</code> signal must be low because we’ll only end up in this situation
if the response path were stalled on the last cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_axi_rd_nbursts</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RLAST</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_ARREADY</span><span class="p">);</span></code></pre></figure>

<p>Not only will the formal property set count the number of bursts that are
outstanding, it will count the total number of outstanding values that need
to be returned.  This number should match the <code class="language-plaintext highlighter-rouge">axi_rlen</code> value within our core.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">axi_rlen</span> <span class="o">==</span> <span class="n">f_axi_rd_outstanding</span><span class="p">);</span></code></pre></figure>

<p>Since the external sub-slave core will never stall in this design, we also
know that <code class="language-plaintext highlighter-rouge">RVALID</code> must be true any time any request is outstanding.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_axi_rd_nbursts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_RVALID</span><span class="p">);</span></code></pre></figure>

<p>Similarly, if there’s anything outstanding, then either <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> is
low blocking any incoming requests, or <code class="language-plaintext highlighter-rouge">S_AXI_RVALID &amp; S_AXI_RLAST</code> are high
indicating that we are on the last beat of the burst.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARREADY</span> <span class="o">||</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RLAST</span><span class="p">));</span></code></pre></figure>

<p>Likewise, if nothing is outstanding, then we want to make certain that
<code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> is set so that we’ll be ready for the next burst.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">);</span></code></pre></figure>

<p>The property set also provides for some return ID checking, which I’ll skip
here.  There’s also a read address check, which we can use to make certain
that <code class="language-plaintext highlighter-rouge">o_raddr</code> is properly set.  That check requires tracking the address
from <code class="language-plaintext highlighter-rouge">o_raddr</code> to the return position where it would be checked.</p>

<p>Instead of working through those two tests, and for the sake of keeping things
short, I’d like to share one final read property.  Specifically, any time
<code class="language-plaintext highlighter-rouge">S_AXI_RLAST</code> becomes true, that is if <code class="language-plaintext highlighter-rouge">S_AXI_RLAST &amp; !$past(S_AXI_RLAST)</code>,
then we want <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> to be high as well.  We can use <code class="language-plaintext highlighter-rouge">$rose()</code> for
this purpose to check this transition.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_past_valid</span> <span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">S_AXI_RLAST</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">);</span></code></pre></figure>

<p>While I initially wanted to check for more than that, such as when
<code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> is false when <code class="language-plaintext highlighter-rouge">S_AXI_RLAST</code> is true, that much has
already been captured above.</p>

<p>Finally, we need one basic assumption, beyond those provided by the AXI
property set.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">////////////////////////////////////////////////////////////////////////</span>
	<span class="c1">//</span>
	<span class="c1">// Assumptions necessary to pass a formal check</span>
	<span class="c1">//</span>
	<span class="c1">////////////////////////////////////////////////////////////////////////</span>
	<span class="c1">//</span>
	<span class="c1">//</span></code></pre></figure>

<p>We need to assume that the external sub-slave will behave properly.  That is,
it won’t change its value unless we’ve requested a read from it.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">o_rd</span><span class="p">))</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_rdata</span><span class="p">));</span>
<span class="cp">`endif</span>
<span class="k">endmodule</span></code></pre></figure>

<p>`
That should give you a basic, yet brief, overview of the
<a href="/blog/2017/10/19/formal-intro.html">formal proof</a>.</p>

<h2 id="cover">Cover</h2>

<p>Normally I spend a section discussing cover properties.  In this case,
we’ve discussed one such cover property above.  I figured it was important
to point out that 
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
generated a trace demonstrating that this cover point could be hit.</p>

<table align="center" style="float: none"><caption>Fig 15. The basic write cover trace, generated by the cover above</caption><tr><td><a href="/img/demofull/demofull-write-cover-trace.png"><img src="/img/demofull/demofull-write-cover-trace.png" alt="A trace, showing that the AXI GPIO core requires six clocks per write" width="720" /></a></td></tr></table>

<h2 id="gpio">GPIO</h2>

<p>For some strange reason, it seems like I’m always fielding questions on
whatever forum about the
<a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">AXI-GPIO</a>
core provided by
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>.  In
particular, there’s a lot of individuals complaining on-line about how slow
<a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">this core</a> is.</p>

<p>Consider for example, the trace shown in Fig. 16 below, drawn from a <code class="language-plaintext highlighter-rouge">cover()</code>
property placed external to <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">the GPIO
core</a>.</p>

<table align="center" style="float: none"><caption>Fig 16. Cover trace from Xilinx's AXI GPIO v2 core, as provided by Vivado 2018.3</caption><tr><td><a href="/img/tweets/axi-gpio-writes.svg"><img src="/img/tweets/axi-gpio-writes.svg" alt="A trace, showing that the AXI GPIO core requires six clocks per write" width="720" /></a></td></tr></table>

<p>Now, consider this: if all you did was connect <a href="/zipcpu/2019/02/09/cpu-blinky.html">your own basic I/O
core</a> to the output of
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this core</a>,
you could create <a href="/zipcpu/2019/02/09/cpu-blinky.html">your own GPIO
controller</a>
running six times faster than <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">this
one</a>.
Even better, your new <a href="/zipcpu/2019/02/09/cpu-blinky.html">GPIO
controller</a>
could then even handle <a href="/formal/2019/05/13/axifull.html">both reads and writes at the same
time</a>.
That’s not all.  If you used
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this core</a>,
you wouldn’t need to waste more clocks going through Xilinx’s
<a href="/doc/axi-spec.pdf">AXI</a>
to <a href="/formal/2018/12/28/axilite.html">AXI-lite</a> bridge.</p>

<p>That is, it would be 6x+ faster if only Xilinx’s interconnect supported
such a speed.  We’ll save that discussion for another day.  Until then,
it’s worth knowing that <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">faster AXI
interconnect</a>s
exist.</p>

<h2 id="conclusions">Conclusions</h2>

<p>We’ve just worked through a basic
<a href="/doc/axi-spec.pdf">AXI</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">slave core</a>.
Not only that, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this slave
core</a>
has the performance I’d expect from a high quality product–up to 100%
sustained throughput.</p>

<p>Sadly, very few of the
<a href="/doc/axi-spec.pdf">AXI</a>
<a href="/formal/2019/05/13/axifull.html">slave cores I’ve examined</a>
can handle this kind of throughput.
It’s a shame, too, since most people purchase
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
in order to get high speed performance for their own special
application–whatever it is.  On the other hand, if the logic
you use within your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
is going to cripple your performance, then why purchase such
an expensive component or go through the pain of digital design?</p>

<p>Perhaps the difference is the
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
software, <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a> as
provided by <a href="https://www.symbioticeda.com">SymbioticEDA</a>.  Because of the
<a href="/blog/2017/10/19/formal-intro.html">formal tool</a>,
and more specifically because of the formal AXI property file, I was
able to build this design with confidence–even though I couldn’t
figure out how to build a proper
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM</a>
state transition diagram for it.</p>

<p>Yes, <a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
truly make digital design a lot easier.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For wisdom is a defence, and money is a defence: but the excellency of knowledge is, that wisdom giveth life to them that have it.  (Ecc 7:12)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
