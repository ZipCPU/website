<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a custom yet functional AXI-lite slave</title>
  <meta name="description" content="Fig 1. The AXI4 bus requires five independent channels">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2019/01/12/demoaxilite.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building a custom yet functional AXI-lite slave</h1>
    <p class="post-meta"><time datetime="2019-01-12T00:00:00-05:00" itemprop="datePublished">Jan 12, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table style="float: right"><caption>Fig 1. The AXI4 bus requires five independent channels</caption><tr><td><img src="/img/bus-axi-channels.svg" alt="Illustration, showing the five separate channels of the AXI4 bus" width="360" /></td></tr></table>

<p>Last year, we discussed <a href="/formal/2018/12/28/axilite.html">how to verify an AXI-lite slave
peripheral</a>.  To do
this, we asked Vivado to generate an example <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">AXI-lite
peripheral</a>
and then added a reference to an <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">AXI-lite property
file</a>
and about 20 more lines of code to our design.  Much to my surprise, Vivado’s
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">AXI-lite peripheral</a>
didn’t pass <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>.
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">The core</a>
failed because it didn’t properly drop the ready lines to prevent an incoming
transaction in the case where the outgoing acknowledgement channel was stalled.</p>

<p>We also noticed that <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">Xilinx’s demonstration
core</a>
as designed could only ever ever process a single
transaction for every two clocks ticks, limiting its maximum
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a>.  No
simple code adjustment would fix this.</p>

<p>That post referenced <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">a core generated by Vivado
2016.3</a>.
Since that time, I’ve also had a chance to
download and examine Vivado’s 2018.3 AXI-lite demonstration core.  While
superficial changes have been made to this example core, it still suffers
from the same basic design flaws: unless the outgoing ready signals on the two
acknowledgment channels, both for <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> and <code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code>, are
dependably held high <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the
core</a>
will drop acknowledgments.  This is fundamentally bad, since it could cause a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
to lock up hard.  Worse, since it would be caused by the vendor’s
demonstration code, no one would think twice to examine it for an error.</p>

<p>For the sake of those who wish to work with an
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a> slave peripheral,
let’s take a moment and examine how we might build a
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">better AXI-slave</a>.</p>

<h2 id="goals-for-any-bus-component">Goals for any Bus Component</h2>

<p>Whenever I build a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
component, whether it be a slave or a master, I start with three basic design
criteria.</p>

<ol>
  <li>
    <p>First, the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
component must maintain the rules of the road for the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
it is on.  In the case of an <a href="/formal/2018/12/28/axilite.html">AXI-lite
bus</a>, that means we need
to examine the <a href="/doc/axi-spec.pdf">AXI-specification</a> to determine how our
code must behave.</p>

    <table style="float: right"><tr><td><img src="/img/tweets/fpropfile.png" alt="What is a formal property file?" width="480" /></td></tr></table>

    <p>Once we’ve done that once, we can then capture this behavior in a <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal
property file</a>
that can then be used later to verify any other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> component.
Such property files are great timesavers, since they typically only need
to be built once, and yet they can then be used to verify any number of
design components.</p>

    <p>A common question I often get from corporate clients new to
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
is, where do I start?  My answer is often, “Start by building property
files for the interfaces you support,” for this very reason: for a small
amount of
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
work, you can get a tremendous return on your investment.</p>

    <p>Today, we’ll be reaping a return on our <a href="/formal/2018/12/28/axilite.html">last AXI-lite
investment</a>.</p>
  </li>
</ol>

<p>My next two goals are performance related.</p>

<ol start="2">
  <li>
    <p>Maximum <a href="https://en.wikipedia.org/wiki/Throughput">throughput</a></p>

    <p>Once the component obeys the rules of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
my next priority is maximum
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a>.  A
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
component must support the highest
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a>
possible.  Think of it this way, the speed of the entire <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU portion of the
design</a>
depends upon the speed of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
High performance is achieved by pipelining multiple transactions to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
in a group.  The higher the
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a> is, the faster the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
(or whatever
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master) can perform its functions.</p>

    <p>Several individuals have posted both on
<a href="https://forums.xilinx.com">Xilinx’s forum</a> and
<a href="https://forum.digilentinc.com">Digilent’s forum</a>
about the MicroBlaze computer being
<a href="/zipcpu/2019/02/09/cpu-blinky.html">horrendously slow</a>
[<a href="https://forum.digilentinc.com/topic/4930-arty-microblaze-speed-question">1</a>]
[<a href="https://forums.xilinx.com/t5/Evaulation-Boards/AXI_GPIO-too-slow/td-p/725431">2</a>]
[<a href="https://forums.xilinx.com/t5/Embedded-Processor-System-Design/Why-microblaze-loop-speed-is-40-times-slower-than-I-expected/td-p/111342">3</a>]
[<a href="https://forums.xilinx.com/t5/7-Series-FPGAs/SDK-GPIO-implementation/td-p/784626">4</a>]
[<a href="https://forums.xilinx.com/t5/Embedded-Processor-System-Design/AXI-GPIO-max-rate/td-p/484496">5</a>].
The measurement is typically made by examining how fast the processor can
toggle a <a href="https://en.wikipedia.org/wiki/General-purpose_input/output">general purpose
output</a>
fed into an <a href="https://en.wikikpedia.org/wiki/Oscilloscope">oscilloscope</a>.
While I’ll admit this isn’t a great measure of
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
performance, it is a somewhat decent measure of peripheral
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
performance.
(Incidentally, <a href="/zipcpu/2019/02/09/cpu-blinky.html">the ZipCPU can toggle a GPIO peripheral about 12x
faster</a>.)</p>

    <p>There is no reason why a basic
<a href="https://en.wikipedia.org/wiki/General-purpose_input/output">GPIO</a> driver,
as an example, needs two clocks for every transaction.</p>

    <p>We’ll create a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
component in a moment that can handle one transaction
on every clock.</p>
  </li>
  <li>
    <p>Minimum <a href="https://en.wikipedia.org/wiki/Latency_(engineering)">latency</a></p>

    <p>By <a href="https://en.wikipedia.org/wiki/Latency_(engineering)">latency</a>
I mean the number of clock cycles it takes from when the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
makes a request until the response comes back from the peripheral.  Most
of the clock cycles used during the request will be
consumed by the <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
first and then the interconnect, meaning that there isn’t all
that much that a peripheral designer can do to affect the
<a href="https://en.wikipedia.org/wiki/Latency_(engineering)">latency</a>
associated with accessing his component.</p>

    <p>What he can do, however, is make certain that he doesn’t <em>increase</em> that
<a href="https://en.wikipedia.org/wiki/Latency_(engineering)">latency</a> by how he
processes the request.</p>

    <p><a href="/doc/axi-spec.pdf">AXI</a> requires that all
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
signals must be registered on the clock edge.  This means that the minimum
<a href="https://en.wikipedia.org/wiki/Latency_(engineering)">latency</a>
through any <a href="/doc/axi-spec.pdf">specification compliant</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">AXI-slave
peripheral</a>
can never be better than a single clock cycle.  The
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">core</a>
presented below will achieve this minimum
<a href="https://en.wikipedia.org/wiki/Latency_(engineering)">latency</a>.</p>
  </li>
  <li>
    <p>My last criteria, <a href="/blog/2017/06/12/minimizing-luts.html">minimum
area</a>,
is often lost after meeting the first three.  In general, a design that
meets the first three criteria is often so constrained that there’s not
much more you can do to achieve <a href="/blog/2017/06/12/minimizing-luts.html">minimum
area</a>.  This is why
the <a href="/zipcpu/2017/11/07/wb-formal.html">choice of a bus
standard</a> is so
important to anyone designing for <a href="/blog/2017/06/12/minimizing-luts.html">low area/minimum
cost</a>: design
choices have consequences.</p>
  </li>
</ol>

<p>Overall system performance depends upon the first three design goals.  High
performance is fairly easy to meet using the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>–which is
one of the reasons why I like it so much.  With
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>,
however, the <a href="/doc/axi-spec.pdf">bus requirements</a> and
maximum <a href="https://en.wikipedia.org/wiki/Throughput">throughput</a> goal can seem
contradictory.  It’s certainly not obvious, and so it’s worth illustrating
how to make this happen.</p>

<p>Therefore let’s examine how to make an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">AXI-lite
slave</a>.  I’ll
focus on a <a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a> based
design.  Indeed, if we do this right, then our design should be able to map into
block <a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>.  (My first
draft didn’t meet this criteria.)  Either way the design approach will be quite
appropriate for a typical <a href="https://en.wikipedia.org/wiki/Hardware_register">register-based</a>
slave peripheral.</p>

<p>Finally, before beginning to look at how we’d do this, let’s just note that
of the two types of transactions, read and write, the
<a href="/doc/axi-spec.pdf">AXI</a>
read channel is simplest to implement.  Unlike the write channel, there’s only
the one request channel called the read address channel going into a read
transaction.  The write channel, on the other hand, requires both an address
and a data channel feeding it, as shown in Fig. 1 above.  Therefore let’s
examine the read channel first, and then apply the lessons we learn from the
read channel to the write channel in the following section.</p>

<h2 id="read-channel-processing">Read Channel Processing</h2>

<p>Sometimes I like to sprint into code and just see how far I can get.  In this
case, such a sprint into the read channel implementation appears easy:
every time we get an <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY &amp;&amp; S_AXI_ARVALID</code> we want to set
<code class="language-plaintext highlighter-rouge">axi_rvalid</code> on the next clock.  As long as <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> remains true, this
is sufficient for high speed interaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">S_AXI_ARVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">axi_rready</span><span class="p">))</span>
	<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">)</span>
	<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">axi_rdata</span> <span class="o">&lt;=</span> <span class="n">slv_mem</span><span class="p">[</span><span class="n">S_AXI_ARADDR</span><span class="p">[</span><span class="n">AW</span><span class="o">+</span><span class="n">ADDR_LSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDR_LSB</span><span class="p">]];</span></code></pre></figure>

<p>Note that we’re following Vivado’s notation here, and using <code class="language-plaintext highlighter-rouge">S_AXI_*</code> to
describe any external signals, whereas we’ll use both the <code class="language-plaintext highlighter-rouge">axi_*</code> and
<code class="language-plaintext highlighter-rouge">S_AXI_*</code> prefixes to describe any internally generated
<a href="/doc/axi-spec.pdf">AXI</a>
signals.</p>

<table align="center" style="float: right"><caption>Fig 2. AXI-lite read transactions with S_AXI_RREADY high</caption><tr><td><img src="/img/demoaxil/demoaxil-rready.svg" alt="Trace showing multiple AXI-lite read transactions, all with ARREADY held high" width="480" /></td></tr></table>

<p>Fig. 2 on the right illustrates how this scheme might work.  Following any
clock period where both <code class="language-plaintext highlighter-rouge">S_AXI_ARVALID &amp;&amp; S_AXI_ARREADY</code> are true,
<code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> is set with the appropriate result on the next clock.  So far,
this is about as easy as
<a href="/zipcpu/2017/05/29/simple-wishbone.html">Wishbone</a>
was.</p>

<p>The problem with the approach outlined above is easily discovered
when we attempt to
<a href="/formal/2018/12/28/axilite.html">verify its functionality</a>.
It’s also the same basic logic the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">Vivado generated
core</a>
was been using: if <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> were always true, this would pass as working
code.  Nothing in the <a href="/doc/axi-spec.pdf">AXI-specification</a>,
however, requires that <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> be guaranteed to be true.  Indeed, I
have to believe the authors of the
<a href="/doc/axi-spec.pdf">AXI specification</a>
were quite proud of creating a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interface that might respond to “<a href="https://en.wikipedia.org/wiki/Backpressure_routing">back
pressure</a>”
as a stall on an outgoing channel is called.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 3. AXI-lite read transactions with S_AXI_RREADY high</caption><tr><td><img src="/img/demoaxil/demoaxil-rfails.svg" alt="Trace showing multiple AXI-lite read transactions, with two lost due to RREADY being low" width="480" /></td></tr></table>

<p>Fig. 3 on the left shows what this naive implementation might lead to when
the <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> line not held high.</p>

<p>In particular, we are required to hold the outgoing data constant any time
<code class="language-plaintext highlighter-rouge">axi_rvalid &amp;&amp; !S_AXI_RREADY</code>.  Did you notice how the blue transaction in this
figure got lost?  This would be a catastrophic bug in our code.  Notice also
how there’s an empty clock cycle in the return channel between the brown return
and the white return, precisely where the blue return should be?</p>

<p>Two realities lead to this bug.  The first is that we need to stall, i.e. lower,
the <code class="language-plaintext highlighter-rouge">axi_arready</code> line when the response ready, <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code>, is low and
<code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> is high.  (The
<a href="/doc/axi-spec.pdf">AXI-specification</a>
is very clear that setting the <code class="language-plaintext highlighter-rouge">axi_rvalid</code> line cannot depend up
<code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> being set initially.)  A straightforward implementation might
look like,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_RREADY</span><span class="p">)</span>
	<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">else</span>
	<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>This implementation, however, would cause the bug shown above in Fig. 3 above:
the ready signal is only dropped <em>after</em> a transaction is lost!  This is a
catastrophic bug.</p>

<p>We could try to simplify this approach and just state that,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">axi_arready</span> <span class="o">=</span> <span class="o">!</span><span class="n">axi_rvalid</span><span class="p">;</span></code></pre></figure>

<p>While this would meet our
<a href="/doc/axi-spec.pdf">bus requirements</a>, it would violate
our maximum <a href="https://en.wikipedia.org/wiki/Throughput">throughput</a> goal.</p>

<p>Another simple fix would be to set the <code class="language-plaintext highlighter-rouge">axi_arready</code> signal combinatorially,
so that</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="n">axi_arready</span> <span class="o">=</span> <span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">;</span></code></pre></figure>

<table align="center" style="float: right"><caption>Fig 4. Result of combinatorial axi_arready logic</caption><tr><td><img src="/img/demoaxil/demoaxil-rcomb.svg" alt="Trace showing multiple AXI-lite read transactions, where the AXI_ARREADY line is generated combinatorially" width="480" /></td></tr></table>

<p>This appears as though it might solve all of our problems.  A trace built upon
this logic is shown in Fig. 4 on the right.</p>

<p>Only it doesn’t solve our problems.  It violates our first goal, since the
<a href="/doc/axi-spec.pdf">AXI specification</a>
is quite clear: all signals, <code class="language-plaintext highlighter-rouge">axi_arready</code> included, must be registered.  That
is, they must all be  set on a clock edge.  Adjusting <code class="language-plaintext highlighter-rouge">axi_arready</code> to meet
this standard will force a single clock delay in processing.</p>

<p>If we try to register <code class="language-plaintext highlighter-rouge">axi_arready</code> while maintaining a
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a>
of one transaction per clock, then we are forced to deal
with accepting a transaction before we realize we should’ve been stalled.
Such a transaction will need to be
<a href="/blog/2017/08/14/strategies-for-pipelining.html">buffered</a>
within our core.</p>

<p>We <a href="/blog/2017/08/14/strategies-for-pipelining.html">studied how to do this back in 2017, under the name of a “buffered
handshake.”</a>
<a href="http://fpgacpu.ca/fpga/skid_buffer.html">Eric LaForest has recently posted a similar description, only he
called it a “Skid Buffer”</a>.
However, I have yet to present code that will perform this handshake here on
this blog.  Until now.</p>

<p>Sadly, the design is not trivial.
<a href="http://fpgacpu.ca/fpga/skid_buffer.html">LaForest</a>
makes it look easy, although I tend to get confused every time I try this.
Traces just don’t do it justice.  Therefore,
let’s examine how this might work through a series of figures.</p>

<table align="center" style="float: right"><caption>Fig 5. The master requests a read</caption><tr><td><img src="/img/demoaxil/demoaxil-dbl-1.svg" alt="" width="360" /></td></tr></table>

<p>We’ll start with Fig. 5 on the right.  This figure shows the beginning of the
transaction, as the master creates a read request to send to the
slave.  We’ll assume that all of the ready signals are true initially, so this
request is immediately accepted by the slave.</p>

<p>This is the way we want things to work.</p>

<p>Some might even argue that this is how slaves are normally accessed: one
cycle at a time separated by idle cycles on both sides.
This was something I discussed in <a href="https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf.pdf">my 2016 ORCONF presentation as well</a> (see slides 26-27), since
the <a href="/doc/wbspec_b4.pdf">Wishbone classic bus</a> can never
handle more than one transaction every three clocks as a result.
We’ll reflect for a moment on the reality that the
<a href="/about/zipcpu.html">ZipCPU</a>
is more than capable of issuing multiple
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
requests on adjacent clocks, and then we’ll ignore this piece of advice and
continue with a second access following immediately after the first one.</p>

<table align="center" style="float: right"><caption>Fig 6. The slave returns its first response</caption><tr><td><img src="/img/demoaxil/demoaxil-dbl-2.svg" alt="" width="360" /></td></tr></table>

<p>Fig. 6 illustrates the slave returning the initial request as a response to
the master.  This is on the next clock, so we are still meeting our maximum
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a>
requirement of a single clock.  During this time, the master
sends a second request to the slave.</p>

<p>Again, this is the way things are supposed to work.  We’re just pushing
data through at high speed, one transaction on every clock and meeting our
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a>
requirements.</p>

<table align="center" style="float: right"><caption>Fig 7. The master stalls the response channel before the second response is accepted</caption><tr><td><img src="/img/demoaxil/demoaxil-dbl-3.svg" alt="" width="360" /></td></tr></table>

<p>Fig. 7 shows the beginning of our problems.  In Fig. 7, the master
lowers his <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> signal (now shown in red), stalling the return
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
It will now take the slave another clock period, i.e. until Fig. 8, before
the slave can lower <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> since <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> is required
to be a clocked signal.  This means that the slave must accept a second
request, the request marked number three in Fig. 7, while still waiting
for its second response to the master to be accepted.</p>

<p>There’s no other way to handle this new request than to
<a href="/blog/2017/08/14/strategies-for-pipelining.html">buffer</a> this
next transaction within the slave.  This means that that the slave will need to
hold on to two separate transactions any time the read address channel is
busy while the read response channel is stalled.</p>

<table align="center" style="float: right"><caption>Fig 8. The slave now needs to stall the address channel</caption><tr><td><img src="/img/demoaxil/demoaxil-dbl-4.svg" alt="" width="360" /></td></tr></table>

<p>On the next clock, shown in Fig. 8, the slave can finally lower the
<code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> line to stall the input.  As we noted above, the slave is
required to hold onto both request number three and the second response as
long as the input ready line, <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> is stalling our whole system.
Failing to do this means that a transaction would get lost in this shuffle.</p>

<p>Now that both request and response channels have stalled, the system can remain
in this state indefinitely.</p>

<table align="center" style="float: right"><caption>Fig 9. The master releases the response channel</caption><tr><td><img src="/img/demoaxil/demoaxil-dbl-5.svg" alt="" width="360" /></td></tr></table>

<p>Eventually, the master will raise the ready line, as shown in Fig. 9 on
the right.  Once this happens, the second response can cross the channel.</p>

<p>Further, the third request can move from the <a href="/blog/2017/08/14/strategies-for-pipelining.html">internal
buffer</a>
to the output position on the next clock.</p>

<p>Because it takes a clock edge to lower the stall signal, request number four
will remain stalled this cycle.</p>

<table align="center" style="float: right"><caption>Fig 10. The slave can now release the request channel</caption><tr><td><img src="/img/demoaxil/demoaxil-dbl-6.svg" alt="" width="360" /></td></tr></table>

<p>Now when we get to Fig. 10, the slave has finally raised its ready signal,
<code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code>, meaning request number four can proceed to the response
channel finishing our example.</p>

<p>This is the concept we are going to try to implement below.</p>

<p>Usually when I start to implement something like this, I create a buffer
is-valid signal to indicate that there’s valid information in the buffer.
However, if you look back over the last several charts, you can see that any
time <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> is low, there’s data in the
<a href="/blog/2017/08/14/strategies-for-pipelining.html">buffer</a>.
Hence, we’ll use <code class="language-plaintext highlighter-rouge">!S_AXI_ARREADY</code> as our signal that we have something in
this extra
<a href="/blog/2017/08/14/strategies-for-pipelining.html">buffer</a>
position.</p>

<table align="center" style="float: right"><caption>Fig 11. The read address stall lin doesn't go low until the buffer is full</caption><tr><td><img src="/img/demoaxil/demoaxil-dbl-7.svg" alt="" width="360" /></td></tr></table>

<p>Fig. 11 illustrates the other situation that often confuses me, since I will
catch myself trying to stall the upstream channel anytime the downstream
channel is stalled.</p>

<p>That’s not how this <a href="/blog/2017/08/14/strategies-for-pipelining.html">buffered
handshake</a>
works, however.  To do this right,
the upstream channel should only stall if the downstream channel is stalled
<em>and</em> if there’s an item in the buffer.  Both criteria need to be true.</p>

<p>We’ll need this tidbit as we move forward.</p>

<p>Let’s also try to simplify things with two helper variables.  The first,
<code class="language-plaintext highlighter-rouge">valid_read_request</code>, will be true if ever there’s been a request on the
read channel, either currently or one that has since stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">valid_read_request</span>  <span class="o">=</span>  <span class="n">S_AXI_ARVALID</span> <span class="o">||</span> <span class="o">!</span><span class="n">S_AXI_ARREADY</span><span class="p">;</span></code></pre></figure>

<p>Similarly, we’ll assign <code class="language-plaintext highlighter-rouge">read_response_stall</code> to indicate that there’s a
valid response currently in the return channel but that the ready flag
is low so that it cannot move forward.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">read_response_stall</span> <span class="o">=</span>  <span class="n">S_AXI_RVALID</span>  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_RREADY</span><span class="p">;</span></code></pre></figure>

<p>So let’s work through our downstream implementation first.</p>

<p>If the downstream read channel is stalled, that means <code class="language-plaintext highlighter-rouge">axi_rvalid</code> is true
and must remain so until the stall is clear.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_rvalid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span> <span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span> <span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">read_response_stall</span><span class="p">)</span>
		<span class="c1">// Need to stay valid as long as the return path is stalled</span>
		<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Likewise if the response was valid before and the downstream response channel
was stalled, then we need to maintain the response on the output channel until
it has been accepted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">valid_read_request</span><span class="p">)</span>
		<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>In all other cases, we’ll release the response channel and lower our valid
signal, since all transactions have by now been accepted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span>
		<span class="c1">// Any stall has cleared, so we can always</span>
		<span class="c1">// clear the valid signal in this case</span>
		<span class="n">axi_rvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>But what about the data content of this channel?</p>

<p>First, I’m going to keep this simple.  Our slave will never return
any type of <a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a>.
You can read about what I dislike about allowing slaves to create
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a> in my <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
properties post</a> if you
are interested.  Not returning any
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a> means the response
type is constant.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">axi_rresp</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// "OKAY" response</span></code></pre></figure>

<p>That was too easy.</p>

<p>The response data payload is just a touch harder, although we can split into
three basic steps.</p>

<p>First, on any valid read address transaction, we’ll set the address for
our <a href="/blog/2017/08/14/strategies-for-pipelining.html">buffer</a>.
If our 
<a href="/blog/2017/08/14/strategies-for-pipelining.html">buffer</a>
doesn’t contain a valid read request, then this will just be a don’t care
address.  Even better, as long as the buffer isn’t already full, then we can
set the
<a href="/blog/2017/08/14/strategies-for-pipelining.html">buffer</a>
address independent of whether there’s a request we are accepting or not.
This helps to satisfy our minimum logic goal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">)</span>
		<span class="n">pre_raddr</span> <span class="o">&lt;=</span> <span class="n">S_AXI_ARADDR</span><span class="p">;</span></code></pre></figure>

<p>The second step is to determine which address to read from.  If our
<a href="/blog/2017/08/14/strategies-for-pipelining.html">buffer</a>
has valid data in it, then we’ll want to read from this
<a href="/blog/2017/08/14/strategies-for-pipelining.html">buffered</a>
address, <code class="language-plaintext highlighter-rouge">dly_addr</code>.  In all other cases we can read directly from the
address provided on the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">axi_arready</span><span class="p">)</span>
		<span class="n">rd_addr</span> <span class="o">=</span> <span class="n">pre_raddr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rd_addr</span> <span class="o">=</span> <span class="n">S_AXI_ARADDR</span><span class="p">;</span></code></pre></figure>

<p>The third step is to do the actual read.  In the case of a
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>,
extraneous reads never hurt.  Therefore we can read any time the outgoing
channel isn’t stalled–regardless
of whether we have an active read request or not.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_response_stall</span><span class="p">)</span>
		<span class="c1">// If the outgoing channel is not stalled (above)</span>
		<span class="c1">// then read</span>
		<span class="n">axi_rdata</span> <span class="o">&lt;=</span> <span class="n">slv_mem</span><span class="p">[</span><span class="n">rd_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">+</span><span class="n">ADDR_LSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDR_LSB</span><span class="p">]];</span></code></pre></figure>

<p>If you were implementing any
<a href="https://en.wikipedia.org/wiki/Hardware_register">hardware registers</a>
instead of a block <a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>,
this is where you would implement the read
from those <a href="https://en.wikipedia.org/wiki/Hardware_register">registers</a>.
You might also to adjust this logic as well: sometimes read transactions have
side effects, such as in my
<a href="/blog/2018/02/09/first-cyclonev.html">Cyclone-V</a> design.
In that case, you’d want to add a bit more logic, perhaps even the following:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_response_stall</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">OPT_READ_SIDEEFFECTS</span> <span class="o">||</span> <span class="n">valid_read_request</span><span class="p">))</span>
		<span class="c1">// If the outgoing channel is not stalled (above)</span>
		<span class="c1">// then read</span>
		<span class="n">axi_rdata</span> <span class="o">&lt;=</span> <span class="n">slv_mem</span><span class="p">[</span><span class="n">rd_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">+</span><span class="n">ADDR_LSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDR_LSB</span><span class="p">]];</span></code></pre></figure>

<p>That sets our response data.  Now for the upstream <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> which, as
I mentioned above, also determines when or if we have an item in our buffer.</p>

<p>The logic here starts by looking downstream.  If we have something in our
buffer or about to be in our buffer, that is if we have a
<code class="language-plaintext highlighter-rouge">valid_read_request</code>, then we’ll need to stall the upstream
channel as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_arready</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">read_response_stall</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Outgoing channel is stalled</span>
		<span class="c1">//    As long as something is already in the buffer,</span>
		<span class="c1">//    axi_arready needs to stay low</span>
		<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">valid_read_request</span><span class="p">;</span></code></pre></figure>

<p>Here’s the difficult part: If the downstream channel is stalled,
and the upstream channel is passing us data, then we need to accept the
request into our buffer and then immediately stall the upstream channel.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span>
			<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARVALID</span><span class="p">);</span></code></pre></figure>

<p>Notice that we didn’t stall the upstream channel <em>until</em> there was a valid item
in our buffer.  This is the detail I always get confused by which I illustrated
in Fig. 11 above.</p>

<p>Finally, if the outgoing response channel isn’t stalled, then we can set
the read address ready line to be ready for the next transaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span>
		<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>That’s all there is to it, although I personally find the pictures above
easier to understand than the code above.  Indeed, if it weren’t for the
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
tools, I might’ve gotten this code quite wrong.</p>

<p>One last figure in this section will illustrate how this logic works.</p>

<table align="center" style="float: right"><caption>Fig 12. A demonstration of how reads work with this core</caption><tr><td><img src="/img/xilinx-axil/axil-demo-read.svg" alt="" width="480" /></td></tr></table>

<p>Fig. 12 shows the results from a rather complex cover statement found at the
end of <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">the file</a>.
Here you can see that, yes, we did meet our requirements for both
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a> and
<a href="https://en.wikipedia.org/wiki/Latency_(engineering)">latency</a>.
The next piece of good news is that this logic passes our
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
test–but I’ll have more to say on that further down.  Finally, let me say
that I found Figs. 5-11 more instructive about what was going on that
the trace shown in Fig. 12 on the right.</p>

<p>For now, let’s turn our attention to the more difficult transaction: the
write transaction.</p>

<h2 id="write-processing">Write processing</h2>

<p>We now need to apply the lessons we just learned from the read channel to the
write channel.  The first lesson is that we’ll need a <a href="/blog/2017/08/14/strategies-for-pipelining.html">buffered
handshake</a>,
and the second lesson is that the return ready signals will also indicate
negatively whether or not buffer is full.</p>

<p>That’s the easy part.</p>

<p>If only the write channel were as easy as the read channel.  Indeed, it would
be if we were able to guarantee that the write address and write data would
both arrive at our slave at the same time.  Sadly, this is not the case.  The
<a href="/formal/2018/12/28/axilite.html">two channels, write address and write data, may be separated by up to two
clocks</a>.  We’ll need to
synchronize those two channels here, however, since we can’t perform the
write transaction internal to
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">our slave</a>
without having both the required address and the required data.  That
then will be the challenge of this section.</p>

<p>Let’s think this through for a moment before sprinting ahead this time.  We
can complete a write transaction any time the following three conditions hold.</p>

<ol>
  <li>
    <p>The outgoing response channel must not be stalled.</p>
  </li>
  <li>
    <p>We must have the address of where we need to write.  This can be
either in our buffer, or coming directly from <code class="language-plaintext highlighter-rouge">S_AXI_AWADDR</code>.  Yes, we’ll
need to buffer the address.</p>
  </li>
  <li>
    <p>We must have the data of what we wish to write as well.  This also includes
<a href="/zipcpu/2017/05/29/select-lines.html">the write strobes</a>,
indicating which bytes in our data word need to be written.  This channel
will also need to be buffered, just like the write address channel.</p>
  </li>
</ol>

<p>As before, we can use <code class="language-plaintext highlighter-rouge">!S_AXI_AWREADY</code> to indicate that we have a value in
our address buffer, and <code class="language-plaintext highlighter-rouge">!S_AXI_WREADY</code> to indicate that we have a value in our
data buffer.</p>

<p>That’s going to be our basic approach.  Now let’s just work through the
various signals.</p>

<p>Our first step will be to define some helper variables, to make the logic
below simpler.  The first will indicate that we have a valid write address,
either one coming in now or one in our buffer.  The second is the same,
but for write data.  Finally, the third helper indicates that the outgoing
channel is stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">valid_write_address</span> <span class="o">=</span> <span class="n">S_AXI_AWVALID</span> <span class="o">||</span> <span class="o">!</span><span class="n">axi_awready</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">valid_write_data</span>    <span class="o">=</span> <span class="n">S_AXI_WVALID</span>  <span class="o">||</span> <span class="o">!</span><span class="n">axi_wready</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">write_response_stall</span><span class="o">=</span> <span class="n">S_AXI_BVALID</span>  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_BREADY</span><span class="p">;</span></code></pre></figure>

<p>These three helper values will make it easier to express our logic below.</p>

<p>Let’s start with the write address channel ready signal, and the logic that
would be appropriate if there were no write data channel.  That is, set the
ready on reset, then deal with the case where the outgoing buffer is stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_awready</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">write_response_stall</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>Now when I say that the outgoing buffer is stalled, I mean that <code class="language-plaintext highlighter-rouge">S_AXI_BVALID</code>
is true and so there’s a value waiting to be returned.  I also mean that
<code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code> is false, meaning that this value can’t go any where.  This
leaves us with two conditions to check, as shown in Fig. 13 below.</p>

<table align="center" style="float: none"><caption>Fig 13. Stall conditions if the response channel is already stalled</caption><tr><td><img src="/img/demoaxil/demoaxil-wdbl-1.svg" alt="" width="720" /></td></tr></table>

<p>If the output channel is stalled and our buffer is either already full
or a new write address is available, then we need to make certain that
the write address channel is stalled.  This is the case shown on the right above.  Likewise if
the output channel is stalled and we just accepted a value, then we need to
lower the ready line of <code class="language-plaintext highlighter-rouge">S_AXI_AWREADY</code>.  This is shown on the left above.
In either case, we need to drop the ready signal for this channel.  However,
if there’s nothing in our buffer and <code class="language-plaintext highlighter-rouge">S_AXI_AWVALID</code> is low (not shown),
then we can just leave our buffer empty.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// The output channel is stalled</span>
		<span class="c1">//	If our buffer is full, we need to remain stalled</span>
		<span class="c1">//	Likewise if it is empty, and there's a request,</span>
		<span class="c1">//	  we'll need to stall.</span>
		<span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">valid_write_address</span><span class="p">;</span></code></pre></figure>

<p>That wasn’t too bad, and it was roughly identical to what we did before.</p>

<p>Now let’s look at the case where the output isn’t stalled, as shown in Fig. 14
below.</p>

<table align="center" style="float: none"><caption>Fig 14. Two conditions preceeding a write address channel being ready</caption><tr><td><img src="/img/demoaxil/demoaxil-wdbl-2.svg" alt="" width="720" /></td></tr></table>

<p>The left side of Fig. 14 shows the case where a write data is coming into our
core, and the right side shows the case where the write data is already within
our core and stalled.  In both cases, we’ll want to make certain that the write
address channel is ready to accept an associated address.</p>

<p>But what’s happening on the write address channel?  It doesn’t matter.  Either
an address is coming in or it isn’t.  If no address comes in, then the
<em>write data</em> channel will have to stall–not the <em>write address</em> channel.
We are working through the write address channel, so that doesn’t impact
us here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">valid_write_data</span><span class="p">)</span>
		<span class="c1">// The output channel is clear, and write data</span>
		<span class="c1">// are available</span>
		<span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>There’s one final condition, shown below in Fig. 15.</p>

<table align="center" style="float: none"><caption>Fig 15. What happens when the response channel is ready, but the address shows up before the data</caption><tr><td><img src="/img/demoaxil/demoaxil-wdbl-3.svg" alt="" width="720" /></td></tr></table>

<p>What happens when there’s no data available from the data channel and a valid
address shows up?  There’d be no data to go with it!  We’ll have to then stall
until there’s data ready.  Two examples of this are shown above in Fig. 15.
If neither example is fits, then we can set <code class="language-plaintext highlighter-rouge">axi_awready</code> otherwise we’ll
need to stall.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span>
		<span class="c1">// If we were ready before, then remain ready unless an</span>
		<span class="c1">// address unaccompanied by data shows up</span>
		<span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">axi_awready</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">S_AXI_AWVALID</span><span class="p">));</span></code></pre></figure>

<p>Did you get all that?</p>

<p>The write data ready signal, <code class="language-plaintext highlighter-rouge">axi_wready</code>, has the same identical logic as
that of the <code class="language-plaintext highlighter-rouge">axi_awready</code> signal save that the write data and address channel
information are reversed.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_wready</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">write_response_stall</span><span class="p">)</span>
		<span class="c1">// The output channel is stalled</span>
		<span class="c1">//	We can remain ready until valid</span>
		<span class="c1">//	write data shows up</span>
		<span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">valid_write_data</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">valid_write_address</span><span class="p">)</span>
		<span class="c1">// The output channel is clear, and a write address</span>
		<span class="c1">// is available</span>
		<span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="c1">// if we were ready before, and there's no new data avaialble</span>
		<span class="c1">// to cause us to stall, remain ready</span>
		<span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">axi_wready</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">S_AXI_WVALID</span><span class="p">);</span></code></pre></figure>

<p>What does it mean to buffer the transaction in this context?  For the write
address channel, it means capturing the incoming address.  Remember,
our buffer is valid any time <code class="language-plaintext highlighter-rouge">axi_awready</code> is low.</p>

<p>The bus requires that we capture this address any time
<code class="language-plaintext highlighter-rouge">S_AXI_AWVALID &amp;&amp; S_AXI_AWREADY</code>.  The reality, though, is that if
<code class="language-plaintext highlighter-rouge">S_AXI_AWREADY</code> is true, then we can capture the address regardless of
whether or not <code class="language-plaintext highlighter-rouge">AWVALID</code> is also true–since our address copy is a don’t
care if no request is active.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Buffer the address</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_AWREADY</span><span class="p">)</span>
		<span class="n">pre_waddr</span> <span class="o">&lt;=</span> <span class="n">S_AXI_AWADDR</span><span class="p">;</span></code></pre></figure>

<p>The same applies to the write data channel.  We’ll want to make a copy of it
any time we accept a value.  Then, if we end up accepting a value while the
output is stalled or likewise if we have no address, this will become the
buffered value waiting to be written to the address that hasn’t yet been given.</p>

<p>As before, we’ll ignore the valid signal since these registers have don’t care
values if <code class="language-plaintext highlighter-rouge">S_AXI_WREADY &amp; !S_AXI_WVALID</code> and it just simplifies our logic count.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Buffer the data</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">pre_wdata</span> <span class="o">&lt;=</span> <span class="n">S_AXI_WDATA</span><span class="p">;</span>
		<span class="n">pre_wstrb</span> <span class="o">&lt;=</span> <span class="n">S_AXI_WSTRB</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>In a moment we’ll do our write and move the operation to the output buffer.
But not until the address and data are synchronized.  Here, we pick between
either the buffered address or the incoming address for that write.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">axi_awready</span><span class="p">)</span>
		<span class="c1">// Read the write address from our "buffer"</span>
		<span class="n">waddr</span> <span class="o">=</span> <span class="n">pre_waddr</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">waddr</span> <span class="o">=</span> <span class="n">S_AXI_AWADDR</span><span class="p">;</span></code></pre></figure>

<p>Likewise, we need to pick between the buffered data and the incoming data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">axi_wready</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Read the write data from our "buffer"</span>
		<span class="n">wstrb</span> <span class="o">=</span> <span class="n">pre_wstrb</span><span class="p">;</span>
		<span class="n">wdata</span> <span class="o">=</span> <span class="n">pre_wdata</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="n">wstrb</span> <span class="o">=</span> <span class="n">S_AXI_WSTRB</span><span class="p">;</span>
		<span class="n">wdata</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>It is finally time to write to our <a href="https://en.wikipedia.org/wiki/Hardware_register">slaves
registers</a>.
Remember our three conditions for writing that we presented above?  Here
they are again: We can write if there’s a place available in the outgoing
channel, if we have a valid address, and if we have valid data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span> <span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span> <span class="p">)</span>
	<span class="c1">// If the output channel isn't stalled, and</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_response_stall</span>
		<span class="c1">// If we have a valid address, and</span>
		<span class="o">&amp;&amp;</span> <span class="n">valid_write_address</span>
		<span class="c1">// If we have valid data</span>
		<span class="o">&amp;&amp;</span> <span class="n">valid_write_data</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>It’s been a while since <a href="/zipcpu/2017/05/29/select-lines.html">I’ve discussed byte enable or select
lines</a>.  The basic
idea is that the <code class="language-plaintext highlighter-rouge">S_AXI_WSTRB</code> signal contains which of the various octets
on the bus should be written by the given value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">wstrb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">slv_mem</span><span class="p">[</span><span class="n">waddr</span><span class="p">[</span><span class="n">AW</span><span class="o">+</span><span class="n">ADDR_LSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDR_LSB</span><span class="p">]][</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>
				<span class="o">&lt;=</span> <span class="n">wdata</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wstrb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">slv_mem</span><span class="p">[</span><span class="n">waddr</span><span class="p">[</span><span class="n">AW</span><span class="o">+</span><span class="n">ADDR_LSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDR_LSB</span><span class="p">]][</span><span class="mi">15</span><span class="o">:</span><span class="mi">8</span><span class="p">]</span>
				<span class="o">&lt;=</span> <span class="n">wdata</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">8</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wstrb</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
			<span class="n">slv_mem</span><span class="p">[</span><span class="n">waddr</span><span class="p">[</span><span class="n">AW</span><span class="o">+</span><span class="n">ADDR_LSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDR_LSB</span><span class="p">]][</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span>
				<span class="o">&lt;=</span> <span class="n">wdata</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wstrb</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
			<span class="n">slv_mem</span><span class="p">[</span><span class="n">waddr</span><span class="p">[</span><span class="n">AW</span><span class="o">+</span><span class="n">ADDR_LSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">ADDR_LSB</span><span class="p">]][</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span>
				<span class="o">&lt;=</span> <span class="n">wdata</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">];</span>
	<span class="k">end</span></code></pre></figure>

<p><a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">Vivado’s auto-generated slave core</a>
uses a <code class="language-plaintext highlighter-rouge">for</code> loop to walk through the various select lines and their associated
bytes.  While this works, I find it harder to read than the code above.
Further, since <a href="https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf">Xilinx requires</a>
that the <a href="/formal/2018/12/28/axilite.html">AXI-lite bus</a>
be only ever 32-bits wide, the code above should still be widely applicable.</p>

<p>That leaves only one step left: adjusting <code class="language-plaintext highlighter-rouge">axi_bvalid</code> to acknowledge
that a write has taken place.  The code below almost follows our three
conditions above, though it skips the first one.  As it turns out, it doesn’t
matter if the output is valid but the bus master isn’t ready:
we’ll set <code class="language-plaintext highlighter-rouge">S_AXI_BVALID</code> high either way using the logic below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_bvalid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span> <span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span> <span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_bvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="c1">// The outgoing response channel should indicate a valid write if ...</span>
		<span class="c1">// 1. We have a valid address, and</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">valid_write_address</span>
			<span class="c1">// 2. We had valid data</span>
			<span class="o">&amp;&amp;</span> <span class="n">valid_write_data</span><span class="p">)</span>
		<span class="c1">// It doesn't matter here if we are stalled or not</span>
		<span class="c1">// We can keep setting ready as often as we want</span>
		<span class="n">axi_bvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">)</span>
		<span class="c1">// Otherwise, if BREADY was true, then it was just accepted</span>
		<span class="c1">// and can return to idle now</span>
		<span class="n">axi_bvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Oops, I forgot one: as with the read channel, our write response won’t return
any <a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">axi_bresp</span> <span class="o">=</span> <span class="mb">2'b0</span><span class="p">;</span>	<span class="c1">// "OKAY" response</span></code></pre></figure>

<p>That’s what it takes to write to an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">AXI slave
peripheral</a>
tuned for high
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a>.
I hope the pictures along the way helped.  I know I tend to struggle getting
the logic right for a basic <a href="/blog/2017/08/14/strategies-for-pipelining.html">buffered
handshake</a>
as we’ve done above.  Without the
<a href="/blog/2017/10/19/formal-intro.html">verification component</a>,
I’m not sure I’d have much confidence doing this.</p>

<p>Fig. 16 below shows an example trace drawn from the logic of this core.</p>

<table align="center" style="float: none"><caption>Fig 16.  Write demonstration through an improved AXI-lite core</caption><tr><td><img src="/img/xilinx-axil/axil-demo-write.svg" alt="" width="780" /></td></tr></table>

<p>The left side of this trace shows several examples of how the logic might stall.
The right side, on the other hand, shows that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">this core</a>
truly can handle one transaction per clock.</p>

<p>Shall we discuss what it takes to verify
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">this design</a>?
It’s actually <em>really</em> easy to do now that we have a <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal property
list</a>
put together for the <a href="/doc/axi-spec.pdf">AXI-lite bus</a>.</p>

<h2 id="verification">Verification</h2>

<p><a href="/blog/2017/10/19/formal-intro.html">Verifying</a>
this design isn’t all that much more difficult than <a href="/formal/2018/12/28/axilite.html">the last design
we verified</a>.  Really,
it isn’t.</p>

<p>The first step is to instantiate our set of <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">AXI-lite bus
properties</a>.
This big ugly block of code only looks that way because there are so many
signals associated with this protocol.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="c1">// Allow a maximum of 2^4-1 or 15 transactions to be in flight at</span>
	<span class="c1">// any given time</span>
	<span class="k">localparam</span>	<span class="n">F_LGDEPTH</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="kt">wire</span>	<span class="p">[(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_axi_awr_outstanding</span><span class="p">,</span>
					<span class="n">f_axi_wr_outstanding</span><span class="p">,</span>
					<span class="n">f_axi_rd_outstanding</span><span class="p">;</span>

	<span class="n">faxil_slave</span> <span class="p">#(.</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="p">(</span><span class="n">C_S_AXI_ADDR_WIDTH</span><span class="p">),</span>
			<span class="p">.</span><span class="n">F_LGDEPTH</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="p">))</span>
		<span class="n">properties</span> <span class="p">(</span>
		<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_reset_n</span><span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_awaddr</span><span class="p">(</span><span class="n">S_AXI_AWADDR</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awcache</span><span class="p">(</span><span class="mh">4'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awprot</span><span class="p">(</span><span class="n">S_AXI_AWPROT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awvalid</span><span class="p">(</span><span class="n">S_AXI_AWVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awready</span><span class="p">(</span><span class="n">S_AXI_AWREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_wdata</span><span class="p">(</span><span class="n">S_AXI_WDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wstrb</span><span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wvalid</span><span class="p">(</span><span class="n">S_AXI_WVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wready</span><span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_bresp</span><span class="p">(</span><span class="n">S_AXI_BRESP</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bvalid</span><span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bready</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_araddr</span><span class="p">(</span><span class="n">S_AXI_ARADDR</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arprot</span><span class="p">(</span><span class="n">S_AXI_ARPROT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arcache</span><span class="p">(</span><span class="mh">4'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arvalid</span><span class="p">(</span><span class="n">S_AXI_ARVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arready</span><span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_rdata</span><span class="p">(</span><span class="n">S_AXI_RDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rresp</span><span class="p">(</span><span class="n">S_AXI_RRESP</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rvalid</span><span class="p">(</span><span class="n">S_AXI_RVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rready</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">f_axi_rd_outstanding</span><span class="p">(</span><span class="n">f_axi_rd_outstanding</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_axi_wr_outstanding</span><span class="p">(</span><span class="n">f_axi_wr_outstanding</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_axi_awr_outstanding</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span><span class="p">));</span></code></pre></figure>

<p>If I wasn’t interested in passing
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
I might be willing to stop right here.  However,
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
is a powerful tool and I’ve learned to depend on its ability to prove that
a design will maintain a set of properties for all time.</p>

<p>So let’s look at the few properties that are necessary for passing the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
step.</p>

<p>Let’s start by examining three read properties.  First, if <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> is
low, then there shouldn’t be any outstanding read transactions at all.  Our
code should match the counter from within our
<a href="/formal/2018/12/28/axilite.html">property set</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_rd_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>Second, if the output is valid but stalled, then we may have accepted either
one or two read requests.  If we have something in our buffer, then
<code class="language-plaintext highlighter-rouge">axi_arready</code> will be low and we will have accepted two requests.  In all other
examples, we’ll have only accepted one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_rd_outstanding</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">axi_arready</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>Those same properties can now be applied to our write channel, but with one
subtle difference.  The write channel contains two separate channels whose
counts must be checked.</p>

<p>First, if the output is valid then each channel, address and data, must have
accepted at least one request.  The two channels may have accepted a second
request as well, but only if they currently have one
<a href="/blog/2017/08/14/strategies-for-pipelining.html">buffered</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">axi_bvalid</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span> <span class="o">==</span> <span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">axi_awready</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_wr_outstanding</span>  <span class="o">==</span> <span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">axi_wready</span>  <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span></code></pre></figure>

<p>On the other hand, if no output is valid, then each channel must either have
nothing outstanding, or it must have one valid and be waiting on the other
channel.  These two options are shown in Fig. 17 below.</p>

<table align="center" style="float: none"><caption>Fig 17. A demonstration of how reads work with this core</caption><tr><td><img src="/img/demoaxil/demoaxil-wdbl-4.svg" alt="" width="720" /></td></tr></table>

<p>They are described in properties below.  Note that it is an error for both
buffers to contain a value if <code class="language-plaintext highlighter-rouge">axi_bvalid</code> is false.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span> <span class="o">==</span> <span class="p">(</span><span class="n">axi_awready</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_wr_outstanding</span>  <span class="o">==</span> <span class="p">(</span><span class="n">axi_wready</span>  <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">axi_awready</span> <span class="o">||</span> <span class="o">!</span><span class="n">axi_wready</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>You can find a <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a> <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/demoaxi.sby">script
for this core here</a>.
Only twenty six steps are necessary to prove that we meet all of the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">bus
properties</a>
I presented in our <a href="/formal/2018/12/28/axilite.html">last AXI-lite
article</a>.</p>

<h2 id="cover-properties">Cover properties</h2>

<p>Only one requirement remains to be shown from our initial goals above.  We’ve
shown that we can meet our
<a href="/doc/axi-spec.pdf">bus interface requirements</a>, but can
we truly accomplish maximum
<a href="https://en.wikipedia.org/wiki/Throughput">throughput</a>
as we wanted?</p>

<p>Let’s see if we can push four values through this slave, retiring one read
on each of four clocks.  If <code class="language-plaintext highlighter-rouge">S_AXI_RVALID &amp;&amp; S_AXI_RREADY</code> will be true any time
a return value is accepted, than if this value is high for four clocks in
a row we’ll know
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">our core</a>
has the ability to as fast as <a href="/doc/axi-spec.pdf">the
specification</a>
will allow it to go.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span> <span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span> <span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">))</span>
		<span class="k">cover</span><span class="p">(($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RREADY</span><span class="p">)))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RREADY</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RREADY</span><span class="p">),</span><span class="mi">3</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RREADY</span><span class="p">));</span></code></pre></figure>

<p>Why four clocks though?  Because I wanted some confidence that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">this core</a>
could truly handle retiring one request per clock without requiring it
be stalled while the pipeline filled up.</p>

<p>The same approach applies to the return path.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span> <span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span> <span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">))</span>
		<span class="k">cover</span><span class="p">(($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_BREADY</span><span class="p">)))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_BREADY</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_BREADY</span><span class="p">),</span><span class="mi">3</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_BREADY</span><span class="p">));</span></code></pre></figure>

<p>That concludes our examination of
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">this core</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`endif</span>
<span class="k">endmodule</span></code></pre></figure>

<p>We’ve now not only built an interface with a <a href="/blog/2017/08/14/strategies-for-pipelining.html">buffered
handshake</a>,
but we’ve also managed to
<a href="/blog/2017/10/19/formal-intro.html">verify</a>
that it works.  Indeed, I would have no
confidence that this worked were it not for the <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>.</p>

<p>Let me share another secret with you: Often, while writing articles like this
one, I’ll find something I want to tweak in the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">example code I’m presenting</a>.
Usually
this is to make the code easier to read and explain, although sometimes I
touch things up to remove extraneous logic as well.  However,
I also want to make certain that the slightly changed code still works.  As a
result, every time I make a change I’m re-running the <a href="/blog/2017/10/19/formal-intro.html">formal verification
proof</a> to
make certain I haven’t introduced changes in the process.  Usually this means
I can greatly simplify a design for presentation.  In this case, the
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
tools also caught a check for <code class="language-plaintext highlighter-rouge">if (ready &amp;&amp; ready)</code> instead of
<code class="language-plaintext highlighter-rouge">if (valid &amp;&amp; ready)</code>.</p>

<p>I might argue that
<a href="/blog/2017/10/19/formal-intro.html">formally verifying</a>
<a href="/doc/axi-spec.pdf">AXI-lite</a>
designs is really easy when
using <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>!  If you haven’t
tried it yourself, let me encourage you to do
so.  Just the ability to <a href="/formal/2018/12/28/axilite.html">verify an AXI-lite
core</a> alone and find bugs
that Xilinx’s VIP wasn’t able to find should give you some confidence when using
the tool.  Wait, did I just say their VIP couldn’t find these bugs?  While I
really don’t know that to be the case, I am drawn to such a conclusion.  I mean,
why would they publish a broken code generator unless they had tried to verify
it only to receive a false positive suggesting that it worked when it didn’t?</p>

<h2 id="conclusion">Conclusion</h2>

<p>This is now the second article in a short series about the <a href="/doc/axi-spec.pdf">AXI-lite
bus</a>.  The
<a href="/formal/2018/12/28/axilite.html">first article</a>
discusses how I created the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">AXI-lite property
file</a>
which was used to verify <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">the slave
implementation</a>
we discussed above.</p>

<p>The <a href="https://github.com/ZipCPU/wb2axip">repository containing</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">this core</a>
also contains several bridge cores to include an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axlite2wbsp.v">AXI-lite to
wishbone core</a>,
a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axilite.v">wishbone to AXI-lite
bridge</a> and
even a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">Wishbone to full AXI
bridge</a>.  If you
look around, you might also notice that I have a similar property files posted
there for both the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/fwb_slave.v">Wishbone</a>
and <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/fav_slave.v">Avalon</a> <a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>.</p>

<p>I’d like to come back to this topic in the future and discuss a <a href="/doc/axi-spec.pdf">full
AXI</a>
to <a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>
bridge as well as the properties necessary to verify it.  That
project and post, however, will need to wait for another day.</p>

<p>Another potential future post would be to discuss how easy it can be to build
the complex cover statements used to demonstrate
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">this core</a>
above.  Such an approach would <a href="/formal/2019/02/21/txuart.html">offer an alternative to the <code class="language-plaintext highlighter-rouge">sequence</code>s that
SVA supports</a> but which the
free version of <a href="http://www.clifford.at/yosys">Yosys</a>
does not.  That will also need to wait for another day as well.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Judgment also will I lay to the line, and righteousness to the plummet: and the hail shall sweep away the refuge of lies, and the waters shall overflow the hiding place. (Is 28:17)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
