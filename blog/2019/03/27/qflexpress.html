<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a universal QSPI flash controller</title>
  <meta name="description" content="Fig 1. Typical flash memory chip I/O">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2019/03/27/qflexpress.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building a universal QSPI flash controller</h1>
    <p class="post-meta"><time datetime="2019-03-27T00:00:00-04:00" itemprop="datePublished">Mar 27, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. Typical flash memory chip I/O</caption><tr><td><img src="/img/spix/spix-io-pins.svg" alt="" width="360" /></td></tr></table>

<p><a href="https://en.wikipedia.org/wiki/Flash_memory">Flash</a> is an important component
in any <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design, and a vital component in any
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core CPU design</a>).
First, many <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
load their configurations on power up from
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  Thus, if you want your
configuration to load from non-volatile memory and without using the
<a href="https://en.wikipedia.org/wiki/JTAG">JTAG</a>,
placing your design into the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
memory is often a requirement.  The good news is that this means most
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
development boards already include a
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory for configuration.  The
even better news is that <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips
are cheap enough that there’s usually plenty of space available for user
applications in addition to the configuration memory.</p>

<p>Just think through those possibilities: what would you do in your design
if you had non-volatile memory available to you?  Even better, what if you
had 8-16MB of non-volatile memory available?</p>

<p>Now, before you get too excited, be aware: there’s usually a beginner out there
who thinks that <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> can be treated
like normal memory.  No, I’m sorry, it can’t.  While  you can read from
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> fairly quickly, writing to
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> is more problematic.  If you want
to change something in <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, you have
the choice of erasing the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>–that
is to turn bits to ones and hence the bytes to <code class="highlighter-rouge">8'hff</code>, and then programming the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
also known as turning bits to zeros.  Of these two, the erase is the most
problematic.  Depending on the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
you might only be able to erase 64kB blocks at a time.  (Yes, some
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips allow 2kB sub-sector erase
operations.)  Worse, a sector erase command will take anywhere between a half
second and two seconds.  It is slow.</p>

<p>For these reasons, <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory make a good ROM addition to your design.</p>

<p>As <a href="/blog/2018/08/16/spiflash.html">I’ve written before</a>, I’ve
now created several <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> designs in
support of my own <a href="/about/zipcpu.html">ZipCPU</a> development.</p>

<p>Today’s story, though, starts with the <a href="https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists">Arty
board</a>,
now sold by <a href="https://store.digilentinc.com">Digilent</a> under the name <a href="https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists">Arty
A7</a>.
This is a wonderful starter board for anyone who wants to try building their
own embedded <a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a>: it has
a decent sized
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
<a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>,
a 100Mbps <a href="https://en.wikipedia.org/wiki/Ethernet">ethernet port</a>, a couple of
switches, buttons, LEDs, some <em>color</em> LEDs, four PMod ports and … 16MB of
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory.</p>

<p>When I first built <a href="https://github.com/ZipCPU/openarty">my own design</a> for the
<a href="https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists">Arty</a>,
<a href="https://store.digilentinc.com">Digilent</a> shipped it with a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip built by <a href="https://www.micron.com">Micron</a>.  Sadly, my <a href="https://github.com/ZipCPU/qspiflash/blob/6fa93fb810c9e091f6608d58f7b3887870b3747f/rtl/wbqspiflash.v">original flash
controller</a> couldn’t handle this
<a href="https://www.micron.com">Micron</a> <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
device.  Why?  Because for a common standard such as <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">Quad-SPI
(QSPI)</a>,
the <a href="https://www.cypress.com/spansion-redirect">Spansion</a> and
<a href="https://www.micron.com">Micron</a> chips were just too different
for my controller.  Well, that and I originally wanted to build a 200MHz
design, but that’s a different story for a different day.</p>

<p><a href="https://www.micron.com">Micron</a>’s
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> implementation had the problem
that it was difficult to reset.  There were modes the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> could get into where, if you
reloaded your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design, the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> might no longer
respond the way you thought it should.  Worse,
<a href="https://www.micron.com">Micron</a>’s design offered settings under which the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> might power up into a state
unknown to the design.  These extra modes were “features”, designed to help you
achieve high speed operation immediately on start up.  To me, however, they
were liabilities, since it became that much harder to know if <a href="https://github.com/ZipCPU/qspiflash/blob/6fa93fb810c9e091f6608d58f7b3887870b3747f/rtl/eqspiflash.v">my
controller</a>
would work.  I complained about this, and sometime later
<a href="https://store.digilentinc.com">Digilent</a> modified the board to use a
different <a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>.</p>

<p>Of course, this only happened after I finally had a design that worked with
the <a href="https://www.micron.com">Micron</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> device.</p>

<p>Worse, I only discovered that <a href="https://store.digilentinc.com">Digilent</a>
had swapped <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips when <a href="https://github.com/ZipCPU/openarty/issues/1">someone
tried to use</a> my <a href="https://github.com/ZipCPU/openarty">OpenArty
design</a>, only to discover the new
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> was incompatible with the old
<a href="https://github.com/ZipCPU/qspiflash/blob/6fa93fb810c9e091f6608d58f7b3887870b3747f/rtl/eqspiflash.v">controller</a>.</p>

<p>It was now time to build a <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">new flash
controller</a>.
Again.  The question before me, though, was whether it might be possible to
build a single <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">Quad-SPI</a>
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">controller</a>
that I could re-use with any <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
device I came across.</p>

<p>This blog article is about the design and verification of that <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">new Quad-SPI
flash
controller</a>.</p>

<h2 id="requirements">Requirements</h2>

<p>No, I do not believe in top-down, requirements driven development.  As <a href="/blog/2018/08/16/spiflash.html">we
discussed in the last article, this flash controller is not the first flash
controller I’ve ever built</a>.  Reality seems to dictate that <a href="https://en.wikipedia.org/wiki/Spiral_model">spiral
development</a>, or other
<a href="https://en.wikipedia.org/wiki/Iterative_and_incremental_development">iterative development</a> approaches work better.
Indeed, I’m slowly becoming a believer in <a href="https://en.wikipedia.org/wiki/Iterative_and_incremental_development">incremental design</a> approaches.</p>

<p>Still, it makes sense to start the story off with a discussion of what a
“better” <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller would look like.  What should it do, and what
functions should it support?</p>

<p>First and foremost, any <a href="https://github.com/ZipCPU/qspiflash">flash controller</a>
must be able to read from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a>.
This is the basic requirement, without which we will fail.</p>

<p>When <a href="/blog/2018/08/16/spiflash.html">we last built a SPI flash
controller</a>, it
could read one word every 64 (8+24+32) clock cycles, as shown in
Fig. 2 below.</p>

<table align="center" style="float: none"><caption>Fig 2: Basic SPI read transaction</caption><tr><td><a href="/img/spix/spi-bare.svg"><img src="/img/spi-bare.svg" alt="" width="720" /></a></td></tr></table>

<p>On the other hand, if you want to build a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller that stands out
when compared to other controllers, a one-size-fits most controller, or
even, as I’ve started to call this, a <em>Universal QSPI flash controller</em>,
then you need to do more than just read values from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>: you need to
read them <em>fast</em>.  How fast?  As fast as the device will support a read
using logic synchronous to the rest of the design.</p>

<p>This will force us not only into the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">Quad-SPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> territory, where <em>four</em>
data lines are strapped together, but it’s also going to have us looking
at whether or not we can keep the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
clock running at the same
rate as the system clock rate.  For my <a href="https://github.com/ZipCPU/openarty">OpenArty design</a>, this means I am going
want to run my
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> at a 100MHz clock rate–twice as fast as most
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
controllers.  Since most
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> devices support 108Mhz, I figured I should be good here.  Hence,
this was my second criteria: running the in
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
mode, with the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
<code class="highlighter-rouge">SCK</code> line
running at the system clock rate.</p>

<table align="center" style="float: none"><caption>Fig 3: Basic QSPI read transaction</caption><tr><td><a href="/img/qspi/qspi-bare.svg"><img src="/img/qspi/qspi-bare.svg" alt="" width="720" /></a></td></tr></table>

<p>This gets us down to 28 (8+6+6+8) <code class="highlighter-rouge">SCK</code> clock cycles per read.</p>

<p>If you are working to achieve speed, however, this still isn’t fast enough.</p>

<p>Most <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> devices offer a mode where, after one <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> command you can leave
the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> in some sort of
eXecute-In-Place (XIP) mode.  In this mode, the next
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> command starts immediately
by sending a 24-bit address, then after some amount of wait, you can read
your data.  This will save us 8
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> clock cycles by not needing to
send a new <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> read command.</p>

<table align="center" style="float: none"><caption>Fig 4: QSPI transaction, starting from XIP mode</caption><tr><td><a href="/img/qspi/qspi-xip.svg"><img src="/img/qspi/qspi-xip.svg" alt="" width="720" /></a></td></tr></table>

<p>We’re now at 20 (6+6+8) <code class="highlighter-rouge">SCK</code> cycles per read.</p>

<p>This still isn’t fast enough for me: I wanted to build a
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash controller</a>
that can handle burst reads.</p>

<p>By “burst reads”, I mean I wanted my
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash controller</a>
to be able to read multiple words in the same transaction.  The first word
will require sending an address and several
dummy cycles, before using up eight clocks for the data.  If we want to keep
reading, we can then arrange for the second and subsequent words to take
no more than 8 <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
additional clocks each.</p>

<table align="center" style="float: none"><caption>Fig 5: QSPI transaction, continuing the last transaction</caption><tr><td><a href="/img/qspi/qspi-pipe.svg"><img src="/img/qspi/qspi-pipe.svg" alt="" width="720" /></a></td></tr></table>

<p>This brings us to 12+8N (6+6+8N) <code class="highlighter-rouge">SCK</code> cycles per N reads,
asymptoting at 8-cycles per read.</p>

<p>Now that’s a <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">fast QSPI flash controller</a>!</p>

<p>Yes, there is a faster mode supported by some <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chips where
the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip returns its data on both edges of the clock.  We’ll save the
investigation of those chips and that mode for a later time.</p>

<p>But what about programming the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>?  Sure, I could use the vendor tools to program my
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, but … I like to have as
much control over my design as I can get.  Therefore, I want an option whereby
I can erase and program my
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> device via <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">my own
controller</a>.</p>

<table align="center" style="float: right"><caption>Fig 6: Issuing an arbitrary 8-bit command</caption><tr><td><a href="/img/qspi/qspi-8bcmd.svg"><img src="/img/qspi/qspi-8bcmd.svg" alt="" width="360" /></a></td></tr></table>

<p>In addition, modern <a href="https://en.wikipedia.org/wiki/Flash_memory">Flash</a> devices
support many features beyond just erasing and
programming their memory region.  Many of them also support an identification
code, whereby you can determine the make and size of your device.  They
might also support “One-Time-Programmable” memory regions–allowing designers
to place special, often build-specific cryptographic data into the devices
they then send to customers.</p>

<p>Supporting all of these features would be nice, but only if they didn’t cumber
the basic read capability of the controller.  So let’s make this capability an
option, and then work to make it a cheap option that doesn’t expand our
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">controller</a>
by all that much.</p>

<p>As we’ll see later, the read-manufacturer ID command support didn’t turn out
to be an optional feature.  Indeed, I needed to use it to get the design
working in the first place–but more on that when we get there.</p>

<p>Ok, how have we done?  Have we finally specified the perfect
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>?
Is this finally everything we need from a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>?</p>

<p>I thought so at first.  So, after building it, I was quite pleased with
my work.</p>

<p>Then my requirements started falling apart.</p>

<p>Most <a href="https://www.xilinx.com">Xilinx</a> designs, you see, require that the
<a href="https://www.xilinx.com">Xilinx</a> startup sequence be able
to control the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> I/O pins
independent of the design.  The unfortunate result is that you can only access
the <code class="highlighter-rouge">SCK</code>
(<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
serial clock) pin through a special <a href="https://www.xilinx.com/support/documentation/user_guides/ug470_7Series_Config.pdf">STARTUPE2
primitive</a>.
Should you need to use this primitive, you’ll lose your access to the <a href="https://www.xilinx.com/support/documentation/user_guides/ug471_7Series_SelectIO.pdf">ODDR
primitive</a>
necessary to control the clock.</p>

<p>The <a href="https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists">Arty</a>
is an unusual development board, in a good way, because it doesn’t have this
problem.  <a href="https://store.digilentinc.com">Digilent</a> <a href="https://reference.digilentinc.com/reference/programmable-logic/arty-a7/reference-manual">created a second I/O pin
which they also tied to the <code class="highlighter-rouge">SCK</code>
pin</a>.
Hence, we can still get system clock rate I/O (100MHz) from our <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>.</p>

<p>My <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">Nexys Video board</a>
wasn’t so lucky.  Neither was my
<a href="https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/">Basys3 board</a>.
Both of these boards require that CCK line (configuration clock) going to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> <code class="highlighter-rouge">SCK</code> pin must go through the
<a href="https://www.xilinx.com/support/documentation/user_guides/ug470_7Series_Config.pdf">STARTUPE2 primitive</a>.
Hence, these design will need to use a <code class="highlighter-rouge">50MHz</code> <code class="highlighter-rouge">SCK</code>.</p>

<p>Strangely, that wasn’t my first problem.</p>

<p>The first problem I realized in my brand new, awesome <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>
design was when someone contacted me to see if they could use my older
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller in an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> project.</p>

<p><em><a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>s!!?!</em>
That changes things a lot!
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>s tend to run at
higher clock rates, whereas most
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> devices max out at around
108MHz.  Worse, an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> chip
may (or may not) have an ODDR I/O controller in the first place.  To even dream
of <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> device support,
I really needed an arbitrary clock divider.</p>

<p>Since I don’t normally build
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>
designs, I’ll be up front: this new design doesn’t (officially) support
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>s, although I think
it could easily be modified to do so.  In particular, I’ve discovered several
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> devices have different numbers
of “dummy” cycles.  Were I to rebuild this design for an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> part, I’d want to
support a varying number of dummy  cycles.  I might also want to support a
run-time adjustable
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
clock speed.</p>

<table align="center" style="float: none"><caption>Fig 7: Using a logic generated SCK at half speed</caption><tr><td><a href="/img/qspi/qspi-halfck.svg"><img src="/img/qspi/qspi-halfck.svg" alt="" width="720" /></a></td></tr></table>

<p>Still, I added a parameterizable clock divider to my “universal” controller.
If nothing else, this would solve the problem with my <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">Nexys
Video</a> and
<a href="https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/">Basys3</a> boards.</p>

<p>That wasn’t my last problem either.</p>

<p>As it turns out, if you want to operate using DDR I/O modes, you may need to
register your outputs and then your inputs for better performance.  This
places a delay between when the logic is valid within your design, and a later
time when the value comes back from the pin.  This delay is non-zero.  On a
<a href="https://www.xilinx.com">Xilinx</a> chip, there’s a rough 3-clock delay.  (I’m
still investigating whether or not I can drop it two 2-clocks.)
<a href="https://www.intel.com">Intel chips</a> can do this with a 2-clock delay.  In
other words, the delay needs to be parameterizable.</p>

<table align="center" style="float: none"><caption>Fig 8: Input, marked as INPT below, is delayed 3-clocks from when the output (OUT) leaves our controller </caption><tr><td><a href="/img/qspi/qspi-xdelay.svg"><img src="/img/qspi/qspi-xdelay.svg" alt="" width="720" /></a></td></tr></table>

<table align="center" style="float: right"><caption>Fig 9: Franken IP?</caption><tr><td><img src="/img/qspi/qspi-frankenip.svg" alt="" width="360" /></td></tr></table>

<p>This was when I started wondering if my requirements had diverged so much
that I was now building a “FrankenIP”.  Nevertheless, I pressed on, being
certain that somewhere, within this <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">Universal IP
core</a>
that there was a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
flash controller trying to break free.</p>

<p>Did I mention that, on top of all these other requirements I wanted a controller
that only had a minimum amount of logic?  This is going to dictate, below,
that all of these options we are working with will need to be created using
<code class="highlighter-rouge">parameter</code>s and generate blocks, but that’s still easy enough to handle.</p>

<p>The difficult part is going to be verifying that all of these various
configurations work, while only having the hardware to test a couple of them.</p>

<p>Before leaving this section, let’s summarize our choices in terms of
latency and throughput in Fig. 10 below.</p>

<table align="center" style="float: none"><caption>Fig 10: Predicted access latency, excluding bus latencies</caption><tr><td><img src="/img/qspi/qspi-latency.png" alt="" width="722" /></td></tr></table>

<p>The top of this chart shows the number of clocks required for each part of a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
interaction.  The basic transaction costs 8 clocks for the command
word, followed by another 6 clocks to send 24-bits of address 4-bits at a time.
After this point, the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip might require between 1 and 10 “dummy cycles”.  This is an annoying
requirement necessary to support <a href="https://www.micron.com">Micron</a> flash chips.  <a href="https://www.winbond.com/hq/?_locale=en">Winbond</a> and
<a href="https://www.cypress.com/spansion-redirect">Spansion</a> flash chips have a fixed number of dummy cycles: six–so we’ll use that
going forward for our calculations.  Following the dummy cycles, it
takes 8 clocks to transfer one 32-bit word of information.</p>

<p>These are the numbers we’re dealing with.</p>

<p>Now for the controller options.  Our last controller, operating in
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> mode
alone, took 64 clock cycles to transfer a word.  Switching to
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">Quad-SPI</a>
alone brings us down to 28 cycles.  Using the eXecute In Place mode allows
us to then skip the eight clocks of the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
I/O command, bringing our access time down another 8 cycles to 20 cycles.  The
next request, however, will require another 20 cycles.  On the other hand, if
we can string multiple requests for sequential addresses together into the
same request, using the pipelined mode of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
we can drop our access time from <code class="highlighter-rouge">20N</code> clocks for <code class="highlighter-rouge">N</code> values down to <code class="highlighter-rouge">12+8N</code>
clock cycles.</p>

<p>This is about as fast as a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
controller will get.</p>

<p>If you have to use the CCK port of a <a href="https://www.xilinx.com">Xilinx</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
you’re clock rate will be
slowed down by at least 2x.  I placed another clock in the chart above, to
allow the <code class="highlighter-rouge">SCK</code> to go low after the <code class="highlighter-rouge">CS_n</code> line becomes active.  Then, if you are
using the registered <a href="https://www.xilinx.com">Xilinx</a>
<a href="https://www.xilinx.com/support/documentation/user_guides/ug471_7Series_SelectIO.pdf">DDR primitives</a>,
you’ll be required to slow down another three clocks.</p>

<p>The <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">“Universal” QSPI flash
core</a>
can therefore provide performance somewhere between
<code class="highlighter-rouge">12+8N</code> clocks and <code class="highlighter-rouge">28+16N</code> clocks per word, depending upon how it is set up,
how your board is designed, and the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip on that board.</p>

<h2 id="timing-control-loop">Timing control loop</h2>

<p>Let’s start out with our <a href="/blog/2017/06/02/generating-timing.html">timing
control</a>, because
the <a href="/blog/2017/06/02/generating-timing.html">timing control</a>
signals are going to be pervasive throughout the rest of
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">the core</a>.</p>

<table align="center" style="float: right"><caption>Fig 11: CSn, and SCK</caption><tr><td><img src="/img/qspi/qspi-sckck.svg" alt="" width="360" /></td></tr></table>

<p>In our highest speed configuration, we’re going to want to handle an <code class="highlighter-rouge">SCK</code>
signal equal to our controllers clock rate.  Such a signal might generate
an output looking like Fig. 11 on the right.  In this figure, the <code class="highlighter-rouge">w_qspi_sck</code>
control signal is being used to control the final <code class="highlighter-rouge">o_qspi_sck</code> output.  (I’ll
also confess, these are top-level signal names.  Within
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">the core</a>,
I’ve used <code class="highlighter-rouge">o_qspi_sck</code> to reflect the signal shown at the right labeled
<code class="highlighter-rouge">w_qspi_sck</code>.  In the non-ODDR modes, there’s no difference between these
two signals, only in the ODDR mode.)</p>

<p>Of course, we’ll want to be able to slow this clock down as well, so let’s
create several signals from a basic clock divider circuit that we can use
to control our logic below in the presence of a slower clock.  These
extra signals are shown in Fig. 12 below.</p>

<table align="center" style="float: none"><caption>Fig 12: Clock control signals</caption><tr><td><a href="/img/qspi/qspi-ckstb.svg"><img src="/img/qspi/qspi-ckstb.svg" alt="" width="720" /></a></td></tr></table>

<p>The <code class="highlighter-rouge">CS_n</code> and <code class="highlighter-rouge">SCK</code> signals are part of the basic
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
protocol.  If <code class="highlighter-rouge">CS_n</code>
is inactive (high), then the other
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">SPI</a>
signals, primarily clock and data, are allowed to be anything so that they
can be multiplexed together in order to control several chips.  The <code class="highlighter-rouge">SCK</code>
signal controls the basic data transfer, and so we’ll focus on making sure
the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">SPI</a>
data values only ever change when <code class="highlighter-rouge">SCK</code> falls.</p>

<p>The other clock control signals are:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">ckstb</code>: True when it’s time to move to the next set of output values.</p>

    <p>In a DDR output mode, this will be true on every cycle during a transaction.
If we are dividing the clock by two, this will be true every other cycle.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ckneg</code>: True when it’s time to set the <code class="highlighter-rouge">SCK</code> signal low</p>

    <p>Since we’ll only set <code class="highlighter-rouge">SCK</code> low at the beginning of a cycle, this signal is
just a pseudonym for the <code class="highlighter-rouge">ckstb</code> signal above.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ckpos</code>: True when it’s time to set the <code class="highlighter-rouge">SCK</code> signal high</p>

    <p>This will take place mid-cycle.</p>

    <p>Of course, if we are in a DDR output mode, that is with <code class="highlighter-rouge">SCK</code> toggling at the
system clock rate, then this doesn’t nearly have as much meaning, so we’ll
leave it high.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ckpre</code>: Some of the logic below will require an extra clock cycle to prepare
for the next transition.  This is the purpose of <code class="highlighter-rouge">ckpre</code>.  It is designed
so as to be true on the clock cycle prior to <code class="highlighter-rouge">ckstb</code>.</p>
  </li>
</ul>

<p>The code within this section is parameterized by several pieces.  The first is
the clock division parameter, <code class="highlighter-rouge">OPT_CLKDIV</code>.  We’ll use this to control a clock
divider in a moment.  The second parameter, really a <code class="highlighter-rouge">localparam</code>, is the
<code class="highlighter-rouge">OPT_DDR</code> parameter.  We’ll set this any time <code class="highlighter-rouge">OPT_CLKDIV == 0</code>, and use
it to indicate that we are driving the <code class="highlighter-rouge">SCK</code> line at our full system clock rate,
using an <code class="highlighter-rouge">ODDR</code> output primitive.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="k">localparam</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>        <span class="n">OPT_ODDR</span> <span class="o">=</span> <span class="p">(</span><span class="n">OPT_CLKDIV</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>In the case where <code class="highlighter-rouge">OPT_ODDR</code> is true, there’s only ever one clock per
<code class="highlighter-rouge">SCK</code> cycle.  Hence, we’ll set all of these values true on every clock cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_ODDR</span><span class="p">)</span>
	<span class="k">begin</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">ckstb</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="n">ckpos</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="n">ckneg</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="n">ckpre</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">end</span></code></pre></figure>

<p>If we are dividing our clock by two, such as in order to use a <code class="highlighter-rouge">CCK</code> port
through a <a href="https://www.xilinx.com/support/documentation/user_guides/ug470_7Series_Config.pdf">STARTUPE2 primitive</a>,
then we’ll set <code class="highlighter-rouge">OPT_CLKDIV</code> to 1.  We’ll also need to toggle these
signals–but only while the port is active.  That way we can respond
to a request no matter what phase of the counter we are in.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_CLKDIV</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">CKSTB_ONE</span>

		<span class="kt">reg</span>	<span class="n">clk_counter</span><span class="o">;</span>

		<span class="k">initial</span>	<span class="n">clk_counter</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">clk_counter</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">clk_counter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">clk_counter</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
			<span class="n">clk_counter</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">pipe_req</span><span class="p">)</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">maintenance</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">o_qspi_cs_n</span> <span class="o">&amp;&amp;</span> <span class="n">o_wb_stall</span><span class="p">))</span>
			<span class="n">clk_counter</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">ckpre</span> <span class="o">=</span> <span class="p">(</span><span class="n">clk_counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span>
			<span class="n">ckstb</span> <span class="o">=</span> <span class="p">(</span><span class="n">clk_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
			<span class="n">ckpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">clk_counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span>
			<span class="n">ckneg</span> <span class="o">=</span> <span class="p">(</span><span class="n">clk_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
		<span class="k">end</span></code></pre></figure>

<p>For the sake of brevity, I’m going to skip the discussion of what it takes
to divide the clock down slower then a factor of two.  Fig. 12 above should
show you what these signals need to look like in that case.</p>

<p>Before leaving this section, I’d like to draw your attention to the presence
of the three generate blocks for this timing: one for <code class="highlighter-rouge">OPT_ODDR</code> when the clock
divider is set to zero, one for when the clock divisions is set to one, and one
more for all other cases.  That means that, when we get to
<a href="/blog/2017/10/19/formal-intro.html">formally verifying</a>
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this core</a>,
we’ll have to make certain that our <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>
work gets applied to each of these three blocks separately.</p>

<h2 id="reading-a-word">Reading a word</h2>

<p>Now that we have the clock divider out of the way, we can turn our attention
to the fun part: building the actual <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>
logic.</p>

<p>If you ever find yourself needing to build your own controller, whether it be
a <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>,
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
or whatever protocol, the way to do it is usually
straight forward: Find the specification sheet for the device you wish
to interact with, search through the sheet for the timing diagram
illustrating the interaction or interactions you wish to implement,
and then build a
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">state machine</a>
whose <a href="/blog/2017/07/31/vcd.html">trace</a>
matches that diagram.</p>

<p>Building a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller
is no different.</p>

<p>In this case, we’ll be implementing the QUAD I/O READ function.  If you look
this function up in the data sheet for your device, you’ll find two
sets of protocols.  The first describes how to get into the QUAD I/O XIP
mode.  The second I/O function shows a timing diagram describing the
QUAD I/O XIP mode we’ll be using.</p>

<p>For example, here’s what the timing diagram looks like for a
<a href="https://www.cypress.com/file/196861/download">Spansion device</a>.</p>

<table align="center" style="float: none"><caption>Fig 13: Spansion Flash timing diagram</caption><tr><td><a href="/img/qspi/qspi-spansion.png"><img src="/img/qspi/qspi-spansion.png" alt="" width="746" /></a></td></tr></table>

<p>Here’s another one describing how our operation needs to work for a <a href="https://www.pjrc.com/store/w25q64fv.pdf">Winbond
device</a>.</p>

<table align="center" style="float: none"><caption>Fig 14: Winbond Flash timing diagram</caption><tr><td><a href="/img/qspi/qspi-winbind.png"><img src="/img/qspi/qspi-winbond.png" alt="" width="799" /></a></td></tr></table>

<p>The data sheet for the <a href="https://www.micron.com">Micron</a> flash that I have doesn’t show the Quad I/O
read from XIP mode, but it does show the Quad I/O read starting with the
8-bit command.</p>

<table align="center" style="float: none"><caption>Fig 15: Micron Quad I/O Read, starting from the SPI command</caption><tr><td><a href="/img/qspi/qspi-micron.png"><img src="/img/qspi/qspi-micron.png" alt="" width="720" /></a></td></tr></table>

<p>We’ll need to use this mode to get into the XIP mode, but more on that in a bit.
For now, let’s just assume we are in the XIP mode where we can start
immediately by sending the address to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash device</a>.</p>

<p>In all cases, we’ll need to go through several steps, and we’ll need to
control the chip select (negative logic), <code class="highlighter-rouge">o_qspi_cs_n</code>, the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> clock signal
sometimes called <code class="highlighter-rouge">SCK</code>, <code class="highlighter-rouge">o_qspi_sck</code>, and the four outgoing data wires,
<code class="highlighter-rouge">o_qspi_dat</code>.  Since these wires will eventually be bi-directional at the top
level, we’ll use a third signal, <code class="highlighter-rouge">o_qspi_mod</code>, to control the final I/O driver.
We’ll also need to read the data lines from the
device, <code class="highlighter-rouge">i_qspi_dat</code>, once it starts returning information to us.</p>

<p>That means that we’ll need to support 3-I/O modes using <code class="highlighter-rouge">o_qspi_mod</code>:</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">NORMAL_SPI = 2'b00</code>: <code class="highlighter-rouge">DAT[0]</code> is an output, <code class="highlighter-rouge">DAT[1]</code> is an input,
and <code class="highlighter-rouge">DAT[3:2]</code> are both set high.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">QUAD_WRITE = 2'b10</code>: All data wires, <code class="highlighter-rouge">DAT[3:0]</code>, are <em>outputs</em> of our
 <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">QUAD_READ  = 2'b11</code>: All data wires, <code class="highlighter-rouge">DAT[3:0]</code>, are <em>inputs</em> into our
 <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">NORMAL_SPI</span> <span class="o">=</span> 	<span class="mb">2'b00</span><span class="o">;</span>
	<span class="k">localparam</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">QUAD_WRITE</span> <span class="o">=</span> 	<span class="mb">2'b10</span><span class="o">;</span>
	<span class="k">localparam</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">QUAD_READ</span> <span class="o">=</span> 	<span class="mb">2'b11</span><span class="o">;</span></code></pre></figure>

<p>How the design interacts with the devices I/O controllers is typically beyond
the scope of any of my
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> designs, although it is required
to actually implement them within any hardware.  At one time, I would specify
specific I/O connections in the toplevel:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span> <span class="n">io_qspi_dat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_qspi_mod</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">?</span> <span class="n">w_qspi_dat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="mb">1'bz</span><span class="o">;</span>
	<span class="k">assign</span> <span class="n">io_qspi_dat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_qspi_mod</span><span class="o">==</span><span class="mb">2'b10</span><span class="p">)</span> <span class="o">?</span> <span class="n">w_qspi_dat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="mb">1'bz</span><span class="o">;</span>
	<span class="k">assign</span> <span class="n">io_qspi_dat</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_qspi_mod</span> <span class="o">==</span> <span class="mb">2'b11</span><span class="p">)</span> <span class="o">?</span> <span class="mb">1'bz</span>
				<span class="o">:</span> <span class="p">(</span><span class="n">w_qspi_mod</span> <span class="o">==</span> <span class="mb">2'b10</span><span class="p">)</span> <span class="o">?</span> <span class="n">w_qspi_dat</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">2</span><span class="p">]</span>
				<span class="o">:</span> <span class="mb">2'b11</span><span class="o">;</span></code></pre></figure>

<p>I’ve stopped setting my I/O pins in this manner, however.</p>

<p>The primary reason for this is that
<a href="https://github.com/YosysHQ/arachne-pnr">Arachne-PNR</a>
would never guarantee that the placement of this final piece of
combinatorial logic would be anywhere near the pin.  As a result,
I’ve now counseled several individuals who have declared
<a href="http://www.clifford.at/yosys">Yosys</a>
broken when their design gets sufficiently large that the
I/O logic no longer gets placed adjacent to their pins.</p>

<p>While I’m told that this is fixed in
<a href="https://github.com/YosysHQ/nextpnr">NextPNR</a>, I haven’t (yet) taken the time
to go back and verify this.  Instead, I’ve gotten used to configuring the
vendor specific I/O buffers to handle this.  Further, since I’m already using
one for the ODDR <code class="highlighter-rouge">SCK</code> pin, it makes sense to use the same thing for all of the
pins–if for no other reason than to keep the timing matching throughout the
design.</p>

<p>Hence our design will need to control <code class="highlighter-rouge">o_qspi_cs_n</code>, <code class="highlighter-rouge">o_qspi_sck</code>,
and <code class="highlighter-rouge">o_qspi_dat[3:0]</code>.  We’ll also control an intermediate value, <code class="highlighter-rouge">o_qspi_mod</code>
to tell an external I/O controller how we want the I/O handled.  Similarly,
we’ll be reading from <code class="highlighter-rouge">i_qspi_dat[3:0]</code>, the data lines that come from that
external I/O controller.</p>

<p>So let’s go back to how <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this
controller</a>
will need to control these various wires.</p>

<p>The basic logic is that upon any
bus request,
we will need to work our way through a sequence of steps.</p>

<p>Just like with the state machine examples in
<a href="/tutorial/">my tutorial</a>, I often find that using a counter
to control the steps in the timing diagram feels the most natural–especially
in a particularly long sequence such as this one.  In this case, the counter
idles at zero, and starts counting down immediately following a bus request.
Once the counter reaches zero, the interface will return to idle and we should
be producing our <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone (WB)
acknowledgment</a>.</p>

<p>You can see this counter, <code class="highlighter-rouge">clk_ctr</code>, and how it relates to our design in Fig. 16
below.</p>

<table align="center" style="float: none"><caption>Fig 16: XIP timing diagram, including numbered states</caption><tr><td><a href="/img/qspi/qspi-xip-ctr.svg"><img src="/img/qspi/qspi-xip-ctr.svg" alt="" width="720" /></a></td></tr></table>

<p>This one counter controls everything, so let’s walk through the steps of
how it works.</p>

<p>Our logic starts with a bus request,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">bus_request</span>  <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>where we set our counter to <code class="highlighter-rouge">14</code> plus the number of dummy cycles,
<code class="highlighter-rouge">NDUMMY</code>.  This number of dummy cycles also includes two cycles for
the mode bits, <code class="highlighter-rouge">8'ha</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">clk_ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">5'd14</span> <span class="o">+</span> <span class="n">NDUMMY</span> <span class="o">+</span> <span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Note, above, that if we are not running in <code class="highlighter-rouge">OPT_ODDR</code> mode, that mode that
runs the <code class="highlighter-rouge">SCK</code> at the system clock speed, then we take an extra step to lower
the clock line after activating the chip select.  This will cost us one extra
clock, and so this first value of <code class="highlighter-rouge">clk_ctr</code> depends upon <code class="highlighter-rouge">OPT_ODDR</code> in addition
to <code class="highlighter-rouge">NDUMMY</code>.</p>

<table align="center" style="float: none"><caption>Fig 17: XIP timing diagram, this time at two clocks per SCK</caption><tr><td><a href="/img/qspi/qspi-halfck-ctr"><img src="/img/qspi/qspi-halfck-ctr.svg" alt="" width="720" /></a></td></tr></table>

<table align="center" style="float: right"><caption>Fig 18: CSn, and SCK</caption><tr><td><img src="/img/qspi/qspi-sckck.svg" alt="" width="360" /></td></tr></table>

<p>On the other hand, if we are running in ODDR mode, then it feels like a waste
to spend a whole cycle to lower <code class="highlighter-rouge">SCK</code>, so both <code class="highlighter-rouge">CS_n</code> and <code class="highlighter-rouge">SCK</code> will drop
together, as shown in Fig. 18 on the right.</p>

<p>Once set, then on any following step during this operation, we’ll decrement
our counter until it reaches zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ckstb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">|</span><span class="n">clk_ctr</span><span class="p">))</span>
		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="n">clk_ctr</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>Once it reaches zero, we are idle.</p>

<p>Now that we have this counter, we can hang all of the rest of our logic
upon it.</p>

<p>For example, here’s the outgoing chip select bit.  Remember, this is an active
low bit.  On any bus request, we’ll clear this bit.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_qspi_cs_n</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>Then at the end of every clock interval, we’ll check the <code class="highlighter-rouge">clk_ctr</code> to
know if this operation is over.  Once the counter gets to one, we’ll set
<code class="highlighter-rouge">o_qspi_cs_n</code> again to indicate the end of the operation on the next cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>The <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
clock is a bit more difficult, particularly because of our requirements
creep.  If we are running in <code class="highlighter-rouge">OPT_ODDR</code> mode, where the outgoing <code class="highlighter-rouge">SCK</code> is
determined by an <code class="highlighter-rouge">ODDR</code> I/O primitive, then we’ll output a <code class="highlighter-rouge">1'b1</code> anytime
we want the clock to toggle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_qspi_sck</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ODDR</span><span class="p">)</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_qspi_sck</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ODDR</span><span class="p">)</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">o_qspi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_ODDR</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clk_ctr</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5'd1</span><span class="p">)</span>
			<span class="n">o_qspi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="n">o_qspi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>If you look closely, you might argue that this <code class="highlighter-rouge">o_qspi_sck</code> signal is
identical to the <code class="highlighter-rouge">o_qspi_cs_n</code> signal.  At this most basic mode, and only if
<code class="highlighter-rouge">OPT_ODDR</code> is true, then these two signals could share the same logic.</p>

<p>I should point out that I ended up using <code class="highlighter-rouge">parameters</code> quite extensively in this
core.  <code class="highlighter-rouge">OPT_ODDR</code> isn’t the only one.  I did this for reasons of code
optimization.  By using <code class="highlighter-rouge">OPT_ODDR</code>, the synthesis tool can quickly recognize
the <code class="highlighter-rouge">if (OPT_ODDR)</code> statement, and that the else following will never get
used.  Hence, the synthesis tool will remove the rest of this nested if.
Similarly, if <code class="highlighter-rouge">OPT_ODDR</code> isn’t true, this part of the <code class="highlighter-rouge">if</code> will get removed
and not count against the logic used by this core.</p>

<p>If <code class="highlighter-rouge">OPT_ODDR</code> isn’t true then things get just a little more interesting.</p>

<p>As per the <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> protocol we are following, the clock idles at <code class="highlighter-rouge">1'b1</code> over the
wire, and so it idles at <code class="highlighter-rouge">1'b1</code> in non-ODDR mode where we
are directly controlling the over-the-wire interface.  On the other hand, if
we are running in <code class="highlighter-rouge">OPT_ODDR</code> mode, we are only controlling whether the clock
<em>toggles</em>.  Hence in <code class="highlighter-rouge">OPT_ODDR</code> mode, the clock pin idles at <code class="highlighter-rouge">1'b0</code>.
(See Figs. 11 and 12 for clarification)</p>

<p>Now, if the clock is low, and <code class="highlighter-rouge">ckpos</code> tells us that it is time to raise it,
then set it high.  This will occur in the middle of our
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">state machine</a>
interval, and only if <code class="highlighter-rouge">OPT_ODDR</code> isn’t set.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ckpos</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_qspi_sck</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="n">o_qspi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>Finally, if our clock divider tells us it is time to lower the clock, that
is if <code class="highlighter-rouge">ckneg</code> is true, then lower the <code class="highlighter-rouge">o_qspi_sck</code> output–but only if our
SPI cycle isn’t finished.  Notice the check here, as above, for whether are or
are not still within any I/O operation.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ckneg</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_qspi_sck</span><span class="p">))</span> <span class="k">begin</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">clk_ctr</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5'd1</span><span class="p">)</span>
			<span class="n">o_qspi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="n">o_qspi_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Now that we’ve set the chip select and the clock, we can turn our attention
to the data bits.  These get set on any bus request, and
then shifted at the end of every clock interval.  Ideally, that would mean
we’d set this anytime <code class="highlighter-rouge">i_wb_stb &amp;&amp; !o_wb_stall</code>.  However, I’ve become somewhat
of a stickler for low-logic solutions, and the reality is that these bits are
don’t cares if <code class="highlighter-rouge">!i_wb_stb &amp;&amp; !o_wb_stall</code>, so I just check for <code class="highlighter-rouge">!o_wb_stall</code>
here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">data_pipe</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Set the high bits to zero initially
</span>		<span class="n">data_pipe</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>

		<span class="n">data_pipe</span><span class="p">[</span><span class="mi">8</span><span class="o">+</span><span class="n">LGFLASHSZ</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">{</span>
				<span class="n">i_wb_addr</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'ha</span><span class="o">,</span> <span class="mh">4'h0</span> <span class="o">};</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span>
		<span class="n">data_pipe</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">data_pipe</span><span class="p">[(</span><span class="mi">32</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="p">((</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mh">4'h0</span> <span class="o">};</span>

	<span class="k">assign</span>	<span class="n">o_qspi_dat</span> <span class="o">=</span> <span class="n">data_pipe</span><span class="p">[</span><span class="mi">28</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span> <span class="o">+:</span> <span class="mi">4</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Perhaps if I were interested in building a lower power design, I’d want to
eliminate any extraneously toggling data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">data_pipe</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">data_pipe</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span>
			<span class="n">data_pipe</span><span class="p">[</span><span class="mi">8</span><span class="o">+</span><span class="n">LGFLASHSZ</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">{</span>
				<span class="n">i_wb_addr</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'ha</span><span class="o">,</span> <span class="mh">4'h0</span> <span class="o">};</span>
	<span class="o">//</span> <span class="o">...</span></code></pre></figure>

<p>But low-power isn’t my current goal.</p>

<p>For now, you can see how <code class="highlighter-rouge">LGFLASHSZ</code> address bits get set, the lower two
address bits get cleared (since we are responding to a 32-bit data
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> request), and the <code class="highlighter-rouge">4'ha</code>
mode bits get set.  These mode bits will help to guarantee that we don’t leave
XIP mode once we’ve gotten into it.</p>

<p>Sure, the entire
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
read operation is longer than this, but there’s never a time when we’ll
need to output more valid bits than this.  Indeed, after these bits get sent,
the controller will switch the I/O lines from output to input modes, so again
there’s no reason to care about these bits after the output duration of
this operation ends.</p>

<p>The last
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
I/O interface item that needs to be controlled is the I/O
mode, to be used in determining which bits are set to outputs and which bits
to inputs in the external I/O controller.</p>

<p>We’ll start in <code class="highlighter-rouge">NORMAL_SPI</code> mode, and then transition on a bus request
to <code class="highlighter-rouge">QUAD_WRITE</code> mode in order to send the address of the data we wish to read.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_qspi_mod</span> <span class="o">=</span>  <span class="n">NORMAL_SPI</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">NORMAL_SPI</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">QUAD_WRITE</span><span class="o">;</span></code></pre></figure>

<p>Once we get past the address and mode bits, we can then go into <code class="highlighter-rouge">QUAD_READ</code>
mode to read our data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ckstb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">5'd9</span><span class="p">))</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">QUAD_READ</span><span class="o">;</span></code></pre></figure>

<p>That’s the logic necessary to control a read.</p>

<p>But what about the rest of our
<a href="/zipcpu/2017/11/07/wb-formal.html">bus logic</a>?
While all of this is going on, we need to be doing a couple of things.  First,
the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
must be stalled.  Second, we need to be collecting data from the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
data lines to return to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Finally, once the operation completes, we need to acknowledge the bus request,
signaling that the data we’ve collected is now valid.</p>

<p>Let’s start with the stall signal.  On any bus request, we’ll set the stall
signal high since it will be many cycles before we can respond to another bus
request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>Then, at the end of every clock interval, we’ll adjust the stall signal so that
it remains high until our operation is done.  Once <code class="highlighter-rouge">clk_ctr == 0</code>, we’ll both
(potentially) acknowledge the request, and drop our stall signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clk_ctr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>We’ll come back to this in a bit and discuss how to handle the register delays
on our input wires, since that will force us to keep the <code class="highlighter-rouge">o_wb_stall</code>
line high even after our transaction has finished.</p>

<p>The <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone acknowledgement</a> signal looks simple enough.  Following the
clock cycle where <code class="highlighter-rouge">clk_ctr==1</code>, we’ll acknowledge this request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">else</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Only … this is where we start to get in trouble with reality.</p>

<p>First, a <a href="/zipcpu/2017/11/07/wb-formal.html">formal proof</a>
of this logic fails if the master drops the <code class="highlighter-rouge">i_wb_cyc</code> line before we have the
chance to set this acknowledgment.  We can’t interrupt our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> I/O cycle when this happens,
lest we fail to output the <code class="highlighter-rouge">0xa0</code> mode bits and the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip get placed into a
state other than the XIP one.  Therefore, we’ll need to keep track of
whether the bus master has dropped the <code class="highlighter-rouge">i_wb_cyc</code> line and then suppress any
acknowledgments if it had.</p>

<p>The <code class="highlighter-rouge">pre_ack</code> logic below keeps track of whether or not we are still
within the original
<a href="/zipcpu/2017/11/07/wb-formal.html">bus cycle</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
		<span class="n">pre_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">pre_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>That way we can use it, within our calculation of the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus acknowledgment</a>,
to return a proper value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_ack</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ckstb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">pre_ack</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>This isn’t quite the last of our problems either.  What if a user wants to
<em>write</em> to our read-only memory?  Such an operation is undefined, but we can’t
allow the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
to stall waiting for the result of an unsupported operation.
<a href="/zipcpu/2017/11/07/wb-formal.html">If I believed in</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>s,
I might raise one here–and there are a lot of good reasons to do so.  I
chose instead to quietly acknowledge any write request
without doing anything instead.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">bus_request</span><span class="p">))</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>Our last step is to set and return our data value to the <a href="/zipcpu/2017/11/07/wb-formal.html">WB
bus</a></p>

<p>That one’s easy, right?  Anytime there’s a value to be read, shift it into
our data register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_sck</span><span class="p">)</span>
		<span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="mi">27</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="n">i_qspi_dat</span> <span class="o">};</span></code></pre></figure>

<p>But, when is there data to be shifted in?  Here, I use a separate signal,
<code class="highlighter-rouge">read_sck</code>, to capture this logic.  While I could have used <code class="highlighter-rouge">ckstb</code>, and
certainly did initially, I had to adjust this approach later to make certain
that <code class="highlighter-rouge">o_wb_data</code> never changes unless we are mid-operation with <code class="highlighter-rouge">clk_ctr &gt; 0</code></p>

<p>If we are in <code class="highlighter-rouge">OPT_ODDR</code> mode, the mode where <code class="highlighter-rouge">SCK</code> can toggle at the system
clock speed, then anytime the output clock is active, we should be reading
into our shift register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_ODDR</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">SCK_ACTUAL</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">read_sck</span> <span class="o">=</span> <span class="n">o_qspi_sck</span><span class="o">;</span></code></pre></figure>

<p>You can see the resulting waveform trace in Fig. 19 below.</p>

<table align="center" style="float: none"><caption>Fig 19: The read_sck signal in ODDR mode</caption><tr><td><img src="/img/qspi/qspi-xip-readsck.svg" alt="" width="720" /></td></tr></table>

<p>This would be catastrophic, though, if we only wanted to shift the data in
on every other clock.  Hence, if we are dividing the clock by two, then
we want to read on the last clock of every clock cycle.  One clock before
then, <code class="highlighter-rouge">o_qspi_sck</code> will be low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_CLKDIV</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">SCK_ONE</span>

		<span class="k">initial</span>	<span class="n">read_sck</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">read_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="n">read_sck</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">o_qspi_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>This extra logic is shown in the last line of the trace shown below in Fig. 20.</p>

<table align="center" style="float: none"><caption>Fig 20: The read_sck signal in slower clocking modes</caption><tr><td><a href="/img/qspi/qspi-halfck-readsck.svg"><img src="/img/qspi/qspi-halfck-readsck.svg" alt="" width="720" /></a></td></tr></table>

<p>Finally, if we are dividing by anything more than two, then we’ll register the
<code class="highlighter-rouge">read_sck</code> signal, and use the <code class="highlighter-rouge">ckpre</code> signal as our indication that we
need to sample on the next clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">SCK_ANY</span>

		<span class="k">initial</span>	<span class="n">read_sck</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">read_sck</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="n">read_sck</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">o_qspi_sck</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ckpre</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Again, this is shown in Fig. 21 below.  Notice how <code class="highlighter-rouge">ckpre</code> is true one clock
before <code class="highlighter-rouge">read_sck</code>, as required to make this work.  Notice also how the
clock goes through its negative cycle first, leaving the <code class="highlighter-rouge">SCK</code> positive
edge mid-interval.</p>

<table align="center" style="float: none"><caption>Fig 21: The read_sck signal in much slower clocking modes</caption><tr><td><a href="/img/qspi/qspi-slow-readck.svg"><img src="/img/qspi/qspi-slow-readck.svg" alt="" width="720" /></a></td></tr></table>

<p>To verify that this logic works, I used one of those <a href="/formal/2019/02/21/txuart.html">“poor man’s sequences”
that I discussed earlier</a>.</p>

<p>Why not use a regular <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SystemVerilog
sequence</a>?
Well, I started out using the more traditional <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SVA
sequences</a>.
However, ultimately it was the variable clock rate that made using <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SVA
sequences</a>
impossible, and so I had to switch to the
<a href="/formal/2019/02/21/txuart.html">poor man’s sequence</a>
approach.</p>

<p>By a <a href="/formal/2019/02/21/txuart.html">poor man’s sequence</a>,
I mean something like the following:</p>

<p>First, I define how long this operation will take in logical steps, not
clock steps.  This
includes the first step, found only when <code class="highlighter-rouge">OPT_ODDR</code> is low, where the <code class="highlighter-rouge">CS_n</code> line
is low and <code class="highlighter-rouge">SCK</code> remains high, followed by the six clock intervals of
the address.  This is then followed by a parameterizable number of dummy cycles,
and then our eight data read cycles.  We can capture this total length with the
<code class="highlighter-rouge">localparam</code>, <code class="highlighter-rouge">F_MEMDONE</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">F_MEMDONE</span> <span class="o">=</span> <span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="n">NDUMMY</span> <span class="o">+</span> <span class="mi">8</span><span class="o">;</span></code></pre></figure>

<p>We can then define a sequence vector of this many states, plus one more for the
acknowledgment cycle, with the meaning that if any of the bits in this vector
is a one, then we are in that state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="n">F_MEMDONE</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_memread</span><span class="o">;</span></code></pre></figure>

<p>The logic to control this sequence is actually fairly simple.  On a reset,
the sequence is cleared.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_memread</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">f_memread</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span></code></pre></figure>

<p>Otherwise, we advance the sequence at the end of every <code class="highlighter-rouge">SCK</code> clock period.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span>
			<span class="n">f_memread</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMDONE</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">1'b0</span> <span class="o">};</span></code></pre></figure>

<p>There’s one problem with only stepping the sequence at the end of every
<code class="highlighter-rouge">SCK</code> clock interval: what happens to the acknowledgment?  <code class="highlighter-rouge">o_wb_ack</code> can only
be high for one clock cycle, not for as many cycles as there are in an
extended <code class="highlighter-rouge">SCK</code> clock interval.  Therefore, we’ll need to clear the upper bit
if our clocking is extended at all.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span>
			<span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMDONE</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>The last step is to start the sequence.  We’ll start it on any bus
request.  Well, almost.  For reasons we’ll get into later we’ll start this
only on a bus request where the <code class="highlighter-rouge">CS_n</code> line is idle (high).</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span> <span class="o">&amp;&amp;</span> <span class="n">o_qspi_cs_n</span><span class="p">)</span>
			<span class="n">f_memread</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>From here, we’ll shift this left one step per every state transition.
Fig. 35 below shows an example of this, but only after adding in several more
features, so let’s work our way up to that point.</p>

<p>Now we can make assertions about what’s supposed to happen in each step.</p>

<p>For example, we want to make certain <code class="highlighter-rouge">o_qspi_sck</code> is high during any <code class="highlighter-rouge">OPT_ODDR</code>
read operation.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">OPT_ODDR</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">|</span><span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMDONE</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_sck</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>We might also wish to assert that we start out this sequence in <code class="highlighter-rouge">QUAD_WRITE</code>
mode, and end it in <code class="highlighter-rouge">QUAD_READ</code> mode.  There’s a couple steps in the middle
where our I/O mode doesn’t matter, but otherwise this fully constraints our
I/O modes.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">f_memread</span><span class="p">[</span><span class="mi">6</span><span class="o">+</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_mod</span> <span class="o">==</span> <span class="n">QUAD_WRITE</span><span class="p">)</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">f_memread</span><span class="p">[(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">7</span> <span class="o">+:</span> <span class="n">NDUMMY</span><span class="p">])</span>
	<span class="k">begin</span> <span class="k">end</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">f_memread</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_mod</span> <span class="o">==</span> <span class="n">QUAD_READ</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>In a moment, we’ll need a copy of what was read from the <code class="highlighter-rouge">i_qspi_dat</code> set of
input pins in order to verify that we received the right values.  So let’s
create a second copy of the incoming data for that check.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ckpos</span> <span class="o">&amp;&amp;</span> <span class="n">o_qspi_mod</span> <span class="o">==</span> <span class="n">QUAD_READ</span><span class="p">)</span>
		<span class="n">f_past_data</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_past_data</span><span class="p">[</span><span class="mi">28</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="n">i_qspi_dat</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">};</span>
	<span class="k">end</span></code></pre></figure>

<p>Next, let’s examine those first six clocks.  These are the ones where we need
to be outputting the address we were given from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.  The first step
to this check is making sure we have a copy of the last requested address
to check against.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Make sure all of the bits are set
</span>		<span class="n">fv_addr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="c1">// Now set as many bits as we have address bits
</span>		<span class="n">fv_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_addr</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>We can now use this to compare against what we are presenting across the port.
For example, during our first time interval, we’ll want to output address
bits <code class="highlighter-rouge">21:18</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">f_memread</span><span class="p">[(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span> <span class="o">+:</span> <span class="mi">7</span><span class="p">])</span>
	<span class="k">begin</span>
		<span class="c1">// 6 nibbles of address, one nibble of mode
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_dat</span><span class="o">==</span> <span class="n">fv_addr</span><span class="p">[</span><span class="mi">21</span><span class="o">:</span><span class="mi">18</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>Don’t let the <code class="highlighter-rouge">OPT_ODDR</code> scare you in this expression.  This just references
the extra clock cycle used in the slow clock mode before lowering the <code class="highlighter-rouge">SCK</code>
line.  During that cycle, output data values are don’t cares, so we don’t
check them here.  However, if we are running in the faster mode, then we
don’t take an extra cycle–hence the reason for checking whether or not
<code class="highlighter-rouge">OPT_ODDR</code> is set here or not.</p>

<p>Here are the rest of the checks for the rest of the address intervals.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_dat</span><span class="o">==</span> <span class="n">fv_addr</span><span class="p">[</span><span class="mi">17</span><span class="o">:</span><span class="mi">14</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_dat</span><span class="o">==</span> <span class="n">fv_addr</span><span class="p">[</span><span class="mi">13</span><span class="o">:</span><span class="mi">10</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_dat</span><span class="o">==</span> <span class="n">fv_addr</span><span class="p">[</span> <span class="mi">9</span><span class="o">:</span> <span class="mi">6</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_dat</span><span class="o">==</span> <span class="n">fv_addr</span><span class="p">[</span> <span class="mi">5</span><span class="o">:</span> <span class="mi">2</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>Don’t forget that, because we are addressing the flash with 32-bit word
addresses, that the bottom two of twenty-four bits are necessarily zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="mi">5</span><span class="o">+</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_dat</span><span class="o">=={</span> <span class="n">fv_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span><span class="mb">2'b00</span> <span class="o">}</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Or, likewise, if we want to stay in XIP mode (and we do), that we have to
output a <code class="highlighter-rouge">4'ha</code> following the address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="mi">6</span><span class="o">+</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_qspi_dat</span> <span class="o">==</span> <span class="mh">4'ha</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Now let’s turn our attention to the returned result.</p>

<p>In <code class="highlighter-rouge">OPT_ODDR</code> mode, we get a result every clock tick.  In this case,
the <code class="highlighter-rouge">$past()</code> function is ideal for checking if we are returning the right
values.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_ODDR</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMDONE</span><span class="p">])</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">28</span><span class="p">]</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_qspi_dat</span><span class="o">,</span><span class="mi">8</span><span class="p">))</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">27</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_qspi_dat</span><span class="o">,</span><span class="mi">7</span><span class="p">))</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">20</span><span class="p">]</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_qspi_dat</span><span class="o">,</span><span class="mi">6</span><span class="p">))</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">19</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_qspi_dat</span><span class="o">,</span><span class="mi">5</span><span class="p">))</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_qspi_dat</span><span class="o">,</span><span class="mi">4</span><span class="p">))</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span><span class="mi">11</span><span class="o">:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_qspi_dat</span><span class="o">,</span><span class="mi">3</span><span class="p">))</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_qspi_dat</span><span class="o">,</span><span class="mi">2</span><span class="p">))</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span> <span class="mi">3</span><span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_qspi_dat</span><span class="o">,</span><span class="mi">1</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>On the other hand, if we haven’t yet reached the end of the sequence,
then both the stall signal should be high and the acknowledgment signal
should be low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">f_memread</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">;</span>
		<span class="k">end</span></code></pre></figure>

<p>If we are running in a slower clock mode, then <code class="highlighter-rouge">$past()</code> won’t work for us.
Instead, we can use the copy we just made of the incoming data to prove
that we received the right value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMDONE</span><span class="p">])</span>
		<span class="k">assert</span><span class="p">((</span><span class="o">!</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">o_wb_data</span> <span class="o">==</span> <span class="n">f_past_data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]))</span><span class="o">;</span></code></pre></figure>

<p>The rest of this logic should match the logic above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">f_memread</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">;</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>We also want to make certain that, on the very last clock tick, the counter
has properly returned to zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMDONE</span><span class="p">])</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>We’ll use one final assertion to double check that <code class="highlighter-rouge">f_memread</code> only ever has
one value active at any given time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">F_MEMACK</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">ONEHOT_MEMREAD</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_memread</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">((</span><span class="n">f_memread</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Finally, just to get some assurance that this actually works, we’ll add a
<code class="highlighter-rouge">cover()</code> statement to check that, yes, we truly can perform this operation.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">o_wb_ack</span> <span class="o">&amp;&amp;</span> <span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMACK</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>We now have a basic, functioning, <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">QSPI flash
controller</a>.
Or do we?  So far, I’ve only presented how to handle requests once we’ve
already gotten into this special XIP mode.  We’ll have to come back to the
question of how to get into this mode in the first place still.  Similarly,
we haven’t discussed how to send or receive arbitrary commands yet, or how
to handle I/O delays.  Let’s push those topics off for a bit longer, and look
at how to read a second word without needing to go through the address cycle
again.</p>

<h2 id="reading-another-word">Reading another word</h2>

<table align="center" style="float: right"><caption>Fig 22: Subsequent word state diagram</caption><tr><td><img src="/img/qspi/qspi-pipe-fsm.svg" alt="" width="240" /></td></tr></table>

<p>With the logic above, we can now read a word from our
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip.  We can do this at the
system clock rate, or any arbitrary division of it.  In this section, let’s
instead focus on what it takes to read data from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> using the pipelined features of
the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>.</p>

<p>While you might wish to call this a <em>burst</em>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> mode, unlike other
burst modes that I’ve worked with (WB, AXI, etc), this one doesn’t carry a
burst length parameter, burst size, or even address increment information.
For this reason, I often call this a <em>pipelined</em> mode rather than a <em>burst</em>
mode, even though there are some obvious similarities between the two.  As a
result, you’ll find I often describe these as “pipe” or “piped” requests.</p>

<p>Within my design, this pipelined mode is controlled by the <code class="highlighter-rouge">OPT_PIPE</code> parameter.
Further, unlike many <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> burst
modes, these piped requests are controlled on a beat by beat basis in the
master.  There’s no pre-announcement of the number of values to be read, such
as in the <a href="/doc/axi-spec.pdf">AXI master specification</a>
or in the <a href="https://cdn.opencores.org/downloads/wbspec_b3.pdf">Wishbone burst modes from the B3
specification</a> that <a href="/zipcpu/2017/11/07/wb-formal.html">I’ve
carefully chosen not to
implement</a>.  Instead, we’ll
need to determine on a beat by beat basis if the next read request continues the
burst, or if we need to raise <code class="highlighter-rouge">o_qspi_cs_n</code> and start over with a new
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
transaction.</p>

<p>Here you can see the definition of the <code class="highlighter-rouge">OPT_PIPE</code> parameter controlling whether
or not we support this mode in the first place.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// OPT_PIPE makes it possible to string multiple requests together,
</span>	<span class="c1">// with no intervening need to shutdown the QSPI connection and send a
</span>	<span class="c1">// new address
</span>	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_PIPE</span>    <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>If this parameter is set, the controller will respond to requests for subsequent
addresses.  Hence, if you request a read from address <code class="highlighter-rouge">A</code>, and then while the
controller is busy making that happen you request a second read from address
<code class="highlighter-rouge">A+1</code> (i.e. one word, or 32-bits later), then the controller should recognize
and honor this request before closing up the interface.</p>

<p>Sadly, that means we’re going to need to go back over a lot of our logic
above and adjust it to make these subsequent reads possible.</p>

<p>The first step, though, is a bit of complicated logic determining if a
subsequent read is even pending that would extend our burst access in the first
place.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_PIPE</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">OPT_PIPE_BLOCK</span>
		<span class="kt">reg</span>	<span class="n">r_pipe_req</span><span class="o">;</span>
		<span class="kt">wire</span>	<span class="n">w_pipe_condition</span><span class="o">;</span>

		<span class="kt">reg</span>	<span class="p">[(</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">next_addr</span><span class="o">;</span></code></pre></figure>

<p>An important part of this check is to know if a bus request is pending for
the <em>next</em> address.  The first step of that logic is to calculate what that
next address, or <code class="highlighter-rouge">next_addr</code>, will be.  In particular, this address is defined
as one more than the last address accepted.  Hence, anytime <code class="highlighter-rouge">!o_wb_stall</code>, we
can create a copy of the incoming address plus one.  (Notice we dropped the
check for <code class="highlighter-rouge">i_wb_stb</code> again.)  Following requests for this <code class="highlighter-rouge">next_addr</code>
will then be honored without closing the interface.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span>  <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
			<span class="n">next_addr</span> <span class="o">&lt;=</span> <span class="n">i_wb_addr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>This will capture the <code class="highlighter-rouge">next_addr</code> from not only the beginning of our first
request, but will also update it at the beginning of any subsequent address
as well, since the logic above, based upon the <code class="highlighter-rouge">!o_wb_stall</code> signal alone,
doesn’t care which of the two it is responding to.</p>

<p>A pipe request requires several things that all need to be true.
First, this has to be part of the last transaction.  Remember how we used
<code class="highlighter-rouge">pre_ack</code> to keep track of whether the last transaction was aborted?
Here, <code class="highlighter-rouge">pre_ack</code> must be true–indicating that the last request was never
aborted.  Second, there must be an outstanding request, so <code class="highlighter-rouge">i_wb_stb</code> must
be true as well.  The new request must also be a read request, so <code class="highlighter-rouge">!i_wb_we</code>.
Further, it must be a request while we are already busy, and so the <code class="highlighter-rouge">CS_n</code> pin
must be active so <code class="highlighter-rouge">!o_qspi_cs_n</code>.  The clock counter must be greater than
zero, and the outstanding request must be for the next address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">assign</span>	<span class="n">w_pipe_condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">pre_ack</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_qspi_cs_n</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">|</span><span class="n">clk_ctr</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">next_addr</span> <span class="o">==</span> <span class="n">i_wb_addr</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>This all makes sure that we are not only receiving a next address read request,
but also that we are getting that request while we are still reading from the
last address.</p>

<p>Since that’s a lot of logic, we’ll register it to keep it from slowing down
the rest of the core.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">r_pipe_req</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ckstb</span><span class="p">))</span>
			<span class="n">r_pipe_req</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="n">r_pipe_req</span> <span class="o">&lt;=</span> <span class="n">w_pipe_condition</span><span class="o">;</span>

		<span class="k">assign</span>	<span class="n">pipe_req</span> <span class="o">=</span> <span class="n">r_pipe_req</span><span class="o">;</span></code></pre></figure>

<p>Of course, if we aren’t supporting burst reads, then this value needs to be
kept at zero–so the synthesizer can optimize away any unused logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="k">assign</span>	<span class="n">pipe_req</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Registering all this logic is going to change our timing diagram somewhat,
as shown in Fig. 23 below.</p>

<table align="center" style="float: none"><caption>Fig 23: Timing associated with piped reads</caption><tr><td><a href="/img/qspi/qspi-pipe-stall.svg"><img src="/img/qspi/qspi-pipe-stall.svg" alt="" width="720" /></a></td></tr></table>

<p>Notice from the figure that the logic recognizing a pipelined request needs
to first notice the request when <code class="highlighter-rouge">clk_ctr == 3</code>.  Then <code class="highlighter-rouge">pipe_req</code> gets set
one clock later, when <code class="highlighter-rouge">clk_ctr == 2</code>, and so the <code class="highlighter-rouge">o_wb_stall</code> line gets
dropped when <code class="highlighter-rouge">clk_ctr == 1</code>.  This is all set up so that <code class="highlighter-rouge">clk_ctr</code> can then
jump back from <code class="highlighter-rouge">clk_ctr==1</code> to <code class="highlighter-rouge">clk_ctr == 8</code> to start the second read.</p>

<p>The <a href="/blog/2017/10/19/formal-intro.html">formal tools</a>,
however, discovered the error in this basic set up.  If
I ever take more than one clock cycle per <code class="highlighter-rouge">SCK</code>, then it might be that
<code class="highlighter-rouge">clk_ctr == 1</code> for multiple cycles before <code class="highlighter-rouge">o_wb_stall</code> needs to be lowered.
Thanks to the <a href="/blog/2017/10/19/formal-intro.html">formal
tools</a>,
I think I found all of the missing logic tests.</p>

<p>All that’s left then is to patch this into our prior logic.  The biggest
changes will be to our counter, <code class="highlighter-rouge">clk_ctr</code>, and our stall signal, <code class="highlighter-rouge">o_wb_stall</code>.
Neither the <code class="highlighter-rouge">o_qspi_cs_n</code> logic nor the <code class="highlighter-rouge">o_qspi_sck</code> logic needs to change,
since both of these are already set appropriately on any bus request.</p>

<p>Let’s start by updating <code class="highlighter-rouge">clk_ctr</code>.  Before, on a read request, we set the
<code class="highlighter-rouge">clk_ctr</code> to <code class="highlighter-rouge">14+NDUMMY+(!OPT_ODDR)</code>.  Now, if <code class="highlighter-rouge">pipe_req</code> and <code class="highlighter-rouge">bus_request</code> are
true, we’ll need to set it to <code class="highlighter-rouge">8</code> just before the operation ends.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// We start out as before
</span>	<span class="k">initial</span>	<span class="n">clk_ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">bus_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">pipe_req</span><span class="p">))</span>
		<span class="c1">// Notice that this is only appropriate for
</span>		<span class="c1">// regular bus reads, and so the check for
</span>		<span class="c1">// !pipe_req
</span>		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">5'd14</span> <span class="o">+</span> <span class="n">NDUMMY</span> <span class="o">+</span> <span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span> <span class="c1">// &amp;&amp; pipe_req
</span>		<span class="c1">// Otherwise, if this is a piped read, we'll
</span>		<span class="c1">// reset the counter back to eight.
</span>		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">5'd8</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ckstb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">|</span><span class="n">clk_ctr</span><span class="p">))</span>
		<span class="c1">// The rest is as it was before
</span>		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="n">clk_ctr</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>At first, updating the stall signal is easy.  We still raise the stall signal
on a bus request, regardless of whether or not its a piped (burst) request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>Where things start to get difficult is when determining when to drop the
stall line in order to accept this transaction.</p>

<p>It turns out that there’s two separate pieces of logic required.  First, if
we are in <code class="highlighter-rouge">OPT_ODDR</code> mode and hence running at the system clock, then we’ll
need to drop <code class="highlighter-rouge">o_wb_stall</code> when <code class="highlighter-rouge">clk_ctr == 2</code> so that <code class="highlighter-rouge">o_wb_stall</code> will be low
when <code class="highlighter-rouge">clk_ctr == 1</code> as shown in Fig. 23 above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span> <span class="o">||</span> <span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ckpre</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">pipe_req</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">5'd2</span><span class="p">))</span>
			<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">clk_ctr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>Remember, we can’t make a mistake here, and timing is critical.  Once mistake,
where <code class="highlighter-rouge">o_wb_stall</code> is low for one too many clock cycles, and we might
accidentally accept an extra request that we have no intention of processing.</p>

<p>On the other hand, if we are running slower than our clock speed, then we’ll
need to drop the stall signal while <code class="highlighter-rouge">clk_ctr == 1</code> as discussed above.
This needs to be done one clock before <code class="highlighter-rouge">ckstb</code> when all of our states change,
and so we use the <code class="highlighter-rouge">ckpre</code> signal for that purpose.  Notice that, if <code class="highlighter-rouge">OPT_ODDR</code>
is true, <code class="highlighter-rouge">ckstb</code> in the above condition will always be true, so this next bit
of logic will get ignored.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckpre</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">pipe_req</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">5'd1</span><span class="p">))</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>Again, if you get confused by this logic at all, refer back to Figs. 11 or 12
above.</p>

<p>Verifying the piped reads follows much of the same logic as the original
memory read verification: we use a
<a href="/formal/2019/02/21/txuart.html">poor man’s sequence</a>.
This sequence is only ever nine steps in length, since all the variable
length stuff was handled above.  These eight states represent the eight
new steps on the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
bus, as well as a final one to return an
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone acknowledgment</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">F_PIPEDONE</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
	<span class="c1">// ...
</span>	<span class="kt">reg</span>	<span class="p">[</span><span class="n">F_PIPEDONE</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_piperead</span><span class="o">;</span></code></pre></figure>

<p>Now we can define a shift register with eight states (plus one for the
acknowledgment), and step through it every time a clock period completes.
This should look very similar to the shift register associated with the
<a href="/formal/2019/02/21/txuart.html">poor man’s sequence</a>
for reading in the first place.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">f_piperead</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">OPT_PIPE</span><span class="p">))</span>
		<span class="n">f_piperead</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span> <span class="k">begin</span>
		<span class="c1">// Shift left, to advance the states in our sequence
</span>		<span class="n">f_piperead</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_piperead</span><span class="p">[</span><span class="n">F_PIPEDONE</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">1'b0</span> <span class="o">};</span>

		<span class="c1">// Likewise, we start this sequence on a bus request when we
</span>		<span class="c1">// are already running
</span>		<span class="n">f_piperead</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">bus_request</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_qspi_cs_n</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Of course, if the states last longer than a single clock, then we’ll need
to make certain that any
<a href="/zipcpu/2017/11/07/wb-formal.html">bus acknowledgments</a>
still don’t last any longer than a single clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ODDR</span><span class="p">)</span>
		<span class="n">f_piperead</span><span class="p">[</span><span class="n">F_PIPEDONE</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>Using this <a href="/formal/2019/02/21/txuart.html">state sequence
vector</a>,
we can now make assertions about this second part of our state machine.  For
example, on that last beat of the sequence, either the data is right, or the
<a href="/zipcpu/2017/11/07/wb-formal.html">acknowledgments</a>
must be low–in which case we don’t care what’s in the data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_piperead</span><span class="p">[</span><span class="n">F_PIPEDONE</span><span class="p">])</span>
		<span class="k">assert</span><span class="p">((</span><span class="o">!</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">o_wb_data</span> <span class="o">==</span> <span class="n">f_past_data</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>Now let’s look at the rest of the steps in the sequence.  Prior to our
acknowledgment, we should be stalled until the end of the <code class="highlighter-rouge">SCK</code> clock cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">f_piperead</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ckstb</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Once we hit the end of the <code class="highlighter-rouge">SCK</code> clock cycle, we should still be stalled for all
stages except the one before we are done.  That one exception is the stage,
shown in Fig. 23 above when <code class="highlighter-rouge">clk_ctr == 1</code>, where we might possibly accept
another request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_piperead</span><span class="p">[</span><span class="n">F_PIPEDONE</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Finally, unless we are acknowledging the last memory cycle, the acknowledgment
line must also be low.  (Remember, we checked for our own acknowledgment
cycle earlier in this cascaded if statement.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMDONE</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_ack</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>One last assertion is necessary to tie our <code class="highlighter-rouge">f_piperead</code> vector to the clock
counter.  On the very last cycle of <code class="highlighter-rouge">f_piperead</code>, the <code class="highlighter-rouge">clk_ctr</code> should be at
zero, unless we are extending into an additional burst read following this
one in which case <code class="highlighter-rouge">clk_ctr</code> should be eight.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_piperead</span><span class="p">[</span><span class="n">F_PIPEDONE</span><span class="p">])</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">clk_ctr</span> <span class="o">==</span> <span class="n">F_PIPEDONE</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>For all other cycles, the <code class="highlighter-rouge">clk_ctr</code> should specify which of the <code class="highlighter-rouge">f_piperead</code>
bits is on.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">f_piperead</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_piperead</span><span class="p">[</span><span class="n">F_PIPEDONE</span><span class="o">-</span><span class="n">clk_ctr</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>As one final step to know that our core truly passes, we’ll add a cover
statement to cover the acknowledgment from one of these pipe reads.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_PIPE</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">cover</span><span class="p">(</span><span class="n">o_wb_ack</span> <span class="o">&amp;&amp;</span> <span class="n">f_piperead</span><span class="p">[</span><span class="n">F_PIPEDONE</span><span class="p">])</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Now, when we run <a href="https://symbiyosys.readthedocs.io/en">SymbiYosys</a>
in cover mode, we’ll get a <a href="/blog/2017/07/31/vcd.html">trace</a> that we can examine assuring us that our
design truly did what we were expecting.</p>

<h2 id="the-startup-sequence">The Startup Sequence</h2>

<table align="center" style="float: right"><caption>Fig 24: Sequence of startup commands</caption><tr><td><img src="/img/qspi/qspi-startup-fsm.svg" alt="" width="240" /></td></tr></table>

<p><a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">Our core</a>
now possesses all of the functionality necessary to read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
just not any of the functionality necessary to get into the Quad I/O XIP read
mode that all of our reads will start from.  Once there, we can read at full
speed (or slower) upon any request, and we can continue that read request as
long as the master continues issuing subsequent read requests.  Getting into
this mode in the first place will be the topic of this section.  Well, that
and how to patch the logic for such a startup sequence into the logic we’ve
already written above.</p>

<p>Before getting into the details, I should note that I’ve built more than one
of these startup scripts before.  Sadly, they all end up being very device
dependent, often because different
<a href="https://en.wikipedia.org/wiki/Flash_memory">Flash</a> devices support different
reset commands, and some need special instructions to set chip specific
configuration registers.  Hence, while the previous two sections are all
(fairly) device <em>independent</em>, and while they all apply to any
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> device that supports
the Quad I/O XIP read mode, things become quite device dependent in this
section.</p>

<p>When I built my <a href="https://github.com/ZipCPU/qspiflash/blob/4a2d41caaf4be8ce6e63d7c5d2a0085476e0127d/rtl/qflexpress.v#L218-L292">first startup script</a>,
I built my startup sequence from a giant counter.  After letting the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> idle for a period of time,
following the <a href="https://www.cypress.com/spansion-redirect">Spansion</a>
specification I was following for starting the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, I would then toggle the <code class="highlighter-rouge">CS_n</code>
line as a form of a reset sequence, and then issue a single read command.
Sometimes this required setting the Quad-SPI enable bit in the configuration
register.</p>

<p>This all worked until I tried using the <a href="https://www.micron.com">Micron</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>.  In that case, toggling
the <code class="highlighter-rouge">CS_n</code> line without toggling <code class="highlighter-rouge">SCK</code> wasn’t guaranteed to do anything useful.
Worse, before setting the Quad-SPI enable bit, you had to set the write enable bit.  And, if that wasn’t
all, the <a href="https://www.micron.com">Micron</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>
required up to 10-cycles between the address and the
data.  Not only that, but that number of cycles is clock rate dependent.  If
you didn’t run at 100MHz, you might be able to use fewer dummy cycles–making
the number of dummy cycles not only vendor but also clock rate dependent.  If
that wasn’t enough, my 100 MHz <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
implementation required setting the drive strength, measured in Ohms, in order
to actually get up to 100MHz, and that requires setting the write enable bit
<em>again</em>.</p>

<p>So I rebuilt my <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> driver in order
to support this <a href="https://www.micron.com">Micron</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a> as well as the others.</p>

<p>Because of the number of times I’ve ended up rebuilding this startup script,
I chose to rebuild it this last time using an array of startup micro-commands
rather than a counter driven script.  While this might not be as low logic
as I like, it will at least be easy enough to adjust from one
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> device to the next.</p>

<p>This, therefore, is the one piece of our “Universal” <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>
that remains device dependent–not counting the number of dummy cycles,
the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
dependent number of wait states on registered I/O, the device dependent
<code class="highlighter-rouge">SCK</code> rate, or ….</p>

<p>Here’s how our micro-control commands will be formatted.</p>

<table align="center" style="float: none"><caption>Fig 25: Startup microcode command word format</caption><tr><td><img src="/img/qspi/qspi-cmdword.png" width="208" alt="" /></td></tr></table>

<ol>
  <li>
    <p>We’ll use one bit to select between a command to be send to the device, and
some number of counts to wait idle before the next command.  I call this the
wait bit, <code class="highlighter-rouge">M_WAITBIT</code>, within the code and marked it as <code class="highlighter-rouge">S</code> for sleep
in Fig. 25 above.  If this bit is set, the other 10-bits of the command word
will indicate the number of counts to remain idle with the <code class="highlighter-rouge">CS_n</code> line inactive
(high).  If the bit is not set, the <code class="highlighter-rouge">CS_n</code> line will be made active (low).
Indeed, this sleep mode is currently the only way to set <code class="highlighter-rouge">CS_n</code> inactive
between commands.</p>
  </li>
  <li>
    <p>The next two bits, shown as <code class="highlighter-rouge">M</code> above, will select the mode the command
will be in, whether <code class="highlighter-rouge">NORMAL_SPI</code>, <code class="highlighter-rouge">QUAD_WRITE</code>, or <code class="highlighter-rouge">QUAD_READ</code>.</p>
  </li>
  <li>
    <p>The final 8-bits will record an 8-bit data byte to be sent to the
device–in either high or low speed, or ignored in <code class="highlighter-rouge">QUAD_READ</code> mode.</p>
  </li>
</ol>

<p>I’ll admit, this is even my second version of this micro-code interface.  My
<a href="https://github.com/ZipCPU/qspiflash/blob/7d7db428220390befe82fc85ba89539703391ce3/rtl/qflexpress.v#L260-L396">first version was a basic bit-banging microcode
interface</a>.  I switched to the
more complicated command interface when the <a href="https://github.com/ZipCPU/qspiflash/blob/7d7db428220390befe82fc85ba89539703391ce3/rtl/qflexpress.v#L260-L396">bit-banging
one</a>
started to become difficult to maintain.  Now, with all of the commands
specifying 8-bit byte values, the command script has become much easier
to read and check by eye.</p>

<p>The good news is that we will barely need to adjust anything else in our
design to make this startup script work once it comes time to integrate it.</p>

<p>The startup script begins with the array of instructions, each 11-bits long.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">M_LGADDR</span><span class="o">=</span><span class="mi">5</span><span class="o">;</span>
	<span class="c1">//
</span>	<span class="kt">reg</span>	<span class="p">[</span><span class="n">M_WAITBIT</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">m_cmd_word</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">M_LGADDR</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>These words are set within a <a href="https://github.com/ZipCPU/qspiflash/blob/c4f98974a8c282284fdd582e19d675287883ca33/rtl/qflexpress.v#L346-L421">giant initial
block</a>.
In general, this block needs to start by placing the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>
into a known state from which we can send an
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
command to enter the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
XIP read state,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h08</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">NORMAL_SPI</span><span class="o">,</span> <span class="mh">8'hff</span> <span class="o">};</span> <span class="c1">// Addr 1
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h09</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">NORMAL_SPI</span><span class="o">,</span> <span class="mh">8'hff</span> <span class="o">};</span> <span class="c1">// Addr 2
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h0a</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">NORMAL_SPI</span><span class="o">,</span> <span class="mh">8'hff</span> <span class="o">};</span> <span class="c1">// Addr 2
</span>	<span class="c1">// Idle, to raise the CS_n line
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h0b</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mh">10'h3f</span> <span class="o">};</span></code></pre></figure>

<p>and end with a Quad Read I/O command, <code class="highlighter-rouge">0xeb</code>,
24-bits of address (I set these to zero in general), a mode command, <code class="highlighter-rouge">0xa0</code>,
some number of dummy cycles as determined by your specification sheet, and
then reading one or two bytes for good measure.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h14</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">NORMAL_SPI</span><span class="o">,</span> <span class="mh">8'heb</span> <span class="o">};</span>
	<span class="c1">// Addr #1
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h15</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">QUAD_WRITE</span><span class="o">,</span> <span class="mh">8'h00</span> <span class="o">};</span>
	<span class="c1">// Addr #2
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h16</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">QUAD_WRITE</span><span class="o">,</span> <span class="mh">8'h00</span> <span class="o">};</span>
	<span class="c1">// Addr #3
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h17</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">QUAD_WRITE</span><span class="o">,</span> <span class="mh">8'h00</span> <span class="o">};</span>
	<span class="c1">// Mode byte
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h18</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">QUAD_WRITE</span><span class="o">,</span> <span class="mh">8'ha0</span> <span class="o">};</span>
	<span class="c1">// Dummy clocks, x10 for the MICRON flash
</span>	<span class="c1">//   This includes the 2 clocks for the mode byte above
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h19</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">QUAD_WRITE</span><span class="o">,</span> <span class="mh">8'h00</span> <span class="o">};</span>
	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h1a</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">QUAD_WRITE</span><span class="o">,</span> <span class="mh">8'h00</span> <span class="o">};</span>
	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h1b</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">QUAD_WRITE</span><span class="o">,</span> <span class="mh">8'h00</span> <span class="o">};</span>
	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h1c</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">QUAD_READ</span><span class="o">,</span>  <span class="mh">8'h00</span> <span class="o">};</span>
	<span class="c1">// Now read a byte for form
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h1d</span><span class="p">]</span> <span class="o">=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">QUAD_READ</span><span class="o">,</span>  <span class="mh">8'h00</span> <span class="o">};</span>
	<span class="c1">// Idle
</span>	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h1e</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
	<span class="n">m_cmd_word</span><span class="p">[</span><span class="mh">5'h1f</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>Some chips will also require you to set the <code class="highlighter-rouge">Quad I/O</code> bit in a configuration
register.  That annoying <a href="https://www.micron.com">Micron</a> chip requires that
we first send a write enable, and then set the <em>enhanced configuration
register</em>, followed by sending the write enable <em>again</em> and the setting the
<em>enhanced volatile configuration register</em> before we can start our flash
command.  In other words, check your
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip vendor’s data sheet to see what information needs to be sent.</p>

<p>The startup interface within our controller centers and revolves first around
an internal signal I call <code class="highlighter-rouge">maintenance</code>, because in this <code class="highlighter-rouge">maintenance</code> (i.e.
startup) mode the design is offline for <code class="highlighter-rouge">maintenance</code>.  Once the <code class="highlighter-rouge">maintenance</code>
flag clears, we’ll enter into our normal operations.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">wire</span>	<span class="n">m_ce</span><span class="o">,</span> <span class="n">new_word</span><span class="o">;</span>
	<span class="k">assign</span>	<span class="n">m_ce</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">m_midcount</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ckstb</span><span class="p">)</span><span class="o">;</span>
	<span class="k">assign</span>	<span class="n">new_word</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_ce</span> <span class="o">&amp;&amp;</span> <span class="n">m_bitcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>

	<span class="k">initial</span>	<span class="n">maintenance</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">initial</span>	<span class="n">m_cmd_index</span> <span class="o">=</span> <span class="n">M_FIRSTIDX</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span></code></pre></figure>

<p>We both start out in maintenance mode, and we return to it upon any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">m_cmd_index</span> <span class="o">&lt;=</span> <span class="n">M_FIRSTIDX</span><span class="o">;</span> <span class="c1">// i.e. 0
</span>		<span class="n">maintenance</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>Then, whenever it is time to move forward to the next word, we step forward
one index into our microcode array, <code class="highlighter-rouge">m_cmd_index</code>, stopping only when we get
to the last word in our sequence.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_word</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">maintenance</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">m_final</span><span class="p">)</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_cmd_index</span><span class="p">))</span>
			<span class="n">m_cmd_index</span> <span class="o">&lt;=</span> <span class="n">m_cmd_index</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p><code class="highlighter-rouge">M_FIRSTIDX</code> above is used to help speed us through
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>,
making it so the design skips the first several commands (mostly sleep
commands) and then goes directly into the startup sequence.  That way, we can
get a <code class="highlighter-rouge">cover()</code> statement to generate a
<a href="/blog/2017/07/31/vcd.html">trace</a> showing us the whole
sequence.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_past_valid</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">($</span><span class="nb">fell</span><span class="p">(</span><span class="n">maintenance</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>But I’m getting ahead of myself.</p>

<p>The <code class="highlighter-rouge">m_final</code> register above will be true when we get to the end of the
sequence.  More on that in a moment as well.</p>

<p>Now that we have a command index into our micro-command table, we’ll want to
use it to read from our array of startup commands.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">m_this_word</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_word</span><span class="p">)</span>
		<span class="n">m_this_word</span> <span class="o">&lt;=</span> <span class="n">m_cmd_word</span><span class="p">[</span><span class="n">m_cmd_index</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>We’re also going to need a flag to tell us when we are on the last command
word.  We’ll call this <code class="highlighter-rouge">m_final</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">m_final</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">m_final</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_word</span><span class="p">)</span>
		<span class="n">m_final</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">m_final</span> <span class="o">||</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">m_cmd_index</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>Next, let’s implement our sleep or wait counter.  This is the one that counts
down some number of sleep cycles, with <code class="highlighter-rouge">o_qspi_cs_n</code> held high (inactive).
Of course, the counter resets to its longest count, <code class="highlighter-rouge">-1</code>, on reset, and it
starts in the middle of a sleep cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">m_midcount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
		<span class="k">initial</span>	<span class="n">m_counter</span>   <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">m_midcount</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="n">m_counter</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>Then, when it’s time to step to the next state, and time to move to the
next micro-command word, the counter starts up only if the <code class="highlighter-rouge">M_WAITBIT</code> (i.e.
the sleep bit) is set within the command word and the sleep count is greater
than zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_word</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">m_midcount</span> <span class="o">&lt;=</span> <span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="p">]</span>
					<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">|</span><span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="o">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="p">])</span>
				<span class="n">m_counter</span> <span class="o">&lt;=</span> <span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Once set, the timer counts down to zero.  Likewise, the flag <code class="highlighter-rouge">m_midcount</code>
will reflect that we are waiting for the timer to complete.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="n">m_midcount</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">m_counter</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_counter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">m_counter</span> <span class="o">&lt;=</span> <span class="n">m_counter</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">end</span></code></pre></figure>

<p>Once this <code class="highlighter-rouge">m_midcount</code> flag clears, we can then move to the next microcode
instruction.  This is also why the logic above depends upon <code class="highlighter-rouge">m_ce</code>, which
itself is only true if <code class="highlighter-rouge">!m_midcount</code>: we only move forward to the next
instruction if our counter has reached zero.</p>

<p>What about the <code class="highlighter-rouge">CS_n</code> line and the mode bits?  Let’s set them here, as well as
a <code class="highlighter-rouge">m_bitcount</code> to keep track of which bit within our eight that we are currently
transmitting.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">m_cs_n</span>      <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">initial</span>	<span class="n">m_mod</span>       <span class="o">=</span> <span class="n">NORMAL_SPI</span><span class="o">;</span>
		<span class="k">initial</span>	<span class="n">m_bitcount</span>  <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">m_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="n">m_mod</span>  <span class="o">&lt;=</span> <span class="n">NORMAL_SPI</span><span class="o">;</span>
			<span class="n">m_bitcount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span></code></pre></figure>

<p>On every <code class="highlighter-rouge">ckstb</code>, we’ll move forward to the next step in our sequence.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_bitcount</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">m_bitcount</span> <span class="o">&lt;=</span> <span class="n">m_bitcount</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>Once every instruction has been acted upon, if this is the final instruction,
then let’s cause these values to stop toggling.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">m_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">m_final</span><span class="p">))</span>
			<span class="k">begin</span>
				<span class="n">m_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
				<span class="n">m_mod</span>  <span class="o">&lt;=</span> <span class="n">NORMAL_SPI</span><span class="o">;</span>
				<span class="n">m_bitcount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span></code></pre></figure>

<p>Otherwise if we are in the middle of a timer count, or if we are about to start
a timer count down, then again set the bits to idle.  <code class="highlighter-rouge">CS_n</code> is deactivated,
and the port is placed in a <code class="highlighter-rouge">NORMAL_SPI</code> mode.  The bit count is also left
at zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">m_midcount</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="p">]))</span>
			<span class="k">begin</span>
				<span class="n">m_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
				<span class="n">m_mod</span>  <span class="o">&lt;=</span> <span class="n">NORMAL_SPI</span><span class="o">;</span>
				<span class="n">m_bitcount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span></code></pre></figure>

<p>Finally, if we aren’t mid byte, and if this isn’t the last byte, and we
aren’t in a sleep cycle or about to start one, then we can accept
a new byte to transmit. <code class="highlighter-rouge">CS_n</code> is activated (lowered) automatically, and the
mode is drawn from the next two bits of the word.  The bit count is set to
the number of remaining <code class="highlighter-rouge">SCK</code> clock periods necessary to send this word,
either 1 for a two-cycle word, or 7 for an eight cycle word.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
				<span class="n">m_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
				<span class="n">m_mod</span>  <span class="o">&lt;=</span> <span class="n">m_this_word</span><span class="p">[</span><span class="mi">9</span><span class="o">:</span><span class="mi">8</span><span class="p">]</span><span class="o">;</span>
				<span class="n">m_bitcount</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ODDR</span> <span class="o">&amp;&amp;</span> <span class="n">m_cs_n</span><span class="p">)</span>
					<span class="o">?</span> <span class="mh">4'h2</span> <span class="o">:</span> <span class="mh">4'h1</span><span class="o">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_this_word</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span>
					<span class="n">m_bitcount</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ODDR</span> <span class="o">&amp;&amp;</span> <span class="n">m_cs_n</span><span class="p">)</span>
						<span class="o">?</span> <span class="mh">4'h8</span> <span class="o">:</span> <span class="mh">4'h7</span><span class="o">;</span>
			<span class="k">end</span>
		<span class="k">end</span></code></pre></figure>

<p>Well, almost.  If we aren’t running in <code class="highlighter-rouge">OPT_ODDR</code> mode, and we aren’t continuing
a previous command, then we’ll add in one extra clock cycle for <code class="highlighter-rouge">SCK</code> to be
high before dropping.</p>

<p>But what data should be sent?  That comes from the rest of the bits in the
micro-command word, bits <code class="highlighter-rouge">7:0</code> as outlined in Fig. 25 above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_ce</span><span class="p">)</span>
		<span class="k">begin</span>
		    <span class="k">if</span> <span class="p">(</span><span class="n">m_bitcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		    <span class="k">begin</span></code></pre></figure>

<p>On any new command to send data to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>, we’ll set the outgoing
data register, <code class="highlighter-rouge">m_dat</code> to the top four bits of the word for the <code class="highlighter-rouge">QUAD*</code> modes.
Otherwise, if we will be transmitting in <code class="highlighter-rouge">NORMAL_SPI</code> mode, then we’ll instead
set bit zero to the top bit, and the other three are don’t cares.  <code class="highlighter-rouge">m_byte</code> is
then used to capture the remaining bits to be sent.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ODDR</span> <span class="o">&amp;&amp;</span> <span class="n">m_cs_n</span><span class="p">)</span>
			<span class="k">begin</span>
			    <span class="n">m_dat</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">{</span><span class="n">m_this_word</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">}};</span>
			    <span class="n">m_byte</span> <span class="o">&lt;=</span> <span class="n">m_this_word</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
			<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			    <span class="n">m_dat</span>  <span class="o">&lt;=</span> <span class="n">m_this_word</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">4</span><span class="p">]</span><span class="o">;</span>
			    <span class="n">m_byte</span> <span class="o">&lt;=</span> <span class="n">m_this_word</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mh">4'h0</span> <span class="o">};</span>
			    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
			    <span class="k">begin</span>
				<span class="c1">// Slow speed
</span>				<span class="n">m_dat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">m_this_word</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">;</span>
				<span class="n">m_byte</span>   <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">m_this_word</span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">1'b0</span> <span class="o">};</span>
			    <span class="k">end</span>
			<span class="k">end</span></code></pre></figure>

<p>Finally, while we are within a word, we’ll want to shift the <code class="highlighter-rouge">m_byte</code> data
over by either one or four bits in order to grab the next bits to send.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		    <span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="n">m_dat</span> <span class="o">&lt;=</span> <span class="n">m_byte</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">4</span><span class="p">]</span><span class="o">;</span>
			<span class="n">m_byte</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">m_byte</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="n">m_this_word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">};</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_mod</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="k">begin</span>
				<span class="c1">// Slow speed
</span>				<span class="n">m_dat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">m_byte</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">;</span>
				<span class="n">m_byte</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">m_byte</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="n">m_this_word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">};</span>
			<span class="k">end</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>The last wire to set is the clock register, <code class="highlighter-rouge">m_clk</code>, that will be used to
drive the <code class="highlighter-rouge">SCK</code> pin.  If we are in <code class="highlighter-rouge">OPT_ODDR</code> mode, where we are
running our clock at the system clock rate, this is as simple as setting the
clock to be identical to the negated <code class="highlighter-rouge">CS_n</code> pin.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_ODDR</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
				<span class="n">m_clk</span> <span class="o">=</span> <span class="o">!</span><span class="n">m_cs_n</span><span class="o">;</span>
		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>Otherwise, the <code class="highlighter-rouge">m_clk</code> pin will set the <code class="highlighter-rouge">o_qspi_sck</code> and hence the <code class="highlighter-rouge">SCK</code> wire
directly, so we’ll need to spend a bit more time at this.  On a reset, the
<code class="highlighter-rouge">SCK</code> clock wire needs to idle at one.  Otherwise, whenever <code class="highlighter-rouge">m_clk</code> is already
low, then the clock is raised on the <code class="highlighter-rouge">ckpos</code> signal.  Further, in the middle
of a count down, the clock is kept idle (high).  Otherwise, the clock goes
low if there’s another bit (nibble) to be sent.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
				<span class="n">m_clk</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cs_n</span><span class="p">)</span>
				<span class="n">m_clk</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">m_clk</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ckpos</span><span class="p">))</span>
				<span class="n">m_clk</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_word</span> <span class="o">&amp;&amp;</span> <span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="p">])</span>
				<span class="n">m_clk</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckneg</span><span class="p">)</span>
				<span class="n">m_clk</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">end</span></code></pre></figure>

<p>That’s the startup logic.</p>

<p>Since it doesn’t depend upon the inputs at all, it’s easily tested by a basic
testbench.  Alternatively, the one cover statement shown above will calculate
a <a href="/blog/2017/07/31/vcd.html">trace</a> for us, showing what this startup routine does.</p>

<p>But how shall we integrate this within the rest of the design?</p>

<p>Actually, that’s the easy part, and part of the magic of using the
<code class="highlighter-rouge">maintenance</code> flag.  First notice that there’s no feedback path from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a> to this micro-code startup
design.  That means that an extra clock cycle (or two) won’t affect our logic.
This makes it easy to adjust each of our basic controller output port logic
block to respond to the <code class="highlighter-rouge">maintenance</code> flag when it is set, and to ignore
the startup registers if not.</p>

<p>For example, in the case of <code class="highlighter-rouge">o_qspi_cs_n</code>, we’d have</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_qspi_cs_n</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="n">m_cs_n</span><span class="o">;</span>
	<span class="k">else</span> <span class="o">///</span> <span class="n">everything</span> <span class="n">continues</span> <span class="n">as</span> <span class="k">before</span><span class="o">.</span></code></pre></figure>

<p>In the case of <code class="highlighter-rouge">o_qspi_sck</code>, we’d have</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_qspi_sck</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ODDR</span><span class="p">)</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_qspi_sck</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ODDR</span><span class="p">)</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span>
		<span class="n">o_qspi_sck</span> <span class="o">&lt;=</span> <span class="n">m_clk</span><span class="o">;</span>
	<span class="k">else</span> <span class="o">//</span> <span class="n">everything</span> <span class="n">continues</span> <span class="n">as</span> <span class="k">before</span></code></pre></figure>

<p>The same applies to <code class="highlighter-rouge">o_qspi_mod</code>, the bits used to control the external I/O
directions,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_qspi_mod</span> <span class="o">=</span>  <span class="n">NORMAL_SPI</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">NORMAL_SPI</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">m_mod</span><span class="o">;</span>
	<span class="k">else</span> <span class="o">//</span> <span class="n">everything</span> <span class="n">continues</span> <span class="n">as</span> <span class="k">before</span></code></pre></figure>

<p>the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone stall</a>
register,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="o">//</span> <span class="n">everything</span> <span class="n">continues</span> <span class="n">as</span> <span class="k">before</span></code></pre></figure>

<p>and so forth and so on.</p>

<p>If we’ve done this all right, we can then get a cover <a href="/blog/2017/07/31/vcd.html">trace</a> showing that
our startup script works using a simple,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">($</span><span class="nb">fell</span><span class="p">(</span><span class="n">maintenance</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>as I mentioned above.</p>

<p>Only, this doesn’t practically work.</p>

<p>The first problem is that I start the script with a very long set of delays.
These are required by some
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>s.  The problem with these
long delays is that the
<a href="/blog/2017/10/19/formal-intro.html">formal tools</a>
can’t practically work through that many cycles.  So, to cut these delays
down, I introduced <code class="highlighter-rouge">M_FIRSTIDX</code> above–as a way to start the startup sequence
in the middle–but only during <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>.</p>

<p>The second problem was the delays within the control structure, and this is
a problem for the same reason as the long delays upon startup.  To deal with
these, I arbitrarily kept the maximum number of counts to 3, but only during
<code class="highlighter-rouge">FORMAL</code> mode.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">m_counter</span>   <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="k">begin</span>
<span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
			<span class="n">m_counter</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="o">;</span>
<span class="cp">`else</span>
			<span class="n">m_counter</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="cp">`endif</span>
		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_word</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="p">])</span>
			<span class="k">begin</span>
				<span class="n">m_counter</span> <span class="o">&lt;=</span> <span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
<span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">m_this_word</span><span class="p">[</span><span class="n">M_WAITBIT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
					<span class="n">m_counter</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="o">;</span>
<span class="cp">`endif</span>
			<span class="k">end</span>
		<span class="k">end</span> <span class="k">else</span> <span class="o">//</span> <span class="k">continue</span> <span class="n">as</span> <span class="n">above</span></code></pre></figure>

<p>My third problem was that even with all this help, the startup design
still didn’t pass <code class="highlighter-rouge">cover()</code>.</p>

<p>If you’ve ever had to debug a <code class="highlighter-rouge">cover()</code> failure, it can be quite annoying,
since the
<a href="/blog/2017/10/19/formal-intro.html">formal tools</a>
provide no information to you telling you why the
<code class="highlighter-rouge">cover()</code> request failed.  Instead, all you learn is that the <code class="highlighter-rouge">cover()</code>
part of the proof failed.</p>

<p>The secret to solving problems like this with <code class="highlighter-rouge">cover()</code> is to break the
<code class="highlighter-rouge">cover()</code> problem up into smaller problems, to help you bisect and find the
problematic cycle.</p>

<p>While this was my approach, I may have also gone a bit overkill at it, as
you’ll see below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">cover</span><span class="p">(</span><span class="o">!</span><span class="n">maintenance</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h0a</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h0b</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h0c</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h0d</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h0e</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h0f</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h10</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h11</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h12</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h13</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h14</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h15</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h16</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h17</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h18</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h19</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h1a</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h1b</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h1c</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h1d</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h1e</span><span class="p">)</span><span class="o">;</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">m_cmd_index</span> <span class="o">==</span> <span class="mh">5'h1f</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>This way, if <code class="highlighter-rouge">cover(m_cmd_index == 5'h12)</code> passed, but <code class="highlighter-rouge">5'h13</code> didn’t,
I could look at the number of steps between states and estimate how many
more steps the
formal tools
needed to reach the ultimate <code class="highlighter-rouge">cover(!maintenance)</code>.  When dividing the clock
by six, such that <code class="highlighter-rouge">CLK_DIV == 5</code>, this meant <em>checking 560 states before the
proof would complete!</em></p>

<p>In the end, I also created some
<a href="/formal/2019/02/21/txuart.html">poor man’s sequence</a>s
to describe the various possible micro-commands and make certain that each were
properly carried out.  We’ll skip these, since they basically follow the
same form as the others above.</p>

<h2 id="arbitrary-commands">Arbitrary commands</h2>

<p>The next step in implementing this core was to create an optional
configuration port through which arbitrary commands could be sent to
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>.  Further, I chose to use
the parameter, <code class="highlighter-rouge">OPT_CFG</code>, to control whether this arbitrary command port should
be integrated into <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">the
controller</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">//
</span>	<span class="c1">// OPT_CFG enables the configuration logic port, and hence the
</span>	<span class="c1">// ability to erase and program the flash, as well as the ability
</span>	<span class="c1">// to perform other commands such as read-manufacturer ID, adjust
</span>	<span class="c1">// configuration registers, etc.
</span>	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_CFG</span>     <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>There are several reasons why we might want such a port.  First, if we don’t
implement any start up sequences, the arbitrary command capability can be used
to create a startup sequence to place us into the XIP mode where the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> will
respond to a sequence starting with an address instead of a command.  Second,
arbitrary command sequences are necessary for erasing and programming the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
should you want that capability.  Finally, while debugging the I/O, to see
what is working and what is not, arbitrary commands are an absolute
necessity to get a perspective of what is going on either right or wrong.</p>

<p>Of course, to do this, the <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>
will need to be able to place the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a> into
a state where it would no longer respond to read requests.  This will
necessitate that we add at least two more states to our basic state diagram,
as shown in Fig. 26 below.</p>

<table style="float: none"><caption>Fig 26: Configuration Port State Diagram</caption><tr><td><a href="/img/qspi/qspi-cfg-fsm.svg"><img src="/img/qspi/qspi-cfg-fsm.svg" /></a></td></tr></table>

<p>In the new configuration mode state, any attempts to read from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a> will be
erroneous–sort of like any requests to write to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> were erroneous earlier.  As
before, such read attempts could be responded to with a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>, although I have
chosen to instead return an empty acknowledgment instead.  This means that any
software controller will be responsible for making certain reads from
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
aren’t attempted during the configuration mode.</p>

<p>Of course, if you read through any
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>
specification, this will appear backwards.  Most <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
chips</a> support
many modes, of which the read mode we are using is a subset of the
“Quad I/O read” mode.  Instead, as far as our controller is concerned, our
read mode is our primary reason for being.  That’s why it is our primary mode
in our state diagram above.</p>

<p>When I first started designing this configuration port, I was only
interested in implementing traditional
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
instructions with this port: send 8-bits of data on <code class="highlighter-rouge">o_qspi_dat[0]</code>, and
receive 8-bits of data on <code class="highlighter-rouge">i_qspi_dat[1]</code>.</p>

<p>The problem with this initial view is that switching back into our
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
mode requires sending the following:</p>

<ol>
  <li>
    <p>A <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
I/O read command in the traditional
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> mode</p>
  </li>
  <li>
    <p>The address, written in QUAD output mode.</p>
  </li>
  <li>
    <p>A mode nibble (sometimes byte) of <code class="highlighter-rouge">4'ha</code> (or <code class="highlighter-rouge">4'ha0</code>).  This needs to be
sent in QUAD output mode, while driving all of the wires.</p>

    <p>If the mode byte is not sent in its entirety across all four
bit lanes, the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip will not
return to XIP mode following this interaction.</p>
  </li>
  <li>
    <p>Dummy bytes, where the clock is ticked.  This can be sent in any I/O mode,
but must allow the I/O direction to be switched.</p>
  </li>
  <li>
    <p>Some amount of data, read in QUAD input mode, so that the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip fully places
us into the XIP mode we want for everything else.  This must also be done
in QUAD input mode to avoid contention on the various wires.</p>
  </li>
</ol>

<p>In other words, in order to support an arbitrary command interface, we need to
support all three modes: <code class="highlighter-rouge">NORMAL_SPI</code>, <code class="highlighter-rouge">QUAD_WRITE</code> and <code class="highlighter-rouge">QUAD_READ</code> just to be
able to return our interface to the state where our logic above will apply.</p>

<p>Not only that, but some commands require 8-bits, some 16, some 24, and some
more bits–such as the command we need to send to return to XIP mode.  To keep
this interface simple, I chose to only support 8-bit transactions, in a way
where larger/longer transactions could be composed from multiple 8-bit
transactions.  That means that the configuration port
must support leaving the <code class="highlighter-rouge">CS_n</code> line low at the end of every
transaction, and then only raising it later upon command.  Further, at the
end of every transaction, the port should be stable: <code class="highlighter-rouge">o_qspi_cs_n</code> will be
high or low as specified in the transaction, and <code class="highlighter-rouge">o_wb_data</code> will be constant.</p>

<p>This necessitated creating five separate control port operations, controlled
by a single control word written to <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">our
controller</a>
over the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
and shown in Fig. 27 below:</p>

<table align="center" style="float: none"><caption>Fig 27: Control word bit assignment</caption><tr><td><a href="/img/qspi/qspi-cfgword-bits.png"><img src="/img/qspi/qspi-cfgword-bits.png" width="603" alt="" /></a></td></tr></table>

<ol>
  <li>
    <p>A traditional 8-bit <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> interaction.</p>

    <p>This would be started upon a write request, but would end with <code class="highlighter-rouge">o_qspi_cs_n</code>
left active.  <code class="highlighter-rouge">o_wb_data</code> would maintain, in its bottom 8-bits, the values
read from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

    <p>I called this a low speed configuration request.</p>

    <p>To initiate such a request, one would a single word to the control port.
Of this word, the lower 8-bits would contain the data to be sent,
the <code class="highlighter-rouge">C</code> (<code class="highlighter-rouge">CS_n</code>) bit would be low, the <code class="highlighter-rouge">S</code> bit (Quad I/O rate) low, and the
<code class="highlighter-rouge">M</code> bit (Configuration mode) would be set high.  Once the operation
completed, you could then read the results back from the data word.
A second write to the configuration port setting <code class="highlighter-rouge">M</code> low would exit
the configuration mode and raise (deactivate) the <code class="highlighter-rouge">CS_n</code> line.  The
direction, or <code class="highlighter-rouge">D</code> bit, would be a don’t care in this operation.</p>
  </li>
  <li>
    <p>A <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">Quad-SPI</a>
8-bit interaction to write 8-bits to the port.</p>

    <table align="center" style="float: right"><caption>Fig 28: Sending 8-bits using Quad I/O</caption><tr><td><img src="/img/qspi/qspi-cfg-hs-write.svg" width="320" alt="" /></td></tr></table>

    <p>This is a two cycle <code class="highlighter-rouge">SCK</code> request, also leaving <code class="highlighter-rouge">o_qspi_cs_n</code> active (low)
at the end.  This two-cycle operation would begin, as before, by writing a
command word to the configuration port.  The bottom 8-bits of this command
word would specify the data bits to be sent to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">Quad-SPI</a>
port.  Likewise, the <code class="highlighter-rouge">M</code> bit would be high placing us into configuration
mode, the <code class="highlighter-rouge">C</code> (<code class="highlighter-rouge">CS_n</code>) bit would be low, the <code class="highlighter-rouge">S</code> (speed) bit would be high
to send us into QSPI mode, and the <code class="highlighter-rouge">D</code> (the direction) bit would be high
to indicate a write operation.  As with the traditional request, the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">Quad-SPI</a>
port would be left with <code class="highlighter-rouge">o_qspi_cs_n</code> active (low).  Further, the port will
be left with the mode bits set so as to continue this active write until
either the next command, or until <code class="highlighter-rouge">o_qspi_cs_n</code> is deactivated (raised).</p>
  </li>
  <li>
    <p>A <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">Quad-SPI</a>
8-bit read interaction</p>

    <table align="center" style="float: right"><caption>Fig 29: Reading 8-bits using Quad I/O</caption><tr><td><img src="/img/qspi/qspi-cfg-hs-read.svg" width="320" alt="" /></td></tr></table>

    <p>This is essentially the same as the last interaction, only the goal is to
read 8-bits of data from the port, four at a time.  The big difference is
that the direction bit, <code class="highlighter-rouge">D</code> in Fig. 27, of the command word needs to be
clear.  As before, the I/O mode will be left in its last mode, <code class="highlighter-rouge">QUAD_READ</code>,
and the <code class="highlighter-rouge">o_qspi_cs_n</code> line will be left active (low) until the next read.</p>
  </li>
  <li>
    <p>A read from this configuration register port should return the last 8-bits
read from the device.</p>

    <table align="center" style="float: right"><caption>Fig 30: Flash controller bus connections, showing two shared ports</caption><tr><td><a href="/img/qspi/qspi-bus-connections.svg"><img src="/img/qspi/qspi-bus-connections.svg" width="320" alt="" /></a></td></tr></table>

    <p>Here, I got a bit greedy.  I merged the two return ports together, as shown
in Fig. 30.  I set
it up so that the <a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
return signals, <code class="highlighter-rouge">o_cfg_stall</code>, <code class="highlighter-rouge">o_cfg_ack</code>, and <code class="highlighter-rouge">o_cfg_data</code>, would be shared
between the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a> and
configuration ports.  I also placed the current configuration port state
in bits <code class="highlighter-rouge">16:8</code>, with the last 8-bits read placed into bits <code class="highlighter-rouge">7:0</code>.</p>

    <p>Much to my surprise, this came back to bite me later when I was working
on improving the address decoding within
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.
Perhaps I shouldn’t have been surprised.  The configuration port, as
currently designed, rather breaks the rules of the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>,
specifically one request should return one acknowledgment only, and that
acknowledgment should come back on the port where the request was made.
This meant that I had a problem when my updated and improved
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
interconnect later looked for an acknowledgment specifically from the
configuration port, when I was sending it over the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a> port.</p>

    <p>I managed to find a quick fix, but I might need to come back to <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this
controller</a>
later and rework some of its <a href="/zipcpu/2017/11/07/wb-formal.html">bus
interface</a>.  For now,
though, it works with
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> (again).</p>
  </li>
  <li>
    <p>Finally, one final but necessary operation is to deactivate <code class="highlighter-rouge">o_qspi_cs_n</code>
and possibly, but not necessarily to close the configuration port at the
same time.</p>

    <p>Deactivating <code class="highlighter-rouge">o_qspi_cs_n</code> simply means writing a word to the port with
the <code class="highlighter-rouge">C</code> (<code class="highlighter-rouge">CS_n</code>) configuration bit set.  Closing the configuration port
means also writing a <code class="highlighter-rouge">0</code> to the <code class="highlighter-rouge">M</code> or mode bit of the configuration word,
after which the design will return to its normal mode for reading from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.</p>

    <p>Do be cautioned: for reasons of space within the design, the software
driver must be careful to place the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> back into Quad I/O XIP mode.
The <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>
does not do this automatically.  On the other hand, this isn’t that hard to
do from the configuration port.</p>
  </li>
</ol>

<p>When we get to our
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>,
we’ll need to cover each of these separate operations.</p>

<p>The transactions themselves are built around a configuration
<a href="/zipcpu/2017/11/07/wb-formal.html">bus interface</a>
to our core, shown in Fig. 30 above, consisting of only an additional
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone strobe bit,
<code class="highlighter-rouge">i_cfg_stb</code></a>, as well as
a set of “special” bits used to decode the instruction word shown above in
Fig. 27 above and defined within the core below:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Set this bit to "turn on" the configuration mode
</span>	<span class="k">localparam</span> <span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">CFG_MODE</span> <span class="o">=</span>	<span class="mi">12</span><span class="o">;</span>
	<span class="c1">// Set the QSPEED_BIT to use any of the higher speed operations:
</span>	<span class="c1">//   QUAD_READ or QUAD_WRITE
</span>	<span class="k">localparam</span> <span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">QSPEED_BIT</span> <span class="o">=</span> 	<span class="mi">11</span><span class="o">;</span>
	<span class="c1">// My dual I/O cores use a DSPEED_BIT
</span>	<span class="k">localparam</span> <span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">DSPEED_BIT</span> <span class="o">=</span> 	<span class="mi">10</span><span class="o">;</span> <span class="c1">// Not supported
</span>	<span class="c1">// Set the DIR_BIT to write, clear it to read
</span>	<span class="k">localparam</span> <span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">DIR_BIT</span>	<span class="o">=</span> 	 <span class="mi">9</span><span class="o">;</span>
	<span class="c1">// USER_CS_n offers user control of the CS bit.  Set to deactivate CS,
</span>	<span class="c1">//   clear it to use the interface
</span>	<span class="k">localparam</span> <span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">USER_CS_n</span> <span class="o">=</span> 	 <span class="mi">8</span><span class="o">;</span></code></pre></figure>

<p>To highlight how this interface might work, suppose we wanted to read the
manufacturer ID (<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
CMD <code class="highlighter-rouge">8'h9f</code>) from the device.  We would need to:</p>

<ol>
  <li>
    <p>First exit from the Quad I/O XIP mode the core is normally in.  That means
we’d need to write, to the configuration port:</p>

    <p>a. One word of a potential address: <code class="highlighter-rouge">32'h10ff</code>.</p>

    <p>These <code class="highlighter-rouge">8'hff</code> data bits are carefully
   chosen to send an “undefined” command to the
   <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
   in the case that we aren’t in Quad I/O XIP mode.  As a result, this is
   also a low-speed command.  At high speed, these would be interpreted as
   24’bits of an address, followed by two mode nibbles–all with the
   low-order bit held high.  Since the last two bits are set, this will
   clear the mode word, so that the
   <a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a> will exit XIP mode
   at the end of the command.</p>

    <p>b. We’ll send one additional word for good effect, just to guarantee that we
   actually complete the read command.  (On a
   <a href="https://www.micron.com">Micron</a>
   <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
   you might need to send more.  Hence, we’ll write 32’h10ff to the port
   again to send another 8 clocks.</p>

    <p>c. Writing a 32’h1100 to the port keeps it in the configuration mode, but
   deactivates the <code class="highlighter-rouge">CS_n</code> bit–so that we can now transition to our next
   command.</p>

    <table align="center" style="float: none"><caption>Fig 31: Exiting from XIP mode</caption><tr><td><a href="/img/qspi/qspi-xip-exit.svg"><img src="/img/qspi/qspi-xip-exit.svg" width="720" alt="" /></a></td></tr></table>
  </li>
</ol>

<ol start="2">
  <li>
    <p>We can now write the <code class="highlighter-rouge">32'h109f</code> to the port.  This will send the <code class="highlighter-rouge">8'h9f</code>
command to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a> in normal
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> mode.</p>

    <table align="center" style="float: none"><caption>Fig 32: Sending a 9F via normal SPI mode</caption><tr><td><a href="/img/qspi/qspi-9f.svg"><img src="/img/qspi/qspi-9f.svg" width="720" alt="" /></a></td></tr></table>
  </li>
</ol>

<ol start="3">
  <li>
    <p>Another 8-clocks are necessary to read the manufacturers ID from the port,
  so we’ll send an additional <code class="highlighter-rouge">32'h1000</code>.</p>
  </li>
  <li>
    <p>During the last command, the controller will read 8-bits from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>.  Now, reading from the
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">controller</a>
will return those 8-bits.</p>

    <table align="center" style="float: none"><caption>Fig 33: Reading the byte following the 9F via normal SPI mode</caption><tr><td><a href="/img/qspi/qspi-9f-read.svg"><img src="/img/qspi/qspi-9f-read.svg" width="720" alt="" /></a></td></tr></table>
  </li>
</ol>

<ol start="5">
  <li>
    <p>Writing 32’h1100 will clear the port and deactivate (raise) the <code class="highlighter-rouge">CS_n</code>, but
leave the
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">controller</a>
in its configuration mode.</p>

    <p>Fig. 33 above shows all three of these transactions.  First, the read.
Notice how I’m only showing <code class="highlighter-rouge">io_qspi_dat[1]</code> here.  This is the traditional
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">SPI</a>
MISO channel.  The bits in this channel are then accumulated into
<code class="highlighter-rouge">o_wb_data</code>, which is then read on the second configuration port
transaction shown above.  After the third transaction, the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">SPI</a>
port is returned to idle.</p>
  </li>
</ol>

<p>Once we are done with our configuration commands, whatever they might be,
we’ll need to place the design back into Quad I/O read mode–so the controller
can go back to what it was doing before.  Doing this may require some device
specific setup, as we discussed in the setup section.  Once accomplished, it
then requires sending a command to the controller
from the configuration mode.</p>

<ol>
  <li>
    <p>First, we send the Quad I/O read command, <code class="highlighter-rouge">32'h10eb</code></p>
  </li>
  <li>
    <p>Then the address.  In our case, this is a simple dummy address–anything
will work, so we send three bytes of zeros.  The trick is–these need to
be written to the port at high speed.  Hence, we set the speed bit and
the direction bit, so we write <code class="highlighter-rouge">32'h1a00</code> three times to the configuration
port.</p>
  </li>
  <li>
    <p>Now we send the mode bit, by writing <code class="highlighter-rouge">32'h1aa0</code>.</p>
  </li>
  <li>
    <p>Depending upon your <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, you may
need to clock it up to eight more times.  (Thanks
<a href="https://www.micron.com">Micron</a>!) These dummy cycles can be in either
read or write mode, though, so we’ll write <code class="highlighter-rouge">32'h1800</code> to clock <code class="highlighter-rouge">SCK</code> twice
several times over.</p>
  </li>
  <li>
    <p>We’ll then read one byte of data from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> by writing a <code class="highlighter-rouge">32'h1800</code>
to the port.</p>
  </li>
  <li>
    <p>The configuration port is then closed by writing <code class="highlighter-rouge">32'h0</code> to the port.</p>

    <p>Once complete, all of the above read commands that start in Quad XIP mode
will work.</p>
  </li>
</ol>

<p>At least, that’s the idea.  We still need to make all of this capability
happen.  Further, we need to make it happen without disturbing any of the
capability we’ve already built above.</p>

<p>To make the logic easier to read, I created a series of simplifying assignments.
The first one, <code class="highlighter-rouge">bus_request</code>, is very similar to the logic we discussed earlier.
The difference now is that we only accept a <code class="highlighter-rouge">bus_request</code> to read from
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a> when we are not in our
configuration mode, <code class="highlighter-rouge">cfg_mode</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">bus_request</span>  <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">cfg_mode</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>After that, a couple of more signals.  First, <code class="highlighter-rouge">cfg_stb</code> simplifies checking
for a bus request on this configuration port.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">cfg_stb</span>      <span class="o">=</span> <span class="p">(</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Many of these requests, such as reading from the port, releasing the port,
or returning <code class="highlighter-rouge">CS_n</code> high can be acknowledged immediately.  This includes
request of the configuration port when our <code class="highlighter-rouge">OPT_CFG</code> parameter was low,
describing the case where we haven’t built the configuration port into the
design at all.  We’ll capture these empty interaction requests with <code class="highlighter-rouge">cfg_noop</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">cfg_noop</span>     <span class="o">=</span> <span class="p">((</span><span class="n">cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">((</span><span class="o">!</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">CFG_MODE</span><span class="p">])</span>
					<span class="o">||</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">USER_CS_n</span><span class="p">])))</span>
				<span class="o">||</span><span class="p">((</span><span class="o">!</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>The rest of these simplifying assignments describe actual requests.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">user_request</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">CFG_MODE</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>Well, not quite.  They are user requests as long as the <code class="highlighter-rouge">CS_n</code> bit is set
low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">cfg_write</span>    <span class="o">=</span> <span class="p">(</span><span class="n">user_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">USER_CS_n</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>The other three commands will require require some amount of
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> interaction.
Primary among these are the writes that place or keep us in configuration
mode.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">cfg_hs_write</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfg_write</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">QSPEED_BIT</span><span class="p">])</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">DIR_BIT</span><span class="p">])</span><span class="o">;</span>
	<span class="k">assign</span>	<span class="n">cfg_hs_read</span>  <span class="o">=</span> <span class="p">(</span><span class="n">cfg_write</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">QSPEED_BIT</span><span class="p">])</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">DIR_BIT</span><span class="p">])</span><span class="o">;</span>
	<span class="k">assign</span>	<span class="n">cfg_ls_write</span> <span class="o">=</span> <span class="p">(</span><span class="n">cfg_write</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">QSPEED_BIT</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>Here are the three types of interactions we’ll support from here:</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">cfg_hs_write</code>, a high speed write request is made of the configuration
port.  This will cause 8-bits to be transmitted to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> over two clock cycles.</p>

    <p>This was shown in Fig. 28 above.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">cfg_hs_read</code>, a high speed read request is be sent to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  This
will create two <code class="highlighter-rouge">SCK</code> clock cycles, after which the 8-bits read across those
cycles can be read from the wishbone port.  Note that, despite this being
called a read command, it is actually a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>
write that commands a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
read.  Therefore, a second
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
operation is still required to read the results back out.</p>

    <p>This was shown in Fig. 29 above.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">cfg_ls_write</code>, this signals a basic
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> command.  This will cause
us to write 8-bits to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> port, and
read 8-bits back, across 8
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
clock cycles.  These 8-bits can later be read from the configuration port via
the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>.</p>

    <p>This was shown in Fig. 6 above.</p>
  </li>
</ol>

<p>Those are our three primary operations that we are going to need to support
in order to support an arbitrary read/write configuration interface directly
to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>I should point out that this is a second generation version of this interface.
The first one was based upon bit-banging the various
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> wires.  I have since abandoned
that interface in favor of this current one since: 1) “most” of these
operations are already supported with our current basic logic, and
2) bit-banging over a slow
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> driven by a <a href="/blog/2017/06/05/wb-bridge-overview.html">serial
debugging port</a> is
highly inefficient.  (Can I highlight the <em>highly</em> in inefficient?)</p>

<p>That’s our vision.  Now we just need to integrate this into the rest of the
design.</p>

<p>The first step is to keep track of any enduring modes that will last beyond
a single request.  In particular, this subset of the design requires tracking
four mode bits.  One to determine whether or
not the configuration mode of the interface is active,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">cfg_mode</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">OPT_CFG</span><span class="p">))</span>
		<span class="n">cfg_mode</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="n">cfg_mode</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="n">CFG_MODE</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>one to determine the value of the chip select in this mode,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">cfg_cs</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">OPT_CFG</span><span class="p">))</span>
		<span class="n">cfg_cs</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="n">cfg_cs</span>    <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">USER_CS_n</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">CFG_MODE</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>and the last two in order to determine the speed and direction of the I/O pins.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">cfg_speed</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">initial</span>	<span class="n">cfg_dir</span>   <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_CFG</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">cfg_speed</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="n">cfg_dir</span>   <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="n">cfg_speed</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="n">QSPEED_BIT</span><span class="p">]</span><span class="o">;</span>
		<span class="n">cfg_dir</span>   <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="n">DIR_BIT</span><span class="p">]</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Note the use of the <code class="highlighter-rouge">OPT_CFG</code> <code class="highlighter-rouge">parameter</code>.  As before, if <code class="highlighter-rouge">OPT_CFG</code> is not
defined then this let’s the synthesis tool know that it can remove all of the
logic surrounding these values and replace them with constants–simplifying the
rest of the design along the way as well.</p>

<p>With these adjusted bits, we can now return to our basic design blocks.
The first one we’ll adjust to support this mode is the <code class="highlighter-rouge">clk_ctr</code>.  Here,
we’ll add two more options–one for a low-speed request that will take
eight clock cycles, and one for a higher speed request that will take
only two clock cycles.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">clk_ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">maintenance</span><span class="p">))</span>
		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">bus_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">pipe_req</span><span class="p">))</span>
		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">5'd14</span> <span class="o">+</span> <span class="n">NDUMMY</span> <span class="o">+</span> <span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span><span class="p">)</span> <span class="c1">// &amp;&amp; pipe_req
</span>		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">5'd8</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfg_ls_write</span><span class="p">)</span>
		<span class="c1">// Here's the low speed request
</span>		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">5'd8</span> <span class="o">+</span> <span class="p">((</span><span class="n">OPT_ODDR</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfg_write</span><span class="p">)</span>
		<span class="c1">// and here's the high speed request
</span>		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">5'd2</span> <span class="o">+</span> <span class="p">((</span><span class="n">OPT_ODDR</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ckstb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">|</span><span class="n">clk_ctr</span><span class="p">))</span>
		<span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="n">clk_ctr</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>Remember, if <code class="highlighter-rouge">OPT_ODDR</code> is false, then we take one extra clock cycle after
<code class="highlighter-rouge">CS_n</code> becomes active for the clock to lower and begin our first cycle.</p>

<p>For the most part, the <code class="highlighter-rouge">SCK</code> logic doesn’t change at all.  It’s essentially
what it was before.</p>

<p>The chip select line needs adjustment, however.  In particular, this line needs
to respond to both read commands, which we’ve discussed above, as well as
configuration writes.  Hence, on a write to the configuration port, <code class="highlighter-rouge">CS_n</code> is now
adjusted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_qspi_cs_n</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="n">m_cs_n</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">CFG_MODE</span><span class="p">])</span><span class="o">||</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">USER_CS_n</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>After the write to the configuration port, the chip select pin follows the
last written value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">cfg_cs</span><span class="p">))</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>Otherwise the chip select is controlled in an identical fashion to what it was
above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">bus_request</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">cfg_write</span><span class="p">))</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span>
		<span class="n">o_qspi_cs_n</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Port direction control starts out as before: on a request to read from memory,
we start out writing to the port, so we can send the address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_qspi_mod</span> <span class="o">=</span>  <span class="n">NORMAL_SPI</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">NORMAL_SPI</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">m_mod</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">bus_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">pipe_req</span><span class="p">))</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">QUAD_WRITE</span><span class="o">;</span></code></pre></figure>

<p>On the other hand, if we have a burst continuation or pipe request then we
need to keep reading.  Likewise, if there’s a configuration
port request to read at high speed, then we also go into high speed read mode.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">bus_request</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">cfg_hs_read</span><span class="p">))</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">QUAD_READ</span><span class="o">;</span></code></pre></figure>

<p>The next two adjustments are basic.  On a high speed write request, we set
all pins to outputs,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfg_hs_write</span><span class="p">)</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">QUAD_WRITE</span><span class="o">;</span></code></pre></figure>

<p>whereas on either a low-speed request or any time the bus remains in
configuration mode at low speed, then the port I/O modes transition back
to normal <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
mode: <code class="highlighter-rouge">io_qspi_dat[3:2]</code> are outputs, <code class="highlighter-rouge">io_qspi_dat[1]</code> is an input, and
<code class="highlighter-rouge">io_qspi_dat[0]</code> is our output data pin.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cfg_ls_write</span><span class="p">)</span><span class="o">||</span><span class="p">((</span><span class="n">cfg_mode</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">cfg_speed</span><span class="p">)))</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">NORMAL_SPI</span><span class="o">;</span></code></pre></figure>

<p>The last piece of logic we’ve discussed before: After sending the address
and the mode command, the wires should become all read wires.  This only
applies, however, if we aren’t already in any configuration mode.  In that
case, we need to maintain whatever I/O standard that we’ve been commanded
to remain in.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ckstb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">&lt;=</span> <span class="mi">5'd9</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">((</span><span class="o">!</span><span class="n">cfg_mode</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">cfg_dir</span><span class="p">)))</span>
		<span class="n">o_qspi_mod</span> <span class="o">&lt;=</span> <span class="n">QUAD_READ</span><span class="o">;</span></code></pre></figure>

<p>The <code class="highlighter-rouge">o_qspi_dat</code> logic is the last of the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
registers that needs to be adjusted.</p>

<p>As you may recall, we set this value any time <code class="highlighter-rouge">o_wb_stall</code> was low,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">data_pipe</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// Set the high bits to zero initially
</span>			<span class="n">data_pipe</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>

			<span class="n">data_pipe</span><span class="p">[</span><span class="mi">8</span><span class="o">+</span><span class="n">LGFLASHSZ</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">{</span>
					<span class="n">i_wb_addr</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'ha</span><span class="o">,</span> <span class="mh">4'h0</span> <span class="o">};</span></code></pre></figure>

<p>The difference is that now we need to set the data bits associated with any
outgoing data.  Note also that we don’t need to check the direction of the
operation, in case it is <code class="highlighter-rouge">QSPI_READ</code> or <code class="highlighter-rouge">QSPI_WRITE</code>, since this will be
handled by the vendor-specific I/O drivers external to this <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this
controller</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)</span>
				<span class="n">data_pipe</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_data</span><span class="p">[</span><span class="n">QSPEED_BIT</span><span class="p">]))</span>
			<span class="k">begin</span> <span class="c1">// Low speed I/O
</span>				<span class="n">data_pipe</span><span class="p">[</span><span class="mi">28</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">;</span>
				<span class="n">data_pipe</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">;</span>
			<span class="k">end</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">)</span>
			<span class="k">begin</span> <span class="c1">// These can be set independent of speed
</span>				<span class="n">data_pipe</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">;</span>
				<span class="n">data_pipe</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">;</span>
				<span class="n">data_pipe</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">;</span>
				<span class="n">data_pipe</span><span class="p">[</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">;</span>
				<span class="n">data_pipe</span><span class="p">[</span> <span class="mi">4</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">;</span>
				<span class="n">data_pipe</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
			<span class="k">end</span></code></pre></figure>

<p>The rest of the data logic is as it was before.  On a <code class="highlighter-rouge">ckstb</code> signal, we shift
everything left by four.  This includes when we are in <code class="highlighter-rouge">NORMAL_SPI</code> mode.
That’s why we wrote to every fourth pin above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span>
			<span class="n">data_pipe</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">data_pipe</span><span class="p">[(</span><span class="mi">32</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="p">((</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mh">4'h0</span> <span class="o">};</span></code></pre></figure>

<p>Alternatively, we might have shifted a variable number of bits on each clock,
either one or four.  I’ve chosen this approach to minimize the logic required,
but we’ll have to check in a moment how effective this approach was.</p>

<p>During our startup script, we can just copy the startup data into the top four
values of the <code class="highlighter-rouge">data_pipe</code>–leaving the rest of the bits as don’t cares.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span>
			<span class="n">data_pipe</span><span class="p">[</span><span class="mi">28</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span> <span class="o">+:</span> <span class="mi">4</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">m_dat</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>These same top four bits are then used to drive our data wires, <code class="highlighter-rouge">o_qspi_dat</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_qspi_dat</span> <span class="o">=</span> <span class="n">data_pipe</span><span class="p">[</span><span class="mi">28</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">OPT_ODDR</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span> <span class="o">+:</span> <span class="mi">4</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Notice the use of the <code class="highlighter-rouge">4*(OPT_ODDR ? 0:1)</code> expression above.  This simply gives
us four dummy output bits for the case where we take an extra clock to drop
the <code class="highlighter-rouge">SCK</code> line after the <code class="highlighter-rouge">CS_n</code> line goes low–as shown above in Fig. 12.</p>

<p>Moving on to the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
logic, we’ll start with the stall line since it doesn’t change much with this
new capability.  The big new difference is that, upon any configuration request,
whether it be a regular
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> operation or
a high speed one, the stall line goes high.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cfg_write</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">bus_request</span><span class="p">))</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="o">//</span> <span class="n">The</span> <span class="n">rest</span> <span class="n">is</span> <span class="n">as</span> <span class="k">before</span></code></pre></figure>

<p>Our <a href="/zipcpu/2017/11/07/wb-formal.html">bus return</a>
logic needs to change just a touch as well.  As before, we’ll
want to acknowledge any request as soon as it completes.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_ack</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ckstb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">pre_ack</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Similarly, we want to acknowledge any memory write requests–requests that we
are not going to act upon, immediately as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">bus_request</span><span class="p">))</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>The one change is that, following a configuration write where <code class="highlighter-rouge">CS_n</code> is either
not activated or deactivated, or following any read from the configuration
port, we’ll want to acknowledge such requests immediately.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfg_noop</span><span class="p">)</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>One other signal changes to create this configuration port capability, and
that is the <code class="highlighter-rouge">o_wb_data</code> signal containing the data to be returned to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.  Unlike before,
we now have to shift our data by either one bit or four bits, depending
upon the mode we are in.  Here, we’ll use <code class="highlighter-rouge">o_qspi_mod[1]</code>, the bit that
determines whether we are in <code class="highlighter-rouge">NORMAL_SPI</code> mode or either <code class="highlighter-rouge">QUAD_READ</code> or
<code class="highlighter-rouge">QUAD_WRITE</code> modes to determine how many bits to shift in.</p>

<p>Of course, you don’t want to forget that, in <code class="highlighter-rouge">NORMAL_SPI</code> mode, the incoming
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
data bit is bit one, as in <code class="highlighter-rouge">i_qspi_dat[1]</code>, and not bit zero or
<code class="highlighter-rouge">i_qspi_dat[0]</code>.  This just follows from the typical
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
pin mapping.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_sck</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_qspi_mod</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
				<span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="mi">30</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="n">i_qspi_dat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">};</span>
			<span class="k">else</span>
				<span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="mi">27</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="n">i_qspi_dat</span> <span class="o">};</span>
		<span class="k">end</span></code></pre></figure>

<p>As a last step in this process, if we are in configuration mode, then
we’ll set the next nine bits to indicate that fact so we can read back off
the mode we are in.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">((</span><span class="n">OPT_CFG</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">cfg_mode</span><span class="p">))</span>
			<span class="n">o_wb_data</span><span class="p">[</span><span class="mi">16</span><span class="o">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">4'b0</span><span class="o">,</span> <span class="n">cfg_mode</span><span class="o">,</span> <span class="n">cfg_speed</span><span class="o">,</span> <span class="mb">1'b0</span><span class="o">,</span>
				<span class="n">cfg_dir</span><span class="o">,</span> <span class="n">cfg_cs</span> <span class="o">};</span>
	<span class="k">end</span></code></pre></figure>

<p>Sadly, these bits are somewhat ambiguous, since I merged the two
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> return
ports together as shown in Fig. 30.  Following a proper data read from
the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory, these bits may be
set to anything–depending upon what was read from the memory.  A configuration
port read would then return this same value.  However, without splitting the
output between the two ports, something we chose not do, we are stuck with this
ambiguity.</p>

<p>Since there are three basic extended operations we are supporting in this
section, we’ll create three new
<a href="/formal/2019/02/21/txuart.html">poor man’s sequence</a>s:
<code class="highlighter-rouge">f_cfglswrite</code>,  <code class="highlighter-rouge">f_cfghswrite</code>, and <code class="highlighter-rouge">f_cfghsread</code>.  By now, though, you should
have the hang of these.  First, there’s a logic block defining the sequence
logic, then another one defining how the rest of the core needs to behave
during the sequence, and lastly a cover statement to make sure the
acknowledgment at the end of the sequence can be reached.</p>

<h2 id="delayed-io">Delayed I/O</h2>

<p>I’ll admit, by the time I got to this point in my design process, I was
feeling pretty good.  <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">My
design</a> was
“working”, the logic did what I wanted in simulation, and all of the
<a href="/blog/2017/10/19/formal-intro.html">formal proofs</a>,
were passing.  I just needed to place it onto my hardware to try it out.
What could possibly go wrong?</p>

<p>Sadly, <a href="/blog/2018/08/04/sim-mismatch.html">everything could go wrong</a>.</p>

<p>High speed I/O, such as at DDR rates and above, really requires for design
stability purposes that the outputs be registered and that they go through
a vendor specific I/O module, like <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/xioddr.v">this one for
Xilinx</a> or even
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/yaddrio.v">this one for
Intel</a>.
Registering the outputs, though, breaks all my logic above.  Registering the
inputs also costs another clock cycle.</p>

<p>If this design hadn’t become “FrankenIP” yet, it was about to do so now.</p>

<p>Yes, this was also the day I just gave up in frustration.  I had worked this
design to perfection, and now reality didn’t agree with me.</p>

<p>The next day, though, I’d figured out how to move forward.</p>

<p>The key is that only the inputs need to be delayed.  None of the control logic
above, <code class="highlighter-rouge">clk_ctr</code>, <code class="highlighter-rouge">o_qspi_cs_n</code>, <code class="highlighter-rouge">o_qspi_sck</code>, <code class="highlighter-rouge">o_qspi_dat</code>, is dependent upon
any inputs, whereas <code class="highlighter-rouge">o_wb_data</code>, and <code class="highlighter-rouge">o_wb_ack</code> are.  In other words, if I just
separated the read logic from the write logic by a programmable number of
clocks, then everything should work as before.</p>

<table align="center" style="float: none"><caption>Fig 34: Incoming traces are delayed by three clocks from outgoing logic</caption><tr><td><a href="/img/qspi/qspi-xilinx-reprise.svg"><img src="/img/qspi/qspi-xilinx-reprise.svg" width="720" alt="" /></a></td></tr></table>

<p>Let’s call this extra read delay, <code class="highlighter-rouge">RDDELAY</code>, and make it a parameter.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">//
</span>	<span class="c1">// RDDELAY is the number of clock cycles from when o_qspi_dat is valid
</span>	<span class="c1">// until i_qspi_dat is valid.  Read delays from 0-4 have been verified.
</span>	<span class="c1">// DDR Registered I/O on a Xilinx device can be done with a RDDELAY=3
</span>	<span class="c1">// On Intel/Altera devices, RDDELAY=2 works
</span>	<span class="c1">// I'm using RDDELAY=0 for my iCE40 devices
</span>	<span class="c1">//
</span>	<span class="k">parameter</span>	<span class="n">RDDELAY</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span></code></pre></figure>

<p>That way it should be easy to re-target this design from one device with one
I/O delay to another.</p>

<p>The next step was to delay all of the input data processing.  If you recall,
the timing of the input data processing was dependent upon two signals:
<code class="highlighter-rouge">o_wb_ack</code> and <code class="highlighter-rouge">read_sck</code>–in addition to the more obvious <code class="highlighter-rouge">o_wb_data</code>.
<code class="highlighter-rouge">o_wb_ack</code> we set as soon as the clock counter reached zero.</p>

<p>My first step, therefore, was to rename the <code class="highlighter-rouge">o_wb_ack</code> logic so that it produced
an acknowledgment that would need to be delayed.  I called this new signal
<code class="highlighter-rouge">dly_ack</code>.  If the <code class="highlighter-rouge">RDDELAY</code> was zero, the two would be identical.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">RDDELAY</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">RDDELAY_NONE</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">o_wb_ack</span> <span class="o">=</span> <span class="n">dly_ack</span><span class="o">;</span></code></pre></figure>

<p>If the <code class="highlighter-rouge">RDDELAY</code> was non-zero, I’d delay <code class="highlighter-rouge">dly_ack</code> using a shift register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">RDDELAY_NONZERO</span>

		<span class="kt">reg</span>	<span class="p">[</span><span class="n">RDDELAY</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">ack_pipe</span><span class="o">;</span>

		<span class="k">initial</span>	<span class="n">ack_pipe</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span> <span class="o">||</span> <span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">)</span>
			<span class="n">ack_pipe</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">RDDELAY</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">ack_pipe</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">ack_pipe</span><span class="p">[</span><span class="n">RDDELAY</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="n">dly_ack</span> <span class="o">};</span>
		<span class="k">else</span>
			<span class="n">ack_pipe</span> <span class="o">&lt;=</span> <span class="n">dly_ack</span><span class="o">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="n">ack_pipe</span><span class="p">[</span><span class="n">RDDELAY</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">;</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>There’s a couple things to note about this logic.  First, if the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus master</a>
aborts the transaction, then the acknowledgment delay shift register is set to
zero.  Second, if <code class="highlighter-rouge">RDDELAY==1</code>, the delay is just a single clock delay.
Otherwise, we have to reference values from <code class="highlighter-rouge">RDDELAY-2</code> down to zero.  My
original plan was to use Verilog’s rules of assignment:
If an N-bit value is assigned to a less-than N-bit register, the upper bits
are ignored.  Unfortunately, while this worked with some tools, it failed with
others.  Eventually, I came up with the logic above that has (so far) worked
in all of my tools.</p>

<p>Finally, at the end of this shift, <code class="highlighter-rouge">o_wb_ack</code> can be set to its delayed value.</p>

<p>I then repeated this logic with the read clock, creating a new value I called
<code class="highlighter-rouge">actual_sck</code> to describe the outgoing read clock, and then delayed <code class="highlighter-rouge">read_sck</code>
to describe the sample time on the input.  Now, if I updated <code class="highlighter-rouge">o_wb_data</code> on
our (now delayed) <code class="highlighter-rouge">read_sck</code> signal, I could use the same logic as before.</p>

<p>The sticky parts, however, turned out to be the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
access.</p>

<p>The first problem was that my set of <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone formal interface
properties</a>
counts the number of outstanding accesses, and in order to pass induction the
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash controller</a>
controller has to assert that it’s own idea of how many accesses are
outstanding needs to match those of the <a href="/zipcpu/2017/11/07/wb-formal.html">bus interface
properties</a>.
Once I delayed acknowledgments through this pipe, my counts were all off.  It
might be that, while processing a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> read, some value gets
acknowledged from a prior read.</p>

<p>Fixing this required maintaining a count of how many
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
acknowledgments were in the pipeline.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span> <span class="n">FORMAL</span>
	<span class="kt">integer</span> <span class="n">k</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">)</span>
		<span class="n">f_extra</span> <span class="o">=</span>  <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">begin</span>
		<span class="n">f_extra</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">RDDELAY</span><span class="o">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">f_extra</span> <span class="o">=</span> <span class="n">f_extra</span> <span class="o">+</span> <span class="p">(</span><span class="n">ack_pipe</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span>
<span class="cp">`endif</span></code></pre></figure>

<p>Yes, I’ll admit to some amount of cringing as I created a for loop like this.
I’ve just told too many individuals <a href="/blog/2017/09/18/clocks-for-sw-engineers.html">not to use for loops in their Verilog
code</a>.  This
loop, on the other hand, is actually somewhat short and so, if you look at the
logic, it can be implemented with a simple lookup table.  Of course,
this value is also defined <em>only</em> in the formal context, so I really don’t
need to be worried about meeting timing here either.</p>

<p>Those were the easy changes.</p>

<p>The harder change was the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus stall</a>
signals, <code class="highlighter-rouge">o_wb_stall</code>.</p>

<p>At issue were the immediate acknowledgment signals, such as when you read from
the configuration register, or write to it without setting the <code class="highlighter-rouge">CS_n</code> pin
active.  Similarly, I grouped the attempts to write to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory in this group.  According
to our design above, all of these bus requests get acknowledged immediately.</p>

<p>In addition, <code class="highlighter-rouge">o_wb_data</code> gets changed immediately following any configuration
write, and so the <code class="highlighter-rouge">cfg_mode</code>, <code class="highlighter-rouge">cfg_cs</code>, <code class="highlighter-rouge">cfg_dir</code> and so forth bits get set
immediately upon the write.</p>

<p>The <a href="/blog/2017/10/19/formal-intro.html">formal tools</a>
again showed me this bug: If I set the configuration state on a bus request
immediately following the read request, the outgoing read data might not match
what was read from the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  This
would be a catastrophic error, violating the whole purpose in designing a <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>–even
if it would only ever be a very rare event.</p>

<p>I solved this problem in two steps.  First, I adjusted the <code class="highlighter-rouge">o_wb_stall</code>
logic to stall on any incoming request if <code class="highlighter-rouge">RDDELAY</code> was greater than zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">maintenance</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">RDDELAY</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">((</span><span class="n">i_cfg_stb</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">))</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">RDDELAY</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">((</span><span class="n">cfg_write</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">bus_request</span><span class="p">)))</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="o">//</span> <span class="o">...</span></code></pre></figure>

<p>Second, I added a flag I called <code class="highlighter-rouge">xtra_stall</code> to indicate that there was
an extra stall cycle, based upon the <code class="highlighter-rouge">RDDELAY</code> value that needed to be
placed into the cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span> <span class="o">||</span> <span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ckpre</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">pipe_req</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">5'd2</span><span class="p">))</span>
			<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">clk_ctr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">xtra_stall</span><span class="p">))</span>
			<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ckpre</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">pipe_req</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">5'd1</span><span class="p">))</span>
		<span class="n">o_wb_stall</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>If <code class="highlighter-rouge">xtra_stall</code> was true, the design would now wait for any
<a href="/zipcpu/2017/11/07/wb-formal.html">bus interactions</a>
to clear the final pipeline before releasing the stall line.</p>

<p>While the <code class="highlighter-rouge">xtra_stall</code> calculation was simple if <code class="highlighter-rouge">RDDELAY==0</code>, basically
<code class="highlighter-rouge">xtra_stall = 0</code>, it was a touch more complicated otherwise.  The first problem
is that, unlike the acknowledgment, the extra stall had to be active if any
stall request was in the pipeline–not just if there was one at the end of the
pipeline.  After writing this logic over and over a couple of times, I eventually chose to make it work with a pipeline similar to that of the one necessary
for <a href="/formal/2018/04/12/areset.html">synchronizing an asynchronous
reset</a>.  Then this didn’t
work, I returned to a more traditional shift register configuration–such as
the one we used above.</p>

<p>The first part of this logic set a value, <code class="highlighter-rouge">not_done</code>, indicating that we’d
want to stall an additional cycle.  On any bus request, if <code class="highlighter-rouge">RDDELAY &gt; 0</code>, we’d
want to stall an additional cycle.  Second, if any interaction with the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
was ongoing, we’d want to stall an additional cycle.  This includes not only
those cases where we haven’t yet gotten to the last state of the transaction,
i.e. <code class="highlighter-rouge">clk_ctr &gt; 1</code>, but also those cases where we are on the last state, but
we’re taking multiple cycles there and we haven’t (yet) gotten to the last one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="n">RDDELAY</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">stall_pipe</span><span class="o">;</span>
	<span class="kt">reg</span>	<span class="n">not_done</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">not_done</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span> <span class="o">||</span> <span class="n">i_cfg_stb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_wb_stall</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clk_ctr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">not_done</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">clk_ctr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">ckstb</span><span class="p">))</span>
			<span class="n">not_done</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Notice that this always block uses <em>blocking</em> assignments, i.e. it uses the
<code class="highlighter-rouge">=</code> sign.  While I generally discourage the use of blocking assignments
within clocked always blocks, I use them religiously in any combinatorial
blocks–such as the one above.  The rule, though, is that you cannot create
a latch in the process.  Hence, the initial assignment that makes certain
<code class="highlighter-rouge">not_done</code> always has at least some value.  Any subsequent assignments will
override that that initial one, and are primarily written that way just to
keep things simple and easy to read.</p>

<p>Now, using this <code class="highlighter-rouge">not_done</code> value, we can set the <code class="highlighter-rouge">stall_pipe</code> and hence the
<code class="highlighter-rouge">xtra_stall</code> value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">stall_pipe</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">stall_pipe</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">RDDELAY</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">stall_pipe</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">stall_pipe</span><span class="p">[</span><span class="n">RDDELAY</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="n">not_done</span> <span class="o">};</span>
	<span class="k">else</span>
		<span class="n">stall_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">not_done</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">xtra_stall</span> <span class="o">=</span> <span class="n">stall_pipe</span><span class="p">[</span><span class="n">RDDELAY</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Notice that setting a value to <code class="highlighter-rouge">-1</code>, according to Verilog’s rules, will set
all the bits in <code class="highlighter-rouge">stall_pipe</code>.  It <em>should</em> do this without error or warning.
Sadly, Verific’s parser (used by the major vendors) will create a warning
regarding truncating a 32-bit value to <code class="highlighter-rouge">RDDELAY</code> bits.  Still, it gets the
job done.</p>

<p>The really fascinating part of this extension to handle I/O delays is how the
formal sequences can be adjusted to handle things.</p>

<p>First, I expanded the various
<a href="/formal/2019/02/21/txuart.html">poor man’s sequence</a>
lengths by creating new length parameters
equivalent to the originals plus the new length,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">F_MEMACK</span>  <span class="o">=</span> <span class="n">F_MEMDONE</span> <span class="o">+</span> <span class="n">RDDELAY</span><span class="o">;</span>
	<span class="k">localparam</span>	<span class="n">F_PIPEACK</span> <span class="o">=</span> <span class="n">F_PIPEDONE</span> <span class="o">+</span> <span class="n">RDDELAY</span><span class="o">;</span></code></pre></figure>

<p>and so on.</p>

<p>Then, I adjusted the driving loop to make it so that the first half of the
sequence proceeded at the rate of the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> interface,
but the second half, the half counting our new RDDELAY clock extensions, at
the rate of the system clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">f_memread</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">RDDELAY</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// This our prior code, ommitted here for brevity
</span>	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">f_memread</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">begin</span>
			<span class="c1">// Advance the pipe whenever SCK advances
</span>			<span class="k">if</span> <span class="p">(</span><span class="n">ckstb</span><span class="p">)</span>
				<span class="n">f_memread</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMACK</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">1'b0</span> <span class="o">};</span></code></pre></figure>

<p>Above, as before, we step the whole register any time the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> clock moves us
forward to the next step in our sequence.  If <code class="highlighter-rouge">OPT_ODDR</code> is true, <code class="highlighter-rouge">ckstb</code> will
be true on every clock, and so this sequence will step forward on every clock.</p>

<p>On the other hand, if <code class="highlighter-rouge">OPT_ODDR</code> isn’t true, then we’ll step the new register
bits on every clock, rather than just once per <code class="highlighter-rouge">ckstb</code> step above.  Therefore,
we’ll step the last <code class="highlighter-rouge">RDDELAY</code> couple of steps at the full system clock speed.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ODDR</span><span class="p">)</span>
				<span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMACK</span><span class="o">:</span><span class="n">F_MEMDONE</span><span class="p">]</span>
					<span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_memread</span><span class="p">[</span><span class="n">F_MEMACK</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">F_MEMDONE</span><span class="p">]</span><span class="o">,</span><span class="mb">1'b0</span><span class="o">};</span></code></pre></figure>

<p>Somethings don’t change.  We still need to start the sequence on any request
to read from <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> memory, as long as
we aren’t already in the middle of a read, at which point we’d start the
<a href="/formal/2019/02/21/txuart.html">poor man’s sequence</a>
for a pipelined read, <code class="highlighter-rouge">f_piperead</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="n">bus_request</span> <span class="o">&amp;&amp;</span> <span class="n">o_qspi_cs_n</span><span class="p">)</span>
				<span class="n">f_memread</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">end</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>This might make more sense if you “saw” it in action, as shown in Fig. 35 below.</p>

<table align="center" style="float: none"><caption>Fig 35: Looking at `f_memread[]` when the incoming I/O is delayed by three clocks, RDDELAY=3</caption><tr><td><a href="/img/qspi/qspi-halfck-xdelay.svg"><img src="/img/qspi/qspi-halfck-xdelay.svg" width="720" alt="" /></a></td></tr></table>

<p>Notice how, for the first several steps of the <code class="highlighter-rouge">f_memread</code> sequence, everything
takes two clocks.  Indeed, it is lined up with the output data lines,
<code class="highlighter-rouge">o_qspi_dat</code>.  The incoming lines, <code class="highlighter-rouge">i_qspi_dat</code>, however are delayed by three
clocks, <code class="highlighter-rouge">RDDELAY=3</code>.  This means that when, in the output time units, it would
be time to read <code class="highlighter-rouge">D[7:4]</code>, the data aren’t yet on <code class="highlighter-rouge">i_qspi_dat[7:4]</code>.  During
this time, <code class="highlighter-rouge">f_memread</code> transitions once every other clock.  Once it gets to
the end, at <code class="highlighter-rouge">f_memread[25]</code> in this case, it starts transitioning on every
clock for <code class="highlighter-rouge">RDDELAY</code> clocks (3 in this case).  Then, on the last clock,
<code class="highlighter-rouge">f_memread[28]</code>, <code class="highlighter-rouge">o_wb_ack</code> is true.</p>

<p>The same would play out in <code class="highlighter-rouge">f_piperead</code>, the sequence for the continuation
read.  Here, in Fig. 35, you can see the beginning of the pipelined read, and so
the port stays active.  You may also notice that <code class="highlighter-rouge">f_piperead</code> and <code class="highlighter-rouge">f_memread</code>
are overlapping.  We already dealt with some of this above.</p>

<p>Although these changes need to be applied to all of the various sequence
vectors, at this point that’s about all that’s left.</p>

<p>Does this mean the design works?  Well, sure, it had all of its functionality
by this point, and it passed a <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>
check, but … did it <em>work</em>?</p>

<h2 id="debugging">Debugging</h2>

<p>Did this <a href="/blog/2017/10/19/formal-intro.html">formally
verified</a>
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">design</a>
work on its first time out?  Of course not, but it did come pretty close.  What
I’ve shared above is the result of my debugging
work, after all of the pain associated with getting it working.</p>

<p>On the other hand, if you need to get a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
controller working, you might be curious about what it took to get this one
to work.</p>

<p>Care to hear it?</p>

<p>Most of the debugging took place over the configuration port, for the simple
reason that the configuration port offers the external user complete control
over the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
port, and hence complete control over the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
Even better, I was able to control the configuration port from the <a href="/blog/2017/06/28/dbgbus-goal.html">debugging
bus</a>–allowing
me to script commands to be sent to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
and examine byte by byte any returns from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>The first step was to shut off the start up sequence, by setting
<code class="highlighter-rouge">OPT_STARTUP=0</code>.  This helps to keep the <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>
from interfering with our debugging work on the configuration port.</p>

<p>Then, once the design was loaded, I used <code class="highlighter-rouge">wbregs</code> (my
<a href="https://en.wikipedia.org/wiki/PEEK_and_POKE">PEEK-POKE</a>
command when using the <a href="/blog/2017/06/28/dbgbus-goal.html">debugging
bus</a>) to place the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>
into a mode where it would then respond to normal
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
commands.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./wbregs flashcfg 0x0001100	<span class="c"># Activate config mode</span>
./wbregs flashcfg 0x00010ff	<span class="c"># Send 16(x4) bits of ones, break the mode</span>
./wbregs flashcfg 0x00010ff
./wbregs flashcfg 0x0001100	<span class="c"># Inactivate the port</span></code></pre></figure>

<p>Incidentally, if you’d like to follow along, the <a href="https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/flashid.sh">script I used is still
present</a>
in the <a href="https://github.com/ZipCPU/openarty/tree/autoarty">OpenArty repository</a>
where I started working with it.</p>

<p>These commands <em>should</em> place the flash into the right mode.  However, when
debugging this interaction, I had no real way of knowing (yet), since none of
these commands returned responses.</p>

<p>The second step was to request the manufacturer ID from my device.  This is an 
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> <code class="highlighter-rouge">0x9f</code>
command, after which every byte clocked through the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
interface will return an additional byte of the ID–eventually returning not
only the manufacturer, but also the product number and the size of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># echo READ-ID</span>
./wbregs flashcfg 0x000109f     <span class="c"># Issue the read ID command</span>
./wbregs flashcfg 0x0001000     <span class="c"># Read the ID</span>
./wbregs flashcfg
./wbregs flashcfg 0x0001000     <span class="c">#</span>
./wbregs flashcfg
./wbregs flashcfg 0x0001000     <span class="c">#</span>
./wbregs flashcfg
./wbregs flashcfg 0x0001000     <span class="c">#</span>
./wbregs flashcfg
./wbregs flashcfg 0x0001100     <span class="c"># End the command</span></code></pre></figure>

<p>If you remember from our <a href="/blog/2017/06/29/sw-dbg-interface.html">previous discussions of
wbregs</a>,
<code class="highlighter-rouge">wbregs address data</code> writes <code class="highlighter-rouge">data</code> to the address given by <code class="highlighter-rouge">address</code>,
whereas <code class="highlighter-rouge">wbregs address</code> reads the value from <code class="highlighter-rouge">address</code> and returns it
as a result.  Hence, this set of
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
commands first writes <code class="highlighter-rouge">8'h9f</code> to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> port,
then writes <code class="highlighter-rouge">8'h00</code> to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> port
and reads the returned result.
This is then repeated three more times, before we issue the command to
deactivate <code class="highlighter-rouge">CS_n</code>, while yet leaving the configuration port active.  (Remember
the bit fields definitions from Fig. 27 above?)</p>

<p>If all goes well, at this point the number should match those from the
data sheet for your
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>.</p>

<p>In my case, things didn’t go quite so well.</p>

<p>No, this didn’t surprise me either.  While I had verified much of the
<a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">controller</a>’s
functionality, I hadn’t verified that the <a href="https://github.com/ZipCPU/openarty/blob/autoarty/rtl/xioddr.v">Xilinx I/O
driver</a>
was working with this design.  As it turns out, there were some other bugs in
the <a href="https://github.com/ZipCPU/openarty/blob/autoarty/auto-data/micron.txt">AutoFPGA configuration
script</a>
for the <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>
as well.</p>

<p>I didn’t discover this, though, until I picked 32’bits to run through my
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone Scope</a>, and looked at the resulting
<a href="/blog/2017/07/31/vcd.html">trace</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_last_cfg</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">r_last_cfg</span> <span class="o">&lt;=</span> <span class="n">cfg_mode</span><span class="o">;</span>
	<span class="k">assign</span>	<span class="n">o_dbg_trigger</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg_mode</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">r_last_cfg</span><span class="p">)</span><span class="o">;</span>
	<span class="k">assign</span>	<span class="n">o_debug</span> <span class="o">=</span> <span class="o">{</span> <span class="n">o_dbg_trigger</span><span class="o">,</span>
			<span class="n">i_wb_cyc</span><span class="o">,</span> <span class="n">i_cfg_stb</span><span class="o">,</span> <span class="n">i_wb_stb</span><span class="o">,</span> <span class="n">o_wb_ack</span><span class="o">,</span> <span class="n">o_wb_stall</span><span class="o">,</span><span class="c1">//6
</span>			<span class="n">o_qspi_cs_n</span><span class="o">,</span> <span class="n">o_qspi_sck</span><span class="o">,</span> <span class="n">o_qspi_dat</span><span class="o">,</span> <span class="n">o_qspi_mod</span><span class="o">,</span><span class="c1">// 8
</span>			<span class="n">i_qspi_dat</span><span class="o">,</span> <span class="n">cfg_mode</span><span class="o">,</span> <span class="n">cfg_cs</span><span class="o">,</span> <span class="n">cfg_speed</span><span class="o">,</span> <span class="n">cfg_dir</span><span class="o">,</span><span class="c1">// 8
</span>			<span class="n">actual_sck</span><span class="o">,</span> <span class="n">i_wb_we</span><span class="o">,</span>
			<span class="p">(((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_cfg_stb</span><span class="p">))</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_ack</span><span class="p">))</span>
				<span class="o">?</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>
			<span class="o">};</span></code></pre></figure>

<p>A <a href="/blog/2017/07/31/vcd.html">trace</a> is worth a thousand LEDs in so many ways.</p>

<p>Further, because the commands were separated so far apart in time, I used the
<a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v">compressed version of the Wishbone
scope</a>,
and so I was still able to capture (roughly) the entire ad-hoc interaction.</p>

<p>Once I fixed the <a href="https://github.com/ZipCPU/openarty/blob/autoarty/auto-data/micron.txt">AutoFPGA configuration
script</a>,
the <a href="https://github.com/ZipCPU/openarty/blob/autoarty/rtl/xioddr.v">I/O drivers</a>
started working and I could now read an ID from the port.  Exciting, no?</p>

<p>The problem was that it was the wrong ID.  Looking at the <a href="/blog/2017/07/31/vcd.html">trace</a> again, I could
see that the right ID was getting returned, only that I had the wrong
<code class="highlighter-rouge">RDDELAY</code> value.  This helped me get the final shifting for the ID right, so
it was now <code class="highlighter-rouge">0x20ba1810</code> as I was expecting.</p>

<p>By the way, if you ever have to do debug this kind of interaction, I cannot
recommend highly enough that you use this known ID value.  The
<a href="/blog/2017/07/31/vcd.html">trace</a> returned from
the manufacturer ID request confirmed for me that my normal
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>
transmit was working, and I could read off how to get the manufacturer ID back
out.</p>

<p>However, when I turned <code class="highlighter-rouge">OPT_STARTUP</code> back on, rebuilt the updated design and
loaded it onto the board–it still wasn’t working.</p>

<p>At this point, I switched to simulation–just to check that the design was
running <code class="highlighter-rouge">OPT_STARTUP</code> like it was supposed to.  (In hind sight, I should’ve
<a href="/blog/2017/06/02/design-process.html">started with
simulation</a>
as soon as I was done with my
<a href="/blog/2017/10/19/formal-intro.html">formal proof</a>.)
As you may recall, I had <a href="/blog/2017/10/19/formal-intro.html">formally
verified</a>
almost all of the core–but not the startup sequence.  I had committed that to
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
Sure enough, looking at the
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
generated <a href="/blog/2017/07/31/vcd.html">trace</a> showed that
startup sequence logic wasn’t doing what I wanted.</p>

<p>Once fixed, I went back and ran the design on the board again.  When the design
still didn’t work, I returned to the <a href="https://www.micron.com">Micron</a> data sheet
to see if I was missing anything.</p>

<p>As it turns out, when using the
<a href="https://www.micron.com">Micron</a> flash, you need to enable the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
mode before entering into it <em>every time</em>!</p>

<p>How did I figure this out?  By using the
<a href="https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/flashid.sh">flashid.sh</a>
script again.  This time, after assuring myself that the manufacturer’s ID
was (still) correct, I read the status register.  This looked good.  I read
the flag status register.  This looked good again.  (Yes, I am trying to read
random status registers from the chip to see what’s going on.)  Reading the
Non-volatile configuration register showed that I had not activated
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
I/Os.  I wrote a new value to this register.  It didn’t change.  I tried again,
this time adding the “Write-Enable” command first.  Now it changed.  Now,
when I sent the commands to enter
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
XIP I/O read mode it worked!</p>

<p>I quickly scripted up a <a href="https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/flashdrvr.cpp">C++ <code class="highlighter-rouge">erase_sector</code> function</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">bool</span>	<span class="n">FLASHDRVR</span><span class="o">::</span><span class="n">erase_sector</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">sector</span><span class="p">,</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">verify_erase</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">unsigned</span>	<span class="n">flashaddr</span> <span class="o">=</span> <span class="n">sector</span> <span class="o">&amp;</span> <span class="mh">0x0ffffff</span><span class="p">;</span>

	<span class="c1">// Remove us from QSPI mode
</span>	<span class="n">take_offline</span><span class="p">();</span>

	<span class="c1">// Send a write enable
</span>	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_WREN</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>

	<span class="n">DEVBUS</span><span class="o">::</span><span class="n">BUSW</span>	<span class="n">page</span><span class="p">[</span><span class="n">SZPAGEW</span><span class="p">];</span>

	<span class="c1">// Send the erase sector command to the configuration port
</span>	<span class="n">printf</span><span class="p">(</span><span class="s">"Erasing sector: %06x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">flashaddr</span><span class="p">);</span>

	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_SE</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">CFG_USERMODE</span> <span class="o">|</span> <span class="p">((</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">));</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">CFG_USERMODE</span> <span class="o">|</span> <span class="p">((</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">));</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">CFG_USERMODE</span> <span class="o">|</span> <span class="p">((</span><span class="n">flashaddr</span>    <span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">));</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>

	<span class="c1">// Wait for the erase to complete
</span>	<span class="n">flwait</span><span class="p">();</span>

	<span class="c1">// Turn quad-mode read back on, so we can read next
</span>	<span class="n">place_online</span><span class="p">();</span>

	<span class="c1">// Now, let's verify that we erased the sector properly
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">verify_erase</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// ... skipped for brevity
</span>	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Then I scripted up a <a href="https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/flashdrvr.cpp">C++ <code class="highlighter-rouge">page_program</code> command</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">bool</span>	<span class="n">FLASHDRVR</span><span class="o">::</span><span class="n">page_program</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">addr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">verify_write</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">DEVBUS</span><span class="o">::</span><span class="n">BUSW</span>	<span class="n">buf</span><span class="p">[</span><span class="n">SZPAGEW</span><span class="p">],</span> <span class="n">bswapd</span><span class="p">[</span><span class="n">SZPAGEW</span><span class="p">];</span>
	<span class="kt">unsigned</span>	<span class="n">flashaddr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0x0ffffff</span><span class="p">;</span>

	<span class="c1">//
</span>	<span class="c1">// ... Skipping preliminary checks for good measure here
</span>	<span class="c1">//
</span>
	<span class="c1">// Write enable
</span>	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_WREN</span><span class="p">);</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>

	<span class="c1">//
</span>	<span class="c1">// Write the page
</span>	<span class="c1">//
</span>
	<span class="c1">// Issue the page program command
</span>	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_PP</span><span class="p">);</span>
	<span class="c1">// The address of the page to be programmed
</span>	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">CFG_USERMODE</span><span class="o">|</span><span class="p">((</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">));</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">CFG_USERMODE</span><span class="o">|</span><span class="p">((</span><span class="n">flashaddr</span><span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">));</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">CFG_USERMODE</span><span class="o">|</span><span class="p">((</span><span class="n">flashaddr</span>    <span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0ff</span><span class="p">));</span>
	<span class="c1">// Write the page data itself
</span>	<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> 
			<span class="n">CFG_USERMODE</span> <span class="o">|</span> <span class="n">CFG_WEDIR</span> <span class="o">|</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">));</span>
	<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">writeio</span><span class="p">(</span><span class="n">R_FLASHCFG</span><span class="p">,</span> <span class="n">F_END</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"Writing page: 0x%08x - 0x%08x"</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">m_debug</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">verify_write</span><span class="p">))</span>
		<span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

	<span class="c1">// Wait for the write to complete
</span>	<span class="n">flwait</span><span class="p">();</span>

	<span class="c1">// Turn quad-mode read back on, so we can verify the program
</span>	<span class="n">place_online</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">verify_write</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Skipped for brevity
</span>	<span class="p">}</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Sure enough, I was now able to erase and then program my first
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>
(a <a href="https://www.micron.com">Micron</a>) using <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this new
controller</a>
with <a href="https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/flashdrvr.cpp">this C++
driver</a>.</p>

<p>My excitement, however, was short lived.</p>

<p>It only <em>mostly</em> worked.</p>

<p>I increased the drive strength on the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
pins in question.</p>

<p>Now it worked better, but still not consistently enough.</p>

<p>The problem was that every now and then, the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>
would fail to return the data I had written to it.
On a second read, however, it would then read the right value.  This suggested
to me that there may have been a synchronization problem between the two.</p>

<p>At this point, I started rolling up my sleeves to build a synchronization
circuit to capture the bits in the middle of the eye.  This would’ve been quite
a fun project, and a fun one to blog and explain about.</p>

<p>Perhaps to my relief, perhaps to my displeasure, someone was kind enough to
point out on twitter that the
<a href="https://www.micron.com">Micron</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>
had options for impedance matching that could be quite important at high speeds.
The first change I made fixed everything.</p>

<p>Bummer.  That synchronization post would’ve been fun.  I might still write one
later, but for another purpose.</p>

<p>Of course, I then had to go back and adjust my startup script to include this
new setup command.</p>

<p>You might also note, I would test changes to the startup script first
using the <a href="https://github.com/ZipCPU/openarty/blob/autoarty/sw/host/flashid.sh">flashid.sh</a>
shell script.  (Yes, I <em>love</em> the capability the <a href="/blog/2017/06/28/dbgbus-goal.html">debugging
bus</a>
offers for scripting unknowns together to find a solution.)</p>

<p>The good and relieving news was that it all worked.  I could now run my
favorite <a href="https://github.com/ZipCPU/openarty">OpenArty</a> <a href="https://github.com/ZipCPU/openarty/blob/autoarty/sw/board">demonstration
software</a> on the
<a href="/about/zipcpu.html">ZipCPU</a> again.</p>

<h2 id="conclusions">Conclusions</h2>

<p>I’ve now tested this new controller with both a 
<a href="https://www.micron.com">Micron</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a> as well as a 
<a href="https://www.winbond.com/hq/?_locale=en">Winbond</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chip</a>.  I’ve also tested a <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/dualflexpress.v">sister
controller</a>
to this one that uses Dual SPI mode (two data bits, not four, using
both MISO and MOSI in a bidirectional fashion)–all with great success.</p>

<table align="center" style="float: right"><caption>Fig 36: Flash controller logic usage</caption><tr><td><img src="/img/qspi/qspi-gates.png" width="360" alt="" /></td></tr></table>

<p>Even better, in spite of all the logic we dumped into this core, it still builds
into a rather small footprint, as shown in Fig. 36 to the right.  In this
figure, the first line shows the number of CMOS gates, in total, that would be
used by this core with all options on, <code class="highlighter-rouge">RDDELAY=0</code>, and <code class="highlighter-rouge">OPT_CLKDIV=7</code>.  The
second line is the same, but limited to measuring the number of
<a href="https://en.wikipedia.org/wiki/NAND_gate">NAND</a> gates the design would use,
were it to use nothing but
<a href="https://en.wikipedia.org/wiki/NAND_gate">NAND</a> gates,
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip flops</a>
and <a href="https://en.wikipedia.org/wiki/Inverter_(logic_gate)">NOT</a> gates.
The third line, marked as <code class="highlighter-rouge">iCE40</code>, shows how many 4-input LUTs would be required
by a design with <code class="highlighter-rouge">RDDELAY=0</code> and <code class="highlighter-rouge">OPT_CLKDIV=0</code>.  This may be a rather
misleading statistic, though, since <a href="http://www.clifford.at/yosys">yosys</a>
is known to pack logic into the reset circuitry present in the iCE40
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip flops</a>.
The last line is a conservative estimate of the number of 6-input LUTs that
would be required in a <a href="https://www.xilinx.com">Xilinx</a> design–the actual
number is likely going to be much lower.  Even in that case, it looks like
we’ve done pretty well!  Indeed, <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this
controller</a>
has a small logic foot print, just as we had desired from the beginning.</p>

<p>All that said, wow, that was a lot of ground to cover!  We’ve now gone over
most of the
details in <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this flash
controller</a>
from the ground up.  We discussed the basic requirements of a good
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> controller, and
how to build one that ran at a high speed.  Yes, this does run roughly twice
the speed of the <a href="https://www.xilinx.com">Xilinx</a> default
flash controller–if your board allows you to run the <code class="highlighter-rouge">SCK</code> pin in ODDR mode.
We also went though how to then modify that initial basic controller that we
started with to handle burst reads, getting into the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Quad_SPI">QSPI</a>
XIP read mode in the first place, sending arbitrary commands to the
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a>,
and even how to handle I/O delays from using registered I/Os.  Once we were
finished, I discussed all of the steps necessary to debug <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this new flash
controller</a>.</p>

<p>No, I haven’t discussed the vendor specific I/O drivers.  You should be able
to find a decent discussion of them in the respective vendor literature.
Instead, I’m trying to keep this blog somewhat vendor independent.</p>

<p>In practice, while I really like how easy it is to port <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this flash
controller</a>
from one design to the next, the <a href="/blog/2017/06/28/dbgbus-goal.html">debugging
bus</a> that this depends
upon is horrendously slow.  Particularly slow are the steps necessary to
determine if an erase step is required, or to determine that either the
erase or programming steps were successful.  Both of these are ideal tasks
for a small program running within the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
so if we continue this discussion that might be where we end up next.</p>

<p>Also, as more of a side note, I don’t normally write blog articles this long.
This has taken several weeks to write, and is likely going to take you a long
time to read.  My apologies to you if this isn’t what you are looking for.  I’ll
try to keep future posts shorter.  That said, my prayer for you is that this
post will all be worth your while as well, so that you might either trust
my own “Universal” <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>
now, or if not that you would at least have a good idea of where to start from
when building your own.</p>

<p>One final note, there’s a reason why I’m calling this a “Universal” <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">flash
controller</a>,
controller, with the “Universal” in quotations.  As currently built, <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">this
controller</a>
will be able to properly interact with all of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash chips</a> I’ve seen to date.
However, I haven’t tested it on <em>every</em> chip in order to be able to prove that
it truly is <em>Universal</em>.  Moreover, I am aware of other classes of
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash devices</a> for which I already know
this controller will not work.  Still, I like the term “Universal”–even if I
have to place it in quotation marks.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>God, who at sundry times and in divers manners spake in time past unto the fathers by the prophets, Hath in these last days spoken unto us by his Son, whom he hath appointed heir of all things, by whom also he made the worlds (Heb 1:1)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
