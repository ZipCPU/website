<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Understanding AXI Addressing</title>
  <meta name="description" content="For those who’ve been following me on twitter,you’ll know that I’ve been slowing working through understanding the AXIstandard.  My goal has been to createfo...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2019/04/27/axi-addr.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Understanding AXI Addressing</h1>
    <p class="post-meta"><time datetime="2019-04-27T00:00:00-04:00" itemprop="datePublished">Apr 27, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>For those who’ve been <a href="https://twitter.com/ZipCPU">following me on twitter</a>,
you’ll know that I’ve been slowing working through understanding the <a href="/doc/axi-spec.pdf">AXI
standard</a>.  My goal has been to create
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
IP for either an <a href="/doc/axi-spec.pdf">AXI</a>
peripheral or an <a href="/doc/axi-spec.pdf">AXI</a> master.  I’ve
made a lot of progress, and so I’d like to share some of that with you today.</p>

<table align="center" style="float: none"><caption>Fig 1: A Signal Collection Application</caption><tr><td><img src="/img/axiaddr/axiaddr-dsp2net.svg" alt="" width="780" /></td></tr></table>

<p>My journey with <a href="/doc/axi-spec.pdf">AXI</a> actually started
some time ago, under a government contract.  I needed to move data from the
DSP code I had written within the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> side of an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>+<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
chip onto the Ethernet.  I had software running on the
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a> processor side
that read from a
<a href="/blog/2017/07/29/fifo.html">FIFO</a> within the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> logic,
as shown in Fig. 1 above.  Since it was easy to do, I connected to the
low-speed interconnect of the
<a href="/blog/2018/02/09/first-cyclonev.html">Cyclone-V</a>,
and then converted that to an Avalon bus, then to a <a href="/zipcpu/2017/11/07/wb-formal.html">WB
bus</a>, and finally to a
64-bit <a href="/zipcpu/2017/11/07/wb-formal.html">WB bus</a> in order
to get to my peripheral.  I was later surprised that my design wasn’t working
nearly as fast as I wanted.</p>

<table align="center" style="float: none"><caption>Fig 2: Too many bus transformations</caption><tr><td><img src="/img/axiaddr/axiaddr-too-many-bridges.svg" alt="" width="780" /></td></tr></table>

<p>Once I finally managed to put a <a href="/blog/2017/07/08/getting-started-with-wbscope.html">wishbone
scope</a>
into the design to probe the bus interaction, I realized that every
time a transformation took place from one bus protocol to another, another clock
cycle was consumed to do it.  Reading from <a href="/blog/2017/07/29/fifo.html">my
FIFO</a>
therefore took a clock to convert from
<a href="/doc/axi-spec.pdf">AXI</a> to Avalon, another one to convert
from Avalon to <a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>,
and then four to convert from my 32-bit
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a> bus to
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a> with a 64-bit data
width.  The return path was similarly slow.  I lost a clock within my
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> generated
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>,
another clock clock converting from
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>
back to Avalon, and then another clock converting from Avalon back to
<a href="/doc/axi-spec.pdf">AXI</a>.  Or rather, I assume there was a
clock lost between <a href="/doc/axi-spec.pdf">AXI</a> and Avalon and
back, but I never had access to that part of the design in order to probe it.
Either way, my code couldn’t meet the real-time requirements I had given it and
I was wasting precious clock cycles in useless bus transformations.</p>

<p>Normally I don’t pay much attention to bus latency.  What’s a clock or two
between bus components, right?  Usually, this doesn’t hurt me.  Since I use
pipelining on the <a href="/zipcpu/2017/11/07/wb-formal.html">WB bus</a>,
I can send up to one request per clock cycle, and a two-clock latency on an
<code class="language-plaintext highlighter-rouge">N</code> item burst brings the total time to <code class="language-plaintext highlighter-rouge">N+2</code> clocks.  This works nicely
for most applications.</p>

<p>Not this one.</p>

<p>In this case, the <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM
processor</a> was only ever
reading one item at a time.  Nothing was pipelined.  Every read therefore
took the full latency of about ten clocks to process.</p>

<p>No wonder I wasn’t meeting my real time requirements.</p>

<p>The easy way to solve this problem would be to get rid of all the bus bridges,
and to switch to the low speed to the high speed
<a href="/doc/axi-spec.pdf">AXI</a> bus connection.</p>

<p>The high speed bus on the
<a href="/blog/2018/02/09/first-cyclonev.html">Cyclone-V</a>, however,
uses <a href="/doc/axi-spec.pdf">AXI</a>.  It doesn’t use
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>, it
uses <a href="/doc/axi-spec.pdf">AXI</a>.  If I wanted to use
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>, I’d need another
bus translator.</p>

<p>Prior to that project, I had tried to create an
<a href="/doc/axi-spec.pdf">AXI</a> slave myself.  I spent several weeks
on it, ending up unsuccessful.  So, with government dollars paying for my
time, I tried again.  I never even made it through the design process, much
less verification and simulation.  Eventually I gave up rather than to impact
the <a href="https://en.wikipedia.org/wiki/Critical_path_method">critical path</a>
of the project.  Several weeks after giving up in frustration,
I realized my confusion, but by then it was too late.</p>

<p>In the end, I never met my real-time promises to my customer.</p>

<p>Ever had something like that that just burns you up?  Where you made a promise
to deliver something to someone and then didn’t deliver?</p>

<p>So now I’m re-examining <a href="/doc/axi-spec.pdf">AXI</a> again.
Perhaps if I had a formal property file this time, it would help me through
the design process?</p>

<p>So that’s what I’m working on, and that’s what led me to today’s post.</p>

<p>To test whether the property file “works” or not, I’m also building a variety
of <a href="/doc/axi-spec.pdf">AXI</a> peripherals.  Perhaps you’ve
read my ramblings <a href="https://twitter.com/ZipCPU">on twitter</a> about all of the
bugs found in <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s example AXI
slave</a>?
Perhaps you’ve seen the
(<a href="/blog/2017/10/19/formal-intro.html">formally verified</a>)
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">AXI demonstration
slave</a> I’ve
been able to put together?  Or the
(<a href="/blog/2017/10/19/formal-intro.html">formally verified</a>)
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">bus fault
isolator</a>,
which can be used with a (possibly) faulty slave to keep from needing breaking
the bus so badly that only a power cycle can rescue a design?
These have been my early successes.</p>

<p>I’m still working on an <a href="/doc/axi-spec.pdf">AXI</a>
to <a href="/zipcpu/2017/11/07/wb-formal.html">WB</a> bridge, as well
as an example (open-source, and
<a href="/blog/2017/10/19/formal-intro.html">formally verified</a>)
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">AXI crossbar interconnect</a>.</p>

<p>In all of this work, I’ve managed to get far enough along in my understanding
of the <a href="/doc/axi-spec.pdf">AXI</a> protocol to be able to
discuss a piece of it with you today.</p>

<p>Specifically, I’d like to discuss how addressing works in
<a href="/doc/axi-spec.pdf">AXI</a> burst transactions.</p>

<h2 id="addressing-made-simple">Addressing made simple</h2>

<p>If you know nothing more about <a href="/doc/axi-spec.pdf">AXI</a>
addressing, you need to know this:  The
<a href="/doc/axi-spec.pdf">AXI</a> address represents the address of
the byte, not the word.  This is unlike
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>,
where the address represents the word and not the byte within it.
To convert from
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
to <a href="/doc/axi-spec.pdf">AXI</a>, add zero bits.  To convert from
<a href="/doc/axi-spec.pdf">AXI</a> to
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>,
drop the low order bits.</p>

<p>That’ll get you past any
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a> issues.  It
will also get you past any single-address transactions using
<a href="/doc/axi-spec.pdf">AXI</a>.</p>

<p>The rest of the full <a href="/doc/axi-spec.pdf">AXI</a> protocol isn’t
quite that easy.</p>

<p>Let’s start at the top.  an
<a href="/doc/axi-spec.pdf">AXI</a> transaction begins on the
address write/read channel.</p>

<table align="center" style="float: right"><caption>Fig 3: An AXI Write transaction</caption><tr><td><img src="/img/axiaddr/axiaddr-write.svg" alt="" width="360" /></td></tr></table>

<p>A write transaction begins when the bus master describes the burst of
information to be written on the write address channel.  This includes the
starting address of the transaction, the length of the transaction, and more.
The master then sends the data associated with the transaction to the slave.
Once accomplished, the slave will return a single acknowledgment.  You can see
an example of this, drawn from a <code class="language-plaintext highlighter-rouge">cover()</code> statement in the proof of <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">this
slave</a> in Fig. 3.</p>

<table align="center" style="float: left; padding=15px;"><caption>Fig 4: An AXI Read transaction</caption><tr><td><img src="/img/axiaddr/axiaddr-read.svg" alt="" width="360" /></td></tr></table>

<p>Reads are similar, as shown in Fig. 4–also drawn from a <code class="language-plaintext highlighter-rouge">cover()</code> statement
applied to the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">same
core</a>, in that
they also begin on the read address channel.  However, instead of being
followed by a channel of data from the master to the slave, the slave
responds instead by returning the data it has read.  The last item of data
from the returned by the slave is marked with an <code class="language-plaintext highlighter-rouge">RLAST</code> flag and it concludes
the transaction.</p>

<p>Since both the write address and read address packets are very similar, I’ll
describe both together and just use the <code class="language-plaintext highlighter-rouge">Ax</code> prefix to refer to an address
signal that could be on one or the other of the two channels.  When <code class="language-plaintext highlighter-rouge">AxVALID</code>
is true, a transaction request has been placed on the channel.  Several other
values associated with this request will tell you the size and length of
the requested transaction.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">AxADDR</code>.  We just discussed this above.  The AxADDR lines reference the byte
within the burst.</p>

    <p>Just for a fun reference here, I grew up thinking that the word “byte” meant
8-bits of data.  It’s not.  That’s the word “octet”.  A “byte” is the smallest
addressable unit of data on a bus.  For POSIX compliant CPUs, that’s 8-bits.
Other CPUs, to include the original ZipCPU, can have different sized bytes.
In my case, I started out supported 32-bit bytes.</p>

    <p>The <a href="/doc/axi-spec.pdf">AXI</a> bus supports 8-bit bytes, and each byte can be read or written
separately using the <code class="language-plaintext highlighter-rouge">WSTRB</code> signal–but we’re now getting ahead of ourselves.
The key takeaway here is that bytes and octets aren’t necessarily the same
thing, but we can use them interchangably when discussing the <a href="/doc/axi-spec.pdf">AXI</a> protocol.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">AxLEN</code>.  When I first examined <a href="/doc/axi-spec.pdf">AXI</a>,
the <code class="language-plaintext highlighter-rouge">AxLEN</code> field appeared to be the biggest reason to use it.  With a
single request on the address channel, you can request anywhere between one
and 256 values by just setting <code class="language-plaintext highlighter-rouge">AxLEN</code> to 0-255 respectively.</p>

    <p>But how should the address of each of those values be calculated?  That’s the
purpose of the <code class="language-plaintext highlighter-rouge">AxBURST</code> value.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">AxBURST</code> is a two-bit value.  It describes whether the address is to be
fixed (<code class="language-plaintext highlighter-rouge">AxBURST == 2'b00</code>), incremented (<code class="language-plaintext highlighter-rouge">AxBurst == 2'b01</code>), or wrapping
(<code class="language-plaintext highlighter-rouge">AxBurst == 2'b10</code>).</p>

    <p>In general, the address of each beat of the burst will increment by the
number of bytes in a bus word.  Only … it’s never that simple.  Let’s come
back to this in a moment.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">AxSIZE </code>is a three bit value referencing the size of the data transfer.
The size can be anywhere between an octet, <code class="language-plaintext highlighter-rouge">AxSIZE == 3'b000</code>, two octets,
<code class="language-plaintext highlighter-rouge">AxSIZE == 3'b001</code>, four octets, <code class="language-plaintext highlighter-rouge">AxSIZE==3'b010</code>, all the way up to 128
octets when <code class="language-plaintext highlighter-rouge">AxSIZE == 3'b111</code>.</p>

    <p>The rule is that <code class="language-plaintext highlighter-rouge">AxSIZE</code> can only ever be less than or equal to your bus
size.  Since I tend to work with 32-bit busses, that means any <code class="language-plaintext highlighter-rouge">AxSIZE</code> must
be less than or equal to <code class="language-plaintext highlighter-rouge">3'b010</code>.</p>
  </li>
</ul>

<p>These are the four addressing signals we’ll look at today: <code class="language-plaintext highlighter-rouge">AxADDR</code>, <code class="language-plaintext highlighter-rouge">AxLEN</code>,
<code class="language-plaintext highlighter-rouge">AxBURST</code>, and <code class="language-plaintext highlighter-rouge">AxSIZE</code>.  Let’s walk through how to use these as a function
of the burst type.</p>

<h2 id="types-of-burst-addressing">Types of Burst Addressing</h2>

<p>As we mentioned above, there are three basic types of burst addressing: FIXED,
INCREMENT, and WRAP.  An <code class="language-plaintext highlighter-rouge">AxBURST</code> value of <code class="language-plaintext highlighter-rouge">2'b11</code> is reserved, and so illegal.</p>

<p>Let’s look at each of these in turn.</p>

<h3 id="fixed-addressing">Fixed Addressing</h3>

<p>This is perhaps the simplest of all of the addressing modes.  The first address
in the burst is given by <code class="language-plaintext highlighter-rouge">AxADDR</code>, and it never changes from there.  This
means that, within a burst, we can calculate the next address, we’ll call this
<code class="language-plaintext highlighter-rouge">o_next_address</code>, from the last address, we’ll call that <code class="language-plaintext highlighter-rouge">i_last_addr</code> and the
burst type, <code class="language-plaintext highlighter-rouge">i_burst</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="mb">2'b00</span><span class="p">)</span>
		<span class="n">o_next_address</span> <span class="o">=</span> <span class="n">i_last_addr</span><span class="p">;</span></code></pre></figure>

<p>That’s pretty easy.</p>

<p>This would be the perfect addressing mode for reading from a
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
as I described above.  Since a
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
can be represented with a single address, this is perfect.</p>

<p>If I ever get a chance to do a similar contract again, this is how I’d do it.</p>

<p>Today, though, I’m working on <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>
properties.  That kind of forces me to support every mode, so I’m not yet done.</p>

<h3 id="increment-addresses">Increment Addresses</h3>

<p>Increment addressing is the kind of addressing you may be more familiar
with.  It’s the type you’d use when doing a
<a href="http://www.cplusplus.com/reference/cstring/memcpy/">memcpy</a>.
In its simplest form, we might write:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="mb">2'b01</span><span class="p">)</span>
		<span class="n">o_next_address</span> <span class="o">=</span> <span class="n">i_last_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Only that’s not quite right.  <a href="/doc/axi-spec.pdf">AXI</a>
allows you to transfer multiple bytes per transaction, and the
<a href="/doc/axi-spec.pdf">AXI</a> address references the first
byte in each burst.  Hence, if we have a 32-bit data bus, we’d want to
increment our address by four bytes at a time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="mb">2'b01</span><span class="p">)</span>
		<span class="n">o_next_address</span> <span class="o">=</span> <span class="n">i_last_addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span></code></pre></figure>

<p>Even this isn’t quite right.  While <a href="/doc/axi-spec.pdf">AXI</a>
doesn’t require <code class="language-plaintext highlighter-rouge">AxADDR</code> to be an aligned address, all of the subsequent
addresses must be aligned.</p>

<table align="center" style="float: none"><caption>Fig 5: Incremental burst addressing</caption><tr><td><img src="/img/axiaddr/axiaddr-increment.svg" alt="" width="720" /></td></tr></table>

<p>Aligning the addresses isn’t all that hard for a 32-bit bus.  Indeed, we
might simply write,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="mb">2'b01</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_next_address</span> <span class="o">=</span> <span class="n">i_last_addr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

		<span class="c1">// Force subsequent alignment</span>
		<span class="n">o_next_address</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>While we’re making good progress, it’s still not this simple.  Remember the
<code class="language-plaintext highlighter-rouge">AxSIZE</code> parameter?  <code class="language-plaintext highlighter-rouge">AxSIZE</code> determines our increment, not our bus size.
When <code class="language-plaintext highlighter-rouge">AxSIZE==0</code>, the increment is one.  When it’s <code class="language-plaintext highlighter-rouge">3'b001</code>, we increment by
two.  When <code class="language-plaintext highlighter-rouge">AxSIZE==3'b010</code> we increment by four and so on.</p>

<p>We’ll use <code class="language-plaintext highlighter-rouge">i_size</code> to represent <code class="language-plaintext highlighter-rouge">AxSIZE</code> in our pseudocode.  We can then write:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="mb">2'b01</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="nb">increment</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i_size</span><span class="p">);</span>
		<span class="n">o_next_address</span> <span class="o">=</span> <span class="n">i_last_addr</span> <span class="o">+</span> <span class="nb">increment</span><span class="p">;</span></code></pre></figure>

<p>That handles our increment.  The problem now is that alignment is more painful,
since our ultimate alignment depends upon the <code class="language-plaintext highlighter-rouge">AxSIZE</code> of the transaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Force subsequent alignment</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="c1">// 16-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="c1">// 32-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
			<span class="c1">// 64-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
			<span class="c1">// 128-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
			<span class="c1">// 256-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span>
			<span class="c1">// 512-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
			<span class="c1">// 1024-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Voila!  We’ve enforced the alignment we need, and so we can now calculate
the next address during an increment.</p>

<p>I discovered the problem with this approach when I tried to verify the
<a href="/doc/axi-spec.pdf">AXI</a> example code from Vivado.
I built a slave with only 5 bits of address.  In this case, <code class="language-plaintext highlighter-rouge">o_next_addr[6:5]</code>
weren’t defined.  So I added in a test of the address width.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Force subsequent alignment</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
			<span class="c1">// 16-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">))</span>
			<span class="c1">// 32-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">))</span>
			<span class="c1">// 64-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">))</span>
			<span class="c1">// 128-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">))</span>
			<span class="c1">// 256-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">))</span>
			<span class="c1">// 512-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">6</span><span class="p">))</span>
			<span class="c1">// 1024-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>The code now no longer referenced any undefined addresses, since the <code class="language-plaintext highlighter-rouge">AW&gt;x</code>
check found and fixed that.</p>

<p>Only … one of my favorite (unnamed) simulation tools couldn’t handle this.
Perhaps this is because I’m using a very old version of the tool.  For whatever
reason, I had to do something to keep this design from referencing bits I didn’t
have.  I chose the following solution, therefore.  It’s not pretty, but it
worked for <code class="language-plaintext highlighter-rouge">AW = 6</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Force subsequent alignment</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
			<span class="c1">// 16-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">))</span>
			<span class="c1">// 32-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[((</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">))</span>
			<span class="c1">// 64-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[((</span><span class="n">AW</span><span class="o">-</span><span class="mi">2</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="mi">2</span><span class="o">:</span><span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">))</span>
			<span class="c1">// 128-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[((</span><span class="n">AW</span><span class="o">-</span><span class="mi">3</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="mi">3</span><span class="o">:</span><span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">))</span>
			<span class="c1">// 256-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[((</span><span class="n">AW</span><span class="o">-</span><span class="mi">4</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="mi">4</span><span class="o">:</span><span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">))</span>
			<span class="c1">// 512-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[((</span><span class="n">AW</span><span class="o">-</span><span class="mi">5</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="mi">5</span><span class="o">:</span><span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">6</span><span class="p">))</span>
			<span class="c1">// 1024-bit alignment</span>
			<span class="n">o_next_addr</span><span class="p">[((</span><span class="n">AW</span><span class="o">-</span><span class="mi">6</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="mi">6</span><span class="o">:</span><span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>It’s at least good enough that we can move on.</p>

<h3 id="wrapping-addresses">Wrapping Addresses</h3>

<p>Many memories support address wrapping, and the
<a href="/doc/axi-spec.pdf">AXI</a> bus even has a burst type
which will support wrapping addresses.</p>

<table align="center" style="float: none"><caption>Fig 6: Wrap burst addressing</caption><tr><td><img src="/img/axiaddr/axiaddr-wrap.svg" alt="" width="720" /></td></tr></table>

<p>The idea behind address wrapping usually comes from
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
accesses.  An address request from the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
might land anywhere within a given
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
line.  The
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
needs to invalidate and then fill the whole
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
line.  During this time, the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
will be stalled until the value it needs is returned from memory.  If the
value lands towards the middle of the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
line, the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
would have to be stalled during the entire read.  On the other hand, if the
memory can return the middle value of the burst first and then wrap around to
return the first part of the burst, the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
doesn’t need to be stalled nearly as long.</p>

<p>This is why address wrapping is so important.  Indeed, many
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
chips will support address wrapping of some type.</p>

<p>Faster <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
is a good thing, right?</p>

<p>Well … that may be true, but it certainly makes the bus more complicated.</p>

<p>The basic idea of wrapping is that the address bits act as though only some
bits increment, and others don’t.  We can capture this with a bit-wise mask
I’m going to call <code class="language-plaintext highlighter-rouge">wrap_mask</code>.  Using this mask, we can write our address
wrapping code as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="n">WRAP</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="nb">increment</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i_size</span><span class="p">);</span>
		<span class="n">o_next_addr</span> <span class="o">=</span> <span class="n">i_last_addr</span> <span class="o">+</span> <span class="nb">increment</span><span class="p">;</span>

		<span class="n">o_next_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">wrap_mask</span><span class="p">)</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">o_next_addr</span> <span class="o">&amp;</span> <span class="n">wrap_mask</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Now the only trick is to figure out how to generate <code class="language-plaintext highlighter-rouge">wrap_mask</code>.</p>

<p>There are also a couple of rules associated with address wrapping that play
into this as well.  For example, when using address wrapping the first burst
must be aligned.  Similarly, only burst lengths of 2, 4, 8, and 16 are
supported, corresponding to <code class="language-plaintext highlighter-rouge">AxLEN</code> values of 1, 3, 7, and 15 respectively.
We’ll write these rules out in a moment later.</p>

<p>For now, we can calculate our wrap address via,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">wrap_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">wrap_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i_size</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">wrap_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i_size</span><span class="o">+</span><span class="mi">2</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">wrap_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i_size</span><span class="o">+</span><span class="mi">3</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
		<span class="n">wrap_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i_size</span><span class="o">+</span><span class="mi">4</span><span class="p">));</span></code></pre></figure>

<h2 id="all-put-together">All put together</h2>

<p>We’ve now learned how to calculate the next address of an
<a href="/doc/axi-spec.pdf">AXI</a> transaction from the last one.  If
you put <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">all of this code
together</a>,
you’ll get something looking like the following:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`default_nettype</span> <span class="n">none</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="k">module</span>	<span class="n">faxi_addr</span><span class="p">(</span><span class="n">i_last_addr</span><span class="p">,</span>
		<span class="n">i_size</span><span class="p">,</span>
		<span class="n">i_burst</span><span class="p">,</span>
		<span class="n">i_len</span><span class="p">,</span>
		<span class="n">o_incr</span><span class="p">,</span>
		<span class="n">o_next_addr</span><span class="p">);</span>
	<span class="k">parameter</span>	<span class="n">AW</span><span class="o">=</span><span class="mi">32</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_last_addr</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_size</span><span class="p">;</span> <span class="c1">// 1b, 2b, 4b, 8b, etc</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_burst</span><span class="p">;</span> <span class="c1">// fixed, incr, wrap, reserved</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_len</span><span class="p">;</span>
	<span class="kt">output</span>	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">o_incr</span><span class="p">;</span>
	<span class="kt">output</span>	<span class="kt">reg</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">o_next_addr</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span> <span class="n">keep</span> <span class="o">*</span><span class="p">)</span> <span class="kt">reg</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">wrap_mask</span><span class="p">,</span> <span class="nb">increment</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="nb">increment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// verilator lint_off WIDTH</span>
			<span class="k">case</span><span class="p">(</span><span class="n">i_size</span><span class="p">)</span>
			<span class="mi">0</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span>  <span class="mi">1</span><span class="p">;</span>
			<span class="mi">1</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span>  <span class="mi">2</span><span class="p">;</span>
			<span class="mi">2</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span>  <span class="mi">4</span><span class="p">;</span>
			<span class="mi">3</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span>  <span class="mi">8</span><span class="p">;</span>
			<span class="mi">4</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
			<span class="mi">5</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
			<span class="mi">6</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
			<span class="mi">7</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
			<span class="nl">default:</span> <span class="nb">increment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">endcase</span>
			<span class="c1">// verilator lint_on WIDTH</span>
		<span class="k">end</span>
	<span class="k">end</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">wrap_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="mb">2'b10</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">wrap_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i_size</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">wrap_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i_size</span><span class="o">+</span><span class="mi">2</span><span class="p">));</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
				<span class="n">wrap_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i_size</span><span class="o">+</span><span class="mi">3</span><span class="p">));</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
				<span class="n">wrap_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i_size</span><span class="o">+</span><span class="mi">4</span><span class="p">));</span>
			<span class="n">wrap_mask</span> <span class="o">=</span> <span class="n">wrap_mask</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="k">end</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_next_addr</span> <span class="o">=</span> <span class="n">i_last_addr</span> <span class="o">+</span> <span class="nb">increment</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">!=</span> <span class="mb">2'b00</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// Align any subsequent address</span>
			<span class="c1">// verilator lint_off SELRANGE</span>
			<span class="k">if</span><span class="p">(</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">))</span>
				<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">))</span>
				<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;=</span><span class="mi">4</span><span class="p">))</span>
				<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;=</span><span class="mi">5</span><span class="p">))</span>
				<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;=</span><span class="mi">6</span><span class="p">))</span>
				<span class="n">o_next_addr</span><span class="p">[((</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">6</span><span class="p">)</span><span class="o">?</span><span class="mi">5</span><span class="o">:</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">AW</span><span class="o">&gt;=</span><span class="mi">7</span><span class="p">))</span>
				<span class="n">o_next_addr</span><span class="p">[((</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">7</span><span class="p">)</span><span class="o">?</span><span class="mi">6</span><span class="o">:</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="c1">// verilator lint_on  SELRANGE</span>
		<span class="k">end</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="mb">2'b10</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// WRAP!</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">wrap_mask</span><span class="p">)</span>
					<span class="o">|</span> <span class="p">(</span><span class="n">o_next_addr</span> <span class="o">&amp;</span> <span class="n">wrap_mask</span><span class="p">);;</span>
		<span class="k">end</span>
	<span class="k">end</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_incr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">o_incr</span><span class="p">[((</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">7</span><span class="p">)</span><span class="o">?</span><span class="mi">7</span><span class="o">:</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">increment</span><span class="p">[((</span><span class="n">AW</span><span class="o">&gt;</span><span class="mi">7</span><span class="p">)</span><span class="o">?</span><span class="mi">7</span><span class="o">:</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">end</span>
<span class="k">endmodule</span></code></pre></figure>

<p>The problem with this code, however, is that it takes up way too much logic.
You can see this by running:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">yosys <span class="nt">-p</span> <span class="s1">'read_verilog axi_addr.v; synth_xilinx; stat'</span></code></pre></figure>

<p>If you look at the tail end of the output, you’ll find that <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">this
design</a>
requires the following logic elements:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">   Number of cells:                392
     LUT1                            5
     LUT2                           52
     LUT3                           15
     LUT4                           27
     LUT5                            3
     LUT6                           89
     MUXCY                          74
     MUXF7                          43
     MUXF8                           4
     XORCY                          80</code></pre></figure>

<p>We can do better.  Indeed, we can do <em>much</em> better.</p>

<h2 id="formal-properties">Formal properties</h2>

<p>So, while preparing this article, I spent some time trying to optimize <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">this
address calculator</a>
to both make it simpler, and to lower the amount of logic it uses.  Along the
way, I made some amazing optimizations and managed to get
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">this core</a>
down to fewer than 67 elements.  After beating my chest for way to long, I went
back back to try to <a href="/blog/2017/10/19/formal-intro.html">formally
verify</a>
some of my cores that used <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">this address
calculator</a>.</p>

<p><a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">This one failed</a>.</p>

<p>Now I was stuck.  Which optimization failed, and how do I roll back just the
right ones?</p>

<p>It was time to turn to <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>.</p>

<table align="center" style="float: right"><caption>Fig 7: A basic miter circuit, to prove two cores are equivalent</caption><tr><td><img src="/img/axiaddr/axiaddr-miter.svg" alt="" width="360" /></td></tr></table>

<p><a href="/blog/2017/10/19/formal-intro.html">Formal verification</a>
in this context was a bit different from many of the other proofs I’ve done,
primarily because what I wanted to do was to make sure that when I optimized
my work, the result doesn’t change.  Ideally, what I’d like to be able to do
is something like comparing two cores,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">one optimized</a>
and <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">one not</a>,
to prove that the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">optimized
one</a>
still does the same thing as the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">reference
design</a>.</p>

<p>Yes, <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a> can do this too.</p>

<p>The basic setup is shown in Fig. 7 on the right.  First, I created a <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/axi_addr_miter.v">miter
circuit</a>–one
with both the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">reference address calculation code</a> as well as the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">optimized code
I was testing</a>.
We’ll call these <code class="language-plaintext highlighter-rouge">ref</code> for <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">reference address
calculator</a>
and <code class="language-plaintext highlighter-rouge">uut</code> for the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">unit under
test</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">axi_addr_miter</span><span class="p">(</span><span class="n">i_last_addr</span><span class="p">,</span> <span class="n">i_size</span><span class="p">,</span> <span class="n">i_burst</span><span class="p">,</span> <span class="n">i_len</span><span class="p">);</span>
	<span class="k">parameter</span>	<span class="n">AW</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
			<span class="n">DW</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_last_addr</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_size</span><span class="p">;</span> <span class="c1">// 1b, 2b, 4b, 8b, etc</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_burst</span><span class="p">;</span> <span class="c1">// fixed, incr, wrap, reserved</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_len</span><span class="p">;</span>

	<span class="k">localparam</span>	<span class="n">DSZ</span> <span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">DW</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">;</span></code></pre></figure>

<p>Let me pause here for a moment, since <code class="language-plaintext highlighter-rouge">DSZ</code> is going to become a very important
part of our logic in a moment.</p>

<p>If you ever look through a piece of
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
generated <a href="/doc/axi-spec.pdf">AXI</a>
code like <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this
one</a>,
you’ll see things like <code class="language-plaintext highlighter-rouge">C_S_AXI_ADDR_WIDTH</code> and <code class="language-plaintext highlighter-rouge">C_S_AXI_DATA_WIDTH</code>.  You
might read these as the address width and data width respectively associated
with the slave interface.  I personally try to avoid these parameter names
if I can, just because I try to fit my logic on an 80-column display and these
long names make my task more difficult.  So, instead of using very expressive
terms like these, I regularly use <code class="language-plaintext highlighter-rouge">AW</code> for address width and <code class="language-plaintext highlighter-rouge">DW</code> for data
width.  In this case, the two are the same.  (Normally I’d using <code class="language-plaintext highlighter-rouge">AW</code> to
reference a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
address width, which as we’ve discussed above doesn’t include the
subword address bits.)</p>

<p><code class="language-plaintext highlighter-rouge">DSZ</code> is a value derived from the data width.  It’s designed so that a
<code class="language-plaintext highlighter-rouge">DSZ</code> of 0 is equivalent to a <code class="language-plaintext highlighter-rouge">DW==8</code>, whereas <code class="language-plaintext highlighter-rouge">DSZ==1</code> is equivalent to a
<code class="language-plaintext highlighter-rouge">DW==16</code> and so forth.  It has the same representation as <code class="language-plaintext highlighter-rouge">i_size</code>, but rather
describes the maximum <code class="language-plaintext highlighter-rouge">i_size</code> the bus can hold.  Two <code class="language-plaintext highlighter-rouge">DSZ</code> values that will
be of high interest to me are <code class="language-plaintext highlighter-rouge">DSZ==2</code>, corresponding to a bus width of
32-bits, and <code class="language-plaintext highlighter-rouge">DSZ==3</code>, corresponding to a bus width of 64-bits.</p>

<p>You’ll see <code class="language-plaintext highlighter-rouge">DSZ</code> often in the discussion that follows.</p>

<p>Now we can return to the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/axi_addr_miter.v">miter
circuit</a>,
and show the instantiations of our two designs, both
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">reference</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">////////////////////////////////////////////////////////////////////////</span>
	<span class="c1">//</span>
	<span class="c1">// The reference address calculator</span>
	<span class="c1">//</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">ref_incr</span><span class="p">;</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">ref_next_addr</span><span class="p">;</span>

	<span class="n">faxi_addr</span> <span class="p">#(.</span><span class="n">AW</span><span class="p">(</span><span class="n">AW</span><span class="p">))</span>
		<span class="kt">ref</span><span class="p">(</span><span class="n">i_last_addr</span><span class="p">,</span> <span class="n">i_size</span><span class="p">,</span> <span class="n">i_burst</span><span class="p">,</span> <span class="n">i_len</span><span class="p">,</span><span class="n">ref_incr</span><span class="p">,</span><span class="n">ref_next_addr</span><span class="p">);</span></code></pre></figure>

<p>and our <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">uut, or unit under
test</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">////////////////////////////////////////////////////////////////////////</span>
	<span class="c1">//</span>
	<span class="c1">// The optimized address calculator, our "unit-under-test"</span>
	<span class="c1">//</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">uut_next_addr</span><span class="p">;</span>

	<span class="n">axi_addr</span> <span class="p">#(.</span><span class="n">AW</span><span class="p">(</span><span class="n">AW</span><span class="p">),</span> <span class="p">.</span><span class="n">DW</span><span class="p">(</span><span class="n">DW</span><span class="p">))</span>
		<span class="n">uut</span><span class="p">(</span><span class="n">i_last_addr</span><span class="p">,</span> <span class="n">i_size</span><span class="p">,</span> <span class="n">i_burst</span><span class="p">,</span> <span class="n">i_len</span><span class="p">,</span> <span class="n">uut_next_addr</span><span class="p">);</span></code></pre></figure>

<p>At this point, I could’ve created my two assertions and been done.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">uut_incr</span> <span class="o">==</span> <span class="n">ref_incr</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">uut_next_addr</span> <span class="o">==</span> <span class="n">ref_next_addr</span><span class="p">);</span>

<span class="k">endmodule</span></code></pre></figure>

<p>The only problem with this quick approach is that the inputs need to be
constrained.  Many of the possible input values are disallowed by the
<a href="/doc/axi-spec.pdf">AXI</a> specification.  What we really want
to do is to assert that the two circuits produce identical results for <em>valid</em>
<a href="/doc/axi-spec.pdf">AXI</a> burst transactions values.</p>

<p>Let’s work through some possible restrictions.</p>

<p>We already known that bursts may be fixed, incrementing or wrapped.  An
<code class="language-plaintext highlighter-rouge">i_burst</code> value of <code class="language-plaintext highlighter-rouge">2'b11</code>, the third possibility, is illegal as per the spec.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_burst</span> <span class="o">!=</span> <span class="mb">2'b11</span><span class="p">);</span></code></pre></figure>

<p>In a similar fashion, the <code class="language-plaintext highlighter-rouge">i_size</code> input can only ever specify a transaction
width equal to or smaller than the current bus size.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_size</span> <span class="o">&lt;=</span> <span class="n">DSZ</span><span class="p">);</span></code></pre></figure>

<p>We also know that, for wrapping bursts, the length of the burst may only ever
be 2, 4, 8, or 16 beats.  Since <code class="language-plaintext highlighter-rouge">AxLEN</code> is one less than the total number of
transfers, this turns into a restriction that <code class="language-plaintext highlighter-rouge">i_len</code> must be 1, 3, 7, or 15.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="mb">2'b10</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">((</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="o">||</span><span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
			<span class="o">||</span><span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
			<span class="o">||</span><span class="p">(</span><span class="n">i_len</span> <span class="o">==</span> <span class="mi">15</span><span class="p">));</span></code></pre></figure>

<p>The specification also says that wrapped bursts must be aligned.  So lets
check for alignment on the incoming address.  Remember the master rule of
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>:
<em>assume</em> inputs, <em>assert</em> any local state and outputs.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Determine if the incoming address is aligned</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">aligned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">case</span><span class="p">(</span><span class="n">DSZ</span><span class="p">)</span>
		<span class="mb">3'b000</span><span class="o">:</span> <span class="n">aligned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="mb">3'b001</span><span class="o">:</span> <span class="n">aligned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="mb">3'b010</span><span class="o">:</span> <span class="n">aligned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="mb">3'b011</span><span class="o">:</span> <span class="n">aligned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="mb">3'b100</span><span class="o">:</span> <span class="n">aligned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="mb">3'b101</span><span class="o">:</span> <span class="n">aligned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="mb">3'b110</span><span class="o">:</span> <span class="n">aligned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="mb">3'b111</span><span class="o">:</span> <span class="n">aligned</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">endcase</span>
	<span class="k">end</span></code></pre></figure>

<p>Now that we can tell whether or not the address is aligned, we can assume that
any wrapped addresses are properly aligned on entry.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">==</span> <span class="mb">2'b10</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">aligned</span><span class="p">);</span></code></pre></figure>

<p>There’s one final bit of tweaking required.
<a href="/doc/axi-spec.pdf">AXI</a> addresses are not allowed to wrap
over 4kB boundaries.  That means that only the bottom twelve bits will ever be
allowed to change.</p>

<p>This suggests a quick and valuable simplification, one that would force any
address bits above 12 to be constant across a burst:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">AW</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">)</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_last_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">12</span><span class="p">];</span></code></pre></figure>

<p>The problem with doing this is that my <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">reference address
calculator</a>
doesn’t have this code.</p>

<p>The reason why the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">reference</a>
doesn’t make certain that the top addresses are
constant is that I’d like to use an assertion in my new
<a href="/doc/axi-spec.pdf">AXI4</a>
formal property file to make certain the address pointer never wraps across
a 4kB.  In other words, my
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxi_addr.v">reference</a>
requires that addresses be able to cross 4kB boundaries so I can detect
a problem, whereas my <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi_addr.v">optimized
code</a>
won’t let things wrap.</p>

<p>A basic simplifying assumption will keep us from testing the 4kB wrap.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">AW</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_last_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">==</span> <span class="n">ref_next_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">12</span><span class="p">]);</span></code></pre></figure>

<p>As we’ve written it, our address calculator is highly parameterizable across
a wide variety of bus widths, <code class="language-plaintext highlighter-rouge">DW</code>.  To capture this, we’ll define a series
of tasks within our <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
file.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[tasks]
prf8
prf16
prf32
prf64
prf128
prf256
prf512
prf1024</code></pre></figure>

<p>Each task corresponds to a different bus width, which we can set using the
<a href="http://www.clifford.at/yosys/cmd_chparam.html">chparam</a> command within the
<a href="http://www.clifford.at/yosys">Yosys</a> script section of our
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a> configuration file.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[script]
read -formal axi_addr.v
read -formal faxi_addr.v
read -formal axi_addr_miter.v
prf8:    chparam -set DW    8 axi_addr_miter
prf16:   chparam -set DW   16 axi_addr_miter
prf32:   chparam -set DW   32 axi_addr_miter
prf64:   chparam -set DW   64 axi_addr_miter
prf128:  chparam -set DW  128 axi_addr_miter
prf256:  chparam -set DW  256 axi_addr_miter
prf512:  chparam -set DW  512 axi_addr_miter
prf1024: chparam -set DW 1024 axi_addr_miter

prep -top axi_addr_miter</code></pre></figure>

<p>We’re now ready to test any optimizations.  So let’s take a new look at the
code above to se if we can optimize the basic address calculator to use fewer
than 392 logic cells, while maintaining the same logic.</p>

<h2 id="making-optimizations">Making Optimizations</h2>

<p>Back at ORCONF 2017 in Hebden Bridge, I had the wonderful opportunity to meet
<a href="https://twitter.com/jangray">Jan Gray</a>, an individual who had <a href="http://fpga.org/2017/12/01/grvi-phalanx-update-presentation-at-the-7th-risc-v-workshop/">managed to place
many</a>
600?-<a href="/blog/2017/06/12/minimizing-luts.html">LUT</a>
RISC-V <a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-cores</a>
inside a <a href="https://www.xilinx.com">Xilinx</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.  I asked
him about how he managed to get his
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-cores</a>
so small.  Among other pieces of advice he gave, one which we’ll work with
today is to, “Make every
<a href="/blog/2017/06/12/minimizing-luts.html">LUT</a> within your
design justify its existence.”</p>

<p>So let’s apply that attitude to our code today, to see what or how we might
optimize it.</p>

<p>Let’s start with the increment.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="nb">increment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="nb">increment</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>What if we knew that, in a valid transaction, <code class="language-plaintext highlighter-rouge">i_size</code> would be less than
<code class="language-plaintext highlighter-rouge">3'h2</code> for a 32-bit bus?
Why examine all three bits of <code class="language-plaintext highlighter-rouge">i_size</code>, when you know the top bit will always
be zero?  Similarly, if the bus size is already 8-bits, then you already know
the increment can only ever be one.</p>

<p>The following code captures some of these assumptions.  While it takes more
lines and appears more complex, the logic it generates may well be smaller.</p>

<p>Remember, <code class="language-plaintext highlighter-rouge">DSZ</code> is equal to <code class="language-plaintext highlighter-rouge">$clog2(DW)-3</code>–essentially our current bus size
but in the units of <code class="language-plaintext highlighter-rouge">i_size</code>.  Further, as per the
<a href="/doc/axi-spec.pdf">AXI spec</a>, we know that <code class="language-plaintext highlighter-rouge">i_size &lt;= DSZ</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="nb">increment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">DSZ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="nb">increment</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DSZ</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="nb">increment</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DSZ</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
				<span class="nb">increment</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="p">((</span><span class="n">i_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DSZ</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
				<span class="k">case</span><span class="p">(</span><span class="n">i_size</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
				<span class="mb">2'b00</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="mb">2'b01</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="mb">2'b10</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="mb">2'b11</span><span class="o">:</span> <span class="nb">increment</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
				<span class="k">endcase</span>
			<span class="k">else</span>
				<span class="nb">increment</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i_size</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>You’ll notice that if <code class="language-plaintext highlighter-rouge">DSZ[2]</code> is high then we use the same logic we had before.</p>

<p>Now let’s turn our attention to the wrap mask.</p>

<p>Since we’re only going to use this value if <code class="language-plaintext highlighter-rouge">i_burst == 2'b10</code>, and ignore
it otherwise, we can set it for all cases.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Start with the default, minimum mask</span>
		<span class="n">wrap_mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>My initial approach to set the lower mask bits, <code class="language-plaintext highlighter-rouge">wrap_mask[i_size:0] = -1</code>,
didn’t work with all of the Verilog parsers I use, so I decided to try using
a <code class="language-plaintext highlighter-rouge">for</code> loop.</p>

<p>I normally discourage the use of <code class="language-plaintext highlighter-rouge">for</code> loops within Verilog.  Most beginning
designers who use them treat them like they would a piece of C/C++ code,
when in actuality the <a href="/blog/2017/09/18/clocks-for-sw-engineers.html">synthesis tool will unroll every loop creating more
logic with each
iteration.</a>
When used poorly, loops end up creating much more
hardware logic than a good design would in practice.</p>

<p>In this case, I wanted to create a different piece of logic to describe
each bit.  Therefore, I tried using a for loop to define each of the bits in
the <code class="language-plaintext highlighter-rouge">wrap_mask</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">for</span><span class="p">(</span><span class="n">iB</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">iB</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="n">iB</span><span class="o">=</span><span class="n">iB</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">{</span><span class="mb">1'b0</span><span class="p">,</span><span class="n">i_size</span><span class="o">}</span> <span class="o">&gt;</span> <span class="n">iB</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">wrap_mask</span><span class="p">[</span><span class="n">iB</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>After staring at this for a while, I realized there was no optimizations
within it for the maximum possible <code class="language-plaintext highlighter-rouge">i_size</code> value.  Since <code class="language-plaintext highlighter-rouge">DSZ</code> is a parameter,
and since the loop index value, <code class="language-plaintext highlighter-rouge">iB</code>, is essentially a constant once the loop
logic is implemented, I could add a check into the for loop.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">for</span><span class="p">(</span><span class="n">iB</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">iB</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="n">iB</span><span class="o">=</span><span class="n">iB</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">DSZ</span> <span class="o">&gt;</span> <span class="n">iB</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">{</span><span class="mb">1'b0</span><span class="p">,</span><span class="n">i_size</span><span class="o">}</span> <span class="o">&gt;</span> <span class="n">iB</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]))</span>
			<span class="n">wrap_mask</span><span class="p">[</span><span class="n">iB</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>This check, <code class="language-plaintext highlighter-rouge">DSZ &gt; iB</code>, would allow the synthesis tool to remove any of the
unused possibilities, leaving <code class="language-plaintext highlighter-rouge">wrap_mask</code> unchanged in this case.</p>

<p>We still need to add in the next three bits to the mask, those dependent upon
the length of the burst.  When I did this before, I used a series of <code class="language-plaintext highlighter-rouge">if</code>s.
If you look a bit closer, though, you’ll notice that <code class="language-plaintext highlighter-rouge">i_len[3]</code> will only
be high if all of the other <code class="language-plaintext highlighter-rouge">i_len[2:0]</code> bits are already ones.  Similarly,
<code class="language-plaintext highlighter-rouge">i_len[2]</code> will only be high if <code class="language-plaintext highlighter-rouge">i_len[1:0]</code> is high, and so on down.  That
means we can calculate the next several bits of the <code class="language-plaintext highlighter-rouge">wrap_mask</code> by simply
shifting <code class="language-plaintext highlighter-rouge">i_len[3:1]</code> up to the right location.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">wrap_mask</span> <span class="o">=</span> <span class="n">wrap_mask</span> <span class="o">|</span> <span class="p">(</span><span class="o">{</span><span class="mh">29'h0</span><span class="p">,</span><span class="n">i_len</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span><span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i_size</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span></code></pre></figure>

<p>Why not check all of <code class="language-plaintext highlighter-rouge">i_len[3:0]</code>?  Because we already know that <code class="language-plaintext highlighter-rouge">i_len[0]</code>
will be true for all possible wrap bursts.</p>

<p>I also know that the addresses within a burst can never cross a 4kB boundary.
These upper address bits must be constant.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">AW</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">)</span>
			<span class="n">wrap_mask</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Then I got to thinking … I already know that the initial address of any
burst with wrap addressing must be aligned from start to finish, so it really
doesn’t matter what the lower bits of this value are set to.</p>

<p>This allowed me to back up and remove the <code class="language-plaintext highlighter-rouge">for</code> loop entirely.  I then replaced
the shift line with,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">wrap_mask</span> <span class="o">=</span> <span class="n">wrap_mask</span> <span class="o">|</span> <span class="p">(</span><span class="o">{{</span><span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span><span class="n">i_len</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="n">i_size</span><span class="p">);</span></code></pre></figure>

<p>Notice throughout these optimizations that we’re primarily using logic based
upon constant values.  This helps to keep us from increasing the amount
of necessary logic, rather than decreasing it.</p>

<p>The next block actually calculates the next address, as we’ve discussed above.
The first step, shown below, has really already been optimized.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_next_addr</span> <span class="o">=</span> <span class="n">i_last_addr</span> <span class="o">+</span> <span class="nb">increment</span><span class="p">;</span></code></pre></figure>

<p>This brings us to our alignment code, where we force the next address to be
word aligned based upon both <code class="language-plaintext highlighter-rouge">DSZ</code> and <code class="language-plaintext highlighter-rouge">i_size</code>.</p>

<p>My first attempt to align the next address was to switch our <a href="/zipcpu/2019/03/28/return-decoding.html">cascaded if
statement to a case
statement</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">!=</span> <span class="mb">2'b00</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// Align any subsequent address</span>
			<span class="k">case</span><span class="p">(</span><span class="n">i_size</span><span class="p">)</span>
			<span class="mb">3'b001</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span>  <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="mb">3'b010</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="mb">3'b011</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="mb">3'b100</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="mb">3'b101</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="mb">3'b110</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="mb">3'b111</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="nl">default:</span> <span class="n">o_next_addr</span> <span class="o">=</span> <span class="n">o_next_addr</span><span class="p">;</span>
			<span class="k">endcase</span>
		<span class="k">end</span></code></pre></figure>

<p>This helped, and performed okay, but I thought I might be able to do better.</p>

<p>Remembering that <code class="language-plaintext highlighter-rouge">i_size</code> must always be <code class="language-plaintext highlighter-rouge">i_size &lt;= DSZ</code>, I optimized this
for each of the possible ranges of bits in <code class="language-plaintext highlighter-rouge">i_size</code>.  For example, if
<code class="language-plaintext highlighter-rouge">DSZ==0</code>, the bus is then only <code class="language-plaintext highlighter-rouge">DW=8</code>-bits wide, and nothing needs to be
done to align an address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span> <span class="o">!=</span> <span class="mb">2'b00</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// Align any subsequent address</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">DSZ</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">begin</span> <span class="k">end</span></code></pre></figure>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">DSZ</code> is less than two, then our bus size must be either
<code class="language-plaintext highlighter-rouge">DW=8</code> bits or <code class="language-plaintext highlighter-rouge">DW=16</code> bits.  In that case, alignment requires only checking
<code class="language-plaintext highlighter-rouge">i_size[0]</code> and clearing <code class="language-plaintext highlighter-rouge">o_next_addr[0]</code> or leaving it alone.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DSZ</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">begin</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
					<span class="n">o_next_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>While we’ll get to a point of diminishing returns soon, we can still apply this
optimization to both <code class="language-plaintext highlighter-rouge">DSZ &lt; 4</code> and then just leave things as they were
otherwise.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DSZ</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
			<span class="k">begin</span>
				<span class="k">case</span><span class="p">(</span><span class="n">i_size</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
				<span class="c1">// ...</span>
				<span class="k">endcase</span>
			<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
				<span class="k">case</span><span class="p">(</span><span class="n">i_size</span><span class="p">)</span>
				<span class="mb">3'b001</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span>  <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="mb">3'b010</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="mb">3'b011</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="mb">3'b100</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="mb">3'b101</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="mb">3'b110</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="mb">3'b111</span><span class="o">:</span>  <span class="n">o_next_addr</span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="nl">default:</span> <span class="n">o_next_addr</span> <span class="o">=</span> <span class="n">o_next_addr</span><span class="p">;</span>
				<span class="k">endcase</span>
			<span class="k">end</span>
		<span class="k">end</span></code></pre></figure>

<p>The final couple of lines then are nearly unchanged.  The only difference is
that instead of checking for whether or not <code class="language-plaintext highlighter-rouge">i_burst == 2'b10</code>, we can simplify
this into just checking for <code class="language-plaintext highlighter-rouge">i_burst[1]</code>, since we know that <code class="language-plaintext highlighter-rouge">i_burst==2'b11</code>
is already an invalid input.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">i_burst</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">begin</span>
			<span class="c1">// WRAP!</span>
			<span class="n">o_next_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_last_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">wrap_mask</span><span class="p">)</span>
					<span class="o">|</span> <span class="p">(</span><span class="n">o_next_addr</span> <span class="o">&amp;</span> <span class="n">wrap_mask</span><span class="p">);;</span>
		<span class="k">end</span>
	<span class="k">end</span>
<span class="k">endmodule</span></code></pre></figure>

<p>With each change, we can now run both <a href="http://www.clifford.at/yosys">Yosys</a>,
to <a href="/zipcpu/2019/03/28/return-decoding.html">see if the change reduced the amount of
logic</a>, as well as
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a> to see if our change
broke our design or not.</p>

<p>What about the logic count?  After all of this work tweaking and adjusting
things, how did we do?</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">   Number of cells:                 49
     LUT2                            1
     LUT3                           11
     LUT4                            5
     LUT5                            1
     LUT6                            7
     MUXCY                          11
     MUXF7                           1
     XORCY                          12</code></pre></figure>

<p>Given that we started with 392 cells, 49 is a tremendous improvement.</p>

<p>But how many <a href="/blog/2017/06/12/minimizing-luts.html">LUTs</a>
does this logic consume?  A 7-series
<a href="https://www.xilinx.com">Xilinx</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
has 6 input <a href="/blog/2017/06/12/minimizing-luts.html">LUTs</a>,
not <code class="language-plaintext highlighter-rouge">LUT1</code>s, <code class="language-plaintext highlighter-rouge">LUT2</code>s, <code class="language-plaintext highlighter-rouge">LUT3</code>s, and so on.  To make scoring logic usage a touch
more difficult, two <code class="language-plaintext highlighter-rouge">LUT5</code>s can be combined into a <code class="language-plaintext highlighter-rouge">LUT6</code>–provided that they
share the same five bit inputs.  Therefore, I’ll often summarize a logic count
by adding the number of <code class="language-plaintext highlighter-rouge">LUT6</code>s to the number of <code class="language-plaintext highlighter-rouge">LUT5</code>s, to the maximum of
the number of <code class="language-plaintext highlighter-rouge">LUT4</code>s and <code class="language-plaintext highlighter-rouge">LUT1</code>s, to the maximum of the number of <code class="language-plaintext highlighter-rouge">LUT3</code>s
and <code class="language-plaintext highlighter-rouge">LUT2</code>s.  While this most certainly
overestimates the score, it does manage to capture some of the effects of
packing into our metric.</p>

<p>Here’s the final logic score, therefore: before optimization we needed 171
<a href="https://www.xilinx.com">Xilinx</a>
6-<a href="/blog/2017/06/12/minimizing-luts.html">LUTs</a>.  After
optimization, our new design can perform an
<a href="/doc/axi-spec.pdf">AXI</a> addresses calculation using only 24
<a href="/blog/2017/06/12/minimizing-luts.html">LUTs</a> on a bus
having 32-data bits and 32-address bits.  That’s a reduction of over 7x,
so it was definitely worth our time.</p>

<h2 id="conclusion">Conclusion</h2>

<p><a href="/doc/axi-spec.pdf">AXI</a> is certainly one of the most
complicated buses I’ve ever worked with.  It’s so complicated that I’m only
discussing <a href="/doc/axi-spec.pdf">AXI</a> addressing today.
However, in order to properly respond to a bus request from an
<a href="/doc/axi-spec.pdf">AXI</a> master, a slave core will need to
properly generate the addresses of any transaction it is responding to.</p>

<p>One fascinating discovery I made along the way is that <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s example AXI
slave</a>
doesn’t even implement all of this logic.  Instead, it only implements
a 32-bit bus width and <code class="language-plaintext highlighter-rouge">i_size == 3'b010</code> addressing.  You’d think for the cost
of only 14 <a href="/blog/2017/06/12/minimizing-luts.html">LUTs</a>,
the cost of implementing all of the <code class="language-plaintext highlighter-rouge">i_size</code> options, they might have included
the rest.</p>

<p>Of course, since <a href="/doc/axi-spec.pdf">AXI</a> is so complicated,
there’s still plenty more to discuss.  <a href="https://www.blueletterbible.org/kjv/jas/4/15">If the Lord
wills</a>,
I’d like to return and present the bugs I’ve found in <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s example AXI
slave</a>
core, the formal property file’s I’ve managed to create in order to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
a (full) <a href="/doc/axi-spec.pdf">AXI4</a> slave core, as well
as some of the other cores that became easy to build once I had the property
files to work with.</p>

<p>These topics, however, will all need to wait for another day.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Remember now thy Creator in the days of thy youth, while the evil days come not, nor the years draw nigh, when thou shalt say, I have no pleasure in them (Ecc 12:1)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
