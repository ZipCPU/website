<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Putting the pieces together to build a data recorder</title>
  <meta name="description" content="Gisselquist Technology,LLC, makes its money primarily off of contract work.  I sell occasional licensesto my IP cores, and occasionally teach students, but m...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2019/11/14/sdspi.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/#training">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Putting the pieces together to build a data recorder</h1>
    <p class="post-meta"><time datetime="2019-11-14T00:00:00-05:00" itemprop="datePublished">Nov 14, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="/about/gisselquist-technology.html">Gisselquist Technology</a>,
LLC, makes its money primarily off of contract work.  I sell occasional licenses
to my IP cores, and occasionally teach students, but most of my income is
primarily coming from building designs for customers.</p>

<p>How I got to this point as a small businessman is a topic for another day,
although one I would very much like to share.</p>

<p>For today, though, I’d like to discuss a project I’ve recently been working on:
a basic data recorder.</p>

<p>Well, that’s not quite it.  You can purchase data recorders on the market
for perhaps cheaper than my hours on this project.</p>

<table align="center" style="float: none"><caption>Fig 1. A basic communications channel</caption><tr><td><img src="/img/sdspi/comms-channel.svg" alt="" width="480" /></td></tr></table>

<p>The actual purpose of the
project is to design and build a special SONAR communications system and
perhaps even a new waveform design to support it, but the first step to getting
such a project going is to be able to transmit through a steel medium and then
to receive the result on the other side.  The focus of this part of the project
was on successfully receiving the transmitted waveform.</p>

<table align="center" style="float: right"><caption>Fig 2. Digilent's Nexys Video Board</caption><tr><td><img src="/img/nexys-video.png" alt="" width="473" /></td></tr></table>

<p>Early on, <a href="https://www.extremesonar.com">my customer, ExtremeSonar</a>, and I
chose a <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">Nexys Video board</a> for the task.  Why?
First, because I already had the board.  Second, because the FPGA on the board
was beefy–it’s really overkill for this project.  With such a large FPGA I
won’t have to worry about running out of logic along the way.  Third,
we chose this board because it’s an awesome all-around board for a lot of
things.  In other words, we though that this one board might serve us well
for multiple contracts.</p>

<h2 id="controlling-the-transmitter">Controlling the Transmitter</h2>

<p>The first part of the design was to build a transmitter that could select
between multiple different waveforms and waveform parameters as we measured
how the medium (solid steel) would respond to these various shapes.</p>

<p>We had several waveforms we wanted to try.  Building the transmitter was easy,
and essentially done in an afternoon.</p>

<p>Then I ran into my first problem: how shall the board be controlled?</p>

<table align="center" style="float: left"><caption>Fig 3. Switch-controlled Transmitter</caption><tr><td><img src="/img/sdspi/txmux.svg" alt="" width="360" /></td></tr></table>

<p>The easy answer was to build a design that could be controlled via one or
more of the on-board switches.  This worked great at the beginning when I
wanted to try out four specific waveforms, but each waveform had parameters
to it: what modulation should be used?  What bit rate should be sent?  There
were also some hardware specific parameters as well associated with the energy
in the transmitted waveform.</p>

<p>It didn’t take long before the sixteen switches on the board just weren’t
enough.</p>

<p>My usual approach to solving this problem would be to connect a
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus</a>
over the serial port and control the waveforms in as much detail as I wanted.</p>

<p>My customer didn’t have access to my debugging bus software, nor did he want
that type of low-level access.  He wanted a design he could just “plug in”
that would then “just work.”</p>

<p>My second approach to this would be to place a
<a href="/about/zipcpu.html">ZipCPU</a> on the FPGA so that it could
be configured in a more user friendly fashion over a serial port console.</p>

<p>The problem with this approach is that, without the
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus</a>,
I can’t load flash data into a design.  Specifically, I can’t load the
<a href="/about/zipcpu.html">ZipCPU</a>’s software
on board.  Sure, Vivado would load a flash configuration into a design for
me–but would Vivado load a
<a href="/about/zipcpu.html">ZipCPU</a> program?  Yes, I suppose
I might’ve bit the bullet and placed a
<a href="https://en.wikipedia.org/wiki/MicroBlaze">MicroBlaze CPU</a> within the design
and done just that.  As you’ll see later on in this article, there were good
reasons for not doing that.</p>

<p>Instead, I chose to create a ROM memory device on board that would hold the
<a href="/about/zipcpu.html">ZipCPU</a>’s
software and then control the transmitter from that.</p>

<p>This worked great, and formed the substance of my first delivery.  The biggest
problem I had with that delivery was that the <a href="https://ttssh2.osdn.jp/index.html">serial port software my customer
was using</a> didn’t support 2MBaud.  I suppose
this shouldn’t be such a surprise, 2MBaud isn’t really a common rate.  I was
more surprised to learn that it didn’t support the more common 115.2K Baud
either.  No, I’d need to run the project at 9600 Baud.  Still, for just a
basic console, this is plenty fast.  For transferring data?  Unacceptable, but
we haven’t gotten there yet.</p>

<h2 id="part-two-receive-data-processing">Part Two: Receive Data Processing</h2>

<p>Building a transmitter is easy.  Making it work with a receiver, that’s much
harder.</p>

<table align="center" style="float: right"><caption>Fig 4. Block Receiver Design</caption><tr><td><img src="/img/sdspi/initial-receiver.svg" alt="" width="540" /></td></tr></table>

<p>Early on in the project I started building such a receiver, much like the one
shown in Fig. 4 on the right.  However, when we started questioning how the
medium would respond to one data rate vs another, one waveform vs another, etc,
I had to abandon those plans.  The problem was that I wanted to build a
receiver for a waveform of a known symbol type and bit rate, and yet we didn’t
yet know if the channel would support either that symbol type and bit rate
or not.</p>

<p>We chose instead to record data for offline processing, figuring that if we
could demonstrate an offline demodulator for such a data element then it would
be easier to place it onto an FPGA.</p>

<p>In hindsight, this should’ve always been my approach from the beginning:</p>

<ol>
  <li>Build a simulation.</li>
  <li>Demonstrate that the algorithms work in simulation.</li>
  <li>Port the simulation to hardware</li>
</ol>

<table align="center" style="float: left"><caption>Fig 5. Intermediate Design Step</caption><tr><td><img src="/img/sdspi/intermediate-block-processing.svg" alt="" width="360" /></td></tr></table>

<p>Therefore, I scrapped my early receiver drafts and focused instead on getting
sampled data I could use to feed such a simulation.</p>

<p>Steel has some very real acoustic properties, and without knowing what those
were success might be a challenge.  Real data, however, required something
I didn’t yet have: a data recorder.</p>

<table align="center" style="float: right"><caption>Fig 6. Hardware goal: real-time processing</caption><tr><td><img src="/img/sdspi/goal-streaming.svg" alt="" width="360" /></td></tr></table>

<p>Once I had that data recorder, I could then prove any receiver algorithms
and then port the results to hardware.</p>

<p>Today’s story is about building that data recorder.</p>

<h2 id="building-the-data-recorder">Building the Data Recorder</h2>

<p>Surely a data recorder would be fairly easy: The
<a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">Nexys Video board</a>
has 512MB of SDRAM on it–plenty to stream data into.  Indeed, if I streamed
data into the board at a maximum speed of 800Mbps (well higher than any
desired data rate), there would then be enough room to record over 5s of
data before running out of SDRAM.  That’s plenty for any need we might have.
Not only that, since the
<a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">Nexys Video board</a>
has a <a href="https://en.wikipedia.org/wiki/SD_card">micro-SD-Card</a> slot on it, there
should be more than enough room on
any modern
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
to hold any capture I might create.</p>

<p>Ahh, the best laid plans of mice and men.</p>

<p>This was where things started to go wrong.</p>

<p>Sure, I had everything I needed to make this work early on, starting with my own
<a href="https://github.com/ZipCPU/videozip">Nexys Video</a> design.  This should be
easy to modify for a commercial purpose.  Indeed, it had already been modified
to set up the transmitter.</p>

<p>As built, the design already consisted of several “working” components.</p>

<ul>
  <li>It had a <a href="/about/zipcpu.html">ZipCPU</a></li>
  <li><a href="/blog/2019/03/27/qflexpress.html">Flash Controller</a>.</li>
  <li><a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">Wishbone to AXI
 bridge</a>,
to control a MIG based DDR3 SDRAM controller</li>
  <li>A <a href="https://github.com/ZipCPU/wbuart32">serial port</a> based console, with a
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus</a>
running over the non-printable character set</li>
  <li>I also had a <a href="https://github.com/ZipCPU/sdspi">SPI-based SD Card controller</a>
to use</li>
  <li>And, of course, the SONAR transmit controller we had used earlier in the
project.</li>
</ul>

<p>This, however, left me missing a couple of key components.</p>

<ol>
  <li>
    <p>I needed a stream to WB recorder.  This was an easy build, and took me
a quiet and pleasant vacation morning to put together.  (Yes, I do enjoy
doing this kind of work on my vacations.)</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> didn’t (yet) handle building
projects with multiple masters very well.  However, this design required
the ability to add more than one bus master (the
<a href="/about/zipcpu.html">ZipCPU</a>
and the data recorder) to the design.  In the end, I chose to upgrade
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
rather than to manually add another bus arbiter to the design.</p>

    <p>The new AutoFPGA upgrade offers the capability to add support for multiple
different bus protocols, and multiple bus masters.</p>

    <p>This would be the first project to use the updated AutoFPGA support, so there
was a bit of risk involved to the project by doing this.</p>
  </li>
  <li>
    <p>I also needed a way to decode the <a href="https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system">FAT
filesystem</a>,
and to be able to write a file to the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a> using it.  After a bit of
googling, I found the
<a href="http://elm-chan.org/fsw/ff/00index_e.html">FATFS project</a> which promised
to be able to handle any <a href="https://en.wikipedia.org/wiki/File_system">file system</a> issues for me.</p>
  </li>
</ol>

<p>Looking over all of this, most of the work had already been done.  I was just
adding a couple minor components to the design.  What could go wrong?</p>

<h2 id="everything-fails-in-integration">Everything Fails in Integration</h2>

<p>What could go wrong?  Everything.</p>

<p>The first problem was that I wanted C-library support to get <code class="highlighter-rouge">malloc()</code>,
<code class="highlighter-rouge">free()</code>, as well as <code class="highlighter-rouge">printf()</code> and its friends.  However, the
<a href="https://sourceware.org/newlib/">newlib C-library</a> that I’ve been using
didn’t fit in the 64-kB block RAM image I had allocated for myself in ROM.
Normally this wouldn’t be an issue, as I would’ve just stored any
<a href="/about/zipcpu.html">ZipCPU</a>
software on <a href="/blog/2019/03/27/qflexpress.html">flash</a>
and then loaded the software from
<a href="/blog/2019/03/27/qflexpress.html">flash</a>
to SDRAM early on.  There was certainly plenty of room on the on-board
<a href="/blog/2019/03/27/qflexpress.html">flash</a>
chip for any software I might create, so this isn’t (normally) a problem.</p>

<table align="center" style="float: left"><caption>Fig 7. Copying Software from an SD-Card</caption><tr><td><img src="/img/sdspi/sw-bootload.svg" alt="" width="480" /></td></tr></table>

<p>My customer, however, didn’t have my <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging
tools</a>, nor did he want
that kind of access.  This left me with no means of getting any software onto
the flash memory within his board.  (We’re not co-located.)  I chose instead
to load an SDRAM image from a file on an
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>,
as shown in Fig. 7 on the left, and then to boot the
<a href="/about/zipcpu.html">ZipCPU</a> from that
image.  This gave me as much code room as I wanted, but required using a
special program to load the file into SDRAM–a program that would need to
be built into the design itself in a special “Boot ROM” device.</p>

<p>Once this program loaded the
<a href="/about/zipcpu.html">ZipCPU</a>’s
software into SDRAM, the main program would begin–allowing the user to control
waveform types, parameters, and the ability to save files to an
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>.</p>

<h2 id="step-one-gathering-files">Step One: Gathering Files</h2>

<p>The problem with “working designs” is that they change over time.  Worse, it
had been a long time since I had worked with <a href="https://github.com/ZipCPU/videozip">my “working” Nexys Video
design</a>.  So, to start this project, I
copied all of the files from <a href="https://github.com/ZipCPU/videozip">my “working” Nexys Video
design</a>,
and then updated them with any changes that had been made since that design.</p>

<ul>
  <li>The <a href="/about/zipcpu.html">ZipCPU</a> had significantly changed
and gotten better.  Among other things, it now had a <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data
cache</a> available to
me.  Even better, since this FPGA had so much logic, there was plenty of room
for it as well.</li>
  <li>The <a href="/blog/2019/03/27/qflexpress.html">flash driver had completely been rewritten</a>.</li>
  <li>The <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">Wishbone to AXI
bridge</a> had been
completely rewritten, and now enjoyed full formal verification
support–something the original driver had never had</li>
  <li>The <a href="https://github.com/ZipCPU/sdspi">SDSPI controller</a>, the one that will
control an <a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>.
using a SPI based protocol, had been modified to add
75-clocks to it to allow any logic within the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a> to start up</li>
  <li>I only really needed to remove the HDMI support that — had never yet
worked anyway.</li>
  <li>Also, on <a href="https://github.com/ZipCPU/zipversa">my last project</a>, I had updated
my favorite debugging bus implementation, fixing some <a href="/formal/2019/10/05/formal-enough.html">significant bugs in
the compression
algorithm</a>.</li>
</ul>

<p>All of this code was easily copied into the new design.  It gave me a lot to
start from.  Even better, all of this code had worked in FPGAs before, so I had
a strong confidence that it would work again.  Sadly, not all of it had been
formally verified.  As a result, there were land mines within this design that
I was just completely unaware of.</p>

<h2 id="step-one-simulation">Step One: Simulation</h2>

<p>The first step to building something like this was to run the design in
simulation and so to demonstrate that it works in simulation alone.  To make
this happen, I set up two basic simulation setups.  The first simulation would
run a given program–such as my data collector, and the second simulation
would run the boot loader.  Selecting between them was as easy as adding a
<a href="/about/zipcpu.html">ZipCPU</a>
program name to the command line.</p>

<p>From these two, my goal was to demonstrate the ability to boot the
<a href="/about/zipcpu.html">ZipCPU</a> from the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>,
and then to collect and write/store data to the <a href="https://en.wikipedia.org/wiki/File_system">file system</a>.  I would do this
first in simulation, then on the actual board.</p>

<h3 id="connectivity-tests">Connectivity Tests</h3>

<p>Normally, I use a <a href="/zipcpu/2018/02/12/zbasic-intro.html">small CPU testing
program</a> as my way of
shaking out a new design.  However, as I got to thinking about this, <a href="https://github.com/ZipCPU/videozip/blob/master/sw/board/cputest.c">my CPU
testing program</a>
does nothing to test the rest of the design.  Therefore, I chose to create
an additional connectivity checking program–one that would attempt to interact
with every peripheral within the design and verify that all of the peripherals
could be interacted with.</p>

<p>For the most part, this piece of the software worked by 1) reading from some
piece of memory, 2) writing a new value to it, 3) verifying that the value
was expected, and then 3) returning the value written to its original form.
Values chosen included all ones, all zeros, and a variety of patterns in
between to make certain all bits could be written and all bytes could be
written individually.</p>

<p>I did this because it just felt like “good practice”.  It also felt like a
complete waste of time, but for the sake of “good practice” I did it anyway.</p>

<p>In hind sight, I’m glad I chose this step.  Much to my surprise, there were
still bugs in the new AutoFPGA bus logic generation algorithms.  This
connectivity test helped flush out those bugs during simulation testing.  Later
on, once everything was passing properly, this connectivity checking program
became a confidence builder that my design still worked following any changes.</p>

<p>Indeed, I’m likely to make this kind of connectivity test a standard practice
with any new design I build.  Having one built now will make building the next
one easier.</p>

<h3 id="sd-card-controller">SD-Card Controller</h3>

<p>Now, after all that I’ve learned about digital design, I’m embarrassed to say
that my <a href="https://github.com/ZipCPU/sdspi/330888ad0474293f87773d6091f097cefa2c9430">SPI based SD-Card
controller</a> was woefully inadequate to the task.</p>

<table align="center" style="float: right"><caption>Fig 8. A XuLA2-LX25 Board from Xess</caption><tr><td><img src="/img/XuLA2.png" alt="" width="250" /></td></tr></table>

<p>Yes, it had been <a href="https://github.com/ZipCPU/xulalx25soc">tested in hardware</a>
before.  In hardware, I had demonstrated the ability to read a sector, to
write all ones or all zeros to the sector, and then to return it to its
original value.  Sadly, this test was far from automated.  As a result, if
I didn’t have that original
<a href="http://www.xess.com/shop/product/xula2-lx25">XuLA2-LX25</a> on my desk (it was
in a drawer), nor did I have ISE up and running to build my design, then I
couldn’t repeat the test and verify that any changes still worked.</p>

<p>Of course, since using the design in that initial project, the
<a href="https://github.com/ZipCPU/sdspi">SDSPI controller</a> needed to be modified.
Among other things, <a href="https://github.com/ZipCPU/sdspi/issues/1">someone was kind enough to point out to me that the 
SD-Card protocol requires 75 clocks be sent to the device before any attempt at
interacting with it</a>.  In it’s
<a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/sdspi.v">previous incarnation</a>,
the <a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
shared SPI pins with the flash chip or I might have noticed this
clocking need.  However, I dutifully made the change to be compliant with the
SD specification.</p>

<p>In the process, I realized that the SPI arbitration code really wasn’t all that
relevant anymore.  I couldn’t properly remove it, since I have at least <a href="https://github.com/ZipCPU/xulalx25soc">one
design that uses it</a>, but that didn’t
mean I couldn’t parameterize and thus remove the logic for those designs that
didn’t need it.  Just to make sure I did it right, I started adding formal
properties to the lower-level design component where I was making changes.</p>

<p>To make this controller work, I created a <a href="https://github.com/ZipCPU/sdspi/blob/eadca4b1a5034c7825cd4a6366b4da0e5ae369bc/sw/sdcard.c">low-level software driver</a> with
three basic functions: <code class="highlighter-rouge">sdcard_init()</code>, <code class="highlighter-rouge">sdcard_read(sector, buffer)</code>, and
<code class="highlighter-rouge">sdcard_write(sector, buffer)</code>.  I also created a <a href="https://github.com/ZipCPU/sdspi/blob/eadca4b1a5034c7825cd4a6366b4da0e5ae369bc/sw/diskio.c">DiskIO wrapper</a>
for the <a href="http://elm-chan.org/fsw/ff/00index_e.html">FATFS</a> library.  This then
provided a basic hardware abstraction layer to access the <code class="highlighter-rouge">sdcard_*</code> functions.</p>

<p>For simulation work, I had long ago built an <a href="https://github.com/ZipCPU/sdspi/blob/eadca4b1a5034c7825cd4a6366b4da0e5ae369bc/bench/cpp/sdspisim.cpp">SD-Card
emulator</a>.  To use the
<a href="https://github.com/ZipCPU/sdspi/blob/eadca4b1a5034c7825cd4a6366b4da0e5ae369bc/bench/cpp/sdspisim.cpp">emulator</a>, you’d need to create a file
on your system which would become the image of the entire
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>’s storage.
A <a href="https://en.wikipedia.org/wiki/File_system">file system</a> could then be placed onto this image.  This made adding
a <a href="https://en.wikipedia.org/wiki/File_system">file system</a> to my controller fairly easy to do.</p>

<p>Of course, I expected this to “just work”, right?  Since it was “working code”
from a prior project (ignore the modifications), it should “just work.”</p>

<p>I was caught by surprise several times during this simulation exercise, however,
when code that used to “just work” didn’t “just work” anymore.</p>

<p>First, the <a href="http://elm-chan.org/fsw/ff/00index_e.html">FATFS library</a> didn’t
recognize the <a href="https://en.wikipedia.org/wiki/File_system">file system</a> I had on my disk image.  I remember just sitting at
my desk, staring at this error, and not knowing where to start to deal
with it.  I tried Voodoo logic: changing what wasn’t broken in an effort to fix
what is.  It didn’t help.  (I appealed to Voodoo logic many more times as the
project went on.  While it made me feel like I was doing something productive,
it never really helped.)  Eventually, I instrumented the
<a href="http://elm-chan.org/fsw/ff/00index_e.html">FATFS library</a> through and through
only to discover when it read the first sector from the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>,
the controller duplicated the first word and never returned the last word.
Since the last word contained the magic number <code class="highlighter-rouge">16'h55aa</code>, and since
<a href="http://elm-chan.org/fsw/ff/00index_e.html">FATFS</a> never found it,
<a href="http://elm-chan.org/fsw/ff/00index_e.html">FATFS</a> couldn’t find my
<a href="https://en.wikipedia.org/wiki/File_system">file system</a>.</p>

<p>Of course, since this was in simulation, I was able to quickly chase this down
to the controller requiring two clocks to read a value from
it’s memory (i.e. the data read from the card), yet the Wishbone ACK was set
one clock (not two clocks) after the request.  I’d never encountered this bug
before, since I’d never read from the controller as fast as my DMA could–I had
done most of my testing via my <a href="/2017/06/05/wb-bridge-overview.html">slower Wishbone-over UART debugging
bus</a>
approach.  High speed production reads?  Never really tested.</p>

<p>Then, I was caught by surprise again when I discovered that my
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
<a href="https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdspisim.cpp">emulator</a>
had no write capability.  Sure, you could issue write commands successfully,
but the emulator never wrote them to the file backed image.</p>

<p>After these many changes, I really wanted to formally verify my
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
<a href="https://github.com/ZipCPU/sdspi/blob/e3d46ab24f79b62544fb11a49de77504bbdab83f/rtl/sdspi.v">controller</a>
Sadly, the logic was too complex.  I couldn’t get
<a href="/blog/2018/03/10/induction-exercise.html">induction</a> to pass.
Worse, since it since it had been so many years since I had written the design,
I struggled to get a grasp on what properties to add.</p>

<p>Nevertheless, I made the changes required and pushed forwards with using
this controller–since it had worked in hardware sometime before.</p>

<h3 id="the-zipcpu-and-the-zipsystem">The ZipCPU and the ZipSystem</h3>

<table align="center" style="float: left"><caption>Fig 9. The components of the ZipSystem CPU wrapper</caption><tr><td><img src="/img/zipsystem.svg" alt="" width="360" /></td></tr></table>

<p>The <a href="/zipcpu/2018/01/31/cpu-build.html">ZipSystem</a> is a name
I have for an <a href="https://github.com/ZipCPU/blob/master/rtl/zipsystem.html">external
wrapper</a> to the
<a href="/about/zipcpu.html">ZipCPU</a> that
contains a set of <a href="/zipcpu/2018/04/17/ziptimer.html">timers</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v">counters</a>,
and possibly even a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA
controller</a>.</p>

<p>Some time back, when doing my
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> work, I realized
that there was a <a href="/zipcpu/2019/03/28/return-decoding.html">better way to write return decoders that used less
logic</a>.  Since
that time,
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>’s logic generator has been
updated to take advantage of this new method.  Seeing that the
<a href="/zipcpu/2018/01/31/cpu-build.html">ZipSystem</a>
still used the old method of determining returns, I upgraded that too.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> also had a new
hold-in-reset counter.  Some FPGAs, notably the iCE40s, require some number
of clocks before the block RAMs can be used.  While not really needed for
this design, this was the last “working” version of the
<a href="/about/zipcpu.html">ZipCPU</a> so I copied it into this
project.  Surely such an extra “feature” wouldn’t hurt, right?</p>

<p>Finally, since I had last worked with my <a href="https://github.com/ZipCPU/videozip">VideoZip example
design</a>, I’d built
(and formally verified) a <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data
cache</a> for
<a href="/about/zipcpu.html">my CPU</a>.  Surely this was the time to use
it, since I had both a beefy FPGA and room to spare, right?</p>

<p>The first problem with these changes was they broke my ability to simulate a
specific software program design.  Instead, the simulation would always start
at the reset address–regardless of whether or not I told it to start elsewhere.</p>

<p>A quick look into the
<a href="/blog/2017/07/31/vcd.html">VCD file</a>
generated by the simulation revealed the problem was with the new
“hold-in-reset” capability.  My top-level simulation script requires the
ability to overwrite the CPUs first instruction address, in order to guarantee
the CPU starts at the right value–wherever it might be in memory, flash, or
SDRAM.  However, if the CPU remained in reset, then any time I’d overwrite the value it would get
overwritten again with the default reset address before the CPU started.</p>

<p>This was annoying, but certainly fixable.</p>

<h2 id="atoi11">atoi(“11”)</h2>

<p>One of the strangest bugs I came across along the way had to deal with
<code class="highlighter-rouge">atoi("11");</code> returning the wrong value.</p>

<p>This one really threw me for a loop.  I couldn’t figure out why the library
code would be broken.  I mean, <code class="highlighter-rouge">atoi("11")</code> should be pretty basic, right?</p>

<p>The good news with this bug is that the
<a href="https://sourceware.org/newlib/">newlib library</a> I use is fully open
source.  That meant that I could modify it if I wanted to.  So, I added some
<code class="highlighter-rouge">NOUT</code> and <code class="highlighter-rouge">NDUMP</code> instructions to announce to the console where it was in the
code, and what various values were along the way.  If you don’t <a href="/zipcpu/2018/01/01/zipcpu-isa.html">remember these
instructions</a>, <code class="highlighter-rouge">NOUT</code>
and it’s simulation only <code class="highlighter-rouge">SOUT</code> variant can be used to
print characters to the simulation console.  <code class="highlighter-rouge">NDUMP</code> and <code class="highlighter-rouge">SDUMP</code> are similar,
save that they print register values to the console.  <code class="highlighter-rouge">NSTR</code> is a similar
instruction used to print out strings.  For example, <code class="highlighter-rouge">NSTR "Hello, World\r\n"</code>
would cause the simulator to print “Hello, World” to the console.
This <code class="highlighter-rouge">NSTR</code> “instruction” is actually a pseudo instruction intercepted by the
assembler and then expanded into a sequence of <code class="highlighter-rouge">NOUT</code> instructions.
If done right, these instructions won’t modify register assignment at all.</p>

<p>Indeed, I found myself using these options so much I created macros to make
placing these instructions into a piece of code even easier:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define NSTR(A)         asm("NSTR \"" A "\\n\"")
#define NVAL(V)	\
	do {							\
		unsigned tmp = (unsigned)(V);			\
		asm volatile("NDUMP %0":"=r"(tmp):"0"(tmp));	\
	} while(0)</span></code></pre></figure>

<p>With these modifications, I was able to chase the problem down to two opcodes.</p>

<p>The first bug had to do with the <code class="highlighter-rouge">muldi3</code> GCC opcode.  As part of the backend
port, the <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/bd6c82b0e0eb88537f833146c79a4216f4858250/sw/gcc-zippatch.patch#L3809-#L3836">needed to implement a <code class="highlighter-rouge">muldi3</code> instruction</a>.
Such an instruction needed to take two ‘di’ (64-bit) values and multiply them
together.  Since the <a href="/about/zipcpu.html">ZipCPU</a> only
supports 32x32-&gt;64 bit multiplies, the 64x64 bit multiply needed to be converted
into component 32-bit parts, each multiplied separately, and then assembled
back into a 64-bit result.</p>

<table align="center" style="float: right"><caption>Fig 10. Splitting a 64-bit multiply into 32-bit multiplies</caption><tr><td><img src="/img/sdspi/muldi3.png" alt="" width="502" /></td></tr></table>

<p>Doing these component multiplies requires several registers.  First, it needs
two registers for each of the incoming operands.  Let’s call these <code class="highlighter-rouge">H1:L1</code>
and again <code class="highlighter-rouge">H2:L2</code>.  Further, the way I had written up the algorithm initially,
it also required to scratch registers, <code class="highlighter-rouge">S0</code> and <code class="highlighter-rouge">S1</code> that I could use however
I wanted to.  Much to my surprise, however, I found that GCC was only giving
me four registers: the two scratch registers were already <code class="highlighter-rouge">H2</code> and <code class="highlighter-rouge">L2</code>!
When I then used these scratch registers mid-algorithm I corrupted the
values I was multiplying.</p>

<p>I rewrote the algorithm here, and so you can see it summarized below.  Imagine
that H0 and L0 are replaced by one of the operands, and H1 and L1 are replaced
by the other.  The result is placed into H0:L0.</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	MOV	L1,L0
	MPY	L1,L0	;	L0 = L1^2
	MOV	H1,H0
	MPY	L1,H0	;	H0 = L1 * H1
	LSL	1,H0	;	H0 = (L1 * H1)*2
	MPYUHI	L1,L1
	ADD	L1,H0</code></pre></figure>

<p>(GCC actually requires a <code class="highlighter-rouge">%</code> before each of these place-holder register
names.)</p>

<p>Yes, I do put comments into my GCC generated assembly.  It really helps
debug the assembly later when you start trying to figure out what GCC was
doing.</p>

<p>The second bug was an unsigned <code class="highlighter-rouge">A &gt;= B</code> comparison.  Since the
<a href="/about/zipcpu.html">ZipCPU</a>
didn’t initially support unsigned <code class="highlighter-rouge">A &gt;= B</code> comparisons, the GCC backend needed
to <a href="https://github.com/ZipCPU/zipcpu/blob/bd6c82b0e0eb88537f833146c79a4216f4858250/sw/gcc-zippatch.patch#L13190-L13211">silently convert these into “equivalent” <code class="highlighter-rouge">A +1 &gt; B</code> comparisons</a> which the 
<a href="/about/zipcpu.html">ZipCPU</a> supported.  The problem, however,
is that if <code class="highlighter-rouge">A</code> is the maximum positive value, then
<code class="highlighter-rouge">(Maximum positive value) &gt;= B</code> doesn’t have the same meaning as <code class="highlighter-rouge">0 &gt; B</code>,
where <code class="highlighter-rouge">0</code> is the <code class="highlighter-rouge">(Maximum positive value)</code> plus one.</p>

<p>One of the failings of my current GCC backend is that I’m not using any of
GCC’s regression test suite.  This was originally due to the fact that the 
<a href="/about/zipcpu.html">ZipCPU</a> didn’t
have <a href="https://sourceware.org/newlib/">C-library</a>
support due to a lack of 8-bit byte support.  (The
<a href="/about/zipcpu.html">ZipCPU</a> originally supported only
32-bit bytes.) Now that the
<a href="/about/zipcpu.html">ZipCPU</a> supports the full C-library via
<a href="https://sourceware.org/newlib/">Newlib</a>, I really should go back and enable
the automated testing to find problems like this earlier.</p>

<p>One of the other “bugs” I finally dealt with in this design was a frustration
I’ve often had with the <code class="highlighter-rouge">SIM</code> instructions.  <code class="highlighter-rouge">SIM</code> instructions are what I refer
to the class of instructions just for the simulator, containing the <code class="highlighter-rouge">NOUT</code>
and <code class="highlighter-rouge">NDUMP</code> instructions I was using among other things.  Because of how they
were implemented, before any conditional checks, it was possible that a prior
branch instruction would execute and then the SIM instruction would execute
anyway.</p>

<p>For example, in the following code, <code class="highlighter-rouge">R1</code> should only be printed if the <code class="highlighter-rouge">Z</code>
(zero) condition code isn’t set.</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	BZ	_some_target
	NDUMP	R1</code></pre></figure>

<p>The problem was that these special <code class="highlighter-rouge">SIM</code> instructions were getting retired
prior to the last pipeline stage, and might possibly get eliminated by a
jump at the last stage.</p>

<p>This time, I finally got fed up with the bug enough to fix it.  (The fix
hasn’t been backported yet …)  I pushed the <code class="highlighter-rouge">SIM</code> instruction information
into the ALU pipeline stage, not just the read-operand stage, and so hopefully
I’ve fixed this for all time–or at least until I try running my next design.</p>

<h3 id="stream-recorder">Stream Recorder</h3>

<p>The stream recorder used by this project was a new core of mine.  It wasn’t all
that hard to create, and I managed to verify it and build it within about 6 hrs
of work or so.  In many ways, it’s very similar to my <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">AXI stream to memory
bridge</a>–although
that one took closer to 20hrs of work to build and verify.</p>

<p>Time is money, right?  See why I like
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>?  It’s so much
easier to work with.</p>

<table align="center" style="float: left"><caption>Fig 11. The high-bandwidth 128-bit bus</caption><tr><td><img src="/img/sdspi/membus.svg" alt="" width="480" /></td></tr></table>

<p>After building this stream processing core, I decided that I really wanted a
high speed access to my SDRAM device.  Therefore, I connected this to a
128-bit <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
bus that contained only the SDRAM memory slave as shown in Fig. 11 on the
left.  Normally, I just use 32-bit
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
buses for everything, but if I wanted to record
800Mbps of data–why not use the full memory data rate?</p>

<p>With the new AutoFPGA updates, AutoFPGA could now handle creating a special
128-bit bus with two masters on it–my normal 32-bit bus with a bus-expander
on it, and the stream recorder.</p>

<p>Of course, this meant that my memory emulator needed updates as well, since
most desktops can’t handle 128-bit words natively.</p>

<table align="center" style="float: right"><caption>Fig 12. Memory address misalignment</caption><tr><td><img src="/img/sdspi/malloc-chunk.svg" alt="" width="360" /></td></tr></table>

<p>My design then worked perfectly!  Perfectly, that is, until I tried to use the
recorder.  As it turns out, I had forgotten that the Stream to WB capability
required an <em>aligned</em> address, and connecting it to a 128-bit bus meant that
it now needed a 128-bit aligned address.  Malloc only generated a word-aligned
(i.e. 32-bit aligned) addresses for me.  If I then used the recorder with this
not-quite-aligned address, it would overwrite the malloc
data structure, as shown in Fig. 12, and then the
<a href="/about/zipcpu.html">CPU</a>
would crash when I tried to <code class="highlighter-rouge">free()</code> the memory later.</p>

<p>Ouch!</p>

<p>Again, think of where you’d look for this bug: In the new Stream2WB core?  Or
in the <code class="highlighter-rouge">free()</code> library call that failed with the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>?</p>

<p>It’s easy to write about these bugs today, long after they were found, but
finding where to look for them in the first place was a real
challenge–especially given that I was under a lot of schedule pressure.</p>

<p>In my case, that meant generating a
<a href="/blog/2017/07/31/vcd.html">VCD trace</a>
starting from CPU startup through stream to memory data write and the following
memory <code class="highlighter-rouge">free()</code> where the CPU would stop on a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
I could then read off the instruction pointer from the CPU
<a href="/blog/2017/07/31/vcd.html">trace</a>,
but it pointed to
<a href="https://sourceware.org/newlib/">newlib</a> library code that, when I stared at
the disassembly of, I wasn’t familiar with.  When I examined the
<a href="https://sourceware.org/newlib/">newlib</a> code responsible, I couldn’t
see any bugs–so what happened to this memory value?  When did it get changed?</p>

<p>To find this, I adjusted my test-bench wrapper to check that memory address
and report any changes to it.  I could then see the address given the “right”
value, and then get overwritten with the wrong value.  The time-stamp of this
change pointed me to time in the
<a href="/blog/2017/07/31/vcd.html">VCD trace</a>
when the recorder just started recording–and then I had one of those forehead
smacking moments, when I realized the core was doing just what I had designed
it to do but that since designing it to do that I had forgotten about the
reality that it didn’t support unaligned transfers.</p>

<h2 id="step-two-hardware">Step Two: Hardware</h2>

<p>That was a lot of bugs to find in “working” code!  I’m thankful that I was able
to find those in simulation.  I’m not sure how I would’ve found all of those
in actual hardware.  The result, however, was that the design now worked in
simulation, and so it was time to move to hardware.</p>

<p>I suppose I should’ve been excited at the prospect of moving to hardware.  I
wasn’t.  I’m often reluctant to leave simulation, simply because once the
design “works” in simulation it then “works”, right?  Only two things can
happen in hardware.  Either it continues to “just work” (not likely), or the
harder hardware debugging starts.</p>

<p>I had no choice, I was getting paid, so I bit the bullet and started my design
in hardware–but not after enjoying a quiet weekend, Friday night movie, etc.
I certainly needed a break to celebrate my “success” while it lasted.</p>

<p>When I then ran the design in hardware, it crashed so hard I thought the power
got pulled somehow.  My <a href="/blog/2017/06/17/why-network-debugging.html">serial port to TCP/IP
converter</a>
suddenly closed due to an underlying error, the telnet I was using for my
console port closed, and … what just happened?</p>

<p>Sigh.</p>

<p>Time to start debugging.</p>

<h3 id="fifo-bugs">FIFO bugs</h3>

<p>The only clue I had to what was going wrong was that there was a
“<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>”
in the
<a href="/blog/2017/06/05/wb-bridge-overview.html">debugging bus</a>.
Sadly, that doesn’t help me much.  My best guess was
that the FIFO I was using was somehow flawed.  Perhaps it was overflowing or
reading the wrong value?  So I tore it apart and added formal properties to it.
Sure enough, I found bugs within it.  Those were easy to clean up, though.
Verifying FIFOs is fairly basic–although <a href="/blog/2017/07/29/fifo.html">my most recent article on the
topic</a> is woefully out of
date–I’ve just learned so much since writing it.
(The <a href="/tutorla">tutorial</a> lesson is pretty good, though.)</p>

<p>I then ran the <a href="https://github.com/ZipCPU/videozip/blob/master/sw/board/cputest.c">CPU’s
self-test</a>,
and then my new connectivity test.  When the results didn’t look right, I
placed a <a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone
Scope</a>
onto the console port.  Sure enough, I wasn’t reading the right values from
the console.  That meant my <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v">UART
FIFO</a> was broken as
well.</p>

<p>Yes, this was frustrating to me.  I’d just found bugs in two FIFOs I’d had
and used in many different projects over the course of several years.  No,
neither of these cores had been formally verified.  No more, though.  Now they
were verified, the bugs were gone, I could <em>prove</em> that they were gone, and
I could now move on.</p>

<p>[Eric Brombaugh]’s response to my tweet about this really captured my own
thoughts:</p>

<table align="center" style="float: none"><caption></caption><tr><td><img src="/img/sdspi/brombaugh-how-long.png" alt="" width="589" /></td></tr></table>

<p>I’m truly hoping this happens soon.</p>

<p>Of course, even after fixing these two FIFOs I still knew that I had more
bugs in this design–I just didn’t know where.  For example, I still hadn’t
found that power supply issue I started out with.  Therefore, since
I knew I was going to need to do some serious work, I upped the speed of the
debugging bus back up from 9.6KBaud on up to 2MBaud again.</p>

<p>The next bug took place in software, so I then turned to my <a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone
Scope</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/5b0269905726eacd634c025af706cc3e4702ed66/rtl/core/zipcpu.v#L2700-L2765">attached to the ZipCPU</a>.
When the results didn’t make sense, I dug in further and discovered the CPU
was trying to execute the wrong instruction at one point.
Where was it getting the wrong instruction from?  I started attaching
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>s
further and further up stream towards the memory.</p>

<p>Sure enough, I saw the wrong instruction come back from my
<a href="https://github.com/ZipCPU/videozip/blob/7d57c21b88761dc355fc80067f665f8224da74a8/rtl/busexpander.v">bus expander</a>.</p>

<p>Let me back up to explain this one, though.  The
<a href="https://github.com/ZipCPU/videozip/blob/7d57c21b88761dc355fc80067f665f8224da74a8/rtl/busexpander.v">bus expander</a>
takes a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
request at one data width, and converts it to a request at another data width
that’s larger than the first.  In this case, it converts a 32-bit request to a
128-bit request, as shown in Fig. 11 above.  To make this work, the lower bits
of the address, the bits that aren’t needed on the 128-bit bus, are recorded
in a FIFO.  Then, when the 128-bit word is read, the 32-bit value of interest
is selected from that 128-bit value using those lower address bits.</p>

<p>Did you catch the word <em>FIFO</em> in that paragraph?</p>

<p>Sure enough, this <a href="https://github.com/ZipCPU/videozip/blob/7d57c21b88761dc355fc80067f665f8224da74a8/rtl/busexpander.v">“hardware-proven” bus expander</a>,
the one I’d used on my
<a href="https://github.com/ZipCPU/videozip">VideoZip project</a> years earlier,
<em>had no FIFO overflow checking!</em>  How on earth had it ever worked earlier?  I
must’ve never made more than 16 requests (the size of the FIFO), and so it
would’ve never overran before.  This time, however, I had the instruction
cache line size configured to 64-words.  Even at that, it almost
worked: the FIFO almost overflowed and then recovered since the data within it
was essentially a counter.  (The cache was reading words in order, after all.)
What kept it from working now was that my <a href="/blog/2019/07/17/crossbar.html">new crossbar
interconnect</a> required one
extra clock stall cycle to get through the arbiter.  This stall caused the
first value to stall and hence write the same bottom address bits to the
expander twice.</p>

<p>Ouch.  Burned again by “working in FPGA” qualified code, but not “formally
verified” code.  You’d think I’d learn by now, no?</p>

<p>Okay, well I’d now found a lot of bugs.  Surely the design would work by now,
right?</p>

<h3 id="xilinxs-mig-its-not-my-fault-when-it-was">Xilinx’s MIG: It’s not my fault! (when it was)</h3>

<p>It still didn’t work.</p>

<p>Again, I chased down the bugs I could as best I could.  As before, I’d find the
symptom of something that was broken, and then attach
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>s
further and further upstream until I found the cause.</p>

<p>Much to my surprise, I found an AXI error when working with Xilinx’s MIG
controller.</p>

<table align="center" style="float: none"><caption>Fig 13. MIG AXI Controller Memory Failure</caption><tr><td><img src="/img/sdspi/mig-annotated-3.png" alt="" width="524" /></td></tr></table>

<p>How on earth would a write request return an unrequested read response?  This made no sense.</p>

<p>So, I contacted Xilinx.  You can read <a href="https://forums.xilinx.com/t5/Memory-Interfaces-and-NoC/MIG-DDR3-SDRAM-controller-responding-without-request/td-p/1037460">my description of the bug
here</a>, although
Xilinx’s representative and I went back and forth over this several times
off-forum.</p>

<p>I was convinced the bug was in their code.  The <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">component of mine that
interacted with their
controller</a> had
been fully and formally verified.  Further, I counted requests internal to that
controller, and examining that request count I could see that this wasn’t a
response to any outstanding requests.</p>

<p>Xilinx’s tech support, however, was just as confused by the
<a href="/blog/2017/07/31/vcd.html">trace</a> as I was.  Perhaps there
was a read request from earlier that hadn’t been returned?  So … I
<a href="/blog/2017/07/31/vcd.html">traced</a>
<em>four seconds</em> of return, and <em>proved</em> that every prior read request had been
properly returned.  (At the time, I didn’t realize just how truly awesome the
<a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v">compressed version of the Wishbone scope</a> really was …)
Perhaps a request of mine broke protocol and crossed a
4kB boundary?  Couldn’t happen, I said, since none of my requests were ever
for more than a single beat.</p>

<p>When they pointed out to me that it was unlikely their code had such an
egregious bug in it after so many others had used it, I quietly had to agree.
Surely even I would’ve seen this bug before if it was in their basic AXI
handling?</p>

<p>Sadly, that also meant that I was really on my own to find the bug.  Well, that
and the fact that I was the only one with a design that had symptoms of being
“broken”.  (I didn’t want to give my design away by posting it on the forum …)</p>

<p>With a little bit of digging, I discovered how to open a design after Synthesis.
I learned how to use Xilinx’s Internal Logic Analyzer.  (Yes, this was my first
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>
time–I’ve only ever used my own <a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone
scope</a>
before.)  I then tore into the MIG controller looking for where this
extraneous return came from.</p>

<p>No, I never found any similar compression capability in the ILA.</p>

<table align="center" style="float: left"><caption>Fig 14. AXI_RVALID source came from a hardware block</caption><tr><td><img src="/img/sdspi/miginternal.svg" alt="" width="360" /></td></tr></table>

<p>The <code class="highlighter-rouge">AXI_RVALID</code> signal came from a hardware FIFO, leading to a design FIFO,
leading to the <code class="highlighter-rouge">AXI_RVALID</code> line shown in the trace above.  The only way this
hardware FIFO would return an invalid value would be if the memory returned a
read response–one that I hadn’t requested.</p>

<p>Hmm …</p>

<p>The other unusual thing about this bug was that there was always activity on
the “user interface” to the memory taking place at the same time.  It wasn’t
my activity.  I was using the AXI interface.  Internally, the MIG controller
turns the AXI interface into a “user interface” internally, then drives a
“native interface” from this “user interface”, and from that drives the
memory itself.  This extra activity on the “user interface” was in
addition to the activity my own code was causing.</p>

<p>At this point I remembered hearing, some time ago, that Xilinx’s MIG controller
needed to read from the memory periodically just to keep it’s PLL’s locked.
That made sense of the extra activity, but this activity should’ve never
produced a response.  Surely their MIG controller was designed to suppress
this return, so why would I see it?</p>

<p>I stared at this bug for a week.</p>

<p>That’s a week I didn’t have for this project.  The project was already due.
Indeed, it was past due.  I hadn’t scheduled this time.  I was only going to
be updating an already working “FPGA proven” design.  How could I be
struggling with a bug this fundamental?</p>

<p>I tried blaming others.  No one else was able to help without being able to
reproduce the bug, for which they’d need my design and my hardware.</p>

<p>I tried taking the dog for a walk, hoping something would come to me.</p>

<p>Nope, nothing.</p>

<p>I considered using the <a href="https://github.com/enjoy-digital/litedram">litedram
controller</a>, and then gave up when
I realized how much setup would be required.</p>

<p>Surely there was an easier way to fix this memory bug than learning how to
integrate with a new language, no?</p>

<p>Let me at least say this: When all else fails, prayer still works.</p>

<p>No, I don’t have control over God.  No, He’s not required to help me any time I
want.  That said, He enjoys helping me.</p>

<blockquote>
  <p>For the eyes of the LORD run to and fro throughout the whole earth, to shew
Himself strong in the behalf of them whose heart is perfect toward Him. … (2 Chron 16:9a)</p>
</blockquote>

<p>He also likes waiting for me to humbly come to Him, which tends not to happen
until after I’ve exhausted every option.  At that point, the point when there’s
no other option, and no where else help might come from, I turn to seriously
begging.</p>

<p>It’s quite humbling.</p>

<blockquote>
  <p>Humble yourselves in the sight of the Lord, and he shall lift you up.
(James 4:10)</p>
</blockquote>

<p>I certainly didn’t know where else to look, and the schedule stress wasn’t
helping.</p>

<p>Sometime after praying (more than once, I might add), I got the idea to check
the memory chip set up against the schematic.  Sure enough, <em>I had configured
the MIG for the wrong memory chip.</em></p>

<p>This also explains the bug.  The MIG controller was expecting a response from
the memory chip a certain number of clocks after its request, and due to the
misconfiguration it suppressed the response from the wrong clock window.</p>

<p>No, it wasn’t Xilinx’s fault.  In spite of all my rants and frustrations, it
was my own code at fault.  (I’m sorry, Xilinx employees, wherever and whoever
you are, for ever speaking poorly about your controller and swearing it didn’t
work.  It was my fault all the time.  This time …)</p>

<p>Time to take a break, and then try again.  Surely the design will now work,
right?  I mean, I started with a “working” design, many of the parts and pieces
had been either formally verified or FPGA proven before I started working with
them, what more could go wrong?</p>

<h3 id="data-cache-bugs">Data Cache Bugs</h3>

<p>There were still two problems with the 
<a href="/about/zipcpu.html">ZipCPU</a> that I didn’t catch until
moving to hardware.  Both of these were related to the 
<a href="/about/zipcpu.html">ZipCPU</a>’s bootloader.</p>

<p>The first problem was annoying, although I’d seen it before.</p>

<p>In my linker scripts, I define a set of values indicating which pieces of
ROM (flash, boot ROM), kernel RAM (block RAM only) or RAM (block RAM or SDRAM)
are on board.  These addresses are provided by
<a href="/zipcpu/2018/12/22/autofpga-ld.html">AutoFPGA</a> when the
design is put together, and may change as components are added or removed
from the design.</p>

<p>To capture these values into my program, I use statements such as,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">extern</span> 	<span class="kt">unsigned</span>	<span class="n">_rom</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span></code></pre></figure>

<p>References to <code class="highlighter-rouge">_rom</code> now become pointer references, filled in by the
linker–just what I want.  Other approaches, such as declaring an external
unsigned pointer <code class="highlighter-rouge">_rom</code>, tended to create memory allocations for the pointer.
This method of declaration simply evaluates to the right answer when
I want it.</p>

<p>The problem comes about when my boot loader software checks to see if
there’s a ROM image to copy from.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">bootloader</span><span class="p">(...)</span> <span class="p">{</span>
	<span class="c1">// ...
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">_rom</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// We need to copy the ROM image to RAM
</span>	<span class="p">}</span>
	<span class="c1">//
</span>	<span class="c1">// Other code
</span><span class="p">}</span></code></pre></figure>

<p>The problem with this code is that the GCC compiler “knows” that <code class="highlighter-rouge">_rom</code> isn’t
a NULL pointer, it’s a pointer to a properly allocated memory array.  (When it
might actually be a NULL pointer …)  As a result, this check gets dropped from
the code.</p>

<p>So, I replaced the check with something that looked like,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define	NOTNULL	(4 != (unsigned)&amp;A[1])</span></code></pre></figure>

<p>and then later,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="k">if</span> <span class="p">(</span><span class="n">NOTNULL</span><span class="p">(</span><span class="n">_rom</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// ...
</span>	<span class="p">}</span></code></pre></figure>

<p>While I’m sure there’s a better way, this worked and by now I was both behind
and frustrated.</p>

<p>The next bug I should’ve anticipated as well.  I was copying from the ROM
memory image of my code into RAM (i.e. setting global values), yet also using
that same RAM for some debugging statements.</p>

<p>I know, I shouldn’t do that.  But the problem wasn’t severe–I just wanted to
print out certain values, and <a href="https://github.com/ZipCPU/videozip/blob/6e4215b3b6ea96595a4083603636a88a5599604d/sw/board/txfns.c#L60">my print routine wanted to use a global to know
if the last character printed was a carriage return or
not</a>.
If it was a carriage return, it would send a new-line and suppress the next
newline.  This effectively turned a “\r\n” sequence into a “\n” sequence.</p>

<p>If the “last-character-was-a-newline” value was wrong, the result wouldn’t look
pretty but it would still work.</p>

<p>In this case, the bug I was getting was worse.  There was another global value
that wasn’t getting set properly.</p>

<p>As with the other hardware bugs, I attached a <a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone
Scope</a>
and started digging.  I should mention, this type of digging is a slow process.
It took Vivado about 15 minutes to create a bit file following any changes.
I’d then run the design, examine the trace, adjust things and try again.
This kind of debugging loop is quite slow.  Eventually, though, I tend to try
running the simulator to see if the same bug pops up since chasing a bug
through a simulation trace is a whole lot easier than moving a <a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone
Scope</a>
around and rebuilding again.</p>

<table align="center" style="float: right"><caption>Fig 15. Data Cache</caption><tr><td><img src="/img/sdspi/dcache.svg" alt="" width="360" /></td></tr></table>

<p>When I finally got to the root of the issue, I could’ve kicked myself.  Using
the value from the RAM that hadn’t yet been initialized caused that
uninitialized cache line (not just the one uninitialized value) to get loaded
into the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data cache</a>.
The bootloader would then copy data from the ROM image to the RAM area where
the globals would be stored using the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA</a>.
The <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data
cache</a>,
however, was unaware of the DMA’s accesses, and so
the cache is now out of sync with memory–as shown in Fig. 15 on the right.</p>

<p>Once I realized what was causing the bug, fixing it was easy: I expanded my
“clear cache” instruction to work on the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data
cache</a>,
as well as the more established <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">instruction
cache</a>.</p>

<h3 id="sdspi-the-io-drivers">SDSPI: The I/O Drivers</h3>

<p>The big risk in this project, of course, was using the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>.</p>

<p>I knew it was a risk because I had never used the
<a href="http://elm-chan.org/fsw/ff/00index_e.html">FATFS</a> library before.</p>

<p>Note that I didn’t consider the fact that I’d never used the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
on this hardware before a risk, nor did I consider using my <a href="https://github.com/ZipCPU/sdspi">SD Card
controller</a>
a risk since it had “worked” when it was last used.</p>

<p>I tried the design first without an
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
in place.</p>

<p>I quickly realized that I needed to <a href="https://github.com/ZipCPU/blob/master/rtl/sdspiv">adjust my
controller</a> to detect
whether or not the card was present.  <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">Digilent’s Nexys Video
board</a>
also includes an
electronic reset to the card that pulls power from it.  I adjusted my
controller again, so that this reset signal would release the controller
from whatever action it was in the middle of if the reset signal were present.</p>

<p>To understand what happened next, you need to understand the first step in any
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
interaction over SPI.  The software driver needs to send the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
a reset command, commonly called a “SEND_GO_IDLE” or <code class="highlighter-rouge">CMD0</code> command.  The
card then responds with an <code class="highlighter-rouge">R1</code> response as it’s called–basically an 8-bit
value equal to <code class="highlighter-rouge">8'h01</code>.</p>

<p>My controller sent this <code class="highlighter-rouge">CMD0</code> and got no response.</p>

<p>Now what?</p>

<p>It had been years since I’d worked with <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdspi.v">this
controller</a>.  Sadly,
I didn’t remember much of how it worked.  I wasn’t certain where to start
debugging.  Still, it had a debugging output which I could place into a
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>
again.</p>

<p>I saw 7 good clock pulses per byte, and one strangely short one.</p>

<table align="center" style="float: none"><caption>Fig 16. An unusually short clock pulse</caption><tr><td><img src="/img/sdspi/short-sclk.svg" alt="" width="560" /></td></tr></table>

<p>I quickly modified the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/llsdspi.v">lower-level
driver</a> to fix it.</p>

<p>I then saw the outgoing MOSI line change while SCK was high.</p>

<table align="center" style="float: none"><caption>Fig 17. MOSI was now no longer aligned with the negative edge of SCK</caption><tr><td><img src="/img/sdspi/offset-mosi.svg" alt="" width="560" /></td></tr></table>

<p>No, this isn’t allowed–not on one of my cores.  I wanted the MOSI line to
only change when SCK fell–never otherwise.  So I tore the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/llsdspi.v">lower level
driver</a> apart.
This time I rewrote it.  I added formal properties to it.  I verified the
interface against something similar to an AXI stream protocol.  (I used
STB and IDLE instead of VALID and READY …)  I ran <code class="highlighter-rouge">cover()</code> checks.
It now worked exactly as desired and designed, so I tried again.</p>

<p>Still no response from the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>.</p>

<p>Not again.</p>

<p>I reread the SD specification I had.  I double checked the power up sequencing.
No, this was right.  Just for good measure, I stuffed a 1ms power-up delay
into the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/llsdspi.v">lower level
controller</a>
and tried again.  Still nothing.</p>

<p>This time I turned to Google.  I started getting worried that my off-the-shelf
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>s
didn’t support SPI.  I was using both SanDisk and Lexar cards, and with a bit
of Googling I found the specification sheet for another similar SanDisk card.
While it wasn’t quite the specification for my card, it did verify that
SanDisk supported SPI mode on at least one
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>.
It also verified how the timing was supposed to work.</p>

<p>No, this should work.</p>

<p>So, for the first time, I went and checked Vivado’s warnings.  Sure enough,
I had warnings for the following four lines:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">io_sd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_sd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="mb">1'bz</span> <span class="o">:</span> <span class="mi">0</span>
	<span class="k">assign</span>	<span class="n">io_sd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_sd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="mb">1'bz</span> <span class="o">:</span> <span class="mi">0</span>
	<span class="k">assign</span>	<span class="n">io_sd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_sd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">?</span> <span class="mb">1'bz</span> <span class="o">:</span> <span class="mi">0</span>
	<span class="k">assign</span>	<span class="n">io_sd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_sd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">?</span> <span class="mb">1'bz</span> <span class="o">:</span> <span class="mi">0</span></code></pre></figure>

<p>These four lines are used to set the I/O lines to 1’b1 (via an external pullup)
or 1’b0 if the I/O is active.  They are really only important when implementing
the full SDIO interface, but that’s what
<a href="https://store.digilentinc.com">Digilent</a> had wired and so it was what
I was using here.</p>

<p>Since Vivado had a problem with these lines, I replaced them with <code class="highlighter-rouge">IOBUF</code>
instantiations that should’ve done the same thing.  I then convinced myself
of a bug in these instantiations, changed them, and changed them again, until
I finally had no confidence at all in my <code class="highlighter-rouge">IOBUF</code> instantiations.</p>

<p>With no other way to debug these, I stuffed the return values of the <code class="highlighter-rouge">IOBUF</code>s
into a
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>.
Much to my surprise, even though the outgoing data wires
were toggling appropriately, the <code class="highlighter-rouge">IOBUF</code> return values didn’t reflect that at
all.</p>

<p>So I got rid of the <code class="highlighter-rouge">1'bz</code> values entirely.  I suppose it’s not really a big
deal.  While the SDIO protocol uses them the SPI protocol doesn’t, so I
figured I should still be good.</p>

<p>Suddenly, and much to my delight, the card I was working with responded!</p>

<table align="center" style="float: none"><caption>Fig 18. The SD-Card responds to a reset command, CMD0</caption><tr><td><a href="/img/sdspi/sdspi-cmd0.png"><img src="/img/sdspi/sdspi-cmd0.png" alt="" width="648" /></a></td></tr></table>

<p>Surly my adventure was coming to an end, right?</p>

<h3 id="sdspi-the-jenga-design">SDSPI: The Jenga Design</h3>

<p>Sadly, no.  This “adventure” was far from complete.  Worse, I was now nearly
two weeks later than I wanted to be in my project schedule.  At least I had the
SDSPI controller fully connected to the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>
so I could see what was going on.</p>

<p>Before going further, let me share some more about this design.  I wrote this
design as one of my earlier digital design projects–back when I was still
“<a href="/blog/2017/09/18/clocks-for-sw-engineers.html">thinking like a
programmer</a>” if
you will.  As a result the <a href="https://github.com/ZipCPU/sdspi/blob/e3d46ab24f79b62544fb11a49de77504bbdab83f/rtl/sdspi.v#L280-L558">state machine within it was incredibly complex–too
complex even</a>.
Indeed, it was so complex that ISE wouldn’t even place a design with this
controller in it without failing timing.</p>

<p>Timing shouldn’t be a problem for a SPI transaction, right?</p>

<p>I had eventually “fixed” the problem years ago by (slightly) breaking up the
giant always block so that smaller blocks would pre-calculate values.  I also
removed any extraneous logic.</p>

<table align="center" style="float: left"><caption>Fig 19. Jenga, a fun game from Hasboro</caption><tr><td><img src="/img/sdspi/jenga.jpeg" alt="" width="96" /></td></tr></table>

<p>The result was what I’m going to call a “Jenga” design, after the classic game
from Hasbro.  That game starts with a wooden tower, from which players one by
one remove support elements and place them on top.  When the tower finally
falls (which it will do), the last person to remove a support loses.</p>

<p>Why was this a “Jenga” design?  Well, obviously, because it appeared to be
designed to fail.  (Yes, this was one of my own designs …)  First, it was so
badly written I couldn’t tell from reading my own code how it was supposed to
work.  That meant that, second, I couldn’t track the dependencies through the
design–what signals were dependent upon which others?  Worse, when I just
slightly modified the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/llsdspi.v">lower-level I/O
controller</a>,
the data out valid line was delayed by one clock from the data in valid line
and … this was causing my whole design to fail.  The Jenga design had been
changed just one too many times.</p>

<p>I tried patching it.  The patch fixed one problem, but generated another.</p>

<p>No matter how I looked at it, there was just no easy way to fix it–especially
without a good understanding of how it was supposed to work originally.</p>

<p>The project was already late, now what?</p>

<p>Seeing no other way forward,
I tore the entire design apart and rebuilt it using <a href="/formal/2018/07/14/dev-cycle.html">formal verification
properties</a> from the
ground up.  In about a day I had a newer design with much simpler state
machines.  Even better, the newer design was separated into three new but
separate modules: <a href="https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/spicmd.v">sending a command</a>, <a href="https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/spirxdata.v">receiving a buffer of
data</a>, and <a href="https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/spitxdata.v">sending a buffer of data to the
SD-Card</a>.  The
[lower level controller](SD-Card](https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/llsdspi.v)
remained the same, but I could now gut most of the Jenga design
and in particular I was able to remove the
<a href="https://github.com/ZipCPU/sdspi/blob/e3d46ab24f79b62544fb11a49de77504bbdab83f/rtl/sdspi.v#L280-L558">unmaintainable state machine</a> and
replace it with <a href="https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/sdspi.v#L393-L468">something much simpler</a>.</p>

<p>Not only that, but I could use the formal tools to generate waveforms
illustrating how each component was supposed to work.  Not only that, I could
formally verify the whole using <a href="/blog/2018/03/10/induction-exercise.html">induction</a>–something
I could never do with the previous Jenga design.</p>

<p>Now, finally, perhaps the design would work?</p>

<p>Not quite.  The first step as always was simulation.</p>

<p>In simulation, I discovered that the CRC generation and checking code for the
data blocks wasn’t working.  (The one part I didn’t formally verify in my haste
…)</p>

<p>Still, I was in a hurry.  After some quick changes, my design worked in
simulation, I moved to hardware.</p>

<h3 id="sd-cards-and-an-undocumented-feature">SD-Cards, and an Undocumented Feature</h3>

<p>I’m now just over two weeks late.  Does this design work now?</p>

<p>Sadly, no.</p>

<p>After running my design, something went wrong.  Badly wrong.  I started
getting
<a href="https://en.wikipedia.org/wiki/File_system">file system</a>.
not found errors.  Resetting the card and reading the
(hopefully constant) CSD register returned values completely unexpected.</p>

<p>Ouch.</p>

<p>I reformatted the card, placed my software image on it and tried again.</p>

<p>Again, something, somehow, somewhere again went badly wrong.</p>

<p>I adjusted the software so that any block read or write would dump to the
screen.  I captured the screen using
<a href="https://www.geeksforgeeks.org/script-command-in-linux-with-examples/">script</a>.
I scrolled back and examined what was going on.</p>

<table align="center" style="float: right"><caption>Fig 20. Read data.  Imagine the boxes filled with hexadecimal data</caption><tr><td><img src="/img/sdspi/sdread-good.svg" alt="" width="360" /></td></tr></table>

<p>Needless to say, I started staring at pages and pages of tables looking sort
of like Fig. 20 on the right.</p>

<p>Out of luck, I happened to notice a dumped data block showing a write to the
<a href="https://en.wikipedia.org/wiki/File_system">file system</a> that looked more
like Fig. 21 below than the prior read that had looked like Fig. 20 above.<br />
(Colors added for effect, since no one reading will want to stare at hex
values.)  I started to look deeper.  Sure enough, it lead to finding a bug
in the new (hastily-verified) controller.</p>

<table align="center" style="float: right"><caption>Fig 21. Write data, offset by one word from the read data</caption><tr><td><img src="/img/sdspi/sdwrite-bad.svg" alt="" width="360" /></td></tr></table>

<p>This bug was easy to chase down.  My <a href="https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/rtl/spitxdata.v">new data-write
module</a>
needed to read from
a (block RAM) memory external to it, and grabbed the value one clock too
late–after the new address changed the value.  Getting this timing right was
one of those things I hadn’t checked in my haste.</p>

<p>I adjusted the timing and tried again.</p>

<p>Nope, still not working.  In particular, the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
was returning error responses.  Perhaps I could chase those down?</p>

<p>So I turned to the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>
again to see what was going on.  This time, I triggered the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
off of the first operation that received a failing return
from the card and … saw something I wasn’t expecting at all.</p>

<p>The card was returning multiple acknowledgements even while a block was being
written.</p>

<p>This was … unexpected.  It was as though the card were responding to the
data I was transmitting as though they were commands and not data.</p>

<p>I adjusted the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>’s
trigger and tried again, hoping to get a better look.</p>

<p>At one point, I increased the memory in the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
and even adjusted its trigger in logic.
I reformatted my (now long-since broken)
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>,
put my application’s image on it again and loaded my design (again).</p>

<p>Much to my surprise, I watched the boot loader properly set up the card, read
my design into SDRAM, and then start and run the design.</p>

<p>This shocked me.  I thought I was suffering from bugs still.  How did this
much logic manage to work without error?  Indeed, everything worked well
until the design then tried to write to the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>.</p>

<p>Somewhere around this time, things started to add up.</p>

<p><a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>s
have some work to do following a write.  If you send the card enough
writes, back to back, you need to expect that the card will ask you to slow
down.  Forget the data rates quoted on the manufacturers sites.  Cards are
slower than that, they just transfer at that rate.</p>

<p>So I checked the SD Spec again.</p>

<p>Sure enough, there was a means of signaling that the card isn’t ready–by
holding D0 low following a command in SDIO mode.  Nothing was said about this,
however, in SPI mode.</p>

<p>Perhaps this was an oversight?</p>

<p>So I went back to my new SDSPI controller and adjusted the write-data command
so that it would wait until the card was idle (i.e. MISO returned an <code class="highlighter-rouge">8'hff</code>
instead of an <code class="highlighter-rouge">8'h00</code>).</p>

<p>Finally, after all this work, the design works from bring up through a data
record and write to the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>.</p>

<p>Whew!</p>

<h3 id="the-power-failure">The “Power” Failure</h3>

<p>What about that initial bug?  You know, the one that looked like a power
failure?</p>

<p>At this point, I was declaring success yet I had never seen that power bug
since I first started working in actual hardware.  Indeed, I’d almost
forgotten about it.</p>

<p>Still, I was running my serial port at 2MBaud–a rate that wouldn’t work when
I delivered this code.  So I switched back to 9.6KBaud to meet my customer’s
requirement.</p>

<p>Just to run a final test, I ran my design at 9.6kBaud.  This time, however,
when I tried to load it into memory the loader shut down and the <a href="/blog/2017/06/17/why-network-debugging.html">UART to TCP/IP
bridge</a>
suddenly quit again as well.</p>

<p>This looked like that ugly “power” problem rearing it’s head again.</p>

<p>Sigh.  Just when I thought things were working.</p>

<p>This time, however, I knew things were working before changing serial port
speed.  Could it be something speed related?</p>

<p>Sure enough, after describing the problem to my family, I remembered a timer
within the debugging bus I’d built.  Specifically, there’s a <a href="https://github.com/ZipCPU/videozip/blob/0daadd8a0d80ad228296a3f00ae511e072845ca1/rtl/wbubus.v#L120-L135">watchdog
timer</a> within it.  The purpose of the timer is
to keep the Wishbone bus from ever locking up.  The timer starts when the
bus is activated, and clears when either the bus becomes idle or a new request
is accepted.  This timer is set to count a rough 500M clocks.  If the bus isn’t
released in 500M clocks, the
<a href="/blog/2017/06/05/wb-bridge-overview.html">debugging bus</a>
will return <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.</p>

<p>To understand more of what’s going on, know that <a href="/blog/2017/06/05/wb-bridge-overview.html">this version of the debugging
bus</a>
takes at least 6-bytes to transmit a 32-bit word.  At 100MHz and 9600Baud,
one baud clock will require about 10.5k clocks.  Ten baud clocks constitute
one character, and six characters are needed for a total of about 625,000
clocks.  Further, in order to support <a href="https://github.com/ZipCPU/videozip/blob/0daadd8a0d80ad228296a3f00ae511e072845ca1/rtl/wbqspiflash.v">my original flash
driver</a>,
the <a href="/blog/2017/06/05/wb-bridge-overview.html">debugging bus</a>
doesn’t release the <code class="highlighter-rouge">CYC</code> line following any write until the whole
pattern is written.  Hence the first write goes through fine, and the bus is
held for the second write.  It then takes 625k clocks to get the second piece
of data, during which time the watchdog times out and the debugging bus
returns a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.</p>

<p>That <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> then gets returned to the 
<a href="/about/zipcpu.html">ZipCPU</a> loader.  This is turned into an
C++ exception within the loader.  When the loader then receives this exception,
it suddenly exits complaining about a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.  Worse, since it exits mid
TCP/IP connection, the TCP/IP connection is suddenly reset which then creates
an error in the TCP/IP bridge–leaving me believing a “power failure” had taken
place that caused me to lose my connection to the FTDI chip.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Wait, what just happened?</p>

<p>What happened was that I didn’t allocate enough time to get a “working”,
“FPGA proven” design to work.</p>

<p>What happened was that I lost more than two weeks of schedule on an already
late project.</p>

<p>Did formal verification help?  Most certainly!  Notice that every one of the
FIFOs within my design that wasn’t formally verified had bugs in it.  Notice
also how I was able to <a href="https://github.com/ZipCPU/sdspi/blob/c74be4fdb9bbe8852c173cf325c2a51ff0b33f11/">build a brand new SDSPI
controller</a>,
using formal tools, in just over a day.  Notice also how it was possible to
quickly adjust that controller to meet the “undocumented feature” in the
<a href="https://en.wikipedia.org/wiki/SD_card">SD-Card</a>
protocol.</p>

<p>That said, I wouldn’t have been able to do any of this without my
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>.
I can also finally describe how it’s different from Xilinx’s Internal Logic
Analyzer.</p>

<p>First, I give Xilinx full marks for their ability to integrate their
Internal Logic Analyzer into their Vivado design flow.  Using Vivado, I found it
possible to trace lines within code that I didn’t feel like I could change.
After selecting the lines I was interested in, there was little more required
to set it up.  Again, full marks for simplicity in set up.</p>

<p>That said, the 
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>
has some capabilities that I didn’t find with Xilinx’s ILA.  The first major
difference is that I have a <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscopc.v">compressed version of the Wishbone
scope</a>.  The
compression itself is really quite simple–it’s just a basic run-length encoder.
Still, that simple compression was enough to examine every transaction from
startup to some time between 4-13 seconds later.  The second major difference
is that the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBScope</a>
can be either 1) externally triggered, triggered from an internal hardware
event, or even 2) triggered internally from software.  Given that software
changes took a rough 30s to modify, triggering from software was <em>much</em> faster
than rebuilding the design to look for a new trigger.  It also allowed me to
trigger off of some rather strange trigger conditions.</p>

<p>Finally, I am also very thankful that, when the chips were down, God answered
my prayers.</p>

<p>Thank you, Lord.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Ask, and it shall be given you; seek, and ye shall find; knock, and it shall be opened unto you (Matt 7:7)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
