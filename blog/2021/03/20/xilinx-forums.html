<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Common AXI Themes on Xilinx's Forum</title>
  <meta name="description" content="Xilinx has committed their infrastructure to AXI.  Zynq’s are built around AXI3,while most of the Vivado generated infrastructure within their FPGAenvironmen...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2021/03/20/xilinx-forums.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Common AXI Themes on Xilinx's Forum</h1>
    <p class="post-meta"><time datetime="2021-03-20T00:00:00-04:00" itemprop="datePublished">Mar 20, 2021</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Xilinx has committed their infrastructure to AXI.  Zynq’s are built around AXI3,
while most of the Vivado generated infrastructure within their FPGA
environment is now AXI4.  As we’ve examined on this forum, their training
materials will lead you to either a <a href="/formal/2018/12/28/axilite.html">broken demonstration
AXI-lite slave design</a>,
or a <a href="/formal/2019/05/13/axifull.html">broken AXI (full) slave
design</a>.  Both of these
designs will hang your bus if the bugs within them are ever triggered.
As of Vivado 2020.2, these bugs have yet to be fixed.  (You can find better,
working examples of an <a href="/blog/2020/03/08/easyaxil.html">AXI4-lite slave design
here</a>, or a <a href="/blog/2019/05/29/demoaxi.html">working AXI4 full
slave design here</a>).</p>

<p>AXI is also ARM’s published bus standard.   The popularity of placing a ARM
CPUs within custom SoCs has helped to make this standard ubiquitous.</p>

<p>While I have filed bug reports in 2017 and 2018 on Xiling’s forums regarding
these broken demonstration designs, Xilinx has yet to fix their designs as of
Vivado 2020.2.
<a href="https://forums.xilinx.com/t5/Simulation-and-Verification/Formally-verifying-the-functionality-of-an-AXI-lite-peripheral/m-p/924562">[1]</a>,
<a href="https://forums.xilinx.com/t5/AXI-Infrastructure/AXI-demonstration-slave-core-has-multiple-bugs-within-it/m-p/973670">[2]</a>
Indeed, at this point, it’s not clear if Xilinx will ever fix their
demonstration designs.  Perhaps I shouldn’t complain–their broken designs
simply make the services I offer and sell that much more valuable.</p>

<p>In the meantime, however, I have been browsing <a href="https://forums.xilinx.com">Xilinx’s
forums</a> to see if I can help individuals working
struggling to get their designs to work with AXI.  My one claim to fame?  I
have now formally verified <a href="https://github.com/ZipCPU/wb2axip">several AXI and AXI-lite
designs</a>.  From this claim alone, I hoped to
demonstrate myself qualified to comment on problems Xilinx users might have.</p>

<p>Along the way, I’ve had mixed success.  I’ve formally verified several user
designs, and I’ve tried formally verifying several of Xilinx’s IP designs.
Sometimes I’ve been successful, and so I’ve found bugs in <a href="/blog/2020/01/01/2019-in-review.html">their AXI
Ethernet-lite core</a>
and verified that there were no bugs in either their <a href="/blog/2020/03/23/wbm2axisp.html">AXI
GPIO or their AXI Block RAM
Controller</a> (limited bounded
model checks only).
Neither was I able to find any bugs in their demonstration AXI or AXI-lite
masters.  (Their AXI stream master, on the other hand …)  Other designs,
however, such as their datamover, their
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
their Avalon to AXI bridge, their AXI
<a href="/formal2020/05/16/firewall.html">firewall</a>, or even their
AXI timer all
depend on encrypted IP components, and so I have been unable to verify them
or comment on their internal operations and details.</p>

<p>Still, I thought it might be worth taking some time to look at a sample of the
Xilinx forum threads I’ve contributed to which have discussed AXI.  Yes, this
sample set is biased: it’s a subset of only those posts I’ve contributed to.
Still, I’ve tried to be active in as many AXI issues as I could have, and so I
have at least convinced myself that this is a representative sampling of AXI
problems Xilinx users have come across.</p>

<h2 id="getting-started">Getting started</h2>

<p>The first problem beginning AXI users tend to come across is finding an easy
how-to discussion or example.
This user, for example, was <a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/How-to-design-a-custom-ip-axi-compatible-to-read-and-write-from/m-p/924333">looking for instructions on how to design a custom
AXI master</a>.
Here, <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-Hello-world-equivalent/m-p/1090446">another user is asking for an AXI Hello world
equivalent?</a>
The best answer I have to these questions is to offer <a href="/blog/2020/03/08/easyaxil.html">my EasyAxil
design</a> as a starting point
for learning how to build an AXI-lite slave design.</p>

<p>In general, however, Xilinx’s answer to the getting started problem is to offer
one of three basic approaches of relatively increasing complexity:</p>

<table align="center" style="float: right"><caption>Fig 1. Learning Waypoints for learning AXI</caption><tr><td><img src="/img/xilinx-forums/baby-steps.svg" alt="" width="420" /></td></tr></table>

<ol>
  <li>
    <p>Use <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">Xilinx’s AXI GPIO controller</a>.
This provides an easy on-ramp for an
engineer to control digital logic by controlling wires within the design.
This approach is quite easy, and it sounds great.  It sounds great, that is,
until you start reading the various user experiences among those who have
used this approach.  <a href="https://forums.xilinx.com/t5/Xilinx-Evaluation-Boards/AXI-GPIO-too-slow/td-p/725431">This user, for example, measured his
GPIO toggling perfromance at 3.8MHz</a>.
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Improve-IO-Performance-for-Microblaze-to-IO-register-using-AXI/m-p/1168976">Another user measured a cycle time of 120ns per instruction when accessing
his AXI-lite peripheral from a 100MHz clock</a>.
These are both kind of slow, given that the <a href="/zipcpu/2019/02/09/cpu-blinky.html">ZipCPU can toggle a GPIO at
47MHz when starting from a 100MHz clock, but that’s really another
story</a>.</p>

    <p>The bottom line here, however, is that while the approach works–it’s really
not the way to achieve high speed communication between your CPU and the
rest of your design.  CPUs just aren’t designed to toggle GPIO registers at
high speeds.  (We’ll ignore the fact that <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">Xilinx’s AXI GPIO
device</a>
requires a minimum of four clocks per access, together with the inherent
latency in their interconnect–or even any interconnect for that matter,
and …)</p>
  </li>
  <li>
    <p>Their second recommendation is that you start with <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">Xilinx’s AXI block RAM
controller</a>,
and then connect both this controller and your design to a shared block RAM.
This will get you closer to an ability to adjust registers within a design,
but it only offers the ability to read and write a shared RAM–not to read
and write control registers within a design, which is a common usage model.
I mean, how do you tell your programming logic (PL) that new data is in the
block RAM, or that it should start processing that data?  A second problem
with this approach is that there’s no way to stall something until your
design is ready or a previous task has completed.  This could easily reduce
a CPU to polling for results that might otherwise be accomplished in a clock
or two.</p>
  </li>
  <li>
    <p>The third approach is often the recommended one: <a href="/formal/2019/05/13/axifull.html">request Vivado create a
demonstration AXI design for
you</a>, and then modify
that design to meet your needs.  This is certainly Xilinx’s recommended
approach. <a href="https://forums.xilinx.com/t5/Vitis-Acceleration-SDAccel-SDSoC/Access-Custom-RAM-module-from-Zynq/m-p/1200037">[1]</a>,
<a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/IP-Core-Axi4-Axi-Lite/m-p/930618">[2]</a></p>
  </li>
</ol>

<p>The problem with this third approach is that <a href="/formal/2019/09/06/axi-story.html">Xilinx’s demonstration designs
are quite broken</a>.</p>

<ul>
  <li>
    <p>Here’s a list of links to forum posts regarding user designs that have been
broken by using (what appears to be) Xilinx’s AXI-lite slave demonstration
design:</p>

    <p>– Reads hang: <a href="https://forums.xilinx.com/t5/High-Level-Synthesis-HLS/Unable-to-access-write-read-custom-slave-AXI-peripheral-register/m-p/1014382">1</a>,
   <a href="https://forums.xilinx.com/t5/PCIe-and-CPM/XDMA-AXI-Lite-write-works-but-read-causes-Ubuntu-16-04-to-crash/m-p/1130550">2</a></p>

    <p>– Writes hang: <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI4-lite-Write-Channel-starts-the-next-transaction-before-the/m-p/1083247">1</a>,
   <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Writing-bytes-on-AXI-error/m-p/1069895">2</a>,
   <a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/What-are-the-possible-reasons-of-AXI-Lite-wrintings-hang/m-p/1072286">3</a></p>

    <p>– Other unspecified: <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Multidriven-AXI-Lite-registers-in-packaged-IP-Core/m-p/1151467">1</a>,
   <a href="https://forums.xilinx.com/t5/Design-Entry/Custom-AXI-Lite-Slave-IP-causing-Microblaze-to-stall/m-p/1132152">2</a></p>

    <p>Even with these bugs, many Xilinx user’s would much rather <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Testing-AXI4-Lite-Slave/m-p/1085153">just blindly
trusting Xilinx’s broken designs</a> based upon a
<a href="https://www.logicallyfallacious.com/logicalfallacies/Appeal-to-Authority">faulty appeal to authority</a>.
 Much to my surprise, some individuals have even found <a href="/blog/2020/03/08/easyaxil.html">my easy
 example</a> to be <a href="https://forums.xilinx.com/t5/Xilinx-IP-Catalog/Rading-BRAM-from-custom-IP-Verilog/m-p/993133">too
 complicated</a>.</p>
  </li>
  <li>
    <p>Here’s a similar list to posts about Xilinx’s demonstration AXI full slave:
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-SLAVE-WREADY/m-p/1137871">1</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Using-AXI-FULL-accessing-ZYNQ-MPSoc-DDR-on-ZCU106-board/m-p/1174700">2</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/BID-and-AWID-are-not-matched-in-AXI-interface/m-p/996443">3</a></p>

    <p>These actually follow a common pattern, where a user will complain of one
problem yet subsequent analysis then reveals another problem within.</p>

    <p>Sadly, while I can often find bugs in user designs when they are posted,
a common theme is that of someone with <a href="https://forums.xilinx.com/t5/Design-Methodologies-and/PL-to-AXI-reg/m-p/1079951">a design bug, but where they cannot
share their AXI slave component</a>.
Without any RTL to work off of, these bugs can be hard to find.</p>

    <p>Another recent complaint was that <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI4-full-slave-read-burst-RVALID-50/m-p/1205683">Xilinx’s demo design only gets 50% read
throughput</a>.
Yes, this was also one of the problems I discovered with <a href="/formal/2019/05/13/axifull.html">a formal
examination  of their AXI full design</a>.
It’s a bit of a shame too, since AXI was supposed to be designed as a <em>high
performance</em> bus, to find so many example designs that can’t achieve high
performance.</p>
  </li>
</ul>

<p>As always, be careful who you trust.  Not every demonstration design someone
will recommend to you works.  One poster,
<a href="https://forums.xilinx.com/t5/user/viewprofilepage/user-id/128087">[larshb]</a>
had a design he’d used successfully for years.  When <a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/Unable-to-perform-AXI-handshake-with-custom-AXIS-IP/m-p/1069905">he recommended it to
another</a>,
I was able to run a formal proof of it and discover many of the same bugs
within it that others had complained of above.</p>

<p>If you want a better design to start from, you should consider <a href="/blog/2020/03/08/easyaxil.html">this Easy
AXI-lite design</a>, and even
the associated <a href="/blog/2020/12/19/axil-register-checking.html">register handling
check</a>.
Alternatively, <a href="https://github.com/analogdevicesinc/hdl/blob/master/library/common/up_axi.v">Analog Devices posts a nice AXI-lite design</a>
that I’ve seen a couple designs built from as well.  While that one works
nicely, it’s not setup within for a formal proof.  How then will you know if
any changes you make to the design break it?  (You won’t.)</p>

<p>Either example, however, should help you get started.</p>

<h2 id="debugging-axi-components">Debugging AXI components</h2>

<p>A second reoccurring theme centered around how should one go about debugging
AXI components.  Of all things, debugging AXI components <em>should</em> be easy.
There are three basic steps involved.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 2. Steps to Verifying an AXI design</caption><tr><td><img src="/img/xilinx-forums/debug-methods.svg" alt="" width="320" /></td></tr></table>

<ol>
  <li>
    <p>Formally verify your AXI component.</p>

    <p>If you haven’t tried verifying an AXI4 design before, then you should know
that it is really is to do for an AXI-lite component:
Just instantiate <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">these AXI-lite slave
properties</a>,
and then <a href="/formal/2018/12/28/axilite.html">apply SymbiYosys to your
design</a>.</p>

    <p>AXI (full) designs are a bit more complicated, but I provide AXI4 properties,
examples and a bit of instruction to <a href="https://patreon.com/ZipCPU">my Patreon
supporters</a>, so those are still quite doable as
well.</p>

    <p>I should also point out that, of all the logic that can be formally verified,
bus logic tends to be some of the easiest to verify.  It’s also some of the
most critical logic within a design.  Consider, for example, what would
happen if a single component failed to follow the rules of the bus: the
entire design will likely lock up.  On the other hand, if that component
follows the rules of the bus but just failed to do what it was designed
to do, you might still manage to recover the rest of the design–at
least enough to use your design to debug what’s going on.  The point here is,
<em>getting your bus logic right is critical to debugging the application you
are really interested in</em>.</p>

    <p>While many individuals would recommend building a simulation test bench to
stimulate your brand new component in a
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
environment, the <a href="https://www.xilinx.com/products/design-tools/vivado/verification-ip.html">AXI Verification IP offered by
Xilinx</a>
isn’t known for triggering the bugs within their own designs–or surely they
would’ve never published them in the first place.</p>
  </li>
  <li>
    <p>Once you’ve formally verified your design, the next step is to place your
component into an <a href="/blog/2018/08/22/what-is-simulation.html">integrated design
simulation</a>,
and verify that it works together with the other components of your design.</p>

    <p>As I mentioned above, be careful with <a href="https://www.xilinx.com/products/design-tools/vivado/verification-ip.html">Xilinx’s AXI Verification
IP</a>.
It won’t necessarily trigger any of the bugs within their designs.  To my
knowledge, this isn’t unique to Xilinx either.  On one contract I’m working
on, with a custom AXI Verification IP, the AXI VIP has <em>the exact same
problem</em>.  The problem itself is rooted in the fact that the bugs are often
triggered by a busy interconnect–something rarely simulated when the
design is examined in isolation.</p>

    <p>That leads to the real difficult part of simulation: testing your design
in a sufficiently complex environment–such as with the Processing System
(PS) of the Zynq attached.  While I’ll admit that I’m still looking for a
good way to do this reasonably, I can also share that I rarely have any
problems with formally verified designs not working when integrated into
larger environments.</p>
  </li>
  <li>
    <p>Connect your design to actual hardware and try it out.</p>

    <p>This should only ever be the <em>third</em> method you try, not the first.  Sadly,
this becomes the method many individuals end up using to debug their designs.
Given that many of the bugs listed in the previous section will hang the
entire system, and worse that <a href="https://www.xilinx.com/products/design-tools/vivado/verification-ip.html">Xilinx’s AXI Verification
IP</a>
isn’t known for triggering these bugs in simulation, users who take this road
often find themselves struggling to figure out where their design actually
failed.</p>
  </li>
</ol>

<p>The result is that there are a lot of forum requests for help debugging
custom IPs.  See for example,
<a href="https://forums.xilinx.com/t5/Implementation/AXI4-lite-register-implementation-problems/m-p/923908">[1]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-Counter/m-p/1030089">[2]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI4-Lite-read-hangs-and-RREADY-is-not-deasserting-after-RVALID/m-p/1035006">[3]</a>,
<a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/Custom-AXI-peripheral-register-0-showing-fixed-data-even-without/m-p/1158158">[4]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Adding-AXI-Write-wait-states/m-p/1169544">[5]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Axi4-lite-slave-wrong-AWADDR-transfer/m-p/1176688">[6]</a>, or
<a href="https://forums.xilinx.com/t5/Design-Entry/why-does-custom-axi4-ip-fail-at-2nd-write-in-simulation/m-p/1190568">[7]</a>.</p>

<p>Here are some forum posts from users requesting simulation help:
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/How-to-debug-an-AXI4-peripheral/m-p/1202103">[1]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Simulating-Custom-AXI-Slave-Peripheral/m-p/1105197">[2]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Testing-AXI4-Lite-Slave/m-p/1079475">[3]</a>.
One person even asked about a technique dear to my heart–<a href="https://forums.xilinx.com/t5/Vivado-Debug-and-Power/FPGA-Verification/m-p/1077142">formal
methods</a>,
although these tend to only rarely be discussed on the forum.</p>

<p>Here’s another crazy one: in <a href="https://forums.xilinx.com/t5/Simulation-and-Verification/simulating-simple-AXI4-Lite-read-amp-write-with-a-custom-IP/m-p/930345">this case, the user didn’t want a full fledged
AXI test.  He believed he could perform a sufficient test in
hardware</a>.
While <a href="/blog/2017/06/02/design-process.html">I’ll admit to having been there
before</a>, the cost of
debugging in hardware is a lot of pain.  Worse, a piece of hardware might
<em>appear</em> to work for weeks or months on end, only to have an undetected and
latent bug lying within it.  (That was my case with <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">my own SDRAM
controller</a>,
before I formally verified it.)  Finding and fixing such bugs can be even more
challenging when they don’t present themselves often.  This is not a path I
would recommend, therefore, if you can avoid it.</p>

<table align="center" style="float: right"><caption>Fig 3. Using a firewall to find an AXI4 bug</caption><tr><td><img src="/img/xilinx-forums/using-an-axi-firewall.svg" alt="" width="420" /></td></tr></table>

<p>One piece of advice I often offer to users forced to do their debugging in
hardware is to connect an <a href="/formal/2020/05/16/firewall.html">AXI
firewall</a> to a design.
This can be useful when trying to determine whether the fault is your own, or
Xilinx’s AXI infrastructure.  If the fault occurs with the
<a href="/formal/2020/05/16/firewall.html">firewall</a> in place,
then the fault must lie somewhere else in your design (or you didn’t wire
it up right).  Even better, the
<a href="/formal/2020/05/16/firewall.html">firewall</a> will provide a
fault signal which you can use to trigger an <a href="/blog/2017/06/08/simple-scope.html">internal logic
analyzer</a> to capture
what’s going on.  The technique isn’t perfect, however, as the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">AXI
firewall</a> I have
modifies the environment it is observing–so it is possible to pass the
<a href="/formal/2020/05/16/firewall.html">firewall</a> test while still
having a bug within your design.  (Doh!)</p>

<h2 id="custom-axi-masters">Custom AXI masters</h2>

<p>The problem isn’t limited to the design of AXI slaves.  Many users have also
written in with problems debugging their custom AXI masters as well.  Examples
include: <a href="https://forums.xilinx.com/t5/Simulation-and-Verification/UART-lite-IP-halts-reading-after-data-is-transmitted/m-p/1170279">messing up AXI
handshaking</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/I-want-the-burst-length-to-be-different-in-every-Burst/m-p/1127226">not knowing how to set up a master to handle arbitrary burst
lengths</a>,
<a href="https://forums.xilinx.com/t5/Other-FPGA-Architecture/Block-RAM-access-with-AXI-Master-Interface/m-p/1100339">needing help just getting started with building an AXI master</a>, and
<a href="https://forums.xilinx.com/t5/Design-Entry/axi-araddr-lt-16-h0-IN-ADDR-31-24-1-IN-ADDR-15-8-1-is-ok/m-p/1095897">just not handling AXI outputs per spec</a>.
Beware that your problem might not just be the master at fault.  <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Custom-AXI-Master-VIP-failed/m-p/981512">In this
example the master was producing a wider ID field than the interconnect was
expecting</a>.</p>

<p>Some of these  problems we’ve discussed on this blog, although I’ll admit to
being rather light on how to generate burst-capable AXI masters.  Still, I
have <a href="/blog/2020/03/23/wbm2axisp.html">posted how to build a generic AXI(lite)
master</a>, and again on
<a href="/blog/2020/06/16/axiaddr-limits.html">the problems associated with building a burst-capable AXI
master</a>.  <a href="https://www.blueletterbible.org/kjv/jas/4/15">If the Lord
wills</a>, we may even discuss a <a href="https://github.com/ZipCPU/zipcpu/blob/b0d4944b13ad6b3b447172dd3f9d27dc86388907/rtl/core/axilops.v">new
AXI4 memory unit for the
ZipCPU</a>
that I’ve been working on recently.</p>

<p>Another common AXI problem is specifying the length of an AXI burst in AxLEN,
rather than one less than the burst’s length.  Although I have <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/BVALID-stays-low-in-custom-ip/m-p/1052704">only one link
for this</a>,
I’m still going to declare it to be a <em>common</em> problem if for no other reason
than it’s one I’ve struggled with myself.  Not only that, this is one of the
first things I look for when attempting to debug someone else’s design: do
the number of requests match the number of responses?  For this, it helps
to have the computer help count, and so either an AXI VIP or an
<a href="/formal/2020/05/16/firewall.html">AXI firewall</a> can also be
useful here.</p>

<h2 id="out-of-protocol-designs">Out-of-protocol designs</h2>

<p>Sadly, there’s only so much you can do for the user who hasn’t done their
reading on how AXI is supposed to work.  Often these individuals can get their
design to work with the AXI VIP suite, or perhaps with one or two peripherals,
or one implementation of the AXI interconnect.  The moment their environment
changes, however, their design then breaks.  Some of these users will then
even go so far as to blame every one nearby when the failure was actually to be
found within their their non-protocol compliant implementation in the first
place.</p>

<p>As one example, the AXI4 specification is very clear that <code class="language-plaintext highlighter-rouge">AWVALID</code> is not
allowed to wait on <code class="language-plaintext highlighter-rouge">WREADY</code> and vice versa, and yet users will still create
designs where they expect one transaction, whether <code class="language-plaintext highlighter-rouge">AW</code> or <code class="language-plaintext highlighter-rouge">W</code>, to take place
before the other.
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-Interconnect-awready-arready-not-going-high-on-one-SI/m-p/1090680">[1]</a>,
<a href="https://forums.xilinx.com/t5/Memory-Interfaces-and-NoC/MIG-do-not-assert-axi-awready/m-p/1138828">[2]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-Intrerconnect-holds-off-WDATA-without-AWADDR/m-p/1138307">[3]</a>
The problem is generally compounded by the fact that few AXI slave substitutes
act like the MIG AXI slave individuals ultimately want to use.  Therefore, once
they verify their core against a generic AXI slave–perhaps even the VIP–they
often pick up a bad habit along the way.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 4. In Xilinx's Ethernet-lite controller, RVALID depends on RREADY contrary to spec</caption><tr><td><img src="/img/xilinx-axi-ethernetlite/axi_rvalid.png" alt="" width="511" /></td></tr></table>

<p>I should also point out that this isn’t just a beginning user mistake either,
since <a href="/blog/2020/01/01/2019-in-review.html">Xilinx made a very similar mistake in their AXI Ethernet-lite
controller</a>
of not setting <code class="language-plaintext highlighter-rouge">RVALID</code> unless <code class="language-plaintext highlighter-rouge">RREADY</code> was already set.</p>

<p>Not every problem is so obvious.  <a href="https://forums.xilinx.com/t5/Simulation-and-Verification/Writing-to-AXI-Slave-using-VIP-package-doesn-t-work/m-p/1097505">This user set a valid signal on the clock
immediately following a reset</a>,
not realizing that this would violate the specification.  Indeed, I might
argue that the AXI4 specification isn’t very clear on this issue–a figure
is used to explain it with a bare minimum of accompanying text.  (See Fig.
A3-1 on page A3-36 in <a href="/doc/axi-spec.pdf">this copy of the
spec</a>.)</p>

<p>As with any bus protocol, you need to know when a request is made.  This
follows from the requirement that there must be one response for every
request.  An AXI request, for example, is made any time <code class="language-plaintext highlighter-rouge">xVALID &amp;&amp; xREADY</code>
are true on the same clock cycle.  Moreover, if <code class="language-plaintext highlighter-rouge">xVALID &amp;&amp; !xREADY</code>, the
request needs to be held into the next cycle.  <a href="https://forums.xilinx.com/t5/Design-Entry/AXI4-cycles-but-no-response/m-p/1112425">This
user</a>,
however, didn’t see a problem with holding <code class="language-plaintext highlighter-rouge">AWVALID</code> high until his request
had been made and then dropping it when <code class="language-plaintext highlighter-rouge">AWREADY</code> was low.  Breaking the
protocol in this fashion will also break valid AXI components.  Not all
components ignore bus signals when <code class="language-plaintext highlighter-rouge">xVALID &amp;&amp; !xREADY</code>.  Many components I’ve
come across, such as <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_gpio/v2_0/pg144-axi-gpio.pdf">Xilinx’s
GPIO</a>
or even their IPIF register handler as just two examples,
accomplish their internal task before setting <code class="language-plaintext highlighter-rouge">xREADY</code> to accept the request
for that task.  In other words, these designs, those that depend upon them,
and many other AXI slave designs will start working on the request <em>before</em>
they accept the request in the first place.</p>

<p>Finally, there was one user who assigned meaning to AXI ID’s coming from his
master.  If I recall, he was attempting to send side-channel information in the
ID bits–something probably more appropriately left for the <code class="language-plaintext highlighter-rouge">xUSER</code> bits.
This user was then disappointed to discover that the AXI width converter didn’t
preserve AXI ID’s.  <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-width-converter-master-has-no-IDs/m-p/1166800">[1]</a>  Had he stuck with
the rules of the bus, instead of trying to use an undocumented feature, he
wouldn’t have needed to try to rearrange his design when the feature he wanted
was suddenly no longer implemented.</p>

<h2 id="throughput-throughput-throughput">Throughput, throughput, throughput!</h2>

<p>Much to my surprise, when I started tallying these forum posts together, there
were <em>a lot</em> of requests for help achieving higher AXI throughput.  Perhaps
this shouldn’t surprise anyone.  One of the main purposes of custom digital
logic in the first place is to implement complex algorithms which can’t be
done in real time on a high powered CPU.  One of the things that is often
missed, however, is that high powered CPUs have carefully designed high speed
bus implementations.  How shall FPGA designs built upon AXI compete?</p>

<table align="center" style="float: right"><caption>Fig 5. What is a "side effect"?</caption><tr><td><img src="/img/xilinx-forums/side-effects.svg" alt="" width="320" /></td></tr></table>

<p>Yes, AXI was designed to be a high performance bus.  That doesn’t mean that
every implementation will achieve that high performance.  Indeed, there have
been a lot of requests for help to achieve higher throughput, or complaints
about the throughput provided by Xilinx’s infrastructure.  Here are just a few
of those:
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI4-Lite-Memory-Mapped-Performance-poor/m-p/1115566">[1]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Throughput-of-AXI-interconnect/m-p/1117062">[2]</a>,
<a href="https://forums.xilinx.com/t5/Memory-Interfaces-and-NoC/How-to-implement-memset-memcpy-to-PL-memory-space/m-p/1127227">[3]</a>,
<a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/AXI-BRAM-64-bit/m-p/1129534">[4]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Can-ARM-Master-send-data-to-mutiple-AXI-slave-interfaces-in/m-p/1147271">[5]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Can-t-latch-input-from-PS-to-PL-each-clock-cycle/m-p/1146449">[6]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/How-can-I-define-AXI4-full-data-size-to-be-larger-than-32-bit/m-p/1146670">[7]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI4-Lite-interface/m-p/1184689">[8]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Improve-IO-Performance-for-Microblaze-to-IO-register-using-AXI/m-p/1169474">[9]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Custom-AXI-slave-simulation-ADDR-LSB-OPT-MEM-ADDR-BITS/m-p/1182659">[10]</a>,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Advantage-of-Multi-slave-AXI-on-my-IP/m-p/1196157">[11]</a>.</p>

<p>I was a bit surprised to discover that the <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/What-is-the-processor-s-command-for-AXI-Full/m-p/1168545">PS (i.e. ARM’s CPU) doesn’t
automatically communicate using bursts with the Programming Logic
(PL)</a>,
but rather needs to be set up for that purpose.  When you think about it,
however, it makes sense.  If the design hadn’t been built that way, then you
might find yourself accidentally reading from a peripheral where read’s also
cause side effects not normally present when simply reading from a memory.
Still, it’s worth remembering.</p>

<p>But let’s start at the top.  If you want high throughput through your AXI
subsystem, then there are some very specific things you can and should be
doing:</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 6. "Rules" for achieving maximum bus performance</caption><tr><td><img src="/img/xilinx-forums/axi-performance-rules.svg" alt="" width="320" /></td></tr></table>

<ol>
  <li>
    <p>Use a common clock across all components if possible.  <a href="/blog/2017/10/20/cdc.html">Crossing from one
domain to another</a> will add
at least two clocks of latency from each domain.  It will also slow your
bus down to the speed of the slowest clock.</p>
  </li>
  <li>
    <p>Avoid width conversions by using a common width for your data bus.  Even the
most basic width conversion will add two clocks of latency to your design.
More complicated conversions, or converters designed to be generic will
likely take more latency.  For example, even <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilsub.v">my own AXI
downsizer</a>
takes two clocks to process an incoming write request, and another clock
(or two) on the return.</p>
  </li>
  <li>
    <p>If possible, use the maximum data width you can for this purpose–but make
it common across all bus components.</p>

    <p>In one case, a user connected their 32-bit design to the 128-bit port of the
ARM (PS).  They were then disappointed to discover that a 32-bit request
from the ARM was coming into the bus at 128-bits (no surprise there), but
then being converted into four independent 32-bit requests–one valid one
and three empty requests!  (In the after-analysis, this may have been a
result of the PS configuration getting out of sync with the design.)</p>
  </li>
</ol>

<p>It’s not just throughput that’s at issue.  <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-Intereconnector/m-p/1054644">This user complained of too much
latency in the interconnect</a>, and
<a href="https://forums.xilinx.com/t5/Versal-and-UltraScale/Strategy-for-lowest-latency-to-access-AXI-register/m-p/1096094">this one was looking for a strategy to achieve low latency
access</a>.  Indeed, latency and
throughput are both related performance numbers.</p>

<table align="center" style="float: right"><caption>Fig 7. Steps to optimizing any design</caption><tr><td><img src="/img/xilinx-forums/optimization-rules.svg" alt="" width="320" /></td></tr></table>

<p>Finally, as with all optimization tasks, your first step will be to get the
design to work slowly, your second step will be to measure your performance,
and then your third step will be to do any actual optimizations.  That
leads to <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Transmission-time-FPGA-CPU-Zynq/m-p/1156187">this discussion of how to measure
throughput</a>.  There was also <a href="https://forums.xilinx.com/t5/Simulation-and-Verification/calculation-of-throughput-in-FPGA/m-p/1007913">this question about
how to measure the throughput to memory within an
FPGA</a>.</p>

<p>I also have an approach I hope to write about soon for measuring AXI throughput.
It’s built around this <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axiperf.v">basic throughput measuring AXI-lite
slave</a>.  The
slave examines AXI (full) bursts and makes measurements of the bus it can snoop
on.  From this information, I should be able to measure bus throughput and
latency–but that’s a project for another day.</p>

<p>Don’t expect too much from software running on the PS either.  I’ve seen a
couple of users asking what it would take to get a software <code class="language-plaintext highlighter-rouge">memcpy()</code> to run
using burst mode.  <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/How-do-I-use-burst-transfer-using-AXI-Full-interface/m-p/958398">How then shall a user command an AXI burst from
software</a>?
(with links <a href="https://forums.xilinx.com/t5/AXI-Infrastructure/AXI-burst-access-to-the-AXI-full-slave-from-Microblaze-is-this/td-p/843235">1</a>
and <a href="https://forums.xilinx.com/t5/AXI-Infrastructure/How-Do-I-Perform-an-AXI-Burst-in-Software/td-p/592502">2</a>)  As I mentioned above, the bottom line
answer is … you can’t.</p>

<p>This follows from the nature of how CPUs work.  CPUs execute instructions.  They
don’t execute bursts of instructions, but singular instructions.  Hence, if you
have a software loop to read a string, the CPU doesn’t know to issue a burst.
It only knows each instruction individually.  To make matters worse, if any read
instruction receives a bus error, the CPU needs to stop on a dime at that
instruction without issuing any further memory accesses or updating any further
registers.  That makes burst memory handling challenging at best.</p>

<p>One potential solution is to tell the CPU that the memory address range in
question is cachable, and then to read it into the cache since cache reads
can be done in bursts.  This has other problems, however, since you might
accidentally read peripheral memory you didn’t intend to read as a result of
reading an entire cache line.  The bottom line here is that if it looks like
memory, you might be able to cache it and get burst access.  If not, you’ll
either need a DMA or be stuck with singleton reads and writes.</p>

<h3 id="axi-datamover-bugs">AXI Datamover Bugs</h3>

<table align="center" style="float: left; padding: 25px"><caption>Fig 8. Three types of AXI Data Mover DMAs</caption><tr><td><img src="/img/xilinx-forums/data-movers.svg" alt="" width="320" /></td></tr></table>

<p>A second topic that surprised me due to its prevalence was the number of
issues surrounding <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_datamover/v5_1/pg022_axi_datamover.pdf">Xilinx’s Datamovers (DMAs)</a>.
Xilinx provides three basic datamovers: a memory to memory DMA sometimes
called MM2MM, a memory to stream DMA (MM2S), and a stream to memory DMA
(S2MM).  They also provide other similar cores to include their <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_cdma/v4_1/pg034-axi-cdma.pdf">centralized
DMA (CDMA)</a> and <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_vdma/v6_2/pg020_axi_vdma.pdf">Video DMA (VDMA)</a> controllers.
Sure enough, they’re all encrypted, or I would’ve run a formal check on them
given all the controversy surrounding the S2MM datamover in particular.</p>

<p>Since we’ve just discussed AXI performance, it follows that the official answer
to achieving high performance on an AXI bus is to use a datamover (DMA) for
high speed memory transfer.  The good news is that these vendor provided data
movers are indeed high speed, full of features,  and provided with a <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/DMA-transfer-tutorial/m-p/1169995">tutorial
on how to do DMA transfers</a>.
In particular, these DMAs are some of the few vendor supplied AXI masters that
will <a href="/blog/2020/06/16/axiaddr-limits.html">use the full AXI burst
capability</a>.
Even better, many user tasks can be placed nicely between an
AXI MM2S and an S2MM, leaving the vendor tools to handle all of the complicated
data movement processing.  What more could you want?</p>

<p>The problem here seems to stem from certain non-intuitive S2MM design features
found in Xilinx’s deesign.  Whether or not these are actually <em>bugs</em> appears
to be a matter of debate, but their S2MM design clearly doesn’t do what many
users are expecting.</p>

<p>I have not personally used Xilinx’s S2MM design, so I’m more of a witness
and idea pollinator regarding it than anything else.  That said, I have built
(and formally verified) <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">my own S2MM
DMA</a>, and I can
assure you that mine does not have these non-intuitive features.</p>

<p>What non-intuitive features am I talking about?  Well, first, the S2MM design
will stop its transfer upon receiving a <code class="language-plaintext highlighter-rouge">TLAST</code> signal.  I’m told this feature
was created to support network packets, where the full length of the packet
might not be known until the end of the packet.  The second problem is that
without the <code class="language-plaintext highlighter-rouge">TLAST</code> signal, the S2MM design will hang while waiting for it.
If that weren’t enough, users need to prevent the S2MM component from receiving
any stream data prior to being configured with a transfer length, destination
address, and a command to start transferring.  Failing to prevent data from
entering prior to configuration will cause the S2MM design to hang.  Or, at
least, this is what I’ve managed to learn from the various S2MM posts I’ve
been watching.</p>

<p>Here are just some of these S2MM posts that I’ve come across:</p>

<ul>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Problem-with-AXI-DMA-data-transfer/m-p/1165733">Broken S2MM</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Tready-S2MM-of-DMA-constantly-low/m-p/1154812">Tready S2MM of DMA constantly low</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Custom-IP-works-functionally-but-on-integration-with-processor/m-p/1151489">S2MM core locks on TLAST</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Strange-AXI-DMA-behavior/m-p/1146003">DMA transfer fails</a> (No solution identified)</p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/How-do-I-verify-if-my-processor-Clock-is-entering-my-custom-IP/m-p/1150933">Absent clock?</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Xilinx-IP-Catalog/How-to-recover-DMA-S2MM-Direct-not-S-G-without-losing-data/m-p/1135825">Need to generate a missing TLAST signal</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-DMA-Receive-by-chunks/m-p/1116887">Generating TLAST?</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/FPGA-Configuration/axi-dma-internal-error/m-p/1116414">S2MM Requires pre-configuration</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/FPGA-Configuration/Problem-with-AXI-DMA/m-p/1116001">S2MM Accepts data, then hangs</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-DMA-S2MM-LENGTH-Register/m-p/1112349">Transfers end early</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/FPGA-Configuration/AXI-master-read-and-write-in-RTL/m-p/1102576">Need a stream to memory solution</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Axi-dma-S2MM-receive-data-are-not-all-perfectly-normal/m-p/1092067">First several words of S2MM transfer get lost</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/Problem-with-AXI-S2MM-DMA-and-SDK/m-p/1060268">S2MM sometimes runs and works, other times just fails and trashes the SDK</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-Datamover-Status-INTERR-Internal-Error/m-p/1166803">Internal error in AXI Datamover</a></p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-DMA-wrong-length-internal-error/td-p/1207387">Wrong DMA Length ?</a></p>
  </li>
</ul>

<p>Like I said, however, the official answer is that this S2MM design is bug free.
Your mileage, however, might vary.</p>

<p>You are, of course, welcome to use <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">my own
S2MM</a>
controller if you would rather.  It is available for free under the Apache
license.  It has worked nicely for some users.  However, unlike Xilinx’s
controller, mine doesn’t come with any Linux kernel or other software drivers.
At the same time, it doesn’t have the surprising features either.</p>

<h3 id="resetting-dma">Resetting DMA</h3>

<p>Before I move on to the smaller categories,
there is one large theme left and that is the problem associated with resetting
an AXI DMA.  Indeed, this problem has been such an issue that I’ve written
two posts on the topic–I’ll get to those in a moment.  The general problem
here seems to be either that users just naturally want to reset the DMA
between bursts, or that somehow the DMA gets hung and so they want to reset
things and start over.</p>

<table align="center" style="float: none"><caption>Fig 9. Resetting the DMA alone</caption><tr><td><img src="/img/xilinx-forums/reset-desired.svg" alt="" width="480" /></td></tr></table>

<p>Why might your DMA hang?  Perhaps because you’ve copied one of Xilinx’s
demonstration designs and you are trying to copy data from it?  That’s a common
theme through this section, but also a theme I’ve rarely been able to prove.
Perhaps the DMA failed because of the bugs in the demonstration designs.
Perhaps it failed because an off-chip interface hung when the chip it was
talking to went off line.  Perhaps something else went wrong with either the
DMA or the AXI infrastructure and now the user wants to reset the DMA.
<a href="/formal/2019/09/06/axi-story.html">[1]</a>
The problem, however, is that the user typically wants to reset the DMA
<em>without resetting the rest of his design</em>.</p>

<p>This is a problem in AXI, since AXI has no mechanism to abort an ongoing
transaction simply because the master is no longer interested in either
continuing it or receiving the results from it.</p>

<table align="center" style="float: none"><caption>Fig 10. Resetting the DMA requires resetting everything touching the AXI bus</caption><tr><td><img src="/img/xilinx-forums/full-axi-reset.svg" alt="" width="480" /></td></tr></table>

<p>The first post I wrote to address this problem was my post discussing protocol
<a href="/formal/2020/05/16/firewall.html">firewalls</a>.  If the
problem is caused by a misbehaving user peripheral, a
<a href="/formal/2020/05/16/firewall.html">firewall</a> should fix the
problem.  The <a href="/formal/2020/05/16/firewall.html">firewall</a>
would guarantee that all AXI requests get responses, and that (following any
protocol error) the DMA gets an appropriate bus error response.  Even better,
my own <a href="/formal/2020/05/16/firewall.html">firewalls</a> can
be configured to reset the downstream slave, and so allow you to recover from
a failure should one ever happen.</p>

<table align="center" style="float: none"><caption>Fig 11. Using a firewall to limit the reset to a single peripheral</caption><tr><td><img src="/img/xilinx-forums/firewalled-reset.svg" alt="" width="480" /></td></tr></table>

<p>The second post discussed <a href="/blog/2020/03/14/axi-reset.html">the difficulty of resetting an AXI
component</a> such as a DMA.
The problem, as mentioned above, is that you need to continue to provide any
write data that you’ve committed to, and you need to continue to wait for any
writes or reads to complete before you can declare a component idle.  That
also means that you need to leave <code class="language-plaintext highlighter-rouge">RREADY</code> and <code class="language-plaintext highlighter-rouge">BREADY</code> high during this time,
and further that you need to know how many responses are outstanding.  This
is quite doable if the core was designed properly with a transaction abort
function, but such a function is fundamentally <em>very different</em> from a soft
reset.  That’s the good news.  The bad news is that there’s no way to recover
from a non-compliant slave apart from using a
<a href="/formal/2020/05/16/firewall.html">firewall</a>–otherwise
your design may well hang until the next reset.</p>

<ul>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Processor-System-reset-freezes-PS-with-long-aux-reset-pulse/m-p/1140853">Short resets reset the DMA, long ones don’t</a>.  This is probably another example of looking for the
bug in the wrong place.  The underlying bug was associated with properly
engineering separate reset domains, but that wasn’t apparent from the
original question.</p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/PCIe-and-CPM/XDMA-Simulation-works-for-many-transfers-then-descriptor-count-0/m-p/1106305">User reports a design lock up when the downstream hiccups and takes too
long to respond</a>.  Unfortunately,
even with some help from an official Xilinx representative, this issue was
never resolved to know what the root cause was.</p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-DMA-S2MM-issue/m-p/1087561">Resetting S2MM, but not the rest of the design</a>.  This looks
like the S2MM problem above, where the S2MM was given data before being
configured.  (But <code class="language-plaintext highlighter-rouge">TREADY</code> was high …?)  This was then compounded when the
user tried to recover his design by resetting his S2MM component and not the
rest of the design.</p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/S2MM-DMA/m-p/1087864">Resetting between every pair of transactions</a>.  This user felt that it
was appropriate to reset the S2MM core between every usage.  Such resets
should  <em>never</em> be required.  In reality, his underlying problem was probably
the <code class="language-plaintext highlighter-rouge">TREADY</code> bug listed above.</p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/PCIe-and-CPM/Software-Reset-for-QDMA-IP-Not-Working/m-p/1069901">Software resets hang the DMA</a>.  This follows from our
discussion above.  It also appears that <a href="https://forums.xilinx.com/t5/PCIe-and-CPM/Software-Reset-for-QDMA-IP-Not-Working/m-p/1036558">this user complained about the same
issue twice</a>.</p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/How-do-you-reset-the-AXI-DMA-IP/m-p/1008913">How do you reset the AXI DMA IP</a>?  This user was
looking for a guaranteed way to restart the AXI DMA from software from
scratch.  He was looking for a failsafe way to do this.  The problem is that,
if your FPGA logic is hanging the DMA, there may be no hardware way to reset
the design without resetting the entire design.</p>
  </li>
</ul>

<p>The bottom line answer remains the same as before: 1) formally verify
<em>everything</em> that touches your bus, 2) Simulate everything before placing
it onto your hardware, and 3) use logic analyzers if necessary if you are
struggling with any problems afterwards.  If you do find hardware bugs in
step three, that’s a sign you messed up steps 1 and 2.  Go back and re-do
those better, so they won’t have the same problems again in the future.</p>

<p>If you can’t simulate an ARM CPU, then get a digital design with a CPU within it
that you can simulate.</p>

<h3 id="fft-ip-core">FFT IP core</h3>

<p>FFT questions aren’t really AXI questions, but they aren’t all that uncommon
either.  Indeed, FFT questions are common enough that we’ve discussed <a href="/digilent/2017/05/29/fft-debugging.html">how to
solve FFT problems in
general</a>
already, as well as how to handle <a href="/dsp/2020/04/20/axil2axis.html">in-hardware protocol testing with an
AXI-stream based component</a>.
Both approaches should help the users below get closer to their solution.</p>

<ul>
  <li>
    <p><a href="https://forums.xilinx.com/t5/AI-Engine-DSP-IP-and-Tools/FFT-IP-core-hanging-after-sometime/m-p/1169001">The FFT core hangs</a>.  From a forum question
standpoint, this one was horrible.  The user provided a vague description
of something going wrong, but then provided no other information suitable
for narrowing the problem down.  In the end, the user explained the issue
by stating that there was an AXI protocol error of some unspecified type.</p>
  </li>
  <li>
    <p><a href="https://forums.xilinx.com/t5/AI-Engine-DSP-IP-and-Tools/FFT-IP-pipeline-latency/m-p/1164810">What is the FFT IP core’s pipeline latency</a>?  This question
confused me.  Why not just measure it?  Any good simulation should be able
to provide this answer.  This leaves me wondering if the user didn’t
simulate his design before moving to hardware, and so had no hard insight into
how the design was actually working now that he had placed it onto his
hardware.</p>
  </li>
</ul>

<h3 id="cache-coherency">Cache coherency</h3>

<p>When working with a CPU, always be aware of the issue of cache coherency.  It’s
not uncommon to use a DMA to transfer data and then, only later, to discover
that the DMA has changed data within the CPU cache.  I know <a href="/blog/2019/11/14/sdspi.html">I’ve had that
problem when working with the
ZipCPU</a>.  That also appears to
be the <a href="https://forums.xilinx.com/t5/Memory-Interfaces-and-NoC/PL-DDR-ACCESS/m-p/1090876">problem this user was struggling
from</a>.</p>

<h3 id="how-to-debug-an-axi4-interconnect">How to debug an AXI4 interconnect?</h3>

<p>It wasn’t clear from <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/FPGA-Verification/m-p/1180297">this post</a> if the user wanted to verify
their own interconnect, or one they built on their own.</p>

<p>Personally, I would recommend formal verification.  That said, my own AXI
interconnect has been failing its formal proof for some time (while passing
simulation tests), so … I have some work to do here in my own back yard.</p>

<h3 id="failing-to-provide-a-full-16-clock-reset">Failing to provide a full 16-clock reset</h3>

<p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Block-Memory-Generator-IP-AXI4-Lite/m-p/1185875">This one</a> isn’t quite as simple as my title
indicates.  Re-reading the post again today, it appears as though the user
had multiple reset domains across clock domains, and that they weren’t properly
synchronized.</p>

<h3 id="ethernet-lite">Ethernet-Lite</h3>

<p>Remember how I mentioned that Xilinx’s AXI ethernet lite core was not
bus compliant?  Here’s <a href="https://forums.xilinx.com/t5/Design-Entry/AXI-Ethernet-Lite-Core-behaviour-to-AXI-master-bus/m-p/1169426">how that looks from this user’s
perspective</a>.</p>

<p>Bottom line takeaway?  What you see may be leading you very far from the
true underlying problem.  Verification needs to start at the low level,
and it needs to be methodical, lest you end up with an <a href="/zipcpu/2017/12/28/ugliest-bug.html">inexplicable
mystery in hardware</a>.</p>

<h3 id="mm2s-performance">MM2S performance</h3>

<p>While most of the problems seem to center around the unexpected S2MM behavior,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Problem-with-AXI-datamover-MM2S/m-p/1174964">one user had a real challenge with the
MM2S</a>.  In this case, the user was getting horrendous
performance from the MM2S DMA.  A DMA <em>should</em> be able to transfer one beat of
data on every cycle.  In this example, the MM2S wasn’t maintaining that speed.
Looking over the problem again now, I wonder if his data FIFOs weren’t deep
enough.  Not knowing how the detailed design was actually configured, it’s
hard to be certain.</p>

<h3 id="measuring-logic-usage">Measuring logic usage</h3>

<p>One of the challenges associated with a complicated bus design is the logic
complexity required to implement it.  In my own work, I’ve done lots of
comparisons between Wishbone, AXI, and AXI-lite “equivalent” components.
(I use “equivalent” in quotes, because the various differences between
bus implementations make it hard to do true apples to apples comparisons.)</p>

<p>Needless to say, since FPGA cost goes up with available logic, logic usage
comes up as a topic.  Much to my surprise, I only found two posts among
my set dealing with this topic.  In the first post, the user is asking
<a href="https://forums.xilinx.com/t5/Other-FPGA-Architecture/FPGA-logic-estimator-to-select-device/m-p/1165735">how to quickly and easily estimate logic resource
requirements</a>.
This is usually pretty easy to do with Yosys at all levels of the design,
although I’m not quite sure how I would do it with Vivado without building
my entire design and connecting it to an XDC file.</p>

<p>A second user is looking for tips and tricks to reduce his design size.  The
key to this post is that <a href="https://forums.xilinx.com/t5/Synthesis/Size-Optimized-HDL-Tricks-Guidlines/m-p/1093591">his timer is taking up 60% of his 25k LUT
area</a>.</p>

<p>Yes, FPGAs are getting bigger and more powerful every day.  However, if you
take that FPGA and place a microblaze on it, a flash-based boot loader, a MIG
SDRAM controller, and the necessary AXI interconnect to connect them all
together, you might quickly find that half of your resources are already
used.  As with my rules for optimization above, step number one is to get
something working, and step two is to start measuring the problem.  From there
you can start to balance performance needs as required.</p>

<p>Indeed, <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Native-Control-of-AXI4-Lite-Master/m-p/978697">this post</a> really takes the cake.  The
user wanted to know the easiest way to control an AXI4-lite peripheral.
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Native-Control-of-AXI4-Lite-Master/m-p/978697">Xilinx’s answer was to recommend using a microblaze CPU</a>.  Seriously?  Just to control an AXI4-lite peripheral, you now need
a CPU, an interconnect, a flash device, and a block RAM and/or external
SDRAM.  Why not just build a simple state machine?</p>

<h3 id="mig-generates-extra-rvalids">MIG generates extra RVALIDs</h3>

<p>Much to my surprise, the MIG generated AXI interface is highly dependent upon
the performance of the memory chip itself.  Indeed, if you misconfigure your
memory chip and its timings, the result will often masquerade as an AXI bug.</p>

<p><a href="https://forums.xilinx.com/t5/Memory-Interfaces-and-NoC/MIG-DDR3-SDRAM-controller-responding-without-request/m-p/1038755">When I first encountered this problem</a>, I was absolutely convinced Xilinx’s controller had an AXI bug within it.
I could count AXI requests and responses, and sure enough I was getting a
response without ever issuing a request.  Upon further investigation, I
discovered I had the MIG configured for the wrong memory chip.  The controller
was issuing read requests of the MIG to keep the PLL locked, the responses
weren’t coming back in their expected windows, and so I was getting read
returns I wasn’t expecting.</p>

<p>At the time, I thought I was the only one who had ever or would ever have this
issue.  I was wrong.  <a href="https://forums.xilinx.com/t5/Memory-Interfaces-and-NoC/MIG-generating-RVALID-without-having-a-AXI-read-cycle-Kingston/m-p/1167170">Here’s a user with a similar issue, discovering in the
end that their chosen memory chip wasn’t
supported</a>.</p>

<h3 id="design-works-infrastructure-is-broken">Design works, infrastructure is broken</h3>

<p>One of the complaints that always catch my eyes are those claiming that Xilinx’s
AXI infrastructure is broken.  I see the complaint often enough that I thought
I’d create my own category for it here.  Unfortunately, in spite of all the
complaints I’ve seen few can actually be traced to Xilinx’s interconnect.  Of
those I’ve reviewed, I’ve moved them into other sections in this post simply
because the problems tend to be caused by user designs and not Xilinx’s
interconnect.</p>

<p>Sure, I’d love to say I’d found a problem with their interconnect.  That would
be great advertising material for Gisselquist Technology!  You can rest assured
thatt I’d certainly post about it here if I had found such!  Unfortunately, all
of the bugs I’ve actually traced down that started with complaints about
Xilinx’s interconnect have turned into bugs elsewhere.  I’m not going to go as
far as to say that there aren’t any bugs in their interconnect, but I sure
haven’t seen any evidence of such … yet.  (I’m still looking …)</p>

<p>To make matters worse for my own pride, <a href="https://www.avery-design.com">Avery Design
Systems</a> pointed out to me (gently) that Xilinx’s
AXI interconnect put mine to shame in terms of performance.  Ouch.</p>

<p>What I have instead for this section appears to be a list of dissatisfied users
who just wanted more than the tools were offering them.</p>

<p>For example, here’s an question from someone who just wasn’t satisfied with what
he had.  <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-Lite-Register-Array/m-p/1158304">He wanted a simple support to connect and control a massive numbers of
registers</a>.  The constraint here was apparently imposed by
his work environment, where he was “asked to add as little custom as possible
and instead use vendor IPs as much as [he could].”  That’s a great idea, when
the vendor IPs 1) do what you want, and 2) work.  Once we realized this, there
wasn’t much more we could do to help him.  It was a shame, however, since
<a href="/blog/2020/03/08/easyaxil.html">building a basic AXI slave register
controller</a> is actually
pretty easy to do–even for a hundred (or more) registers.</p>

<p><a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-SmartConnect-limited-to-8-masters/m-p/1089712">Another user complained that Xilinx’s brand new (at the time) SmartConnect
was limited to 8 masters</a>.
While I offered him an <a href="/blog/2019/07/17/crossbar.html">open source AXI interconnect
alternative</a>, he didn’t
reply and so it’s not clear if his issue was ever answered.</p>

<p>In my final example, I wish I could tell you what <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-Full-Master-64bit-MSB-32bit-error/m-p/1153145">this user’s error
was</a>.
Looking over his design, I couldn’t see anything wrong with it.
When I later commented to that effect, he accepted my comment as the
solution.  Perhaps there was something else wrong elsewhere in his design?</p>

<p>Just to round out the section with an actual “problem”, I’ll point out that at
one time I complained about the fact that Xilinx’s AXI to AXI-lite bridge
limited the AXI-lite downstream to only one burst at a time.  The response I
discovered was two-fold.  First, I discovered that this was a “feature” of
their area optimized interconnect.  Second, I was told that AXI-lite was never
designed for speed, so you shouldn’t expect high performance from it anyway.
If you want speed, you should be using AXI full (and a custom DMA-type of
master, not a CPU).</p>

<p>Sorry, that’s all I have for (validated) complaints about Xilinx’s AXI
infrastructure.</p>

<h3 id="limited-size">Limited size</h3>

<p>One complaint that’s come up a couple of times is that the various DMAs have
a limited size that they can transfer.  <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-DMA-IP-Core-upgrade/m-p/1034872">This user, for example, is complaining
that the DMA size is limited to 8MB</a>.  (Yes, I remember
when nobody thought anyone would ever need more than 640kB …)</p>

<p>I know from my own experience that I came across this issue as well when
designing <a href="https://github.com/ZipCPU/wb2axip">my own DMAs</a>.  At some point,
you need to allocate how many bits will be used to capture the transfer
length.  You also need to decide how wide the address bus should be, and
whether or not the DMA will be allowed to wrap from high addresses back
around to low addresses, etc., etc.  (Welcome to hardware design!)  In my case,
I parameterized most if not all of these items.  That way, if you don’t like my
default choices, you can just adjust the parameters until you have the choice
you want.</p>

<p>Unfortunately, Xilinx doesn’t appear to have parameterized their DMA’s transfer
sizes.  This means that you’ll either need to interrupt your CPU that much
more, use a scatter-gather engine to script multiple DMA transfers, or
choose to switch to an open source implementation that doesn’t have that limit.</p>

<h3 id="partial-address-decoding">Partial address decoding</h3>

<p>Every now and again, someone writes in asking about something absolutely crazy
taking place in their design–something so crazy it doesn’t make any sense.
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-Peripheral-Register-Access/m-p/1014667">In this case, a user wrote in describing how every 16th byte in his design
was getting written in a single write</a>.  It made no
sense to him.  Indeed, it doesn’t make much sense at all–until you dig into
how address decoding is done within an FPGA.</p>

<p>This phenomenon is a consequence of what’s known as “partial address decoding”.
This is the cheap way of address decoding, where you don’t compare against all
address bits.  Instead you only compare against enough bits to make sure that
the peripherals are all at the addresses they are promised to be at and you
make no promises regarding phantom peripherals which may appear to reside at
all of the other addresses.</p>

<p>Here was <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Vivado-what-is-addresses-and-address-ranges-of-IPs-in-vivado/m-p/984656">another user asking how address decoding is accomplished within an
interconnect</a>.  It’s
really not that hard to understand–especially not when you dig into it
just a little bit.</p>

<p>To read more on this topic, feel free to look at <a href="/zipcpu/2019/09/03/address-assignment.html">how AutoFPGA handles address
assignments</a>,
since I discuss the topic there.</p>

<h3 id="know-the-specification">Know the specification</h3>

<p>FPGA design is a type of engineering.  As an engineer, you’ll be required to
read, study, and understand complex data sheets.  This is the nature of the
business.  One such data sheet is the <a href="/doc/axi-spec.pdf">AXI
specification</a>.  That’s sort of a
requirement when working with AXI.  Know <a href="/doc/axi-spec.pdf">the
specification</a>, and things will get much
easier.</p>

<p>One user I remember declared that AXI was too hard.  <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Read-and-write-through-AXI4/m-p/999075">He wanted something
easier</a>.
I wish I had a better answer for him, but the bottom line is that engineering
requires reading, studying, and understanding complex data sheets.  It’s what
engineers get paid for.   If you don’t like it, find something you do like.</p>

<p>Another user just wanted to know the easiest way to drive an AXI UART-lite?
<a href="https://forums.xilinx.com/t5/Xilinx-Evaluation-Boards/AXI-4-UART-Lite/m-p/998352">He just needed a basic AXI master</a>.
Their request could’ve been quite simply handled, with the exception that they
were limiting themselves to <em>proven IP only</em> (i.e. Xilinx’s vendor libraries).
<a href="https://forums.xilinx.com/t5/Xilinx-Evaluation-Boards/AXI-4-UART-Lite/m-p/997614">[2nd Ref]</a></p>

<p>Without understanding AXI, <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-DMA-changing-some-value-to-0/m-p/998347">this user assumed READY would just stay high once
it rose initially</a>.  Sure enough, his design didn’t
do what he was expecting.  Like most of the engineers I’ve known, myself
included, this engineer was also quite convinced the problem wasn’t in his
own design but in the DMA he was using.</p>

<p>I’d love to say that all bugs get solutions.  <a href="https://forums.xilinx.com/t5/Embedded-Development-Tools/Writing-data-in-AXI-register-through-XIo-Out32-address-data-or/m-p/998160">This user posted that something
was causing his design to freeze when accessing his custom AXI IP component</a>.  The bug dates back to 2012.
I don’t have records going back that far, but I do know the demo IP was broken
back in 2016.  I also have reason to believe it was broken earlier–in 2014
based on some user designs I’ve examined dating back that far.</p>

<p>It’s not that uncommon to find students asking for help, and just trying to
get their homework done.  They’ll take the demo design and modify it as little
as possible.  As an example, here’s an individual complaining that his <a href="https://forums.xilinx.com/t5/Implementation/custom-ip-creation-in-vivado/m-p/995679">matrix
solution AXI slave not working</a>.  Sadly, this individual’s design had so
many problems within it that we never got far enough to get to the problem
he was struggling with.</p>

<p>It’s a shame to find someone who used Xilinx’s demo design.  In this case,
<a href="https://forums.xilinx.com/t5/Synthesis/AXI-custom-ip-with-microblaze/m-p/993821">the user design only worked once</a>.  When I pointed out the bugs in Xilinx’s
demo design, the user upgraded to the latest version of Vivado thinking that
the bugs would have been fixed.  Imagine their surprise, and indeed my own,
when the bugs reported in 2017 are still present in Vivado 2020.2.</p>

<p>Here’s a crazy discussion of things not working: <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Xil-In32-taking-excessively-long-time-to-read-two-registers/m-p/983131">in this example, a user
measures the time difference between two AXI reads in his design</a>.  Two reads, with nothing else in between
them, are recorded to take around 50us.  That’s dismal performance!  In the
end, he discovered that he could drop this time down to less than a microsecond
by switching the C compiler from debug mode to release mode.</p>

<p>Reading <a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/Xil-In32-taking-excessively-long-time-to-read-two-registers/m-p/983131">his post</a>
again today, in hind sight, it looks like I missed his implicit conversion from
integer to double in between his two AXI reads.  The bottom line here is that
you need to know what your CPU is doing.  You might also find it helps to dig
into the assembly of what’s going on every now and again.  This should’ve been
one of those times.</p>

<p>There should be a rule against complicated AXI signaling.  Looking over
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI-lite-read-channel-overflow/m-p/961738">this user’s custom AXI peripheral</a>, he makes one
of the more fundamental mistakes.  <code class="language-plaintext highlighter-rouge">RVALID</code> should be set based upon
<code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code> <em>and nothing else</em>!  Keep it simple.  If your design isn’t
ready to handle the its inputs, then keep <code class="language-plaintext highlighter-rouge">ARREADY</code> low.  Much to my surprise,
his design was producing two <code class="language-plaintext highlighter-rouge">RVALID</code>s for every <code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code>.
No wonder the design wasn’t working!  Had he posted his full custom AXI
module, I would’ve provided a simple formal check–I might’ve even been able
to point out the line that was broken.  Indeed, the formal check should’ve
taken place before he ever tried his design in actual hardware.  Failing
that, a good <a href="/formal/2020/05/16/firewall.html">firewall</a>
would’ve helped find the problem nicely.</p>

<h2 id="looking-for-a-tutorial">Looking for a tutorial</h2>

<p>If the above posts haven’t made the case for it, several users have asked for
better training materials.  <a href="https://forums.xilinx.com/t5/Ethernet/AXI-Lite-Slave-Example-Tutorial/m-p/967775">Here’s a user looking for an AXI-lite slave
example/tutorial</a>.    Here’s <a href="https://forums.xilinx.com/t5/Design-Entry/Custom-AXI-IP-Tutorial/m-p/1085203">another, requesting a custom IP AXI
tutorial</a>.  Or a third, <a href="https://forums.xilinx.com/t5/Memory-Interfaces-and-NoC/How-to-interface-custom-IP-with-MIG-DDR3-via-AXI-master-burst/m-p/1073843">wondering how to move data from memory to an FPGA
processing core and back to memory
again</a>.
Again, the common theme here is, where shall I go to find the training material
I need to learn how to do what I need to?</p>

<p>Not everything fits nicely into official training material.  Some questions,
<a href="https://forums.xilinx.com/t5/Processor-System-Design-and-AXI/AXI4-4K-address-boundary/m-p/996921">like this one on how to handle non-power of two burst
lengths</a>, just need simple explanations.  Questions like
these make the forums fun.</p>

<h2 id="conclusions">Conclusions</h2>

<p>Yes, AXI can be complex.  Frankly, it’s becoming the cost of doing business
with either a CPU or external memory on an FPGA.  Read <a href="/doc/axi-spec.pdf">the
specification</a>, study it, and
understand it.</p>

<p>You can also look up the various AXI articles I’ve posted.  I’ve posted articles
on designing both AXI and AXI-lite slaves and masters.  We’ve discussed
on this blog <a href="/blog/2020/03/14/axi-reset.html">how to reset AXI
designs</a>, and <a href="/formal/2020/06/12/four-keys.html">the problems
with Xilinx’s DMAs</a>.</p>

<p>Let me also encourage you to formally verify your AXI designs.  The formal
verification tool can be one of the better teachers you come across.  You
just need to provide the formal solver with your design and <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">an
AXI-lite</a>
or AXI property file.  Then, run the solver.  If the design fails, the solver
will give you the line number of a failing property together with a trace
showing the bug.  Believe me, two hours with a formal solver will fix a lot
more bugs in your design than you’ll fix in two hours just trying to get your
design placed on hardware.</p>

<p>Finally, let me also point out that a lot of the user problems above could’ve
been avoided if the user had access to the RTL designs for the other half
of the interface they were working with.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>There hath no temptation taken you but such as is common to man: but God is faithful, who will not suffer you to be tempted above that ye are able; but will with the temptation also make a way to escape, that ye may be able to bear it. (1Cor 10:13)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
