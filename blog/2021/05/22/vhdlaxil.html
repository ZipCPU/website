<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Fixing Xilinx's Broken AXI-lite Design in VHDL</title>
  <meta name="description" content="Someone recently posted on Xilinx’s forums that they were having issues withtheir design.  Apparently, the design was hanging on startup.  When I asked ifthe...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2021/05/22/vhdlaxil.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Fixing Xilinx's Broken AXI-lite Design in VHDL</h1>
    <p class="post-meta"><time datetime="2021-05-22T00:00:00-04:00" itemprop="datePublished">May 22, 2021</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Someone recently posted on Xilinx’s forums that they were having issues with
their design.  Apparently, the design was hanging on startup.  When I asked if
they had an AXI-lite slave within it, they shared their design with me.  It
looked an awful lot like <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s AXI-lite template
design</a>.</p>

<p>It’s amazing how often this design comes up.</p>

<p>This time, however, the design was written in VHDL.  Since I don’t normally
write about or discuss VHDL on the blog, I thought this might be an opportunity
to examine a VHDL design.  No, we won’t be examining VHDL today, just a VHDL
design.  Perhaps this will help someone new to AXI who isn’t (yet) familiar
with Verilog.</p>

<p>Either way, let’s have some fun and examine <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s demonstration AXI-lite
slave demonstration design, but this time in
VHDL</a>.</p>

<p>I’ll be using the commercial Symbiotic EDA Suite for this evaluation.  The
suite is now sold under the name “<a href="https://www.yosyshq.com/products-and-services">Tabby CAD
Suite</a>” by a company named
<a href="https://www.yosyshq.com/">YosysHQ</a>,
but I’ll leave those details for their marketing folks.  Feel free to <a href="https://www.yosyshq.com/contact">contact
them</a> and tell them I sent you.</p>

<!-- Matthew 8:4 -->

<table align="center" style="float: right"><caption>Fig 1. VHDL Verification Setup</caption><tr><td><img src="/img/vhdlaxil/vhdl-setup.svg" alt="" width="320" /></td></tr></table>

<p>The setup for this verification proof is nearly identical to any Verilog
setup, save that VHDL doesn’t really have a (supported) language for expressing
assertions.  (What about
<a href="https://en.wikipedia.org/wiki/Property_Specification_Language">PSL</a>?  See the
word “supported”.)  For this reason, I’ll create a SystemVerilog wrapper around
the VHDL design, as shown in Fig. 1 on the right.  Within that wrapper, I’ll
instantiate both the AXI-lite slave module under test, as well as the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal
AXI-lite slave property set</a> that
<a href="/formal/2018/12/28/axilite.html">we’ve discussed before</a>.
It’s all quite straightforward and (mostly) boiler plate.  In this case I
needed only five properties at the top level in order to get the design to
pass <a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<p>The first thing to note about Xilinx’s VHDL design is that, yes, it’s
still broken.</p>

<table align="center" style="float: none"><caption>Fig 2. Xilinx's AXI-lite slave might accept 7 (or more) requests, while only returning a single response</caption><tr><td><a href="/img/vhdlaxil/read-failure.png"><img src="/img/vhdlaxil/read-failure.png" alt="" width="780" /></a></td></tr></table>

<p>Indeed, Xilinx’s
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">AXI-lite VHDL design</a> uses the same logic as their <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2018_3.v">AXI-lite
Verilog design</a> does.  Register for register, it’s hard to see a difference
between the two designs.</p>

<h2 id="how-to-recognize-your-design-is-broken">How to recognize your design is broken</h2>

<p>Let’s suppose, however, that you didn’t have any formal tools.  How could you
tell this design is broken?</p>

<p>After formally verifying many AXI-lite designs, it’s gotten really easy for me
for me to spot the same bugs that keep taking place over and over.  Indeed,
there are just a couple things I look for and then I can spot most of these
bugs (now) by eye.  Here are two quick checks.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">AxVALID</code> should (somehow) depend upon <code class="language-plaintext highlighter-rouge">(not xVALID) or xREADY</code></li>
</ol>

<p>This is really the big criteria, and the one <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s
design</a>
fails.  Because AXI allows
<a href="https://en.wikipedia.org/wiki/Back_pressure">backpressure</a>, at some
point when the return channel is stalled, such as when
<code class="language-plaintext highlighter-rouge">RVALID and (not RREADY)</code>,
the source channel will have to stall as well.  This applies to both read
and write channels.</p>

<p>So, let’s look at <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s AXI-lite slave
design</a>
and see if <code class="language-plaintext highlighter-rouge">ARREADY</code> somehow depends upon either <code class="language-plaintext highlighter-rouge">not RVALID</code> or <code class="language-plaintext highlighter-rouge">RREADY</code>.
The answer is: it doesn’t.  Here’s what their <code class="language-plaintext highlighter-rouge">axi_arready</code> logic looks like:</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl">	<span class="c1">-- Implement axi_arready generation</span>
	<span class="c1">-- axi_arready is asserted for one S_AXI_ACLK clock cycle when</span>
	<span class="c1">-- S_AXI_ARVALID is asserted. axi_awready is </span>
	<span class="c1">-- de-asserted when reset (active low) is asserted. </span>
	<span class="c1">-- The read address is also latched when S_AXI_ARVALID is </span>
	<span class="c1">-- asserted. axi_araddr is reset to zero on reset assertion.</span>

	<span class="k">process</span> <span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">begin</span>
	  <span class="k">if</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">)</span> <span class="k">then</span> 
	    <span class="k">if</span> <span class="n">S_AXI_ARESETN</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="k">then</span>
	      <span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="sc">'0'</span><span class="p">;</span>
	      <span class="n">axi_araddr</span>  <span class="o">&lt;=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span> <span class="sc">'1'</span><span class="p">);</span>
	    <span class="k">else</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">axi_arready</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="ow">and</span> <span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
	        <span class="c1">-- indicates that the slave has acceped the valid read address</span>
	        <span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="sc">'1'</span><span class="p">;</span>
	        <span class="c1">-- Read Address latching </span>
	        <span class="n">axi_araddr</span>  <span class="o">&lt;=</span> <span class="n">S_AXI_ARADDR</span><span class="p">;</span>           
	      <span class="k">else</span>
	        <span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="sc">'0'</span><span class="p">;</span>
	      <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
	    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
	  <span class="k">end</span> <span class="k">if</span><span class="p">;</span>                   
	<span class="k">end</span> <span class="k">process</span><span class="p">;</span> </code></pre></figure>

<p>Do you see any references there to <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code>?  How about to <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code>?
How about any other signals related (somehow) to one or both of those two
signals?</p>

<p>No, you didn’t.  That’s because it’s not there.</p>

<p><a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">This design</a>
is broken.  We’ll come back to this in a moment to fix it.</p>

<ol start="2">
  <li>Transitions should only be made on <code class="language-plaintext highlighter-rouge">xVALID and xREADY</code></li>
</ol>

<p>When using AXI, nothing happens unless both the valid and ready signals are
asserted on the given channel at the same time.  While the formal tool
doesn’t detect any more bugs in <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">this
slave</a>,
let’s still take a moment to look at some of the logic within it.</p>

<p>For example, what about the slave’s internal write enable signal?</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="n">slv_reg_wren</span> <span class="o">&lt;=</span> <span class="n">axi_wready</span> <span class="ow">and</span> <span class="n">S_AXI_WVALID</span> <span class="ow">and</span> <span class="n">axi_awready</span> <span class="ow">and</span> <span class="n">S_AXI_AWVALID</span><span class="p">;</span></code></pre></figure>

<p>Have you ever wondered what would happen if this were only partially true?
I mean, what would happen if <code class="language-plaintext highlighter-rouge">S_AXI_AWVALID &amp;&amp; axi_awready &amp;&amp; !S_AXI_WVALID</code>?
What would happen is that the write address channel would accept a transaction
and the design would go downhill quickly.  In one design I remember, one
with a lot of activity, every following write transaction was issued to the
wrong address–much like you might expect.  Of course, the other possibility
is that the design might just hang.</p>

<p>Indeed, this is why, in my own
<a href="/blog/2020/03/08/easyaxil.html">EasyAxil design</a>,
I created a combinatorial signal, <code class="language-plaintext highlighter-rouge">axil_write_ready</code>, and fed this to both
the AW and W
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>s:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">axil_write_ready</span> <span class="o">=</span> <span class="n">awskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">wskd_valid</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">);</span></code></pre></figure>

<p>When I built the
<a href="/blog/2020/03/08/easyaxil.html">EasyAxil design</a>
without <a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>s,
I did roughly the same thing–only I registered the <code class="language-plaintext highlighter-rouge">axil_write_ready</code>
signal–something we’ll do here in just a moment.</p>

<p>On the other hand, if you are familiar with
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s design</a>,
you might quickly answer that <code class="language-plaintext highlighter-rouge">axi_awready</code> is the same as <code class="language-plaintext highlighter-rouge">axi_wready</code>,
and neither would be true unless <code class="language-plaintext highlighter-rouge">S_AXI_AWVALID and S_AXI_WVALID</code> were both
already true.  Okay, so let’s go back and ask, then, why are <code class="language-plaintext highlighter-rouge">axi_awready</code>
and <code class="language-plaintext highlighter-rouge">axi_wready</code> separate signals if they’re equivalent?</p>

<p>Let me go one farther: this design won’t even set <code class="language-plaintext highlighter-rouge">axi_awready</code> unless
both <code class="language-plaintext highlighter-rouge">S_AXI_AWVALID</code> and <code class="language-plaintext highlighter-rouge">S_AXI_WVALID</code> are both true.  So … why do we need
to check for <code class="language-plaintext highlighter-rouge">S_AXI_AWVALID</code> and <code class="language-plaintext highlighter-rouge">S_AXI_WVALID</code> a second time?</p>

<p>Let’s come back to this when we clean up the write logic further down.</p>

<p>The problem is worse on the read side.  Consider the read enable signal.</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="n">slv_reg_rden</span> <span class="o">&lt;=</span> <span class="n">axi_arready</span> <span class="ow">and</span> <span class="n">S_AXI_ARVALID</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">axi_rvalid</span><span class="p">)</span> <span class="p">;</span></code></pre></figure>

<p>Now, ask yourself, what would happen if <code class="language-plaintext highlighter-rouge">axi_arready and S_AXI_ARVALID</code> but
<code class="language-plaintext highlighter-rouge">axi_rvalid</code> were also true?  In that case, the master would believe a request
had been made, but this <code class="language-plaintext highlighter-rouge">slv_reg_rden</code> signal would never go high.  This would
become a nasty bug.</p>

<p>Here you can see the same condition repeated again when setting <code class="language-plaintext highlighter-rouge">axi_arready</code>.</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="k">if</span> <span class="p">(</span><span class="n">axi_arready</span> <span class="o">=</span> <span class="sc">'1'</span> <span class="ow">and</span> <span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="sc">'1'</span> <span class="ow">and</span> <span class="n">axi_rvalid</span> <span class="o">=</span> <span class="sc">'0'</span><span class="p">)</span> <span class="k">then</span></code></pre></figure>

<p>This time, there’s a second problem: the author intended to use the same
logic as the <code class="language-plaintext highlighter-rouge">slv_reg_rden</code> signal, but wrote out the logic instead.  That
means that if you ever have to fix this logic, you’ll have to do it multiple
times.  In this case, it would be better to replace this logic with
<code class="language-plaintext highlighter-rouge">slv_reg_rden</code> and then only fix it once.</p>

<p>Let’s therefore take this as an opportunity to correct <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s demonstration
design</a>.</p>

<h2 id="fixing-the-read-side">Fixing the read side</h2>

<p>At this point, you should know the problem: in the presence of any
<a href="https://en.wikipedia.org/wiki/Back_pressure">backpressure</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s design</a>
will drop requests.  This will cause the bus to freeze, which will then
cause your design to hang.  The CPU will stop.  To make matters worse, the
debugger will also lock up.  You will be unable to get any
diagnostic information using either the system bus or the CPU.</p>

<p>This is nothing more than a recipe for <a href="/blog/2017/05/19/fpga-hell.html">FPGA
Hell</a>.</p>

<p>I’ve already pointed out the root cause of the problem above: <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">the
design</a>
never checks for <code class="language-plaintext highlighter-rouge">S_AXI_RVALID = '1' and S_AXI_RREADY = '0'</code> when adjusting
<code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code>.  As a result, it accepts requests into the design even when
it will be unable to return a response.</p>

<p>Let’s start by fixing that.</p>

<p>As it turns out, the fix is simple.  All we need to do is to adjust a <a href="https://github.com/ZipCPU/wb2axip/blob/93565afffbe00da17e5f126137daaeb482bdd520/bench/formal/xlnxdemo_2020_2.vhd#L328">single
line</a>.
Instead of,</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="k">if</span> <span class="p">(</span><span class="n">axi_arready</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="ow">and</span> <span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
		<span class="c1">-- indicates that the slave has acceped the valid read address</span>
	<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="sc">'1'</span><span class="p">;</span></code></pre></figure>

<p>we’ll replace it with,</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="k">if</span> <span class="p">(</span><span class="n">axi_arready</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="ow">and</span> <span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="sc">'1'</span>
		<span class="ow">and</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="ow">or</span> <span class="n">S_AXI_RREADY</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">))</span> <span class="k">then</span>
	<span class="c1">-- indicates that the slave has acceped the valid read address</span>
	<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="sc">'1'</span><span class="p">;</span></code></pre></figure>

<p>Voila!  This design will now pass a formal verification check.</p>

<p>No, it’s not a great design.  At best, this design will only ever get 50%
throughput.</p>

<table align="center" style="float: none"><caption>Fig 3. Without a skidbuffer, this design can only get 50% throughput</caption><tr><td><a href="/img/vhdlaxil/read-throughput.png"><img src="/img/vhdlaxil/read-throughput.png" alt="" width="780" /></a></td></tr></table>

<p>While not great, at least it will now pass a formal property check.  That
also means that it won’t hang your design anymore, and you’ll be back to being
able to use the CPU debugger to debug your software.</p>

<p>If we wanted to go further, we could do one better by dropping the read
latency by one clock cycle.  We can do this by holding <code class="language-plaintext highlighter-rouge">axi_arready</code>
high until a request becomes available.  One small change to <code class="language-plaintext highlighter-rouge">axi_arready</code>
and we’re there.</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="k">if</span> <span class="p">((</span><span class="n">axi_arready</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="ow">or</span> <span class="n">S_AXI_ARVALID</span> <span class="o">=</span> <span class="sc">'0'</span><span class="p">)</span>
		<span class="ow">and</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="ow">or</span> <span class="n">S_AXI_RREADY</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">))</span> <span class="k">then</span>
	<span class="c1">-- indicates that the slave has acceped the valid read address</span>
	<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="sc">'1'</span><span class="p">;</span>
<span class="k">else</span>
	<span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="sc">'0'</span><span class="p">;</span></code></pre></figure>

<p>While we are at it, we should also adjust the <code class="language-plaintext highlighter-rouge">slv_reg_rden</code> logic.  The
<a href="https://github.com/ZipCPU/wb2axip/blob/93565afffbe00da17e5f126137daaeb482bdd520/bench/formal/xlnxdemo_2020_2.vhd#L370">original logic</a>.
just didn’t make any sense:</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="n">slv_reg_rden</span> <span class="o">&lt;=</span> <span class="n">axi_arready</span> <span class="ow">and</span> <span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="n">axi_rvalid</span><span class="p">);</span></code></pre></figure>

<p>As I mentioned above, what happens when
<code class="language-plaintext highlighter-rouge">axi_arready and S_AXI_ARVALID and axi_rvalid</code>?  With the new <code class="language-plaintext highlighter-rouge">axi_arready</code>
logic above, however, we’ve guaranteed that <code class="language-plaintext highlighter-rouge">axi_arready</code> will only be set if
<code class="language-plaintext highlighter-rouge">axi_rvalid</code> is also low.  Therefore, we can replace this logic with,</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="n">slv_reg_rden</span> <span class="o">&lt;=</span> <span class="n">axi_arready</span> <span class="ow">and</span> <span class="n">S_AXI_ARVALID</span><span class="p">;</span></code></pre></figure>

<p>For completeness, we should also remove any further references to
<code class="language-plaintext highlighter-rouge">S_AXI_ARVALID and axi_arready</code> and simply replace them with <code class="language-plaintext highlighter-rouge">slv_reg_rden</code>.</p>

<p>You can see the performance of this updated design in Fig. 4 below.</p>

<table align="center" style="float: none"><caption>Fig 4. The AXI spec recommends leaving xREADY high if possible</caption><tr><td><a href="/img/vhdlaxil/read-latency.png"><img src="/img/vhdlaxil/read-latency.png" alt="" width="780" /></a></td></tr></table>

<p>The astute reader might also notice that this new and updated <code class="language-plaintext highlighter-rouge">axi_arready</code>
signal looks an awful lot like <code class="language-plaintext highlighter-rouge">not axi_rvalid</code>.  A quick formal check confirms
that, with the exception of the reset value for <code class="language-plaintext highlighter-rouge">axi_arready</code>, this is indeed
the case.  I’ll leave that change to the student.</p>

<p>Rather than simplifying the read logic any further, however, let’s instead move
on to the write logic.</p>

<h2 id="cleaning-up-the-write-logic">Cleaning up the write logic</h2>

<table align="center" style="float: right"><caption>Fig 5. What do to with a working design?</caption><tr><td><img src="/img/tweets/if-it-works.svg" alt="" width="320" /></td></tr></table>

<p>One of the challenges I have when looking at a design like this is not
making edits throughout the design.  Sure, the one change above will “fix”
the protocol violations, but we could do much better with the write path as
well.</p>

<p>The design works, though, why would we want to change it?  Other than for
the simple fact that I’m an engineer and that’s what I do, I can think of
several reasons why we might want to clean this up a little bit.</p>

<p>First, the write logic as provided only gets 33% throughput.</p>

<table align="center" style="float: none"><caption>Fig 6. Write throughput is limited at 33%</caption><tr><td><a href="/img/vhdlaxil/write-throughput-before.png"><img src="/img/vhdlaxil/write-throughput-before.png" alt="" width="780" /></a></td></tr></table>

<p>That’s pitiful.</p>

<p>Back when <a href="/formal/2018/12/28/axilite.html">I first ran the formal
tools</a> on <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s demo
design</a>,
the write channel got 50% throughput–even though it was broken.  Since then,
Xilinx has fixed the protocol violations in the write channel.  The only
problem is, when fixing it, they dropped that 50% throughput number down to 33%.</p>

<p>In the process, they also added an <code class="language-plaintext highlighter-rouge">aw_en</code> register.  Indeed, the existence of
this register will tell you if the write channel is from their “fixed” version
or not.  Looking at Fig. 6 above, you can see that the design uses a minimum
of one clock cycle to acknowledge a write request, one clock cycle to return a
response, and then a third clock cycle to set <code class="language-plaintext highlighter-rouge">aw_en</code>.  If we, instead, only
acknowledged a response when <code class="language-plaintext highlighter-rouge">S_AXI_BVALID = '0'</code>, then we wouldn’t need
<code class="language-plaintext highlighter-rouge">aw_en</code>–we could use <code class="language-plaintext highlighter-rouge">axi_awready</code>–but I’ll get to that in a moment.</p>

<p>Third, did you notice that <code class="language-plaintext highlighter-rouge">axi_awready</code> and <code class="language-plaintext highlighter-rouge">axi_wready</code> used the same
identical logic?  Sure, it works, but why would you have two registers to do
the same thing?  Why not just use one?  Indeed, if we just set <code class="language-plaintext highlighter-rouge">S_AXI_WREADY</code>
to <code class="language-plaintext highlighter-rouge">axi_awready</code> we’d get the same performance for less logic.</p>

<p>Finally, did you notice that <code class="language-plaintext highlighter-rouge">S_AXI_BRESP</code> is the constant <code class="language-plaintext highlighter-rouge">"00"</code>?  Constant
expressions should be combinatorial expressions–not registered ones.</p>

<p>Let’s make a couple of quick changes to the write logic therefore.</p>

<ol>
  <li>
    <p>As a first step, let’s remove the <code class="language-plaintext highlighter-rouge">axi_wready</code>, <code class="language-plaintext highlighter-rouge">axi_bresp</code> and <code class="language-plaintext highlighter-rouge">aw_en</code>
signal declarations.  You can also remove <code class="language-plaintext highlighter-rouge">axi_rresp</code> while you are at it,
since that signal has the same problem <code class="language-plaintext highlighter-rouge">axi_bresp</code> has.</p>
  </li>
  <li>
    <p>We can then set <code class="language-plaintext highlighter-rouge">S_AXI_WREADY</code> to <code class="language-plaintext highlighter-rouge">axi_awready</code>, and both <code class="language-plaintext highlighter-rouge">S_AXI_BRESP</code>
and <code class="language-plaintext highlighter-rouge">S_AXI_RRESP</code> to <code class="language-plaintext highlighter-rouge">"00"</code>.</p>
  </li>
  <li>
    <p>Now that we’ve dropped the <code class="language-plaintext highlighter-rouge">axi_wready</code> definition, we’ll also need to
remove the <a href="https://github.com/ZipCPU/wb2axip/blob/93565afffbe00da17e5f126137daaeb482bdd520/bench/formal/xlnxdemo_2020_2.vhd#L202-L224">process defining it</a>.
Remember, that process was producing a signal that was identical to
<code class="language-plaintext highlighter-rouge">axi_awready</code> anyway–so there’s no reason to use both.</p>

    <p>That’ll get us started.</p>
  </li>
  <li>
    <p>We’ll then want to update the <code class="language-plaintext highlighter-rouge">axi_awready</code> logic to remove the <code class="language-plaintext highlighter-rouge">aw_en</code>
logic, while still checking for any backpressure.</p>

    <p>That means we can change the first <code class="language-plaintext highlighter-rouge">if</code> condition in the logic block below
to one that doesn’t use <code class="language-plaintext highlighter-rouge">aw_en</code>, but also won’t be broken.  Incidentally,
we’ll also want to clear <code class="language-plaintext highlighter-rouge">axi_awready</code> in all other cases.  That means <a href="https://github.com/ZipCPU/wb2axip/blob/93565afffbe00da17e5f126137daaeb482bdd520/bench/formal/xlnxdemo_2020_2.vhd#L167-L178">this
original logic</a>,</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl">      <span class="k">if</span> <span class="p">(</span><span class="n">axi_awready</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="ow">and</span> <span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="sc">'1'</span> <span class="ow">and</span> <span class="n">S_AXI_WVALID</span> <span class="o">=</span> <span class="sc">'1'</span> <span class="ow">and</span> <span class="n">aw_en</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
        <span class="c1">-- slave is ready to accept write address when</span>
        <span class="c1">-- there is a valid write address and write data</span>
        <span class="c1">-- on the write address and data bus. This design </span>
        <span class="c1">-- expects no outstanding transactions. </span>
           <span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="sc">'1'</span><span class="p">;</span>
           <span class="n">aw_en</span> <span class="o">&lt;=</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="k">elsif</span> <span class="p">(</span><span class="n">S_AXI_BREADY</span> <span class="o">=</span> <span class="sc">'1'</span> <span class="ow">and</span> <span class="n">axi_bvalid</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
           <span class="n">aw_en</span> <span class="o">&lt;=</span> <span class="sc">'1'</span><span class="p">;</span>
           <span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="sc">'0'</span><span class="p">;</span>
      <span class="k">else</span>
        <span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="sc">'0'</span><span class="p">;</span></code></pre></figure>

<p>can be simplified into the following:</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="k">process</span> <span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">begin</span>
  <span class="k">if</span> <span class="n">rising_edge</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">)</span> <span class="k">then</span> 
    <span class="k">if</span> <span class="n">S_AXI_ARESETN</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="k">then</span>
      <span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="sc">'0'</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">axi_awready</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="ow">and</span> <span class="n">S_AXI_AWVALID</span> <span class="o">=</span> <span class="sc">'1'</span> <span class="ow">and</span> <span class="n">S_AXI_WVALID</span> <span class="o">=</span> <span class="sc">'1'</span>
		<span class="ow">and</span> <span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="ow">or</span> <span class="n">S_AXI_BREADY</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">))</span> <span class="k">then</span>
        <span class="c1">-- slave is ready to accept write address when</span>
        <span class="c1">-- there is a valid write address and write data</span>
        <span class="c1">-- on the write address and data bus. This design </span>
        <span class="c1">-- expects no outstanding transactions. </span>
           <span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="sc">'1'</span><span class="p">;</span>
      <span class="k">else</span>
        <span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="sc">'0'</span><span class="p">;</span>
      <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
    <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
  <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
<span class="k">end</span> <span class="k">process</span><span class="p">;</span></code></pre></figure>

<p>where now I’ve shown the whole process.</p>

<p>Unfortunately, we can’t remove the clock cycle of latency from the write
channel like we did with the read logic, since we’d then need to register
either the write address or write data if one came early.  Sure, that’s a
valid design approach, but I’m trying to make as few changes to
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s template</a>
as possible.  If you’d rather go all out to build a better design from scratch,
then go for the <a href="/blog/2020/03/08/easyaxil.html">EasyAxil</a>
design.  That one will get you much better performance.</p>

<ol start="5">
  <li>Our next simplification will be to change the write enable signal,
<code class="language-plaintext highlighter-rouge">slv_reg_wren</code>,</li>
</ol>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="n">slv_reg_wren</span> <span class="o">&lt;=</span> <span class="n">axi_wready</span> <span class="ow">and</span> <span class="n">S_AXI_WVALID</span> <span class="ow">and</span> <span class="n">axi_awready</span> <span class="ow">and</span> <span class="n">S_AXI_AWVALID</span> <span class="p">;</span></code></pre></figure>

<p>to the much simpler <code class="language-plaintext highlighter-rouge">axi_awready</code> signal.</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="n">slv_reg_wren</span> <span class="o">&lt;=</span> <span class="n">axi_awready</span><span class="p">;</span></code></pre></figure>

<p>This, of course, doesn’t change how the design performs at all–it just
simplifies the logic required to get it to perform in the first place.</p>

<p>But, shouldn’t we be checking here that
<code class="language-plaintext highlighter-rouge">AWVALID &amp;&amp; AWREADY &amp;&amp; WVALID &amp;&amp; WREADY</code>?</p>

<p>In this case, it’s not required–we already did that when setting <code class="language-plaintext highlighter-rouge">axi_awready</code>.
If you aren’t convinced, then add an assertion to the wrapper:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="n">axi_awready</span><span class="p">)</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">S_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_AWREADY</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WREADY</span><span class="p">);</span></code></pre></figure>

<p>You might notice that this <code class="language-plaintext highlighter-rouge">slv_reg_wren</code> signal is different from its read
equivalent.  For the read equivalent, we only set <code class="language-plaintext highlighter-rouge">slv_reg_rden</code> high if
<code class="language-plaintext highlighter-rouge">S_AXI_ARVALID and axi_arready</code> were both true.  Here, we are only checking
<code class="language-plaintext highlighter-rouge">axi_awready</code>.  The difference is because <code class="language-plaintext highlighter-rouge">axi_arready</code> remains asserted
even when the design is idle, and so <code class="language-plaintext highlighter-rouge">slv_reg_rden</code> requires that we check
<code class="language-plaintext highlighter-rouge">S_AXI_ARVALID</code> as well whereas <code class="language-plaintext highlighter-rouge">slv_reg_wren</code> does not.</p>

<h2 id="conclusion">Conclusion</h2>

<p>As I mentioned above, the resulting design isn’t that great.  At best, it can
only ever achieve a 50% throughput.  AXI-lite is a much more capable bus than
that.  Indeed, we should be able to get 100% throughput from an AXI-lite slave,
<a href="/blog/2020/03/08/easyaxil.html">just like this design does</a>.
Doing so, however, requires a
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>, and adding a
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a> would remove
any remaining semblance of this being a Xilinx design in the first place.</p>

<p>There’s also a much more fundamental lesson to be learned here: just because
a design comes from a vendor doesn’t mean it works.  I’ve come across a lot
of individuals on Xilinx’s forums who want to use Xilinx’s demonstration design
if for no other reason than because it came from Xilinx.</p>

<p>Logically, this is called a “faulty appeal to authority.”  The logic goes,
1) Bill is an authority, 2) Bill said <em>X</em>, therefore  3) <em>X</em> must be true.  In
this case, 1) Xilinx is an FPGA vendor, 2) that makes them an authority,
3) Xilinx provided <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">this demonstration AXI-lite
design</a>,
therefore 4) the demonstration design must work.</p>

<p>Unfortunately this logic is quite fallacious.  Not only is <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo_2020_2.vhd">Xilinx’s
demonstration design</a>
faulty, but I’ve also been tracking flaws in two other demonstration designs,
as well as in Xilinx’s <a href="/blog/2020/01/01/2019-in-review.html">AXI Ethernet-Lite
IP</a>, and now
even in their AXI QuadSPI IP.</p>

<p>The obvious conclusion should be that you should think for yourself.  Verify
your own designs.  Don’t trust an authority simply because he or she is an
authority.</p>

<p>This reality applies to much more than just digital logic designs.  It applies
to the “science” regarding the Coronavirus–the same science that has been
changing on a day to day basis over the last year.  It applies to climate
change.  Indeed, I still remember when the climate scientists were warning of
an impending ice age.  It applies to the COVID “vaccine”, which you can choose
to have injected into your bloodstream or not.  It also applies to your
relationship to the Almighty.  In that final judgment day, you will stand
before the Almighty.  It won’t be your spouse, your boss, or your pastor,
and it certainly won’t be your church.  You will stand there alone.</p>

<p>Think about that, then live accordingly.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Though I speak with the tongues of men and of angels, and have not charity, I am become as sounding brass, or a tinkling cymbal. (1 Cor 13:1)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
