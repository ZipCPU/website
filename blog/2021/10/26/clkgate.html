<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Clock Gating</title>
  <meta name="description" content="Most libraries contain aclock gatingcircuit within them.  These tend to bedesigned by an analog hardware designer, rather than the digital designer,for the s...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2021/10/26/clkgate.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Clock Gating</h1>
    <p class="post-meta"><time datetime="2021-10-26T00:00:00-04:00" itemprop="datePublished">Oct 26, 2021</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Most libraries contain a
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
circuit within them.  These tend to be
designed by an analog hardware designer, rather than the digital designer,
for the simple reason that getting the layout right can be critical.  Such
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
circuits are often used as a means of power savings.</p>

<p>The circuit itself tends to be fairly simple.  It consists of a clock input,
an enable input, a latch, an AND gate, and the resulting output clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">clkgate</span><span class="p">(</span> <span class="kt">input</span> <span class="kt">wire</span> <span class="n">i_clk</span><span class="p">,</span> <span class="n">i_en</span><span class="p">,</span>
		<span class="kt">output</span> <span class="kt">wire</span> <span class="n">o_clk</span><span class="p">);</span>

	<span class="kt">reg</span>	<span class="n">latch</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_clk</span><span class="p">)</span>
		<span class="n">latch</span> <span class="o">=</span> <span class="n">i_en</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">o_clk</span> <span class="o">=</span> <span class="p">(</span><span class="n">latch</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_clk</span><span class="p">);</span></code></pre></figure>

<p>Indeed, the circuit is simple enough that I like to <a href="/tutorial/formal.html">assign it to students
as an exercise in formal verification</a>.</p>

<p>It’s important this be done right for several reasons.  First, clock glitches
are bad.  They can cause some of your circuit to experience a clock, while
other parts do not, while even other parts of the circuit are left in an
indeterminate state.  Therefore, it’s important to make certain the output
clock won’t glitch when the enable line changes–whenever it changes.
Second, it’s important that the resulting clock can be used in the same
clock domain as the original clock.</p>

<p><a href="https://en.wikipedia.org/wiki/Clock_gating">Clock gating</a> can be a very
important part of <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> 
design for power reasons.
First, it takes energy to toggle a wire–any wire–within a design.  The more
often you toggle it, the more power your design then uses.  Hence, if you
want to lower the power required by a design, then it becomes important to
keep as much of the logic within the design from toggling as possible.
Second, the greater the capacitance of the wire, the greater the energy that’s
required to toggle it.  This is especially true of a
<a href="https://en.wikipedia.org/wiki/Clock_signal#Distribution">clock tree</a>, where
the clock signal may need to travel through a chip-sized
<a href="https://en.wikipedia.org/wiki/Clock_signal#Distribution">clock tree</a> to get to
a large majority of the flip flops within the chip.  If, at any point in that
<a href="https://en.wikipedia.org/wiki/Clock_signal#Distribution">tree</a>,
the clock can be stopped then both the clock and everything depending
upon it can be kept from consuming any further dynamic power.</p>

<p>This makes clock gating an important topic.</p>

<p>FPGAs tend to be both unique and somewhat disadvantaged in this discussion.
Like <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>s,
FPGA libraries also include
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gates</a>.  On Xilinx Series 7
devices, for example, these are <code class="language-plaintext highlighter-rouge">BUFGCE</code> library elements that can be used to
<a href="https://en.wikipedia.org/wiki/Clock_gating">gate clocks</a>.
That’s not the what makes FPGAs unique.  The difference with FPGAs is that,
unlike <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>s, FPGAs come
with pre-configured <a href="https://en.wikipedia.org/wiki/Clock_signal#Distribution">clock
trees</a> that tend to
be global (chip-wide) in scale and scope.  This fixes their capacitance,
forcing clocks to require a significant amount of energy to toggle in order to
reach the entire <a href="https://en.wikipedia.org/wiki/Clock_signal#Distribution">clock
tree</a>.
That also means that, in order to gate a clock, you’ll need to create a second
clock from the first one–one that can be gated, and you’ll then need
to place it into a global clock buffer as well.  This second clock will only
add to your power usage–unlike an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> where the
<a href="https://en.wikipedia.org/wiki/Clock_signal#Distribution">clock tree</a> might be
trimmed down so that it is only as big as it needs to be.  In other words,
there’s nothing to be gained by <a href="https://en.wikipedia.org/wiki/Clock_gating">gating a
clock</a> within an FPGA other than
perhaps testing and verifying an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> system that might
require <a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>.
Low power in an FPGA system is often achieved therefore, not by a
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gate</a>,
but rather by a logic signal that can be issued to all flip-flops within a
given design region.  We might call this a “Clock Enable”, or <code class="language-plaintext highlighter-rouge">i_ce</code> as I tend
to call it.  When <code class="language-plaintext highlighter-rouge">i_ce</code> is low, nothing transitions and energy is minimized.</p>

<p>This FPGA clock enable power reduction mechanism lends to flip-flop structures
that look like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">Q</span> <span class="o">&lt;=</span> <span class="n">D</span><span class="p">;</span></code></pre></figure>

<p>As long as <code class="language-plaintext highlighter-rouge">i_ce</code> stays low, the flip-flop uses a minimum amount of power.</p>

<p>Today, though, I’d like to share some of my experiences with using a
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
circuit in simulations–independent of the ultimate hardware the design
would drive.</p>

<h2 id="clock-gating-in-simulation">Clock Gating in Simulation</h2>

<p>When I first tried
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
in simulation, my purpose was just to learn about
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>.
Is it easy or hard?  Eventually, I’d like to be able
to add a <a href="https://github.com/ZipCPU/zipcpu/blob/ddc09c805fe43122b78df079747c66fa8a14e255/rtl/core/zipcore.v#L2124-L2165">clock gating capability to the
ZipCPU</a>,
so that the <a href="/about/zipcpu.html">ZipCPU</a>
could be used in an application requiring low power.</p>

<p>I also started this task with a hypothesis:</p>

<p><strong>Hypothesis:</strong> Simulation time is proportional to the amount of signals that
have to be evaluated each cycle.</p>

<p>For this reason, if the number of signals needing to be evaluated can be
greatly reduced due to the presence of a
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gate</a>,
then it only makes sense that gating any unused clocks within a simulation
will only speed up the simulation.  At least, this was my hypothesis starting
out.</p>

<h3 id="gating-the-zipcpus-clock">Gating the ZipCPU’s clock</h3>

<p>I decided to build my <a href="https://github.com/ZipCPU/zipcpu/blob/ddc09c805fe43122b78df079747c66fa8a14e255/rtl/core/zipcore.v#L2124-L2165">initial attempts at stopping the
clock</a>
around the <a href="/about/zipcpu.html">ZipCPU</a>’s sleep
functionality.  Basically, the <a href="/about/zipcpu.html">ZipCPU</a>
has a <a href="/zipcpu/2018/01/01/zipcpu-isa.html"><code class="language-plaintext highlighter-rouge">WAIT</code> instruction</a>
that puts the <a href="/about/zipcpu.html">ZipCPU</a> to sleep until the
next <a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>.  This
seemed like the perfect time to stop the
<a href="/about/zipcpu.html">ZipCPU</a>’s clock.  Indeed, the
<a href="/zipcpu/2018/01/01/zipcpu-isa.html"><code class="language-plaintext highlighter-rouge">WAIT</code> instruction</a>
was integrated into the <a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">instruction set</a>
for just this purpose.</p>

<p>Then, after thinking about it some more, I started wondering about what the
<a href="/about/zipcpu.html">ZipCPU</a> should do if the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugging interface</a>
halted the CPU externally?  Certainly, if the CPU isn’t enabled, it should
stop it’s clock as well, no?</p>

<p>So I built some <a href="https://github.com/ZipCPU/zipcpu/blob/ddc09c805fe43122b78df079747c66fa8a14e255/rtl/core/zipcore.v#L2124-L2165">clock gating
logic</a>
into the <a href="/about/zipcpu.html">ZipCPU</a> to see what might
happen.  Once the <a href="/about/zipcpu.html">ZipCPU</a>
passed it’s formal checks again, I placed it into a large integrated
simulation to test it.</p>

<p>Can anyone guess what happened?</p>

<p>Nothing.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> never came out of reset.</p>

<p>The problem is that the <a href="/about/zipcpu.html">ZipCPU</a>
required a clock to acknowledge the reset, and I was starting the design with
the clock off.</p>

<p>Oops.</p>

<p>First lesson learned: be very careful how you handle clock enables and
the reset signal.</p>

<p>The second problem was similarly ugly: if the clock is off, and the clock
gate control logic is controlled by the clock that is off, then you’ll never
be able to wake up.</p>

<p>So, after a lot of work, here’s the logic I came up with:  It’s split into
two parts.  Part one is the combinatorial part.  This is used to tell us
when to wake up.  Well, that’s not quite true.  <a href="/blog/2017/09/18/clocks-for-sw-engineers.html">Very few things in any
digital design are truly <em>combinatorial</em></a>.
Perhaps a better way to say it is
that part one consists of logic that will be clocked with the always–on clock,
and used to turn the gated clock on and off.  Part two is the registered part,
registered on the gated clock that is.  This is the part I use to help tame
the combinatorial logic portion.</p>

<p>Let’s start with the combinatorial part.  This part sets an output from the CPU,
<code class="language-plaintext highlighter-rouge">o_clken</code>, which is then used to control the clock gate circuit externally.
It’s primarily based upon the registered value, <code class="language-plaintext highlighter-rouge">r_clken</code>, but with a few
exceptions.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_clken</span> <span class="o">=</span> <span class="n">r_clken</span> <span class="o">||</span> <span class="n">i_dbg_we</span> <span class="o">||</span> <span class="n">i_clear_cache</span>
			<span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">i_halt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i_interrupt</span> <span class="o">||</span> <span class="o">!</span><span class="n">sleep</span><span class="p">));</span></code></pre></figure>

<p>Basically, we want to wake up on an
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>
and we want to make sure the clock stays running unless we are asleep.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_clken</span> <span class="o">=</span> <span class="cm">/* ... */</span> <span class="o">||</span> <span class="p">(</span><span class="n">i_interrupt</span> <span class="o">||</span> <span class="o">!</span><span class="n">sleep</span><span class="p">);</span></code></pre></figure>

<p>Well, there’s an exception to that rule.  If the CPU is commanded to halt
from the debugging interface, then it doesn’t matter if an
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a> is pending
or if the CPU wants to be awake: the debug interface should always be able to
put the CPU into a deep sleep–that’s the purpose of the <code class="language-plaintext highlighter-rouge">i_halt</code> signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_clken</span> <span class="o">=</span> <span class="cm">/* ... */</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">i_halt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i_interrupt</span> <span class="o">||</span> <span class="o">!</span><span class="n">sleep</span><span class="p">));</span></code></pre></figure>

<p>What about a <a href="/zipcpu/2017/08/25/hw-debugging.html">debugging
command</a>, such as
writing to a register via the debugging interface, done here by setting
<code class="language-plaintext highlighter-rouge">i_dbg_we</code>, or informing the CPU (while it is halted) that external memory
may have changed so the CPU can know to clear its cache?  That’s the purpose
of the <code class="language-plaintext highlighter-rouge">i_clear_cache</code> signal.  In both cases, the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugger</a>
needs to be able to be able to interact with the design while it’s
asleep.  For this we’ll need two additional exceptions.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_clken</span> <span class="o">=</span> <span class="n">r_clken</span> <span class="o">||</span> <span class="n">i_dbg_we</span> <span class="o">||</span> <span class="n">i_clear_cache</span> <span class="cm">/* ... */</span><span class="p">;</span></code></pre></figure>

<p>Everything else can be stuffed into the registered signal, <code class="language-plaintext highlighter-rouge">r_clken</code>–part two
of our enable logic.</p>

<p>Let’s take a look at that register, shall we?</p>

<p>The tricky part with this register is the reset.  On a reset, the CPU should
only disable the clock if the <code class="language-plaintext highlighter-rouge">i_halt</code> input is requesting that we stop.
This would be the case where the CPU is configured to start up into a halted
configuration, or equivalently if the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugger</a>
has control of the processor and issues it a reset.  In this case, a CPU
reset isn’t the same as a
<a href="/blog/2020/03/14/axi-reset.html">bus reset</a>.
In order to keep from freezing up external buses when rebooting the CPU from
an external input in this fashion, it’s important we keep the clock enabled
until all bus operations are finished.  (Remember, <a href="/blog/2020/03/14/axi-reset.html">resetting an AXI bus
component typically requires resetting the entire
bus</a> and everything
connected to it.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span> <span class="o">||</span> <span class="p">(</span><span class="n">i_halt</span> <span class="o">&amp;&amp;</span> <span class="n">r_halted</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_dbg_we</span><span class="p">))</span>
		<span class="n">r_clken</span> <span class="o">&lt;=</span> <span class="n">i_mem_busy</span> <span class="o">||</span> <span class="o">!</span><span class="n">i_halt</span><span class="p">;</span></code></pre></figure>

<p>The second criteria here has to deal with the <a href="/zipcpu/2017/08/25/hw-debugging.html">debugging
interface</a>.  Basically,
if the <a href="/zipcpu/2017/08/25/hw-debugging.html">debugging
interface</a>
raises the <code class="language-plaintext highlighter-rouge">i_halt</code> signal, then the CPU is supposed to come to a halt.  Indeed,
the CPU will halt once it both finishes its current operation and once the
pipeline is filled again.  However, that leads to a lot of times when we can
and cannot halt.  For example, the CPU can’t halt in the middle of an
<a href="/zipcpu/2021/09/30/axiops.html">atomic operation</a> that might
lock the bus, lest the rest of the design lock up.  Similarly, the
<a href="/about/zipcpu.html">ZipCPU</a> can’t halt in the middle of a
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">two part compressed
instruction</a>,
nor can it halt while a divide,
<a href="/zipcpu/2021/07/03/slowmpy.html">multiply</a>,
or <a href="/zipcpu/2021/04/17/axilops.html">memory operation</a>
is pending.  That’s why the
<a href="/about/zipcpu.html">ZipCPU</a>
has an <code class="language-plaintext highlighter-rouge">r_halted</code> signal–to help tame all these conditions to something that
can be registered.  Therefore, if the CPU is halted, and the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debug interface</a>
wants it to stay halted, then we halt and ignore any other criteria.  The
exception to this rule is if we want to read from a register using the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugging interface</a>.
In that case, we’ll need to wake up for a few clocks to read the register.</p>

<p>That’s the first set of criteria, shown above.</p>

<p>The next step controls when we should wake up.  In general, we’ll want to
be awake if we aren’t sleeping.  We also want to wake up on an incoming
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>.  The exception
to this rule is that we don’t care about whether or not the CPU is sleeping or
an <a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a> is pending
if we’ve been commanded to halt–just like the combinatorial logic driving
<code class="language-plaintext highlighter-rouge">o_clken</code> above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_halt</span><span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">sleep</span> <span class="o">||</span> <span class="n">i_interrupt</span> <span class="o">||</span> <span class="n">pending_interrupt</span><span class="p">))</span>
		<span class="n">r_clken</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Here, again, the
<a href="/about/zipcpu.html">ZipCPU</a> logic attempts to tame
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>
handling with two signals: a combinatorial
input, <code class="language-plaintext highlighter-rouge">i_interrupt</code>, and a registered signal, <code class="language-plaintext highlighter-rouge">pending_interrupt</code>, to deal
with cases where we couldn’t immediately respond to an
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a> yet still
need to.</p>

<p>In all other cases, we’ll want to halt.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">begin</span>
		<span class="n">r_clken</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Well, not quite.  There are some exceptions to that rule.  (This seems to be
the story of a CPU in general–simple logic turns into a lot of exceptions.)
For example, if we’ve locked the bus or if we are in the middle of an
<a href="/zipcpu/2021/09/30/axiops.html">exclusive access operation</a>,
then we don’t want to shut the clock off.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">o_bus_lock</span><span class="p">)</span>
			<span class="n">r_clken</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Similarly, if we are in the middle of a two-part instruction, then we want
to complete the instruction before halting as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">alu_phase</span><span class="p">)</span>
			<span class="n">r_clken</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p><a href="/zipcpu/2018/01/01/zipcpu-isa.html">As you may recall</a>, the
<a href="/about/zipcpu.html">ZipCPU</a>
has a set of compressed instructions.  These instructions will pack two
16-bit instructions into a single 32-bit word.  While this in itself isn’t
all that unique among CPU’s, the
<a href="/about/zipcpu.html">ZipCPU</a>’s implementation is a bit
unusual.  Specifically, the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
will only ever issue 32-bit instructions at a time, leaving the
CPU with no (current) capability to restart one of these instructions in the
middle.  For this reason, the <a href="/about/zipcpu.html">ZipCPU</a>
cannot halt in the middle of a pair of 16-bit instructions.  In this case,
<code class="language-plaintext highlighter-rouge">alu_phase</code> will be true following the first instruction in any
instruction pair.
By only gating the clock if <code class="language-plaintext highlighter-rouge">alu_phase</code> is false, we help to guarantee that
these instruction pairs will always proceed to completion.</p>

<p>Our next condition is that, if the CPU is still busy with some operation–any
operation, then we’ll want to keep the clock on until we’ve finished it.
This includes <a href="/zipcpu/2021/04/17/axilops.html">memory</a>,
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
divide, the (not-yet-implemented) floating point
unit, writing a value to the register file, etc.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="n">i_mem_busy</span> <span class="o">||</span> <span class="n">alu_busy</span> <span class="o">||</span> <span class="n">div_busy</span> <span class="o">||</span> <span class="n">fpu_busy</span>
					<span class="o">||</span> <span class="n">wr_reg_ce</span> <span class="o">||</span> <span class="n">i_dbg_we</span>
					<span class="o">||</span> <span class="n">i_bus_err</span><span class="p">)</span>
				<span class="n">r_clken</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i_halt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r_halted</span><span class="p">)</span>
				<span class="n">r_clken</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">end</span></code></pre></figure>

<p>But, in general, that’s the logic required to halt the
<a href="/about/zipcpu.html">ZipCPU</a>’s clock.
The actual clock halting logic, however, is <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/zipaxi.v">external to the
CPU</a>–so that
it can be tailored to the environment containing the CPU.  Currently, the <a href="https://en.wikipedia.org/wiki/Clock_gating">clock
gating</a> logic is only implemented
in the <a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/zipaxi.v">AXI wrapper</a>–but
that may change in time if
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
proves to be valuable or useful.</p>

<h3 id="gating-an-axi-dma">Gating an AXI DMA</h3>

<p>What about an AXI component?  For example, I’ve built an
<a href="/blog/2020/06/16/axiaddr-limits.html">AXI DMA</a> and it only
gets fired up every now and then.  Can we gate it’s clock?</p>

<p>Sure, why not?</p>

<p>The big difference between the approach I used for my
<a href="/blog/2020/06/16/axiaddr-limits.html">AXI DMA</a> and the
approach I used for the
<a href="/about/zipcpu.html">ZipCPU</a>
above is that I placed the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">DMA</a>’s
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gate</a> within the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">DMA logic</a> itself
rather than in an encapsulating wrapper.  This gave me access to both the
gated clock, the original/raw AXI clock, and the current clock gating signal.
This turned out to be quite useful, since I could then keep the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffers</a> on the
AXI clock, and the rest of the logic on the gated clock–but more on that in
a moment.  The unfortunate part of this choice is that it also means that this
gating circuit isn’t (currently) portable across devices–but today’s focus
is really on simulation only, since I’m really still experimenting
with the whole concept in the first place.</p>

<p>Gating the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">DMA</a>’s
clock internally had the nice benefit that I could use flip-flops to latch all
of the critical <a href="https://en.wikipedia.org/wiki/Clock_gating">clock
gating</a> signals within the
design.  Further, as mentioned above, I could also run the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffers</a>
on the raw AXI clock, and only read them using the gated AXI clock.  That
meant that the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">DMA</a>
didn’t have to wake up from any kind of sleep until
the clock after an incoming bus request.</p>

<p>Speaking of latches, the second big difference in this design had to deal
with the logic for the clock gate itself.  Instead of a latch, I used a
negative edge flip-flop–as I’ll share in a moment.  The approach isn’t text
book, so I’m not convinced if I like it or not, but it’s pretty simple to build
and it passes a formal test nicely.</p>

<p>This new/updated clock gating circuit comes in two halves.
The first half sets a register that we’ll use to control the clock gate.
As before, we’ll use a registered signal, <code class="language-plaintext highlighter-rouge">clk_active</code>, to handle most of
our control logic–with the exception that we want to turn the clock on given
any <a href="/blog/2020/03/08/easyaxil.html">AXI-lite control request on our slave
port</a>.</p>

<p>The first half takes place on the positive edge of the clock.  In this
case, we will turn the clock on in response to either an incoming bus request
or, alternatively, if a registered <code class="language-plaintext highlighter-rouge">clk_active</code> signal is high.  We’ll 
come back to <code class="language-plaintext highlighter-rouge">clk_active</code> in a moment.</p>

<p>Here’s the portion of the gating circuit that takes place on the positive
edge of the clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="kt">reg</span>	<span class="n">gatep</span><span class="p">,</span> <span class="n">gaten</span><span class="p">,</span> <span class="n">clk_active</span><span class="p">,</span> <span class="n">r_gate</span><span class="p">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">gatep</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">gatep</span> <span class="o">&lt;=</span> <span class="n">clk_active</span> <span class="o">||</span> <span class="n">awskd_valid</span>
				<span class="o">||</span> <span class="n">wskd_valid</span> <span class="o">||</span> <span class="n">arskd_valid</span><span class="p">;</span></code></pre></figure>

<p>The second half of this circuit moves this <code class="language-plaintext highlighter-rouge">gatep</code> value to the negative
edge of the clock.  Note that there’s no additional logic on this path, save
for a simple reset check.  That’s important since this logic must take place
in a half clock period, rather than a whole clock period.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">negedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">gaten</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">gaten</span> <span class="o">&lt;=</span> <span class="n">gatep</span><span class="p">;</span></code></pre></figure>

<p>Once accomplished, we can then create a gated clock much like we did with the
latch above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">assign</span>	<span class="n">gated_clk</span> <span class="o">=</span> <span class="n">S_AXI_ACLK</span> <span class="o">&amp;&amp;</span> <span class="n">gaten</span><span class="p">;</span></code></pre></figure>

<p>The trick here, however, is that the non-gated logic still needs to know
if the clock has been gated.  At issue specifically are the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffers</a>.  These
need to be able to handle any incoming signal no matter whether the clock
is on or off.  For this reason, the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffers</a>
operate on the AXI clock, and not the gated clock.  To handle the transition,
I created another signal, <code class="language-plaintext highlighter-rouge">clk_gate</code> below, to indicate if the logic on the
gated clock is active on this clock cycle.
While I might set this based upon <code class="language-plaintext highlighter-rouge">gaten</code> above, that would involve a second
edge to edge crossing, and indeed one that’s not required.  I can
instead just move the <code class="language-plaintext highlighter-rouge">gatep</code> signal to the next clock to know whether or not
the clock is active on a given cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">r_gate</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">r_gate</span> <span class="o">&lt;=</span> <span class="n">gatep</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">clk_gate</span> <span class="o">=</span> <span class="n">r_gate</span><span class="p">;</span></code></pre></figure>

<p>The resulting signal, <code class="language-plaintext highlighter-rouge">clk_gate</code>, should pass a timing check easier–assuming
this piece of logic ever hits something more than the simulator.  (It may not.)</p>

<p>Even better, I can easily adjust my <a href="/blog/2020/03/08/easyaxil.html">Easy AXI-Lite
design</a>
to integrate this <code class="language-plaintext highlighter-rouge">clk_gate</code> signal into the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffers</a>
control signals:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">axil_write_ready</span> <span class="o">=</span> <span class="n">clk_gate</span> <span class="o">&amp;&amp;</span> <span class="n">awskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">wskd_valid</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXIL_BVALID</span> <span class="o">||</span> <span class="n">S_AXIL_BREADY</span><span class="p">);</span>

	<span class="c1">// And sometime later ...</span>

	<span class="k">assign</span>	<span class="n">axil_read_ready</span> <span class="o">=</span> <span class="n">clk_gate</span> <span class="o">&amp;&amp;</span> <span class="n">arskd_valid</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXIL_RVALID</span> <span class="o">||</span> <span class="n">S_AXIL_RREADY</span><span class="p">);</span></code></pre></figure>

<p>The only remaining question is how to set the registered value, <code class="language-plaintext highlighter-rouge">clk_active</code>
that we used above to control our gating signal.  As we work through the
various logic cases, the first two answers are that this core logic will be
inactive following a reset, and it will need to be active if we are ever busy
with a memory move.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">clk_active</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">begin</span>
			<span class="n">clk_active</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">r_busy</span><span class="p">)</span>
				<span class="n">clk_active</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>We’ll also have to turn the clock on if we’re ever involved in any bus
transactions.  Since this design follows the <a href="/blog/2020/03/08/easyaxil.html">basic EasyAXIL AXI-lite
design</a>,
there aren’t any deep pipelines anywhere within the AXI-lite control
structure.  That means we can just focus on the AXI-lite signals
themselves–whether incoming from the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffers</a>
or outgoing.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="n">awskd_valid</span> <span class="o">||</span> <span class="n">wskd_valid</span> <span class="o">||</span> <span class="n">arskd_valid</span><span class="p">)</span>
				<span class="n">clk_active</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">S_AXIL_BVALID</span> <span class="o">||</span> <span class="n">S_AXIL_RVALID</span><span class="p">)</span>
				<span class="n">clk_active</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">end</span></code></pre></figure>

<p>Those are the two designs, therefore, that I’ll be testing today: an updated
<a href="/about/zipcpu.html">ZipCPU</a>, and a modified <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">AXI
DMA</a>,
both of which will automatically turn their clocks off if they’re ever idle.</p>

<h2 id="performance-tests">Performance tests</h2>

<p>When I first ran <a href="https://github.com/ZipCPU/axidmacheck/tree/zipcpu">my AXI DMA test
bench</a> using this clock
gating, the test bench ran in 4.4 seconds with clock gating and 5.3 seconds
without.  A 20% improvement!  Wow!  That’s a big deal.  If simulation speeds
can be improved by 20% simply via clock gating, then I’d be tempted to do a
whole lot more clock gating just to get my simulations to run faster.  Think of
how much time I could save on my 5hr simulation jobs!</p>

<p>I then ran another test, this time on a commercial design I’ve been working on.
This test took 83:45 (83 minutes, 45 seconds) without clock gating, and
88:50 with clock gating.  In this case, clock gating not only didn’t help, it
actually made things worse.  Unfortunately, my notes from this test are a bit
old and I can’t remember which design I tested or which simulator I used
anymore.  Was it
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
or <a href="http://iverilog.icarus.com/">IVerilog</a>?  If I was using
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>,
then did I remember to flag the clock gate control signal to
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>?
Beyond that, which design had I tested and which configuration of that design
was it?</p>

<p>Time to start over.</p>

<p>So, let’s be clear today: today’s first test was of my <a href="https://github.com/ZipCPU/axidmacheck">AXI DMA test
bench</a>, using <a href="https://github.com/ZipCPU/axidmacheck/tree/abc25ce841ee7db3f5dd0325f75426a89469397a">this ZipCPU
branch</a>.  I ran the test
using <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>.
I controlled the test via <a href="https://github.com/ZipCPU/axidmacheck/blob/abc25ce841ee7db3f5dd0325f75426a89469397a/sim/automaster_tb.cpp#L199-L389">an external C++ test script</a>, and for the first test
of the DMA only I left the CPU halted the whole time.  As I mentioned above,
today’s results initially took 4.4s with clock gating enabled and 5.3s
without.  This test involved primarily gating the
<a href="/about/zipcpu.html">ZipCPU</a>.</p>

<p>So why not try gating the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">DMA</a>?
Even better, why not try gating all of the DMAs within the design?  That means
not only the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">memory to memory
DMA</a>,
but also the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">memory to stream
(MM2S)</a>,
and the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">stream to memory DMA
(S2MM)</a>.  The
logic is easy enough to add–especially since I’ve now worked out the details
(shown above) when testing the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">memory to memory
DMA</a>.</p>

<p>So, for a second test using the same repository, I chose to run the
<a href="/about/zipcpu.html">ZipCPU</a> in a
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
based simulation, inside my <a href="https://github.com/ZipCPU/axidmacheck/tree/zipcpu">AXI DMA test
bench</a>,
gating all three AXI DMAs.  As a test case, I ran
<a href="https://en.wikipedia.org/wiki/Dhrystone">Dhrystone</a>, and <a href="/blog/2021/08/14/axiperf.html">my AXI
performance monitor</a>,
and configured the CPU for 4kB instruction and data caches.</p>

<p>The results?</p>

<p>Well, let’s just say the results were not what I was expecting or hoping for.</p>

<table align="center" style="float: none"><caption>Fig 1. Simulation CPU time, with and without clock gating</caption><tr><td><img src="/img/clkgate/lowpower-times.png" alt="" width="662" /></td></tr></table>

<p>Perhaps the first lesson learned is that this is not how a proper test should
be conducted.  I spent the entire weekend running tests, examining the results,
updating and adjusting the test, and then running the test again.  Sure, the
DMA test only took about 5s to run, but 1000 rounds of
<a href="https://en.wikipedia.org/wiki/Dhrystone">Dhrystone</a>, followed by the simulated
serial port outputting the data (this took longer than
<a href="https://en.wikipedia.org/wiki/Dhrystone">Dhrystone</a> itself), took about
12 minutes to run.  I’d then examine the results, adjust things, and run
the test again and again.</p>

<p>I also adjusted a second variable while running the test.  Not only did I
turn <a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
for the DMA’s or the CPU on and off, but I also enabled
or disabled the <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> option within the design.  <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> is
the name of a parameter that I’ve started adding to many of my designs.
When set, the design will use extra logic to either pin values at zero or
keep them from toggling when not used.  A classic example might be <code class="language-plaintext highlighter-rouge">AXI_AxADDR</code>.
If <code class="language-plaintext highlighter-rouge">AXI_AxVALID</code> is low, why should <code class="language-plaintext highlighter-rouge">AXI_AxADDR</code> change?</p>

<p>Much to my surprise, turning on and off the <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> option had more of
an effect on my simulations than the clock gate.</p>

<table align="center" style="float: none"><caption>Fig 2. VCD file size as a function of OPT_LOWPOWER</caption><tr><th>OPT_LOWPOWER=0 (Unused)</th><th>OPT_LOWPOWER=1 (active)</th></tr><tr><td><img src="/img/clkgate/initial-sizes.png" alt="" width="331" /></td><td><img src="/img/clkgate/lowpower-sizes.png" alt="" width="331" /></td></tr></table>

<!-- FIGURE -->

<p>Indeed, in the final analysis my
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
work didn’t have much of an impact on my simulations at all.</p>

<p>So what lessons can we draw from these tests?</p>

<ol>
  <li>
    <p>I was not able to demonstrate any significant simulation time benefit
to be gained by <a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>.
Sure, 5-6% is measurable and it was eventually consistent, but it’s not
really anything to write home about.  This itself was a bit of a
disappointment, as I was hoping to reproduce that 20% improvement in
a larger design with a more complex simulation and I wasn’t able to do so.</p>
  </li>
  <li>
    <p><a href="/blog/2017/07/31/vcd.html">VCD file</a> size appears to
be a reasonable proxy for energy used by a design.</p>

    <p>This works because a <a href="/blog/2017/07/31/vcd.html">VCD file</a>
contains only <em>changed</em> signals.  Signals are only written into the <a href="/blog/2017/07/31/vcd.html">VCD
file</a> when they change.
Signals that don’t change are never updated.  As a result, if only one
small portion of a design is changing, the impact of the rest of the design
on the <a href="/blog/2017/07/31/vcd.html">VCD file</a>
size can be very small.</p>

    <p>This isn’t a perfect proxy, however, since some signals such as clocks
have a greater capacitance, and therefore a greater energy usage within a
design than others.  Still,
<a href="/blog/2017/07/31/vcd.html">VCD file</a> size can be a
<em>useful</em> indicator.</p>
  </li>
  <li>
    <p>It can be easier to gate a clock than it is to properly audit your design
for toggling signals that don’t need to be toggling.  In other words,
one might argue that
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
can be used as a poor man’s substitute for good low power design practice.</p>
  </li>
  <li>
    <p>My two AXI caches
<a href="https://github.com/ZipCPU/blob/zipcore/rtl/core/axiicache.v">[1]</a>
<a href="https://github.com/ZipCPU/blob/zipcore/rtl/core/axidcache.v">[2]</a>,
together with my <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">AXI to AXI-lite
bridge</a>,
all needed some low power work since they were allowing a lot of signals
to toggle unnecessarily.  Indeed, even though my brand new <a href="/blog/2021/08/14/axiperf.html">AXI performance
monitor</a> had a <a href="https://github.com/ZipCPU/wb2axip/blob/1c34ceb8807b0348ea242ec3d5d4aace13932483/rtl/axiperf.v#L699-L700">low power
option</a>, I hadn’t yet enabled it.</p>

    <p>Worse, my <a href="https://github.com/ZipCPU/blob/zipcore/rtl/core/axidcache.v">AXI data
cache</a> didn’t
initially work with <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> set.  Under certain circumstances, it
would issue a read of a zero address, <code class="language-plaintext highlighter-rouge">M_AXI_ARADDR == 0</code>, simply because
I had tested for <code class="language-plaintext highlighter-rouge">i_op[0]</code> (a write operation) instead of <code class="language-plaintext highlighter-rouge">!i_op[0]</code> (a
read operation).  This seems to be a <a href="/zipcpu/2019/02/04/debugging-that-cpu.html">common, and rather frustrating
problem</a>,
where I’ll check a design component into my repository without verifying
all of it.  I then pull it out later to use it, configure it in a way it
hasn’t yet been tested for, expect it to “just work” and then find myself
debugging the entire design in order to find and fix an unexpectedly
broken component within it.</p>
  </li>
  <li>
    <p>The <a href="/about/zipcpu.html">ZipCPU</a> itself needed some
low power work.  Specifically, the
<a href="/zipcpu/2021/07/03/slowmpy.html">multiplies</a> were <a href="https://github.com/ZipCPU/zipcpu/blob/8aed45b765b39ed0e1da78338f7ce8a9564c4d0c/rtl/core/mpyop.v#L203-L206">always
turned on and calculating</a>–even
if the CPU was ignoring their results.  Similarly, the <a href="https://github.com/ZipCPU/zipcpu/blob/8aed45b765b39ed0e1da78338f7ce8a9564c4d0c/rtl/core/idecode.v#L686-L700">early branching
address</a>
and the <a href="https://github.com/ZipCPU/zipcpu/blob/8aed45b765b39ed0e1da78338f7ce8a9564c4d0c/rtl/core/idecode.v#L600-L604">simulation instruction
details</a>
were always calculated–even when the CPU wasn’t branching and the
simulation instruction wasn’t active.</p>

    <p>These things are easy enough to fix, but you won’t recognize they are a
problem if you aren’t looking for them in the first place.</p>
  </li>
  <li>
    <p>Small changes tended to have a big impact on the <a href="/blog/2017/07/31/vcd.html">VCD
file</a> size.  For
example, I started with a rough 15GB <a href="/blog/2017/07/31/vcd.html">VCD
file</a> size even with
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
and, through the small number of optimizations listed above, I managed to
get that file size down to 9GB.</p>
  </li>
  <li>
    <p>As for design, when designing a component for
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
it really helps to have access to both the gated and the ungated clock,
as well as an ungated signal to tell you whether or not the current
clock is gated.</p>

    <p>This much cannot be stressed enough.  Having access to both sides of the
gate was very valuable.</p>

    <p>As an example, one of my initial purposes was to examine AXI’s low power
interface signals: CSYSREQ, CSYSACK, and CACTIVE.  Indeed, one of my
earlier <a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a> versions
of the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">AXI DMA</a>
specifically made use of these signals.</p>

    <p>I’ve since <a href="https://github.com/ZipCPU/wb2axip/commit/1c34ceb8807b0348ea242ec3d5d4aace13932483">ripped all of that logic back out</a>.</p>

    <p>Why?  First, the <a href="/doc/axi-spec.pdf">AXI specification</a>
isn’t very clear on how these signals should be used.  Only
when digging elsewhere did I discover that these signals are all required
to be registered.  What good are registered signals, when the only clock you
have available to register them with comes from the gated clock domain?
A design always needs a way of exiting a low power state, and this is going
to require some amount of logic in the ungated clock domain.  Second, these
signals are supposed to require support from the AXI interconnect, and
my interconnect doesn’t (yet) support them.  Perhaps I’m missing something.
How is the interconnect to know that a bus component is or isn’t busy?
Should it always try to shut components down?  As a result, until I finally
figure out these signals, I’ve torn the capability out.  It was just one more
item that needed to be maintained, and worse it was rather dubious whether
I was accurately supporting the standard at that.</p>
  </li>
</ol>

<h2 id="conclusions">Conclusions</h2>

<p>While I’m sure there’s a good reason to use
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
out there, I’m also pretty sure I haven’t (yet) found it outside of an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> context.</p>

<ol>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Clock_gating">Clock gating</a> doesn’t appear
to have any substantial impact on simulation run time–when using
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
that is.</p>
  </li>
  <li>
    <p>If you have to allocate a second global clock buffer on an FPGA for a gated
clock, then you haven’t really gained much of a power savings–since a
large portion of any FPGA design’s power usage will be consumed by the
clock buffer.</p>
  </li>
  <li>
    <p>Yes, <a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>
can stop registers from toggling.  But, let me ask, should those registers
have been toggling in the first place?  To me, this feels like a cheaters
way of handling a bad engineering design.  Wouldn’t it be better to simply
clean up the design in the first place?</p>
  </li>
  <li>
    <p>That leaves low-power
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>
design as the only remaining reason I can think of for
<a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>.</p>
  </li>
</ol>

<p>I guess my final conclusion would be that we need to come back to the topic
of low power FPGA design on this blog, and deal with it properly and fully at
that time.  There’s a lot more to low power design than gating clocks, and a
review of the tools available to the power conscious FPGA designer could be
quite valuable.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And the sun stood still, and the moon stayed, until the people had avenged themselves upon their enemies. Is not this written in the book of Jasher? So the sun stood still in the midst of heaven, and hasted not to go down about a whole day. (Joshua 10:13)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
