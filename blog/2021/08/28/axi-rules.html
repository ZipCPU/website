<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>AXI Handshaking Rules</title>
  <meta name="description" content="I’m going to try to keep this article short, while still answering the question:what is the bare minimum you need to know when using an AXI handshake?">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2021/08/28/axi-rules.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">AXI Handshaking Rules</h1>
    <p class="post-meta"><time datetime="2021-08-28T00:00:00-04:00" itemprop="datePublished">Aug 28, 2021</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I’m going to try to keep this article short, while still answering the question:
what is the bare minimum you need to know when using an AXI handshake?</p>

<p>We’ll start with the basics, there are masters and slaves.  “Slave” ports are
those that receive data, whereas “master” ports transmit or send data to
slaves.</p>

<table align="center" style="float: none"><caption>Fig 1. AXI stream data flow direction: masters feed slaves</caption><tr><td><img src="/img/slave-rules/mvslave.svg" alt="" width="420" /></td></tr></table>

<p>I’ve tended to follow the convention found in Xilinx’s examples of prefixing
my master ports with <code class="language-plaintext highlighter-rouge">M_*_</code> and my slave ports with <code class="language-plaintext highlighter-rouge">S_*_</code>.  I’ll then
often fill in the <code class="language-plaintext highlighter-rouge">*</code> part of the middle with some name reminding me which
interface is being described.  For example, <code class="language-plaintext highlighter-rouge">S_VID_TVALID</code> would be the
<code class="language-plaintext highlighter-rouge">TVALID</code> signal found on the slave video interface.  The result is a signal
list, for AXI stream, looking something like that in Fig. 2 below.</p>

<table align="center" style="float: none"><caption>Fig 2. AXI stream signals</caption><tr><td><img src="/img/slave-rules/axis-signals.png" alt="" width="605" /></td></tr></table>

<p>In most cases, only the clock, reset, valid, ready, and data signals are
required of an interface.  In packet interfaces, or <a href="/blog/2021/03/20/xilinx-forums.html">whenever using Xilinx’s
stream DMAs</a>, the
<code class="language-plaintext highlighter-rouge">TLAST</code> signal is also required.  Video interfaces also use the <code class="language-plaintext highlighter-rouge">TUSER</code>
signal to indicate a start of frame.</p>

<p>The rest of the signals are optional, and I’ve rarely found a use for them.</p>

<p>Today, however, I want to focus on the handshake signals.  Therefore we’ll
group these signals into three categories: <code class="language-plaintext highlighter-rouge">TVALID</code>, <code class="language-plaintext highlighter-rouge">TREADY</code>, and we’ll
lump everything else into the signal <code class="language-plaintext highlighter-rouge">TDATA</code>.  This is simply because the
handshaking signals create rules on all of the payload signals equally.</p>

<p>Further, while I will be discussing AXI stream handshakes today, all of our
rules will also apply to AXI and AXI-lite handshakes as well.  Indeed, some
of the examples and illustrations I will be using further on come from
non-stream designs.</p>

<h2 id="the-rules">The rules</h2>

<p>So let’s start the basic handshaking rules.  Indeed, I like to think of these
as the bare minimum number you need to know in order to build an AXI handshake.</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">xVALID</code> must be cleared following any reset.</p>
  </li>
  <li>
    <p>Nothing happens unless <code class="language-plaintext highlighter-rouge">xVALID &amp;&amp; xREADY</code>.</p>

    <p>Just as a point of notation here, I’m following the AXI4 specifications
convention of using <code class="language-plaintext highlighter-rouge">xVALID</code> to refer to an AXI stream channel of some
type.  In this case, I might have said <code class="language-plaintext highlighter-rouge">M_AXIS_TVALID &amp;&amp; M_AXIS_TREADY</code>
or <code class="language-plaintext highlighter-rouge">S_AXIS_TVALID &amp;&amp; S_AXIS_TREADY</code>, but I’ve just shortened things with
the abbreviation above to try to simplify things.</p>
  </li>
  <li>
    <p>Something <em>always</em> happens anytime <code class="language-plaintext highlighter-rouge">xVALID &amp;&amp; xREADY</code> – <em><a href="/formal/2019/04/16/axi-mistakes.html">Be careful
not to add any other conditions to this
check</a>
lest you miss a handshake!</em></p>
  </li>
  <li>
    <p>Nothing can change unless <code class="language-plaintext highlighter-rouge">!xVALID || xREADY</code>.</p>

    <p>This is more of a master rule than one for a slave, but still quite
important.  We’ll come back to this more in a moment.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">xREADY</code> signal must be registered.  Use a
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>
if necessary to avoid any throughput impacts.</p>

    <p>Okay, this isn’t quite what’s required by the specification.  Rather, this
is a consequence of what the specification does require.  The specification
simply requires that, “On master and slave interfaces, there must be no
combinatorial paths between input and output signals.”</p>
  </li>
</ol>

<table align="center" style="float: none"><caption>Fig 3. Combinatorial paths are not allowed between AXI inputs and outputs</caption><tr><td><img src="/img/tweets/axi-spec-registered.png" alt="" width="614" /></td></tr></table>

<ol start="6">
  <li>
    <p>(Recommendation only:) <code class="language-plaintext highlighter-rouge">READY</code> should be held high when the design is
idle, and only lowered (if required) following <code class="language-plaintext highlighter-rouge">VALID &amp;&amp; READY</code>.</p>

    <p>This works great for AXI streams.  It even works well for the AXI read
address channel.  It’s just a bit harder to do with the write address and
write data channels if you don’t have a
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>
available to you.  We’ll discuss this problem more in a moment.</p>
  </li>
</ol>

<h2 id="example-slave-logic">Example Slave logic</h2>

<p>If all you do is follow those basic rules, you’ll pretty much be forced
into some basic logic forms.  Let’s look at the form of a slave logic
handler, and then we’ll look at the master logic next.</p>

<p>Within a slave, therefore, you are likely to have logic blocks that look like
the following:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">ACLK</span><span class="p">)</span>
		<span class="c1">// Logic to determine S_AXIS_TREADY</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXIS_TVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXIS_TREADY</span><span class="p">)</span> <span class="c1">// plus nothing!</span>
		<span class="c1">// Do something</span></code></pre></figure>

<p>Some time ago, I <a href="/formal/2019/04/16/axi-mistakes.html">wrote about the problem associated with adding conditions
to the handshake check</a>.
Since that time, the worst problem I’ve seen with this handshake has been with
AXI memory mapped slaves that can only handle a read or a write request at a
given time, but never both.  So let’s discuss how to handle that situation
quickly.</p>

<p>For example, <a href="https://github.com/jofrfu/tinyTPU/blob/b8df109e7bf1c358e89dee7fbf9cc0d65786b6fb/src/vhdl/AXI/tinyTPU_v1_0_S00_AXI.vhd#L353-L366">this VHDL design is quite broken</a>:</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl">	<span class="n">FSM</span><span class="p">:</span>
	<span class="k">process</span><span class="p">(</span><span class="n">STATE_cs</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="c1">-- not listing all items here</span>
	  <span class="k">variable</span> <span class="n">AW_VALID_ARVALID</span> <span class="p">:</span> <span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">begin</span>
		<span class="n">AWVALID_ARVVALID</span> <span class="p">:</span><span class="o">=</span> <span class="n">S_AXI_AWVALID</span> <span class="o">&amp;</span> <span class="n">S_AXI_ARVALID</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">STATE_cs</span> <span class="k">is</span>
		<span class="k">when</span> <span class="n">IDLE</span> <span class="o">=&gt;</span>
			<span class="c1">-- Skipping irrelevant lines ...</span>
			<span class="n">S_AXI_AWREADY</span> <span class="o">&lt;=</span> <span class="sc">'1'</span><span class="p">;</span>
			<span class="n">S_AXI_ARREADY</span> <span class="o">&lt;=</span> <span class="sc">'1'</span><span class="p">;</span>
			<span class="c1">-- ...</span>
			<span class="k">case</span> <span class="n">AWVALID_ARVALID</span> <span class="k">is</span>
			<span class="k">when</span> <span class="s1">"10"</span> <span class="o">=&gt;</span>
				<span class="c1">-- ...</span>
				<span class="n">STATE_ns</span> <span class="o">&lt;=</span> <span class="n">WRITE_ADDRESS</span><span class="p">;</span>
			<span class="k">when</span> <span class="s1">"01"</span> <span class="o">=&gt;</span>
				<span class="c1">-- ...</span>
				<span class="n">STATE_ns</span> <span class="o">&lt;=</span> <span class="n">WRITE_ADDRESS</span><span class="p">;</span>
			<span class="k">when</span> <span class="k">others</span> <span class="o">=&gt;</span>
				<span class="c1">-- ...</span>
				<span class="n">STATE_NS</span> <span class="o">&lt;=</span> <span class="n">IDLE</span><span class="p">;</span>
			<span class="k">end</span> <span class="k">case</span><span class="p">;</span>
		<span class="c1">-- ...</span>
		<span class="k">end</span> <span class="k">case</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">process</span> <span class="n">FSM</span><span class="p">;</span>

	<span class="c1">-- ...</span>

	<span class="n">SEQ_LOG</span><span class="p">:</span>
	<span class="k">process</span> <span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">)</span> <span class="k">is</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="n">S_AXI_ACLK</span><span class="na">'event</span> <span class="ow">and</span> <span class="n">S_AXI_ACLK</span> <span class="o">=</span> <span class="sc">'1'</span> <span class="k">then</span>
			<span class="k">if</span> <span class="n">S_AXI_ARESETN</span> <span class="o">=</span> <span class="sc">'0'</span> <span class="k">then</span>
				<span class="n">STATE_cs</span> <span class="o">&lt;=</span> <span class="n">IDLE</span><span class="p">;</span>
				<span class="c1">-- ...</span>
			<span class="k">else</span>
				<span class="c1">-- ...</span>
				<span class="n">STATE_cs</span> <span class="o">&lt;=</span> <span class="n">STATE_ns</span><span class="p">;</span>
			<span class="k">end</span> <span class="k">if</span><span class="p">;</span>
		<span class="k">end</span> <span class="k">if</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">process</span><span class="p">;</span></code></pre></figure>

<p>Notice, here, how the designer allowed both <code class="language-plaintext highlighter-rouge">AWVALID &amp;&amp; AWREADY</code> and
<code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code> to be true at the same time.  If ever the two were
both true at the same time, both of the bursts would be lost.</p>

<table align="center" style="float: none"><caption>Fig 4. If a read and write burst are both received on the same cycle, both will be dropped</caption><tr><td><img src="/img/slave-rules/tinytpu.png" alt="" width="447" /></td></tr></table>

<p>My favorite approach to dealing with this situation is to use two combinatorial
wires to control reading from the AW and AR
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffers</a>
respectively.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Accept writes, but only if there are no pending reads</span>
	<span class="k">assign</span>	<span class="n">axil_write_ready</span> <span class="o">=</span> <span class="n">skid_awvalid</span> <span class="o">&amp;&amp;</span> <span class="n">skid_wvalid</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">axil_read_ready</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">axil_read_ready</span> <span class="o">=</span> <span class="n">skid_arvalid</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">);</span></code></pre></figure>

<p>This approach fits nicely into the framework we’ve already established in the
<a href="/blog/2020/03/08/easyaxil.html">Easy AXI-lite template</a>.</p>

<p>This isn’t the only valid approach.  Many Xilinx IP’s handle this situation by
quietly buffering the request that wasn’t accepted so that it can be handled
later.  They then come back to this buffered request once they finish
handling the one they’ve chosen to handle and before raising <code class="language-plaintext highlighter-rouge">xREADY</code> again.</p>

<p>That’s how they handle it when it works.</p>

<p>Then there’s their AXI QUAD SPI IP design.  This design tries to do something
very similar, only … they weren’t consistent in how they built their logic.
Hence, in this example, some of their logic prioritizes writes over reads.</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl">	<span class="n">rnw_cmb</span> <span class="o">&lt;=</span> <span class="n">S_AXI4_ARVALID</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">S_AXI4_AWVALID</span><span class="p">);</span>
	<span class="c1">-- ...</span>
	<span class="n">axi_length_cmb</span> <span class="o">&lt;=</span> <span class="n">S_AXI4_ARLEN</span> <span class="p">(</span><span class="k">when</span> <span class="n">rnw_cmb</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span>
			<span class="k">else</span>
			<span class="n">S_AXI4_AWLEN</span><span class="p">;</span></code></pre></figure>

<p>But when you get to their actual state machine, they choose to process reads
before writes.  First, though, here’s the <code class="language-plaintext highlighter-rouge">wr_transaction</code> signal that you’ll
see referenced by the state machine below.</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl"><span class="n">wr_transaction</span> <span class="o">&lt;=</span> <span class="n">S_AXI4_AWVALID</span> <span class="ow">and</span> <span class="p">(</span><span class="n">S_AXI4_WVALID</span><span class="p">);</span></code></pre></figure>

<p>Now that you know what `wr_transaction is, you can look inside their
state machine to see how reads get prioritized over writes:</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl">	<span class="k">when</span> <span class="n">IDLE</span> <span class="o">=&gt;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI4_ARVALID</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
			<span class="c1">-- ...</span>
		<span class="k">elsif</span> <span class="p">(</span><span class="n">wr_transaction</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
			<span class="c1">-- ...</span>
		<span class="c1">-- ...</span></code></pre></figure>

<p>The result is that, if the IP ever gets both a read request and a write
request at the same time, it will process and return the read request
with the AXI burst parameters of the write request–such as the burst’s
length, for example.</p>

<p>The point here is simple: If <code class="language-plaintext highlighter-rouge">AWVALID &amp;&amp; AWREADY</code> or <code class="language-plaintext highlighter-rouge">ARVALID &amp;&amp; ARREADY</code>
then a transaction has been accepted.  If both are true, then you need to make
sure you are processing both transactions properly, or at least buffering one
for later processing.</p>

<h2 id="example-master-logic">Example Master logic</h2>

<p>From the perspective of a master, the logic forms are just a touch different.
In this case, I’m more set in my ways.  Indeed, I’ve gotten to the point
where I always use the following logic form for any AXI master handshake.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// OPT_LOWPOWER is a parameter telling me when to force unused signals</span>
	<span class="c1">// to a known value, to reduce any unnecessary signal toggling within</span>
	<span class="c1">// an FPGA.</span>
	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">OPT_LOWPOWER</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ARESETN</span><span class="p">)</span>
		<span class="n">M_AXIS_TVALID</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXIS_TVALID</span> <span class="o">||</span> <span class="n">M_AXIS_TREADY</span><span class="p">)</span>
		<span class="n">M_AXIS_TVALID</span> <span class="o">&lt;=</span> <span class="n">next_valid_signal</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ARESETN</span><span class="p">)</span>
		<span class="n">M_AXIS_TDATA</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXIS_TVALID</span> <span class="o">||</span> <span class="n">M_AXIS_TREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">M_AXIS_TDATA</span> <span class="o">&lt;=</span> <span class="n">next_data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">next_valid</span><span class="p">)</span>
			<span class="n">M_AXIS_TDATA</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Of course, this assumes the existence of the (possibly combinatorial) signals
<code class="language-plaintext highlighter-rouge">next_valid_signal</code> and <code class="language-plaintext highlighter-rouge">next_data</code>.  No, that doesn’t mean I’m a die hard
believer in two process state machines–but that’s another story for another
day.</p>

<p>I will say that most of the AXI handshaking bugs I come across in masters
come from not following this form.</p>

<p>For example, you can find the following logic in Xilinx’s AXI stream master
template design:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">axis_tlast</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_pointer</span> <span class="o">==</span> <span class="n">NUMBER_OF_ITEMS</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span>  <span class="n">ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ARESETN</span><span class="p">)</span>
		<span class="n">axis_tlast_delay</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">axis_tlast_delay</span> <span class="o">&lt;=</span> <span class="n">axis_tlast</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">M_AXIS_TLAST</span> <span class="o">=</span> <span class="n">axis_tlast_delay</span><span class="p">;</span></code></pre></figure>

<p>See the bug?  If not, check out Fig. 5 below.</p>

<table align="center" style="float: none"><caption>Fig 5. Xilinx's broken AXI stream master: TLAST changes when it should be stalled</caption><tr><td><img src="/img/xilinx-vivado/broken-tlast-trace-annotated.png" alt="" width="834" /></td></tr></table>

<p>If <code class="language-plaintext highlighter-rouge">M_AXIS_TVALID &amp;&amp; !M_AXIS_TREADY</code> on the penultimate beat of the burst,
<code class="language-plaintext highlighter-rouge">M_AXIS_TLAST</code> will get set while the channel is supposed to be stalled  <em>in
violation of the protocol</em>.  You might find yourself surprised later when the
data packet arrives with the wrong number of items in it.</p>

<p>These sorts of problems aren’t limited to AXI stream designs, nor are they
limited to Xilinx’s templates.  For example, here’s the same sort of bug
in their AXI Ethernet-lite IP.  Again, this bug is due to the fact that
they didn’t follow the form above.</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl">  <span class="n">AXI4_RDATA_GEN</span> <span class="p">:</span> <span class="k">if</span> <span class="p">(</span><span class="n">C_S_AXI_PROTOCOL</span> <span class="o">=</span> <span class="s1">"AXI4"</span><span class="p">)</span> <span class="k">generate</span>
      <span class="n">AXI_READ_OUTPUT_P</span><span class="p">:</span> <span class="k">process</span> <span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">)</span> <span class="k">is</span>
      <span class="k">begin</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="na">'event</span> <span class="ow">and</span> <span class="n">S_AXI_ACLK</span> <span class="o">=</span> <span class="sc">'1'</span><span class="p">)</span> <span class="k">then</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="o">=</span><span class="n">RST_ACTIVE</span><span class="p">)</span> <span class="k">then</span>
                  <span class="n">S_AXI_RDATA</span>  <span class="o">&lt;=</span> <span class="p">(</span><span class="k">others</span> <span class="o">=&gt;</span><span class="sc">'0'</span><span class="p">);</span>
              <span class="k">elsif</span> <span class="n">S_AXI_RREADY</span> <span class="o">=</span> <span class="sc">'1'</span> <span class="k">then</span>
                  <span class="n">S_AXI_RDATA</span>   <span class="o">&lt;=</span> <span class="n">IP2Bus_Data</span><span class="p">;</span>
              <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
          <span class="k">end</span> <span class="k">if</span><span class="p">;</span>
      <span class="k">end</span> <span class="k">process</span> <span class="n">AXI_READ_OUTPUT_P</span><span class="p">;</span></code></pre></figure>

<p>In this case, if <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> and <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> are both low, the requested
data will not be placed on the bus.  Instead, the design will read the wrong
data from the IP on the first beat of any return burst.</p>

<p>If you simply follow the logic templates above, you won’t make this mistake.</p>

<h2 id="capturing-the-rules-in-formal-properties">Capturing the rules in formal properties</h2>

<p>These basic handshaking rules are also really easy to capture in some simple
formal properties.</p>

<p>For example, we can check whether or not <code class="language-plaintext highlighter-rouge">TVALID</code> is properly reset.
The first step to such a check is to assume the existence of an initial
reset.  For this, we can use <code class="language-plaintext highlighter-rouge">f_past_valid</code>.  This is simply a piece of helper
logic that I often create.  It’s just something that is clear on the first
cycle, set on every other cycle, and only used during formal verification.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="n">f_past_valid</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">f_past_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">ACLK</span><span class="p">)</span>
		<span class="n">f_past_valid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>On that very first cycle, we can assume that the reset must be active.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">ARESETN</span><span class="p">);</span></code></pre></figure>

<p>This is the only reset constraint required.  Beware, though, the formal
solver might toggle your reset line later when you aren’t expecting it.</p>

<p>We can also use <code class="language-plaintext highlighter-rouge">f_past_valid</code> to handle initial value checks.  In particular,
if <code class="language-plaintext highlighter-rouge">f_past_valid</code> is clear then our <code class="language-plaintext highlighter-rouge">TVALID</code> logic should have any initial
value we’ve given to it–zero.  Similarly, if the reset was active on the last
cycle the <code class="language-plaintext highlighter-rouge">TVALID</code> should also be low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid</span> <span class="o">||</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="o">!</span><span class="n">ARESETN</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">M_AXIS_TVALID</span><span class="p">);</span></code></pre></figure>

<p>This check, however, assumes that you’ve set <code class="language-plaintext highlighter-rouge">M_AXIS_TVALID</code> to zero initially.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">M_AXIS_TVALID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p><a href="https://www.reddit.com/r/FPGA/comments/p719jl/initial_statements_in_verilog/">If you’d rather not use initial values</a>,
the check is easily modified to except the first clock cycle from the check.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid</span> <span class="o">||</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="o">!</span><span class="n">ARESETN</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_past_valid</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">M_AXIS_TVALID</span><span class="p">);</span></code></pre></figure>

<p>In this case, the assertion is only checked on clock cycles following the
first one.  Since the first clock cycle includes the reset, this guarantees
that <code class="language-plaintext highlighter-rouge">M_AXIS_TVALID</code> is clear on the second clock cycle and so we know
our property holds.</p>

<p>While AXI does not require an asynchronous reset, it does permit one.  The
check is easily modified to handle an environment with an asynchronous reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ARESETN</span> <span class="o">||</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="o">!</span><span class="n">ARESETN</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">M_AXIS_TVALID</span><span class="p">);</span></code></pre></figure>

<p>Reading this out, it says that if the reset is ever active then <code class="language-plaintext highlighter-rouge">M_AXIS_TVALID</code>
should be clear.  Likewise, if the reset was active on the last clock cycle,
then <code class="language-plaintext highlighter-rouge">M_AXIS_TVALID</code> should also be clear.</p>

<p>From this beginning, we can turn our attention to the handshake itself.</p>

<p>Here, the rule is simple: if the stream stalled on the last cycle,
then all of the values must remain the same on this cycle.  That means that
<code class="language-plaintext highlighter-rouge">M_AXIS_TVALID</code> must remain true, and everything else must remain stable.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">M_AXIS_TVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXIS_TREADY</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">M_AXIS_TVALID</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">M_AXIS_TDATA</span><span class="p">));</span></code></pre></figure>

<p>If you had more than just the <code class="language-plaintext highlighter-rouge">M_AXIS_DATA</code> connection, you’d also want to
assert these are stable as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">//</span>
		<span class="c1">// Assert the same for any other associated</span>
		<span class="c1">// data that might be present: TLAST, TID,</span>
		<span class="c1">// TDEST, TSTRB, TKEEP, TUSER, etc.</span>
		<span class="c1">//</span>
		<span class="c1">// Only asssert the signals you actually have in</span>
		<span class="c1">// your interface.</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">M_AXIS_TLAST</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">M_AXIS_TSTRB</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">M_AXIS_TKEEP</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">M_AXIS_TID</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">M_AXIS_TDEST</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">M_AXIS_TUSER</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>There.  That’s all that’s required of an AXI stream handshake.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Getting AXI handshaking right is a basic requirement of working with anything
AXI related.  The logic templates above should help anyone in that journey.
As you can see from the examples, however, there are plenty of ways of getting
this wrong.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>A prudent man foreseeth the evil, and hideth himself: but the simple pass on, and are punished. Prov 22:3, 27:12</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
