<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Some Simple Clock-Domain Crossing Solutions</title>
  <meta name="description" content="In many ways,metastabilityis the bigboogeyman withinFPGAdesign.  It is hard to see when desk-checking a design, it doesn’t show upon all simulations (certain...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2017/10/20/cdc.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Some Simple Clock-Domain Crossing Solutions</h1>
    <p class="post-meta"><time datetime="2017-10-20T00:00:00-04:00" itemprop="datePublished">Oct 20, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>In many ways,
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>
is the big
<a href="https://en.wikipedia.org/wiki/Bogeyman">boogeyman</a> within
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design.  It is hard to see when desk-checking a design, it doesn’t show up
on all simulations (certainly not with
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>), your synthesis tool
can’t solve it, and timing analysis often just gets in the way of dealing
with it.
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">Metastability</a>,
though, can make your design unreliable.  If your design has a problem with
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>,
then it might never work.  It might work today and not tomorrow.  It might
work perfectly for months, and then have a fatal flaw.</p>

<p>In many ways,
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>
problems are the worst of all errors.  They are hard to trace.  You might
deliver to a customer a design that passes all of your internal tests,
only to have that (now) disgruntled customer tell you it doesn’t work.
Then, to add insult, when you get the hardware back to examine, it works again.
This is the nature of an unpredictable problem such as
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>.</p>

<p>Ouch!</p>

<p>So, what causes
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>?
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">Metastability</a>
is caused when the <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)#Timing_considerations">set up and hold
time</a>
requirements of a
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
aren’t met.  The
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
then enters a state which is neither zero nor one, neither high nor low.  It
may be read by some of your logic as a zero, and by other parts of your logic
as a one.
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">Metastability</a>,
therefore, can cause your logic to do some very unpredictable and (apparently)
illogical things.</p>

<p>For the digital designer,
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>
can take place any time a signal crosses from one clock domain to another.
This is called a “<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">Clock Domain
Crossing</a>”, or
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>, and it needs
some special engineering to be done properly.</p>

<p>Today, therefore, let’s look at several basic solutions to solving
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>
issues.</p>

<h2 id="what-is-a-clock-domain">What is a clock domain</h2>

<p>If we need to pay special attention to <a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">clock domain
crossings</a>,
the first question that we need to answer is, just what is a “clock domain”?</p>

<p>A “Clock Domain” is that portion of your circuitry that is generated and
processed by a single clock.  I like to build my component IPs to use a
single master clock that I call, <code class="language-plaintext highlighter-rouge">i_clk</code>.  All of the registers, then, that are
set within such components on the positive edge of this <code class="language-plaintext highlighter-rouge">i_clk</code> clock signal
form a single clock domain.  Indeed, all of the registers set within an entire
design on the same edge of a same clock form a single clock domain.
Combinatorial logic based upon this register set is also within this same
clock domain.</p>

<table style="float: right"><caption>Fig 1: Four clock domains</caption><tr><td><img src="/img/cdc-domains.svg" alt="Blobology image, showing four separate clock domains: asynchronous inputs, posedge clock_one, negedge clock_one, and posedge clock_two" width="400" /></td></tr></table>

<p>As an example, Fig 1 shows four separate clock domains within a design.
Perhaps this might make more sense, though, if we looked at how to recognize
these examples within some Verilog RTL.</p>

<p>Let’s examine the positive edge of <code class="language-plaintext highlighter-rouge">clock_one</code>.  Any register set on the
positive edge of <code class="language-plaintext highlighter-rouge">clock_one</code> is within one clock domain–the yellow domain in
Fig 1.  Hence, <code class="language-plaintext highlighter-rouge">r_reg_one</code> in the example below will be within this clock
domain.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">reg</span>	<span class="n">r_reg_one</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clock_one</span><span class="p">)</span>
	<span class="n">r_reg_one</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">some_logic</span><span class="p">);</span></code></pre></figure>

<p>Any logic can be created, based upon <code class="language-plaintext highlighter-rouge">r_reg_one</code> and transitioning on
the positive edge of <code class="language-plaintext highlighter-rouge">clock_one</code>, without crossing a clock domain.  Hence,
<code class="language-plaintext highlighter-rouge">r_pipe_one</code> below is still within the same <code class="language-plaintext highlighter-rouge">clock_one</code> clock domain.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">reg</span>	<span class="p">[(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">r_pipe_one</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clock_one</span><span class="p">)</span>
	<span class="n">r_pipe_one</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">r_pipe_one</span><span class="p">[(</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">r_reg_one</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>This applies to combinatorial logic as well, not just register logic.  Any
combinatorial logic depending only upon inputs created within the same
clock domain is also within that clock domain.  Hence, <code class="language-plaintext highlighter-rouge">w_wire_one</code> below
remains within the <code class="language-plaintext highlighter-rouge">clock_one</code> clock domain.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">wire</span>	<span class="n">w_wire_one</span><span class="p">;</span>

<span class="k">assign</span>	<span class="n">w_wire_one</span> <span class="o">=</span> <span class="o">|</span><span class="n">r_pipe_one</span><span class="p">;</span></code></pre></figure>

<p>Anything depending upon another clock, though, is in a different clock domain.
For example, <code class="language-plaintext highlighter-rouge">r_reg_two</code> below is in the <code class="language-plaintext highlighter-rouge">posedge clock_two</code> clock domain,
shown in red in Fig 1 above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clock_two</span><span class="p">)</span>
	<span class="n">r_reg_two</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">some_other_logic</span><span class="p">);</span></code></pre></figure>

<p>Likewise, the negative edge of a clock is a separate clock domain from the
positive edge of the same clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">negedge</span> <span class="n">clock_one</span><span class="p">)</span>
	<span class="n">r_reg_three</span> <span class="o">&lt;=</span> <span class="p">...;</span></code></pre></figure>

<p>So if that’s a clock domain, what’s a
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">clock domain crossing</a>?</p>

<table style="float: left; padding: 15px"><caption>Fig 2: Clock Domain Crossings (CDCs)</caption><tr><td><img src="/img/cdc-crossing.svg" alt="Blobology image, showing four separate clock domains: asynchronous inputs, posedge clock_one, negedge clock_one, and posedge clock_two" width="320" /></td></tr></table>

<p>A <a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">clock domain crossing
(CDC)</a>
takes place anytime the inputs to a given
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
were set based upon something other than the clock edge used by that
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>.
Fig 2 illustrates three examples of this that we’ll discuss below.</p>

<p>The clearest example of a
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>
is when the inputs to a register, say <code class="language-plaintext highlighter-rouge">r_reg_two</code>, are set based upon
one clock, <code class="language-plaintext highlighter-rouge">clock_one</code>, yet the output is set based upon a second
clock–in this case <code class="language-plaintext highlighter-rouge">clock_two</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clock_two</span><span class="p">)</span>
	<span class="n">r_reg_two</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">some_function_of</span> <span class="n">r_reg_one</span><span class="p">);</span></code></pre></figure>

<p>This also applies to crossing from the positive edge of one clock to the
negative edge of any clock as well.  Hence, the following is a
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>,
since <code class="language-plaintext highlighter-rouge">r_reg_one</code> was set on the <code class="language-plaintext highlighter-rouge">posedge clock_one</code> whereas <code class="language-plaintext highlighter-rouge">r_reg_three</code> is
set on the negative edge of the same clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">negedge</span> <span class="n">clock_one</span><span class="p">)</span>
	<span class="n">r_reg_three</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">some_function_of</span> <span class="n">r_reg_one</span><span class="p">);</span></code></pre></figure>

<p>The third type of
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">clock domain crossing</a>
you are likely to see is the asynchronous input. If you have an input whose
value isn’t changing on your clock, then setting any register based upon it
represents a
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">clock domain crossing</a>:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clock_one</span><span class="p">)</span>
	<span class="n">r_input</span> <span class="o">&lt;=</span> <span class="n">i_value</span><span class="p">;</span></code></pre></figure>

<p>Classic examples of asynchronous inputs that need carefully engineered
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>s
are buttons, switches,
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART receivers</a>, and incoming
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a>
clocks, although other examples abound.  You may even remember the struggle
I had crossing from an <a href="https://en.wikipedia.org/wiki/HDMI">HDMI</a> pixel clock
domain to my memory clock domain, as I discussed in a
<a href="/blog/2017/09/14/even-i-get-stuck.html">previous post</a>.</p>

<p>The problem with all of these
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>s
is that they need to be managed, so as to mitigate the risk of any
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s
being placed into a
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastable</a> state.
How to mitigate these
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>s
is the topic of the rest of this article.</p>

<h2 id="re-synchronizing-a-slow-logic-signal">Re-synchronizing a slow logic signal</h2>

<p>Chances are that, if you’ve only superficially looked into
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>s
before, you’ve been told that the way to synchronize a value going from one
clock to another is to pass it through two
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s
clocked with the new clock, as shown in Fig 3.</p>

<table style="float: right"><caption>Fig 3: CDC solution: Two Flip-flops</caption><tr><td><img src="/img/cdc-dbl-clock.svg" alt="Crossing clock domains via two flip-flops" width="400" /></td></tr></table>

<p>Each of the two
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s
in this figure is clocked with the clock from the new clock domain, whereas
the input to the first one was created within the old clock domain.  While the
result of the first one may have a high probability of
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>,
the output of the second
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
has a much lower probability of
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>.</p>

<p>Some engineers will even recommend not two
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s
but three.  In many ways, how many
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s
you use is dependent upon your application space,
and how catastrophic any
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>
problems would be.</p>

<p>Example code for this might look like,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">new_clock</span><span class="p">)</span>
	<span class="o">{</span> <span class="n">new_val</span><span class="p">,</span> <span class="n">xfer_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">xfer_pipe</span><span class="p">,</span> <span class="n">i_val</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>where <code class="language-plaintext highlighter-rouge">xfer_pipe</code> is either one or two bits wide.</p>

<p>The trick to remember in this process is that none of your code should
reference the output of the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>(s)
in the <a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastable</a>
region of the transfer pipe, referred as <code class="language-plaintext highlighter-rouge">xfer_pipe</code> above.  The value of
<code class="language-plaintext highlighter-rouge">xfer_pipe</code> is the value in the
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>
danger region, shown in Fig 3 above in red.  Instead, you should wait one
more clock and use <code class="language-plaintext highlighter-rouge">new_val</code> (in this example) instead.</p>

<p>This works nicely for cases where the value from the old clock domain changes
slowly–much slower than the frequency of the new clock domain’s clock.
Not all <a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>
problems, though, are that simple.  Other problems require
different solutions, but almost all such solutions are dependent upon this
first basic method.</p>

<h2 id="asynchronous-reset-assertion-synchronous-release">Asynchronous Reset Assertion, Synchronous Release</h2>

<p>One particularly common example of a
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a> is an
asynchronous reset.  I know I’ve given <a href="/blog/2017/08/21/rules-for-newbies.html">beginners the advice of never using an
asynchronous reset</a>.
I stand by this advice <em>for beginning
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designers</em>.  [<a href="https://forums.xilinx.com/t5/PLD-Blog/That-Dangerous-Asynchronous-Reset/ba-p/12856">Xilinx Ref</a>]
There comes a time,
though, when you need an asynchronous reset.</p>

<p>For me, I last found myself <em>needing</em> an asynchronous reset was when I needed
to reset a circuit whose clock I had stopped.  Without the clock, I couldn’t
reset the circuit and so I needed an asynchronous reset.</p>

<p>The problem isn’t so much entering the reset state, the problem is
exiting the reset state.  The exit needs to be done synchronous to the
clock.  If it isn’t, you not only risk
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>
problems, but you also risk some parts of your design getting released from
the reset state before (or after) others.
(This <a href="https://forums.xilinx.com/t5/PLD-Blog/That-Dangerous-Asynchronous-Reset/ba-p/12856">Xilinx Ref</a> discusses some of that)</p>

<p>Creating an asynchronous reset line with a synchronous release isn’t really
all that hard to do in Verilog.  Indeed, you might argue that the Verilog
solution below looks a lot like our two
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
solution above.</p>

<p>In this example, we assume an active low asynchronous reset, and we synchronize
the exit from this reset state using another active low signal, <code class="language-plaintext highlighter-rouge">s_reset_n</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">reg</span>	<span class="n">s_reset_n</span><span class="p">,</span> <span class="n">r_pipe</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_reset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">s_reset_n</span><span class="p">,</span> <span class="n">r_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="mb">2'b00</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">{</span> <span class="n">s_reset_n</span><span class="p">,</span> <span class="n">r_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">r_pipe</span><span class="p">,</span> <span class="mb">1'b1</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>You can then use the <code class="language-plaintext highlighter-rouge">s_reset_n</code> as a synchronous active low reset signal
throughout your design.</p>

<p>Engineers have argued about whether active high or active low resets are
better.  In general it doesn’t make a difference within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
however the peripherals the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
controls may have specific requirements.
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
<a href="/blog/2017/10/13/fpga-v-asic.html">designers</a>, on the
other hand, tend to like the active low reset.  Verilog designed to handle
both <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> and
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
implementations will likely need this circuitry therefore.</p>

<h2 id="the-cross-clock-handshake">The Cross-clock Handshake</h2>

<p>One of the problems with the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a> chain
method of handling
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>s is that
nothing guarantees that the input is stable long enough to know that the
output was received.  Sometimes, for example, you want a
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>
method that can handle going from a slow clock to a fast clock, from a fast
clock to a slow clock, or even from one clock of unknown speed to another
clock having no known relationship to the first.  This calls for another
approach: the handshaking method, shown in Fig 4.</p>

<table style="float: right"><caption>Fig 4: A Request-acknowledgement hand-shake</caption><tr><td><img src="/img/cdc-dbl-ack.svg" alt="Crossing clock domains with a handshake.  First a request crosses, then the acknowlegement returns.  When both are clear, a new request can take place" width="400" /></td></tr></table>

<p>In this figure, two clock domains are shown, yellow and green, together with
the <a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastable</a>
region between the two shown in pink or red.  Time goes from top to bottom,
showing messages being passed back and forth from the two sides.</p>

<p>The figure also shows how the hand-shaking method works.  The first thing
that happens is that a request is made from the old clock domain and then
passed to the new clock domain.  The request goes through the
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>
region using the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
chain method described above.  Once it gets to the new clock domain,
an acknowledgement is sent back–also going through the same
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
chain method, but this time with the old clock driving the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a> chain.
Once the acknowledgement has been received, the request signal may be dropped
(cleared), at which point the new clock domain drops its acknowledgement flag.</p>

<p>One trick of this method, though, is that no new request can be made until the
acknowledgement has been cleared.  This “I’m busy” region is shown in Fig 4
as a bright red bar, during which time no new requests may be sent.</p>

<p>Let’s walk through this approach in Verilog, shall we?</p>

<p>First, something starts this off by setting the <code class="language-plaintext highlighter-rouge">req</code> register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">old_clock</span><span class="p">)</span>
	<span class="n">req</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">some_logic</span><span class="p">);</span></code></pre></figure>

<p>This logic isn’t quite complete, but we’ll come back to it in a moment.</p>

<p>Then, on the new clock, a
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
chain is used to receive this
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>
request from the old clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">new_clock</span><span class="p">)</span>
	<span class="o">{</span> <span class="n">new_req</span><span class="p">,</span> <span class="n">xreq_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">xreq_pipe</span><span class="p">,</span> <span class="n">req</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Once the request has been received, it is immediately sent back to the original
clock in the form of an acknowledgement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">old_clock</span><span class="p">)</span>
	<span class="o">{</span> <span class="n">old_ack</span><span class="p">,</span> <span class="n">xack_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">xack_pipe</span><span class="p">,</span> <span class="n">new_req</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Only when this acknowledgement is low again are we ready to send any subsequent
requests.  Hence, we are busy from the time the original request is sent until
the time later when the acknowledgement is cleared.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">busy</span> <span class="o">=</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">old_ack</span><span class="p">);</span></code></pre></figure>

<p>This then gives us the final logic we need to create our request in the
first place.  We can send a request any time we are not busy, and
some event has happened that we wish to place on the other clock domain.
Once the acknowledgement has been received, we drop our request line
and wait for the acknowledgement to be dropped as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">old_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">some_event</span><span class="p">))</span>
		<span class="n">req</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_ack</span><span class="p">)</span>
		<span class="n">req</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Indeed, this is the basic handshaking method used within my
<a href="https://github.com/ZipCPU/wbscope">Wishbone scope</a>
in order to send information, such as a reset scope command, from the bus clock
domain to the data clock domain and back again.</p>

<h2 id="signaling-a-rare-event">Signaling a (rare) event</h2>

<p>From here, we can build upon this idea to send an “event” from one domain
to another.  By “event”, I mean something that will only ever be true for
a single clock cycle.  To work, though, the event will need to be rare
enough that the
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>
circuit isn’t still busy handling the last event.</p>

<table align="center" style="float: none"><caption>Fig 5: Passing an event across clocks</caption><tr><td><img src="/img/cdc-stb.svg" alt="An event crossing clock domains: first it triggers the request, and then the rising change in the acknowledgement triggers the event in the new domain" width="480" /></td></tr></table>

<p>The basic method, shown in Fig 5 above, is almost identical to what we did
before.  There are only two basic differences.</p>

<p>The first difference is that we trigger off of a specific single-clock
event, rather than off of some yet to be defined logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">old_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_stb</span><span class="p">))</span>
		<span class="n">req</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_ack</span><span class="p">)</span>
		<span class="n">req</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">assign</span>	<span class="n">busy</span> <span class="o">=</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">old_ack</span><span class="p">);</span></code></pre></figure>

<p>The second difference is that we need to recognize a rising request signal
within the new clock domain.  This means that we need to keep track of the last
state of the request signal, <code class="language-plaintext highlighter-rouge">last_req</code>, in our pipeline request logic as well
as the rest of the pipeline request logic we used before.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">new_clock</span><span class="p">)</span>
	<span class="o">{</span> <span class="n">last_req</span><span class="p">,</span> <span class="n">new_req</span><span class="p">,</span> <span class="n">xreq_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">new_req</span><span class="p">,</span> <span class="n">xreq_pipe</span><span class="p">,</span> <span class="n">req</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Then, any time the <code class="language-plaintext highlighter-rouge">last_req</code>uest is low, but a <code class="language-plaintext highlighter-rouge">new_req</code>uest has been
made, we know we need to generate the event under the new clock domain.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">new_clock</span><span class="p">)</span>
	<span class="n">o_stb</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">last_req</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">new_req</span><span class="p">);</span></code></pre></figure>

<p>You can use this approach to send triggers from one clock domain,
such as the video refresh interrupt created within the video clock domain
to the interrupt controller which may be within the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
clock domain.</p>

<h2 id="sending-a-group-of-wires-at-once">Sending a group of wires at once</h2>

<p>You can also use this transfer approach to send a group of wires at once.</p>

<p>This was the approach I used when I wanted to send a byte’s worth of data
at once from the
<a href="https://www.raspberrypi.org/products/raspberry-pi-2-model-b/">RPi</a>
to the <a href="http://www.latticesemi.com/iCE40">iCE40</a> on top of my
<a href="http://www.icoboard.org">ICO board</a>.  Since I was designing the
interface with no idea of how fast the two clocks would be relative to
one another, I needed a handshaking method to control the transfer of all
8-bits at once.  You can see the project that uses this approach
<a href="https://github.com/ZipCPU/icozip">here</a>.  The
<a href="https://www.raspberrypi.org/products/raspberry-pi-2-model-b/">RPi</a>
software can be found in <a href="https://github.com/ZipCPU/icozip/blob/master/sw/host/netpport.cpp">sw/host/netpport.cpp</a>,
whereas the Verilog half of the interface can be found in
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/pport/pport.v">pport/pport.v</a>.</p>

<p>How would we handle that?</p>

<p>The first step would be to copy the data to a transfer region, and then
to set a “pre-transfer” signal indicating that the data was valid.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">old_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">valid_data</span><span class="p">))</span>
		<span class="n">transfer_data</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">;</span>
		<span class="n">valid_data</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_ack</span><span class="p">)</span>
		<span class="n">valid_data</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>This needs to be done on the clock before the transfer starts.</p>

<p>You can then perform a handshake to the other clock domain.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">old_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">valid_data</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="n">req</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_ack</span><span class="p">)</span>
		<span class="n">req</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">assign</span>	<span class="n">busy</span> <span class="o">=</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">old_ack</span><span class="p">);</span></code></pre></figure>

<p>Once the changed acknowledgement has been received, the data can be copied
into <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s
controlled by the new clock domain.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">new_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">last_req</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">new_req</span><span class="p">))</span>
		<span class="n">o_data</span> <span class="o">&lt;=</span> <span class="n">transfer_data</span><span class="p">;</span></code></pre></figure>

<p>No <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
chain is necessary to receive the transfer data, since the
hand shake approach has already guaranteed that the transfer data is valid.</p>

<p>One other difference, though, is that you don’t want to acknowledge the other
side until the transfer has been completed.  Hence, you would have the
following for the acknowledgement,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">old_clock</span><span class="p">)</span>
	<span class="o">{</span> <span class="n">old_ack</span><span class="p">,</span> <span class="n">xack_pipe</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">xack_pipe</span><span class="p">,</span> <span class="n">last_req</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>This guarantees that the data will remain stable throughout the copy.</p>

<p>While this has worked quite well for me for some time, I did come back to this
process in a <a href="/blog/2020/10/03/tfrvalue.html">later article</a>,
though, to discuss how this basic approach can be improved upon and made even
faster by removing the clearing pass through the synchronizers.</p>

<h2 id="sending-a-stream-of-values">Sending a stream of values</h2>

<p>What we haven’t discussed is the idea of sending a stream of values from one
clock to the next.</p>

<p>Perhaps you are trying to write video from a camera to memory.  In this case,
you might be receiving 24-bit pixels at a high (pixel) clock rate, but that
you need to write <code class="language-plaintext highlighter-rouge">128-bits</code> of data at a time to your
<a href="https://en.wikipedia.org/wiki/DDR3-SDRAM">DDR3-SDRAM</a> memory at a lower rate.</p>

<table style="float: right"><caption>Fig 6: A FIFO can cross clock domains</caption><tr><td><img src="/img/cdc-fifo-plain.svg" alt="A FIFO can cross clock domains" width="320" /></td></tr></table>

<p>Alternatively, you might be wanting to store and forward results from a
high speed <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">analog to digital converter
(A/D)</a> across an
ethernet port.  Indeed, the example applies for a low speed <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">A/D
Converter</a>
as well!  Perhaps you are consistently sending data to the
new clock domain, but you are only reading it out rarely, and in high speed
bursts at that.</p>

<p>In both examples, you have a stream of data that needs to be moved from one
clock domain to another.</p>

<p>The solution to this problem is to use a
<a href="/blog/2017/07/29/fifo.html">FIFO</a>, such as the one shown in
Fig 6 above.  You may recall that <a href="/blog/2017/07/29/fifo.html">we’ve discussed FIFOs
before</a>.
Using such a <a href="/blog/2017/07/29/fifo.html">FIFO</a>,
you can drive the input at one rate and the output at another.</p>

<table style="float: left; padding: 15px;"><caption>Fig 7: FIFOs need to manage other signals as well</caption><tr><td><img src="/img/cdc-fifo.svg" alt="A FIFO can cross clock domains" width="420" /></td></tr></table>

<p>The problem, though, is how do you build a
<a href="/blog/2017/07/29/fifo.html">FIFO</a> that
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">crosses clock domains</a>?
Specifically, you need to keep the source from writing if the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
is full, and you need to keep the sink from reading the output when the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
is empty–and both of these conditions depend on knowing information from the
other side of the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>.  Not only that,
but you need to be able to handle the
<a href="https://en.wikipedia.org/wiki/Clock_domain_crossing">CDC</a>
with your reset circuitry as well.</p>

<p>This, however, will need to remain <a href="/blog/2018/07/06/afifo.html">the topic of a future post</a>.</p>

<p>Until then, if you are more interested in the topic,
Clifford E. Cummings of
<a href="http://www.sunburst-design.com">Sunburst Design</a>
has written a <a href="http://www.sunburst-design.com/papers/CummingsSNUG2008Boston_CDC.pdf">wonderful, and rather extensive,
paper</a>
on the topic.  I suspect you will find it to be very valuable–I certainly have.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>We know that we have passed from death unto life, because we love the brethren. He that loveth not his brother abideth in death. (1John 3:14)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
