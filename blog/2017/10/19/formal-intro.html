<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>My first experience with Formal Methods</title>
  <meta name="description" content="Clifford Wolf has written a nice tool, yosys-smtbmc, based upon hisyosys synthesys tool, that allows you to applyformal methodsto your Verilog code.  The pro...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2017/10/19/formal-intro.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">My first experience with Formal Methods</h1>
    <p class="post-meta"><time datetime="2017-10-19T00:00:00-04:00" itemprop="datePublished">Oct 19, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Clifford Wolf has written a nice tool, <code class="language-plaintext highlighter-rouge">yosys-smtbmc</code>, based upon his
<a href="http://www.clifford.at/yosys">yosys</a> synthesys tool, that allows you to apply
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a>
to your Verilog code.  The promise of
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a>
is that you can then mathematically <em>prove</em> that your code works, or if not
then the formal solver should be able to tell you where your code is failing.</p>

<p>I’ve only been working with these
<a href="https://en.wikipedia.org/wiki/Formal_methods">methods</a>
for a week or so, but already there are some things I can share.</p>

<p>The first project I tried applying these formal methods to was a simple
<a href="https://github.com/ZipCPU/wbpmic">SPI-based A/D converter</a>.  This particular
controller is designed to interact with a
<a href="https://store.digilentinc.com">Digilent</a> <a href="https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/">product containing a
MEMs based microphone</a>.  I’ve had
<a href="https://github.com/ZipCPU/wbpmic">the project</a>
built for some time, although I’ll admit I’ve never actually done anything
more with it than plug it in.</p>

<p>Since <a href="https://github.com/ZipCPU/wbpmic">the project</a> is simple enough, I
thought I’d try applying
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a>
to it, to <em>prove</em> that my controller worked.  Sure, I had a <a href="https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/wbmic_tb.cpp">test
bench</a>
that I had built some time earlier to convince me that the project worked.
The <a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/wbmic.v">design</a> worked
well against this <a href="https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/wbmic_tb.cpp">test
bench</a>,
so I didn’t expect to find many problems using
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a>.</p>

<p>Imagine my surprise when I found several bugs instead.  Not only that, many of
those bugs were within my <a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">FIFO
implementation</a>–something
that I’d passed from one project to another for some time.  You see, when I
<a href="/blog/2017/07/29/fifo.html">built my FIFO</a> I only tested
it in a fashion such as a “reasonable” person might use it.  Under this
“reasonable use” scenario, the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
had done well.</p>

<p>The formal prover, however, didn’t limit itself to what I considered
“reasonable” usage of the
<a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">FIFO</a>.
It created underruns and overruns, wrote to the
<a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">FIFO</a>
when it was full, and read from the
<a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">FIFO</a>
when it was empty.
It even wrote <em>and</em> read from the empty
<a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">FIFO</a>
on the same clock, and it wrote and read from the full
<a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">FIFO</a>
on the same clock as well.
When the internal logic didn’t “match” the criteria I gave the solver, it then
showed me where <a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">my FIFO
code</a>
didn’t properly handle these conditions.</p>

<p>I guess I just didn’t have that much creativity when I created my <a href="https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/wbmic_tb.cpp">test
bench</a>
in the first place.</p>

<p>Was the result worth it?  Keep in mind, I’ve never used
<a href="https://en.wikipedia.org/wiki/Formal_methods">these methods</a>
before.  So did I think it was worth it?  I think so.  I haven’t “proved”
all of my projects yet, nor do I know if I will be able to, but I have added
proofs to some of them—and found bugs as a result.</p>

<p>Today, though, I’d like to share some of what I have learned.</p>

<h2 id="state-sets">State Sets</h2>

<p>If you’ve never worked with
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a>
before, the basic concept is that you will
go through your code and declare which states are valid and which are not.
You’ll then use a theorem prover to <em>mathematically</em> <em>prove</em> that you can
<em>never</em> enter an invalid state from a valid one.  If the prover cannot
prove this, then typically you will have either a bug in your
code, or a bug in your formal assertions.</p>

<p>You can think of the “state” as the values in all of your
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s,
together with the values of all of your inputs.</p>

<table style="float: right"><caption>Fig 1: Bounded Model Check</caption><tr><td><img src="/img/formal-bmc.svg" alt="BMC starts from a valid initial state, then wanders to see if it can get to an illegal state" width="320" /></td></tr></table>

<p>The first step in yosys-smtbmc based theorem solving is the <em>bounded model
checker</em> (BMC), figuratively shown in Fig 1.  This
part of the theorem solver starts your design in its initial state,
and then walks through all of the state transitions that it can, stepping your
logic forward from one time step to the next, just to see if any set of
conditions will drive your model to an invalid state.</p>

<p>This may be the most straightforward part of using yosys-smtbmc, and the
easiest to understand.  The problem with the BMC step is that your time is
limited.  Therefore, you will only want to allow the BMC step to check some
finite number of transitions.  This number needs to be chosen carefully,
otherwise there may be states you might eventually get into over time that it
won’t find.</p>

<p>You can also find these additional states via the second step:
the <em>induction</em> step.</p>

<p>The induction step is just like the <a href="https://en.wikipedia.org/wiki/Mathematical_induction">mathematical
induction</a> you learned in
<a href="https://en.wikipedia.org/wiki/Precalculus">Pre-calculus</a>.  You
first prove that some property is true for the first value,
<code class="language-plaintext highlighter-rouge">n=1</code>.  This was the purpose of the BMC step above.  If it is true for this
base case, you then proceed with the inductive step.  This step assumes that
your logic is within some initially valid state, say state <code class="language-plaintext highlighter-rouge">n</code>, and it then
tries to prove that your logic will only transition to a valid state,
say state <code class="language-plaintext highlighter-rouge">n+1</code>.</p>

<p>That’s the idea.</p>

<table style="float: left; padding: 15px"><caption>Fig 2: The induction step</caption><tr><td><img src="/img/formal-induction.svg" alt="Induction starts from a random valid state, and tries to prove that the state will never become invalid" width="320" /></td></tr></table>

<p>In practice, I’ve struggled with this induction step.  The challenge
to the designer with the induction step is that  you have to declare <em>every</em>
unreachable state as invalid, or it might start processing from an
unreachable state you aren’t expecting.  As figure 2 shows, states
that are neither valid nor invalid,
but still states that the design will never reach, may easily become starting
states for induction.  It is therefore up to the designer to clearly
indicate that all states must be either valid or invalid.</p>

<table style="float: right"><caption>Fig 3: Unreachable states should be invalid</caption><tr><td><img src="/img/formal-unreachable.svg" alt="To make induction work, all unreachable states should be declared as invalid" width="320" /></td></tr></table>

<p>Let me try to explain this a touch better.  In a moment we’ll go over some
System Verilog statements that
<a href="http://www.clifford.at/yosys">yosys</a>
will recognize.  These statements declare only the state that you cannot
get to.  They do this by either reducing the size of the total state space
examined, or by declaring particular states to be illegal.  That part is the
job of the formal specification designer.  The job of the
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal method</a>
is to determine which states may be reached, and to then cross check these
states against the illegal ones.</p>

<p>Perhaps a simple table, such as the one in Fig 4, might help to explain this.</p>

<table style="float: left; padding: 15px;"><caption>Fig 4: Unreachable vs Invalid states</caption><tr><td><img src="/img/formal-chart.svg" alt="" width="420" /></td></tr></table>

<p>What you want to know, as a designer, is whether or not there is any way that
you might reach an invalid state from a valid one.  Hence, you want to know if a
particular illegal state is reachable from a valid state.  This is the
purpose of <a href="https://en.wikipedia.org/wiki/Formal_methods">formal method</a>s.</p>

<p>The part I struggled with while working through the induction step is that any
state that isn’t declared to be invalid might be a starting point for
induction–even if the state is unreachable.</p>

<p>This should help give you an idea, should you try working with
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal method</a>s
yourself, that you need to make certain that unreachable states
are either declared to be invalid or removed from the set of possible states.</p>

<p>Speaking of, that’s our next step: discussing how to declare states to be
invalid when using <a href="http://www.clifford.at/yosys">yosys</a>.</p>

<h2 id="formal-declarations">Formal Declarations</h2>

<p><a href="http://www.clifford.at/yosys">yosys</a>
can be made to understand some basic formal statements, drawn from a
subset of the System Verilog formal verification language.  This can be
frustrating for a new user of
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal method</a>s with
<a href="http://www.clifford.at/yosys">yosys</a>,
since most of the material on line discusses the full System Verilog formal
description language subset.  What <a href="http://www.clifford.at/yosys">yosys</a>
supports is much less than that.  Basically,
<a href="http://www.clifford.at/yosys">yosys</a> supports <code class="language-plaintext highlighter-rouge">assert()</code>, <code class="language-plaintext highlighter-rouge">assume()</code>,
<code class="language-plaintext highlighter-rouge">restrict()</code>, and some expressions about transitions.  Let’s examine those
formal verification statements here.</p>

<p>The first statement of interest is the <code class="language-plaintext highlighter-rouge">assert()</code> statement.  At first blush,
this statement works very much like the <code class="language-plaintext highlighter-rouge">assert()</code> statement within C/C++.
The value given to the <code class="language-plaintext highlighter-rouge">assert()</code> statement must be true, or you your design
isn’t working as desired.  <code class="language-plaintext highlighter-rouge">assert()</code>s do more than that, though.
<code class="language-plaintext highlighter-rouge">assert()</code>s declare states that are invalid within your design.</p>

<p>We’ll come back to that thought in a moment.</p>

<p>The other thing you need to know about <code class="language-plaintext highlighter-rouge">assert()</code>s is that within a simulation,
if the <code class="language-plaintext highlighter-rouge">assert()</code> is ever not true, the simulation will halt on a failure.
This allows you focus on what caused the problem within your design.</p>

<p>The next basic statement is the <code class="language-plaintext highlighter-rouge">assume()</code> statement.  This statement is like
the <code class="language-plaintext highlighter-rouge">assert()</code>, but with the exception that the theorem prover doesn’t try to
prove that the <code class="language-plaintext highlighter-rouge">assume()</code> statement is true.  Instead, it forces the <code class="language-plaintext highlighter-rouge">assume()</code>
to be true.  Any logic path that would cause the <code class="language-plaintext highlighter-rouge">assume()</code> to be false
is quietly culled.  From the perspective of the state space that will be
examined, the <code class="language-plaintext highlighter-rouge">assume()</code> statement removes particular states from the
realm of possibilities.</p>

<p>For example,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">last_clk</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">assume</span><span class="p">(</span><span class="n">i_clk</span> <span class="o">==</span> <span class="o">!</span><span class="n">last_clk</span><span class="p">);</span></code></pre></figure>

<p>will force the <code class="language-plaintext highlighter-rouge">i_clk</code> input to the design to toggle with every
simulation step (that’s the meaning of the <code class="language-plaintext highlighter-rouge">$global_clock</code>–it’s true on
every change of the time step).  States and state transitions where the
clock doesn’t toggle are just quietly removed from the realm of possibility.</p>

<p><code class="language-plaintext highlighter-rouge">assume()</code> statements have one more feature: if during a simulation the
condition is <em>invalid</em>, the simulation will halt with an error just as it would
if the <code class="language-plaintext highlighter-rouge">assert()</code> statement were false.</p>

<p>The <code class="language-plaintext highlighter-rouge">restrict()</code> instruction is similar to the <code class="language-plaintext highlighter-rouge">assume()</code> instruction.
Like <code class="language-plaintext highlighter-rouge">assume()</code>, <code class="language-plaintext highlighter-rouge">restrict()</code> also reduces the size of the state space that
the theorem prover needs to work within.  In that way, a <code class="language-plaintext highlighter-rouge">restrict</code> statement
is much like an <code class="language-plaintext highlighter-rouge">assume()</code> statement.
However, unlike the <code class="language-plaintext highlighter-rouge">assume()</code> statement, the <em>simulator</em> will ignore any
<code class="language-plaintext highlighter-rouge">restrict()</code> statements within your code.</p>

<p>I’ve also found several functions to be very valuable: <code class="language-plaintext highlighter-rouge">$past()</code>,
<code class="language-plaintext highlighter-rouge">$stable()</code>, <code class="language-plaintext highlighter-rouge">$rose()</code>, and <code class="language-plaintext highlighter-rouge">$fell()</code>.  Since these are important,
let’s work our way through them.</p>

<p>The <code class="language-plaintext highlighter-rouge">$past()</code> function has the form of <code class="language-plaintext highlighter-rouge">$past(expression, N)</code>, for arbitrary
expressions, and positive integers, <code class="language-plaintext highlighter-rouge">N</code>.  This statement returns the value
of the expression <code class="language-plaintext highlighter-rouge">N</code> clocks ago.  Hence, <code class="language-plaintext highlighter-rouge">$past(expression,1)</code> references what
the expression evaluated to during the last clock.  The number of clocks
parameter, <code class="language-plaintext highlighter-rouge">N</code>, defaults to one, so <code class="language-plaintext highlighter-rouge">$past(expression)</code> is just the same as
<code class="language-plaintext highlighter-rouge">$past(expression,1)</code>.</p>

<p>System Verilog allows two more arguments to the <code class="language-plaintext highlighter-rouge">$past()</code> function for a total
of four.  Not so with <a href="http://www.clifford.at/yosys">yosys</a>, however you
may not find these extra arguments necessary either.  For example, the fourth
System Verilog argument to the <code class="language-plaintext highlighter-rouge">$past()</code> function specifies what clock and
clock edge you are referencing the <code class="language-plaintext highlighter-rouge">$past()</code> expression from.  Instead,
<a href="http://www.clifford.at/yosys">yosys</a>
only allows expressions of <code class="language-plaintext highlighter-rouge">$past()</code> values within a clocked
always block, and so it uses the clock specified in the always statement to
define the clock the <code class="language-plaintext highlighter-rouge">$past()</code> function is relative to.</p>

<p>There is one other trick with the <code class="language-plaintext highlighter-rouge">$past()</code> function: prior to the first
clock, the $past value is undefined and often assumed to be zero by many
formal theorem solvers.  You’ll need to be careful, therefore, not to expect
the $past value to reference any <code class="language-plaintext highlighter-rouge">initial</code> value within your logic.</p>

<p>For this reason, I’ve gotten in the habit of creating a signal to tell me if
the past value is valid, such as:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">f_past_valid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">f_past_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>I can then use <code class="language-plaintext highlighter-rouge">f_past_valid</code> as part of an expression to determine whether or
not the inputs to a <a href="/zipcpu/2017/05/29/simple-wishbone.html">wishbone
slave</a> will not
change once the strobe goes high until the stall line is low.  Remember how
<a href="/zipcpu/2017/05/29/simple-wishbone.html">we discussed</a>
that with <a href="/doc/wbspec_b4.pdf">wishbone</a> nothing happens
until <code class="language-plaintext highlighter-rouge">(i_wb_stb)&amp;&amp;(!o_wb_stall)</code>?  This means that once the
wishbone master
asserts the strobe signal, <code class="language-plaintext highlighter-rouge">i_wb_stb</code>, that it is likely to wait for the
<code class="language-plaintext highlighter-rouge">o_wb_stall</code> signal to lower before changing the bus request details.
To capture this thought, we’ll assume that once <code class="language-plaintext highlighter-rouge">i_wb_stb</code>
goes high, none of the bus request information will change until the
clock after <code class="language-plaintext highlighter-rouge">o_wb_stall</code> goes low:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">);</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_wb_we</span>   <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_wb_addr</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_addr</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_wb_data</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_wb_sel</span>  <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_sel</span> <span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>Alternatively, instead of assuming that the current value was equal to the
last value, we could have instead assumed that these values were <code class="language-plaintext highlighter-rouge">$stable()</code>
for the same effect:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">);</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_addr</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_sel</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>The last of the basic commands you’ll want to know is the <code class="language-plaintext highlighter-rouge">$rose()</code> command.
This command returns true or false depending on whether the signal given to
it has risen (positive edge) over the last clock period or not.</p>

<p>This particular function is <em>very</em> useful for telling the theorem prover that
your inputs are only going to change on the positive edge of the clock,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="c1">// If it isn't the positive edge ...</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_wb_clk</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="c1">// Then nothing changes</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">);</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_addr</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_sel</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>A similar <code class="language-plaintext highlighter-rouge">$fell()</code> primitive exists as well for testing negative clock edges.</p>

<p><a href="http://www.clifford.at/yosys">yosys</a> provides one more helpful feature.
Anytime you use
<a href="http://www.clifford.at/yosys">yosys</a>
to generate a formal description of your code,
<a href="http://www.clifford.at/yosys">yosys</a> defines the <code class="language-plaintext highlighter-rouge">FORMAL</code> flag.  Hence, you
can surround your formal properties with <code class="language-plaintext highlighter-rouge">ifdef</code>s, as in:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
<span class="c1">// ...</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">illegal_state</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="cp">`endif</span></code></pre></figure>

<p>These, therefore, are your basic  formal declaration statements:
<code class="language-plaintext highlighter-rouge">assert()</code>, <code class="language-plaintext highlighter-rouge">assume()</code>, and <code class="language-plaintext highlighter-rouge">restrict()</code>.  They are helped by the functions
<code class="language-plaintext highlighter-rouge">$stable()</code>, <code class="language-plaintext highlighter-rouge">$past()</code>, <code class="language-plaintext highlighter-rouge">$rose()</code>, <code class="language-plaintext highlighter-rouge">$fell()</code>, and perhaps some others that I
haven’t learned yet.  (Remember, this is only my first week.)  <code class="language-plaintext highlighter-rouge">assert()</code>
declares statements to be illegal, and <code class="language-plaintext highlighter-rouge">assume()</code> and <code class="language-plaintext highlighter-rouge">restrict()</code> are used
to limit the size of the state space.</p>

<p>With these basic principles, let’s look at some formal theorem proving
concepts.</p>

<h2 id="basic-concept">Basic concept</h2>

<p>The basic approach to formally describing your program is to <code class="language-plaintext highlighter-rouge">assume()</code> that
the inputs will be valid, and then to <code class="language-plaintext highlighter-rouge">assert()</code> that the outputs are valid.
You may also wish along the way to <code class="language-plaintext highlighter-rouge">assert()</code> particular internal states
are valid as well.</p>

<p>This works until you aggregate up one level, so that you have a higher level
module instantiating a lower level one.  In that case, you want to <code class="language-plaintext highlighter-rouge">assert()</code>
the values that will be passed to the lower level module rather than
<code class="language-plaintext highlighter-rouge">assume()</code>ing them.</p>

<h2 id="a-fifo-example">A FIFO example</h2>

<p>Let’s work our way through a simple example–that of a
<a href="/blog/2017/07/29/fifo.html">FIFO</a>.
In this case, we’ll examine the
<a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">FIFO</a>
I just worked with for my <a href="https://github.com/ZipCPU/wbpmic">SPI-based microphone
ADC</a> core.</p>

<p>As you may remember from <a href="/blog/2017/07/29/fifo.html">our last
FIFO</a> discussion, a
<a href="/blog/2017/07/29/fifo.html">FIFO</a> depends upon two
memory pointers: the write pointer, <code class="language-plaintext highlighter-rouge">r_first</code>, and the read pointer, <code class="language-plaintext highlighter-rouge">r_last</code>.
The only time <code class="language-plaintext highlighter-rouge">r_first</code> and <code class="language-plaintext highlighter-rouge">r_last</code> are equal is when the
<a href="/blog/2017/07/29/fifo.html">FIFO</a> is empty.
Likewise, the number of items within the
<a href="/blog/2017/07/29/fifo.html">FIFO</a> is
determined by <code class="language-plaintext highlighter-rouge">r_first</code> minus <code class="language-plaintext highlighter-rouge">r_last</code>.</p>

<p>There are some other rules associated with these two variables.
The first is that we cannot be allowed to read from the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
any time it is empty.  The second rule is that we cannot
write to the <a href="/blog/2017/07/29/fifo.html">FIFO</a> when it
is full, unless we are also reading from the
<a href="/blog/2017/07/29/fifo.html">FIFO</a> at the same time.
Any attempt to read from an empty
<a href="/blog/2017/07/29/fifo.html">FIFO</a>, or write to a full
<a href="/blog/2017/07/29/fifo.html">FIFO</a> should generate an error.</p>

<p>In order to keep the state transitions from being dependent upon the
number of items in the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>, I pre-compute two values:
<code class="language-plaintext highlighter-rouge">will_overflow</code>, which is true if the next write will overflow the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>, and
<code class="language-plaintext highlighter-rouge">will_underflow</code>, which will be true if the next read will read from an
empty <a href="/blog/2017/07/29/fifo.html">FIFO</a>.</p>

<p>Further, <a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">this particular
FIFO</a> also returns
a status value indicating 1) how many items are in the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>,
2) whether or not the FIFO is non-empty, and 3) whether or not the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
is past half-full.</p>

<p>All of these details may also be derived from <code class="language-plaintext highlighter-rouge">r_first</code> and <code class="language-plaintext highlighter-rouge">r_last</code> alone.  If
they don’t match, the <a href="/blog/2017/07/29/fifo.html">FIFO</a>
is in an illegal state.  Therefore, these properties are a perfect match
for learning
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal method</a>s</p>

<p>The first step is to gate all of our work so that the synthesis tool will
ignore it, unless we are working with the
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal verification methods</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
<span class="c1">// ... ALl of our formal specifications go here</span>
<span class="cp">`endif</span> <span class="c1">// This goes at the end of our formal specification</span></code></pre></figure>

<p>Next, within this <code class="language-plaintext highlighter-rouge">FORMAL</code> block we want to make certain that the assumptions
we are going to make regarding our inputs will become asserts when this core
is included into a larger design.  We’ll do this by creating an <code class="language-plaintext highlighter-rouge">ASSUME</code> macro
that we can use to constrain our inputs.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">SMPLFIFO</span>
<span class="cp">`define</span>	ASSUME	assume<span class="cp">
`else</span>
<span class="cp">`define</span>	ASSUME	assert<span class="cp">
`endif</span></code></pre></figure>

<p>Remember that you only want to constrain via <code class="language-plaintext highlighter-rouge">ASSUME</code> statements about
parameters that can be set by a higher level module, not external inputs.</p>

<p>Earlier, I described what it would take to assume that the clock toggles.
We’ll repeat that here.  We’re also going to insist that this
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
starts in it’s reset state, by insisting that the <code class="language-plaintext highlighter-rouge">i_rst</code> line is initially
valid.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span> <span class="n">restrict</span><span class="p">(</span><span class="n">i_rst</span><span class="p">);</span>

<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">restrict</span><span class="p">(</span><span class="n">i_clk</span> <span class="o">==</span> <span class="o">!</span><span class="n">f_last_clk</span><span class="p">);</span>
	<span class="n">f_last_clk</span> <span class="o">&lt;=</span> <span class="n">i_clk</span><span class="p">;</span></code></pre></figure>

<p>Before leaving this beginning statement, let’s also insist that our
inputs <em>only</em> change on the positive edge of the clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_clk</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="cp">`ASSUME</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_rst</span><span class="p">));</span>
		<span class="cp">`ASSUME</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wr</span><span class="p">));</span>
		<span class="cp">`ASSUME</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_data</span><span class="p">));</span>
		<span class="cp">`ASSUME</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_rd</span><span class="p">));</span>
	<span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>We also discussed above the need to know whether the <code class="language-plaintext highlighter-rouge">$past()</code> function
would return valid results.  We’ll use the <code class="language-plaintext highlighter-rouge">f_past_valid</code> register for this
purpose.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">f_past_valid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">f_past_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>This also highlights the fact that your formal verification logic may have
and use registers, just like the rest of your logic–even though you won’t
be using it within your design other than for formal verification.</p>

<p>Next, let’s look at making sure that our helper logic works.</p>

<p>First, the <code class="language-plaintext highlighter-rouge">r_fill</code> output should be equal to the number of
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
memory entries that are full.  This is given by the difference between
<code class="language-plaintext highlighter-rouge">r_first</code> and <code class="language-plaintext highlighter-rouge">r_last</code>.  Above, we chose to use a clocked register to hold this
value.  We did this for timing reasons, but there is the possibility that
we got this wrong.  So, let’s check it here.  Formally, one might say that
the state where <code class="language-plaintext highlighter-rouge">r_fill</code> doesn’t equal this difference is an illegal state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">f_fill</span> <span class="o">=</span> <span class="n">r_first</span> <span class="o">-</span> <span class="n">r_last</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">f_fill</span> <span class="o">==</span> <span class="n">r_fill</span><span class="p">);</span></code></pre></figure>

<p>Now, let’s move on to our empty flag.  Any time the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
is empty, we want to set the <code class="language-plaintext highlighter-rouge">will_underflow</code> flag.  In addition, we want
<code class="language-plaintext highlighter-rouge">o_empty_n</code> to be true any time we are not empty.  As I mentioned before, the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
is empty any time <code class="language-plaintext highlighter-rouge">r_first</code> is equal to <code class="language-plaintext highlighter-rouge">r_last</code>.  We can use <code class="language-plaintext highlighter-rouge">f_fill</code> from
above for this purpose.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">f_fill</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">will_underflow</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_empty_n</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">will_underflow</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_empty_n</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>In a similar value, any time the fill is one less than the number of items
in the buffer, then the buffer is “full”.  Let’s make sure we got that logic
right too.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">f_fill</span> <span class="o">==</span> <span class="o">{</span><span class="p">(</span><span class="n">LGFLEN</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">will_overflow</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">will_overflow</span><span class="p">);</span></code></pre></figure>

<p>The
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
<a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">code</a>
also has a value, <code class="language-plaintext highlighter-rouge">r_next</code>, which is supposed to
reference the next value to be read.  To know if we got this right, let’s add
one to the <code class="language-plaintext highlighter-rouge">r_last</code> pointer,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">f_next</span> <span class="o">=</span> <span class="n">r_last</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>and then look to see if <code class="language-plaintext highlighter-rouge">r_next</code> equals this as desired,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span><span class="p">(</span><span class="n">r_next</span> <span class="o">==</span> <span class="n">f_next</span><span class="p">);</span>
<span class="k">end</span></code></pre></figure>

<p>Finally, let’s examine the pointers under overflow and underflow conditions.
First, on any reset, both pointers will be set to zero and any output error
will be cleared.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">f_past_valid</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_rst</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_err</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>If we are not in reset, we might have an underflow.  Let’s check.  If the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
was empty on the last clock, <em>and</em> if there was a request to read from the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
on that clock, then we had an underflow.  In that case, assert that the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
read pointer, <code class="language-plaintext highlighter-rouge">r_last</code>, has not changed as a result.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Underflow detection</span>
		<span class="k">if</span> <span class="p">(($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_rd</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">r_fill</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="k">begin</span>
			<span class="c1">// This core doesn't report underflow errors,</span>
			<span class="c1">// but quietly ignores them</span>
			<span class="c1">//</span>
			<span class="c1">// assert(o_err);</span>
			<span class="c1">//</span>
			<span class="c1">// On an underflow, we need to be careful not</span>
			<span class="c1">// to advance the pointer.</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_last</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r_last</span><span class="p">));</span>
		<span class="k">end</span></code></pre></figure>

<p>Had this pointer changed, the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
might accidentally jump from the empty state to the full state with garbage in
the buffer.  We want to avoid this.</p>

<p>We do almost the same thing on an overflow condition, but there are just a
couple differences.
First, in the case of a read and write on the same clock while we are full,
no overflow has taken place.  Hence we need to check that a write without
a read has taken place.  That’s the first difference.  The second difference
is that this core reports overflow conditions, but not underflow conditions.
Hence, we assert that <code class="language-plaintext highlighter-rouge">o_err</code> is true on any overflow.  Likewise, on any
overflow we also assert that the <code class="language-plaintext highlighter-rouge">r_first</code> pointer hasn’t changed.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">//</span>
		<span class="c1">// Overflow detection</span>
		<span class="k">if</span> <span class="p">(($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wr</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_rd</span><span class="p">))</span>
				<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">will_overflow</span><span class="p">)))</span>
		<span class="k">begin</span>
			<span class="c1">// Make sure we report this result</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_err</span><span class="p">);</span>

			<span class="c1">// Make sure we didn't advance our write</span>
			<span class="c1">// pointer on overflow</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_first</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r_first</span><span class="p">));</span>
		<span class="k">end</span>
	<span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>As with the underflow, a pointer change during an overflow condition can be
catastrophic as well.  It could cause the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
to suddenly become empty, losing any of the data within it.  This formal
check about tells the theorem prover that doing so would be illegal, and that
we want to know if anything would create such a condition.</p>

<p>What we haven’t discussed are the
<a href="http://symbiyosys.readthedocs.io/en/latest/quickstart.html">instructions for installing</a>
<a href="http://www.clifford.at/yosys">yosys</a>,
<a href="https://symbiyosys.readthedocs.io/en/latest/">SymbiYosys</a>,
and the various theorem provers.  These may be found
<a href="http://symbiyosys.readthedocs.io/en/latest/quickstart.html">on line</a>.
Neither have we discussed the
<a href="https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/Makefile">Makefile</a>
I used to coordinate the proof, nor the <a href="https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/smplfifo.ys">yosys
config</a>
that I used.  Feel free to examine these on your own if you would like.</p>

<h2 id="what-did-i-find">What did I find?</h2>

<p>You may recall from earlier that I found several errors in my
<a href="/blog/2017/07/29/fifo.html">FIFO</a> as a result of using
these methods.  If you are reading this, then you may be wondering just how
significant those errors were.  Here are some of the things I found:</p>

<ul>
  <li>
    <p>Originally, I had said that a write during an underflow would only
take you out of the underflow condition if there was no read at the same
time.  This is wrong.</p>

    <p>A write to an empty
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
will always succeed, independent of whether or not a read is taking place
at the same time, and a read from an empty
<a href="/blog/2017/07/29/fifo.html">FIFO</a>
should always fail–independent of a write taking place at the same time.</p>

    <p>Fixing this required several changes throughout.</p>
  </li>
  <li>
    <p>I hadn’t initialized all of my variables.  In particular, <code class="language-plaintext highlighter-rouge">r_next</code> and
<code class="language-plaintext highlighter-rouge">r_fill</code> weren’t originally initialized.</p>
  </li>
  <li>
    <p>When calculating the number of elements in the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>,
I had assumed that if the <code class="language-plaintext highlighter-rouge">will_overflow</code> value was true that any write to
the <a href="/blog/2017/07/29/fifo.html">FIFO</a> would
overflow the <a href="/blog/2017/07/29/fifo.html">FIFO</a>.
This isn’t the case.  If <code class="language-plaintext highlighter-rouge">will_overflow</code> is true, then any write <em>without a
concurrent read</em> will overflow the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>.
A read and write during the same clock period will not overflow the
<a href="/blog/2017/07/29/fifo.html">FIFO</a>.</p>
  </li>
</ul>

<p>If you’d like, all of the changes are captured within the
<a href="https://github.com/ZipCPU/wbpmic">github repository</a>
on line, so you can review what I found
<a href="https://github.com/ZipCPU/wbpmic/commit/01efb009ce963b536213f5e8e695acf1c93c2d84#diff-9ce5778d79774aac9ca5e898c621af07">here</a>.</p>

<h2 id="final-thoughts">Final Thoughts</h2>

<p>Please keep in mind, I’m only a beginner at
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a>.
I’ve never used any of them before this week, but I’ve already found several
problems in my own code using them.  Are
<a href="https://en.wikipedia.org/wiki/Formal_methods">formal methods</a>
worth the effort?  Well, for me and in this example, they were.</p>

<p>I’d like to come back to this topic in the future after I’ve learned some
more.  I’d also like to apply these methods to many other problems as well.
However, I’ve also got some problems which I’m not yet certain how to prove.
For example, while I’ve managed to prove a <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/llqspi.v">low level QSPI flash
driver</a>,
I have yet to figure out how to prove the entire protocol.  Likewise, I’ve
managed to prove that my <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">UART transmitter
(lite)</a> works,
but not yet the receiver or the <a href="https://github.com/ZipCPU/wbuart32">entire IP
core</a> including the <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v">wishbone
interface</a>.</p>

<p>For now, I think I’ll just see if I can’t prove my
<a href="https://github.com/ZipCPU/wb2axip">WB to AXI4 bridge</a> next.
I think that would be useful for all.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Ye have heard that it hath been said, Thou shalt love thy neighbour, and hate thine enemy.  But I say unto you, Love your enemies, bless them that curse you, do good to them that hate you, and pray for them which despitefully use you, and persecute you (Matt 5:44)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
