<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>FPGAs vs ASICs</title>
  <meta name="description" content="I’ve now been developing on Field Programmable Gate Arrays(FPGA)sfor about seven or eight years.  I have heard of Application-specificintegrated circuit(ASIC...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2017/10/13/fpga-v-asic.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">FPGAs vs ASICs</h1>
    <p class="post-meta"><time datetime="2017-10-13T00:00:00-04:00" itemprop="datePublished">Oct 13, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I’ve now been developing on <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">Field Programmable Gate Arrays
(FPGA)</a>s
for about seven or eight years.  I have heard of <a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">Application-specific
integrated circuit
(ASIC)</a>
development, but I’ve never done any work with
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s.</p>

<p>So I thought I’d ask some folks about them: is
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
development the same as
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> development?
Is it just a matter of using a different set of tools?  Indeed, how
hard would it be to present my own designs as
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
capable designs?</p>

<p>As I started to ask around, I got quite the earful in return.  At the risk of
pontificating about what I know nothing about, I’ll try to share some of what
I learned here.  Feel free to write me and correct any misconceptions
I might have.</p>

<h2 id="differences-betweeen-fpga-and-asic-development">Differences betweeen FPGA and ASIC development</h2>

<p>The first thing I learned was that
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
developers have a much easier task. Unlike
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s,
an <a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design starts from a completely blank tableau.</p>

<table align="center" style="float: none"><caption>Fig 1: FPGA designers start further along in the design process</caption><tr><td><img src="/img/fpga-v-asic.svg" alt="FPGA vs ASIC internals" width="780" /></td></tr></table>

<p>Whereas on an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
you start out with a large array of
<a href="https://en.wikipedia.org/wiki/Logic_block">logic block</a>s,
clock buffers,
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s,
on-chip
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>s, I/O buffers,
(de)serializers, power distribution networks and more,
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
development
starts further down into the weeds.  This means  that these components must
either be purchased, come from the manufacture as part of a library, or they
must be individually developed for use within any
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design.</p>

<p>The next big difference is the design cycle.  Simple
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designs may be built within an afternoon, or even a couple of weeks for a
moderately more complex design.  Indeed, such designs fit nicely into the
academic calendar and make great school engineering projects.</p>

<table align="center" style="float: none"><caption>Fig 2: (Simplified) FPGA Design Cycle</caption><tr><td><img src="/img/fpga-design-flow.svg" alt="Simplified FPGA design cycle" width="380" /></td></tr></table>

<p>This is not true of <a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design.</p>

<table style="float: right"><caption>Fig 3: ASIC Design Cycle</caption><tr><td><img src="/img/asic-design-flow.svg" alt="Simplified ASIC design cycle" width="380" /></td></tr></table>

<p>Specifically, the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
manufacturing cycle alone can take many weeks
(months) before you get your chip back, at which point you then need to
integrate it onto a circuit board and test it.  Iterative development of
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s
takes months longer (and $M more) per iteration than the minutes it can take
with an <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<p>Those are the drawbacks.  What about the benefits?
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
technology offers higher speeds and lower power solutions beyond what an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
can provide.  Speed differences between the two design methods can easily be
10x or more.  Further, an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design may be reverse engineered from its bitstream, whereas reverse
engineering an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
is much harder.</p>

<table align="center" style="float: none"><caption>Fig 4: FPGA vs ASIC benefits</caption><tr><td><img src="/img/fpga-v-asic-list.svg" alt="FPGA vs ASIC Benefits Table" width="780" /></td></tr></table>
<p>Wow!  Does this mean I could run my
<a href="/about/zipcpu.html">ZipCPU</a>
with a 1GHz clock, just by switching from an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
based design to an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design?  I like it!</p>

<p>So, just how bad are those drawbacks?</p>

<p>Well, the first big drawback is the cost.
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design is expensive.  Just paying for a single run of a single
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design can cost many millions of dollars.  For a large number of chips, this
price can be cheaper than the cost of purchasing a large number of similarly
capable
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s.
For single one-off designs, the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
is typically much cheaper.</p>

<p>There are also several other differences from the standpoint of the designer.</p>

<ol>
  <li>
    <p>Standard Cells</p>

    <p>Originally,
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design involved drawing and placing <a href="https://en.wikipedia.org/wiki/Bipolar_junction_transistor">bipolar
transistors</a> and
<a href="https://en.wikipedia.org/wiki/MOSFET">N-FET</a>s into
a design.  Since every manufacturer’s process was different, these designs
also needed to change from one manufacturer to another.  Tools were
available to help, but these tools were incompatible from one manufacturer
to another.  As a result, designs that worked with one manufacturer’s
process could not easily be transferred to another manufacturer’s process.</p>

    <p>This changed with the invention of <a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">Standard Cell</a>s.
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">Standard Cell</a>s are similar to the
<a href="https://en.wikipedia.org/wiki/Logic_block">logic blocks</a>
within
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
that form the basic logic unit for all of the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
logic.  In the same manner that arbitrary
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
logic can be created from
<a href="https://en.wikipedia.org/wiki/Logic_block">lookup tables (LUT)</a>
within the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
arbitrary logic can be created using
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">standard cell</a>s within
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s.
The biggest difference, though, is that
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">standard cell</a>s
tend to be at a much lower logic level than
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
<a href="https://en.wikipedia.org/wiki/Logic_block">logic blocks</a>.</p>

    <p>As an example, the
<a href="http://opencircuitdesign.com/qflow">QFlow</a>
open-source
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
development tool set uses a
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">standard cell</a>
library provided by
<a href="https://vlsiarch.ecen.okstate.edu/flows/">vlsirch.ecen.okstate.edu</a>.
Their <a href="https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/">tsmc025</a>
library consists of
<a href="https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/AND2X1.html">AND</a> gates,
<a href="https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/OR2X1.html">OR</a> gates,
<a href="https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/NAND2X1.html">NAND</a> gates,
<a href="https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/DFFPOSX1.html">D-flip flops</a>,
<a href="https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/MUX2X1.html">2-1 MUX</a>s,
<a href="https://vlsiarch.ecen.okstate.edu/flows/stdcell_datasheet/tsmc025/data/DFFPOSX1.html">clock buffer</a>s,
and more, but no six or eight input
<a href="https://en.wikipedia.org/wiki/Logic_block">LUTs</a>.</p>

    <p>Still, the impact of <a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">standard cell</a> technology was huge.
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">Standard cell</a>s made it possible for
<a href="https://en.wikipedia.org/wiki/Hardware_description_language">Hardware Description Languages (HDL)</a>, such as
<a href="https://en.wikipedia.org/wiki/Verilog">Verilog</a>
and <a href="https://en.wikipedia.org/wiki/VHDL">VHDL</a>, to start to proliferate
since synthesis tools could turn an
<a href="https://en.wikipedia.org/wiki/Hardware_description_language">HDL</a>
design into design based upon <a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">standard
cell</a>s.</p>
  </li>
  <li>
    <p>Clocks</p>

    <p>A second big difference between
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
and
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design is the clock.  The difference is two fold.  First,
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
have many resources designed to create and adjust clocks.  Second,
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
have dedicated clock routing networks.  Neither of these come for free on an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>.
Let’s discuss each of these in detail.</p>

    <p>First, most
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
have clock management resources within them.  These
resources allow you to change the frequency of a clock, and adjust its
phase.  These clock management resources are vital to creating a variety of
I/O interfaces.</p>

    <p><a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">standard cell</a>
libraries often don’t have these components within them.  The reason,
according to <a href="http://anysilicon.com/asic-pll-design-overview">AnySilicon</a>,
is that the
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> needs of an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer vary too much from one design to the next.  This makes it
difficult to grab a simple off the shelf
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
and place it into your design.  It also means that the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer needs to pay to procure a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
designed to his problem’s needs.</p>

    <p>The second problem was that
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
have dedicated clock routing networks, while
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s
do not.  This means that an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer must design the clock routing network for his design together
with the logic routing that
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
developers are familiar with.  Unlike the logic routing networks used by both
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
and
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s,
<em>clock</em> routing networks need to be designed so that the clock arrives at
every <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
at (roughly) the same time–making clock and logic routing more difficult.</p>
  </li>
  <li>
    <p>Reset</p>

    <p>I know that <a href="/blog/2017/08/21/rules-for-newbies.html">I have told beginners never to use an asynchronous
reset</a>.
That advice applies to beginners, and specifically to beginning
(<a href="https://www.xilinx.com">Xilinx</a>)
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designers only.</p>

    <p>The
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer <em>needs</em> the reset capability.</p>

    <p>Unlike
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s where
initial <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
conditions can be specified, and where the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
circuitry will quietly take care to set all of the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a> to the
initial values you specify,
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s within
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designs start with random initial values.  The <code class="highlighter-rouge">initial</code> statement
within <a href="https://en.wikipedia.org/wiki/Verilog">Verilog</a> just doesn’t
get synthesized by the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
tools.  This means that the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer needs to use the reset wire in order to force any hardware
registers/<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s
into known initial conditions.</p>

    <p>On an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>,
the reset wire is often an active low wire.  It is also used to keep the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s
logic from triggering, and hence from drawing power, until the power within
the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
is steady and reliable.</p>

    <p>This also brings up a host of timing issues, since the global reset may
be asynchronously asserted, and there is typically an asynchronous
propagation delay across the design.  This affects both asserting the
reset as well as de-asserting the reset.</p>

    <p>The bottom line, though, is that circuits that didn’t need reset logic
within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
often require it when implemented within an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>.</p>
  </li>
  <li>
    <p>On-chip RAM</p>

    <p>On-chip block
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
is an important part of any chip design.
Indeed, all of my own <a href="/about/zipcpu.html">ZipCPU</a>
designs depend upon block
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>.
I used it for fast, <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">local
memory</a>, for
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">cached
memory</a>
structures,
<a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">FIFO</a>s
and more.  On-chip <a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
however, doesn’t come for free for the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer.</p>

    <p>While it is possible to build a
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a> out of
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">standard cell</a>s,
the resulting performance (area, power, speed, etc) is often
unacceptable.</p>

    <p>This places the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer in the position where he needs to purchase (or design his own) the
design for any on-chip
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
he’d like to have.</p>
  </li>
  <li>
    <p>I/O peripherals</p>

    <p><a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
I/O pins can often handle multiple I/O standards.  These standards, while
possible for the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer to implement, also come at a cost.</p>

    <p>How about the input deserializers and output serializers that
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
offer?  These fundamental components of
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
make many I/O communication standards possible.
As with the multiple I/O standard capability, these essential I/O components
don’t come standard to the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer either.</p>

    <p>That’s the bad news.  The good news is that, at the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
level, you can build I/O designs that are very difficult to create within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
Examples include
<a href="https://en.wikipedia.org/wiki/HDMI">HDMI</a> pre-filters,
<a href="https://en.wikipedia.org/wiki/DDR_SDRAM">DDR memory</a> drivers,
<a href="https://en.wikipedia.org/wiki/USB">USB</a> interface drivers,
and even analog I/O components such as <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">analog to digital
converters</a> or
<a href="https://en.wikipedia.org/wiki/Digital-to-analog_converter">digital to analog
converters</a>.  As
with the rest of the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design experience, many companies will sell you these components as well.</p>
  </li>
  <li>
    <p>Power</p>

    <p><a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s have
wires running through them to deliver a sufficient amount of power to the
entire design.  Should the power be used unevenly, the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> has
been designed to guarantee that every component still gets a sufficient
amount of power to run.</p>

    <p>Since
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
development is done at a lower level, the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer needs to concern himself with power distribution throughout his
design.  In particular, he needs to insure that none of the components of
the design are power starved.  Such
<a href="https://en.wikipedia.org/wiki/Brownout_(electricity)">brown-out</a>s
will create problems that can be difficult to trouble-shoot later.</p>
  </li>
  <li>
    <p>Process variations</p>

    <p>If the above differences weren’t sufficient to highlight that
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
development has many differences from
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
development, then you should know we’re not done yet.</p>

    <p>The next difference is “process variations.”
Basically, by process variations, I am referring to the reality that
very small silicon components, on the order of tens of nanometers
or smaller, aren’t necessarily all manufactured to the same exact size.
Some components may be thicker than others just because it is difficult
to manufacture components that small to any exacting standard.</p>

    <p>What this means for the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
developer is that their design needs to be verified for process extremes.
At one extreme, logic might work faster than another extreme.  The
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
developer, using tools designed for this purpose,
needs to be able to deal with this and properly simulate both extremes,
to validate that the logic will work within the full limits of the
manufacturer’s process.</p>
  </li>
  <li>
    <p>Tools</p>

    <p>When I first starting learning
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design, I learned the synthesis and implementation buttons within
<a href="http://www.xilinx.com">Xilinx</a>’s
<a href="https://www.xilinx.com/products/design-tools/ise-design-suite.html">ISE</a>
program.  Synthesize; implement; generate programming file; load onto
hardware, and that was all I needed to know.  Moving to
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
was easy: once I found the synthesis, implementation, and bitstream
generation buttons I had all I needed.</p>

    <p>The tools required for
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design, however, are much more extensive.</p>

    <p>Sure, there’s the basic
<a href="https://en.wikipedia.org/wiki/Logic_synthesis">synthesis</a> tool, but there
are also arithmetic
synthesis and power synthesis tools as well.  These help the designer choose
and trade off multiplier architectures and power structures.</p>

    <p>There are also place and route tools and timing analyzers for
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
just as there are for
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s.</p>

    <p>The <a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer also has floor planning tools to help him place components, insert
a <a href="https://en.wikipedia.org/wiki/Clock_signal#Distribution">clock tree</a>,
<a href="https://en.wikipedia.org/wiki/Scan_chain">scan chains</a>
and <a href="http://semimd.com/favre/2015/10/26/lefdef-io-ring-check-automation/">I/O rings</a>.</p>

    <p>Modern
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designers also need to be able to estimate
<a href="https://en.wikipedia.org/wiki/Parasitic_capacitance">parasitic capacitance</a>,
sometimes just referred to as
<a href="https://en.wikipedia.org/wiki/Parasitic_capacitance">parasitics</a>.
<a href="https://en.wikipedia.org/wiki/Parasitic_capacitance">Parasitics</a> arise
when conductors of different potentials are placed close to each other.
While this effect can usually be ignored at low frequencies, it can
cause <a href="https://en.wikipedia.org/wiki/Crosstalk">crosstalk</a>
between digital logic lines,
<a href="https://en.wikipedia.org/wiki/Feedback">feedback</a> within analog circuits,
<a href="https://en.wikipedia.org/wiki/Parasitic_oscillation">parasitic
oscillations</a>, and more
at higher frequencies.  To avoid these effects, the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer uses <a href="https://en.wikipedia.org/wiki/Parasitic_extraction">parasitic
extraction</a> tools
to estimate the
<a href="https://en.wikipedia.org/wiki/Parasitic_capacitance">parasitics</a> within the
design for the purpose of updating his design simulations to see if the
estimated <a href="https://en.wikipedia.org/wiki/Parasitic_capacitance">parasitic
capacitance</a>
will impact design performance.</p>

    <p>A <a href="https://en.wikipedia.org/wiki/Formal_equivalence_checking">logic equivalence
checker</a>
is another
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
tool that may be unfamiliar to an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designer.
<a href="https://en.wikipedia.org/wiki/Formal_equivalence_checking">Logic equivalence
checker</a>s
are used to formally prove that the circuit designed
to this point matches the initial desired behavior.</p>

    <p>When this is all done, there are a series of physical checks that can be
made to the <a href="https://en.wikipedia.org/wiki/Physical_design_(electronics)">physical
design</a> before
<a href="https://en.wikipedia.org/wiki/Tape-out">tape out</a>.  For example, the final
<a href="https://en.wikipedia.org/wiki/Layout_Versus_Schematic">layout should be checked to make certain it still matches the
schematic</a>.
<a href="https://en.wikipedia.org/wiki/Antenna_effect">Antenna rule checking</a> is
used to make static electric discharge does not damage the device
during manufacture.  <a href="https://en.wikipedia.org/wiki/Design_rule_checking">Design Rule Checks
(DRC)</a> can also be
used.  DRC checks were initially used to just verify that all of the
components within a design have the correct widths, separations,
and that any enclosures were the minimum size.  Modern
<a href="https://en.wikipedia.org/wiki/Design_rule_checking">DRC</a>
checkers now look for potential short-circuits, undriven lines, and much
more.</p>
  </li>
  <li>
    <p>Selecting a Package</p>

    <p>An
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
board designer can often select between a variety of chip shapes, form
factors, and means of connecting to the board.  Some
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
have ball grid array connectors, others have their pins on the sides.</p>

    <p>Unlike the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
board designer, who gets to choose from pre-made packages, the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer is required to pick which package he wants his chip to be placed
within.</p>
  </li>
</ol>

<p>Have I convinced you that there are more parts to
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design than
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
design?  If not, just understand that we haven’t yet touched on the
test, verification, and debugging differences yet.</p>

<h2 id="asic-hell-is-worse-then-fpga-hell">ASIC Hell is worse then FPGA Hell</h2>

<p>Verifying and subsequently testing an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design is very different from that of an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design for two basic reasons: the monetary and calendar
costs.  As I mentioned above, a simple
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design can be made, tested, and proven in an afternoon for the simple cost of
a small development board.
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s,
on the other hand, can require months to manufacture, not to
mention the millions of dollars required to manufacture them.</p>

<p>Now, consider how this impacts the cost of any design bug.
If you find a mistake within your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
logic, you can often fix it within a week or so of isolating the problem.
If you’ve already delivered the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
solution to your customer, all it takes to upgrade their hardware is to send
them an updated configuration file electronically.  The cost is minimal.
On the other hand, if you find a bug in an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design, you will need to re-manufacture your chips at the cost of months
and millions of dollars.  Customers will be required to assemble new boards
with the new chips in their design.  As an example of how painful this can
become, you might wish to consider how Intel <a href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug">paid roughly $475M for the
mistake in their divide
algorithm</a>,
shipped with the first Pentium computers.</p>

<p>Indeed, if you think <a href="/fpga-hell.html">FPGA Hell</a> is a
nightmare, imagine being stuck in the same position after designing an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>!
Your costs would be orders of magnitude higher!  Not only would you have to pay
the multiple millions of dollars for each new mask, but imagine if you didn’t
know <em>what</em> the problem was in order to fix it?</p>

<p>Just to illustrate, let’s consider the cost of finding and fixing bugs in
software,
on an <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
and within an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>.</p>

<p>In software, the
<a href="https://www.gnu.org/software/gdb/">debugger</a>
can help you find your fault.  You can often find and fix the problem in seconds
to minutes.  (Often, not always.)</p>

<p><a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
are harder to debug than software since you cannot see within them to examine
what’s going on.  Dealing with this problem has been one of the focuses of
<a href="https://zipcpu.com/">this blog</a>.  Hence we’ve
discussed many techniques that can be used to find faults within
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designs.  We’ve discussed <a href="/blog/2017/06/16/dbg-bus-forest.html">how to get information
into an</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design, and how to pull information out.  We’ve discussed
<a href="/digilent/2017/05/29/fft-debugging.html">how to “single-step”</a> an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design, <a href="/zipcpu/2017/08/25/hw-debugging.html">how to “single-step” a
CPU</a>
within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design, as well as how to <a href="/blog/2017/07/08/getting-started-with-wbscope.html">pull a trace out from within such a
design</a>.
Using these techniques, faults can often be found within anywhere between an
hour or two on up to a couple of days–depending upon the fault.  Sometimes,
<a href="/blog/2017/09/14/even-i-get-stuck.html">I’ve had faults take a month or
longer</a> to find and fix–but
this is rare.</p>

<p>Now, imagine how you would debug an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design?</p>

<p>Your first and foremost goal would be to find problems within your
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design before you send it out for manufacture.  Indeed, if you can find bugs
before <a href="https://en.wikipedia.org/wiki/Tape-out">tape out</a>, your cost per bug
will be relatively cheap.  Here are some methods you might use:</p>

<ol>
  <li>
    <p><a href="/blog/2017/06/23/my-dbg-philosophy.html">Simulation</a> is
an obvious technique.  This works for both
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s
as well as
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s.</p>

    <p>Unlike
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s,
however,
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s
can contain both digital and analog circuitry.  Hence an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>s
simulation needs may require tools that can handle analog circuitry
as well as digital.</p>
  </li>
  <li>
    <p>Prototyping digital circuitry using an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

    <p>If you’d like to know if your
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
will even boot, or if it will properly run programs, this is often a good
place to start.</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designers also tend to use <a href="https://en.wikipedia.org/wiki/Formal_verification">formal
methods</a> to find obscure
bugs that their test benches don’t reveal.</p>

    <p>The big difference between <a href="https://en.wikipedia.org/wiki/Formal_verification">formal
methods</a> and more
traditional test benching approaches is that traditional test benches often
test only a couple logic paths.
<a href="https://en.wikipedia.org/wiki/Formal_verification">Formal methods</a> attempt
to test <em>every</em> logic path in order to <em>prove</em> that the design “works”.</p>

    <p>There are several types of
<a href="https://en.wikipedia.org/wiki/Formal_verification">formal methods</a>
available, with each type able to find a different type of design fault.</p>
  </li>
</ol>

<p>These are the cheap means of debugging an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design.  They are cheap because they can be performed without actually
manufacturing the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
chips themselves.</p>

<p>The more difficult task is testing the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
after it has been manufactured.  This is often done, not for the purpose of
finding faults in the design (those were fixed before manufacture, right?),
but rather for the purpose of finding faults
within the manufacture of the particular part.</p>

<p>Two basic approaches are used for this task.  The first approach is to use a
<a href="https://en.wikipedia.org/wiki/Scan_chain">scan chain</a>, the second to do
<a href="https://en.wikipedia.org/wiki/Boundary_scan">boundary scans</a>.  While
both are similar, the
<a href="https://en.wikipedia.org/wiki/Scan_chain">scan chain</a> approach applies to
the internal logic within an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>,
whereas the
<a href="https://en.wikipedia.org/wiki/Boundary_scan">boundary scan</a> approach applies
to the I/O pads only.</p>

<p>To test an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
using a <a href="https://en.wikipedia.org/wiki/Scan_chain">scan chain</a>, the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer must first connect every
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
within the design to the
<a href="https://en.wikipedia.org/wiki/Scan_chain">scan chain</a>.  This must be done
as part of the design process, and before the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
is manufactured.  A debug port is also created on the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
part, allowing the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer access to the scan chain.  When activated, every flip flop within the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
may be read and set.  This allows an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
designer internal visibility into their design, allowing him to determine
if the device that was manufactured accurately represents what he had
intended to manufacture.</p>

<p>This debugging <a href="https://en.wikipedia.org/wiki/Scan_chain">scan chain</a>
capability is often hidden within the manufacturer specified power and
ground rails supplied to the design, as well as (potentially) pins with
no particular connection to them.</p>

<p><a href="https://en.wikipedia.org/wiki/Boundary_scan">Boundary scan</a> scan testing is
very similar, with the difference that instead of connecting to the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>s
within a design, the
<a href="https://en.wikipedia.org/wiki/Boundary_scan">boundary scan</a> circuitry
connects to all of the I/Os within a design.  As a result, a
<a href="https://en.wikipedia.org/wiki/Boundary_scan">boundary scan</a> can be used
to verify that different parts within a board are properly connected, and
that there are no short circuits between the
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
and the rest of the board it is placed within.  Unlike the hidden nature of
<a href="https://en.wikipedia.org/wiki/Scan_chain">scan chain</a>s, many chip manufacturers
use a standard
<a href="https://en.wikipedia.org/wiki/JTAG">JTAG</a> interface to their
<a href="https://en.wikipedia.org/wiki/Boundary_scan">boundary scan</a> logic.</p>

<p>Given the above, I think it’s safe to conclude that
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
testing methodologies are a superset of the technologies used to design
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
logic.</p>

<h2 id="formal-verification">Formal Verification</h2>

<p>While I haven’t discussed <a href="http://www.clifford.at/yosys/about.html">yosys</a>
much on <a href="https://zipcpu.com/">this blog</a>,
<a href="http://www.clifford.at/yosys/about.html">yosys</a>
provides both an open source synthesis capability as well as access to several
open source <a href="https://en.wikipedia.org/wiki/Formal_verification">formal verification
methods</a> for HDL designs.
These can then be used to <em>prove</em> that the logic, either within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
or an
<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a>
design, will work.</p>

<p>I’d like to experiment with some of these methods,
and report about them on
<a href="https://zipcpu.com/">this blog</a>.
Indeed, I think it would be valuable to <em>prove</em> that the
<a href="/about/zipcpu.html">ZipCPU</a> does what that
<a href="https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf">specification</a>
says it is supposed to do.  Sure, I’ve tested it with a <a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c">roaming test
program</a>,
but I expect that a
<a href="https://en.wikipedia.org/wiki/Formal_verification">formal</a> proof would be
more complete.</p>

<p>Once I get the chance to try this, I’ll be glad to <a href="/blog/2017/10/19/formal-intro.html">write about my
experiences</a>
with <a href="http://www.clifford.at/yosys/about.html">yosys</a> verification methods,
and share any thing I discovered with everyone here.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Again, the kingdom of heaven is like unto treasure hid in a field; the which when a man hath found, he hideth, and for joy thereof goeth and selleth all that he hath, and buyeth that field.</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
