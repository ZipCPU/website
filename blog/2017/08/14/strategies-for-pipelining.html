<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Strategies for pipelining logic</title>
  <meta name="description" content="One of the things that newFPGAstudents struggle with is the fact thateverything in digital logic takes place in parallel.">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2017/08/14/strategies-for-pipelining.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Strategies for pipelining logic</h1>
    <p class="post-meta"><time datetime="2017-08-14T00:00:00-04:00" itemprop="datePublished">Aug 14, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>One of the things that new
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
students struggle with is the fact that
<em>everything</em> in digital logic takes place in parallel.</p>

<p>Many of these students come from a computer science background. 
They understand how an algorithm works, and how one thing must take place
after another in a specific sequence.  They tend to struggle, though, with
the idea that every step in an algorithm occupies a piece of digital logic
that will act on <em>every</em> clock tick–whether used or not.</p>

<p>One solution to sequencing operations is to create a giant state machine.
The reality, though, is that an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
tends to create all the logic for
every state at once, and then only select the correct answer at the end of
each clock tick.  In this fashion, a state machine can be very much like
the <a href="/zipcpu/2017/08/11/simple-alu.html">simple ALU</a>
we’ve discussed.</p>

<p>On the other hand, if the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
is going to implement all of the logic for the
operation anyway, why not arrange each of those operations into a sequence,
where each stage does something useful?  This approach rearranges the
algorithm into a pipeline.
<a href="https://en.wikipedia.org/wiki/Pipelining_(DSP_implementation)">Pipelining</a>
tends to be faster than the state machine approach for
accomplishing the same algorithm, and it can even be more resource efficient,
although it isn’t necessarily so.</p>

<p>The difficult part of a digital logic pipeline is that the pipeline runs and
produces outputs even when the inputs to the pipeline are not (yet) valid.</p>

<p>So, let’s discuss several different strategies for handling the signaling
associated with pipeline logic.  In general, there’s no one size fits all
strategy.  The strategy you pick will depend upon the needs of your algorithm,
and its data source (input) and destination (output).</p>

<p>We’ll work our way through several different strategies from the simplest
to most complex.</p>

<h2 id="the-global-valid-signal-for-sampled-data">The global valid signal for sampled data</h2>

<p>The first strategy for handling pipelining that we’ll discuss is to use a
global valid signal.
At each stage, the data coming into the pipeline is valid when the 
global valid signal is true.  Likewise, each stage may take no more clocks
to finish then there are between valid signals.  I like to use the <code class="language-plaintext highlighter-rouge">CE</code> or
“clock enable” signal to represent this valid logic.  Hence,
Fig 1 shows a block diagram of this sort communication.</p>

<table style="float: none"><caption>Fig 1: Pipelining with a global valid signal</caption><tr><td><img src="/img/pipeline-blocks-global-ce.svg" alt="Pipelining with a global valid signal" width="780" /></td></tr></table>

<p>The basic rules are this:</p>

<ol>
  <li>
    <p>There is a global <code class="language-plaintext highlighter-rouge">CE</code> line, synchronous with the clock.  This line is
true anytime new data is ready.</p>
  </li>
  <li>
    <p>Logic is allowed to transition <em>only</em> when this <code class="language-plaintext highlighter-rouge">CE</code> line is true</p>
  </li>
</ol>

<p>This leads to a trace diagram similar to Fig 2 below.</p>

<table style="float: none"><caption>Fig 1: Pipelining with a global valid signal</caption><tr><td><img src="/img/pipeline-global-ce.svg" alt="Pipelining with a global valid signal" width="780" /></td></tr></table>

<p>The neat thing about this approach is that there’s no real pipelining logic
required per se.  Each stage just waits for the global valid signal to be true,
and then applies its logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="kt">output</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">some</span> <span class="k">function</span> <span class="n">of</span><span class="p">)(</span><span class="n">i_input</span><span class="p">);</span>
	<span class="k">end</span> <span class="c1">// else *NOTHING*.  Nothing is allowed to change without CE=1</span></code></pre></figure>

<p>You may find very quickly, though, that this approach doesn’t handle all
pipelining needs.  However, while it doesn’t handle all pipelining needs,
it does handle the needs of a crucial problem set:
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing"><em>signal processing</em></a>.</p>

<p>In a typical
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">signal processing</a>
application, data either comes into an 
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
from an analog to digital (A/D) converter, or it goes out of the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
to a digital to analog (D/A) converter, or perhaps it does both.  The sample
rate defines when the <code class="language-plaintext highlighter-rouge">CE</code> signal needs to be high, and any transient
states are flushed through the system.
The digital logic engineer’s job is to manipulate the samples along the way.</p>

<p>Because the data moves through the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
at a fixed rate, and because it never suddenly changes speeds, the global
valid signal works quite well for it.</p>

<p>Applications include
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filtering</a>,
digital <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">phase lock loops</a>,
<a href="/dsp/2017/07/11/simplest-sinewave-generator.html">numerically controlled oscillators</a>,
and more. 
Indeed, anything that works at a <em>fixed data rate</em> is usually
a good candidate for this method of pipelining.</p>

<p>Why, even our resamplers have worked off of the concept of a global valid
signal, they’ve just had to deal with two different valid signals: one that
holds for one clock per input sample, and another that holds for one clock
for every output sample.
<a href="/dsp/2017/06/06/simple-interpolator.html">[1]</a>
<a href="/dsp/2017/07/29/series-linear-interpolation.html">[2]</a></p>

<h2 id="the-traveling-ce-to-reduce-latency">The traveling CE to reduce latency</h2>

<p>The global valid signal we discussed above, though, has two basic problems.
The first problem is that there’s no way to know if an output sample is
“valid” or not”.
The second is that the whole operation depends upon a uniform clock creating
the <code class="language-plaintext highlighter-rouge">CE</code> signal.  What
happens if the data is produced in a bursty fashion, and you want to know
not only <em>when</em> the output is valid but also <em>if</em> the output is valid?  In
this case, another approach is required.</p>

<p>I’m going to call this second approach the “traveling CE” approach.  Basically,
each stage in the pipeline propagates the CE forward, as in Fig 3.</p>

<table style="float: none"><caption>Fig 3: Pipelining with a traveling CE</caption><tr><td><img src="/img/pipeline-blocks-traveling-ce.svg" alt="Pipeline block diagram of a traveling CE" width="780" /></td></tr></table>

<p>The basic rules to this approach are:</p>

<ol>
  <li>
    <p>Whenever the <code class="language-plaintext highlighter-rouge">CE</code> signal is true, the data associated with it must also be
valid.</p>
  </li>
  <li>
    <p>At the end of every stage of processing, a <code class="language-plaintext highlighter-rouge">CE</code> signal must be produced,
together with the output data for that stage.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">CE</code> signal <em>must</em> be initialized to zero.  Further, if any reset is
to be used, the <code class="language-plaintext highlighter-rouge">CE</code> <em>must</em> be set to zero on any reset.  (The data is a
don’t care on reset, but the <code class="language-plaintext highlighter-rouge">CE</code> line <em>must</em> be set to zero.)</p>
  </li>
  <li>
    <p>Nothing is allowed to change <em>except</em> on a <code class="language-plaintext highlighter-rouge">CE</code> signal.  Hence, the only
time the incoming data is referenced is when <code class="language-plaintext highlighter-rouge">i_ce</code> (the input <code class="language-plaintext highlighter-rouge">CE</code> line
to a pipeline stage) is high.</p>
  </li>
  <li>
    <p>Finally, every piece of logic must be ready, at all times, for a new value
to enter into the pipeline.  This particular pipeline strategy cannot handle
stalls.</p>
  </li>
</ol>

<p>A trace of this type of logic might look like Fig 4.</p>

<table style="float: none"><caption>Fig 4: Pipelining with a traveling CE</caption><tr><td><img src="/img/pipeline-traveling-ce.svg" alt="Pipelining with a traveling CE" width="780" /></td></tr></table>

<p>In Verilog, the approach looks like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">o_ce</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="n">i_ce</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">o_output</span> <span class="o">&lt;=</span> <span class="p">...</span> <span class="c1">// some function of i_input;</span>
	<span class="c1">// else *NOTHING*.  Nothing is allowed to change except on</span>
	<span class="c1">// a reset or an i_ce</span></code></pre></figure>

<p>This approach works very well when the pipeline can be separated into stages
that take no more than a single input valid signal.  Likewise, it works well
when none
of the stages depends upon any feedback from future results.  In other words,
if nothing ever needs to wait, then this approach to pipelining works fairly
well.</p>

<p>Applications of this pipelining approach include
<a href="https://en.wikipedia.org/wiki/Multiplication_algorithm">logic multiplies</a>,
<a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier transform</a>
processing (<a href="https://github.com/ZipCPU/dblclockfft">example</a>),
video processing, gear-boxes, and more.  Indeed, we used this approach
within our <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbbus.v">hexbus debugging
bus</a>
to hook the input processing chain together.  You may notice, however, that
this approach didn’t work on the output processing chain.  The problem
there was that the <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a>
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">transmitter</a>
took longer than a single clock to transmit a character, and so another
pipeline signaling approach was needed–one that allowed the end of the
pipeline to control the rate of the pipeline.</p>

<h2 id="the-simple-handshake">The simple handshake</h2>

<p>The biggest problem with the traveling CE approach to pipelining is
that there’s no way to handle the case where the listener isn’t ready.  To
use a
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a>
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">transmitter</a>
as an example, you can create a pipeline to fill the
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">transmitter</a>,
but what do you do when the
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">transmitter</a>
is busy?  This requires a simple
handshake approach, one that I will describe here in this section.</p>

<p>The basic hand shake relies on a pair of signals–one from the current
device and another from the next one in the pipeline.  We’ll call these
signals <code class="language-plaintext highlighter-rouge">STB</code> (or valid) and <code class="language-plaintext highlighter-rouge">BUSY</code>, although the wires go by a variety of
other names depending upon the interface.  Fig 5 shows a simple pipeline,
having only two stages, with the handshaking signals working through it.</p>

<table style="float: right"><caption>Fig 5: Block diagram of a simple handshake</caption><tr><td><img src="/img/pipeline-blocks-handshake.svg" alt="A simple handshake pipeline signal" width="380" /></td></tr></table>

<p>The basic rules associated with the simple handshake are:</p>

<ol>
  <li>
    <p>A transaction takes place any time the <code class="language-plaintext highlighter-rouge">STB</code> line is true and the
<code class="language-plaintext highlighter-rouge">BUSY</code> line is false.</p>
  </li>
  <li>
    <p>The receiving pipeline stage needs to be careful <em>not</em> to ever lower the
<code class="language-plaintext highlighter-rouge">BUSY</code> line, unless it is ready to receive data on the next clock.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">STB</code> line should be raised any time data is ready to send. 
The data source <em>must not</em> wait for <code class="language-plaintext highlighter-rouge">BUSY</code> to be false before raising
the <code class="language-plaintext highlighter-rouge">STB</code> line.</p>

    <p>The issue with not waiting for <code class="language-plaintext highlighter-rouge">BUSY</code> to be true has to do with avoiding
deadlocks.  By setting <code class="language-plaintext highlighter-rouge">STB</code> independent of <code class="language-plaintext highlighter-rouge">BUSY</code>, the dependence between
the two is removed.</p>
  </li>
  <li>
    <p>Likewise, the <code class="language-plaintext highlighter-rouge">BUSY</code> line <em>should</em> <em>idle</em> in the not busy condition.</p>

    <p>While many AXI demonstration implementations idle with
the <code class="language-plaintext highlighter-rouge">AXI_*READY</code> line false (their equivalent of a <code class="language-plaintext highlighter-rouge">BUSY</code> line being true),
this will only slow down your interaction by an unnecessary clock. 
Remember, one of the goals of pipelining logic is speed.  Making <code class="language-plaintext highlighter-rouge">BUSY</code> true
when it doesn’t need to be will slow down the pipeline.</p>
  </li>
  <li>
    <p>Once <code class="language-plaintext highlighter-rouge">STB</code> is raised, the data being transferred cannot be changed until
the clock after the transaction takes place.  That is, use <code class="language-plaintext highlighter-rouge">(STB)&amp;&amp;(!BUSY)</code>
to determine if things need to change.</p>
  </li>
  <li>
    <p>The data lines are in a “don’t care” condition any time <code class="language-plaintext highlighter-rouge">STB</code> is false.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">STB</code> and <code class="language-plaintext highlighter-rouge">BUSY</code> lines must be initialized to zero.  If you have a need
for a reset or a clear pipeline operation, these signals need to be returned
to zero on either of these signals.</p>

    <p>Since the data lines will be placed into a “don’t care” condition, they
don’t need to have any value on reset.</p>
  </li>
</ol>

<p>If you look at this handshake from the standpoint of the logic involved,
a trace would look like Fig 6.</p>

<table style="float: none"><caption>Fig 6: A simple handshake pipeline signal</caption><tr><td><img src="/img/pipeline-handshake.svg" alt="A simple handshake pipeline signal" width="780" /></td></tr></table>

<p>Pay close attention to the “(Transaction)” line.  This line is the key
to understanding the trace.  It is formed from the combinational
result of <code class="language-plaintext highlighter-rouge">(STB)&amp;&amp;(!BUSY)</code>.  This line is the analog of the <code class="language-plaintext highlighter-rouge">CE</code> line in the
traveling <code class="language-plaintext highlighter-rouge">CE</code> approach from before.  When the (Transaction) line is high, the
data is valid (since <code class="language-plaintext highlighter-rouge">STB</code> was high), and the processing can step forward one
further step.</p>

<p>I’ve used this approach many times when building controllers for slow
hardware.  In those cases, the receiver generally looks like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span> <span class="n">o_busy</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">state</span>  <span class="o">&lt;=</span> <span class="n">IDLE_STATE</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_busy</span><span class="p">))</span> <span class="k">begin</span>
		<span class="c1">// We just accepted an input sample into this controller</span>
		<span class="c1">// Turn o_busy on, and start processing this input.</span>
		<span class="n">o_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="n">state</span>  <span class="o">&lt;=</span> <span class="n">START_STATE</span><span class="p">;</span>
		<span class="n">data</span>   <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">;</span>
		<span class="c1">// etc.</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
		<span class="c1">// A state machine is used to handle an interaction</span>
		<span class="c1">// with the hardware now that a request has been made.</span>
		<span class="c1">// ....</span>
		<span class="nl">FINAL_STATE:</span> <span class="k">begin</span>
			<span class="n">o_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
			<span class="n">state</span>  <span class="o">&lt;=</span> <span class="n">IDLE_STATE</span><span class="p">;</span>
			<span class="c1">// ... other logic</span>
			<span class="k">end</span>
		<span class="c1">// default:</span>
		<span class="k">endcase</span></code></pre></figure>

<p>As you might have guessed by now, my
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a>
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">transmitter</a>
uses this approach.  You can also find several examples of interacting
with such a transmitter among the <a href="https://github.com/ZipCPU/wbuart32/tree/master/bench/verilog">bench
tests</a> for the
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a>
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">transmitter</a>.
Perhaps closer to home, you may find this approach to pipelining used
by the transmit half of the <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbbus.v">hexbus
module</a>.</p>

<p>The problem with the
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a>
example is that it doesn’t really capture the logic required in any mid-point
pipeline stage, only the final stage.</p>

<p>At the midpoint, there are two choices for how to handle things.  You can
either register the <code class="language-plaintext highlighter-rouge">BUSY</code> signal and suffer a pipeline stall in between
any two transactions, or you can create a <code class="language-plaintext highlighter-rouge">BUSY</code> signal using combinational
logic.  The combinational <code class="language-plaintext highlighter-rouge">BUSY</code> (shown in the example code below) has the
problem that the time required for <code class="language-plaintext highlighter-rouge">BUSY</code> determination accumulates as you
move backwards through the pipeline.  This can slow down your logic, so
when this combinational path approaches your clock period it becomes
undesirable.  On the other hand, if it’s a
<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a>
or any other slow peripheral at the end of the logic pipeline
(<a href="https://opencores.org/project,qspiflash">flash</a>,
<a href="https://github.com/ZipCPU/wbicapetwo">ICAPE2</a>
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/wboledrgb.v">OLEDrgb</a>, etc),
then you might not care about any clocks lost in the <code class="language-plaintext highlighter-rouge">BUSY</code> signal calculation.</p>

<p>All that is to say, here’s an example of how to build a pipeline component
with this handshake as both the input and the output to the component:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r_busy</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">initial</span>	<span class="n">o_stb</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// busy and stb must be cleared on any reset</span>
		<span class="c1">// Data is a don't care</span>
		<span class="n">r_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">o_stb</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_busy</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_stb</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// An incoming transaction has just taken place</span>
			<span class="n">r_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
			<span class="c1">// begin your logic here ...</span>
			<span class="c1">//</span>
		<span class="k">end</span>
		<span class="c1">// else we remain in an idle condition</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">o_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_busy</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="c1">// An output transaction just took place</span>
		<span class="n">r_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">o_stb</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_stb</span><span class="p">)</span> <span class="k">begin</span>
		<span class="c1">// o_busy is true, so you can perform any necessary logic here</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">your</span> <span class="kt">logic</span> <span class="n">is</span> <span class="n">complete</span><span class="p">)</span>
			<span class="n">o_stb</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span> <span class="c1">// else we have to wait for our output data to be accepted</span>
	<span class="c1">// by the next stage before we can move on.</span></code></pre></figure>

<p>The final step is to set the output busy line, <code class="language-plaintext highlighter-rouge">o_busy</code>.  We use <code class="language-plaintext highlighter-rouge">r_busy</code>
to record any time our own component is busy.  The final busy is set up so
that no empty delay cycles will be necessary, even though it requires some
combinational logic (i.e. borrowed clock time) to do.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">o_busy</span> <span class="o">=</span> <span class="p">(</span><span class="n">r_busy</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">o_stb</span> <span class="o">||</span> <span class="n">i_busy</span><span class="p">);</span></code></pre></figure>

<p>This example is easily modified to to remove the combinational accumulation
by simply setting the <code class="language-plaintext highlighter-rouge">o_busy</code> line via the <code class="language-plaintext highlighter-rouge">r_busy</code> logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">o_busy</span> <span class="o">=</span> <span class="n">r_busy</span><span class="p">;</span></code></pre></figure>

<p>This will create an idle cycle between pipeline stages, but it will also fix
the combinational time accumulation problem.</p>

<p>Examples of this type of handshaking abound.  For example, the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
has a form of interaction that uses this form of handshaking, although it
changes the signal names a touch.  While the <code class="language-plaintext highlighter-rouge">STB</code> name remains the same, the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
uses <code class="language-plaintext highlighter-rouge">STALL</code> as the name for its <code class="language-plaintext highlighter-rouge">BUSY</code> line.  Likewise, the
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI bus specification</a>
uses this form of handshaking.  Indeed, it uses this form across
<em>five separate</em> hand-shaking channels.  AXI uses the terms
<code class="language-plaintext highlighter-rouge">*AXI_*VALID</code> for <code class="language-plaintext highlighter-rouge">STB</code> and <code class="language-plaintext highlighter-rouge">*AXI_*READY</code> instead of <code class="language-plaintext highlighter-rouge">!BUSY</code>.
We’ve also already discussed the transmit half, i.e. return processing
chain, of the main <a href="https://github.com/ZipCPU/dbgbus">dbgbus</a> module as
another example.</p>

<h2 id="the-buffered-handshake">The buffered handshake</h2>

<p>If you are trying to go for high speed, for example if you wished to run the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> at 200MHz instead of its more
natural 100MHz speed, then the simple handshake method can suffer from severe
timing problems as the pipeline grows in length.  This problem is twofold.
First, any time a <code class="language-plaintext highlighter-rouge">BUSY</code> signal needs to pass combinationally from the <code class="language-plaintext highlighter-rouge">N</code>th
stage back to the first stage,
the time required increases at each stage.  This can slow down your logic.
The logic chain line can cross large sections of digital logic, incurring
timing delays from one end of the chip to another, while the logic elements
along the way that this signal needs to pass through just contribute to
the pain.  Second, while it is
possible to slow the <code class="language-plaintext highlighter-rouge">BUSY</code> signals down, by inserting a stall between
pipeline stages, this can slow the pipeline down by a factor of two.</p>

<p>Another approach is needed.</p>

<p>The way to mitigate this problem to set the <code class="language-plaintext highlighter-rouge">BUSY</code> value with a clocked
register.  This means that when a subsequent pipeline stage isn’t ready
(a pipeline stall), it will cost a clock until the <code class="language-plaintext highlighter-rouge">BUSY</code> line can be true.
To avoid losing any data, the data that arrived before the <code class="language-plaintext highlighter-rouge">BUSY</code> signal
could go high will need to be stored in a buffer.</p>

<p>For this reason, I’m going to call this a “buffered handshake”.</p>

<p>The “buffered handshake” is going to use the exact same signals as
we showed in Fig 5 above.  Further, although Fig 6 shows what the signaling
might look like, it doesn’t capture the concept of the <code class="language-plaintext highlighter-rouge">BUSY</code> signal
propagating from the end to the beginning, with the data bunching up in the
middle like an accordion.</p>

<p>Perhaps some pictures would help this explanation.  Consider a four stage
pipeline, such as the one shown in Fig. 7.</p>

<table style="float: none"><caption>Fig 7: A four stage pipeline using a buffered handshake</caption><tr><td><img src="/img/pipeline-blocks-dbl-1.svg" alt="Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #1" width="780" /></td></tr></table>

<p>This figure shows four separate pipeline stages, from the data source or
generator, to the ultimate consumer of the data.  The pipeline in this
figure is currently full, with each stage having a payload value within it.
As a result, each of the <code class="language-plaintext highlighter-rouge">STB</code> signals is valid going into the next block.</p>

<p>Fig 8 shows what happens if the final stage in this pipeline stalls on the
next clock.</p>

<table style="float: none"><caption>Fig 8: Final pipeline stage stalls</caption><tr><td><img src="/img/pipeline-blocks-dbl-2.svg" alt="Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #2--stall starts" width="780" /></td></tr></table>

<p>Were this the simple handshake we discussed above, all of the <code class="language-plaintext highlighter-rouge">BUSY</code> flags
would go true at once.</p>

<p>In the case of the buffered handshake, only one <code class="language-plaintext highlighter-rouge">BUSY</code> flag becomes true.</p>

<p>This means that <code class="language-plaintext highlighter-rouge">Stage[2]</code> hasn’t had an opportunity to set it’s <code class="language-plaintext highlighter-rouge">BUSY</code> flag.
It has no choice but to ingest <code class="language-plaintext highlighter-rouge">payload #4</code> or risk dropping it (this would
be bad).  Therefore, <code class="language-plaintext highlighter-rouge">Stage[2]</code> has a buffer which it uses to store
<code class="language-plaintext highlighter-rouge">payload #4</code> on the next clock, as shown in Fig 9.</p>

<table style="float: none"><caption>Fig 9: The stall propagates</caption><tr><td><img src="/img/pipeline-blocks-dbl-3.svg" alt="Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #3--stall propagates" width="780" /></td></tr></table>

<p>This leaves <code class="language-plaintext highlighter-rouge">Stage[1]</code> in the position <code class="language-plaintext highlighter-rouge">Stage[2]</code> was in on the last clock.
It cannot push <code class="language-plaintext highlighter-rouge">payload #5</code> forward, and yet it hasn’t had the opportunity to
set its <code class="language-plaintext highlighter-rouge">BUSY</code> line.  It <em>must</em> accept <code class="language-plaintext highlighter-rouge">payload #6</code>.  It does so by placing it
into its buffer.</p>

<p>If at this time the data sink now becomes available, it will
lower its busy line, yielding an image looking like Fig 10.</p>

<table style="float: none"><caption>Fig 10: The pipeline starts to clear</caption><tr><td><img src="/img/pipeline-blocks-dbl-4.svg" alt="Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #4--initial stall clears" width="780" /></td></tr></table>

<p>As this pipeline clears, <code class="language-plaintext highlighter-rouge">Stage[2]</code> transmits <code class="language-plaintext highlighter-rouge">payload #3</code> and clears its
<code class="language-plaintext highlighter-rouge">BUSY</code> flag.  It’s now ready to transmit <code class="language-plaintext highlighter-rouge">payload #4</code> on the next clock,
as well as to received <code class="language-plaintext highlighter-rouge">payload #5</code> on that same clock, as in Fig 11.</p>

<table style="float: none"><caption>Fig 11: The pipeline continues to clear</caption><tr><td><img src="/img/pipeline-blocks-dbl-5.svg" alt="Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #5--Continues to clear" width="780" /></td></tr></table>

<p>At this point, <code class="language-plaintext highlighter-rouge">Stage[1]</code> can now flush its buffer and the pipeline is clear
again as in Fig 12.</p>

<table style="float: none"><caption>Fig 12: The pipeline finally clears</caption><tr><td><img src="/img/pipeline-blocks-dbl-6.svg" alt="Block diagram of a 4-stage pipeline using a buffered handshake.  Sequence #6--Stall has cleared" width="780" /></td></tr></table>

<p>You may notice that this pipeline uses the same <code class="language-plaintext highlighter-rouge">STB</code> and <code class="language-plaintext highlighter-rouge">BUSY</code> signals
that we’ve used for the simple handshaking approach to pipelining.  The
difference with this approach is that the <code class="language-plaintext highlighter-rouge">BUSY</code> signal is registered,
and must wait on a clock to propagate.</p>

<p>The rules defining this behavior are very similar to those for the simple
handshake above:</p>

<ol>
  <li>
    <p>A data transfer takes place any time <code class="language-plaintext highlighter-rouge">(STB)&amp;&amp;(!BUSY)</code> whether the given
pipeline stage is ready for it or not.</p>
  </li>
  <li>
    <p>If the output <code class="language-plaintext highlighter-rouge">(STB)&amp;&amp;(BUSY)</code> are true, but the input <code class="language-plaintext highlighter-rouge">(STB)&amp;&amp;(!BUSY)</code> is
true, the data must be stored into a buffer.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">BUSY</code> is true on the input, but <code class="language-plaintext highlighter-rouge">BUSY</code> isn’t true on the output, then
the buffer’s values can be released and sent forwards and we can set
<code class="language-plaintext highlighter-rouge">BUSY</code> for the incoming data to be false.</p>
  </li>
</ol>

<p>So, now that you know the concept, how shall we set up the logic necessary
to implement this?  We’ll look at how to design the logic for one stage
in this pipeline only, since the other stages will use similar logic.</p>

<p>The following logic is rather confusing when it comes to naming, since both
input and output ports share names.  I’ll use the <code class="language-plaintext highlighter-rouge">i_</code> prefix to reference
a wire coming into a stage, whether the <code class="language-plaintext highlighter-rouge">i_stb</code> line coming from the previous
stage or the <code class="language-plaintext highlighter-rouge">i_busy</code> line coming from the subsequent stage.  In a similar
manner, I’ll use the <code class="language-plaintext highlighter-rouge">o_</code> prefix to reference logic leaving this stage,
whether the <code class="language-plaintext highlighter-rouge">o_stb</code> sent to the subsequent pipeline stage to indicate that
this stage has something to pass on, or the <code class="language-plaintext highlighter-rouge">o_busy</code> line to send to the
previous stage to indicate that this stage is now busy.  We’ll also use the
<code class="language-plaintext highlighter-rouge">r_</code> prefix to reference values within our register, both <code class="language-plaintext highlighter-rouge">r_stb</code> to indicate
that something valid is in it as well as <code class="language-plaintext highlighter-rouge">r_data</code> to indicate the value of
what’s in it.</p>

<p>The first requirement is that the pipeline be empty on any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r_stb</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">initial</span>	<span class="n">o_stb</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">initial</span>	<span class="n">o_busy</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">r_stb</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">o_stb</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">o_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="c1">// Data is a don't care</span>
	<span class="k">end</span></code></pre></figure>

<p>Next, let’s deal with the case where the next or subsequent stage isn’t <code class="language-plaintext highlighter-rouge">BUSY</code>.
This should be the normal pipeline flow case.
Under normal flow, we’ll want to copy the input strobe <code class="language-plaintext highlighter-rouge">i_stb</code> to the output
strobe, <code class="language-plaintext highlighter-rouge">o_stb</code>.  Further, some data may need to be applied to <code class="language-plaintext highlighter-rouge">i_data</code> to
create the output <code class="language-plaintext highlighter-rouge">o_data</code>.  We’ll use the notation <code class="language-plaintext highlighter-rouge">logic(i_data)</code> to
indicate this.  The <code class="language-plaintext highlighter-rouge">logic()</code> function is not intended to be valid Verilog,
but rather to convey the concept of what’s taking place.</p>

<p>If, on the other hand, some data was in the buffer, then <code class="language-plaintext highlighter-rouge">o_busy</code> must
also have been true on this clock.  <code class="language-plaintext highlighter-rouge">o_stb</code> must also be true and <code class="language-plaintext highlighter-rouge">o_data</code>
valid.  Since <code class="language-plaintext highlighter-rouge">(o_stb)&amp;&amp;(!i_busy)</code>, a transaction has taken place and <code class="language-plaintext highlighter-rouge">r_stb</code>
can be copied to <code class="language-plaintext highlighter-rouge">o_stb</code>, and <code class="language-plaintext highlighter-rouge">r_data</code> to <code class="language-plaintext highlighter-rouge">o_data</code>–flushing our buffer.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// Always block continued ... (i_reset) is false</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_busy</span><span class="p">)</span> <span class="c1">// the next stage is not busy</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_stb</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// Nothing is in the buffer, so send the input</span>
			<span class="c1">// directly to the output.</span>
			<span class="n">o_stb</span>   <span class="o">&lt;=</span> <span class="n">i_stb</span><span class="p">;</span>

			<span class="c1">// This logic() function is arbitrary, and specific</span>
			<span class="c1">// the what this stage is supposed to do.</span>
			<span class="n">o_data</span>  <span class="o">&lt;=</span> <span class="kt">logic</span><span class="p">(</span><span class="n">i_data</span><span class="p">);</span>
		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="c1">// o_busy is true and something is in our buffer.</span>
			<span class="c1">// Flush the buffer to the output port.</span>
			<span class="n">o_stb</span>  <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
			<span class="n">o_data</span> <span class="o">&lt;=</span> <span class="n">r_data</span><span class="p">;</span> <span class="c1">// This is the buffered data</span>

			<span class="c1">// We can ignore the input in this case, since</span>
			<span class="c1">// we'll only be here if `o_busy` is also true.</span>
		<span class="k">end</span>

		<span class="c1">// We can also clear any stall condition</span>
		<span class="n">o_busy</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

		<span class="c1">// And declare the register to be empty.</span>
		<span class="n">r_stb</span>   <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>The next case is the case where <code class="language-plaintext highlighter-rouge">o_stb</code> is false (and <code class="language-plaintext highlighter-rouge">i_busy</code> is true).  This
case wasn’t shown in
the diagram series above.  It’s basically the case where a pipeline stage
has no data payload within it at all.  In that case, we’ll keep <code class="language-plaintext highlighter-rouge">o_busy</code> false,
we’ll accept any data, and then set the output <code class="language-plaintext highlighter-rouge">o_stb</code> value to indicate to
the next stage that we have something ready to be read.  Who knows, the
<code class="language-plaintext highlighter-rouge">i_busy</code> flag might be de–asserted on the next clock and we might not need
to stall.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// Always block continued ... (i_reset) is false, (i_busy) is true</span>
<span class="c1">//</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_stb</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_stb</span>  <span class="o">&lt;=</span> <span class="n">i_stb</span><span class="p">;</span>
		<span class="n">o_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

		<span class="c1">// Keep the buffer empty</span>
		<span class="n">r_stb</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

		<span class="c1">// Apply the logic to the input data, and set the output data</span>
		<span class="n">o_data</span> <span class="o">&lt;=</span> <span class="kt">logic</span><span class="p">(</span><span class="n">i_data</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>The last case to deal with is the case where <code class="language-plaintext highlighter-rouge">i_busy</code> is true, <code class="language-plaintext highlighter-rouge">o_stb</code>
indicates we have a payload loaded, and we now need to store our input into
our buffer.  Hence, we’ll set <code class="language-plaintext highlighter-rouge">r_stb</code> and mark this stage of the pipeline
as <code class="language-plaintext highlighter-rouge">BUSY</code> with <code class="language-plaintext highlighter-rouge">o_busy</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// Always block continued ... (i_reset) is false, (i_busy) and (o_stb) are both</span>
<span class="c1">// true.</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_busy</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="c1">// If the next stage *is* busy, though, and we haven't</span>
		<span class="c1">// stalled yet, then we need to accept the requested value</span>
		<span class="c1">// from the input.  We'll place it into a termporary</span>
		<span class="c1">// location.</span>
		<span class="n">r_stb</span>  <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_stb</span><span class="p">);</span>
		<span class="n">o_busy</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_stb</span><span class="p">);</span>
	<span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>That ends our giant always block, but we still have one value that we haven’t
set: <code class="language-plaintext highlighter-rouge">r_data</code>.  <code class="language-plaintext highlighter-rouge">r_data</code> needs to be set based upon the input data, <code class="language-plaintext highlighter-rouge">i_data</code>.
If you need to apply a <code class="language-plaintext highlighter-rouge">logic()</code> transform to <code class="language-plaintext highlighter-rouge">i_data</code>, you can do that here to
<code class="language-plaintext highlighter-rouge">r_data</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_busy</span><span class="p">)</span>
		<span class="n">r_data</span> <span class="o">&lt;=</span> <span class="kt">logic</span><span class="p">(</span><span class="n">i_data</span><span class="p">);</span></code></pre></figure>

<p>That was a lot harder than the simple handshake, now, wasn’t it?</p>

<p>Be aware, the code above hasn’t been tested.  Although I copied it from a
(working) data width bus translation module, I found some bugs and made some
changes along the way.  Hence, if you try this and find any bugs, then please
please write me at the e-mail address in the postscript below.</p>

<p>You may also notice that <code class="language-plaintext highlighter-rouge">r_stb</code> and <code class="language-plaintext highlighter-rouge">o_busy</code> above are the same signal.  I’ve
kept them separate for conceptual understanding, but these two can be
combined into a single signal.</p>

<p>The overall approach, though, is a clear example of how
<a href="https://en.wikipedia.org/wiki/Logic_block">logic resources</a>
can be traded
to achieve pipeline speed and throughput.  Indeed, it is only one of many
examples, but its a worthwhile lesson to take away from this exercise. 
While I haven’t done so, I think that if you <a href="/blog/2017/06/12/minimizing-luts.html">count the
LUTs</a>
used by this routine, you’ll find that all this extra logic has at least
doubled the number of
<a href="https://en.wikipedia.org/wiki/Logic_block">LUTs</a> required.</p>

<p>Although this is a useful approach to pipelining, it may easily be more
logic than your problem requires.  Indeed, very few of my own routines
have ever needed to use this buffered handshaking approach.  The routines
that have needed to use it tend to be <a href="/zipcpu/2017/05/29/simple-wishbone.html">wishbone
peripherals</a>
with complex logic within them–such as my <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM
controller</a>,
my attempt at a <a href="https://opencores.org/project,wbddr3">DDR3 SDRAM controller</a>,
or a wishbone bus width expansion module that I put together for an
HDMI video project.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We’ve now walked through several examples of the signaling associated with
pipeline logic.  These examples have gone from the simple global <code class="language-plaintext highlighter-rouge">CE</code> approach,
all the way to a buffered handshake approach.  Which type of pipeline signaling
you use will be specific to your problem and your needs.  However, these
approaches should handle most of the problems you might have.</p>

<p>Let’s come back to this topic of pipelining at least one more time, though,
and look at how the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> handles
its pipeline signaling within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU proper</a>.
This is a more complicated environment, as lots of events can stall the 
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
along the way.  Indeed, handling the pipeline needs of a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
can be quite a challenge.</p>

<p>That will then be our next post on this topic.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For the time is come that judgment must begin at the house of God: and if it first begin at us, what shall the end be of them that obey not the gospel of God? (1Pet 4:17)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
