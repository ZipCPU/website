<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Taking a New Look at Verilator</title>
  <meta name="description" content="I’d like to discuss a very profound simulation capability, one that I havefound to be amazingly useful when building and understanding my ownsoftware.  In pa...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2017/06/21/looking-at-verilator.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Taking a New Look at Verilator</h1>
    <p class="post-meta"><time datetime="2017-06-21T00:00:00-04:00" itemprop="datePublished">Jun 21, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I’d like to discuss a very profound simulation capability, one that I have
found to be <em>amazingly</em> useful when building and understanding my own
software.  In particular, I’d like to discuss
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.  No, not <em>just</em>
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.  I’d like to discuss how
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
can be incorporated into your designs to provide you with a simulation tool
that, to my knowledge, is not matched elsewhere.</p>

<p>If you are a Verilog programmer and you are not familiar with
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>, then
let this be my opportunity to call this wonderful tool to your attention.</p>

<p>If you are a VHDL programmer, you may be disappointed to learn that
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a> only works with Verilog,
not with VHDL.  Perhaps I can use this opportunity to show you some of what
you are missing.</p>

<p>According to the <a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
<a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator#NAME">manual</a>,
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a> is used to
“Convert Verilog code to C++/System C”.  For the purpose of this
article, we’ll consider only the Verilog to C++ converter part.  Further, we’re
going to discuss what can be done with such a capability, and why it is so
amazingly valuable.</p>

<h2 id="basic-verilator-testbench">Basic Verilator Testbench</h2>

<p>If you’ve never used
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
before, and you wish to try it out, the first
step is the same as with any other program you’d like to try on your computer.
You’ll need to download
<a href="https://www.veripool.org/projects/verilator/wiki/Installing">download</a>
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
and <a href="https://www.veripool.org/projects/verilator/wiki/Installing">install</a> it.
For me, this was as simple as “sudo apt-get install verilator”, but other
approaches exist as well.</p>

<p>Once you have it installed, let’s walk through how you might use it.
Specifically, we’ll walk through an example of what it takes to set your
project up to use it.</p>

<p>This first step discussion for how to use
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
will follow closely with the quick
<a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator#EXAMPLE-C-EXECUTION">example code</a>
found in the
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
<a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator">Manual</a>.
This will show us what we need to know in order to use
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a> with any project.</p>

<p>You will start by running the
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
command line program on your top level Verilog file.  For the purposes of this
discussion, let’s assume that top level file is a very generic “module.v”.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">verilator -Wall -cc module.v</code></pre></figure>

<p>Assuming your design has no syntax errors, this
will create a directory, obj_dir, and a C++ class definition for
Vmodule in the files obj_dir/Vmodule.h and obj_dir/Vmodule.cpp.
Another file in that directory, obj_dir/Vmodule.mk, can be used to “make”
these files into the library that you will need to link your C++ driver
program to.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">cd obj_dir; make -f Vmodule.mk ; cd ..</code></pre></figure>

<p>We’re going to spend most of our time in this post looking at how to drive this
C++ code to simulate your design.</p>

<p>If you look through the <a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator">Verilator
manual</a>,
you’ll find an <a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator#EXAMPLE-C-EXECUTION">example</a>
test bench driver that looks similar to the following:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;stdlib.h&gt;
#include "Vmodule.h"
#include "verilated.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Initialize Verilators variables
</span>	<span class="n">Verilated</span><span class="o">::</span><span class="n">commandArgs</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

	<span class="c1">// Create an instance of our module under test
</span>	<span class="n">Vmodule</span> <span class="o">*</span><span class="n">tb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vmodule</span><span class="p">;</span>

	<span class="c1">// Tick the clock until we are done
</span>	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">Verilated</span><span class="o">::</span><span class="n">gotFinish</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
	<span class="p">}</span> <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>We’ll walk through this example from the top.</p>

<p>The <a href="http://en.cppreference.com/w/cpp/language/main_function">main()</a> program that uses
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
must initialize
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a> with
any arguments (argc and argv), and then it needs to create a new object of the
class Vmodule–where module.v is the name of the design we applied the
Verilator program to above.</p>

<p>Before we get to that next step, you need to know that the Vmodule class that
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
created for you exposes all of your inputs and outputs as variables.
Hence you can set the <strong>i_clk</strong> input to your module.  Changing this value
from a 0 to a 1 will also cause any <strong>@(posedge i_clk)</strong> logic to trip as well.</p>

<p>Hence, our job when simulating is just to run a tight loop where we set the
clock, evaluate everything, set the clock again, and evaluate everything again.
The loop stops when
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
comes across a <a href="http://users.ece.utexas.edu/~patt/14s.382N/tools/verilog_manual.html#finish">$finish</a> statement within the
Verilog code, or when you type a Ctrl-C.  (I hardly ever use the $finish
statement, so Ctrl-C is one of the main ways I terminate a simulation.)</p>

<p>This sounds simple enough, but let’s see if we can’t simplify it a touch more.</p>

<p>I’d like to create, from this outline, a test bench module that incorporates
all of this information.  We’ll call it
TESTBENCH, and you can see an example of how I’ve used a very similar
capability within the ZipCPU project
<a href="https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/testb.h">here</a>.
Our TESTBENCH class will provide
two functions: reset() and tick(), and we want to be able to check any time
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>’s
code has encountered a
<a href="http://users.ece.utexas.edu/~patt/14s.382N/tools/verilog_manual.html#finish">$finish</a> statement.
To do this, we can wrap the above code in a class, as in:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">MODULE</span><span class="o">&gt;</span>	<span class="k">class</span> <span class="nc">TESTBENCH</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">m_tickcount</span><span class="p">;</span>
	<span class="n">MODULE</span>	<span class="o">*</span><span class="n">m_core</span><span class="p">;</span>

	<span class="n">TESTBENCH</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_core</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vmodule</span><span class="p">;</span>
		<span class="n">m_tickcount</span> <span class="o">=</span> <span class="mi">0l</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">virtual</span> <span class="o">~</span><span class="n">TESTBENCH</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">delete</span> <span class="n">m_core</span><span class="p">;</span>
		<span class="n">m_core</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">virtual</span> <span class="kt">void</span>	<span class="n">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="c1">// Make sure any inheritance gets applied
</span>		<span class="k">this</span><span class="o">-&gt;</span><span class="n">tick</span><span class="p">();</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">virtual</span> <span class="kt">void</span>	<span class="n">tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Increment our own internal time reference
</span>		<span class="n">m_tickcount</span><span class="o">++</span><span class="p">;</span>

		<span class="c1">// Make sure any combinatorial logic depending upon
</span>		<span class="c1">// inputs that may have changed before we called tick()
</span>		<span class="c1">// has settled before the rising edge of the clock.
</span>		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>

		<span class="c1">// Toggle the clock
</span>
		<span class="c1">// Rising edge
</span>		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>

		<span class="c1">// Falling edge
</span>		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">virtual</span> <span class="n">bool</span>	<span class="n">done</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">Verilated</span><span class="o">::</span><span class="n">gotFinish</span><span class="p">());</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The main program likewise needs to change, but it primarily just gets
simplified:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include "testbench.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Verilated</span><span class="o">::</span><span class="n">commandArgs</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="n">TESTBENCH</span><span class="o">&lt;</span><span class="n">Vmodule</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">tb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TESTBENCH</span><span class="o">&lt;</span><span class="n">Vmodule</span><span class="o">&gt;</span><span class="p">();</span>

	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tick</span><span class="p">();</span>
	<span class="p">}</span> <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>At this point, we’ve just reworded things.  We haven’t really created any
new features.  We have, however, insisted that any module.v using this
test harness must have inputs <strong>i_clk</strong> and <strong>i_reset</strong>.</p>

<p>One more step is required before we can use this program.  We need
to compile our program, and we need to point the compiler to any include
files that were created in our obj_dir directory, as well as adding some
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
specific components:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">g++ -I obj_dir -I/usr/share/verilator/include module.cpp /usr/share/verilator/include/verilated.cpp -o module</code></pre></figure>

<p>Your actual Verilator components may not be in the /usr/share/verilator directory, depending upon how your distribution installed
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.
You can find out the correct directory by looking for <strong>$VERILATOR_ROOT</strong>
in the output of</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">verilator -V</code></pre></figure>

<p>At this point we have a program, module, that we can run that will simulate
our Verilog module.</p>

<p>You can see an example of one such test bench I use
<a href="https://github.com/ZipCPU/zipcpu/blob/master/sim/verilator/testb.h">here</a>.
If you look a bit harder, you may even find several versions of this module
wandering around other projects found in
<a href="https://github.com/ZipCPU">ZipCPU’s github</a>.</p>

<p>Ok, so now we can simulate our design–much like any other simulator.
You might argue at this point that Verilator is less than the other
simulation design programs.  While it can simulate our design, it’s not as
simple to set up.</p>

<p>Don’t worry, we’re not done yet.</p>

<p>Let’s go a step further.  Let’s start using
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
to perform some simple magic for us.</p>

<h2 id="debugging-verilog-via-printf">Debugging Verilog via Printf</h2>

<p>The first thing we are going to do with
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a> is to describe how you
can print out values from within your simulation.  This will turn Verilog
simulation debugging into something very akin to software debugging.</p>

<p>When I debug software, I tend to use two approaches:
<a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>
and <a href="https://www.gnu.org/software/gdb/">gdb</a>.
By using the two of these, I tend to stay of of the realm of
“Voodoo computing” (my personal term for the software equivalent of
<a href="/fpga-hell.html">FPGA Hell</a>–when you have no idea what is
going wrong with your software).  If a piece of software
I am working with creates a core dump, my first approach to finding the bug
is usually to use <a href="https://www.gnu.org/software/gdb/">gdb</a>.  In all other
cases, such as when I am just trying to understand what is going on, I’ll use
<a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>
and I’ll just dump any piece of
relevant data to the standard output stream.  As a last resort, I’ll pull
up <a href="https://www.gnu.org/software/ddd/">ddd</a> and step through my code and any
library code I’m using.</p>

<p>One of the big problems with debugging FPGA’s, though, is that there are no
<a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>
capabilities within FPGA’s.  Hence, software engineers trying to program
FPGA’s often find themselves stuck when things don’t work.  Their favorite
tool is missing.</p>

<p>While the official Verilog answer to this is the <a href="http://www.referencedesigner.com/tutorials/verilog/verilog_09.php">$monitor
command</a>
within Verilog, I’d like to demonstrate a different approach using
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.</p>

<p>The first thing we are going to do to create this debug by
<a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>
capability
is to subclass our TESTBENCH class.  We’ll create a new class, called
MODULE_TB, that inherits from the TESTBENCH.  This will allow us to maintain
a generic TESTBENCH across many projects, but yet still add functionality
to it that is specific to the module we are testing.</p>

<p>The next thing we are going to do is to override the method we just created
above for requesting a clock tick.  We’re going to replace that method with
another method that first calls the original tick method, and then outputs
whatever logic we’d like to know about.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">MODULE</span><span class="n">_TB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TESTBENCH</span><span class="o">&lt;</span><span class="n">Vmodule</span><span class="o">&gt;</span> <span class="p">{</span>

	<span class="k">virtual</span> <span class="kt">void</span>	<span class="n">tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Request that the testbench toggle the clock within
</span>		<span class="c1">// Verilator
</span>		<span class="n">TESTBENCH</span><span class="o">&lt;</span><span class="n">Vmodule</span><span class="o">&gt;::</span><span class="n">tick</span><span class="p">();</span>

		<span class="c1">// Now we'll debug by printf's and examine the
</span>		<span class="c1">// internals of m_core
</span>		<span class="n">printf</span><span class="p">(</span><span class="s">"%8ld: %s %s ...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">m_tickcount</span><span class="p">,</span>
			<span class="p">(</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">v__DOT__wb_cyc</span><span class="p">)</span><span class="o">?</span><span class="s">"CYC"</span><span class="o">:</span><span class="s">"   "</span><span class="p">,</span>
			<span class="p">(</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">v__DOT__wb_stb</span><span class="p">)</span><span class="o">?</span><span class="s">"STB"</span><span class="o">:</span><span class="s">"   "</span><span class="p">,</span>
			<span class="p">...</span> <span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>As a result, we just added a
<a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>
capability to Verilog via
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.</p>

<p>Did you notice the values “<strong>v__DOT__wb_cyc</strong>” and
“<strong>v__DOT__wb_stb</strong>”?
These are local registers within the Vmodule construct that
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.
created for us.  They are being used to hold the values of the <strong>wb_cyc</strong> and
<strong>wb_stb</strong> registers used to run an internal wishbone bus.  Indeed, all of
your registers should be visible to you
from the <strong>m_core</strong> structure we have created.  While the naming tends to be
roughly consistent, if you struggle finding a variable you would like to print
then just look through the obj_dir/Vmodule.h file.  If you are still
struggling, take a look at how a known variable in obj_dir/Vmodule.cpp is
being set, and you should be able to figure out the internal variable name.</p>

<p>I should also point out: <a href="https://www.veripool.org/wiki/verilator/">Verilator</a>’s
variable naming convention has changed over time.  While my version of
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
works with a “v__DOT__” preceding any top
level register name, and the “__DOT__” substrings indicate hierarchical
transitions between
components, you may have to look within your own module to find how your
variables are named.  It’s for this reason that, in any new designs, I start
the design with a series of #define’s indicating the
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
to C++ mapping, so I know how to get access to any variables of interest.</p>

<p>As an example, <a href="https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/main_tb.cpp">this
file</a>
begins with a set of #define’s that I use to simplify access to various
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> internal variable names.</p>

<p>Remember, this is for debugging–so a little cheating is allowed.</p>

<p>We’re not done yet, though.</p>

<p>That <a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>
capability can print an enormous amount of information to the screen–Gigabytes
even!  It can print information that we are interested in, but it can
also print so much irrelevant information that it can be a struggle to find
the relevant information we are interested in.</p>

<p>For this reason, I often add a boolean “writeout” variable prior to any
<a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>’s,
which I then use to gate whether or not I
<a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a> any values.  I can
then use this value to look for whatever conditions I find useful for debugging
that day.  For example, the code below will write out the relevant portions
of any internal wishbone transaction.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">MODULE</span><span class="n">_TB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TESTBENCH</span><span class="o">&lt;</span><span class="n">Vmodule</span><span class="o">&gt;</span> <span class="p">{</span>

	<span class="k">virtual</span> <span class="kt">void</span>	<span class="n">tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Request that the testbench toggle the clock within
</span>		<span class="c1">// Verilator
</span>		<span class="n">TESTBENCH</span><span class="o">&lt;</span><span class="n">Vmodule</span><span class="o">&gt;::</span><span class="n">tick</span><span class="p">();</span>

		<span class="n">bool</span>	<span class="n">writeout</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="c1">// Check for debugging conditions
</span>		<span class="c1">//
</span>		<span class="c1">// For example:
</span>		<span class="c1">//
</span>		<span class="c1">//   1. We might be interested any time a wishbone master
</span>		<span class="c1">//	command is accepted
</span>		<span class="c1">//
</span>		<span class="k">if</span> <span class="p">((</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">v__DOT__wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">v__DOT__wb_stall</span><span class="p">))</span>
			<span class="n">writeout</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="c1">//
</span>		<span class="c1">//   2. as well as when the slave finally responds
</span>		<span class="c1">//
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">v__DOT__wb_ack</span><span class="p">)</span>
			<span class="n">writeout</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">writeout</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Now we'll debug by printf's and examine the
</span>			<span class="c1">// internals of m_core
</span>			<span class="n">printf</span><span class="p">(</span><span class="s">"%8ld: %s %s ...</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">m_tickcount</span><span class="p">,</span>
				<span class="p">(</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">v__DOT__wb_cyc</span><span class="p">)</span><span class="o">?</span><span class="s">"CYC"</span><span class="o">:</span><span class="s">"   "</span><span class="p">,</span>
				<span class="p">(</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">v__DOT__wb_stb</span><span class="p">)</span><span class="o">?</span><span class="s">"STB"</span><span class="o">:</span><span class="s">"   "</span><span class="p">,</span>
				<span class="p">...</span> <span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Others who have looked at this approach consider it very “textual”.  It is.</p>

<p>If you find “textual” to be old fashioned, then please consider that I maintain
a very old fashioned hammer in my garage for when I need such a tool.
Like my hammer, this old fashioned approach to debugging is still very
valuable.  When I was debugging the
<a href="https://github.com/ZipCPU/openarty/blob/master/sw/board/hello.c">Hello World</a>
program in the <a href="https://github.com/ZipCPU/openarty">OpenArty</a> project, as part
of both the first time the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
supported the
C library as well as the first time it supported 8-bit bytes, this was the
approach I used when things weren’t working.  When I traced the problem down
to a value in memory that had the wrong value within it, I was then able to look
backwards through the massive textual output to find the exact memory operation
that had set the value erroneously.  I was then able to quickly find the
broken logic and fix the bug.</p>

<p>This debug by <a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>
approach should satisfy most of the software programmers
out there who are used to finding bugs in this manner.</p>

<p>Many hardware designers are going to look for something more.  Hence,
let’s look at how to use a graphical waveform viewer such as
<a href="http://gtkwave.sourceforge.net">GTKWave</a>.</p>

<h2 id="debugging-verilog-via-gtkwave">Debugging Verilog via GTKWave</h2>

<p>If you’ve never used a waveform viewer, such as
<a href="http://gtkwave.sourceforge.net">GTKWave</a>
before, then you are in for a treat.  Such graphical viewers are really an
essential part of any HDL designers toolkit.  Using
<a href="http://gtkwave.sourceforge.net">GTKWave</a>, you can view and inspect
<em>every</em> variable within your design on <em>every</em> clock.</p>

<p>Let’s rebuild our module so that it creates a
<a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD</a> output file that can
then be read by <a href="http://gtkwave.sourceforge.net">GTKWave</a>.  This will allow
us to examine our design using it.</p>

<p>The first change we are going to need to make is to change how we call
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.
Specifically, we’ll add the “–trace” option to the command line.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">verilator -Wall --trace -cc module.v</code></pre></figure>

<p>This will turn our module into a C++ class, found within obj_dir/Vmodule.h
and .cpp as before, but this time it can support tracing.  We can turn this
C++ class definition into a library in the same fashion as before.</p>

<p>The next step in this process is going to be transforming the TESTBENCH wrapper
of our <a href="https://www.veripool.org/wiki/verilator/">Verilated</a>
module.  If you want, you can follow along on how to do this from the
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
<a href="https://www.veripool.org/projects/verilator/wiki/Manual-verilator#FREQUENTLY-ASKED-QUESTIONS">FAQ</a>, although I think you’ll find we go into a touch more
detail here.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;verilated_vcd_c.h&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">MODULE</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">TESTBENCH</span> <span class="p">{</span>
	<span class="c1">// Need to add a new class variable
</span>	<span class="n">VerilatedVcdC</span>	<span class="o">*</span><span class="n">m_trace</span><span class="p">;</span>
	<span class="p">...</span>

	<span class="n">TESTBENCH</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// According to the Verilator spec, you *must* call
</span>		<span class="c1">// traceEverOn before calling any of the tracing functions
</span>		<span class="c1">// within Verilator.
</span>		<span class="n">Verilated</span><span class="o">::</span><span class="n">traceEverOn</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
		<span class="p">...</span> <span class="c1">// Everything else can stay like it was before
</span>	<span class="p">}</span>

	<span class="c1">// Open/create a trace file
</span>	<span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">opentrace</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vcdname</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_trace</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m_trace</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VerilatedVcdC</span><span class="p">;</span>
			<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">trace</span><span class="p">(</span><span class="n">m_trace</span><span class="p">,</span> <span class="mi">99</span><span class="p">);</span>
			<span class="n">m_trace</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">vcdname</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Close a trace file
</span>	<span class="k">virtual</span> <span class="kt">void</span>	<span class="n">close</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_trace</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m_trace</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
			<span class="n">m_trace</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">virtual</span> <span class="kt">void</span>	<span class="n">tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Make sure the tickcount is greater than zero before
</span>		<span class="c1">// we do this
</span>		<span class="n">m_tickcount</span><span class="o">++</span><span class="p">;</span>

		<span class="c1">// Allow any combinatorial logic to settle before we tick
</span>		<span class="c1">// the clock.  This becomes necessary in the case where
</span>		<span class="c1">// we may have modified or adjusted the inputs prior to
</span>		<span class="c1">// coming into here, since we need all combinatorial logic
</span>		<span class="c1">// to be settled before we call for a clock tick.
</span>		<span class="c1">//
</span>		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>

		<span class="c1">//
</span>		<span class="c1">// Here's the new item:
</span>		<span class="c1">//
</span>		<span class="c1">//	Dump values to our trace file
</span>		<span class="c1">//
</span>		<span class="k">if</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="n">m_trace</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">m_tickcount</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>

		<span class="c1">// Repeat for the positive edge of the clock
</span>		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="n">m_trace</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">m_tickcount</span><span class="p">);</span>

		<span class="c1">// Now the negative edge
</span>		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">eval</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_trace</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// This portion, though, is a touch different.
</span>			<span class="c1">// After dumping our values as they exist on the
</span>			<span class="c1">// negative clock edge ...
</span>			<span class="n">m_trace</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">m_tickcount</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
			<span class="c1">//
</span>			<span class="c1">// We'll also need to make sure we flush any I/O to
</span>			<span class="c1">// the trace file, so that we can use the assert()
</span>			<span class="c1">// function between now and the next tick if we want to.
</span>			<span class="n">m_trace</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Further, within our
<a href="http://en.cppreference.com/w/cpp/language/main_function">main()</a>
function, we’ll add a line,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">tb</span><span class="o">-&gt;</span><span class="n">opentrace</span><span class="p">(</span><span class="s">"trace.vcd"</span><span class="p">);</span></code></pre></figure>

<p>any time we want to create a
<a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD</a> output file.</p>

<p>Building this new program is a touch more difficult than it was before.  You
are going to need to include the verilated_vcd_c.cpp file, but in all other
cases the build is the same.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">g++ -I obj_dir -I/usr/share/verilator/include module.cpp /usr/share/verilator/include/verilated.cpp /usr/share/verilator/include/verilated_vcd_c.cpp -o module</code></pre></figure>

<p>After you run your “module” file, you should now find a “trace.vcd” file
in your current directory.  Running “gtkwave trace.vcd” should give you a
chance to view all of the variables within your trace.  In other words, after
you finish a simulation, you can now view all of your internal register values,
at <em>every</em> simulation clock tick.</p>

<h2 id="simulating-peripherals-with-verilator">Simulating Peripherals with Verilator</h2>

<p>At this point, we haven’t really done anything any other simulator cannot do.
We’ve simulated our program, <em>and</em> we’ve created both a
<a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>
based dump of the program as well as trace.</p>

<p>Where <a href="https://www.veripool.org/wiki/verilator/">Verilator</a> really shines,
though, is in the ability to add simulated peripherals to the design.  Let’s
consider three peripherals as part of an example:</p>

<ol>
  <li>
    <p>A <a href="https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp">UART simulator</a>
that allows you to connect the UART to either a file, or a TCP/IP stream.</p>

    <p>The importance of this type of simulator cannot be overstated, as it allows
you to create a debugging interface to your board–an interface that you
can also access when running your simulator.</p>

    <p>Many students have struggled to get their first UART up and running.  Having
a UART simulator, which would check their outputs and verify it’s validity
while acting <em>like</em> a true UART would be valuable for them.</p>
  </li>
  <li>
    <p>A <a href="https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp">QSPI Flash simulator</a>.  I’ve used this simulator many, many times to
not only verify that the core I am testing properly interacts with the
on-board flash, but also to know and understand how that flash interaction
impacts the rest of my design.</p>

    <p>For example, using the
<a href="https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/qspiflashsim.cpp">QSPI Flash simulator</a>
together with the <a href="https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp">UART simulator</a>, I
can start the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> from a hard
reset and run all the way through <a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c">Hello
World</a>
without leaving the simulation.</p>

    <p>The other day, I had the chance to then compare how long it takes to do
this when using a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA</a>
based <a href="https://github.com/ZipCPU/zbasic/blob/master/sw/zlib/crt0.c">bootloader</a>
approach, given that the simulations are <em>cycle accurate</em>.
(The DMA approach is almost 2x as fast–but feel free to try it yourself
to find out.)</p>
  </li>
  <li>
    <p>A <a href="https://github.com/ZipCPU/vgasim">VGA simulator</a> I used to process the VGA signal on my
<a href="https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users">Basys3</a>
board.  Using
<a href="https://github.com/ZipCPU/vgasim">this simulator</a>, I was not only able to
verify the functionality of my
<a href="https://github.com/ZipCPU/vgasim/blob/master/rtl/llvga.v">VGA outputs</a>,
but I was also able to display the pixels that would be displayed on any
<a href="https://github.com/ZipCPU/vgasim/blob/master/bench/cpp/vgasim.cpp">VGA screen within an X-window</a> on my own
development workstation.</p>

    <p>Who knows?  I may have the opportunity to present this simulator as part of
this blog.</p>

    <p>Compare <a href="https://github.com/ZipCPU/vgasim">this simulator</a>, though, to <a href="http://vgasim.sourceforge.net">an
alternative</a> that works with your more
commercial simulation products.  Unlike that approach, if you had a
simulator integrated into
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>,
you could then interact with your VGA display in real simulation time–even
if it is a slower (realtime) than the actual hardware would’ve provided.</p>
  </li>
</ol>

<p>To incorporate these changes into our module’s simulation, we only need to
make some minor adjustments to our overloaded tick() method.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// Include the files defining our various simulation components
</span><span class="cp">#include &lt;uartsim.h&gt;
#include &lt;qspiflashsim.h&gt;
#include &lt;vgasim.h&gt;
</span>
<span class="k">class</span> <span class="nc">MODULE</span><span class="n">_TB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TESTBENCH</span><span class="o">&lt;</span><span class="n">Vmodule</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="c1">// Add the simulation components to the variables used by our module's
</span>	<span class="c1">// test bench
</span>	<span class="n">UARTSIM</span>		<span class="o">*</span><span class="n">m_uart</span><span class="p">;</span>
	<span class="n">QSPIFLASHSIM</span>	<span class="o">*</span><span class="n">m_flash</span><span class="p">;</span>
	<span class="n">VGASIM</span>		<span class="o">*</span><span class="n">m_vga</span><span class="p">;</span>

	<span class="n">MODULE_TB</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Initialize as before
</span>		<span class="p">...</span>
		<span class="c1">// Then make sure we create our simulation components
</span>		<span class="n">m_uart</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UARTSIM</span><span class="p">();</span>
		<span class="n">m_qspi</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSPIFLASHSIM</span><span class="p">();</span>
		<span class="n">m_vga</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">VGASIM</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">virtual</span> <span class="kt">void</span>	<span class="n">tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Simulation instructions
</span>		<span class="c1">//
</span>		<span class="c1">// Prior to actually ticking the clock, call any simulation
</span>		<span class="c1">// functions
</span>
		<span class="c1">// Simulate a UART
</span>		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_uart</span> <span class="o">=</span> <span class="n">m_uart</span><span class="p">(</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_uart</span><span class="p">);</span>

		<span class="c1">// Simulate a QSPI Flash
</span>		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_qspi_data</span> <span class="o">=</span> <span class="n">qspi_flash_simulator</span><span class="p">(</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_qspi_clk</span>
			<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_qspi_cs_n</span><span class="p">,</span> <span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_qspi_data</span><span class="p">,</span>
			<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_qspi_output_mode</span><span class="p">);</span>

		<span class="c1">// Simulate a VGA
</span>		<span class="n">m_vga</span><span class="p">(</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_vga_vsync</span><span class="p">,</span>
			<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_vga_hsync</span><span class="p">,</span>
			<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_vga_red</span><span class="p">,</span>
			<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_vga_grn</span><span class="p">,</span>
			<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_vga_blue</span><span class="p">);</span>

		<span class="c1">//
</span>		<span class="c1">// Now that we have our simulation inputs/outputs handled,
</span>		<span class="c1">// let's actually toggle our clock
</span>		<span class="c1">//
</span>		<span class="n">TESTBENCH</span><span class="o">&lt;</span><span class="n">Vmodule</span><span class="o">&gt;::</span><span class="n">tick</span><span class="p">();</span>

		<span class="c1">// This is the code we had before
</span>		<span class="n">bool</span>	<span class="n">writeout</span><span class="p">;</span>
		<span class="p">...</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Here, you can see how our overloaded tick() method first called the update
methods of any simulators we had introduced.
This guarantees that such simulators can handle data on a clock by clock basis,
verifying the outputs of your design, and providing whatever capability is
necessary on every clock tick.  Once any simulation inputs or outputs have
been handled, we then call the test bench’s tick method, so as to handle
toggling the clock, keeping track of simulation time, and writing anything to
the trace file.</p>

<p>Let’s pause for a moment at this point and let what we’ve just done sink
in.</p>

<p>Perhaps some examples will help.</p>

<ul>
  <li>
    <p>I’ve used this approach to debug my
<a href="http://opencores.org/project,qspiflash">QSPIFLASH</a> controller.  Yes, I did
this using the debug by
<a href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a>
method to find problems.  I also placed assert statements within the QSPI
flash decoding logic of the simulator.  This would cause the QSPI flash
controller to <em>halt</em> the simulation any time it detected an error in the
protocol.  For example, I could detect whether or not I waited enough
clocks on startup before issuing the first command.</p>
  </li>
  <li>
    <p>I’ve used this approach to debug the <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM
controller</a>
that I built for the XuLA2-LX25 board.  Because the <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/bench/cpp/sdramsim.cpp">SDRAM
simulation</a>
I built was cycle accurate, I could then run performance and bench testing
programs on the board later, and know just how well the board would perform.</p>
  </li>
  <li>
    <p>The <a href="https://github.com/ZipCPU/vgasim">VGA simulator</a> on my
<a href="https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users">Basys3</a>
board might be worth discussing for a moment.</p>

    <p>Because the
<a href="https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users">Basys3</a>
didn’t have enough RAM for a frame buffer, I had to place
the video data into the QSPI flash memory.  To make matters worse, I needed
to compress
the flash (run length encoding) to get the data so that I could load it
fast enough to support the VGA frame rate I was working with.</p>

    <p>When I tried the algorithm out on the real hardware, the initial result was
quite jumbled–as one might expect from the first time you try to build and
test <em>any</em> decompression algorithm.  However, by simulating the video
hardware, I could find and pinpoint where the run-length decoding went bad,
and therefore fix my algorithm.</p>

    <p>Further, because I was using a cycle accurate QSPI flash simulator (from
above), I could make certain that I was meeting the timing I needed to meet
to make this VGA run without data loss.</p>

    <p>I expect to need to build an HDMI simulator in the near future as well–both
for input as well as output.</p>
  </li>
  <li>
    <p>I also used this approach to debug an <a href="https://github.com/ZipCPU/sdspi">SD-card
controller</a> that controls an SD card via a
SPI interface.</p>

    <p>Given the opportunity, I’ll likely use the same method to build and debug
a similar controller using the SDIO interface instead of the SPI interface
in the future.</p>
  </li>
  <li>
    <p>Other things I’ve simulated include a PS/2 mouse connected to my
<a href="https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users">Basys3</a>
board, the ethernet controller on my
<a href="http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists">Arty</a> board,
the GPS PPS signal from a <a href="http://store.digilentinc.com/pmod-gps-gps-receiver">PMod GPS</a>,
and even a <a href="http://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution">PMod OLEDrgb board</a>.</p>
  </li>
</ul>

<p>Here’s another neat fact in all of this: because these simulations are built
from independent source code modules, we can link them together to create
intregrated simulations as well.  As an example, I can now simulate the
<a href="https://github.com/ZipCPU/">ZipCPU</a> in an
<a href="https://github.com/ZipCPU/zbasic">environment</a> where the CPU has
access not not only a UART, but also an SD-Card.</p>

<h2 id="only-one-clock">Only one clock</h2>

<p>While this approach is very powerful, what I’ve demonstrated above only
demonstrates applying
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
to a design with a single clock.</p>

<p>I’m currently working on a design of a Video driver that will read HDMI
signals at one rate, write HDMI signals back out at (perhaps) another rate,
interact
with the CPU at a fourth rate, and interact with DDR3 SDRAM memory at a fifth
rate.  While <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> can currently build
a test harness for such a simulation, the work to handle all of these clocks
and to display the resulting video is far from complete.
This may even include <a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
support for having one of those clocks have an adjustable period–but we’ll
see what is required for actually making all of that work.</p>

<p>In other words, should you find the amazing
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
capabilities outlined above valuable when using a single clock, then
please consider yourself invited to contact the author of
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a> and support his work.</p>

<p>If you would like to help fund my own work of creating a test harness that will
support multiple clocks, and even HDMI video, please feel free to <a href="https://www.patreon.com/ZipCPU">support 
this blog on Patreon</a>.</p>

<h2 id="other-benefits">Other Benefits</h2>

<p>Before I leave off discussing the value of
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
to discuss its limitations,
let me add one more item to my list of its benefits: It’s a <em>lot</em> faster to
compile a Verilog module using Verilator than it is to compile and build it
using a more traditional synthesis tool and design flow.</p>

<p>What I mean by this is, if I start a Vivado design build and a
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
design build at the same time, then I will have found any synthesis bugs
with
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
long before Vivado completes.</p>

<p>Further,
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
finds many bugs that Vivado either does not find, or that it buries in a long
list of useless warnings.</p>

<p>Put together, these facts provide me with the motivation I need to build my
projects within <a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
before trying to build it with a commercial synthesis tool.  Finding and
fixing bugs is just so much faster and easier with
Verilator.</p>

<p>On the other hand, <a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
tends to run my 100MHz clock at about 300kHz (without optimization),
so there does come a transition point where using the real hardware becomes
faster/better/cheaper than using
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>’s simulation capability.</p>

<h2 id="verilators-limitations">Verilator’s Limitations</h2>

<p>While I have very much grown to love using the
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
approach I just outlined above, there are a couple of limitations I’ve come
across when using it:</p>

<ol>
  <li>
    <p>You can only design components for which you have all of the Verilog
logic in hand.</p>

    <p>For example, while there exist proprietary <a href="https://www.xilinx.com/support/documentation/ip_documentation/xfft/v9_0/pg109-xfft.pdf">vendor supplied
FFT’s</a>,
you will struggle to use them within
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.</p>

    <p>This will force you to either abandon
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>, to look for
an open source <a href="https://github.com/ZipCPU/dblclockfft">alternative to their
FFT</a>s,
or to simulate every portion of your design <em>except</em> for the proprietary
component.</p>

    <p>As a second example, while both Xilinx and Altera will provide you with
a soft core CPU and toolchain, you will struggle to test such a CPU within
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.</p>

    <p>On the other hand, you could still verify your design using
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
if you were using a <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>.
Gosh, even the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> debugger can run
within <a href="https://www.veripool.org/wiki/verilator/">verilator</a>, using the same
serial port interface it would have were it running on an FPGA.  Hence, as
with the FFT, open source alternative’s exist.  (I’ve also managed to run
the <a href="https://openrisc.io">OpenRISC CPU</a> within
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a> as well, so
the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> is by no means
unique–although I did need to add a <a href="https://github.com/ZipCPU/wbuart32/blob/master/bench/cpp/uartsim.cpp">UART
simulation</a>
to the <a href="https://openrisc.io">OpenRISC CPU</a> to do it.)</p>
  </li>
  <li>
    <p><a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
only works with Verilog, not VHDL.  Perhaps you would like to write or
contribute to a VHDL extension to
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>?  That’s the beauty
of open source, right?</p>
  </li>
  <li>
    <p><a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
has only limited support for tri-state busses, and absolutely no support
for vendor specific things such as clock modules or SERDES capabilities.</p>

    <p>I get around this by placing all of my logic within a vendor-independent
module.  This is my “main” module beneath the top level file containing any
vendor dependent capabilities.</p>
  </li>
  <li>
    <p><a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
has no support for handling ‘x’ (unknown) values or ‘z’ (high impedence)
values.  Neither does <a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
recognize or comment on any potential clock transition conflicts, or
<a href="https://en.wikipedia.org/wiki/Metastability_in_electronics">metastability</a>
issues.</p>
  </li>
  <li>
    <p>Synthesizing a project with
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>
will provide you no feedback regarding whether or not your design will fit
within a particular device, neither whether or not your design would meet
the timing requirements of a particular device.  You still need a fullblown
FPGA tool chain to find out these things.</p>

    <p>While I recommend <a href="https://www.veripool.org/wiki/verilator/">Verilator</a> as
an approach for young engineers just learning to program in Verilog for
the first time, this is the biggest limitation.  The reality is that,
at some time, you will need to convert your design into a physical
reality, and at that time you’re going to want to know if it will work
on your target device.</p>
  </li>
</ol>

<p>Still, with all its limitations,
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a> has been a fundamental
component of every one of my designs.</p>

<h2 id="my-personal-experience">My Personal Experience</h2>

<p>If you look across the <a href="https://github.com/ZipCPU">various projects I’ve posted on
GitHub</a>, you may notice that almost all of them use
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a> for simulation.
Even the <a href="https://github.com/ZipCPU/tttt">4x4x4 Tic-tac-toe program</a> that I
posted to test the C-library on my devices can run on the
<a href="https://github.com/ZipCPU">ZipCPU</a> using
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.
Perhaps the best recommendation I can give for
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>, therefore, is simply
the facts that 1) these projects work, 2) some of them are both quite
capable and complex, and 3) they have all been debugged with
<a href="https://www.veripool.org/wiki/verilator/">Verilator</a>.</p>

<p>How about your experience?  I’d love to hear some of your comments below.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Shall the axe boast itself against him that heweth therewith? or shall the saw magnify itself against him that shaketh it? as if the rod should shake itself against them that lift it up, or as if the staff should lift up itself, as if it were no wood. (Is 10:15)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
