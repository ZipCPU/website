<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Finishing off the debugging bus: building a software interface</title>
  <meta name="description" content="Today’s post marks the end in a journey discussing what it takes to builda very basic debugging bus to provideyou with access to the internals of what’s goin...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zipcpu.com/blog/2017/06/29/sw-dbg-interface.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="http://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<li><a HREF="https://www.patreon.com/ZipCPU">Support this Blog</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Finishing off the debugging bus: building a software interface</h1>
    <p class="post-meta"><time datetime="2017-06-29T00:00:00-04:00" itemprop="datePublished">Jun 29, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Today’s post marks the end in a journey discussing what it takes to build
a very basic <a href="https://github.com/ZipCPU/dbgbus">debugging bus</a> to provide
you with access to the internals of what’s going on within your FPGA.</p>

<p>Looking at where we came from, we started by outlining what a <a href="/blog/2017/06/05/wb-bridge-overview.html">bus like this
might look like</a>.
We used Fig 1 to illustrate this.</p>

<table style="float: right"><caption>Fig 2: System Diagram</caption><tr><td><img src="/img/sample-interconnect.svg" alt="An example WB interconnect" width="420" /></td></tr></table>

<p>We then walked through the steps necessary to build such a bus.  These steps
started with a discussion of what was necessary to build a <a href="/blog/2017/06/08/simple-wb-master.html">simple wishbone
bus master</a>.</p>

<p>Then we stepped back and looked at how to initially create
<a href="/blog/2017/06/14/creating-words-from-bytes.html">bus command words from the serial port
bytes</a>
sent to it.</p>

<p>On the other side of the interface, we showed <a href="/blog/2017/06/15/words-back-to-bytes.html">how to turn the bus response
words back into
bytes</a>.</p>

<p>This made the basis of the interface.  To this, we
<a href="/blog/2017/06/16/adding-ints.html">added interrupts</a>
to the interface, so we can tell if something has happened within the
device, as well as <a href="/blog/2017/06/19/debug-idles.html">bus idle
indications</a>
to give us an assurance that we are connected to the right bus.</p>

<p>We then put the <a href="/blog/2017/06/20/dbg-put-together.html">pieces of the bus
together</a>
into a full blown debugging bus component core.</p>

<p>The debugging bus needed a wishbone bus to command, so we outlined <a href="/blog/2017/06/22/simple-wb-interconnect.html">how to
build a basic wishbone
interconnect</a>
that this bus could be connected to.  Together, this formed a fully functional
Verilog design.  The last post then discussed how to <a href="/blog/2017/06/26/dbgbus-verilator.html">build a fully functional
Verilator simulation</a>
of our new design.</p>

<p>We even tested the design and got some confidence that it worked.</p>

<p>Today, we’re going to build a
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus/sw">software interface</a>
that can be used to connect to this
<a href="https://github.com/ZipCPU/dbgbus">debugging bus component</a>.</p>

<h2 id="software-interface-requirements">Software Interface Requirements</h2>

<p>Some time ago <a href="/blog/2017/05/22/a-vision-for-controlling-fpgas.html">we discussed</a>
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h">the interface</a>
we wanted to use to access this bus with.  Here, we’ll discuss some of the
components of making this interface work.</p>

<p>The basic software components we are going to use are shown in Fig 2.
In general, this post will focus on the
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">HEXBUS</a> <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/sw/hexbus.cpp">software
interface component</a>
which is specific to this interface standard.  This component, though, fits in
place between some other components, and it’s important to understand how
these parts and pieces are put together.</p>

<table style="float: left; padding: 15px"><caption>Fig 2: Software Components</caption><tr><td><img src="/img/sw-dbg-components.svg" alt="Debugging Bus Software Components" width="240" /></td></tr></table>

<p>We’ve already built the FPGA
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus/rtl">dbgbus interface</a>. 
Further, <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/netuart.cpp">bridging such an
interface</a>
from a serial port onto a TCP/IP stream isn’t that hard–although we may
come back and describe it in full later.</p>

<p>The next step up in the stack is a generic low level O/S system interface
component
calls <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.h">LLCOMMS</a>.
This component provides read() and write() wrappers over the O/S system
calls, further abstracting the underlying transport the interface runs over.
In particular, the generic interface can be used to abstract whether or not
the interface is running over an O/S file descriptor (such as from
/dev/ttyUSB0)
or a network port (such as localhost:&lt;port&gt;).  Both interfaces are
found within the <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.cpp">LLCOMMS
implementation</a>.</p>

<p>This gives us a bit of immunity against changes in the underlying transport
when moving from one device to another.  For example, the XuLA2 board has a
unique USB communication design.  Inheriting from the
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.h">LLCOMMS</a>
interface, and replacing the critical portions with a <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/sw/usbi.h">USB interface
component</a>
will allow us to continue using <a href="https://github.com/ZipCPU/dbgbus">these dbgbus
components</a>, despite the transport
having changed to support that unique interface.</p>

<p>On the other side of the <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus/sw">HEXBUS
interface</a> is the 
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp">wbregs</a>
command line program.  This is a basic peek/poke type program which we’ll use
here as a demonstration program to show how to use the interface.  As a result,
the <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp">wbregs</a>
program doesn’t really exercise the full limits of the debugging bus
capability.  Still, it makes for a nice example program that can be
used to illustrate the bus.</p>

<p>It’s between these various other components that we’ll build our <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus/sw">HEXBUS
software interface</a>.</p>

<h2 id="the-hexbus-software-interface">The HEXBUS software interface</h2>

<p>It’s now time to get into the <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/sw/hexbus.cpp">HEXBUS software
interface</a>.
As you may remember, this interface needs to match the generic
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h">devbus.h</a>,
so you might wish to follow along in that file for reference.</p>

<p>With a little simplification, the readio(), readz(), and readi()
requests can be mapped into a single internal readv() method.  This method
handles reading a variable number of values from the interface, given an
address and whether or not the address will increment between values.  A
similar simplification can be applied to the writeio(), writez(), and writei()
interface methods.  Hence, we’ll spend our time discussing how readv()
and writev() work.</p>

<p>The first step to either readv() or writev() is to build a command that first
sends the address to the
component.  This is the purpose of the encode_address() method.
Because our interface is as simple as it is, encoding the address is
as simple as sprintf() call, writing “A” and then the hexadecimal
address to the buffer.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">char</span>	<span class="o">*</span><span class="n">HEXBUS</span><span class="o">::</span><span class="n">encode_address</span><span class="p">(</span><span class="k">const</span> <span class="n">HEXBUS</span><span class="o">::</span><span class="n">BUSW</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// We'll write the address onto an internal command buffer, and then
</span>	<span class="c1">// track a pointer to the end of the buffer
</span>	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">m_buf</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">HEXB_ADDR</span><span class="p">;</span>	<span class="c1">// Place an "A" at the beginning of our buffer
</span>	<span class="n">sprintf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">"%x"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>	<span class="c1">// encode the value in hex
</span>	<span class="n">ptr</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>	<span class="c1">// Adjust ptr to point to the end of the addr
</span>	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>		<span class="c1">// cmd, and return ptr
</span><span class="p">}</span></code></pre></figure>

<p>encode_address() returns a pointer to the end of the buffer, so that the
read or write command may be appended to it.</p>

<p>This is the basics of the encode_address() command. Some additional
adjustments may also be found in the <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/sw/hexbus.cpp">HEXBUS interface
source</a>,
so that we can avoid setting an address twice if we don’t need to.</p>

<p>Both readv() and writev() call encode_address() as their basic first step:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// encode_address stores its results in a local buffer, m_buf
// Remember the two LSB's are command indications that are not part of the
// address, and that setting the LSB will keep the address from
// incrementing between bus operations.  Hence, we examine whether or not
// we are incrementing, and adjust accordingly
</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">encode_adress</span><span class="p">(</span><span class="n">a</span> <span class="o">|</span> <span class="p">((</span><span class="n">inc</span><span class="p">)</span><span class="o">?</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span></code></pre></figure>

<p>After this, readv() and writev() diverge.  We’ll focus on readv() first,
and come back to writev() later.</p>

<p>Within readv(), the command to read a value from the interface is a simple “R”,
terminated with a newline.  We’ll append this request to the address command,
and pass it to our <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/llcomms.h">lower level
communications</a>
interface.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// encode_address stores its results in a local buffer, m_buf
</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">encode_adress</span><span class="p">(</span><span class="n">a</span> <span class="o">|</span> <span class="p">((</span><span class="n">inc</span><span class="p">)</span><span class="o">?</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
<span class="k">while</span><span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">HEXB_READ</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span>   <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

	<span class="c1">// Write this buffer to the lower level comms port
</span>	<span class="n">m_dev</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">m_buf</span><span class="p">,</span> <span class="p">(</span><span class="n">ptr</span><span class="o">-</span><span class="n">m_buf</span><span class="p">));</span>

	<span class="c1">// Read a word from the interface
</span>	<span class="n">buf</span><span class="p">[</span><span class="n">nread</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">readword</span><span class="p">();</span>

	<span class="c1">// Clear the command buffer so we can start over
</span>	<span class="n">ptr</span> <span class="o">=</span> <span class="n">m_buf</span>
<span class="p">}</span></code></pre></figure>

<p>The loop operates over all of the requested words.  Within the loop, readv()
calls readword() to read individual words from the
interface, and write them into the given buffer.  This is then repeated until
all of the words have been read.</p>

<p>The writev() code, on the other hand, sends a “W” followed by the hexadecimal
value which we wish to write.  That request is completed with a newline.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span>	<span class="n">nw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="n">nw</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Append the write command
</span>	<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'W'</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
	<span class="c1">// If the value isn't zero, append it too.  End the command with
</span>	<span class="c1">// a newline
</span>	<span class="c1">// (The hardware assumes a value of zero if it isn't given
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">m_buf</span><span class="p">[</span><span class="n">nw</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">nw</span><span class="p">])</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'\n'</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">m_dev</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">m_buf</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-</span><span class="n">m_buf</span><span class="p">);</span>

	<span class="n">readidle</span><span class="p">();</span>

	<span class="n">nw</span><span class="o">++</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">m_buf</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Once the actual write command is sent to the lower level, we call readidle()
to read (and ignore) any acknowledgements.  This keeps the interface
synchronous–which is especially important given that there are no FIFO’s
yet built within it.</p>

<p>We nown turn our attention to readword() and readidle().  The structure of
the two of these is quite similar.  Here, we’ll start with looking at how
readword() is composed.</p>

<p>Since multiple words can be sent across the interface using the same
command word, we need a state variable to capture and remember the last
command word.  We’ll use m_cmd for that purpose.
It is retained from response to response, so that it need not be repeated.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span>		<span class="n">nr</span><span class="p">;</span>
<span class="kt">unsigned</span>	<span class="n">word</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
<span class="n">bool</span>		<span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// Initialize our response register to zero
</span><span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
	<span class="c1">// Read a character from the interface, block if necessary
</span>	<span class="k">do</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">lclreadcode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="c1">// If the character is a lower case hexadecimal digit, shift our
</span>	<span class="c1">// word by four bits and set the lower four bits with this
</span>	<span class="c1">// value.
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">'a'</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">'f'</span><span class="p">))</span>
		<span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0f</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Otherwise, if the word we've received is an out-of-band
</span>		<span class="c1">// character.  Such characters always end the current response.
</span>		<span class="c1">// They can also be used to start a new response.  Here, we'll
</span>		<span class="c1">// focus on the last command first.  That's what's in m_cmd,
</span>		<span class="c1">// and also what's in our "word" buffer
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// On any read value, update the address pointer
</span>			<span class="k">if</span> <span class="p">(</span><span class="n">m_inc</span><span class="p">)</span>
				<span class="n">m_lastaddr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

			<span class="c1">// We've found the word we need, so we are done
</span>			<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

			<span class="c1">// Copy the result into ... result
</span>			<span class="n">result</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_ACK</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// On a write acknowledgement (might be left over
</span>			<span class="c1">// unread from a previously unfinished transaction?)
</span>			<span class="c1">// adjust the address pointer, and increment the number
</span>			<span class="c1">// of acknowledgements received.
</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m_inc</span><span class="p">)</span>
				<span class="n">m_lastaddr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">m_nacks</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_INT</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// On an interrupt notification, just set the interrupt
</span>			<span class="c1">// flag.
</span>			<span class="n">m_interrupt_flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// On a bus error, set the bus error flag, and
</span>			<span class="c1">// throw a bus error in case anything wishes to catch
</span>			<span class="c1">// and process it.
</span>
			<span class="n">m_bus_err</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">throw</span> <span class="n">BUSERR</span><span class="p">(</span><span class="n">m_lastaddr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_IDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// If we get multiple idles while waiting for a
</span>			<span class="c1">// response, then our response has been lost.
</span>			<span class="c1">// Throw a bus error
</span>
			<span class="n">abort_countdown</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">abort_countdown</span><span class="p">)</span>
				<span class="k">throw</span> <span class="n">BUSERR</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_ADDR</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// On an address response from the debugging bus,
</span>			<span class="c1">// set the address tracking reads to the value
</span>			<span class="c1">// returned, as well as the m_inc to whether or not
</span>			<span class="c1">// this indicates an incrementing address.
</span>			<span class="n">m_addr_set</span>  <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">m_inc</span>       <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">m_lastaddr</span>  <span class="o">=</span> <span class="n">word</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_RESET</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// On any bus reset, any address that was set is now
</span>			<span class="c1">// invalid.  Mark it so.
</span>			<span class="n">m_addr_set</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// Any out of band character other than a newline is a
</span>		<span class="c1">// new command that we start
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
			<span class="n">m_cmd</span> <span class="o">=</span> <span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="c1">// Clear the register so we can receive the next word	
</span>		<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>

<span class="c1">// Return any recovered/read result
</span><span class="k">return</span> <span class="n">result</span><span class="p">;</span></code></pre></figure>

<p>readword() reads from the port one character at a time, by calling
lclreadcode().  lclreadcode() reads a single byte from the interface,
tossing out any device-not-ready bytes (0x7f or 0xff).  After that,
readword() is very similar to our <a href="https://github.com/ZipCPU/dbgbus/blob/master/hexbus/rtl/hbpack.v">bytes to words
component</a>
within the
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus/rtl">HEXBUS RTL</a> design.
Any command word (“R”, “W”, “A”, etc) coming
in is stored.  After that, words are built from assembling the hexadecimal
values together.  As soon as a non-hexadecimal character is received, the
word received is complete.</p>

<p>The big difference between this logic and the logic of readidle() below is
that readidle() only loops while data is available to be read, and it doesn’t
return on any words read–since readidle() is called after <em>writing</em> (not
reading) to the interface.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// Start by clearing the register
</span><span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Repeat as long as there are values to be read
</span><span class="k">while</span><span class="p">(</span><span class="n">m_dev</span><span class="o">-&gt;</span><span class="n">available</span><span class="p">())</span> <span class="p">{</span>
	<span class="c1">// Read one character from the interface
</span>	<span class="n">nr</span> <span class="o">=</span> <span class="n">lclreadcode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>

	<span class="c1">// If it's a hexadecimal digit, adjust our word register
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">'a'</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">'f'</span><span class="p">))</span>
		<span class="n">word</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0f</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Any thing else identifies the beginning (or end)
</span>		<span class="c1">// of a response word.  Deal with it based upon the
</span>		<span class="c1">// last response m_cmd received.
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_ADDR</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Received an address word
</span>			<span class="n">m_addr_set</span>  <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">m_inc</span>       <span class="o">=</span> <span class="p">(</span><span class="n">word</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">m_lastaddr</span>  <span class="o">=</span> <span class="n">word</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Read data ... doesn't make sense in this
</span>			<span class="c1">// context, so we'll just ignore it
</span>			<span class="k">if</span> <span class="p">(</span><span class="n">m_inc</span><span class="p">)</span>
				<span class="n">m_lastaddr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_INT</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// On an interrupt, just set the flag to note
</span>			<span class="c1">// we've received one.
</span>			<span class="n">m_interrupt_flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_ACK</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Write acknowledgement.  writev() will check
</span>			<span class="c1">// whether the correct number of
</span>			<span class="c1">// acknoweledgments has been received before
</span>			<span class="c1">// moving on.  Read and note it here.
</span>			<span class="k">if</span> <span class="p">(</span><span class="n">m_inc</span><span class="p">)</span>
				<span class="n">m_lastaddr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">m_nacks</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// On an err, throw a BUSERR exception
</span>			<span class="n">m_bus_err</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">throw</span> <span class="n">BUSERR</span><span class="p">(</span><span class="n">m_lastaddr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_cmd</span> <span class="o">==</span> <span class="n">HEXB_RESET</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// On any reset, clear the address set flag
</span>			<span class="c1">// and any unacknowledged bus error condition
</span>			<span class="n">m_addr_set</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">m_bus_err</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// Any out of band character other than a whitespace
</span>		<span class="c1">// is a new command starting--keep track of which
</span>		<span class="c1">// command it is.
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
			<span class="n">m_cmd</span> <span class="o">=</span> <span class="n">m_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>While there are other details within the software interface, such as a
means of creating a log file that can be used to find interface errors,
or a means of querying whether or not an interface has taken place, we’ll
gloss over these in favor of simplifying our description today.  Feel free
to browse the software and see how they work.</p>

<h2 id="register-naming">Register Naming</h2>

<p>There’s another piece to our software which isn’t shown in Fig 2.  This
portion defines names, and then provides
a register name to address translation.  It starts by <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/regdefs.h">defining constant
values</a> for all of
our register addresses.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	R_VERSION       0x00002040
#define	R_SOMETHING	0x00002044
#define	R_BUSERR       	0x00002048
#define	R_PWRCOUNT	0x0000204c
#define	R_INT		0x00002050
#define	R_HALT		0x00002054
</span>
<span class="cp">#define	R_SCOPE		0x00002080
#define	R_SCOPD		0x00002084
</span>
<span class="cp">#define	R_MEM		0x00004000</span></code></pre></figure>

<p>This will make it easy to say within your software something like,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">variable</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio_R_VERSION</span><span class="p">);</span></code></pre></figure>

<p>as an example.</p>

<p>To facilitate the command line register usage of tools like
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp">wbregs</a>,
we create a <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/regdefs.cpp">user name to constant mapping
function</a>.
This is nothing more than a table of register address, register name pairs,
as is shown below:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">const</span>	<span class="n">REGNAME</span>	<span class="n">raw_bregs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">R_VERSION</span>       <span class="p">,</span>	<span class="s">"VERSION"</span> 	<span class="p">},</span>
	<span class="p">{</span> <span class="n">R_BUSERR</span>        <span class="p">,</span>	<span class="s">"BUSERR"</span>  	<span class="p">},</span>
	<span class="p">{</span> <span class="n">R_PWRCOUNT</span>      <span class="p">,</span>	<span class="s">"PWRCOUNT"</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">R_INT</span>		  <span class="p">,</span>	<span class="s">"int"</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">R_HALT</span>	  <span class="p">,</span>	<span class="s">"halt"</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">R_SCOPE</span>         <span class="p">,</span>	<span class="s">"SCOPE"</span>   	<span class="p">},</span>
	<span class="p">{</span> <span class="n">R_SCOPD</span>         <span class="p">,</span>	<span class="s">"SCOPD"</span>   	<span class="p">},</span>
	<span class="p">{</span> <span class="n">R_MEM</span>           <span class="p">,</span>	<span class="s">"RAM"</span>     	<span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>A short routine also decodes the register names and turns them into addresses,
which can then be used with readio() or writeio();</p>

<p>From a software standpoint, this approach to register naming is very
important.  Because registers are given names, whether the C++ name
<strong>R_VERSION</strong> or more human readable and case insensitive name
“<strong>VERSION</strong>”, any software using
these names doesn’t need to be changed from one design to the next, nor
when the addresses change.  As examples, I can use the same software to control
the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>, whether to load a program into
memory or debug a running program,
on one board as I can on other boards.  Any changed addresses are taken care
of by recompiling the software for the new board.</p>

<h2 id="testing-it-all-out">Testing it all out</h2>

<p>If you are just joining the discussion at this point, you’ll want to have
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>,
<a href="https://gcc.gnu.org">g++</a>, <a href="http://gtkwave.sourceforge.net">gtkwave</a>,
and <a href="https://git-scm.com">git</a> installed to test the interface out yourself.
Although many of these are Linux programs (I use
<a href="https://www.ubuntu.com">Ubuntu</a> myself), I have instructions available for
doing this on a Windows platform using <a href="https://www.cygwin.com">Cygwin</a>.
(Those instructions are available to anyone who wants to test them and let
me know how well they do (or don’t) work–just send me an e-mail asking for
them, and promising to tell me if they work for you.)  Then, once these
utilities are installed, you should be able to just download and build the
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>,
simulation of the <a href="https://github.com/ZipCPU/dbgbus">debugging bus</a> we’ve
been working on.</p>

<p>Cloning and building the project should be quite straightforward:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">cd ~/your/chosen/project/path
git clone https://github.com/ZipCPU/dbgbus
cd dbgbus
make</code></pre></figure>

<p>Now that this is built, there are two steps to interacting with the simulation.
The first step is to run the simulation executable.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">cd bench/cpp
./testbus_tb</code></pre></figure>

<p>Have a little caution when running this.  If the trace file generation is
turned on (look for opentrace(“trace.vcd”) in
<a href="https://github.com/ZipCPU/dbgbus/blob/master/bench/cpp">testbus_tb.cpp</a>), it
may quickly write a <em>VERY LARGE</em> file to your computer.
That file will be called trace.vcd, and it will be written in the same
directory as the testbus_tb program is called from.  If this is a problem,
feel free to comment out the trace generation line and run without generating
a trace.</p>

<p>The second step, which you may wish to do in another terminal window, is to
run the <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp">wbregs</a>
program to interact with this simulation.  I like to start any testing
session by just proving that I can read the internal version number from the
simulation:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">cd ~/your/chosen/project/path/dbgbus/sw
./wbregs VERSION</code></pre></figure>

<p><a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp">wbregs</a>
should return an 8-digit hexadecimal number looking like a date.
The current date within the repository is 0x20170622, but I may change that
later to indicate changes to the repository.</p>

<p>We also placed a counter internal to the simulation.  Using this counter, we
can query how many ticks have passed since the simulation started.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">./wbregs PWRCOUNT</code></pre></figure>

<p>And again.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">./wbregs PWRCOUNT</code></pre></figure>

<p>You should get two different answers, and the number should increase between
the two.</p>

<p>We can also check the status of the onboard
<a href="https://github.com/ZipCPU/wbscope">wishbone scope</a>,
by reading from its control register.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">./wbregs SCOPE</code></pre></figure>

<p>Look at the top nibble of the return word in response.  It’s a ‘1’.  That means
that the scope now has enough samples to fill its memory, but that it has yet
to be triggered.  We’ll come back to this in a moment.</p>

<p>Let’s turn our attention to the block RAM memory.  Using
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp">wbregs</a>
we can write to the first location in memory:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">./wbregs MEM 0xdeadbeef</code></pre></figure>

<p>While we can read from and write to other locations in memory as well,</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">./wbregs 0x4008 0xdeadbeef</code></pre></figure>

<p>only the first memory location has a name, MEM, associated with it.  To access
other locations, you will need to give
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/wbregs.cpp">wbregs</a>
the address in numeric (strtoul) format.</p>

<p>If you recall, we built our design, though, in such a way that any
read or write command to memory would trigger the
<a href="https://github.com/ZipCPU/wbscope">scope</a>.</p>

<p>Let’s see if it got triggered:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">./wbregs SCOPE</code></pre></figure>

<p>Here, the scope returns a response having 7 in its high order nibble.  This
means that the scope has not only been triggered, but it’s also stopped
recording.  At this point, in your software code, you could issue a:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">ctrl_register</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_SCOPE</span><span class="p">);</span>
<span class="n">scopelen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">((</span><span class="n">ctrl_register</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x1f</span><span class="p">));</span>
<span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint32_t</span><span class="p">[</span><span class="n">scopelen</span><span class="p">];</span>

<span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readz</span><span class="p">(</span><span class="n">R_SCOPD</span><span class="p">,</span> <span class="n">scopelen</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span></code></pre></figure>

<p>This would read the state from the scope control register. 
Specifically, though, this would examine the scope control register to find
out how much internal RAM the scope has been built with.  Once determined, a
buffer can be built to read from the scope, and the read command can be issued.
All of this is simplified by the <a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">scope helper
class</a>,
but we’ll save that for another lesson for another day.</p>

<h2 id="what-can-you-use-this-for">What can you use this for</h2>

<p>This ends our series in how to build a bus that you can use for debugging
an FPGA.  While it’s taken a while to get here, interacting with an 
FPGA in this manner can be particularly valuable.  While we’ve focused on
the use case of being able to get scope information out of the design,
many other use cases exist.</p>

<ul>
  <li>
    <p>Reading/writing video memory within the FPGA, such as reading the results
from a camera</p>
  </li>
  <li>
    <p>Reading, erasing, and programming the <a href="http://opencores.org/project,qspiflash">QSPI flash
memory</a> within the FPGA</p>
  </li>
  <li>
    <p>Setting up a fallback design, using the
<a href="https://github.com/ZipCPU/wbicapetwo">internal configuration access port</a>,
or even switching FPGA configurations without using the official JTAG port.</p>
  </li>
  <li>
    <p>Grabbing data from a GPS receiver</p>
  </li>
  <li>
    <p>Controlling an
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/wboled.v">OLEDrgb</a>, or
even a 2-line LCD, to make sure your controller works before trying to use
a CPU to run it.</p>
  </li>
  <li>
    <p>Setting up the memory, either block RAM or SDRAM, within your design so that
it can be processed later.</p>
  </li>
</ul>

<p>Indeed, the possibilities are so numerous, it’s hard to list them all here.</p>

<p>There is one thing, though, that this interface lacks: speed.  Speed can be
achieved by packing more bits per word than four, and by compressing this
interface.  Both of these capabilities are part of the 
<a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/wbubus.v">WBUBUS</a> I normally
use.  You are more than welcome to use this interface if you would like,
subject only to the conditions of the
<a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GPL</a>.</p>

<p>That’s why I intend to to use this design and specifically the
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h">devbus</a>,
interface it implements as a basis for moving forward with future articles
on this blog.</p>

<p>Thoughts or comments?  Please feel free to share them below.</p>

<p>Thanks!</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For which of you, intending to build a tower, sitteth not down first, and counteth the cost, whether he have sufficient to finish it? (Luke 14:28)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">zipcpu</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
