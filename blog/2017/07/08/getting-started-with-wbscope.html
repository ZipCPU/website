<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Getting Started with the Wishbone Scope</title>
  <meta name="description" content="Ever found yourself stuck with anFPGAdesign that didn’t work and no idea why not?  This seems to be a commonproblem withinFPGAdesign.  Perhapsthe design work...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2017/07/08/getting-started-with-wbscope.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Getting Started with the Wishbone Scope</h1>
    <p class="post-meta"><time datetime="2017-07-08T00:00:00-04:00" itemprop="datePublished">Jul 8, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Ever found yourself stuck with an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design that didn’t work and no idea why not?  This seems to be a <a href="/fpga-hell.html">common
problem</a> within
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design.  Perhaps
the design works within a simulator.  Perhaps you don’t know how to simulate
the hardware component the design is working with.  Either way, you will
want to know how to somehow draw information out of the broken design to
see where it fails.</p>

<p>We’ll show an example of how to do that here, using two primary components to
make this happen.  The first is any device or simulation imeplementing a
generic <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h">DEVBUS</a>
interface into a wishbone bus implemneted within your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
If you don’t have such an interface as part of your design, the
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">HEXBUS</a>
interface should still suite your purposes nicely, although it will require
a serial port to communicate on.  The second necessary component is a
<a href="https://github.com/ZipCPU/wbscope">wishbone scope</a>, which you can access
using the <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h">DEVBUS</a>
interface.</p>

<p>There are two parts required to adding a
<a href="https://github.com/ZipCPU/wbscope">wishbone scope</a> into your design, the 
<a href="/blog/2017/06/22/simple-wb-interconnect.html">Verilog
integration</a>
and the <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp">software
component</a>.
The first part is to connect the scope to your design: both by selecting
wires from within your design that you wish to examine, as well as identifying
trigger logic within your design to know when to capture those wires.
(The block RAM used to capture a trace isn’t unlimited.)
The second part is the logic necessary to read that capture off of the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
and format it into a <a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD file</a>
that you can use to view your data on a clock for clock basis using
<a href="http://gtkwave.sourceforge.net">gtkwave</a>.</p>

<p>We’ll walk through the two steps separately, and then show an example
of using them to view a bus interaction.</p>

<h2 id="changes-to-your-design">Changes to your design</h2>

<p>There are only four basic changes to your design that you’ll need to make in
order to connect a
<a href="https://github.com/ZipCPU/wbscope">wishbone scope</a> into your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> design.</p>

<p>First, you’ll need to add the scope to your <a href="https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v">wishbone
interconnect</a>
within your design.  This involves six basic points of adjustment:</p>

<ol>
  <li>
    <p>You’ll need to decode the scope’s address.  I like to create an address
select line (not to be confused with the byte SELect linse), indicating
that the current address references the scope.  Make sure that ADDR[0]
is not a part of this computation, as the scope needs that line to
determine which internal register is being accessed.</p>
  </li>
  <li>
    <p>You’ll need to add the scope to the design, and wire the wishbone inputs
to the scope.  The STB line from the wishbone master needs to be gated
(anded) with the address select logic result.  The scope requires only
one ADDR bit, so no others need to be connected.  The wishbone outputs:
ACK, STALL, and DATA will be declared and connected.</p>
  </li>
  <li>
    <p>The ACK line needs to be logically OR’d with other ACK lines within your
design.  This logic should already exist, if you have a working wishbone
interconnect, so follow along there and see what’s required.</p>
  </li>
  <li>
    <p>As with the ACK, the DATA line needs to be integrated into the bus
data return.  In particular, the bus data return to the master should
contain the scope’s data anytime time the scope’s ACK line is true.</p>
  </li>
  <li>
    <p>Because the
<a href="https://github.com/ZipCPU/wbscope">wishbone scope</a> will never stall the
bus, you can technically
ignore the STALL line.  For form and maintainability, though, you’ll
probably want to use this line to create the wishbone master’s STALL
return line.  This is usually created by a large OR of every device’s
address decode line AND’ed with their STALL line.</p>
  </li>
  <li>
    <p>I often use a touch of logic to determine whether or not many ACK’s are
begin returned at once, if more than one device is selected, or if no
devices are selected.  This logic will need to be adjusted as well.</p>
  </li>
</ol>

<p>If you are going to use the scope that already exists within the
<a href="https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v">DBGBUS</a>’s
test infrastructure, all of this logic has already been taken care of for you.
For more details, we also discussed how to do this in <a href="/blog/2017/06/22/simple-wb-interconnect.html">the article on building
a simple wishbone
interconnect</a>.</p>

<p>The second step is deciding what you wish to trigger on.  This is as simple
a piece of logic as you wish.  Within the
<a href="https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v">DBGBUS</a>’s
implementation, you’ll find a line that looks like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span> <span class="n">scope_trigger</span> <span class="o">=</span> <span class="p">(</span><span class="n">mem_sel</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">wb_stb</span><span class="p">);</span></code></pre></figure>

<p>This triggers the scope on any attempt to reference the block RAM peripheral
within the testbus, although what you choose to trigger on is up to you.
Want to trigger on any time the wishbone error is set as an example?  The
following logic would do that:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span> <span class="n">scope_trigger</span> <span class="o">=</span> <span class="p">(</span><span class="n">wb_err</span><span class="p">);</span></code></pre></figure>

<p>We’ll stick to the former, though.</p>

<p>Third, you’ll want to select those wires that you want to capture and
record.  These wires can be anything you are interested in within your design.
In our case, we’re going to capture some signals from within the
wishbone bus’s interaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">debug_data</span> <span class="o">=</span> <span class="o">{</span> <span class="n">wb_cyc</span><span class="p">,</span> <span class="n">wb_stb</span><span class="p">,</span> <span class="n">wb_we</span><span class="p">,</span> <span class="n">wb_ack</span><span class="p">,</span> <span class="n">wb_stall</span><span class="p">,</span>
		<span class="n">wb_addr</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="mb">1'b1</span><span class="p">,</span>
		<span class="n">wb_odata</span><span class="p">[</span><span class="mi">9</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span>
		<span class="n">wb_idata</span><span class="p">[</span><span class="mi">9</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>The <a href="https://github.com/ZipCPU/wbscope">wishbone scope</a>
fixes this amount of debug data at 32-bits per clock, otherwise we might have
grabbed more of this bus interaction.  If you need more, you should be able to
using multiple <a href="https://github.com/ZipCPU/wbscope">scopes</a>
at the same time to achieve a wider capture.</p>

<p>As a final step, you can limit the
<a href="https://github.com/ZipCPU/wbscope">scope</a> so that it only captures data any
time a particular bit is true within your design.  This capability is very
useful for digital signal processing applications, where the data of interest
may not exist on every clock.  This is the <code class="language-plaintext highlighter-rouge">i_ce</code> input to the scope. 
For this simple example, we’ll keep this set to ‘1’.</p>

<p>While we aren’t going to reconfigure the basic
<a href="https://github.com/ZipCPU/wbscope">wishbone scope</a> for this example, there
are several configuration parameters that can be set.  These parameters
include:</p>

<ul>
  <li>
    <p>The log of the size of the memory within the scope, LGMEM.  By default, this
is set to 10, so by default the scope will use 2^10 words of block RAM.
Powers of two from anywhere between 2^2 and 2^31 are possible–with the
natural consequence being that your actual
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
hardware will limit how memory you can actually use.</p>
  </li>
  <li>
    <p>Whether or not the scope is synchronous with your wishbone clock or not.
This is the SYNCHRONOUS flag.  It defaults to true (<code class="language-plaintext highlighter-rouge">1</code>).  If you ever need
to collect data on one clock and read it on another, then set this to
zero.  That will trigger the inclusion of a lot of clock transfer logic
within the design.</p>

    <p>For our design, we’ll leave this at the default as a synchronous scope,
but that will also require the same <code class="language-plaintext highlighter-rouge">i_clk</code> parameter being passed to the
core twice.</p>
  </li>
  <li>
    <p>The default holdoff parameter sets the initial holdoff of the scope. 
This holdoff parameter may be changed at a later time by simply writing the
new holdoff to the control register.  Setting it within a parameter just
sets the initial value of the holdoff register.</p>

    <p>If the holdoff is set to zero, the trigger will be aligned with the last
data sample in the scope’s memory.  As the holdoff time is increased,
the trigger location will move towards the beginning of the scope’s memory.</p>

    <p>As another way to put it, once triggered, the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
waits for a number of
clocks given by the holdoff value before stopping its collect.  Hence, a
holdoff of zero can be used to capture any logic leading up to an event,
whereas a holdoff of the size of the buffer will capture any logic
immediately following an event.</p>

    <p>The default parameter value for the default holdoff places the trigger
near the middle of the collect.</p>
  </li>
</ul>

<p>That’s it!  That’s all you need to do to set up a
<a href="https://github.com/ZipCPU/wbscope">wishbone scope</a> within the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
part of your design.</p>

<h2 id="the-software-controller">The software controller</h2>

<p>To use the <a href="https://github.com/ZipCPU/wbscope">Wishbone scope</a>, you’ll also
want to set up a software controller to handle the communication between the
design, and to reformat the result into whatever you wish it to be.
This is the purpose of the
<a href="https://github.com/ZipCPU/wbscope">scope</a>
software controller.  It is also specific to the logic you’ve chosen to
capture, so this section will show you how to set it up.</p>

<p>When I initially used the <a href="https://github.com/ZipCPU/wbscope">Wishbone scope</a>
in my earlier projects, all the scope controller ever did was to check that
the scope had indeed been triggered, and then dump every piece of data that
had been collected to the terminal.</p>

<p>At one time, I wrote a new software controller every time I needed a scope
within my design.  If you wander through my designs, you can even find
examples of these older scope controllers, such as <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/sw/ramscope.cpp">this
example</a>
 that I used when debugging an <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM
controller</a>.
These controller’s, though, all had the same logic:</p>

<p>Step one: Check if the scope is ready to be read, and exit if not.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">v</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">R_SCOPE</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="mh">0x60000000</span> <span class="o">!=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&amp;</span> <span class="mh">0x60000000</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Scope is not yet ready</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="p">...</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Step two: Calculate the size of the scope and allocate a buffer</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">lglen</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">&gt;&gt;</span><span class="mi">20</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01f</span><span class="p">;</span>
<span class="n">scoplen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">lgln</span><span class="p">);</span>
<span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DEVBUS</span><span class="o">::</span><span class="n">BUSW</span><span class="p">[</span><span class="n">scoplen</span><span class="p">];</span></code></pre></figure>

<p>Step three: Read the scope’s memory from the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
transferring it from the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
to a buffer on your local computer.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readz</span><span class="p">(</span><span class="n">R_SCOPD</span><span class="p">,</span> <span class="n">scoplen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span></code></pre></figure>

<p>Step four: Decode the scope’s data</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">scoplen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Do something to printf buf[i] to the screen</span>
	<span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>After a while, though, I found myself cut/copy and pasting the same code
from one controller to the next. 
Just the code above created a <em>lot</em> of boilerplate.</p>

<p>To help get reduce the amount of boilerplate code, the scope now has a
<a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">controller scope
class</a>.
Since building that <a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">scope control
class</a>,
the scope’s capabilities have
significantly increased.  For example, the scope controller can now
create a <a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD file</a>.
It can now identify which sample produced the trigger
(thanks to some <a href="https://github.com/ZipCPU/wbscope/blob/master/bench/cpp/wbscope_tb.cpp">bench
testing</a>, and so it can place the inferred
trigger into the <a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD file</a>
as well.  So let’s instead discuss how to interact with this <a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">scope controller
object</a>.</p>

<p>The first step to using this
<a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">controller</a>.
framework is to create your own
subclass of the
<a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">controller</a>.
to desccibe your particular wire choices within your RTL logic.</p>

<p>For the example we are working with, we’ll call this controller subclass a
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp">MEMSCOPE</a>–since
it’s going to look at interactions with the block RAM memory.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">MEMSCOPE</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SCOPE</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">MEMSCOPE</span><span class="p">(</span><span class="n">FPGA</span> <span class="o">*</span><span class="n">fpga</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">addr</span><span class="p">)</span> <span class="o">:</span> <span class="n">SCOPE</span><span class="p">(</span><span class="n">fpga</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{};</span>
	<span class="o">~</span><span class="n">MEMSCOPE</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>
	<span class="p">...</span></code></pre></figure>

<p>The scope object is created with a pointer to the FPGA object implementing the
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h">DEVBUS</a>
interface, together with the address of where this scope is within
our wishbone bus.</p>

<p>Two virtual methods then need to be overloaded.  The first method, called
decode(), simply decodes the scope wires onto stdout.  This is where the
printf() interface I used to use ends up.  The difference, though, is that
the <a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">class</a>
takes care of reading from the <a href="https://github.com/ZipCPU/wbscope">scope</a>,
calculating the memory
address, as well as marking where the trigger is.  To make this work,
be careful not to end any of the printf()’s within your decode function
with a newline.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">MEMSCOPE</span><span class="o">::</span><span class="n">decode</span><span class="p">(</span><span class="n">DEVBUS</span><span class="o">::</span><span class="n">BUSW</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">cyc</span><span class="p">,</span> <span class="n">stb</span><span class="p">,</span> <span class="n">we</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">stall</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">odata</span><span class="p">,</span> <span class="n">idata</span><span class="p">;</span>

	<span class="n">cyc</span>   <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">stb</span>   <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">we</span>    <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">29</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">ack</span>   <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">stall</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">27</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">addr</span>  <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x3f</span><span class="p">;</span>
	<span class="n">odata</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x3ff</span><span class="p">;</span>
	<span class="n">idata</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span>      <span class="p">)</span><span class="o">&amp;</span><span class="mh">0x3ff</span><span class="p">;</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="p">(</span><span class="n">cyc</span><span class="p">)</span><span class="o">?</span><span class="s">"CYC"</span><span class="o">:</span><span class="s">"   "</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" %s"</span><span class="p">,</span> <span class="p">(</span><span class="n">stb</span><span class="p">)</span><span class="o">?</span><span class="s">"STB"</span><span class="o">:</span><span class="s">"   "</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" %s"</span><span class="p">,</span> <span class="p">(</span><span class="n">we</span><span class="p">)</span> <span class="o">?</span><span class="s">"W"</span> <span class="o">:</span><span class="s">"R"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[@....%02x]...%03x-&gt;...%03x"</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">odata</span><span class="p">,</span> <span class="n">idata</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" %s"</span><span class="p">,</span> <span class="p">(</span><span class="n">ack</span><span class="p">)</span><span class="o">?</span><span class="s">"ACK"</span><span class="o">:</span><span class="s">"   "</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">" %s"</span><span class="p">,</span> <span class="p">(</span><span class="n">stall</span><span class="p">)</span><span class="o">?</span><span class="s">"(STALL)"</span><span class="o">:</span><span class="s">"       "</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The second method that needs to be overloaded is the define_traces() method.
This is where the connection is made between your design and the
<a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD file</a>
the
<a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">scope object</a>
can generate.  To make this possible, the
<a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">scope object</a>
offers a register_trace() function.  register_trace() takes three arguments.
The first is the name of the wire or trace that’s being defined.
The second argument specifies how many bits the trace has of the 32 the
scope has captured.   The third and final argument
specifies which bit position this value starts at.
Hence, we can define all of our traces with a simple:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">MEMSCOPE</span><span class="o">::</span><span class="n">define_traces</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">register_trace</span><span class="p">(</span><span class="s">"wb_cyc"</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
	<span class="n">register_trace</span><span class="p">(</span><span class="s">"wb_stb"</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
	<span class="n">register_trace</span><span class="p">(</span><span class="s">"wb_we"</span><span class="p">,</span>     <span class="mi">1</span><span class="p">,</span> <span class="mi">29</span><span class="p">);</span>
	<span class="n">register_trace</span><span class="p">(</span><span class="s">"wb_ack"</span><span class="p">,</span>    <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>
	<span class="n">register_trace</span><span class="p">(</span><span class="s">"wb_stall"</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
	<span class="n">register_trace</span><span class="p">(</span><span class="s">"wb_addr"</span><span class="p">,</span>   <span class="mi">6</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
	<span class="n">register_trace</span><span class="p">(</span><span class="s">"wb_odata"</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">register_trace</span><span class="p">(</span><span class="s">"wb_idata"</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>  <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>All that remains is to create and run this <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp">scope
controller</a>.</p>

<p>Creating it is simple, after connecting to your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
and creating an object supporting the
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h">DEVBUS interface</a>,
you can just create the new scope from a pointer to the
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h">DEVBUS</a>
and the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
address of <a href="https://github.com/ZipCPU/wbscope">the scope</a>:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">MEMSCOPE</span> <span class="o">*</span><span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MEMSCOPE</span><span class="p">(</span><span class="n">m_fpga</span><span class="p">,</span> <span class="n">R_SCOPE</span><span class="p">);</span></code></pre></figure>

<p>You can check whether or not
<a href="https://github.com/ZipCPU/wbscope">the scope</a>
is ready to be read with a simple</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scope</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">())</span> <span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Scope is not yet ready:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>Otherwise we’ll simply print our results, and write out a
<a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD file</a>:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">else</span> <span class="p">{</span>
	<span class="n">scope</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>

	<span class="n">scope</span><span class="o">-&gt;</span><span class="n">writevcd</span><span class="p">(</span><span class="s">"scopd.vcd"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>That’s it!  That’s all the software required to use
<a href="https://github.com/ZipCPU/wbscope">the Wishbone scope</a>
and to capture and output a
<a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD file</a>
containing the scope information.</p>

<h2 id="trying-it-out">Trying it out</h2>

<p>Let’s use this with the
<a href="https://github.com/ZipCPU/dbgbus">debugging bus interface</a> <a href="https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v">example
design</a>,
and show how we can pull the data we need out of the design.</p>

<p>You’ll first need to build the example design.  To do this, you’ll need to
have <a href="https://gcc.gnu.org">g++</a>,
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>,
<a href="https://git-scm.com">git</a>, and
<a href="http://gtkwave.sourceforge.net">GTKWave</a> installed.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git clone https://github.com/ZipCPU/dbgbus
<span class="nb">cd </span>dbgbus
make</code></pre></figure>

<p>We’ll demonstrate grabbing
<a href="https://github.com/ZipCPU/wbscope">the scope</a>’s
output while running the
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>,
simulation, although you could use this with your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
just as well.
Indeed, if your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
is connected to the TCP/IP port that our
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>,
simulation is using, then you can interact with your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
with no changes.
The first step will be to start the simulation in one window:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd </span>bench/cpp
./testbus_tb</code></pre></figure>

<p>Were you trying to do this on an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
you’d instead use the
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/netuart.cpp">netuart</a>
program to bridge a serial port on your FPGA to the TCP/IP port that our
<a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/devbus.h">DEVBUS</a>
software interface will interact with.</p>

<p>Either way, your next step will be to move to another window and interact
with your <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
If you are using the <a href="https://github.com/ZipCPU/dbgbus/blob/master/bench/rtl/testbus.v">DBGBUS
demo</a>,
you’ll need to either read or write from the memory to trigger the scope:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd </span>sw/
./wbregs mem 0xdeadbeef</code></pre></figure>

<p>Now that the scope has finished its collection (even in simulation it’s
pretty quick from trigger to stop), let’s use our <a href="https://github.com/ZipCPU/dbgbus/blob/master/sw/memscope.cpp">scope
controller</a>
to grab the result:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./memscope</code></pre></figure>

<p>This will take a couple of moments to read the data from the simulation.
(It’s a lot faster when using real hardware.)  On my computer it can take
close to a full minute, but that might be very CPU dependent.</p>

<p>The result, though, will be a file <code class="language-plaintext highlighter-rouge">scopd.vcd</code>.  To examine this, just type</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">gtkwave scopd.vcd</code></pre></figure>

<p>With a little work with gtkwave, here’s what our results look like:</p>

<table style="float: none"><caption>Fig 1: Example Output using MEMSCOPE</caption><tr><td><img src="/img/memscope.png" alt="Example Scope Output" width="780" /></td></tr></table>

<h2 id="thats-it">That’s it!</h2>

<p>Did you see how easy that was?  The only hard part was
<a href="/blog/2017/06/05/wb-bridge-overview.html">building the means to communicate between the FPGA and your host
PC</a>.  After that,
all that you really needed to do was to add the
<a href="https://github.com/ZipCPU/wbscope">wishbone scope</a>
component to the wishbone bus within your design, and then define the traces
you wanted to follow in your subclass of the <a href="https://github.com/ZipCPU/wbscope/blob/master/sw/scopecls.cpp">software scope
controller</a>.</p>

<p>Stick around, though.  <a href="/about/gisselquist-technology.html">Gisselquist
Technology</a> is working
on a simpler way to connect your wishbone device components together using
<a href="https://github.com/ZipCPU/autofpga">autofpga</a>.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And the things that thou hast heard of me among many witnesses, the same commit thou to faithful men, who shall be able to teach others also. (2Tim 2:2)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
