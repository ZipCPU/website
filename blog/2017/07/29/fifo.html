<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Getting the basic FIFO right</title>
  <meta name="description" content="NOTE: Since designing the logic for this FIFO, I’ve discovered several bugsin my own FIFO implementations using formal methods.  I no longer trust thecode be...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/blog/2017/07/29/fifo.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Getting the basic FIFO right</h1>
    <p class="post-meta"><time datetime="2017-07-29T00:00:00-04:00" itemprop="datePublished">Jul 29, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><em>NOTE: Since designing the logic for this FIFO, I’ve discovered several bugs
in my own FIFO implementations using formal methods.  I no longer trust the
code below to properly handle reads on underflows, or writes on overflows.
For a more reliable development, please see the
<a href="/tutorial">tutorial</a>.  Even better, the
<a href="/tutorial">tutorial</a> example shows how to handle having
2^N elements in the FIFO, how to verify that the FIFO works properly, and
how to handle backpressure on the two channels.</em></p>

<p>If you’ve ever waited in a line, then you understand what a
<a href="https://en.wikipedia.org/wiki/FIFO">FIFO</a> is about.
A <a href="https://en.wikipedia.org/wiki/FIFO">FIFO</a>
refers to a <em>First in, First out</em> (i.e.
<a href="https://en.wikipedia.org/wiki/FIFO">FIFO</a>) data structure that has
many applications in both computers and electronics.  The data structure
is designed to support the digital equivalent of waiting in line.</p>

<p>Perhaps I need to underline that.
<a href="https://en.wikipedia.org/wiki/FIFO">FIFO</a>’s don’t have one application, they
have <em>many</em> applications in both software and electronic digital design.</p>

<p>Let’s see if we can find some examples, shall we?</p>

<ul>
  <li>
    <p>A <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>, such as the
<a href="/about/zipcpu.html">ZipCPU</a></p>

    <p>Interrupting a CPU costs time and performance.  It’s not a simple thing to
do, in spite of the hard work of many men to make interrupts fast and
efficient.   Hence, at some data rates, handling requests one at a time can
just cripple a CPU–it’s just spending too much time handling the interrupt.</p>

    <p>To deal with this, peripheral hardware is often created so that the CPU
can mange many items at the same time–spreading the cost of the interrupt
across many accesses.</p>

    <p>Perhaps a good analogy here might be an airport taxi line.  Only one person
(family) can get into any taxi at a time, and then all the taxi’s move
forward so the next person can get into the next taxi.  In this case, when
an airplane arrives (the CPU gets busy), the line suddenly swells as many
people get off and start waiting in line for a taxi.</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM Memory</a></p>

    <p>Memory is also another candidate for a FIFO.   Unlike the airport taxi line,
Memory acts more
like a school cafeteria buffet line.  Only one class is allowed to use
the line at a time, yet there are several stations that each student needs
to visit to get his lunch.  Hence, in the case of memory, you want to make
many transactions at once, fill the pipeline, and then get the whole data
through the line as soon as possible so the next class can come through.</p>

    <p>In this case, you want a FIFO that can be filled, or nearly filled, and
then make all its transactions at once and release the memory so that
something else can use it.</p>

    <p>(Example: <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA
Controller</a>,
and a <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/wbufifo.v">Wishbone-UART debugging bus
FIFO</a>)</p>
  </li>
  <li>
    <p>A <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">Universal Asynchronous Receiver Transmitter
(UART)</a>,
sometimes known as a <a href="https://en.wikipedia.org/wiki/Serial_port">serial port</a>.</p>

    <p>Computers like to load a serial port with data.  However, the serial port
can typically only handle one item every so many clocks.  Often, the serial
port can operate much faster than the computer can interrupt, but slower
than the computer can issue characters to the port.</p>

    <p>In this case, a FIFO can be used to allow the computer to write many
characters to the port.  These characters will then “wait in line” to be
transmitted, and when the line is (nearly) empty, the computer can then
send a whole bunch more characters to the port–keeping the port busy at all
times.</p>

    <p>A similar case for a FIFO can be made on receive as well.  The computer
just waits for the line to fill up, before it processes all of the elements
in the line quickly.</p>

    <p><a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v">(Verilog example code)</a></p>
  </li>
  <li>
    <p>Audio</p>

    <p>Audio is very much like the UART above.  The CPU can write at one speed,
but the audio may only be able to read at another.  A FIFO can allow a
CPU the ability to write a <em>lot</em> of things to the audio port at once, after
which the audio hardware reads the samples out one by one.</p>

    <p>Audio receiving is in many ways like some buses I’ve traveled on.  The line
for the bus grows and grows.  Once it reaches a certain length (in the case
of the FIFO), the “bus” comes along and clears the line.</p>

    <p><a href="https://github.com/ZipCPU/wbpmic/blob/master/rtl/smplfifo.v">(Verilog example code)</a></p>
  </li>
  <li>
    <p>Video</p>

    <p>Unlike UARTs and Audio, the video FIFOs I’ve worked with have rarely (if ever)
required the CPU’s attention.  They usually work in the background.  When
receiving video data, once a FIFO buffer fills, the buffer is then dumped
into memory.  Likewise on the transmit: the video controller reads from
memory, fills its buffer, and then slowly sends it to the display one pixel
at a time.</p>
  </li>
</ul>

<p>These are all examples of a FIFO.</p>

<p>Basically, you need a FIFO anytime something is going to be produced (written)
at one rate, and consumed (read) at another.  The buffer in the FIFO, then,
adjusts like any line as items are added, or removed, from it.</p>

<p>It’s really a fundamental digital design component.</p>

<p>Let’s see what we need to do to build one.</p>

<h1 id="the-goal">The Goal</h1>

<p>For our simple example here, we’ll assume there are three operations that
can be done on a FIFO, and some parts and pieces of FIFO status that we may
wish to know.</p>

<ol>
  <li>
    <p>The FIFO may need to be reset.  This clears any items from the line,
and empties the buffer regardless of how many items were in line or how
full the buffer ever was.</p>
  </li>
  <li>
    <p>You can add someone to the end of the line.  This is what happens when data
is <em>written</em> to the FIFO.</p>

    <p>In digital electronics, though, there is a maximum length to any line.
Hence, if the line is too long, attempts to add one more item to the line
will fail.</p>
  </li>
  <li>
    <p>You can process the first item in the line.  This is what happens when data
is <em>read</em> from the FIFO.</p>

    <p>Any attempt to read from an empty FIFO must of necessity fail.</p>
  </li>
</ol>

<p>Those are the operations that can take place on a FIFO.</p>

<p>For our discussion below, we’ll support three pieces of status:</p>

<ol>
  <li>
    <p>We’ll want to know how many items are in the line.
That way we can announce that the line is empty, full, half-full or …
whatever condition is necessary to move forward.</p>

    <p>Eventually, we’ll want to know if the line is full or empty, but we’ll just
start with trying to know how many items are within it.</p>
  </li>
  <li>
    <p>We’ll want to know if we ever spilled an item by adding too many items to
the line (overflow), or if</p>
  </li>
  <li>
    <p>We ever tried to read from the FIFO when it was empty (underflow).</p>
  </li>
</ol>

<p>Further, to outline the necessary logic, we’ll start with a software example
of this FIFO, and then convert it to digital logic (i.e. Verilog).</p>

<h1 id="circular-buffer">Circular Buffer</h1>

<p>Wikipedia’s <a href="https://en.wikipedia.org/wiki/FIFO">FIFO</a> article discusses
creating a
<a href="https://en.wikipedia.org/wiki/FIFO">FIFO</a>
using dynamically allocated objects and pointers.</p>

<p>Where this fails is in digital logic, because physical logic resources are
limited–dynamically allocated memory is unavailable.</p>

<p>Hence, we’re going to use a different form of algorithm here.  We’ll use instead
a circular buffer with a fixed size.</p>

<p>In this buffer, there are two pointers: the write pointer and the read pointer.</p>

<p>Whenever the read and write pointers are identical, as in Fig 1 below,
we’ll use that as the indication that the buffer is empty.
Initially, both pointers will point to the same address in the buffer (zero).
Further, we’ll return both pointers to zero any time the user requests that the
buffer be reset.</p>

<table style="float: none"><caption>Fig 1: Empty FIFO</caption><tr><td><img src="/img/fifo-empty.svg" alt="Example image of an empty FIFO" width="780" /></td></tr></table>

<p>When an item is written to the buffer, the write pointer is incremented.
This pointer then always points to the item not yet written to.</p>

<p>When an item is read from the buffer, the read pointer is incremented.  This
pointer always references the next item to be read.</p>

<p>If you look at a diagram of this, such as Fig 2, it looks like the
read pointer is <em>chasing</em> the write pointer.</p>

<table style="float: none"><caption>Fig 2: FIFO with data</caption><tr><td><img src="/img/fifo-rdwr.svg" alt="Example FIFO read/write pointers" width="780" /></td></tr></table>

<p>What happens when the write or read pointer gets to the end
of the buffer?  The pointer in question simply wraps around to the
beginning of the buffer.  Because the buffer pointers just wrap around,
this type of buffer is called a <em>circular buffer</em>.</p>

<p>You can tell when this type of FIFO is full, because write pointer one plus
will equal the read pointer, as in Fig 3 below.</p>

<table style="float: none"><caption>Fig 3: A full FIFO</caption><tr><td><img src="/img/fifo-full.svg" alt="Example image of a full FIFO" width="780" /></td></tr></table>

<p>Further, we’re going to use a special property of FIFO’s that are <code class="language-plaintext highlighter-rouge">2^N</code>
in length.  That is, the read and write pointers will always fit into
<code class="language-plaintext highlighter-rouge">N</code> bits, so no boundary checking is required.  Likewise, the number of elements
within the FIFO is given by the bottom <code class="language-plaintext highlighter-rouge">N</code> bits of the difference between the
write and read pointers.</p>

<h1 id="a-simple-software-fifo">A Simple Software FIFO</h1>

<p>Our focus today is going to be on implementing this operation in Verilog.
Sometimes, though, it helps for formalism of expression to first implement
something like this in C++.  Hence, we’ll use the following C++ code to
illustrate how a FIFO works.</p>

<p>First, we’ll declare what we stated above: our FIFO will have three operations.
These are reset, write, and read.  We’ll also want to be able to query how
many items are in the FIFO.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">FIFO</span> <span class="p">{</span>
	<span class="kt">bool</span>	<span class="n">m_overflow</span><span class="p">,</span> <span class="n">m_underflow</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="o">*</span><span class="n">m_mem</span><span class="p">,</span> <span class="n">m_len</span><span class="p">,</span> <span class="n">m_rdaddr</span><span class="p">,</span> <span class="n">m_wraddr</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="n">FIFO</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">lglength</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// On any allocation of a new FIFO,</span>
		<span class="c1">// allocate memory to hold our buffer,</span>
		<span class="c1">// and record how big the buffer is.</span>
		<span class="n">m_len</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">lglength</span><span class="p">);</span>
		<span class="n">m_mem</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m_len</span><span class="p">];</span>
		<span class="n">reset</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="kt">void</span>	<span class="n">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">void</span>	<span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">item</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="n">read</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
	<span class="kt">int</span>	<span class="n">fill</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<p>Resetting the FIFO will simply set both read and write pointers back to zero.
It will also clear any error flags.  Note that we aren’t going to <em>clear</em>
the memory here–mostly because we won’t be able to do that in Verilog very
easily later.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">FIFO</span><span class="o">::</span><span class="n">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Reset our pointers to the beginning of the memory</span>
	<span class="n">m_wraddr</span> <span class="o">=</span> <span class="n">m_rdaddr</span> <span class="o">=</span> <span class="mi">0</span>

	<span class="c1">// Reset the error flags to false</span>
	<span class="n">m_overflow</span> <span class="o">=</span> <span class="n">m_underflow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><em>Writing</em> an item is almost as simple as setting the memory and incrementing
the pointer.  We’re going to add two more pieces to this logic, though.  The
first is required: the address of the next write pointer, <code class="language-plaintext highlighter-rouge">nxtaddr</code> may need
to wrap around the buffer to be valid.  So, we’ll check that first.  Second,
if the newly calculated next write pointer, <code class="language-plaintext highlighter-rouge">nxtaddr</code>, is equal to our read
address, that’s an indication that the buffer is full.  Here, we’ll cowardly
refuse to write to a full FIFO.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// Produce an item / Write one item to the FIFO</span>
<span class="kt">void</span> <span class="n">FIFO</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// First, calculate the address of the next</span>
	<span class="c1">// write pointer.</span>
	<span class="kt">int</span> <span class="n">nxtaddr</span> <span class="o">=</span> <span class="n">m_wraddr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// Adjust for any wrapping around the ends of the buffer</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nxtaddr</span> <span class="o">&gt;=</span> <span class="n">m_len</span><span class="p">)</span>
		<span class="n">nxtaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="c1">// If this next pointer is the same as the read pointer,</span>
	<span class="c1">// the FIFO is full: cowardly refuse to write to the FIFO</span>
	<span class="c1">// in that casej</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nxtaddr</span> <span class="o">!=</span> <span class="n">m_rdaddr</span><span class="p">)</span> <span class="p">{</span>

		<span class="c1">// Actually write an item to the FIFO</span>
		<span class="n">m_mem</span><span class="p">[</span><span class="n">m_wraddr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">item</span><span class="p">;</span>
		<span class="n">m_wraddr</span> <span class="o">=</span> <span class="n">nxtaddr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="c1">// Set an error flag on any attempt to write to a full FIFO</span>
		<span class="n">m_overflow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><em>Reading</em> from the FIFO is just about as simple: we want to return the next
item in our buffer and increment the read pointer, wrapping if necessary.  As
before, though, there’s a twist: we only want to
increase our buffer pointer if the FIFO wasn’t empty.  Attempts to read from
an empty buffer should create an underflow (error) condition, while leaving
the FIFO empty.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// Read/consume one item from the FIFO</span>
<span class="kt">int</span> <span class="n">FIFO</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">item</span><span class="p">;</span>

	<span class="c1">// We'll return the next item to be read</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">m_mem</span><span class="p">[</span><span class="n">m_rdaddr</span><span class="p">];</span>

	<span class="c1">// Only consume if the FIFO is not empty</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_rdaddr</span> <span class="o">!=</span> <span class="n">m_wraddr</span><span class="p">)</span> <span class="p">{</span>

		<span class="c1">// Increment the read pointer</span>
		<span class="n">m_rdaddr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="c1">// Check to see if it wraps ppast the end of the buffer</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m_rdaddr</span> <span class="o">&gt;=</span> <span class="n">m_len</span><span class="p">)</span>
			<span class="n">m_rdaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">m_underflow</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">item</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Finally, our last operation is to return the number of items found within this
FIFO.  This is given by the write pointer minus the read pointer, but done in
such a way as to never return anything less than zero or greater than the
size of our buffer.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span>	<span class="n">FIFO</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">m_wraddr</span> <span class="o">-</span> <span class="n">m_rdaddr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">m_len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>In many ways, this set of operations isn’t really complete.  We haven’t returned
the number of empty (unused) values in the buffer, we haven’t created any
boolean values to return whether or not the buffer is non-empty, half-empty, or
half full, neither have we made any methods to read whether or not an error
condition has occurred.  We’ll leave these exercises to the student.</p>

<h1 id="first-verilog-cut">First Verilog Cut</h1>

<p>If we just tried to translate this C++ code to Verilog, we might end up with
the always block shown below:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">parameter</span>	<span class="n">LGLEN</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="kt">reg</span>	<span class="p">[(</span><span class="n">LGLEN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">rdaddr</span><span class="p">,</span> <span class="n">wraddr</span><span class="p">;</span>
<span class="kt">reg</span>	<span class="p">[(</span><span class="n">INPUTWIDTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">mem</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGLEN</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)];</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">rdaddr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">overrun</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">underrun</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">o_fill</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_write</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wraddr</span> <span class="o">+</span> <span class="mb">1'b1</span> <span class="o">!=</span> <span class="n">rdaddr</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">mem</span><span class="p">[</span><span class="n">wraddr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_item</span><span class="p">;</span>
			<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">wraddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">);</span>
			<span class="n">o_fill</span>   <span class="o">&lt;=</span> <span class="n">o_fill</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;;</span>
		<span class="k">end</span> <span class="k">else</span>
			<span class="n">overrun</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_read</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wraddr</span> <span class="o">!=</span> <span class="n">rdaddr</span><span class="p">)</span> <span class="c1">// If not empty</span>
		<span class="k">begin</span>
			<span class="n">o_item</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">rdaddr</span><span class="p">]</span>
			<span class="n">rdaddr</span> <span class="o">&lt;=</span> <span class="n">rdaddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
			<span class="n">o_fill</span>   <span class="o">&lt;=</span> <span class="n">o_fill</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;;</span>
		<span class="k">end</span> <span class="k">else</span>
			<span class="n">underrun</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span> <span class="c1">/// Ooops!  What about ((i_write)&amp;&amp;(i_read))</span></code></pre></figure>

<p>With a little thought, it’s not too hard to see that this initial approach
is going to have some problems.</p>

<ol>
  <li>
    <p>What happens when a read and write request come in together?</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">wraddr + 1'b1</code> needs to be limited to <code class="language-plaintext highlighter-rouge">N</code> bits, otherwise we don’t get the
proper wrap around the end of the buffer effect.</p>
  </li>
</ol>

<p>We’ll need to make some changes therefore.</p>

<h1 id="next-verilog-cut">Next Verilog Cut</h1>

<p>Let’s see if we can’t improve on our first attempt to write the Verilog
code for a FIFO with four basic changes.</p>

<p>The first change we’ll make is to separate the read and write tasks, and
likewise the various variables, into separate always blocks.  This will
make it easier to handle concurrent reads and writes.</p>

<p>Our second change will be to capture the logic associated with testing whether
or not the FIFO is full or empty into two flags: <code class="language-plaintext highlighter-rouge">full</code> and <code class="language-plaintext highlighter-rouge">empty</code>.  This
will help us figure out how to optimize things later.</p>

<p>Third, to deal with concurrent reading and writing, we’ll allow the following:
Concurrent reads and writes are allowed, as long as the FIFO isn’t empty.
This is to allow the memory a full clock to handle the write before the memory
is available to be read.</p>

<p>Finally, we’ll separate the calculation of the number of items in the buffer
into its own logic section.</p>

<p>So, to walk through the code, on every clock we will write to memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">mem</span><span class="p">[</span><span class="n">wraddr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_item</span><span class="p">;</span></code></pre></figure>

<p>If there’s no write taking place on this clock, the memory write will just
change the contents of an unused data item.</p>

<p>Likewise on every clock we will read from memory and create one of our outputs.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">o_item</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">rdaddr</span><span class="p">];</span></code></pre></figure>

<p>As with the memory write, if the FIFO isn’t being read on this clock then it
won’t hurt us to set the output anyway.</p>

<p>Many FPGA’s will also allow you to gate
these memory operation for no additional logic cost, as in:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_write</span><span class="p">)</span>
		<span class="n">mem</span><span class="p">[</span><span class="n">wraddr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_item</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_read</span><span class="p">)</span>
		<span class="n">o_item</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">rdaddr</span><span class="p">];</span></code></pre></figure>

<p>While such gating may be useful, it’s not required in this example.</p>

<p>The next step in writing to the FIFO is handling the FIFO write pointer,
<code class="language-plaintext highlighter-rouge">wraddr</code>.
Since the logic used to adjust the FIFO write pointer is almost identical to the
logic to adjust the overrun flag, we’ll place the two into the same always
block.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">overrun</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_write</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Update the FIFO write address any time a write is made to</span>
		<span class="c1">// the FIFO and it's not FULL.</span>
		<span class="c1">//</span>
		<span class="c1">// OR any time a write is made to the FIFO at the same time a</span>
		<span class="c1">// read is made from the FIFO.</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">full</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_read</span><span class="p">))</span>
			<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">wraddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">overrun</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Other than separating this into its own always block, the biggest change
between this version and our prior one is the introduction of the <code class="language-plaintext highlighter-rouge">!full</code>
flag.  This flag replaces the <code class="language-plaintext highlighter-rouge">(wraddr+1'b1)!=rdaddr</code> calculation from before.</p>

<p>The other more subtle change is that we will now write to the FIFO any
time the FIFO is not full, <em>or</em> any time the FIFO is full <em>and</em> a read is
taking place on the same clock.</p>

<p>The read address, <code class="language-plaintext highlighter-rouge">rdaddr</code>, and <code class="language-plaintext highlighter-rouge">underrun</code> error flag calculation below
follow a very similar form to that of the write address and overflow
calculation above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// Set wraddr and underrun</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">rdaddr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">underrun</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_read</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// On any read request, increment the pointer if the FIFO isn't</span>
		<span class="c1">// empty--independent of whether a write operation is taking</span>
		<span class="c1">// place at the same time.</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">)</span>
			<span class="n">rdaddr</span> <span class="o">&lt;=</span> <span class="n">rdaddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="c1">// If a read is requested, but the FIFO was full, set</span>
			<span class="c1">// an underrun error flag.</span>
			<span class="n">underrun</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>The big difference is that the FIFO must be non-empty to read, <em>even if</em> a
write is taking place on the same clock.  This gives the memory a clock
to store the value, before trying to read it.</p>

<p>The next and final trick is determining how full the FIFO is.</p>

<p>You might be tempted to set <code class="language-plaintext highlighter-rouge">o_fill &lt;= wraddr-rdaddr</code> just like we did in our
C++ implementation.  This, however, doesn’t work.  Such a fill measure will
always be one clock out of date.</p>

<p>Instead, we’ll count how many items are in our buffer as those items are
added or removed from the buffer.  That means, though, that we’ll need to pay
attention to not only the read and write request lines, but also whether or
not the FIFO is full or empty when the request is made.  This simple logic
fits nicely into a case statement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// Calculate the fill</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_fill</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">casez</span><span class="p">(</span><span class="o">{</span> <span class="n">i_write</span><span class="p">,</span> <span class="n">i_read</span><span class="p">,</span> <span class="o">!</span><span class="n">full</span><span class="p">,</span> <span class="o">!</span><span class="n">empty</span> <span class="o">}</span><span class="p">)</span>
	<span class="mb">4'b01?1</span><span class="o">:</span> <span class="n">o_fill</span> <span class="o">&lt;=</span> <span class="n">o_fill</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span>	<span class="c1">// A successful read</span>
	<span class="mb">4'b101?</span><span class="o">:</span> <span class="n">o_fill</span> <span class="o">&lt;=</span> <span class="n">o_fill</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>	<span class="c1">// A successful write</span>
	<span class="mb">4'b1110</span><span class="o">:</span> <span class="n">o_fill</span> <span class="o">&lt;=</span> <span class="n">o_fill</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>	<span class="c1">// Successful write, failed read</span>
	<span class="c1">// 4'b11?1: Successful read *and* write -- no change</span>
	<span class="nl">default:</span> <span class="n">o_fill</span> <span class="o">&lt;=</span> <span class="n">o_fill</span><span class="p">;</span>	<span class="c1">// Default, no change</span>
	<span class="k">endcase</span></code></pre></figure>

<p>That leaves as our final task determining whether or not the FIFO is full,
as well as what the next write address would be, were we to write to our FIFO
on this clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">nxtaddr</span> <span class="o">=</span> <span class="n">wraddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
<span class="k">assign</span>	<span class="n">full</span>  <span class="o">=</span> <span class="p">(</span><span class="n">nxtaddr</span> <span class="o">==</span> <span class="n">rdaddr</span><span class="p">);</span>
<span class="k">assign</span>	<span class="n">empty</span> <span class="o">=</span> <span class="p">(</span><span class="n">wraddr</span>  <span class="o">==</span> <span class="n">rdaddr</span><span class="p">);</span></code></pre></figure>

<p>The above approach should yield a working FIFO.</p>

<p>It just won’t be a high speed FIFO, or a low logic FIFO implementation.</p>

<p>The problem is specifically the cost of calculating <code class="language-plaintext highlighter-rouge">full</code> and <code class="language-plaintext highlighter-rouge">empty</code>.
Remember when I discussed <a href="/blog/2017/06/12/minimizing-luts.html">keeping the conditions on an <code class="language-plaintext highlighter-rouge">if-then-else</code> branch
simple</a>?  We just
violated that rule.</p>

<p>We’ll have to try again, therefore.</p>

<h1 id="high-speed-verilog-cut">High Speed Verilog Cut</h1>

<p>This time, let’s keep everything the same as before, with the exception of the
<code class="language-plaintext highlighter-rouge">full</code> and <code class="language-plaintext highlighter-rouge">empty</code> flags.  Let’s spend some time focusing on those.</p>

<p>The problem with these two flags is that they are calculated within the
nested if’s above.  Further, they are calculated within the nested if of a
large amount of logic, since each of the address lines sets <code class="language-plaintext highlighter-rouge">N</code> bits.
What this means is that once the logic has been calculated, it then needs
to be distributed among many elements–an additional timing cost.</p>

<p>We’ll solve this problem by pushing back the <code class="language-plaintext highlighter-rouge">full</code> and <code class="language-plaintext highlighter-rouge">empty</code> logic one
clock earlier.  This will keep the <code class="language-plaintext highlighter-rouge">full</code> and <code class="language-plaintext highlighter-rouge">empty</code> designations
synchronous to the actual state of the FIFO on any given clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">wire</span>	<span class="p">[(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">dblnext</span><span class="p">,</span> <span class="n">nxtread</span><span class="p">;</span>
<span class="k">assign</span>	<span class="n">dblnext</span> <span class="o">=</span> <span class="n">wraddr</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">assign</span>	<span class="n">nxtread</span> <span class="o">=</span> <span class="n">rdaddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">full</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">empty</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">casez</span><span class="p">(</span><span class="o">{</span> <span class="n">i_write</span><span class="p">,</span> <span class="n">i_read</span><span class="p">,</span> <span class="o">!</span><span class="n">full</span><span class="p">,</span> <span class="o">!</span><span class="n">empty</span> <span class="o">}</span><span class="p">)</span>
	<span class="mb">4'b01?1</span><span class="o">:</span> <span class="k">begin</span>	<span class="c1">// A successful read</span>
		<span class="n">full</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">empty</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">nxtread</span> <span class="o">==</span> <span class="n">wraddr</span><span class="p">);</span>
	<span class="k">end</span>
	<span class="mb">4'b101?</span><span class="o">:</span> <span class="k">begin</span>	<span class="c1">// A successful write</span>
		<span class="n">full</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">dblnext</span> <span class="o">==</span> <span class="n">rdaddr</span><span class="p">);</span>
		<span class="n">empty</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span>
	<span class="mb">4'b11?0</span><span class="o">:</span> <span class="k">begin</span>	<span class="c1">// Successful write, failed read</span>
		<span class="n">full</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">empty</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span>
	<span class="mb">4'b11?1</span><span class="o">:</span> <span class="k">begin</span>	<span class="c1">// Successful read and write</span>
		<span class="n">full</span>  <span class="o">&lt;=</span> <span class="n">full</span><span class="p">;</span>
		<span class="n">empty</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>We’ll get a warning for adding a 32-bit number to an <code class="language-plaintext highlighter-rouge">N</code> bit number when
calculating dblnext, but rather than complicating the logic to get rid of
the warning, we’ll leave it as is so you can see and understand what’s going
on.</p>

<p>That’s it, though.  Now you know how to build a simple (application independent)
FIFO in Verilog.</p>

<h1 id="next-steps">Next Steps</h1>

<p>Knowing how to build a FIFO is really the first step in many steps.  It’s a
required part of many component designs, and so being able to build one
is a good skill to have.</p>

<p>Indeed, now that we’ve discussed how to build a FIFO, we can return to our
<a href="https://github.com/ZipCPU/dbgbus">debugging bus</a> and create an asynchronous
capabilities.  Such a capability will be required to demonstrate the pipeline
modes of the wishbone bus.</p>

<p>If you ever want to reference other examples, you’ll find many FIFO
implementations posted on <a href="https://opencores.org/projects">OpenCores</a>.</p>

<p>Strangely, from my own experience, I tend not to reuse the FIFO’s I’ve built
from one design need to the next.  Sure, the <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v">FIFO I
built</a> for a
<a href="https://github.com/ZipCPU/wbuart32">UART</a> tends
to stay with that <a href="https://github.com/ZipCPU/wbuart32">UART</a>, but the FIFO’s
I build for <a href="https://github.com/ZipCPU/wbpmic">audio</a> or video tend to be
different from the <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/ufifo.v">one for the
UART</a>–even though
the design outline above is roughly the same.</p>

<p>Instead, whenever I need a FIFO, I tend to copy from a working FIFO
and then adjust the code to fit my new needs.  The reason is simple: it seems
that every application requires a different interface to the FIFO.</p>

<p>For example, a CPU will want to know from a
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/wbuart.v">UART receiver</a>
how many items can be read (i.e. <code class="language-plaintext highlighter-rouge">o_fill</code>), but from the transmitter it wants
to know how many items can be written to it (<code class="language-plaintext highlighter-rouge">N-1-ofill</code>).  Likewise, the CPU
might wish to wait until the receive queue is halfway full (<code class="language-plaintext highlighter-rouge">o_fill &gt; N/2</code>),
whereas the transmit FIFO would want to wait until the transmit queue is half
empty (<code class="language-plaintext highlighter-rouge">ofill &lt; N/2-1</code>).</p>

<p>I guess this means that FIFO’s are one of the few places where the question
of whether the glass is half full or half empty becomes important.</p>

<p>Another strange FIFO I’ve needed is the one to handle <a href="https://github.com/ZipCPU/wb2axip">AXI bus
requests</a>.  In this case, instead of a
single set of read and write pointers, I’ve needed to use
multiple pointers so as to properly know where a transaction request is in
the process, and whether or not the AXI ready signals need to be dropped.</p>

<p>The point is just that, in spite of the basics, FIFO’s tend to differ from
one context to another.</p>

<p>Let me know your thoughts and experiences below!</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>He hath made everything beautiful in his time: also he hath set the world in their heart, so that no man can find out the work that God maketh from the beginning to the end.</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
