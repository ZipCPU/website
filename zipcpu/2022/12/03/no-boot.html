<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Your soft-core CPU won't boot.  Where should you start debugging?</title>
  <meta name="description" content="When I first decided to start GisselquistTechnology, one of myfirst internal projects was to see if I could get theLinux kernel to boot from a read-onlyfile ...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2022/12/03/no-boot.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Your soft-core CPU won't boot.  Where should you start debugging?</h1>
    <p class="post-meta"><time datetime="2022-12-03T00:00:00-05:00" itemprop="datePublished">Dec 3, 2022</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>When I first decided to start <a href="/about/gisselquist-technology.html">Gisselquist
Technology</a>, one of my
first internal projects was to see if I could get the
<a href="https://en.wikipedia.org/wiki/Linux">Linux</a> kernel to boot from a read-only
file system–to promote longevity on a flash device, using a kernel that I
could swap out remotely at a later time via a call to
<a href="https://wiki.archlinux.org/title/kexec">kexec()</a>.  I intended to
do this using a <a href="https://beagleboard.org/black">Beagle Board Black</a>, and then
to sell the capability to a customer as something they could do with their
own internally developed boards.</p>

<table align="center" style="float: left; padding: 25px"><tr><td><img src="/img/no-boot/blank-screen.svg" alt="" width="320" /></td></tr></table>

<p>So, I made a bunch of kernel configuration changes, and then tried to boot
my newly configured kernel.</p>

<p>Nothing happened.</p>

<p>I just stared at a blank screen.</p>

<p>At the time, I had no idea where to start.</p>

<p>Since that time, I’ve gone on to build <a href="/about/zipcpu.html">my own
CPU</a>.  In other words, I’ve now had
to deal with this problem many times over, where I “start” my CPU and
nothing happens.  No, I haven’t gone back to the
<a href="https://en.wikipedia.org/wiki/Linux">Linux</a>
kernel, but I’ve
still had the same basic problem.</p>

<p>There is one key difference, however: with a soft-core CPU, 1) I know my
hardware (I never knew the ARM that well), and 2) I can run a
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
of that hardware and <a href="/blog/2017/07/08/getting-started-with-wbscope.html">get a
trace</a>
leading me straight to the problem.  (Yes, this is a
painful approach, but it is a reliable one.)</p>

<p>So, let me offer you some of the lessons I’ve learned while trying to debug
the startup of the <a href="/about/zipcpu.html">ZipCPU</a>.
Specifically, how shall the CPU be debugged between when it is released from
reset and the first (successful) call to <code class="language-plaintext highlighter-rouge">printf()</code>?</p>

<h2 id="how-to-debug-a-boot-failure">How to debug a boot failure</h2>

<p>So, let’s look into how one might debug a “boot failure”.  In this case, by
“boot failure”, I mean that you’ve “loaded” both your soft-core CPU either
into <a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
or onto an FPGA, and your program onto your memory device
and then something goes wrong between <a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">releasing the CPU from
reset</a>
and the first console output.  The question here and now is, how do you
debug that?  I mean, a CPU represents a lot of logic to dig through, and
there’s a lot of software between reset and <code class="language-plaintext highlighter-rouge">main()</code>.  How do you go about
narrowing down the problem to find the bug?</p>

<p>Here’s some of the approaches I’ve found valuable.</p>

<ol>
  <li>
    <p>Start at the <a href="/zipcpu/2018/03/21/dblfetch.html">instruction
fetch</a></p>

    <p>My first step is almost always to look at a
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
trace of the <a href="/zipcpu/2018/03/21/dblfetch.html">instruction
fetch</a>.</p>

    <p>For this, you’ll first need a hex dump of the program you are trying to run.
I usually get this from <code class="language-plaintext highlighter-rouge">objdump -S -D &lt;program&gt;</code>.  Indeed, I use this
command so often, I have a <a href="https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/board/Makefile#L80-L81">common “make”
target</a>
that I will use to produce this dump file.</p>

    <p>Now, looking at the dump file, open a <a href="/blog/2017/07/31/vcd.html">simulation
trace</a> and look at the
address and value of the first several instructions coming from the
<a href="/zipcpu/2018/03/21/dblfetch.html">instruction fetch</a>
and going to the CPU’s core.  These address/value pairs
should match a dump of your executable file.</p>

    <p>If they don’t match, that should tell you where to look next:</p>

    <ul>
      <li>
        <p>Reset problems</p>

        <p>Are you getting any instructions from the
<a href="/zipcpu/2018/03/21/dblfetch.html">instruction fetch</a>
at all?  If not, you might have a bug in your <a href="/zipcpu/2017/08/25/hw-debugging.html">reset
control</a>.
Does the CPU come out of reset at all?  If it does, does it come out
of reset reading from the right address?</p>

        <p>It can be a challenge to get a CPU, configured to boot from a
<a href="/blog/2019/03/27/qflexpress.html">flash memory</a>
address, to start from a different address describing some other memory
that might be easier to work with–such as block RAM.  I often do this to
initially verify the CPU, before verifying the
<a href="/blog/2019/03/27/qflexpress.html">flash memory</a>, but
getting a program to load and start properly from somewhere other than the
reset address can be a true test of both the loader and the <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">CPU’s
debugging port</a>.</p>
      </li>
      <li>
        <p>Loader</p>

        <p>Did your software get loaded into the right place?  That is, if the CPU
is coming out of reset properly, and if it is reading from the right
addresses, is it getting the right values?  If not, then this is worth
chasing down through the
<a href="/blog/2017/07/31/vcd.html">VCD trace</a>.
You might find that you haven’t loaded the right values into memory in
the first place.  (Or … you might also find that either your
<a href="/zipcpu/2018/03/21/dblfetch.html">instruction fetch</a>
unit, your
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>, or
your memory controller are broken ….)</p>

        <p>In my case, I often need to be reminded that the
<a href="/about/zipcpu.html">ZipCPU</a> is a <a href="https://en.wikipedia.org/wiki/Endianness">big 
endian</a> machine while my host
computer is a x86 type of <a href="https://en.wikipedia.org/wiki/Endianness">little
endian</a> machine.  Sometimes
a translation is required between the two.</p>
      </li>
    </ul>
  </li>
</ol>

<table align="center" style="float: right"><tr><td><img src="/img/no-boot/nfs.svg" alt="" width="420" /></td></tr></table>

<ul>
  <li>
    <p>Memory controller problems</p>

    <p>Before you start your CPU, it’s often worth double checking the load
interface.  After writing to address XYZ, for example, can you read the
same value back from address XYZ that you have just written to it?  This
problem may be indistinguishable from a loader problem.  In both cases,
values will be read from memory, but they won’t be the right values.</p>

    <p>To tell the difference between loader and memory controller problems, pick
one address that the
<a href="/zipcpu/2018/03/21/dblfetch.html">fetch</a>
returns in error and track what’s written to it.
If the loader puts the right value into it, but the memory controller
returns something else, then you know to look into your memory controller
for the bug.  We’ll come back to this again in a moment.</p>
  </li>
</ul>

<table align="center" style="float: left; padding: 25px"><tr><td><img src="/img/no-boot/financial.svg" alt="" width="420" /></td></tr></table>

<p>You can often dig into this bug using a <a href="/2017/06/05/wb-bridge-overview.html">debugging
  bus</a>: While <a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">holding
  the CPU in
  reset</a>,
  write to the memory that will hold it’s program and then
  read the memory values back out.  They should match.  This doesn’t always
  work, however, since the CPU might use types of accesses to the memory
  that the <a href="/2017/06/05/wb-bridge-overview.html">debug bus</a>
  <a href="/2021/12/30/dbgaxil.html">doesn’t support–things like
  <code class="language-plaintext highlighter-rouge">ARLEN&gt;0</code> or <code class="language-plaintext highlighter-rouge">ARBURST=WRAP</code></a>–but
  it’s at least a good start.</p>

<table align="center" style="float: right"><tr><td><img src="/img/no-boot/why-auto.svg" alt="" width="420" /></td></tr></table>

<ul>
  <li>
    <p>Bus addressing</p>

    <p>There’s always the possibility that you have an error in how the
<a href="/blog/2019/07/17/crossbar.html">bus interconnect</a>
was set up.  Perhaps the
<a href="/blog/2019/07/17/crossbar.html">bus interconnect</a>
is routing the CPU’s reset address to the wrong slave, perhaps you have
the wrong number of address wires driving the slave.  Either way, you’ll
see this problem when tracing the instruction request from the CPU back
to the bus slave responding to it.</p>
  </li>
</ul>

<ol start="2">
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a> is just a bunch of memory copies.  Look for the loops.</p>

    <p>The first piece of software any CPU starts is often known as
<a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a>.  This
is the software that sits between reset and main().  This is the software
responsible for placing your <code class="language-plaintext highlighter-rouge">main()</code> program into memory.</p>
  </li>
</ol>

<table align="center" style="float: left; padding: 25px"><caption>Fig 1. CRT0 is primarily a bunch of memory copies</caption><tr><td><img src="/img/no-boot/crt0.svg" alt="" width="480" /></td></tr></table>

<p>The first thing
   <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a>
   needs to do is to configure your RAM or ROM controllers.  The next step
   is usually a series of memory copies.</p>

<p>On many computers, <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a>
   is written in assembler.  While I tried to avoid that with the
   <a href="/about/zipcpu.html">ZipCPU</a>, there’s still <a href="https://github.com/ZipCPU/zipcpu/blob/bc3ced1d51c975b20877d39aac0a578a461835f5/sim/zipsw/zlib/crt0.c#L165-L219">a small
   assembly routine required</a>
   before I can transition to the C function that performs the actual
   memory copies–<a href="https://github.com/ZipCPU/zipcpu/blob/bc3ced1d51c975b20877d39aac0a578a461835f5/sim/zipsw/zlib/crt0.c#L266">a function I’ve named <code class="language-plaintext highlighter-rouge">_bootloader</code></a>.
   The small assembler script is responsible for any hardware configurations
   necessary to get the RAM running, for then setting the
   <a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a>,
   and finally for calling the <code class="language-plaintext highlighter-rouge">_bootloader</code> function.  This is marked
   as step 1 in Fig. 1 above.  Because this step is so small, typically
   less than 20 instructions, it can easily be debugged using the
   <a href="/blog/2017/07/31/vcd.html">VCD trace file</a> if necessary.</p>

<p>This is not the case with the step that follows.</p>

<p>The first step of the <code class="language-plaintext highlighter-rouge">_bootloader</code> function, marked as step 2 in Fig. 1,
   is a big memory copy.  It will <a href="https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c#L324-L333">copy instruction memory from ROM to RAM</a>,
   and then again to <a href="https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c#L324-L333">copy any pre-initialized global variables from ROM to
   RAM</a>.</p>

<p>Debugging this memory copy can be a challenge.</p>

<p>So how do you go about debugging a
   <a href="https://cplusplus.com/reference/cstring/memcpy/">memcpy()</a>?
   That piece of software 
   is just a huge loop!  The CPU may be copying millions of bytes, and
   so staring at this trace can quickly get frustrating.</p>

<table align="center" style="float: right"><tr><td><img src="/img/no-boot/zippc.svg" alt="" width="420" /></td></tr></table>

<p>Here’s the trick: instruct your
   <a href="/blog/2017/07/31/vcd.html">VCD</a>
   <a href="https://gtkwave.sourceforge.net">viewer</a>
   (I use <a href="http://gtkwave.sourceforge.net">GTKWave</a>)
   to display the CPU instruction address register, often called the <a href="https://en.wikipedia.org/wiki/Program_counter">program
   counter or PC (for short)</a>,
   as an “analog” waveform.  Then zoom out.  Watch how this waveform changes,
   and you’ll quickly find where the loop begins and ends.</p>

<ul>
  <li>
    <p>Make sure the bus doesn’t freeze up while reading.  This is often a sign
that you didn’t formally verify a bus component.  It could be either
<a href="https://zipcpu.com/zipcpu/2021/04/17/axilops.html">CPU’s memory
controller</a>, the
hardware memory controller, or the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> between
the two.</p>
  </li>
  <li>
    <p>Look for loops that do not end.  This is often a sign that either the
CPU can’t execute the instructions you think it can, or that the CPU
is reading the wrong data from memory.</p>
  </li>
  <li>
    <p>Now debug the beginning and ending of these loops</p>

    <p>If the first word is correctly copied into memory but the last word is not,
then bisect the loop as many times as necessary to find the bug.  Perhaps
you are copying from a device that isn’t as big as you think it is?
Perhaps you have an incorrect copy size?</p>
  </li>
</ul>

<p>One problem I’ve often had here can be traced to trying to use one
   <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a>
   routine for many hardware situations.  For example, sometimes I’ll have a
   high speed (block RAM) address range to copy memory to in addition to a
   (slower speed) SDRAM address range.  To tell the difference, I need to
   check this block RAM address against NULL <em>after linking</em>.  However, GCC
   will often <em>assume</em> the address is not NULL (because of how I’ve declared
   it), and so skip this comparison.  In this case, the CPU didn’t run all the
   <a href="https://cplusplus.com/reference/cstring/memcpy/">memcpy()</a>’s I had
   requested.  Looking over how
   <a href="https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c">CRT0</a>
   got translated to assembly should show you if the NULL checks were removed
   by the compiler or not.</p>

<table align="center" style="float: left; padding: 25px"><tr><td><img src="/img/no-boot/know-assembly.svg" alt="" width="420" /></td></tr></table>

<p>After copying program memory and initial variables, the <code class="language-plaintext highlighter-rouge">_bootloader</code>
   routine then needs to <a href="https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c#L335-L343">zero
   out</a>.
   the <a href="https://en.wikipedia.org/wiki/.bss">BSS data segment</a>.  This basically
   requires a glorified
   <a href="https://cplusplus.com/reference/cstring/memset/">memset()</a>,
   which can be debugged in the same fashion as the
   <a href="https://cplusplus.com/reference/cstring/memcpy/">memcpy()</a> above.</p>

<ol start="3">
  <li>
    <p>Verify the <a href="/zipcpu/2018/03/21/dblfetch.html">instruction
fetch</a> following the
<a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a> routine</p>

    <p>Once <a href="https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c">CRT0</a>
completes, that is once both the (alternative)
<a href="https://cplusplus.com/reference/cstring/memcpy/">memcpy()</a> and
<a href="https://cplusplus.com/reference/cstring/memset/">memset()</a>
functions complete, the CPU should jump to the beginning of <code class="language-plaintext highlighter-rouge">main()</code>.
This is illustrated as step 4 in Fig. 1 above, and shown in Fig. 2 below.
Therefore, let’s go back to the <a href="/zipcpu/2018/03/21/dblfetch.html">instruction
fetch</a>
and see that it does so.</p>

    <p>Does the CPU return from the <code class="language-plaintext highlighter-rouge">_bootloader</code> properly?  Or did
the return address get overwritten somehow?</p>

    <p>Are the instructions provided to the CPU the correct ones?</p>

    <p>In one case, I used the DMA to copy data from the
<a href="/blog/2019/03/27/qflexpress.html">flash</a>
to a DDR3 SDRAM via Xilinx’s DDR3 controller.  When I struggled to get the
<a href="/about/zipcpu.html">ZipCPU</a> software to work, I called
a <a href="https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/syscalls.c#L54-L68">software serial port output
routine</a>
from within <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a> to help me debug what
was going on.  In that case, the serial port output routine
I used wanted to insert carriage return characters before newlines, and
so it needed to know if the last character was a carriage return.  This
value was supposed to be kept in SDRAM memory–the very memory I
was trying to use and load.  This shouldn’t be a problem, I reasoned,
since at most I might output an extra carriage return, and the
<a href="https://cplusplus.com/reference/cstring/memcpy/">memcpy()</a>
routine would eventually overwrite this value with the correct one anyway.</p>

    <p>The problem, however, was that using this memory region caused the CPU
to read memory <em>into the data cache before</em> the DMA completed.  This
left me with with a corrupt copy of data memory in the cache once the
<code class="language-plaintext highlighter-rouge">_bootloader</code> completed.  In other words, don’t forget to clear the
cache once the DMA completes any memory copies.</p>
  </li>
</ol>

<ol start="4">
  <li>
    <p>SIM instructions</p>

    <p>Many CPU’s, to include both <a href="https://openrisc.io">OpenRISC</a> and the
<a href="/about/zipcpu.html">ZipCPU</a>, have special simulation
only instructions.  These are basically <a href="https://en.wikipedia.org/wiki/NOP_(code)">NOOP
instructions</a> that will cause
the CPU to perform a special task in simulation only.  In the case of the
<a href="/about/zipcpu.html">ZipCPU</a>, the instruction
<code class="language-plaintext highlighter-rouge">NOUT</code> can be used to dump a character to the simulation console.  The
instruction <code class="language-plaintext highlighter-rouge">NDUMP</code> can be used to dump a register’s value to the console.
The <a href="/about/zipcpu.html">ZipCPU</a> assembler also
understands <code class="language-plaintext highlighter-rouge">NSTR</code>, which can be used to create a series of <code class="language-plaintext highlighter-rouge">NOUT</code>
instructions to send a more readable string to the simulation console.
If these instructions are left in the code when it runs in actual hardware,
then they will simply be ignored like any other
<a href="https://en.wikipedia.org/wiki/NOP_(code)">NOOP instruction</a>.</p>

    <p>How can you use these?  You can use them to pepper your
<a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a> function with these
instructions, and therefore know how far your CPU got in the
bootup process before it died.</p>

    <p>In my case, I’ve done this often enough that the
<a href="/about/zipcpu.html">ZipCPU</a>’s <a href="https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c"><code class="language-plaintext highlighter-rouge">_bootloader</code>
function</a>
has the appropriate <code class="language-plaintext highlighter-rouge">NSTR</code> commands (commented) throughout, so I can
uncomment these if necessary to tell how far it got in the loading process.</p>
  </li>
</ol>

<ol start="5">
  <li>
    <p>Use the <a href="/2017/06/05/wb-bridge-overview.html">debugging
bus</a> to your advantage</p>

    <p>I recently had the opportunity to test both a
<a href="https://www.apmemory.com/products/psram-iot-ram/">PSRAM</a> and a
<a href="https://1bitsquared.com/products/pmod-hyperram">HyperRAM</a> driver
with the <a href="/about/zipcpu.html">ZipCPU</a>.  In both cases,
however, the memory needed to be configured properly before it could be
used.  This meant that I needed to modify the
<a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a> function so that it
first configured the memory, and the memory controller, before attempting
to copy the CPU software to memory.</p>

    <p>To get this right, I first fired up the hardware and used the <a href="/2017/06/05/wb-bridge-overview.html">debug
bus</a> to read and
write hardware memory controller configurations.  Any problems were
debugged using the <a href="/blog/2017/07/08/getting-started-with-wbscope.html">WBSCOPE</a>
until the memory fully worked.  Then, with the same
<a href="/2017/06/05/wb-bridge-overview.html">debugging bus</a>,
I verified that I could read and write values to this memory using the
configuration I was testing.  Only after I tested these memory
configurations did I then tell the CPU to invoke them from its
<a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a> function.</p>
  </li>
</ol>

<table align="center" style="float: right"><tr><td><img src="/img/no-boot/config-flash.svg" alt="" width="420" /></td></tr></table>

<p>The problem was actually a bit worse, though, since I wanted to reconfigure
   the flash memory controller that was responsible for reading the initial
   <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a> software.  This controller
   naturally started in SPI mode, but I wanted to reconfigure it to run using
   XiP in QSPI mode.  (Normally, my flash controller does this on startup,
   but I was testing an ASIC controller that day that didn’t have such an
   option.)  That meant I needed to:</p>

<ol>
  <li>
    <p>Configure the external RAM</p>
  </li>
  <li>
    <p>Copy a small subroutine to the external RAM.  This got copied to the
same RAM location that <code class="language-plaintext highlighter-rouge">main()</code> would run from later.</p>
  </li>
  <li>
    <p>Using that small subroutine, take the flash driver off-line and
reconfigure it</p>
  </li>
  <li>
    <p>Return to the original <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a>
function, to now perform the
<a href="https://cplusplus.com/reference/cstring/memcpy/">memcpy()</a>s as
normal, but this time with a flash running in QSPI XiP mode</p>
  </li>
  <li>
    <p>Make sure I flushed the instruction cache, now that my (own) program
memory had changed.</p>
  </li>
</ol>

<p>Debugging this was a bit of a pain, but still it was all quite doable.
   The trick was figuring out how to debug the small subroutine, running in
   RAM, that was reconfiguring the flash driver.  For that, I used the
   <a href="/about/zipcpu.html">ZipCPU</a>’s BREAK instruction to force
   it to halt mid-run, where I could <a href="/zipcpu/2017/08/25/hw-debugging.html">inspect what the CPU had
   accomplished</a>.</p>

<ol start="6">
  <li>
    <p>CPU Break instructions</p>

    <p>The <a href="/about/zipcpu.html">ZipCPU</a> has a <a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK
instruction</a>.
Other CPU’s often have something similar.  Sometimes an
illegal instruction gets repurposed to accomplish the same thing.  The
<a href="/about/zipcpu.html">ZipCPU</a> uses its
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instruction</a>
for debugging.  When/if the CPU hits a
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instruction</a>,
it will halt and wait for the debugger.  At this point, I can <a href="/zipcpu/2017/08/25/hw-debugging.html">step in and
check</a> the
<a href="/about/zipcpu.html">ZipCPU</a>’s register values and any
hardware configurations.  This is really powerful.  For example, you
might:</p>
  </li>
</ol>

<table align="center" style="float: left; padding: 25px"><tr><td><img src="/img/no-boot/fundamental.svg" alt="" width="420" /></td></tr></table>

<ol>
  <li>
    <p>Make the first instruction of <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a>
a <a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instruction</a>.
If the CPU hits the break, you know it managed to 1) boot from the right
address, and 2) read the right instruction at that address.  (While
it’s possible you might still read the right instruction in spite of
these being in error, this would break the fundamental assumption of all
debugging.)</p>

    <p>This is a big help, especially if you are stuck debugging the CPU
from hardware.</p>
  </li>
  <li>
    <p>Place a second
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instruction</a>
after configuring memory.  Now go in and check: was the memory configured
correctly?  Can you still read and write your memory via a
<a href="/2017/06/05/wb-bridge-overview.html">debugging bus</a>?
If not, then back up and fix your bug.</p>

    <p>In the <a href="/about/zipcpu.html">ZipCPU</a>’s case, the
debugger isn’t (yet) smart enough to handle more than one
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instruction</a>.
I will therefore recompile the software without the first
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instruction</a>,
but now including the second one.</p>
  </li>
  <li>
    <p>Place another
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instruction</a>
after each of the various
<a href="https://cplusplus.com/reference/cstring/memcpy/">memcpy()</a>
functions within <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a>.  Are each
of these
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instructions</a>
getting hit?
When they are hit, has the memory that was supposed to be copied been
copied properly?  I usually just check a couple of addresses: the first
three and the last three.  I tend not to check the middle unless these
first and last ones are too repetitive to provide me with any confidence
that the copy was done properly.</p>
  </li>
  <li>
    <p>Make the first instruction of <code class="language-plaintext highlighter-rouge">main()</code> a
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instruction</a>.
Does the CPU get that far?</p>
  </li>
</ol>

<p>Let’s back up to our original list and keep going.  For example …</p>

<ol start="7">
  <li>
    <p>What if your CPU doesn’t have a break instruction?</p>

    <p>If your CPU doesn’t have a break instruction, sometimes you can get away
with a “branch to the current address” instruction, and so create a very
tight loop.  While it’s not quite the same thing, it can still work for this
purpose.</p>

    <p>If your CPU doesn’t have a <a href="/zipcpu/2017/08/25/hw-debugging.html">debug access port to read and write registers
from</a>,
then you may need to spend a lot of time doing the same thing with
LEDs.  While slower, it’s still doable.</p>
  </li>
</ol>

<table align="center" style="float: left; padding: 25px"><tr><td><img src="/img/no-boot/clib-printf.svg" alt="" width="420" /></td></tr></table>

<ol start="8">
  <li>
    <p>Console output, but without the console device driver</p>

    <p>If you can get to the BREAK instruction at the beginning of <code class="language-plaintext highlighter-rouge">main()</code>,
then you are almost there.  Once you get this far, if you are still not
there then the problem must exist between <code class="language-plaintext highlighter-rouge">main()</code> and the first console
output.</p>

    <p>The next check, therefore, is to make sure the console even works.</p>

    <p>There are a couple of problems you might have here.  For example, is the
console port properly connected to the bus?  Is it at the right address?</p>

    <p>For this, you can again use the
<a href="/2017/06/05/wb-bridge-overview.html">debugging bus</a>.
Use it to write to the console device while the CPU is halted.  Do the
values you write get written to the CPU’s console?  If not, then pull
it up in the
<a href="/blog/2018/08/22/what-is-simulation.html">simulator</a>
and figure out why not.</p>

    <p>If it fails in the
<a href="/blog/2018/08/22/what-is-simulation.html">simulator</a>,
then you should have all the information you need to know how to fix it.</p>

    <p>If it works in the
<a href="/blog/2018/08/22/what-is-simulation.html">simulator</a>,
but not in actual hardware, then check that
the <a href="/blog/2017/05/24/serial-port.html">right IO pin is connected, and that the serial port is configured for
the baud right rate</a>.
(You can read about <a href="https://zipcpu.com/blog/2018/08/04/sim-mismatch.html">other reasons why a design might work in simulation,
but not in real hardware,
here</a>.)</p>

    <p>This particular bug is actually a fairly rare bug for me, since I typically
use the serial port for the <a href="/2017/06/05/wb-bridge-overview.html">debugging
bus</a>.  So, in my
case, if I have the <a href="/2017/06/05/wb-bridge-overview.html">debugging
bus</a>
running in the first place then I’ve already <a href="/blog/2017/05/24/serial-port.html">debugged the serial port’s
hardware</a>.
I know, for example, that I have the right IO pin, the right
baud rate, the right parity, the right number of bits per character, etc.</p>

    <p>Once the raw serial port works, in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
first and then hardware,
and <code class="language-plaintext highlighter-rouge">printf()</code> still doesn’t, then it’s time to debug the standard library.
For this, I’ve been known to add more SIM instructions, either <code class="language-plaintext highlighter-rouge">NSTR</code> or
<code class="language-plaintext highlighter-rouge">NDUMP</code>, into the library to trace it through it’s operation and find out
where it’s failing.</p>

    <p>Once the <a href="https://en.wikipedia.org/wiki/C_file_input/output">stdio library</a>
works (in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>),
but still fails in hardware, the next step would be
to add serial port accesses to your design that bypass the
<a href="https://en.wikipedia.org/wiki/C_file_input/output">stdio</a>
see where the design is failing.  I have a <a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/txfns.h">special set of functions, I
call them
<code class="language-plaintext highlighter-rouge">txfns</code></a>, that
I use for this purpose.  They’re designed to be as light and as simple
as possible, while writing outputs to the serial port.  Using them, I can
output strings and hexadecimal numbers directly to the serial port.  That’s
usually enough to debug the <a href="https://en.wikipedia.org/wiki/C_file_input/output">stdio
library</a>.  You can think
of these functions as hardware replacements to <code class="language-plaintext highlighter-rouge">NSTR</code> and <code class="language-plaintext highlighter-rouge">NDUMP</code>, since
that’s how I typically use them.</p>

    <p>You could also use
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">BREAK instructions</a>
here.  Again, the goal is to both figure out where the software is going
as it works its way through <a href="https://en.wikipedia.org/wiki/C_file_input/output">the
library</a>,
as well as to dump enough values at any particular point along
the way so that you can “see” what’s going on.</p>
  </li>
</ol>

<table align="center" style="float: right"><tr><td><img src="/img/no-boot/stupid-murphy.svg" alt="" width="420" /></td></tr></table>

<ol start="9">
  <li>
    <p>Once you get to the console output, things get easier</p>

    <p>Debug by printf is a thing.  It may not be ideal, but it does work.
When compared to debugging a blank cursor, debug by printf() will feel like
cooking with gas.</p>

    <p>The task of this article, however, has been to illustrate how to
this far in the first place.</p>
  </li>
</ol>

<h2 id="crt0-example">CRT0 Example</h2>

<p>Just for understanding, let’s walk through this process by examining how
the <a href="/about/zipcpu.html">ZipCPU</a> would go about running
<a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">Hello World</a>.
We’ll look at this from
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
<a href="/blog/2017/07/31/vcd.html">traces</a>, all drawn from the
<a href="https://github.com/ZipCPU/zbasic/tree/dev">ZBasic</a>
(<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a> only)
distribution, and I’ll show you some valuable things you can notice from these
<a href="/blog/2017/07/31/vcd.html">traces</a> alone.</p>

<p>Our first <a href="/blog/2017/07/31/vcd.html">trace</a> shows an
overview of what <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">Hello
World</a>
would look like from a <a href="http://gtkwave.sourceforge.net">GTKWave</a>
<a href="/blog/2017/07/31/vcd.html">trace</a>
standpoint.  It shows the CPU from after reset, through loading <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">Hello
World</a>, running
<a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">Hello World</a>,
and then cleaning up and closing the
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
In this case, “cleanup” is another way of saying, “waiting for the serial
port to finish its writes.”</p>

<table align="center" style="float: none"><caption>Fig 2. An overview of running Hello World on the ZipCPU</caption><tr><td><img src="/img/no-boot/overview-annotated.png" alt="" width="780" /></td></tr></table>

<p>Let me walk you quickly through the
<a href="/blog/2017/07/31/vcd.html">traces</a> shown in Fig. 2.</p>

<p>The first two <a href="/blog/2017/07/31/vcd.html">traces</a>
are either the <a href="/formal/2019/02/21/txuart.html">serial
port</a>’s input or its
output.  As you may <a href="/formal/2019/02/21/txuart.html">recall, serial
port</a>s idle high, so here
you can see that the outgoing serial port wire is idle for most of the
<a href="/blog/2017/07/31/vcd.html">trace</a>, until it finally sends
the “<a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">Hello, World!</a>”
output out.</p>

<p>In the particular configuration shown here, the
<a href="/about/zipcpu.html">ZipCPU</a> has been configured to drive the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a> from
either its instruction or its data cache.  An arbiter has already selected
one of these two, but you may watch it change from one to the other in
<a href="/blog/2017/07/31/vcd.html">traces</a> to follow.
AutoFPGA has labeled the <a href="/about/zipcpu.html">ZipCPU</a>’s bus
signals with a <code class="language-plaintext highlighter-rouge">bus_component_*</code> prefix, in this case <code class="language-plaintext highlighter-rouge">wb_zip_</code>. As you
might expect, the first access, following reset, is to read the first
instruction.  This is where our figure starts.  This access has been held up,
however, until the <a href="/blog/2019/03/27/qflexpress.html">Quad SPI flash
controller</a>
finishes configuring the external flash device (model) for eXecute in
Place (XiP) Quad SPI mode.</p>

<p>The “ipc” <a href="/blog/2017/07/31/vcd.html">trace</a> shows the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="https://en.wikipedia.org/wiki/Program_counter">Program Counter (PC)</a>,
or more specifically the
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">supervisor</a>’s
<a href="https://en.wikipedia.org/wiki/Program_counter">PC</a> within the
<a href="/about/zipcpu.html">ZipCPU</a>.  (Another register, <code class="language-plaintext highlighter-rouge">upc</code>,
captures the <a href="/zipcpu/2018/01/01/zipcpu-isa.html">user</a>
<a href="https://en.wikipedia.org/wiki/Program_counter">PC</a>.)
I’ve also added the <code class="language-plaintext highlighter-rouge">ipc</code> register to this display twice.  The first
<a href="/blog/2017/07/31/vcd.html">trace</a>
shows it in its default hexadecimal display setting.  A quick glance will
illustrate this trace is generally unreadable unless you zoom in so far you
lose all of the surrounding context.  The second <code class="language-plaintext highlighter-rouge">ipc</code> trace is set to analog
mode.  Here you can see very distinctly where the CPU jumps from flash memory
to the block RAM used by the <a href="https://github.com/ZipCPU/zbasic/tree/dev">ZBasic
distro</a> for most of its operation.
This is the indication that the <a href="/about/zipcpu.html">ZipCPU</a>
has just began running
<a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c"><code class="language-plaintext highlighter-rouge">main()</code></a>.
(If you look closely, you’ll also see where
<a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c"><code class="language-plaintext highlighter-rouge">main()</code></a>
completes and returns control to <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a>.</p>

<p>The final <a href="/blog/2017/07/31/vcd.html">trace</a> is that of the
<a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a>.  Since the
<a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a>
is just a generic <a href="/about/zipcpu.html">ZipCPU</a> <a href="/zipcpu/2018/01/01/zipcpu-isa.html">register, and
specifically register 13</a>,
that’s why it’s listed as <code class="language-plaintext highlighter-rouge">regset[13][31:0]</code> on the trace.  The big thing to
notice here is where the <a href="https://en.wikipedia.org/wiki/Stack_register">stack
pointer</a> first changes.  This is
your indication that the CPU has <a href="https://github.com/ZipCPU/zbasic/blob/dev/sw/zlib/crt0.c#L168">started running
<code class="language-plaintext highlighter-rouge">CRT0</code></a>.</p>

<p>To see more, however, we’ll need to zoom in a bit.</p>

<p>Let’s start by zooming into the first section of the
<a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a> area.
In this case, we’ll zoom in a lot.</p>

<table align="center" style="float: none"><caption>Fig 3. CRT0 first copies instructions from flash to RAM</caption><tr><td><img src="/img/no-boot/crt0insn-annotated.png" alt="" width="780" /></td></tr></table>

<p>The first thing you’ll notice is that the <code class="language-plaintext highlighter-rouge">ipc</code> register shows clear looping.
This is to be expected of a memory copy loop.  It is a loop, after all.</p>

<p>The next thing you’ll notice is that this loop takes place in sections
followed by pauses.  This is caused by the data cache.  Every pause you see
is a cache miss, where the data cache reads another cache line from the
<a href="/blog/2019/03/27/qflexpress.html">flash</a>.
The <a href="/about/zipcpu.html">ZipCPU</a> then writes the cache
line to RAM.  Since the <a href="/about/zipcpu.html">ZipCPU</a>’s
data cache implementations are all <em>write-through</em> caches, writes to memory
also go immediately to the bus.  These are the busy portions of the loop.</p>

<p>Finally, you’ll notice that the
<a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a>
is constant throughout this whole section.  That’s an indication that it’s
all taking place within a single function.</p>

<p>The second big section of this <a href="https://en.wikipedia.org/wiki/Crt0">CRT0</a>
operation where where the <a href="https://en.wikipedia.org/wiki/.bss">BSS segment</a>
is cleared to zero.  You can see this in Fig. 4 below.</p>

<table align="center" style="float: none"><caption>Fig 4. CRT0 next clears uninitialized global (BSS) memory</caption><tr><td><img src="/img/no-boot/bss-annotated.png" alt="" width="780" /></td></tr></table>

<p>In this case, I’ve zoomed in around the transition from the instruction copy
to where the <a href="/about/zipcpu.html">ZipCPU</a> starts zeroing
the <a href="https://en.wikipedia.org/wiki/.bss">BSS segment</a>.  The first thing I’d
like you to notice is how easy this transition is to see from the 
<a href="https://en.wikipedia.org/wiki/Program_counter">ipc</a> trace.  Indeed, the
<a href="/blog/2017/07/31/vcd.html">trace</a> suddenly changes shape.
Sure, the rest of the <a href="/blog/2017/07/31/vcd.html">trace</a>
changes shape as well, but if we zoomed out any more you might miss this and
only see the <a href="https://en.wikipedia.org/wiki/Program_counter">ipc</a> change.</p>

<p>As with the last section, the shape of this section is primarily driven by
the data cache.  This <a href="https://en.wikipedia.org/wiki/.bss">BSS</a>
<a href="https://cplusplus.com/reference/cstring/memset/">memset()</a>
loop just writes to one value of memory after another, with each value
passing straight through the cache to memory.</p>

<p>What you may not notice is that there haven’t been any requests of the
bus for instructions.  If you look closer, however, you’ll see that’s not
quite true.  Just before the
<a href="https://cplusplus.com/reference/cstring/memset/">memset()</a>
loop, there’s a cache request–this
time from the <em>instruction</em> cache, to get the next eight instructions.  These
are sufficient to then run the
<a href="https://cplusplus.com/reference/cstring/memset/">memset()</a>
function from cache alone.  Hence,
there are no more instruction requests of the bus until this loop exits.</p>

<p>Just to show one final example of looping in
<a href="/blog/2017/07/31/vcd.html">traces</a>,
Fig. 5 below shows the activity on the bus associated with the serial port
while the design finally sends
“<a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">Hello, World!</a>”
to the console.</p>

<table align="center" style="float: none"><caption>Fig 5. Sending Hello World to the console</caption><tr><td><img src="/img/no-boot/console-annotated.png" alt="" width="780" /></td></tr></table>

<p>Now, if you look at the bus ports for the console, shown with the prefix
<code class="language-plaintext highlighter-rouge">wb_uart_</code>, you’ll see a repeating pattern of two requests.  The first is
a read request, to verify that there’s room in the
<a href="https://github.com/ZipCPU/wbuart32">serial port</a>’s buffer
for another byte of data.  The second is a write request, sending the next
byte to the buffer.</p>

<p>The big thing to learn here, if nothing else, is the utility of displaying
the <a href="https://en.wikipedia.org/wiki/Program_counter">PC</a> as an analog signal.</p>

<h2 id="debugging-a-memory-value">Debugging a memory value</h2>

<p>One common problem I’ve run into is where you get deep into the standard
library (i.e. into someone else’s software), and you see the CPU read some
value from memory and then do the wrong thing.  Or, rather, it does the right
thing but with the wrong value.  That leads to the question, why was that
value wrong?  When did it become wrong?  These are both things you may
need to answer.</p>

<p>I discussed how to find a bug like this in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
in a previous post.</p>

<p>What if you need to find this value while running from hardware?</p>

<p>Ouch.  That’s harder.  Still, the same approach applies: pick the address of
interest, and track its value.</p>

<p>In hardware, this often means that you’ll need to create a bus monitor
peripheral.  That monitor peripheral will then look to find <em>every</em> time you
write to a given address, and keep track of what the value at that address
becomes when you write to it.  Beware, inserting such a peripheral into your
design might change your address map, so you might need to do a bit of
rework, but the basic idea applies.</p>

<p>If your monitor detects a “wrong value” being written to the address of
interest, then it should be able to halt the CPU–so you can see what just
happened.  Or, perhaps, you might wish to simply <a href="/blog/2017/06/08/simple-scope.html">trigger a
trace</a>
of the CPU to see what’s going on there.</p>

<p>If, on the other hand, you never write a “wrong value” to the address of
interest, and yet still read a “wrong” value–then you know where to look: the
memory controller for the memory you are writing to.  You may need to
initiate reads of this address at various other times–at least enough to
narrow down and find when the value is changing.  Is it changing via a bus
write to some other address?  That would be important to know.  Is it not
changing when it’s being written to?  That would also be important.  Finding
out when, and the circumstances around it will be key to figuring this out.</p>

<p>Your eventual goal here will be to encapsulate the basic
<a href="/blog/2017/06/08/simple-scope.html">bug-triggering sequence</a>
so that you can <a href="/blog/2017/06/08/simple-scope.html">trigger</a>
it in a much simplified setting–either with
the <a href="/2017/06/05/wb-bridge-overview.html">debugging bus</a>
and not the CPU, or perhaps in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
From there, you should (hopefully) be able to get a
<a href="/blog/2017/07/31/vcd.html">trace</a>
in order to narrow it down further.</p>

<h2 id="conclusions">Conclusions</h2>

<p>The big challenge with all of the above tasks is that you are likely going to
be debugging someone else’s work: either their design or their software
library.  In my case, it’s my CPU but Xilins’x MIG controller is not my
RTL, neither are <a href="https://sourceware.org/newlib/">newlib</a> nor
<a href="http://elm-chan.org/fsw/ff/00index_e.html">FATFS</a> my software.  Sure,
it’s <a href="/about/zipcpu.html">my CPU</a>, but I didn’t
design any of the other components on the circuit board, nor have I designed
the external memory.  If I want all of these components to work together in
my project and for my purpose, then I need to know how to handle debugging
them.  This will often mean tracing through someone else’s software just
to find the bugs in my own stuff.</p>

<p>What about <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>?</p>

<p>No, I haven’t gone back to the
<a href="https://en.wikipedia.org/wiki/Linux">Linux</a>
operating system I tried to boot on the
<a href="https://beagleboard.org/black">Beagle Bone</a>.  I’ve just had too many other
paying opportunities to do something else, and I’ve now lost touch with the
potential customer who may have wanted that system.</p>

<p>Still, if I needed to debug <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>,
I think I’d use this same approach.  The
<a href="https://en.wikipedia.org/wiki/Linux">Linux</a>
kernel contains within it several simplified console output functions
that can be used for debugging the kernel prior to the entire operating system
being up and running.  While I haven’t tried using these personally (yet), I’ve
seen others do it to great success.  Similarly, my
<a href="https://beagleboard.org/black">Beagle Bone</a>
has a JTAG port that I could use instead of the <a href="/2017/06/05/wb-bridge-overview.html">debug
bus</a>.  It’s not a
one to one replacement, but my bet is that it will still be good enough.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>In the beginning was the Word, and the Word was with God, and the Word was God. (John 1:1)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
