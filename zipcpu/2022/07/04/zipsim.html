<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ZipCPU Lesson: If it's not tested, it doesn't work.</title>
  <meta name="description" content="The ZipCPU has had a problem.It’s kind of fundamental to digital design, so let’s chat about it.">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2022/07/04/zipsim.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">ZipCPU Lesson: If it's not tested, it doesn't work.</h1>
    <p class="post-meta"><time datetime="2022-07-04T00:00:00-04:00" itemprop="datePublished">Jul 4, 2022</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>The <a href="/about/zipcpu.html">ZipCPU</a> <del>has</del> <em>had</em> a problem.
It’s kind of fundamental to digital design, so let’s chat about it.</p>

<table align="center" style="float: right"><caption>Fig. 1, The "No testy--no worky" principle</caption><tr><td><img src="/img/zipsim/no-testy-no-worky.svg" alt="" width="420" /></td></tr></table>

<p>It begins with the goal of the <a href="/about/zipcpu.html">ZipCPU</a>.
The <a href="/about/zipcpu.html">ZipCPU</a> is designed to be low logic,
and that’s where the problem begins.  The problem is simply that low logic
means different things to different people.  Low logic means one thing on an
iCE40 with only 8k 4-LUTs.  Low logic means something else on a Spartan 6, and
something else entirely on a 20k 6-LUT Artix-7.  It means one thing when
driving a <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone
bus</a>, and another thing
when <a href="/zipcpu/2021/04/17/axilops.html">driving an AXI
bus</a>.</p>

<p>The natural consequence of trying to support multiple design requirements and
different targets is that the CPU is highly parameterized.  In general, this
is a good thing.</p>

<p>We’ve discussed how to handle <a href="/zipcpu/2018/12/20/sby-makefile.html">formally verifying parameterized
designs</a>.
That’s not all that hard to do, although <a href="/zipcpu/2018/12/20/sby-makefile.html">the
article</a> needs a bit
of updating.  Specifically, <code class="language-plaintext highlighter-rouge">chparam</code> in Yosys should only be used as an
argument to a <code class="language-plaintext highlighter-rouge">hierarchy</code> command, but that aside handling multiple parameters
is still quite easy to accomplish formally.</p>

<p>My problem is that my formal proofs don’t quite capture <em>everything</em>.
Yes, those things they do capture they do so exhaustively, but I still keep
finding a bug every now and again at integration time when two things don’t
work together like they should.</p>

<p>Frankly, I need a simulation solution that can test the
<a href="/about/zipcpu.html">ZipCPU</a> in each and every one of its
many potential configurations.  That’s what I’d like to discuss today.</p>

<h2 id="first-approach-the-zbasic-system">First approach: The ZBasic System</h2>

<p>My previous approach at testing the
<a href="/about/zipcpu.html">ZipCPU</a> was the separate
<a href="/zipcpu/2018/02/12/zbasic-intro.html">ZBasic</a> repository.
This is simply a demonstration system connecting the
<a href="/about/zipcpu.html">ZipCPU</a> to a variety of other
components.  Most notable among these other components are the <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">block RAM
memory</a>, the <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuart/wbuart.v">serial
port</a>, and the
<a href="/blog/2017/06/05/wb-bridge-overview.html">debugging bus</a>.
Other less notable components include the <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/sdspi/sdspi.v">SPI based SD card protocol
controller</a> and
the <a href="/zipcpu/2019/02/09/cpu-blinky.html">GPIO controller</a>.</p>

<p>That makes the <a href="/zipcpu/2018/02/12/zbasic-intro.html">ZBasic</a>
system into a pretty complete great demonstration system–for simulating a
single configuration.</p>

<ul>
  <li>
    <p>It offers as much <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">block
RAM</a>
as your simulation environment will allow</p>
  </li>
  <li>
    <p>The <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/wbuart/wbuart.v">serial
port</a>
has both transmit and receive functionalities, so you can interact with
the CPU.</p>
  </li>
  <li>
    <p>When using <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>,
the <a href="/blog/2020/04/01/design-flow.html">SD card can be treated as a full SD card of whatever
size is necessary</a></p>
  </li>
</ul>

<p>This is all great, but it’s hardly ideal for testing the <em>CPU</em>–even though
that’s what I’ve used it for.</p>

<p>To that end, I built several CPU tests that I have kept in the
<a href="https://github.com/ZipCPU/zbasic">ZBasic repository</a> to help me know if the
CPU is working.</p>

<ul>
  <li>
    <p><a href="http://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c">There’s the standard CPU
test</a>, which
is designed to check the performance of (almost) every instruction in
isolation.</p>
  </li>
  <li>
    <p>There’s a <a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c">Hello World
test</a>, which
I’ve included in order to flesh out any obvious problems with the C-Library.</p>
  </li>
  <li>
    <p>There’s another <a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/hellostep.c">Hello World
test</a>
that works by stepping through the <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">classic Hello World
program</a> one
instruction at a time: a supervisor mode task sets up the program in user
mode, and then steps through it.</p>
  </li>
  <li>
    <p>Finally, there’s a <a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/lockcheck.c"><code class="language-plaintext highlighter-rouge">LOCK</code> instruction checking
program</a>.
This one generates three (or four) concurrent tasks all attempting to get
access to the same MUTEX and then verify that they have said MUTEX.</p>
  </li>
</ul>

<p>These programs are what actually tests the CPU–which was the original purpose
of the <a href="https://github.com/ZipCPU/zbasic">ZBasic repository</a>.</p>

<p>The most obvious problem I’ve alluded to so far is that this repository only
tests a single configuration.  That configuration tends to be a full pipeline,
cache enabled, Wishbone design.  The next big problem is that the test is
dependent on many other (non-CPU) components for success.</p>

<p>The result of all of this is that I’ve often published changes to the
<a href="/about/zipcpu.html">ZipCPU</a> repository that … broke one
part or another of the CPU and then never realized it.</p>

<p>Frankly, I needed a better testing environment.</p>

<h2 id="envisioning-a-better-simulation-test">Envisioning a better simulation test</h2>

<p>When thinking over what I needed, I decided upon three goals for a new
simulation environment.  Obviously, it needed to test multiple configurations.
That was my first goal.  But that also lead to my second goal, which was that
I wanted my simulation environment to test both the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
and <a href="/zipcpu/2021/04/17/axilops.html">AXI front ends</a>.
Finally, I also wanted this new simulation environment to be all Verilog.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig. 2, Supported base ZipCPU configuration groups</caption><tr><td><img src="/img/zipsim/zip-configs.svg" alt="" width="420" /></td></tr></table>

<p>The first step was to identify a series of “supported” configurations.
I chose to define 22 such configurations, of which I’m (currently) only testing
the 14 I’ve ever used in practice.  The 22 configurations fall into six basic
groups:</p>

<ul>
  <li>
    <p><strong>ASM</strong>: The Assembly only configuration is the lowest logic configuration of
the <a href="/about/zipcpu.html">ZipCPU</a>.  It doesn’t have full
instruction support, neither does it support user mode.  Missing instructions
include shifts by more than one bit, multiplies, and divides.  Worse,
without user mode, there’s no way to trap on one of these instructions being
illegal.  As a result, you can’t really use this configuration with GCC.
GCC will often attempt to implement one (or more) of these instructions, and
without the ability to trap on them there’s no real way to rescue a program
so generated for this configuration.</p>

    <p>While this configuration is defined, there are no tests assigned to it.
Yet.  (Technically, that makes this configuration unusable.  Remember,
if it’s not tested then it doesn’t really work.)</p>

    <p>What I really like about this configuration is that this represents the
lowest logic configuration of the
<a href="/about/zipcpu.html">ZipCPU</a>: requiring only 584 Xilinx
7-Series 6-LUTs.</p>
  </li>
  <li>
    <p><strong>TRAP</strong>: This configuration now supports shifts, user mode, and the lock
instruction.  Since it supports user mode, it also supports traps, and so
the CPU can now support the divide and multiply instructions from user
mode–assuming I ever build the trap software to handle such instructions
properly.</p>

    <p>Without the software to support this TRAP configuration, or for that matter
without a GCC flag implemented to replace divide and multiply instructions
with soft equivalents, there are no tests of this configuration yet.</p>
  </li>
  <li>
    <p><strong>MIN</strong>: This is the minimum CPU configuration supported by a generic ZipCPU
backend for GCC.  It includes support for multiplies, divides, shifts, lock
instructions, user mode, and the compressed instruction set.  This
configuration uses the most basic instruction fetch and memory controllers.
This also the only configuration where the
<a href="/about/zipcpu.html">ZipCPU</a> is not running its
full pipeline.  Finally, this configuration is the first of several that
allows the CPU to be externally configured: the CPU may be reset, halted, or
stepped externally and registers within the CPU may be now read and written
externally,</p>

    <p>This is the minimum configuration that I can currently test automatically.</p>
  </li>
  <li>
    <p><strong>PIPE</strong>: This is the minimum pipelined configuration.  Yes, the
<a href="/about/zipcpu.html">ZipCPU</a> is
pipelined by design, but that can require too much logic for some hardware
to handle.  Therefore, the <a href="/about/zipcpu.html">ZipCPU</a>
supports both pipelined and non-pipelined configurations.  This configuration
is the first of the pipelined configurations.  It also uses (naturally) the
piped fetch and memory controllers–allowing multiple bus requests to be
outstanding at any given time.  As an extra bonus with pipelining, this is
the first configuration supporting early branching.</p>

    <p>In this case, early branching is defined by any branch recognized by the
instruction decoder, which can be forwarded to the instruction fetch
prior to the associated instruction making its way through the rest of the
<a href="/about/zipcpu.html">ZipCPU</a>’s pipeline.</p>
  </li>
  <li>
    <p><strong>CACHE</strong>: Here’s where we get to a more traditional CPU configuration.  In
this configuration, both instructions and data are kept in a (nominally 4kB)
cache.  Because this configuration is cached, this is also the first one that
has a chance of keeping the CPU’s pipeline fully loaded.</p>
  </li>
  <li>
    <p><strong>Low Power</strong>: The final configuration has been optimized for low power.  This
configuration is the same as the CACHE configuration above, save for two
changes.  First, unused signals have been zero’d out to prevent any
unnecessary toggling.  Since this costs extra logic to do, it’s not the
primary or default configuration by any means.  Second, this configuration
enables the <a href="/blog/2021/10/26/clkgate.html">clock gating feature that we’ve discussed
before</a>.  As a result,
whenever the <a href="/about/zipcpu.html">ZipCPU</a> is sleeping
(i.e. waiting for an interrupt), the CPU’s clock will be turned off when
using this configuration.</p>

    <p>No, it’s not likely I’ll be able to use this in any FPGA projects, but I
do use it from time to time on simulation projects and so it’s
nice to know it can be done.</p>
  </li>
</ul>

<p>That’s six basic configurations, of which I have tests defined for only
four at present.</p>

<table align="center" style="float: right"><caption>Fig. 3, All 22 ZipCPU test configurations</caption><tr><td><img src="/img/zipsim/all-configs.svg" alt="" width="480" /></td></tr></table>

<p>Then, for each of these four configurations, I want to
test the <a href="/about/zipcpu.html">ZipCPU</a> in one of four
environments:
using a basic Wishbone wrapper I call the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipbones.v">ZipBones</a>,
a second Wishbone wrapper with an attached peripheral set
(<a href="/zipcpu/2018/04/17/ziptimer.html">timers</a>,
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt controller</a>s,
some performance counters, a
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/peripherals/wbdmac.v">DMA</a>,
etc.)
called the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipsystem.v">ZipSystem</a>,
an <a href="/blog/2021/08/14/axiperf.html">AXI-Lite</a>
wrapper called
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipaxil.v">ZipAXIL</a>,
or finally a <a href="/blog/2021/08/14/axiperf.html">Full AXI
wrapper</a> I call
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipaxi.v">ZipAXI</a>.
You can see these configurations enumerated in Fig. 3.  It’s not quite 24 total
configurations, simply because it hasn’t (yet) made any sense to build an
AXI-Lite cache.  Therefore, the cache and low–power configurations only test
the <a href="https://github.com/ZipCPU/zipcpu/blob//2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipaxi.v"><em>AXI</em> wrapper to the
ZipCPU</a>,
not the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipaxil.v">AXI-Lite
wrapper</a>.</p>

<p>This sort of comes with a rather derived requirement: I’ll need a simulation
environment that can be uniform enough to support all (or most) of these
configurations.  This is just to minimize the amount of rework necessary
to go from a test of one configuration to another.  However, since the
AXI environment is so different from the Wishbone one, I eventually settled
on two top level simulation drivers: <a href="https://github.com/ZipCPU/zipcpu/blob//2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/axi_tb.v">one for
AXI</a>,
and <a href="https://github.com/ZipCPU/zipcpu/blob//2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/wb_tb.v">one for
Wishbone</a>.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig. 4, All Verilog test bench</caption><tr><td><img src="/img/zipsim/all-verilog.svg" alt="" width="420" /></td></tr></table>

<p>My last requirement was that this simulation environment be all Verilog.
This is sort of a new requirement to me, since <a href="/blog/2020/04/01/design-flow.html">I normally use Verilator for
my simulations</a>.
Five reasons drive this requirement:</p>

<ul>
  <li>
    <p>Sometime back, <a href="/zipcpu/2021/07/23/cpusim.html">I needed to build a simulation with a CPU for a bus
driver</a> and the
<a href="/about/zipcpu.html">ZipCPU</a> fit that role nicely</p>

    <p>Some of my recent <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>
projects have required driving a bus from Verilog.
While an all Verilog model of an ARM might have worked here, the
<a href="/about/zipcpu.html">ZipCPU</a>
fits this role nicely in its absence.</p>
  </li>
  <li>
    <p>X propagation.</p>

    <p>I’ve now been burned, more than once, by a model that works just fine in
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
that then failed to work in a simulator that supports ‘X propagation.  This
has bit me in two ways:</p>

    <ol>
      <li>
        <p><a href="/blog/2020/08/22/oddr.html">My ODDR design</a> failed
miserably here.  Where I struggled was with a design that just needed to
create a register that simply toggles within it.  That register didn’t
need to be reset, it just needed to toggle with every clock.  However, if
you include this design in an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>
environment, where initial statements
aren’t allowed, then you either need to add a reset or the ‘X propagation
will kill you–even if the design would’ve worked.</p>

        <p>My first “solution” to this problem was to replace things like <code class="language-plaintext highlighter-rouge">==</code> with
<code class="language-plaintext highlighter-rouge">===</code> and so forth.  That worked great until the post place and route
simulation.  So … I bit the bullet and added a reset to that design.
(Who cares, right?  It’s an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>!  Logic is
cheap in <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>s.)</p>
      </li>
      <li>
        <p>I’ve often found myself using <code class="language-plaintext highlighter-rouge">always @(*)</code> blocks to set something to a
constant.  This works great when using either
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
or synthesis tools, because you get the value you want.  Unfortunately,
this is not Verilog language compliant.  With a true Verilog compliant
simulator, any registers set within such a block will be set to ‘X
(undefined) since nothing ever triggers such an always block.</p>
      </li>
    </ol>

    <p>Frankly, if I want to deliver “working” IP to any customers, then that IP
really needs to work on their simulator as well.</p>
  </li>
  <li>
    <p>External device models require assignment delays, and often encrypted IP.</p>

    <p>I’ve also recently needed to run simulations against external device models
that include assignment delays within them, and I’ve wanted to drive
these simulations with the <a href="/about/zipcpu.html">ZipCPU</a>.</p>

    <p>Sometimes these models are of my own creation.  In this case, <a href="http://iverilog.icarus.com">Icarus
Verilog</a>
has handled the problem quite nicely.  At other times, these simulations
are proprietary, encrypted, models provided by various device vendors.  This
necessitates being able to use proprietary simulation tools.</p>

    <p>So far I’ve tried three proprietary tools:</p>
    <ol>
      <li>NC Verilog (which doesn’t like my use of <code class="language-plaintext highlighter-rouge">localparam</code>s)</li>
      <li>XCellium, which can currently (for me) handle all but Xilinx’s
proprietary IP.  (I must be missing something–Xilinx says it is
supported …)</li>
      <li>Xilinx’s Vivado, which SegFaulted on the first project I tried it on.
Since then, I’ve now gotten it to the point where I can run batch
simulations on it–just like with XCellium–so both simulators are quite
usable for me.</li>
    </ol>
  </li>
  <li>
    <p><a href="https://github.com/YosysHQ/mcy">MCY, or Mutation Coverage with Yosys</a>,
works nicely with an all Verilog simulation model to start from.</p>

    <p>In case you are not familiar with <a href="https://github.com/YosysHQ/mcy">MCY</a>,
<a href="https://github.com/YosysHQ/mcy">MCY</a> is a means of testing the test
bench.  Want to know what bugs your test bench will catch?  Mutate the design
(i.e. break it), and see if the test bench can find the mutation.  A good
test bench should be able to find any mutation, or at least a high percentage
of them.</p>

    <p>Sadly, although <a href="https://github.com/YosysHQ/mcy">MCY</a> can be used with
formal methods, it doesn’t integrate well with them.  (i.e., you need to be
careful that you don’t mutate any formal properties.)  This has really slowed
my adoption of <a href="https://github.com/YosysHQ/mcy">MCY</a>.</p>
  </li>
  <li>
    <p>Post place-and-route timing simulations</p>

    <p>Simulating internal timing requires an all RTL model–ideally one that
achieves a high level of coverage.  So, any test script that passes an
<a href="https://github.com/YosysHQ/mcy">MCY</a> check should (ideally) be able to
exercise all of the paths within a design even after place and route.</p>
  </li>
  <li>
    <p>Finally, several of the customers I’ve worked with have asked for all
Verilog test benches.
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a> C++
models were simply unacceptable to them.</p>
  </li>
</ul>

<p>Bottom line is, if I want to work with others in the IP community, then I’ll
need a Verilog–only test bench.</p>

<h2 id="building-the-simulation-environment">Building the simulation environment</h2>

<p>The first step was to build a simulation environment that would meet these
needs.</p>

<p>My first problem was the <a href="/about/zipcpu.html">ZipCPU</a>’s 
configuration.  Prior to defining a common configuration set, the
<a href="/about/zipcpu.html">ZipCPU</a> was completely configured via
an <a href="https://github.com/ZipCPU/zipcpu/blob/43a0cdbbb549d360aa05b606305667d3c24bad7c/rtl/cpudefs.v">external Verilog “header” file that defined a set of macros used to
configure the CPU</a>.
These macros controlled <a href="https://github.com/ZipCPU/zipcpu/blob/43a0cdbbb549d360aa05b606305667d3c24bad7c/rtl/cpudefs.v#209">whether or not the CPU was
pipelined</a>,
which fetch or memory controller was used, <a href="https://github.com/ZipCPU/zipcpu/blob/43a0cdbbb549d360aa05b606305667d3c24bad7c/rtl/cpudefs.v#64-78">which multiply
implementation</a>
was used, which portions of the instruction set were implemented and more.</p>

<p>My problem with this external configuration file was that it was hard to
automatically override the definitions within it.  The easy way to override
things is with parameters (Generics, when using VHDL).  So my first step was
to <a href="https://github.com/ZipCPU/zipcpu/tree/2ffbf68b450948dee56f36bbd113e80866a9362a">rewrite the ZipCPU</a>
to get rid of any and all “ifdef”s and to replace them with configuration
parameters.</p>

<table align="center" style="float: right"><caption>Fig. 5, Minimum CPU Testbench Requirements</caption><tr><td><img src="/img/zipsim/min-cpu.svg" alt="" width="360" /></td></tr></table>

<p>I then needed a top level simulation environment.  A minimum CPU needs
memory and a console.  My <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/zipsw/cputest.c">favorite CPU test
program</a>
also requires a <a href="/zipcpu/2018/04/17/ziptimer.html">timer</a>,
and my <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/zipsw/cputest.c">clock gating test software</a>
requires interrupts from an automatically <a href="/zipcpu/2018/04/17/ziptimer.html">reloading
timer</a>.  I also threw a
<a href="/blog/2017/06/08/simple-scope.html">CPU logic analyzer in there for good
measure</a> although I
don’t yet have a test that uses it.</p>

<p>This leads to a test environment looking like Fig. 6.</p>

<table align="center" style="float: none"><caption>Fig. 6, ZipCPU simulation test bench components</caption><tr><td><img src="/img/zipsim/zip_tb.svg" alt="" width="560" /></td></tr></table>

<p>It’s not just a single test environment either.  I built two near–identical
test environments: <a href="https://github.com/ZipCPU/zipcpu/commit/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/axi_tb.v">one for
AXI</a>,
and <a href="https://github.com/ZipCPU/zipcpu/commit/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/wb_tb.v">another for Wishbone</a>.
Further, since I wanted to test the same executable logic in each environment,
I made sure that the address space controlled by each test environment was the
same between both
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/axi_tb.v">AXI</a> and
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/wb_tb.v">Wishbone</a>
test benches.</p>

<p>As a side note, I never would’ve considered a test setup this complex early on
in my own personal development.  A
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> just to test a
CPU?  That’s a project in and of itself!  Or how about the bus resizing
elements, which are required to test the CPU on a non–32bit bus?  All of
these extra parts and pieces were never things that I had considered to be
necessary components of a <em>CPU</em> repository, yet the C library won’t run without
the console, and so the testing the design necessitates having a
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> on hand.
Similarly, either I need to build a bus width agile console port, or
alternatively I just need to suck up the reality of crossing bus widths.</p>

<p>I then ran into a problem when trying to figure out how to support both the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipbones.v">ZipBones</a>
CPU wrapper, the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipsystem.v">ZipSystem</a>
wrapper, as well as the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipaxi.v">ZipAXI</a>
wrapper from a common addressing space.  For background, <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/core/zipcore.v">the
core</a>
<a href="/about/zipcpu.html">ZipCPU</a> is just that: a CPU.  It doesn’t
come with many of the peripherals necessary for most CPU environments.  For
this reason, the <a href="/about/zipcpu.html">ZipCPU</a> initially
came with two wrappers.  (There are now four.)  You could either use the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipbones.v">ZipBones</a>
wrapper or the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipsystem.v">ZipSystem</a>.
The difference between these two is that the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipsystem.v">ZipSystem</a>
contained a locally mapped set of peripherals:
<a href="/zipcpu/2018/04/17/ziptimer.html">timers</a>, counters, one or
two <a href="/zipcpu/2019/04/02/icontrol.html">interrupt controller</a>s,
and a <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/peripherals/wbdmac.v">DMA</a>.  The
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipbones.v">ZipBones</a>
wrapper had none of these, so it might be lighter in logic area.  Then, when I
later built the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipaxil.v">AXI-Lite wrapper</a>
and later the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipaxi.v">AXI (full) wrapper</a>,
I left these near-peripherals out.</p>

<p>How, then, should I guarantee that the
<a href="/about/zipcpu.html">ZipCPU</a>’s software can interact
with these external peripherals regardless of the wrapper used?</p>

<p>The obvious answer is to guarantee within the test bench that each of these
wrappers can see the same set of necessary peripherals–regardless of whether
or not they come pre–packaged within the CPU wrapper or not.  Hence, I included
an <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/peripherals/axilperiphs.v">AXI-Lite CPU peripheral
set</a>
into the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/axi_tb.v">AXI testbench
top</a>, and several
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipsystem.v">ZipSystem</a>
peripherals directly into the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/wb_tb.v">Wishbone top</a> for the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipbones.v">ZipBones</a> system to interact with.
All that remained was to make sure these peripherals all mapped to the same
addresses.</p>

<p>This wasn’t (yet) enough.</p>

<p>One of the recent drivers of this work has been my desire to operate the
<a href="/about/zipcpu.html">ZipCPU</a>
in environments with non–32bit wide buses.  One project I’m working on
requires a 64-bit bus.  A second project, based on <a href="https://www.enclustra.com/en/products/fpga-modules/mercury-kx2/">Enclustra’s Mercury+ KX7
board</a>,
will require a 512-bit bus if I only want to be able to keep up with the
memory bandwidth that board is capable of.
This meant that my simulation test bench environments needed to be
bus–width agnostic as well.  This then turned into
a requirement that my test bench include a bus downsizer,
in addition to requiring one more parameter to define the simulation
environment.  Thankfully, the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/wbdown.v">bus
downsizer</a>
can be included even if the bus doesn’t need downsizing–in that case, it just
becomes a simple
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/wbdown.v#L77-L99">pass-through</a>.</p>

<p>Then, after using these simulation environments for a while, I ended up
retrofitting each of them with a Verilog <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/wb_tb.v#L962-L980">watchdog
timer</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">TB_WATCHDOG_TIMEOUT</span> <span class="o">=</span> <span class="mi">1_000_00</span><span class="p">;</span>	<span class="c1">// 1ms</span>
	<span class="kt">reg</span>	<span class="p">[$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">TB_WATCHDOG_TIMEOUT</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">watchdog_counter</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">watchdog_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="c1">// if (i_reset)</span>
	<span class="c1">//	Resets aren't strictly necessary in</span>
	<span class="c1">//	simulation only environments ...</span>
	<span class="c1">//</span>
	<span class="c1">//	watchdog_counter &lt;= 0;</span>
	<span class="c1">// else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cpu_stall</span><span class="p">)</span>
		<span class="c1">// Clear the watchdog if the CPU ever makes a</span>
		<span class="c1">// (successful) bus request</span>
		<span class="n">watchdog_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">watchdog_counter</span> <span class="o">&lt;=</span> <span class="n">watchdog_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">watchdog_counter</span> <span class="o">&gt;</span> <span class="n">TB_WATCHDOG_TIMEOUT</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="p">$</span><span class="nb">display</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">ERROR: Watchdog timeout!"</span><span class="p">);</span>
		<span class="p">$</span><span class="nb">finish</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>This timer will count the number of clock cycles it’s been since the CPU has
attempted to access the bus.  It’s sort of a proxy for whether or not the
CPU has ever locked up.  (Hint: This means the CPU <em>was</em> locking up.  In
this case, the lock-up was caused by the clock gating logic found in the
Wishbone drivers.)  The way it works is, if the CPU’s bus inputs ever become
idle for some parameterized number of clock cycles, <code class="language-plaintext highlighter-rouge">TB_WATCHDOG_TIMEOUT</code>,
then the simulation halts with an ERROR.  This helped to keep failing
simulations from hanging the entire simulation setup.  (We’ll get to the
setup in the next section.)</p>

<p>The final critical component of the simulation environment was the
<a href="/about/zipcpu.html">ZipCPU</a> software executable itself.  By
parameterizing the simulation software load using the name of the
<a href="/about/zipcpu.html">ZipCPU</a> executable,
I now had complete control over what simulations would run and how.</p>

<h2 id="configuring-the-test-cases">Configuring the test cases</h2>

<p>The last critical piece in this setup, prior to the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl">simulation
script</a>,
was the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/sim_testcases.txt">test definition
file</a>.
The <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl">Perl
script</a>
reads the various test configurations from this <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/sim_testcases.txt">test definition
file</a>,
and then commands a run of that test.  All output from the test then gets
logged to a file for later viewing.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig. 7, Defining a simulation</caption><tr><td><img src="/img/zipsim/test-defn.svg" alt="" width="360" /></td></tr></table>

<p>To show how this is done, let’s back up a moment and start with the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/sim_testcases.txt">simulation configuration file</a>.
I chose to define a given simulation run via five space delimited fields.
These are:</p>

<ol>
  <li>
    <p>The name of the test.  This also becomes the name of the executable <a href="http://iverilog.icarus.com">Icarus
Verilog</a> builds, as well as being transformed
into the name of the output log file.  For these reasons, the test name needs
to be unique.</p>
  </li>
  <li>
    <p>The CPU configuration.  Given that there were 15 separate parameters I
wanted to control via the configuration, it helped to have named
configuration rather than writing all of these parameters out on each
configuration line.  The <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl">simulation drive
script</a>
could then easily look up a configuration by name, and set everything.
For example, here’s what the generic <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L64-L78">pipeline
configuration</a>
looks like from Perl:</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">    <span class="k">my</span> <span class="nv">$pipeconfig</span> <span class="o">=</span><span class="p">"</span><span class="s2"> -POPT_PIPELINED=1</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_LGDCACHE=2</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_LGICACHE=2</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_MPY=6</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_DIV=1</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_SHIFTS=1</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_LOCK=1</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_EARLY_BRANCHING=1</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_LOWPOWER=0</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_DISTRIBUTED_REGS=0</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_USERMODE=1</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_CLKGATE=0</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_DBGPORT=1</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_TRACE_PORT=0</span><span class="p">"</span>
        <span class="o">.</span> <span class="p">"</span><span class="s2"> -POPT_CIS=1 </span><span class="p">";</span></code></pre></figure>

<p>This is just the first step in the configuration, though.  This would then
need to be coupled with a top level entity, a simulation file set, and
one more parameter indicating which wrapper was being used: either one of the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipbones.v">ZipBones</a> or
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipsystem.v">ZipSystem</a> wrappers (for
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>),
or the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipaxil.v">ZipAXIL</a> or
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipaxi.v">ZipAXI</a> wrappers.
I’ll get to these details in the next section, though.</p>

<ol start="3">
  <li>
    <p>Now that the design has a named configuration to use, the next step was to
select a test.  For this, the third element in each line was the name of a
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/verilator/mkhex.cpp">executable turned hex file</a>.
This file would then be included into the simulation via
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/memsim.v#L81"><code class="language-plaintext highlighter-rouge">$readmemh()</code></a>
for the <a href="/about/zipcpu.html">ZipCPU</a> to execute.</p>
  </li>
  <li>
    <p>To know, later on, if the test passed successfully, I also kept track of
the output of the CPU’s console.  This is the fourth component of a test
configuration line: the name of a file to write this console output into.</p>

    <p>The reason for this configuration parameter was to help guarantee that all
intermediate and output files had unique names.  This would allow me to run
the script multiple times, for different tests, on multiple different
processors concurrently.</p>

    <p>In hindsight, I could’ve just created a file name from the name of the
test.  Perhaps I might’ve called it <code class="language-plaintext highlighter-rouge">$tstname-out.txt</code> or some such.
Still, this works, so I have no need to change it at present.</p>
  </li>
</ol>

<table align="center" style="float: right"><caption>Fig. 8, Reconfigurability is a test requirement</caption><tr><td><img src="/img/zipsim/reconfigurable.svg" alt="" width="420" /></td></tr></table>

<ol start="3">
  <li>
    <p>The final part of the command line was really key to the success of this
format as a whole.  The final piece is an (optional) white-space separated
list of parameter overrides.  Frankly, if I ever do this again, this will
be a guaranteed part of any future approach.</p>

    <p>Why?  Because it keeps me from modifying the files under test just to test
a new configuration.</p>

    <p>Why?  Because in one customer project, I created an <a href="http://iverilog.icarus.com">Icarus
Verilog</a> script file for each test, and I then
kept needing to change one (or more) of those files to turn on (or off)
<a href="/blog/2017/07/31/vcd.html">VCD</a>
generation.  (Yes, <a href="/blog/2017/07/31/vcd.html">VCD</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/wb_tb.v#L945-L956">generation in the Verilog test benches is completely
parameterized</a>).
It then became a hassle to recognize whether or not the changes to the
file needed to be committed to the repository or not, since git only ever
flagged that the file was changed.  (It didn’t help that the change was
a single character on a very long <a href="http://iverilog.icarus.com">Icarus</a>
command line.) This way, I can control the current test configuration
separate from the other files under version control, and I can also see
at a glance whether configuration changes were substantial or not.</p>

    <p>How have I used this?  I’ve now used it for more than just turning on and off
<a href="/blog/2017/07/31/vcd.html">VCD</a> (or other trace file)
generation.  I’ve also used it to adjust the default bus width, or to turn on
<a href="/blog/2021/10/26/clkgate.html">clock gating</a>
for configurations that don’t have it enabled by default.  Want to create
an ad-hoc test to check a 512bit bus?  Not a problem!  In another project,
one with fewer configuration parameters, I use this parameter list field to
set all of the key parameters (and macros!)–such as whether an analog PHY
is present, or whether or not Xilinx SERDES I/O elements should be used and
tested.</p>

    <p>Even better, when required, I can use this optional field to implement
Verilog macros as well.  So there are a lot of opportunities here.</p>
  </li>
</ol>

<p>That’s the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/sim_testcases.txt">configuration file</a>.
As you can see, it really captures all of the potential ways the simulation
can be reconfigured to support one test or another.</p>

<h2 id="the-simulation-driver">The simulation driver</h2>

<p>Now let’s turn our attention over to some of the key components of this
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L64-L78">simulation perl script driver</a>.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig. 9, Steps to a scripted simulation</caption><tr><td><img src="/img/zipsim/script-ops.svg" alt="" width="360" /></td></tr></table>

<p>The script starts off by <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L9-L162">defining a massive number of configuration default
values</a>.
I’ll skip <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L9-L162">this section</a>
for brevity, but you are more than welcome to look through it.  These define
both the basic <a href="/about/zipcpu.html">ZipCPU</a> configurations,
such as we listed above, as well as <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L138-L162">which wrapper is to be used for each
configuration</a>.</p>

<p>From there, the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L164-L178">script starts looking over the command line
arguments</a>.  In this
case, we insist on at least one argument <em>or die!</em>.  Sorry, couldn’t help it.
<code class="language-plaintext highlighter-rouge">or die</code> is common Perlese for exiting the script with an error.  Otherwise,
if the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L170-L174">first command line argument is the single word
<code class="language-plaintext highlighter-rouge">all</code></a>,
then we’ll ignore any other arguments and run every test case found in the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/sim_testcases.txt">configuration file</a>.
Finally, if neither case applies, then <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L175-L176">the argument list is interpreted as a
set of test names</a>
that we’ll then <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L450-L471">look
up</a>
in our <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/sim_testcases.txt">test definitions
file</a>.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl"><span class="nv">$all_run</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">eq</span> <span class="p">"")</span> <span class="p">{</span>
	<span class="k">print</span> <span class="p">"</span><span class="s2">No test cases given</span><span class="se">\n</span><span class="p">";</span>
	<span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span> <span class="k">elsif</span> <span class="p">(</span><span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">eq</span> <span class="p">"</span><span class="s2">all</span><span class="p">")</span> <span class="p">{</span>
	<span class="nv">$all_run</span>  <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
	<span class="nb">open</span><span class="p">(</span><span class="nv">SUM</span><span class="p">,"</span><span class="s2">&gt;&gt; </span><span class="si">$report</span><span class="p">");</span>
	<span class="k">print</span><span class="p">(</span><span class="nv">SUM</span> <span class="p">"</span><span class="se">\n</span><span class="s2">Running all tests:</span><span class="se">\n</span><span class="s2">--------------------</span><span class="se">\n\n</span><span class="p">");</span>
	<span class="nb">close</span> <span class="nv">SUM</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="c1">## Run any named tests found in the definitions file</span>
	<span class="nv">@array</span> <span class="o">=</span> <span class="nv">@ARGV</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>We’re going to want to place our results in a directory that isn’t under
version control.  Let’s call this directory <code class="language-plaintext highlighter-rouge">test/</code>, and make sure it exists.
If not, we’ll create it next.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="o">-</span><span class="nv">d</span> <span class="p">"</span><span class="s2">test/</span><span class="p">")</span> <span class="p">{</span>
	<span class="nb">mkdir</span> <span class="p">"</span><span class="s2">test</span><span class="p">";</span>
<span class="p">}</span></code></pre></figure>

<p>The next step is found at the bottom of the file.  Here we either look
up a test configuration by name, via the <code class="language-plaintext highlighter-rouge">gettest()</code> function (<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L450-L471">also
implemented within this perl script</a>, or read
every line from the configuration file.  Every line is then passed to the
<code class="language-plaintext highlighter-rouge">simline()</code> function for both parsing and to run the actual simulation.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl"><span class="k">if</span> <span class="p">(</span><span class="nv">$all_run</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">open</span><span class="p">(</span><span class="nv">TL</span><span class="p">,"</span><span class="si">$simd</span><span class="s2">/sim_testcases.txt</span><span class="p">");</span>
	<span class="k">while</span><span class="p">(</span><span class="nv">$line</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nv">TL</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">next</span> <span class="k">if</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=~</span> <span class="sr">/^\s*#/</span><span class="p">);</span>
		<span class="c1"># print "TEST LINE: $line";</span>
		<span class="nv">simline</span><span class="p">(</span><span class="nv">$line</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nb">open</span><span class="p">(</span><span class="nv">SUM</span><span class="p">,"</span><span class="s2">&gt;&gt; </span><span class="si">$report</span><span class="p">");</span>
	<span class="k">print</span><span class="p">(</span><span class="nv">SUM</span> <span class="p">"</span><span class="s2">----</span><span class="se">\n</span><span class="s2">Test run complete</span><span class="se">\n\n</span><span class="p">");</span>
	<span class="nb">close</span> <span class="nv">SUM</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="k">foreach</span> <span class="nv">$akey</span> <span class="p">(</span><span class="nv">@array</span><span class="p">)</span> <span class="p">{</span>
		<span class="nv">$line</span> <span class="o">=</span> <span class="nv">gettest</span><span class="p">(</span><span class="nv">$akey</span><span class="p">);</span>
		<span class="k">next</span> <span class="k">if</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=~</span> <span class="sr">/FAIL/</span><span class="p">);</span>
		<span class="c1"># print "TEST LINE: $line";</span>
		<span class="nv">simline</span><span class="p">(</span><span class="nv">$line</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Incidentally, it’s this <code class="language-plaintext highlighter-rouge">simline()</code> function where all the work takes
place, so let’s break this function up into pieces and walk through it, since
this is the function that actually runs the simulator for a given test
configuration.</p>

<p>The key to this function is Perl’s pattern matching ability.</p>

<p>We’ll start by removing any end of line comments.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="k">while</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=~</span> <span class="sr">/^(.*)#.*/</span><span class="p">)</span> <span class="p">{</span>
		<span class="nv">$line</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>We’ll then apply a pattern match to the line to separate out the various
components of the line.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="k">if</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=~</span> <span class="sr">/^\s*(\S+)\s*(\S+)\s*(\S+)\s*(\S+)\s(.*)\s*$/</span><span class="p">)</span> <span class="p">{</span>
		<span class="nv">$tstname</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span><span class="p">;</span>
		<span class="nv">$config</span>  <span class="o">=</span> <span class="err">$</span><span class="mi">2</span><span class="p">;</span>
		<span class="nv">$memfil</span>  <span class="o">=</span> <span class="err">$</span><span class="mi">3</span><span class="p">;</span>
		<span class="nv">$confil</span>  <span class="o">=</span> <span class="err">$</span><span class="mi">4</span><span class="p">;</span>
		<span class="nv">$params</span>  <span class="o">=</span> <span class="err">$</span><span class="mi">5</span><span class="p">;</span></code></pre></figure>

<p>The pattern above depends upon the existence of four (or more) white space
delineated fields, as we described them above, where the last field containing
the (optional) parameter list may be left blank.  If this pattern doesn’t
match, then … this isn’t a properly configured test line, and we’ll generate
an error and then skip it.</p>

<p>For now, let’s assume the pattern matches and we’ll continue.</p>

<p>It’s important for me to know <em>when</em> things happen.  This helps me know
how long a test takes, as well as how deep into a test I am at any given
time.  When I’m not producing any console output, this is also the first
indication I have of any (potential) errors.  So, I’ll take this time to
grab a time stamp to describe the beginning of the simulation call.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="p">(</span><span class="nv">$sc</span><span class="p">,</span><span class="nv">$mn</span><span class="p">,</span><span class="nv">$hr</span><span class="p">,</span><span class="nv">$dy</span><span class="p">,</span><span class="nv">$mo</span><span class="p">,</span><span class="nv">$yr</span><span class="p">,</span><span class="nv">$wday</span><span class="p">,</span><span class="nv">$yday</span><span class="p">,</span><span class="nv">$isdst</span><span class="p">)</span><span class="o">=</span><span class="nb">localtime</span><span class="p">(</span><span class="nb">time</span><span class="p">);</span>
	<span class="nv">$yr</span><span class="o">=</span><span class="nv">$yr</span><span class="o">+</span><span class="mi">1900</span><span class="p">;</span> <span class="nv">$mo</span><span class="o">=</span><span class="nv">$mo</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
	<span class="nv">$tstamp</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">("</span><span class="s2">%04d/%02d/%02d %02d:%02d:%02d</span><span class="p">",</span>
				<span class="nv">$yr</span><span class="p">,</span><span class="nv">$mo</span><span class="p">,</span><span class="nv">$dy</span><span class="p">,</span><span class="nv">$hr</span><span class="p">,</span><span class="nv">$mn</span><span class="p">,</span><span class="nv">$sc</span><span class="p">);</span></code></pre></figure>

<p>Incidentally, if you look through this <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl">simulation driver Perl
script</a>, you’ll find
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L214-L279">the script works for</a>
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
as well as <a href="http://iverilog.icarus.com">Icarus</a>–it’s just that
the <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
support <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl#L9">isn’t (currently) configured either by
default</a> or by the command line.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="k">if</span> <span class="p">(</span><span class="nv">$verilator_flag</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">## Configure for Verilator ...</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">## Configure for IVerilog ...</span>
	<span class="p">}</span></code></pre></figure>

<p>Now that we have our configuration test parameters, the next step is to put
the <a href="http://iverilog.icarus.com"><code class="language-plaintext highlighter-rouge">iverilog</code> command line</a> together.</p>

<p>We’ll start with <code class="language-plaintext highlighter-rouge">-g2012</code>.  I personally use the <code class="language-plaintext highlighter-rouge">-g2012</code> option for all my
work.  I need it to support my liberal use of <code class="language-plaintext highlighter-rouge">localparam</code>s, but I’m sure
there are other goodies that come with this as well.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="nv">$cmd</span> <span class="o">=</span> <span class="p">"</span><span class="s2">iverilog -g2012</span><span class="p">";</span></code></pre></figure>

<p>Let’s look up the parameters associated with our named configuration next.
To do this, however, we’ll need to know the top level module name, whether
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/wb_tb.v"><code class="language-plaintext highlighter-rouge">wb_tb</code></a> or
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/rtl/axi_tb.v"><code class="language-plaintext highlighter-rouge">axi_tb</code></a>.
We’re going to need that, so let’s grab that off of the configuration file
string.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="k">if</span> <span class="p">(</span><span class="nv">$cfgfiles</span><span class="p">{</span><span class="nv">$config</span><span class="p">}</span> <span class="o">=~</span> <span class="sr">/-s\s+(\S+)\s/</span><span class="p">)</span> <span class="p">{</span>
		<span class="nv">$toplevel</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">elsif</span> <span class="p">(</span><span class="nv">$cfgfiles</span><span class="p">{</span><span class="nv">$config</span><span class="p">}</span> <span class="o">=~</span> <span class="sr">/-s\s+(\S+)$/</span><span class="p">)</span> <span class="p">{</span>
		<span class="nv">$toplevel</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">## This should probably be an error.</span>
		<span class="nv">$toplevel</span> <span class="o">=</span> <span class="p">"</span><span class="s2">no_tb</span><span class="p">";</span>
	<span class="p">}</span></code></pre></figure>

<p>We can now look up our configuration string.  This is the string with all of
our parameters defined in it.  In my case, I prefixed each parameter with
<code class="language-plaintext highlighter-rouge">-P</code>.  This, however, isn’t sufficient.  Parameters need to be prefixed with
<code class="language-plaintext highlighter-rouge">-P</code> <em>and</em> the name of the top level–so we’ll do a simple substitution here to
get that right.  While we’re at it, we’ll add a shell escape for our quotation
marks–so the shell won’t play with them unduly.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="k">if</span> <span class="p">(</span><span class="nv">$cfghash</span><span class="p">{</span><span class="nv">$config</span><span class="p">}</span> <span class="ow">ne</span> <span class="p">"")</span> <span class="p">{</span>
		<span class="c1">## Must include sim file list and top level</span>
		<span class="c1">## as well as any parameters</span>
		<span class="nv">$cfgstr</span> <span class="o">=</span> <span class="nv">$cfghash</span><span class="p">{</span><span class="nv">$config</span><span class="p">};</span>
		<span class="nv">$cfgstr</span> <span class="o">=~</span> <span class="sr">s/-P/-P$toplevel./g</span><span class="p">;</span>
		<span class="nv">$cfgstr</span> <span class="o">=~</span> <span class="sr">s/\"/\\\"/g</span><span class="p">;</span>
		<span class="nv">$cmd</span> <span class="o">=</span> <span class="nv">$cmd</span> <span class="o">.</span> <span class="p">"</span><span class="s2"> </span><span class="p">"</span> <span class="o">.</span> <span class="nv">$cfgstr</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>Two more parameters come from the test configuration line itself.
These are the name of the memory file, containing the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/zipsw/cputest.c">ZipCPU test
program</a>
memory image, and the name of the console file output.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="nv">$cmd</span> <span class="o">=</span> <span class="nv">$cmd</span> <span class="o">.</span> <span class="p">"</span><span class="s2"> -P</span><span class="si">$toplevel</span><span class="s2">.MEM_FILE=</span><span class="se">\\\"</span><span class="s2">zipsw/</span><span class="si">$memfil</span><span class="se">\\\"</span><span class="p">";</span>
	<span class="nv">$cmd</span> <span class="o">=</span> <span class="nv">$cmd</span> <span class="o">.</span> <span class="p">"</span><span class="s2"> -P</span><span class="si">$toplevel</span><span class="s2">.CONSOLE_FILE=</span><span class="se">\\\"</span><span class="si">$testd</span><span class="s2">/</span><span class="si">$confil</span><span class="se">\\\"</span><span class="p">";</span></code></pre></figure>

<p>With that, it’s now time to look at our parameter list.  This list comes in the
form of a set of <code class="language-plaintext highlighter-rouge">A=B</code> pairs, where the <code class="language-plaintext highlighter-rouge">A</code> is the parameter name and <code class="language-plaintext highlighter-rouge">B</code>
is it’s value.</p>

<p>The first step is to try to match the remaining portion of the line to
both an <code class="language-plaintext highlighter-rouge">A=B</code> pair and an everything else in the line.  I’ve chosen to
name this “everything else” as the <a href="https://en.wikipedia.org/wiki/CAR_and_CDR">CDR after the use of this term in
LISP</a>.  Once the design
has been separated into these three pieces, I can then use the first
two, the <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> of <code class="language-plaintext highlighter-rouge">A=B</code>, to generate a command line parameter
setting.  Since this will follow all other parameter settings on the command
line, this one should override any previous parameters set by the same name.
Don’t forget to escape any string quotations!</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="nv">$cdr</span> <span class="o">=</span> <span class="nv">$params</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="nv">$cdr</span> <span class="o">=~</span> <span class="sr">/\s*(\S+)=(\S+)(.*)$/</span><span class="p">)</span> <span class="p">{</span>
		<span class="nv">$p</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span><span class="p">;</span>
		<span class="nv">$v</span> <span class="o">=</span> <span class="err">$</span><span class="mi">2</span><span class="p">;</span>
		<span class="nv">$cdr</span> <span class="o">=</span> <span class="err">$</span><span class="mi">3</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="nv">$v</span> <span class="o">=~</span> <span class="sr">/\"(.*)\"/</span><span class="p">)</span> <span class="p">{</span>
			<span class="nv">$str</span> <span class="o">=</span> <span class="err">$</span><span class="mi">1</span><span class="p">;</span>
			<span class="nv">$cmd</span> <span class="o">=</span> <span class="nv">$cmd</span> <span class="o">.</span> <span class="p">"</span><span class="s2"> -P</span><span class="si">$toplevel</span><span class="s2">.</span><span class="si">$p</span><span class="s2">=</span><span class="se">\\\"</span><span class="si">$str</span><span class="se">\\\"</span><span class="p">";</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nv">$cmd</span> <span class="o">=</span> <span class="nv">$cmd</span> <span class="o">.</span> <span class="p">"</span><span class="s2"> -P</span><span class="si">$toplevel</span><span class="s2">.</span><span class="si">$p</span><span class="s2">=</span><span class="si">$v</span><span class="p">";</span>
		<span class="p">}</span>
	<span class="p">}</span></code></pre></figure>

<p>Our last step will be to append the name of our file list to the command
line, and then specify that <a href="http://iverilog.icarus.com">Icarus</a>
should produce an output file in our
test directory having the same name as our test’s configuration name.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="k">if</span> <span class="p">(</span><span class="nv">$cfgfiles</span><span class="p">{</span><span class="nv">$config</span><span class="p">}</span> <span class="ow">ne</span> <span class="p">"")</span> <span class="p">{</span>
		<span class="nv">$cmd</span> <span class="o">=</span> <span class="nv">$cmd</span> <span class="o">.</span> <span class="p">"</span><span class="s2"> </span><span class="p">"</span> <span class="o">.</span> <span class="nv">$cfgfiles</span><span class="p">{</span><span class="nv">$config</span><span class="p">};</span>
	<span class="p">}</span>

	<span class="nv">$cmd</span> <span class="o">=</span> <span class="nv">$cmd</span> <span class="o">.</span> <span class="p">"</span><span class="s2"> -o </span><span class="si">$testd</span><span class="s2">/</span><span class="si">$tstname</span><span class="p">";</span></code></pre></figure>

<p>This should be unique enough to work with.</p>

<p>For those not familiar with <a href="http://iverilog.icarus.com">Icarus Verilog</a>,
this is <a href="http://iverilog.icarus.com">Icarus</a>’s way of doing business.
Simulation takes place in two parts.  The first part is to build a simulation
executable, and the second part is to build the simulation itself.<br />
(Vivado isn’t all that different.)  Now that we have a command line built up
to build the executable, therefore, we go ahead and run
<a href="http://iverilog.icarus.com">Icarus</a> to build our simulation executable.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="nv">e</span> <span class="p">"</span><span class="si">$testd</span><span class="s2">/</span><span class="si">$tstname</span><span class="p">")</span> <span class="p">{</span>
		<span class="nb">unlink</span> <span class="p">"</span><span class="si">$testd</span><span class="s2">/</span><span class="si">$tstname</span><span class="p">";</span>
	<span class="p">}</span>

	<span class="nv">$cmd</span> <span class="o">=</span> <span class="nv">$cmd</span> <span class="o">.</span> <span class="p">"</span><span class="s2"> |&amp; tee -a </span><span class="si">$sim_log</span><span class="p">";</span>
	<span class="nb">system</span> <span class="p">"</span><span class="s2">echo </span><span class="se">\</span><span class="s2">'</span><span class="si">$cmd</span><span class="se">\</span><span class="s2">'</span><span class="p">";</span>
	<span class="nb">system</span> <span class="p">"</span><span class="s2">bash -c </span><span class="se">\</span><span class="s2">'</span><span class="si">$cmd</span><span class="se">\</span><span class="s2">'</span><span class="p">";</span>
	<span class="nv">$errB</span> <span class="o">=</span> <span class="vg">$?</span><span class="p">;</span></code></pre></figure>

<p>If all goes well, we should now have a simulation executable–assuming
<a href="http://iverilog.icarus.com">Icarus</a> didn’t find some error while building
our design.</p>

<p>So … let’s run our simulation!</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="k">if</span> <span class="p">(</span><span class="nv">$errB</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="o">-</span><span class="nv">x</span> <span class="p">"</span><span class="si">$testd</span><span class="s2">/</span><span class="si">$tstname</span><span class="p">")</span> <span class="p">{</span>
		<span class="c1">## Grab a timestamp</span>
		<span class="p">(</span><span class="nv">$sc</span><span class="p">,</span><span class="nv">$mn</span><span class="p">,</span><span class="nv">$hr</span><span class="p">,</span><span class="nv">$dy</span><span class="p">,</span><span class="nv">$mo</span><span class="p">,</span><span class="nv">$yr</span><span class="p">,</span><span class="nv">$wday</span><span class="p">,</span><span class="nv">$yday</span><span class="p">,</span><span class="nv">$isdst</span><span class="p">)</span><span class="o">=</span><span class="nb">localtime</span><span class="p">(</span><span class="nb">time</span><span class="p">);</span>
		<span class="nv">$yr</span><span class="o">=</span><span class="nv">$yr</span><span class="o">+</span><span class="mi">1900</span><span class="p">;</span> <span class="nv">$mo</span><span class="o">=</span><span class="nv">$mo</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="nv">$tstamp</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">("</span><span class="s2">%04d/%02d/%02d %02d:%02d:%02d</span><span class="p">",</span>
				<span class="nv">$yr</span><span class="p">,</span><span class="nv">$mo</span><span class="p">,</span><span class="nv">$dy</span><span class="p">,</span><span class="nv">$hr</span><span class="p">,</span><span class="nv">$mn</span><span class="p">,</span><span class="nv">$sc</span><span class="p">);</span>
		<span class="nb">system</span> <span class="p">"</span><span class="s2">echo </span><span class="se">\"</span><span class="si">$tstamp</span><span class="s2"> -- Starting simulation</span><span class="se">\"</span><span class="s2"> | tee -a </span><span class="si">$sim_log</span><span class="p">";</span>

		<span class="c1">## Then run the simulation</span>
		<span class="nb">system</span> <span class="p">"</span><span class="si">$testd</span><span class="s2">/</span><span class="si">$tstname</span><span class="s2"> &gt;&gt; </span><span class="si">$sim_log</span><span class="p">";</span>

		<span class="c1">## Finish the log with another timestamp</span>
		<span class="p">(</span><span class="nv">$sc</span><span class="p">,</span><span class="nv">$mn</span><span class="p">,</span><span class="nv">$hr</span><span class="p">,</span><span class="nv">$dy</span><span class="p">,</span><span class="nv">$mo</span><span class="p">,</span><span class="nv">$yr</span><span class="p">,</span><span class="nv">$wday</span><span class="p">,</span><span class="nv">$yday</span><span class="p">,</span><span class="nv">$isdst</span><span class="p">)</span><span class="o">=</span><span class="nb">localtime</span><span class="p">(</span><span class="nb">time</span><span class="p">);</span>
		<span class="nv">$yr</span><span class="o">=</span><span class="nv">$yr</span><span class="o">+</span><span class="mi">1900</span><span class="p">;</span> <span class="nv">$mo</span><span class="o">=</span><span class="nv">$mo</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="nv">$tstamp</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">("</span><span class="s2">%04d/%02d/%02d %02d:%02d:%02d</span><span class="p">",</span>
					<span class="nv">$yr</span><span class="p">,</span><span class="nv">$mo</span><span class="p">,</span><span class="nv">$dy</span><span class="p">,</span><span class="nv">$hr</span><span class="p">,</span><span class="nv">$mn</span><span class="p">,</span><span class="nv">$sc</span><span class="p">);</span>
		<span class="nb">system</span> <span class="p">"</span><span class="s2">echo </span><span class="si">$tstamp</span><span class="s2"> &gt;&gt; </span><span class="si">$sim_log</span><span class="p">";</span></code></pre></figure>

<p>Once we get to this point, the simulation has now completed.  This may take
many hours, depending upon the configuration and the test.  For example,
running the <code class="language-plaintext highlighter-rouge">LOCK</code> check on the
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/rtl/zipbones.v">ZipBones</a>
MIN configuration takes about 12hrs on my computer.  On the other hand, when
using <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>,
<em>all</em> of the tests for all of the configurations can complete in less than one
hour–but … that’s another story.  (It’s also one of the reasons why I love
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a> so
much!)</p>

<p>Now that everything has completed, let’s go dig through the log file to
see if we’ve been successful.</p>

<p>If we find <code class="language-plaintext highlighter-rouge">ERROR</code> in the log file, or any reference to an assertion failure,
then we have not been successful.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">		<span class="nb">system</span> <span class="p">"</span><span class="s2">grep </span><span class="se">\</span><span class="s2">'ERROR</span><span class="se">\</span><span class="s2">' </span><span class="si">$sim_log</span><span class="s2"> | sort -u</span><span class="p">";</span>
		<span class="nb">system</span> <span class="p">"</span><span class="s2">grep -q </span><span class="se">\</span><span class="s2">'ERROR</span><span class="se">\</span><span class="s2">' </span><span class="si">$sim_log</span><span class="p">";</span>
		<span class="nv">$errE</span> <span class="o">=</span> <span class="vg">$?</span><span class="p">;</span>
		<span class="nb">system</span> <span class="p">"</span><span class="s2">grep -iq </span><span class="se">\</span><span class="s2">'assert.*fail</span><span class="se">\</span><span class="s2">' </span><span class="si">$sim_log</span><span class="p">";</span>
		<span class="nv">$errA</span> <span class="o">=</span> <span class="vg">$?</span><span class="p">;</span>
		<span class="nb">system</span> <span class="p">"</span><span class="s2">grep -iq </span><span class="se">\</span><span class="s2">'fail</span><span class="se">\</span><span class="s2">' </span><span class="si">$sim_log</span><span class="p">";</span>
		<span class="nv">$errF</span> <span class="o">=</span> <span class="vg">$?</span><span class="p">;</span></code></pre></figure>

<p>We can now take these results and write them into a report file, to track
all of our simulation results.  We’ll assume here that if we haven’t found
any errors, then the test has been successful.</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl">	<span class="nb">open</span> <span class="p">(</span><span class="nv">SUM</span><span class="p">,"</span><span class="s2">&gt;&gt; </span><span class="si">$report</span><span class="p">");</span>
	<span class="nv">$msg</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">("</span><span class="s2">%s IVerilog  -- %s</span><span class="p">",</span> <span class="nv">$tstamp</span><span class="p">,</span> <span class="nv">$tstname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nv">$errE</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nv">$errA</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nv">$errF</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">## ERRORs found</span>
		<span class="k">print</span> <span class="nv">SUM</span> <span class="p">"</span><span class="s2">ERRORS    </span><span class="si">$msg</span><span class="se">\n</span><span class="p">";</span>
		<span class="k">print</span>     <span class="p">"</span><span class="s2">ERRORS    </span><span class="si">$msg</span><span class="se">\n</span><span class="p">";</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">print</span> <span class="nv">SUM</span> <span class="p">"</span><span class="s2">PASSED    </span><span class="si">$msg</span><span class="se">\n</span><span class="p">";</span>
		<span class="k">print</span>     <span class="p">"</span><span class="s2">PASSED    </span><span class="si">$msg</span><span class="se">\n</span><span class="p">";</span>
	<span class="p">}</span></code></pre></figure>

<p>This isn’t really an ideal test, but it’s worked for me so far.</p>

<p>The <em>ideal</em> would be for the test to end with some form of SUCCESS message.
My test setup still needs some work, though, before I will have a dependable
SUCCESS message to work from.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Put together, <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/sim_run.pl">this script</a> allows me to test a rough 67 test
cases.  Why so many?  Simply because each test checks something different.
Sadly, I’ve learned from experience that it’s possible to have 66 test cases
pass and one fail.</p>

<p>Ideally, the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/zipsw/cputest.c">initial CPU test</a>
should catch any and all bugs.  Sadly, it doesn’t.  Or rather, it hasn’t.  For
example, the original <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/zipsw/cputest.c">CPU
test</a>
never caught the bugs associated with stepping the CPU, one instruction at a
time.  Specifically, stepping through a divide instruction would void the
divide instruction, and leave you forever stepping through the same
instruction.  While I’ve now fixed the <a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/zipsw/cputest.c">CPU test
program</a>
so it checks for that bug, I’m reasonably confident that nothing other than my
<a href="https://github.com/ZipCPU/zipcpu/blob/2ffbf68b450948dee56f36bbd113e80866a9362a/sim/zipsw/lockcheck.c"><code class="language-plaintext highlighter-rouge">LOCK</code> checking program</a>
will truly check for whether or not <code class="language-plaintext highlighter-rouge">LOCK</code> instruction works.  Further, the
bus width tests have found bugs the other tests haven’t as well.</p>

<table align="center" style="float: right"><caption>Fig. 10, Does testing need to go multicore?</caption><tr><td><img src="/img/zipsim/multicore.svg" alt="" width="420" /></td></tr></table>

<p>While the test set is reasonably complete, I am also painfully aware of some
significant holes remaining in it–thanks to both
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>’s
coverage checking capability and <a href="https://github.com/YosysHQ/mcy">MCY</a>.
For example, while I exercise the exclusive access capabilities of
both AXI and Wishbone buses, I only do so from a single CPU.  Worse, the
CPU will not allow a <code class="language-plaintext highlighter-rouge">LOCK</code> instruction sequence to be interrupted or stepped
through–it’s either all one instruction or none by design.  In many ways,
that’s a good thing … except that it means there will never be any true
<em>bus</em> contention to test whether or not the memory modules handle locking
properly.  Another glaring fault in this test setup is that nothing is
(currently) testing the CPU’s debug port.  Hence, I may choose to fix both
of these by adding additional CPU’s to my simulation, in such a way that one
master CPU controls and starts all others.</p>

<p>For now, let me note that I’ve enjoyed this approach so much that I’ve
started using something similar on my commercial projects, and I’ve even
ported a similar script to Vivado.</p>

<p>Bottom line: the approach works nicely, and I’m likely to use it again.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Judge me, O LORD; for I have walked in mine integrity: I have trusted also in the LORD; therefore I shall not slide.  Examine me, O LORD, and prove me; try my reins and my heart. (Ps 26:1-2)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
