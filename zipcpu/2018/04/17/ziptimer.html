<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ZipTimer: A simple countdown timer</title>
  <meta name="description" content="If you are a beginningFPGAdesigner, the first example you will be given to learn is that of a counter.It’s sort of a tradition.  Class room exercises all ill...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2018/04/17/ziptimer.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">ZipTimer: A simple countdown timer</h1>
    <p class="post-meta"><time datetime="2018-04-17T00:00:00-04:00" itemprop="datePublished">Apr 17, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>If you are a beginning
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designer, the first example you will be given to learn is that of a counter.
It’s sort of a tradition.  Class room exercises all illustrate concepts
with simple counters.  If you ask a question, the instructor will go to the
board and start his explanation with a counter.  At least, that’s what I would
do if I trying to teach an Verilog concept.</p>

<p>But just how useful is a counter in the end anyway?</p>

<p>Let’s try examining a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">counter</a>
all the way from an irrelevant classroom
discussion to a vital system component.</p>

<p>How can this be?  Well, one
peripheral necessary to any
<a href="https://en.wikipedia.org/wiki/Computer_multitasking">multitasking</a>
<a href="https://en.wikipedia.org/wiki/Operating_System">operating system</a>, whether
<a href="http://www.unix.org/what_is_unix.html">Unix</a>,
<a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, Windows, or some other
<a href="https://en.wikipedia.org/wiki/Operating_System">O/S</a>, is an
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>.
An <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
is little more than a reconfigurable counter.  All it does is issue an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
to the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
at a periodic interval.</p>

<p>Embedded systems, such as those found within
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>’s,
have an additional timing
need.  These systems often need to insert known delays between different
operations.  Instead of an
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>,
these systems need what are known as
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">“one-shot” timers</a>.
Once programmed, they generate an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
after the programmed delay takes place and then they return to idle.</p>

<table align="center" style="float: right"><caption>Fig 1. The ZipSystem</caption><tr><td><img src="/img/zipsystem.svg" alt="" width="480" /></td></tr></table>
<p>The
<a href="/about/zipcpu.html">ZipCPU</a> wrapper known as the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>
has three such timers within it, shown in Fig 1 as “Generic Timers (x3)”.
I call these timers
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">ZipTimers</a>.
Each of these
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">ZipTimers</a>
supports generating either a regular
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
or a one-shot delay based
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.  These
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">ZipTimers</a>
have been a part of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>
since I started.  Their simplicity makes them perfect
candidates for beginner exercises, and even better candidates for learning
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>.</p>

<p>The <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">ZipTimer</a>
has two capabilities beyond the traditional beginner’s counter
exercise.  These are first the ability to be programmed over a <a href="/zipcpu/2017/11/07/wb-formal.html">wishbone
bus</a>,
and second the ability to
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a> the
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a>
when the specified delay runs out.</p>

<p>Therefore, let’s examine this <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer
peripheral</a>
as an exercise in learning Verilog,
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>,
and connecting a simple item to a bus using
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.
Along the way, I’ll do my best to avoid calling this a “counter example”.</p>

<h2 id="the-beginners-exercise">The Beginner’s Exercise</h2>

<p>Hopefully everyone reading this blog has at one time built a countdown timer
in Verilog.  Indeed, I use a basic countdown timer as one of the first examples
in the <a href="/projects.html">Formal Verification course</a>
I now teach.  Below is the simple example timer that we’ll start
with today.</p>

<table align="center" style="float: right"><caption>Fig 2. A Countdown Timer</caption><tr><td><img src="/img/timer-oneshot.svg" alt="" width="248" /></td></tr></table>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r_value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_start</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">TIMEOUT</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">r_value</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>This counter starts at zero.  Any time an <code class="highlighter-rouge">i_start</code> signal takes place, the
counter is set to <code class="highlighter-rouge">TIMEOUT</code> and then counts down to zero, as illustrated in
Fig 2.  Note that
setting this counter to <code class="highlighter-rouge">TIMEOUT</code> doesn’t guarantee that it will take
<code class="highlighter-rouge">TIMEOUT</code> clock ticks until it returns to zero–it is possible the <code class="highlighter-rouge">i_start</code>
signal resets this counter back to <code class="highlighter-rouge">TIMEOUT</code> before it hits zero.</p>

<p>We’ll also create an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
signal that we will set anytime the counter becomes zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">o_int</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">o_int</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>That’s not all that hard, right?</p>

<p>Did you notice the subtlety associated with checking <code class="highlighter-rouge">r_value==1</code> here?
One of my readers pointed this out.  If <code class="highlighter-rouge">i_start</code> happens to be true on the
same cycle that <code class="highlighter-rouge">r_value==1</code>, then <code class="highlighter-rouge">o_int</code> might be true on a clock cycle
when <code class="highlighter-rouge">r_value != 0</code>.  Yes, this is a bug.  It’ll come back in the next section
as well.  However, I’m going to leave this bug in place because this was how I
originally designed the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">ZipTimer</a>–with
this bug within it.  (Oops!) It wasn’t until years later when I attempted to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a> the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer
code</a>
presented below that I discovered this subtlety.</p>

<p>For now, let’s just peel this onion back a bit further.</p>

<p>The problem with the above implementation of a counter is that it isn’t very
reusable.  If you are going to generate a counter that will be
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable</a>,
then you’ll want to add a
<a href="/zipcpu/2017/05/29/simple-wishbone.html">bus interface </a>.
If we use the
<a href="/zipcpu/2017/11/07/wb-formal.html">wishbone bus</a>,
then anytime <code class="highlighter-rouge">(i_wb_stb)&amp;&amp;(i_wb_we)</code> is true, and the address reflects our
timer’s address, then we can reload our timer from <code class="highlighter-rouge">i_wb_data</code>.
This would give us a more adaptable, configurable timer.  Such a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">controlled timer</a>
could easily become a
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a> peripheral.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r_value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">r_value</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>This works fine for
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
implementations, but what if you want this counter to run in a <a href="/blog/2017/10/13/fpga-v-asic.html">context
where <code class="highlighter-rouge">initial</code> statements are
ignored</a>?  In that case,
you need an <code class="highlighter-rouge">i_reset</code> input.  On a reset, that is when <code class="highlighter-rouge">i_reset</code> is high,
the counter should return to idle, <code class="highlighter-rouge">r_value == 0</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r_value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">r_value</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>In a similar fashion, with only a tiny adjustment, we can use this module
to count events.  We’ll use an incoming <code class="highlighter-rouge">i_ce</code> signal to denote when an event
has taken place.  Examples of such events include not only clock cycles
(<code class="highlighter-rouge">i_ce=1</code>), but also incoming or outgoing samples in a
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">DSP</a>
system, or lines or frames in a video system.  All of these options can
be created by appropriately setting an <code class="highlighter-rouge">i_ce</code> input to one <a href="/blog/2017/08/14/strategies-for-pipelining.html">any time the
timer is to
step</a>.
Put together, our original counter now becomes,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r_value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">r_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">r_value</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>That’s quite the configurable counter, no?</p>

<p>Let’s now return to our
<a href="/zipcpu/2017/11/07/wb-formal.html">bus interface</a>
and properly set the rest of the required
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">control values</a>.
Since we can respond on every clock cycle, there’s no reason to ever stall the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>We’ll also need to create a response to the <a href="/zipcpu/2017/11/07/wb-formal.html">wishbone
bus</a>.  Since
this operation takes only a single cycle, we’ll acknowledge the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
any time we are selected.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">o_wb_ack</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>We can do this if the current counter state data is always valid on the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>’s
<code class="highlighter-rouge">o_wb_data</code> lines.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">o_wb_data</span> <span class="o">=</span> <span class="n">r_value</span><span class="o">;</span></code></pre></figure>

<p>Voila!  A <a href="/zipcpu/2017/05/29/simple-wishbone.html">simple, wishbone bus
controlled</a>
count-down timer!</p>

<h2 id="interval-timer">Interval Timer</h2>

<p>The former code works great for a one-shot timer.  However, if you want to
create a timer that
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a> the
<a href="/about/zipcpu.html">CPU</a> every 10ms (as an example), only
to be reset by the <a href="/about/zipcpu.html">CPU</a> in an
<a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt service routine</a>,
then you will find that the interval pseudorandomly walks in phase.  The
intervals will all be longer then 10ms.  How can we fix this?</p>

<table align="center" style="float: right"><caption>Fig 3. An Interval Timer</caption><tr><td><img src="/img/timer-interval.svg" alt="" width="248" /></td></tr></table>
<p>One solution is to use an
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>.
Simply put, an
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
is one that counts down to zero, and then resets itself to count down again.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r_value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">r_value</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">interval_count</span><span class="o">;</span></code></pre></figure>

<p>As before, we’ll generate an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
anytime this timer hits zero,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">o_int</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">o_int</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>But … what if we wanted to allow this reload value to be externally set?
To create this capability, we’ll attach this
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
to <a href="/zipcpu/2017/11/07/wb-formal.html">wishbone bus</a>.
Perhaps we want something like,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">r_value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="n">r_interval_count</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="o">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">r_value</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">r_interval_count</span><span class="o">;</span></code></pre></figure>

<p>This is almost identical to our original counter above, save that every time
it resets it goes back to <code class="highlighter-rouge">r_interval_count</code> instead of the original <code class="highlighter-rouge">TIMEOUT</code>
parameter.  Since <code class="highlighter-rouge">r_interval_count</code> is programmable from the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>,
we now have a <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interrupt
timer</a>.
How hard can this be?</p>

<p>In this case, the devil is in the details.</p>

<p>Look closer.  Do you see any of the problems with this implementation?
For example, what happens if you want to switch from a 4-second intervals to
10ms intervals?  Just how many counts will that first 10ms interval contain?
Up to 4 seconds?</p>

<p>If that’s not the response you want, then how should this timer respond?</p>

<p>While we consider this, let’s also consider merging the countdown timer
together with the
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
in a way that both respond to
<a href="/zipcpu/2017/05/29/simple-wishbone.html">bus requests</a>.
Here’s the capability or requirement we’ll build to then:</p>

<ul>
  <li>
    <p>On any reset, the counter will set itself to zero and wait to be configured</p>

    <p>This matches the count-down timer behavior we discussed above.</p>
  </li>
</ul>

<table align="center" style="float: none"><caption>Fig 4. The ZipTimer Register</caption><tr><td><img src="/img/timer-reg.png" alt="" width="557" /></td></tr></table>

<ul>
  <li>
    <p>On any write, the counter will assume the value written to it, as shown
in Fig 4 as the <code class="highlighter-rouge">New Counter</code> bits, and will then start counting down.
If the number written was a zero, then the counter will stay at zero and stop.</p>

    <p>Again, this matches the count-down timer behavior we originally discussed.</p>
  </li>
  <li>
    <p>If the high bit is set upon any write, shown as <code class="highlighter-rouge">R</code> in Fig 4 above,
then the timer will enter into interval mode.  In all other cases, the timer
will be started as a one-shot countdown timer.</p>

    <p>This is our first break from the original countdown timer’s functionality,
allowing us to run in an interval timer mode.</p>

    <p>Further, if set to interval mode, then the value written to the timer will
become the interval definition.  Hence, when the timer finishes counting
down to zero, we’ll just automatically restart it again with the same
<code class="highlighter-rouge">New Counter</code> value just written to it.</p>
  </li>
  <li>
    <p>On writing a zero to the counter, all ongoing counts will be ended and the
counter will return to idle.  Any interval capability will be turned off.</p>
  </li>
  <li>
    <p>We’ll also use a <a href="/blog/2017/08/14/strategies-for-pipelining.html">global CE
register</a>,
<code class="highlighter-rouge">i_ce</code>.  This will allow you to count down things other than clock cycles.
Perhaps you can count incoming samples on an interface.  Perhaps you
want to count video frames.  Perhaps you want to count finished instructions.
All of these can be implemented with an appropriate connection to this <code class="highlighter-rouge">i_ce</code>
wire.</p>
  </li>
</ul>

<p>Simple enough?  Almost.</p>

<p>If low logic is a priority, and it has always been a priority for me, then
you’ll also want to be able to configure this peripheral for just the amount
of logic necessary.  We’ll use the parameter <code class="highlighter-rouge">VW</code> to control how many bits
are in our counter.  We’ll also use <code class="highlighter-rouge">BW</code> to be the width of the data
bus–nominally 32 bits.  Finally we’ll use the one bit parameter,
<code class="highlighter-rouge">RELOADABLE</code> to control whether or not this timer offers an
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
mode or not.  For example, if you know you are only ever going to measure
20ms intervals from a 100MHz clock, then you won’t ever need any
more than <code class="highlighter-rouge">VW=21</code> bits.</p>

<p>Simple enough now?  I thought so.  Let’s dive into a walk through of the code.</p>

<h2 id="the-code">The Code</h2>

<p>We’ll walk through the code of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">ZipTimer</a>
in two separate sections.  First, we’ll discuss the traditional Verilog code.
Then we’ll move from that to the
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
section.  Once we’ve finished discussing the
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
within the code, I show how to connect a peripheral like this to an
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
based design.</p>

<p>Normally I skip the front matter of a Verilog file when blogging, so as to
only focus on the relevant portions.  In this case, I’ll show the three
parameters: <code class="highlighter-rouge">BW</code>, containing the size of the bus, <code class="highlighter-rouge">VW</code>, containing the
number of bits in our counter, and <code class="highlighter-rouge">RELOADABLE</code>–set to one if we want
to support an
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
capability in addition to the one-shot timer capability.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="n">BW</span> <span class="o">=</span> <span class="mi">32</span><span class="o">;</span>
	<span class="k">parameter</span>	<span class="n">VW</span> <span class="o">=</span> <span class="p">(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span>
	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">RELOADABLE</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>I’ll also simplify the write command below to a <code class="highlighter-rouge">wb_write</code> flag.  Since you’ll
see this often below, here’s the declaration.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">wb_write</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>As a result, any time you read <code class="highlighter-rouge">wb_write</code> below you now know that it is
nothing more than a
<a href="https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)">predicate</a>
that will be true any time the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
is writing to our only
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
register.</p>

<p>We’ll also use a flag <code class="highlighter-rouge">r_running</code> to keep track of whether or not the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
is <em>running</em>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_running</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">r_running</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wb_write</span><span class="p">)</span>
			<span class="n">r_running</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">|</span><span class="n">i_wb_data</span><span class="p">[(</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">r_zero</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">auto_reload</span><span class="p">))</span>
			<span class="n">r_running</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>Basically the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
is <code class="highlighter-rouge">r_running</code> any time it is non-zero, or any time it is
zero and about to reload for the next interval.  If we wanted to, it would
<a href="/blog/2018/03/14/is-formal-hard.html">make sense to scribble in our
notes</a>
at this point that,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">if</span> <span class="p">((</span><span class="n">r_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">auto_reload</span><span class="p">))</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">r_running</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>The contrary case, where <code class="highlighter-rouge">r_running</code> is not true, will be a little more
difficult to specify so we’ll save it until we have to think our way through it
in the next section.  Either way, when we get to building our
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
section, we’ll then <a href="/blog/2018/03/14/is-formal-hard.html">copy our scribbled notes over
there</a>
so we can place all of our
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
in one place.</p>

<p>Moving on, if you recall from above, we used a <code class="highlighter-rouge">RELOADABLE</code> parameter
option to select whether or not this
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
included the
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
ability, or just a one-shot capability.  Hence, if <code class="highlighter-rouge">RELOADABLE</code> is true
then we’ll include this
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
capability.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RELOADABLE</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>The
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
capability itself centers around two registers.  The
first, <code class="highlighter-rouge">r_auto_reload</code>, is a single bit flag telling us whether or not the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
needs to be restarted once it hits zero.  The second register will tell us
what our interval is should <code class="highlighter-rouge">r_auto_reload</code> be set–but we’ll get to that
in a moment.</p>

<p>Initially, I cleared this <code class="highlighter-rouge">r_auto_reload</code> value upon any reset and set it
on any write where the most significant bit is set.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">r_auto_reload</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
				<span class="n">r_auto_reload</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wb_write</span><span class="p">)</span>
				<span class="n">r_auto_reload</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_wb_data</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span><span class="o">;</span></code></pre></figure>

<p>This approach failed when I tried to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">ZipTimer</a>.
When I dug a bit deeper, I realized that the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
interval could never be allowed to be zero.  Were it zero, this would
break the <code class="highlighter-rouge">r_running</code> assertion we placed into our notes above.
Hence, I rewrote the <code class="highlighter-rouge">r_auto_reload</code> logic above into,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">r_auto_reload</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
				<span class="n">r_auto_reload</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wb_write</span><span class="p">)</span>
				<span class="n">r_auto_reload</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_wb_data</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">|</span><span class="n">i_wb_data</span><span class="p">[(</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>The big difference is that in order to create an
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>,
you need to not only set the high order bit but you must also provide a
non-zero interval length.</p>

<p>The second item worth commenting on here is the assign statement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">assign</span>	<span class="n">auto_reload</span> <span class="o">=</span> <span class="n">r_auto_reload</span><span class="o">;</span></code></pre></figure>

<p>By assigning to a global <code class="highlighter-rouge">wire</code> value within a <code class="highlighter-rouge">generate</code> block, I
can then use this <code class="highlighter-rouge">wire</code> value throughout the rest of my design without
needing to waste <code class="highlighter-rouge">reg</code>s when <code class="highlighter-rouge">RELOADABLE</code> is false and I don’t need them.
Optimizations within the synthesizer will then remove any extra logic dependent
upon these values.</p>

<p>The next register associated with the
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
capability is the <code class="highlighter-rouge">r_interval_count</code> register–containing the the interval
length expressed as value to reset our register to after it reaches zero.
On any write, we’ll set this interval count to the information found on the
data <a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
in <code class="highlighter-rouge">i_wb_data</code>.  The <code class="highlighter-rouge">r_auto_reload</code> we just dealt with
above will determine whether or not this <code class="highlighter-rouge">r_interval_count</code> is relevant or not.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">r_interval_count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
				<span class="n">r_interval_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wb_write</span><span class="p">)</span>
				<span class="n">r_interval_count</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[(</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
		<span class="k">assign</span>	<span class="n">interval_count</span> <span class="o">=</span> <span class="n">r_interval_count</span><span class="o">;</span></code></pre></figure>

<p>Finally, if we are building without the
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
capability, we’ll set both of these values, <code class="highlighter-rouge">auto_reload</code> and <code class="highlighter-rouge">interval_count</code>,
to zero.  The synthesizer will then remove any of the relevant
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
logic below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="k">assign</span>	<span class="n">auto_reload</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">assign</span>	<span class="n">interval_count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Let’s now dig into the core of this count-down timer: the counter’s value,
<code class="highlighter-rouge">r_value</code>.  This follows primarily from the counter we started with, corrected
by our discussion above, but now with the changes necessary to handle both an
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
capability as well as a <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">one-shot countdown
timer</a>
capability.</p>

<p>In both cases, the counter is initialized to zero, cleared on reset, and
set on any
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">write</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wb_write</span><span class="p">)</span>
			<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">[(</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Otherwise, we’ll adjust the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
any time <code class="highlighter-rouge">i_ce</code> is true and the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
is currently running.  As you may remember from above, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
is <code class="highlighter-rouge">r_running</code> any time <code class="highlighter-rouge">r_value</code> it is nonzero, or we are in
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
mode (<code class="highlighter-rouge">r_auto_reload</code> is true).</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">r_running</span><span class="p">))</span>
		<span class="k">begin</span></code></pre></figure>

<p>If the counter is not zero, we’ll count down.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r_zero</span><span class="p">)</span>
				<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">r_value</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>Once it reaches zero, we’ll restart it if we are in
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
mode.  In this mode, <code class="highlighter-rouge">auto_reload</code> will be true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">auto_reload</span><span class="p">)</span>
				<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">interval_count</span><span class="o">;</span>
		<span class="k">end</span></code></pre></figure>

<p>If <code class="highlighter-rouge">auto_reload</code> is not set then once the counter reaches zero, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
will stop.</p>

<p>The next register in our implementation is <code class="highlighter-rouge">r_zero</code>.  <code class="highlighter-rouge">r_zero</code> is a helper
register.  It needs to
be equivalent to <code class="highlighter-rouge">r_value == 0</code>.  (We’ll prove that these two expressions
evaluate to the same value in a moment.)  By setting <code class="highlighter-rouge">r_zero</code> on the clock
before <code class="highlighter-rouge">r_value</code> reaches zero, we relieve some of the timing stress within
this module.  Hence, instead of an always block that depends upon whether
or not <code class="highlighter-rouge">r_value == 0</code>, such as the original designs we started out with,
they can instead depend upon a single pre-calculated single-bit value <code class="highlighter-rouge">r_zero</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="n">r_zero</span>  <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">r_zero</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wb_write</span><span class="p">)</span>
			<span class="n">r_zero</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_wb_data</span><span class="p">[(</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">r_running</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_ce</span><span class="p">))</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}},</span> <span class="mb">1'b1</span> <span class="o">}</span><span class="p">)</span>
				<span class="n">r_zero</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">r_zero</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">auto_reload</span><span class="p">))</span>
				<span class="n">r_zero</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">end</span></code></pre></figure>

<p><a href="/blog/2018/03/14/is-formal-hard.html">Were I writing this code from
scratch</a>, I’d
scribble into the margin that I’ll want to come back and prove the
<a href="/blog/2017/10/19/formal-intro.html">formal property</a>
that</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">assert</span><span class="p">(</span><span class="n">r_zero</span> <span class="o">==</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>The final required piece of logic is the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
register, <code class="highlighter-rouge">o_int</code>.  While we might consider setting the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
line to <code class="highlighter-rouge">r_zero</code>, we’d then get lots of
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>s
every time the counter was idle.  We’d also get lots of
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>s
between any pair of <code class="highlighter-rouge">i_ce</code> strobes while the counter was waiting to reload.
Hence, we’ll only set the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
any time <code class="highlighter-rouge">r_value</code> transitions to zero, or more explicitly any time it is
equal to one and the <code class="highlighter-rouge">i_ce</code> register is high.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_int</span>   <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">wb_write</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_ce</span><span class="p">))</span>
			<span class="n">o_int</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
		<span class="k">else</span> <span class="c1">// if (i_ce)
</span>			<span class="n">o_int</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}},</span> <span class="mb">1'b1</span> <span class="o">}</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>As our last step, we’ll set the return data on the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
to be the indication of whether we are in
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
mode (<code class="highlighter-rouge">auto_reload</code> is high), followed by the current
state of the counter.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_wb_data</span> <span class="o">=</span> <span class="o">{</span> <span class="n">auto_reload</span><span class="o">,</span> <span class="n">r_value</span> <span class="o">};</span></code></pre></figure>

<p>Other
<a href="/zipcpu/2017/11/07/wb-formal.html">wishbone return</a>
return values follow from our prior discussion:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">assign</span>	<span class="n">o_wb_ack</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>That’s all it takes to generate a timer peripheral for a
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a>.  It’s a bit more
than the simple counter we started out with.
In the next section, we’ll discuss how we might go about <a href="/blog/2017/10/19/formal-intro.html">formally
verifying</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">this timer</a>.</p>

<h2 id="the-formal-proof">The formal proof</h2>

<p>If you are not familiar with using <a href="http://www.clifford.at/yosys/">yosys</a>
for <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>,
then I’ll recommend you go back and read about my <a href="/blog/2017/10/19/formal-intro.html">first experiences with
formal methods</a>.</p>

<p>If you just want a quick reminder, there are two basic operators we’ll be using
below.  The <code class="highlighter-rouge">assume()</code> operator restricts the size of the possible state space
that the
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
will examine.  The <code class="highlighter-rouge">assert()</code> operator defines which states within
this group are illegal.  The formal engine will try all possible logic threads
to find one where the
<a href="https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)">predicate</a>
expression inside the <code class="highlighter-rouge">assert()</code> statement can be made to be false.</p>

<table align="center" style="float: right"><caption>Fig 5. The Golden Rule of Formal Verification</caption><tr><td><img src="/img/fv-master-rule.svg" alt="" width="360" /></td></tr></table>
<p>To know which of <code class="highlighter-rouge">assume()</code> or <code class="highlighter-rouge">assert()</code> to use for any particular
property, I follow the rule shown in Fig 5.  Hence, we’ll <code class="highlighter-rouge">assume()</code>
any properties about our inputs, and we’ll <code class="highlighter-rouge">assert()</code> any properties
about our own internal state or any outputs we might produce.</p>

<p>There is a third operator we’ll be using as well.  This is the <code class="highlighter-rouge">$past()</code>
operator.  As we use it below, this operator returns the value of the
item within it one clock ago.  The problem with the <code class="highlighter-rouge">$past</code> operator is that
it tends to misbehave prior to the beginning of time.  Hence, any time you
see me using this you’ll also see <code class="highlighter-rouge">f_past_valid</code> in the condition list.</p>

<p>As with most of my
<a href="/blog/2017/10/19/formal-intro.html">formal property</a>
sections, they start with the definition of the <code class="highlighter-rouge">f_past_valid</code> variable
I just mentioned.  We discussed this above, and in more detail
<a href="/blog/2017/10/19/formal-intro.html">before</a>.
Basically, any assertion regarding something one clock in the <code class="highlighter-rouge">$past()</code>,
before any <code class="highlighter-rouge">initial</code> settings, will fail.
By checking for <code class="highlighter-rouge">f_past_valid</code> being true as part of a formal logic
test, I can then use <code class="highlighter-rouge">$past()</code> expressions in any <code class="highlighter-rouge">assert()</code> statements below
without worrying about whether or not the logic being referenced occurred
before time began.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="kt">reg</span>	<span class="n">f_past_valid</span><span class="o">;</span>
	<span class="k">initial</span>	<span class="n">f_past_valid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">f_past_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span></code></pre></figure>

<p>The next order of business is bounding the <code class="highlighter-rouge">i_reset</code> signal.  This signal needs
to be true initially.  We’ll also insist that it’s true any time <code class="highlighter-rouge">f_past_valid</code>
is false.  Aren’t these two the same condition?  Not quite. While they are
very similar, they are separate conditions.  This second
condition specifies that any time the induction engine tries to set
<code class="highlighter-rouge">f_past_valid</code> to false, then the <code class="highlighter-rouge">i_reset</code> line must also be true which will
then force the design into its initial state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="k">assume</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span>
			<span class="k">assume</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>If we do this properly, we can use <code class="highlighter-rouge">f_past_valid</code> being false as an indication
that our design should be in its reset state.  In a similar fashion, on the
clock following any <code class="highlighter-rouge">i_reset</code>, the design should also be in its reset state.</p>

<p>We’ll pull any value from above that has an <code class="highlighter-rouge">initial</code> statement or responds
to an <code class="highlighter-rouge">i_reset</code> signal, and insist on either condition that the registers
have the same value.  We’ll also desk check our design to make certain that
registers set via an <code class="highlighter-rouge">initial</code> statement are also responsive to an <code class="highlighter-rouge">i_reset</code>
and vice-versa.  That is, an <code class="highlighter-rouge">initial</code> statement should set the register
to the same value that an <code class="highlighter-rouge">i_reset</code> would set them to.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">||</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span>     <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_running</span>   <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">auto_reload</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">interval_count</span><span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_zero</span>      <span class="o">==</span> <span class="mb">1'b1</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Let’s now move on to some internal consistency checks.  For example, we
stated above that we wanted <code class="highlighter-rouge">r_zero</code> to be equivalent to <code class="highlighter-rouge">r_value==0</code>.
Let’s now assert that this relationship holds.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_zero</span> <span class="o">==</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>Likewise, anytime our value is non-zero the timer should be running.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_running</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>In a similar fashion, any time we are in interval mode we should be running.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auto_reload</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_running</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Perhaps you may recall these from our scribbled notes above as well?</p>

<p>Further, if our parameter <code class="highlighter-rouge">RELOADABLE</code> is false, then <code class="highlighter-rouge">auto_reload</code> should
also be false.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RELOADABLE</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">auto_reload</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Finally, anytime <code class="highlighter-rouge">auto_reload</code> is true, we should have a non-zero interval
time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">auto_reload</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">interval_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Those are the simple properties.  The next several are more complex.</p>

<p>Our next step will be to work through the properties associated with <code class="highlighter-rouge">r_value</code>.</p>

<p>For the first of these more complex properties, we’ll say that any
time <code class="highlighter-rouge">r_value==0</code>, i.e. any time the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
has stopped counting down, then it should stay that way.  However, if you try
to express this simply,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">r_value</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>you might be surprised that your assertion doesn’t hold.  You’ll first find
that following a
<a href="/zipcpu/2017/05/29/simple-wishbone.html">wishbone write</a>,
<code class="highlighter-rouge">r_value</code> might be something other than zero.
You’ll then discover that, by design, following an automatic reload it won’t
be zero either.  Hence, the actual property is a touch more complex.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">r_value</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">wb_write</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">auto_reload</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Next, let’s consider the case where <code class="highlighter-rouge">r_value</code> was equal to zero on the last
clock, but isn’t equal to zero any more.  Specifically, we want to test
whether the interval
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
started over on a reload as desired.</p>

<p>In this case, the simple property has several exceptions to it.  The counter
won’t move to its reload value following a reset, nor will it necessarily
move to its reload value following a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">write</a>.
Finally, it should only restart if <code class="highlighter-rouge">i_ce</code> is true, and in all other
cases remain where it was.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">wb_write</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">r_value</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">auto_reload</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_ce</span><span class="p">))</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="n">interval_count</span><span class="p">)</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r_value</span><span class="p">))</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Now let’s consider the case where the <code class="highlighter-rouge">r_value</code> is not equal to zero on
the last clock.  While I’d like to write the assertion that,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">r_value</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r_value</span><span class="p">)</span><span class="o">-</span><span class="mb">1'b1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>the formal engine again corrects me with several traces showing why this
isn’t the case.  The first trace reminds me that, following a reset,
<code class="highlighter-rouge">r_value</code> will be zero.  Once I fix that and try again, the second trace
reminds me that <code class="highlighter-rouge">r_value</code> can be anything
following a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">write</a>.
Rather than running the formal tools again, I go back and desk check this
time to discover that
if <code class="highlighter-rouge">i_ce</code> isn’t true on the last clock then <code class="highlighter-rouge">r_value</code> shouldn’t change.</p>

<p>This brings us to the following property,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">wb_write</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">r_value</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_ce</span><span class="p">))</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r_value</span><span class="p">)</span><span class="o">-</span><span class="mb">1'b1</span><span class="p">)</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">r_value</span><span class="p">))</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>How about a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">write</a>?
Following a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">write</a>,
we want our counter to have the data written to it in our value.
The exception is a reset.  If a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">write</a>
and a reset occur on the same clock, we’d rather reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">wb_write</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[(</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]))</span><span class="o">;</span></code></pre></figure>

<p>This also applies to the interval length.  Following a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">write</a>,
if the value is non-zero, and if this module is built with the
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
capability, then the high bit will determine whether or not we enter into
<a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">interval timer</a>
mode.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">wb_write</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">RELOADABLE</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">|</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[(</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">])))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">auto_reload</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">[(</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]))</span><span class="o">;</span></code></pre></figure>

<p>We’re almost done.  Before leaving, we need to double check our output
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.
This wire, <code class="highlighter-rouge">o_int</code>, should be set any time <code class="highlighter-rouge">r_value</code> transitions from <code class="highlighter-rouge">1</code> to
<code class="highlighter-rouge">0</code>.  Or, at least, that was my original thought.  Then as I worked through
this logic using <a href="/blog/2017/10/19/formal-intro.html">formal
methods</a>,
I realized there were some exceptions.</p>

<p>If the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
is reset in the last cycle, then the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
should be inactive.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">||</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_int</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Following a
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">write</a>, the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
wire should be zero as well.  This will allow us to turn the timer <em>off</em> by
simply writing a zero to it.  Likewise, if
<code class="highlighter-rouge">i_ce</code> wasn’t true on the last clock, then we didn’t just hit zero and the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
should be clear again.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(($</span><span class="nb">past</span><span class="p">(</span><span class="n">wb_write</span><span class="p">))</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_ce</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_int</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>So when should the output
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
be set?  Any time we transition to zero.
Hence, it should be set following the clock where <code class="highlighter-rouge">i_ce</code> was high and
<code class="highlighter-rouge">r_value</code> was a one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_int</span> <span class="o">==</span> <span class="p">((</span><span class="n">r_running</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">r_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span><span class="o">;</span></code></pre></figure>

<p>Our last
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
are associated with the
<a href="/zipcpu/2017/11/07/wb-formal.html">wishbone bus</a>.
At first glance, these properties below may just appear like restatements
of the logic above.  In many ways they are.  However, by placing these here
I know I won’t carelessly adjust this interface logic while trying to optimize
things.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_ack</span> <span class="o">==</span> <span class="n">i_wb_stb</span><span class="p">)</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span><span class="n">BW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">auto_reload</span><span class="p">)</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span><span class="p">[</span><span class="n">VW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">r_value</span><span class="p">)</span><span class="o">;</span>
<span class="cp">`endif</span>
<span class="k">endmodule</span></code></pre></figure>

<p>That’s the last of our formal properties.  Did you notice along the way how
the formal engine helped us find the right properties for our code?  That it
found subtleties like the reset condition that needed to be checked for?
Not only that, did you notice how the formal engine helped us flesh out the
final details in our <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer
implementation</a>?</p>

<p>These are all reasons why I have now started using
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
before ever writing a test bench or running a simulation.  Using
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
helps me discover details I might otherwise not think about.</p>

<h2 id="autofpga">AutoFPGA</h2>

<p>We have one more task before we are done: connecting <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">this
timer</a>
to the rest of our design.  If you are using
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>,
that’s just as easy as adding the configuration file for this timer
to the <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
<a href="https://github.com/ZipCPU/tinyzip/blob/master/auto-data/Makefile">command line</a>.
Alternatively, we could <a href="/blog/2017/06/22/simple-wb-interconnect.html">connect this to the bus interconnect by
hand</a>,
but I think you’ll find it simpler to use
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.</p>

<p>Normally this isn’t necessary with the
<a href="/about/zipcpu.html">ZipCPU</a>
since the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">ZipTimer</a>
is already connected manually within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>
module, shown above in Fig 1.
Two recent <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
based designs, one for the
<a href="https://github.com/ZipCPU/arrowzip/">MAX-1000</a>
and another for the
<a href="https://github.com/ZipCPU/tinyzip">TinyFPGA</a> (neither quite complete),
however, don’t use the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>
but rather the bare
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
<a href="/about/zipcpu.html">ZipCPU</a> wrapper, shown in Fig 6.</p>

<table align="center" style="float: right"><caption>Fig 6. The ZipBones</caption><tr><td><img src="/img/zipbones.svg" alt="" width="320" /></td></tr></table>

<p>In each of these designs, you can find a
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
bustimer configuration within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
<a href="https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt">configuration</a>
file, since having the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
is so useful to the
<a href="/about/zipcpu.html">ZipCPU</a>–as
it would be to any
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a>.</p>

<p>You may recall from the general format of an
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
configuration file that the entries consist of <code class="highlighter-rouge">@KEY=VALUE</code> pairs.  They are
primarily used to tell
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
what text to copy and paste into a set of various project files.
If the <code class="highlighter-rouge">VALUE</code> takes less than a line, the <code class="highlighter-rouge">@KEY=VALUE</code> definition can be
placed on a single line.  Otherwise, all of the lines following <code class="highlighter-rouge">@KEY=</code> will
consist of the <code class="highlighter-rouge">VALUE</code> for that key.  Likewise, if the <code class="highlighter-rouge">VALUE</code> is numeric,
you can have
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
calculate the value by placing a <code class="highlighter-rouge">$</code> between the <code class="highlighter-rouge">@</code> and the <code class="highlighter-rouge">KEY</code> and so use
the <code class="highlighter-rouge">@$KEY=EXPRESSION</code> form.  Finally, to reference
one value, <code class="highlighter-rouge">@KEYONE=VALONE</code>, from within another, you would reference
it as <code class="highlighter-rouge">@$(KEYONE)</code> within the value portion of the second
<code class="highlighter-rouge">@KEYTWO=VALTWO</code> construct.</p>

<p>Perhaps this would make more sense if we walked through an example.</p>

<p>Every <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
component description begins with a <code class="highlighter-rouge">@PREFIX</code> tag.  This defines the beginning
of the component, as well as providing a name for the component.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@PREFIX=bustimer</code></pre></figure>

<p>I chose to call this device a <code class="highlighter-rouge">bustimer</code>.  Unlike other timers that might be
internal to other portions of the design, this one can be accessed from the
main <a href="/zipcpu/2017/11/07/wb-formal.html">wishbone bus</a>–hence
the name.</p>

<p>If you are following along from the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
<a href="https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt">configuration</a>
file, you can skip to the <code class="highlighter-rouge">@PREFIX=bustimer</code> line.  The information prior
defines how to connect the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
<a href="/about/zipcpu.html">ZipCPU</a>
wrapper to the bus.  A watchdog timer definition follows this one, all within
the same
<a href="https://github.com/ZipCPU/tinyzip/blob/master/auto-data/zipbones.txt">configuration</a>
file.</p>

<p>While <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
doesn’t require it, I often define a <code class="highlighter-rouge">@DEVID</code> tag.  I
primarily use this tag for contexts that don’t like lower case.
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
doesn’t do anything fancy with this tag, other then paste it into other
tags as I tell it to below.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@DEVID=BUSTIMER</code></pre></figure>

<p>The <a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v">main.v</a>
file of an
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
based project starts with a series of
<code class="highlighter-rouge">ifdef</code>’s just before the <code class="highlighter-rouge">module</code> declaration.  This allows a user to select
some items and not others, as well as capturing a set of dependencies of what
items depend upon others.  In this case, we have no dependencies, but we’ll
still create an <code class="highlighter-rouge">define</code> line in case something else depends upon this
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@ACCESS=@$(DEVID)_ACCESS</code></pre></figure>

<p>Now let’s connect our timer to a
<a href="/zipcpu/2017/05/29/simple-wishbone.html">wishbone bus</a>.
Specifically, we want to connect this component to the system
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
by default named <code class="highlighter-rouge">wb</code>.
We’ll also declare that this
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
is a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
slave whose result is always available and that never stalls,
<code class="highlighter-rouge">@SLAVE.TYPE=SINGLE</code>, and one that has only a single address, <code class="highlighter-rouge">@NADDR=1</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@SLAVE.BUS=wb
@SLAVE.TYPE=SINGLE
@NADDR=1</code></pre></figure>

<p>Actually connecting this to a
<a href="/zipcpu/2017/05/29/simple-wishbone.html">bus</a>
depends upon the code we want to place into our
<a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v">main.v</a>
file.  This is the purpose of the <code class="highlighter-rouge">@MAIN.INSERT</code> tag.  Code within
this tag will get copied directly (after variable name substitution) into the
<a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v">main.v</a>
file.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.INSERT=
	ziptimer @$(PREFIX)i(i_clk, i_reset, 1'b1,
			wb_cyc, (wb_stb)&amp;&amp;(@$(PREFIX)_sel), wb_we, wb_data,
				@$(PREFIX)_ack, @$(PREFIX)_stall,
				@$(PREFIX)_data, @$(PREFIX)_int);</code></pre></figure>

<p>While you don’t need to reference the <code class="highlighter-rouge">@$(PREFIX)</code> tag at all, I often use this
to help keep the names unique within any given design.  Once the pattern
matching takes place, these lines will just turn into:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.INSERT=
	ziptimer bustimeri(i_clk, i_reset, 1'b1,
			wb_cyc, (wb_stb)&amp;&amp;(bustimer_sel), wb_we, wb_data,
				bustimer_ack, bustimer_stall,
				bustimer_data, bustimer_int);</code></pre></figure>

<p>You don’t need to define the <code class="highlighter-rouge">bustimer_ack</code>, <code class="highlighter-rouge">bustimer_stall</code>, or
<code class="highlighter-rouge">bustimer_data</code> wires.
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
will define these for you once you tell it that this item is a
<a href="/zipcpu/2017/05/29/simple-wishbone.html">bus</a> slave.
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
will also create a <code class="highlighter-rouge">bustimer_sel</code> wire.  This wire will be true any time this
<a href="/zipcpu/2017/05/29/simple-wishbone.html">bus</a>
component’s address is selected.  You do need to connect these wires to your
component, as we’ve done above.</p>

<p>After running
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>,
you should then be able to find this code snipped in the
<a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v">main.v</a>,
file.
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
will also declare the rest of the wires necessary to set this up as well.</p>

<p>The last wire, <code class="highlighter-rouge">bustimer_int</code>, is also defined automatically by
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> as
part of generating and connecting up the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
wires.  In our case, we have a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v">programmable interrupt controller
(PIC)</a>
<a href="https://github.com/ZipCPU/tinyzip/blob/master/auto-data/pic.txt">defined elsewhere in the
design</a>
with the name of <code class="highlighter-rouge">buspic</code>.  Hence, all we need to tell
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
is that we have an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
named <code class="highlighter-rouge">BUSTIMER</code>, whose
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
wire is <code class="highlighter-rouge">bustimer_int</code>, that needs to be connected to the
<code class="highlighter-rouge">buspic</code>s inputs.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@INT.BUSTIMER.WIRE= @$(PREFIX)_int
@INT.BUSTIMER.PIC= buspic</code></pre></figure>

<p>This will add our <code class="highlighter-rouge">bustimer_int</code> to the list of components within the
<code class="highlighter-rouge">bus_int_vector</code>.  Hence, if you check the
<a href="https://github.com/ZipCPU/tinyzip/blob/master/rtl/main.v">main.v</a>
file, you’ll see the <code class="highlighter-rouge">bustimer_int</code> listed long with the other
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
lines.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">bus_int_vector</span> <span class="o">=</span> <span class="o">{</span>
	<span class="c1">// ...
</span>	<span class="n">bustimer_int</span><span class="o">,</span>
	<span class="c1">// ...
</span><span class="o">};</span></code></pre></figure>

<p>Internal to the
<a href="https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h">board.h</a>
file that
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
creates for the internal processor that might use this design, this will
also create a line,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	BUSPIC_BUSTIMER	BUSPIC(1)</span></code></pre></figure>

<p>after assigning this peripheral to
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
control wire number one.</p>

<p>The last two parts deal with non-Verilog parts of the design.  The first of
these deals with <a href="/blog/2017/06/29/sw-dbg-interface.html">connecting this device to the external debugging
interface</a>.
Specifically, we’ll want to create a register, <code class="highlighter-rouge">R_BUSTIMER</code>, with the human
name, <code class="highlighter-rouge">BUSTIMER</code>.  These next three lines adjust the files
<a href="https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.h">regdefs.h</a>
and <a href="https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp">regdefs.cpp</a>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@REGS.NOTE= // The bus timer
@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)</code></pre></figure>

<p>First, upon reading these lines,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
will place a definition into the
<a href="https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.h">regdefs.h</a>
output file, defining an
<code class="highlighter-rouge">R_BUSTIMER</code> identifier to be equivalent to the address of this
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
register.  This will tell external host components where in the memory
space to access this register when using <code class="highlighter-rouge">readio()</code> or <code class="highlighter-rouge">writeio()</code>.</p>

<p><a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
will also place references to this register into
<a href="https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp">regdefs.cpp</a>.
<a href="https://github.com/ZipCPU/tinyzip/blob/master/sw/host/regdefs.cpp">This file</a>
contains a mapping between the computer regiser name <code class="highlighter-rouge">R_BUSTIMER</code>
and the user name for this register, <code class="highlighter-rouge">BUSTIMER</code>.  As a result, you can then
use the <code class="highlighter-rouge">wbregs</code> program, a variant of the old fashioned
<a href="https://en.wikipedia.org/wiki/PEEK_and_POKE">peek and poke hardware interface</a>,
to read from the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
with the command <code class="highlighter-rouge">wbregs bustimer</code>, or to write to it via
<a href="/blog/2017/06/29/sw-dbg-interface.html"><code class="highlighter-rouge">wbregs bustimer newvalue</code></a>.
(I have another version of this program called <code class="highlighter-rouge">avregs</code> for use with the
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon bus</a>
on a
<a href="/blog/2018/02/09/first-cyclonev.html">Cyclone-V</a>
 …)</p>

<p>The last item places a reference to this
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
into the
<a href="https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h">board.h</a>
file.  This file would be used by the
<a href="/about/zipcpu.html">ZipCPU</a>
to know if the
<a href="/zipcpu/2017/11/07/wb-formal.html">bus</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
was built into the design and, if so, what address that
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
was placed into.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@BDEF.IONAME=_bustimer
@BDEF.IOTYPE=unsigned
@BDEF.OSDEF=_BOARD_HAS_@$(DEVID)
@BDEF.OSVAL=static volatile @$BDEF.IOTYPE *const @$(BDEF.IONAME) = ((@$BDEF.IOTYPE *)@$[0x%08x](REGBASE));</code></pre></figure>

<p><a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
will use this to create a line, similar to the following one, inside the
<a href="https://github.com/ZipCPU/tinyzip/blob/master/sw/zlib/board.h">board.h</a>
file:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#ifdef	BUSTIMER_ACCESS
#define	_BOARD_HAS_BUSTIMER
</span><span class="k">static</span> <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="k">const</span> <span class="n">_bustimer</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x00100000</span><span class="p">);</span>
<span class="cp">#endif	// BUSTIMER_ACCESS</span></code></pre></figure>

<p>Remember, the goal of
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
is to make the inclusion of
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
components into a design easier.  Hence, by placing these few lines into an
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
configuration file, this
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
will be included into the design.  Removing these lines from the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
configuration will seemlessly remove this
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
from the design.</p>

<h2 id="conclusions">Conclusions</h2>

<p>We’ve now gone over everything it takes to create a useful countdown timer
within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design–whether a “one-shot” timer, or a fully programmable
interval timer.  Once put together, the final <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">Verilog
code</a>
isn’t all that much more difficult than
the original counter we started out from.  What may surprise you, though,
is how much work we went through to place such a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">simple
counter</a>
into a design.  Not only did we
<a href="/blog/2017/10/19/formal-intro.html">formally</a>
verify our
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>,
but then we also had to connect it to the
<a href="/zipcpu/2017/11/07/wb-formal.html">wishbone bus</a>
within the design.  We also dealt with several subtle issues associated with
making a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
useful along the way.</p>

<p>What can you use such a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
for?</p>

<p>We’ve already discussed how this can be the centerpiece of the
<a href="https://en.wikipedia.org/wiki/Computer_multitasking">multitasking</a>
implementation within an
<a href="https://en.wikipedia.org/wiki/Operating_System">Operating System</a>.
Upon any
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>, the
<a href="https://en.wikipedia.org/wiki/Operating_System">Operating System</a>
can then swap user tasks or processes.
<a href="https://www.blueletterbible.org/kjv/jas/4/15">Should the Lord will</a>, I’ll
come back and share how one
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/s6soc">implementation</a>
<a href="https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c">uses this</a>
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
for exactly that purpose.</p>

<p>There’s another valuable use of a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>
such as this–one which may not be
as obvious.  In the presentation above, we discussed wiring the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
wire to the
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v">interrupt controller</a>.  If you instead connected the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
output to the reset wire for the
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a>,
you would have created a
<a href="https://en.wikipedia.org/wiki/Watchdog_timer">watchdog</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer</a>.</p>

<p>So you see, a basic counter isn’t nearly as irrelevant as you might have
thought it would be, neither is it as simple.  It’s also provides a very
good example of the full
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
<a href="/blog/2017/06/02/design-process.html">design process</a>.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And He said unto them, It is not for you to know the times or the seasons, which the Father hath put in His own power. (Acts 1:7)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
