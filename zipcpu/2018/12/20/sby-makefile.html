<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Makefiles for formal proofs with SymbiYosys</title>
  <meta name="description" content="It seems that the more I work with theZipCPU, the more options it accumulates.">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2018/12/20/sby-makefile.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Makefiles for formal proofs with SymbiYosys</h1>
    <p class="post-meta"><time datetime="2018-12-20T00:00:00-05:00" itemprop="datePublished">Dec 20, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>It seems that the more I work with the
<a href="/about/zipcpu.html">ZipCPU</a>, the more options it accumulates.</p>

<table align="center" style="float: right"><caption>Fig 1. <a href="/about/zipcpu.html">A CPU</a> with lots of options</caption><tr><td><a href="/img/zipcpu-config.png"><img src="/img/zipcpu-config.png" alt="" width="300" /></a></td></tr></table>

<p>I simplified the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU options</a>
somewhat to present Fig. 1, but you can see <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">all the CPU options and their
settings</a>
in the <a href="https://github.com/ZipCPU/zipcpu/">ZipCPU GitHub repository</a>.</p>

<p>First it was the prefetch: I built a <a href="/zipcpu/2017/11/18/wb-prefetch.html">basic
prefetch</a>, then <a href="/zipcpu/2018/03/21/dblfetch.html">one
that can issue two bus requests at
once</a>, then <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">one with
a fullly integrated
I-cache</a>.  In
each case, I wanted more performance but didn’t want to give up the ability of
building the <a href="/about/zipcpu.html">ZipCPU</a> in an extremely
low logic configuration.</p>

<p>Then it was <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/mpyop.v">the
multiplies</a>:
not every board I worked with had the embedded DSP elements required for
hardware accelerated multiplies.  Indeed, some that had embedded
DSP elements couldn’t handle a 32x32 bit multiply within a single clock
(Spartan 6).  This forced me into two separate multiplication implementations.
Then, the fact that the iCE40 has <em>no</em> DSPs lead to an <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/slowmpy.v">additional
multiplication
implementation</a>
just to handle that environment.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 2. The pipeline structure of the ZipCPU</caption><tr><td><img src="/img/zipcpu.png" alt="" width="531" />&gt;</td></tr></table>

<p>The <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v">initial memory
subsystem</a>,
while working, was cripplingly slow.  A <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v">faster memory subsystem was written to
replace it</a>,
and then a proper <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data
cache</a>
was written to replace that.  On top of that, the
<a href="/about/zipcpu.html">ZipCPU</a> can optionally support a
<a href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">lock instruction for atomic
access</a>,
a compressed instruction set, a set of CPU-local peripherals, and more.</p>

<p>If those weren’t enough changes, the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/idecode.v">instruction
decoder</a> needs to
support all of the various instruction set extensions.  Lock instructions need
to be honored by the memory module, unless no lock instruction is implemented.
Multiplication instructions need to be honored if enabled, while creating
illegal instruction exceptions if not.  Some of the options need special
decoding, such as the simulation instructions or the early
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branching</a>
instructions.</p>

<p>This leaves me with an ongoing and growing problem: how do you
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">a core</a>
that has so many options associated with it?</p>

<p>Let’s look at this problem from both the standpoint of the
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
script file, as well as a supporting
<a href="https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html">Makefile</a>.</p>

<h2 id="symbiyosys-tasks">SymbiYosys Tasks</h2>

<p>While the <a href="/about/zipcpu.html">ZipCPU</a> is highly
configurable, it doesn’t make sense to test every permutation of the various
configurations.  Therefore, let’s look over some of the more common
configuration settings used by the
<a href="/about/zipcpu.html">ZipCPU</a>.  More than that, we’ll give
each of these configurations names.  These names will us remember the
configuration set, as well as helping to make our
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
configuration simpler in a moment.</p>

<ul>
  <li>
    <p>dcache</p>

    <p>This new option describes a configuration that uses the brand new
(<a href="/blog/2017/10/19/formal-intro.html">formally verified</a>,
Xilinx Series-7 proven) <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data
cache</a>.  If
you want performance from the <a href="/about/zipcpu.html">ZipCPU</a>,
this is no-holds barred attempt at high speed and full features.</p>

    <p>This is the configuration I am testing within my
<a href="https://github.com/ZipCPU/openarty">OpenArty</a> project, in case you want to
see it in action.  (You may need to check out the <a href="https://github.com/ZipCPU/openarty/tree/dev">dev
branch</a> where it exists
today.)</p>
  </li>
  <li>
    <p>piped</p>

    <p>Prior to the <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data
cache</a>, this
configuration was the no-holds barred high speed, full
featured <a href="/about/zipcpu.html">ZipCPU</a> version.  It
describes a fully pipelined implementation containing an
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">instruction cache</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/mpyop.v">multiplies</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divides</a>,
compressed instruction set, and early branching capability.  (The
early branching capability allows you to branch from the decode stage,
without waiting for the later stages.  It applies only to unconditional
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branches</a>.)</p>
  </li>
  <li>
    <p>nopipe</p>

    <p>This is the same thing, only we shut down everything we don’t need: no
pipeline CPU (forcing a minimum of 3 clocks per instruction), no
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/mpyop.v">multiplies</a>,
no <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide
instructions</a>,
but still supports the compressed instruction set.</p>
  </li>
  <li>
    <p>lowlogic</p>

    <p>Much to my surprise, the no-pipelined option wasn’t as small as I needed to
get for some implementations, so this version drops the compressed
instruction set support.</p>
  </li>
  <li>
    <p>ice40</p>

    <p>Didn’t we get rid of enough stuff yet?</p>

    <p>Apparently not.</p>

    <p>The <a href="/formal/2018/07/21/zipcpu-icoboard.html">iCE40 doesn’t support distributed
RAM</a>.  All reads
from the register file need to go directly into a register first, and only
on the next clock can we do anything with them.</p>
  </li>
</ul>

<p>Using
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>,
we can declare different “tasks” to verify each of these
configurations.  The following code declares five such “tasks”, one on
each line.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[tasks]
dcache		full_proof      dcache
piped		full_proof      no_dcache
nopipe		nopipe          no_dcache
lowlogic	nopipe		no_dcache
ice40		nopipe          no_dcache	nobkram</code></pre></figure>

<p>Notice the format of this section.  It starts with a <code class="language-plaintext highlighter-rouge">[tasks]</code> line.  Every
line thereafter begins with the name of a task.  In our case, these represent
the various configurations we just outlined above.  The second half of the line
is more interesting.  This consists of a series of labels which will also be
accepted as task names later.  That way, we can specify <code class="language-plaintext highlighter-rouge">ice40</code> and get
all of the <code class="language-plaintext highlighter-rouge">nopipe</code> (non-pipelined) options, together with the <code class="language-plaintext highlighter-rouge">no_dcache</code>
option and the more critical <code class="language-plaintext highlighter-rouge">nobkram</code> option.</p>

<table align="center" style="float: right"><caption>Fig 3. One command per line</caption><tr><td><img src="/img/sby-taskcmd.svg" alt="taskname: yosys-cmd" width="300" /></td></tr></table>
<p>How might we use this?  There are two basic approaches.  First, we can begin
any line following in our
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
script with a task name followed by a colon.  Once done, everything
following is only executed if that given task name is the active
task.  This applies to the aliased names as well, such as <code class="language-plaintext highlighter-rouge">full_proof</code> or
<code class="language-plaintext highlighter-rouge">no_dcache</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[options]
mode prove
depth 18
dcache:   depth  9
piped:    depth 14
nopipe:   depth 11
lowlogic: depth 10
ice40:    depth 11</code></pre></figure>

<p>So far, this is kind of interesting but not all that useful.</p>

<p>Let’s consider some other things <a href="http://www.clifford.at/yosys">yosys</a> offers.</p>

<p>Using <a href="http://www.clifford.at/yosys">yosys</a>,
you can set a macro.  You might recognize macros by their Verilog usage:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// Define a macro, NO_DISTRIBUTED_RAM</span>
<span class="cp">`define</span>	NO_DISTRIBUTED_RAM<span class="cp">
</span><span class="c1">//</span>
<span class="cp">`ifdef</span> <span class="n">NO_DISTRIBUTED_RAM</span>
  <span class="c1">// Code that only gets executed if `NO_DISTRIBUTED_RAM` is defined</span>
<span class="cp">`else</span>
  <span class="c1">// Code that only gets executed if `NO_DISTRIBUTED_RAM` is not defined</span>
<span class="cp">`endif</span></code></pre></figure>

<p>One problem with this sort of declaration is that it isn’t clear whether the
macro defined in one file will remain active in another.</p>

<p>Alternatively, we could use a
<a href="http://www.clifford.at/yosys">yosys</a>
<a href="http://www.clifford.at/yosys/cmd_read.html">command to set this macro</a>
but only for some configurations.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[script]
nobkram: read -define -DNO_DISTRIBUTED_RAM
read -define -DZIPCPU
#
# ... files the ZipCPU depends upon have been skipped here
# for brevity
#
read -formal zipcpu.v</code></pre></figure>

<p>This defines the macro <code class="language-plaintext highlighter-rouge">NO_DISTRIBUTED_RAM</code> across all input files, but only
if <code class="language-plaintext highlighter-rouge">nobkram</code> is the active task.  Likewise, <code class="language-plaintext highlighter-rouge">ZIPCPU</code> is defined for all
tasks.  This latter definition is how I handle <a href="/formal/2018/12/18/skynet.html">telling submodules if they
are being verified as separate modules or as submodules
instead</a>.</p>

<p>Another very useful <a href="http://www.clifford.at/yosys">yosys</a>
command is the <a href="http://www.clifford.at/yosys/cmd_chparam.html"><code class="language-plaintext highlighter-rouge">chparam</code>
command</a>.  You can use this to change
the value of any parameter within your logic.  As examples, the
<a href="/about/zipcpu.html">ZipCPU</a> has several high
level parameters.  Perhaps you may have noticed some of them in Fig 1. above.
For example, <code class="language-plaintext highlighter-rouge">IMPLEMENT_FPU</code> is a single bit parameter
that controls whether the (still not yet existent) floating point unit (FPU)
is included.  As a more relevant example, <code class="language-plaintext highlighter-rouge">OPT_LGDCACHE</code> controls the size
of the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data cache</a>,
and whether the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data cache</a>,
is included at all.  If this value is set to zero, no
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data cache</a>
will be included in the build, whereas if it is non-zero it sets the size
of the cache.</p>

<table align="center" style="float: right"><caption>Fig 4. Associating multiple lines with a given script</caption><tr><td><img src="/img/sby-taskcmd-set.svg" alt="" width="300" /></td></tr></table>

<p>For this, we’ll use the second approach for specifying task-configurations,
as shown in Fig. 4 on the right.  In this case, we can start a set of
task-specific commands using the task name and a colon on a line by itself.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">chparam -set IMPLEMENT_FPU    0 zipcpu

dcache:
chparam -set OPT_LGDCACHE    10 zipcpu

no_dcache:
chparam -set OPT_LGDCACHE     0 zipcpu</code></pre></figure>

<p>This process is continued until either another task name, or
until a line containing two <code class="language-plaintext highlighter-rouge">-</code>s by themselves.  Hence, the definition of the
<code class="language-plaintext highlighter-rouge">full_proof</code> <a href="/about/zipcpu.html">ZipCPU</a> configuration shown
below, as well as the minimal <code class="language-plaintext highlighter-rouge">nopipe</code>-lined option and the even more
minimal <code class="language-plaintext highlighter-rouge">lowlogic</code> option.  When done, the <code class="language-plaintext highlighter-rouge">--</code> line specifies that all the
tasks join together again for the lines following.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">full_proof:
chparam -set IMPLEMENT_MPY    1 zipcpu
chparam -set IMPLEMENT_DIVIDE 1 zipcpu
chparam -set EARLY_BRANCHING  1 zipcpu
chparam -set OPT_CIS          1 zipcpu
chparam -set OPT_PIPELINED    1 zipcpu

nopipe:
chparam -set IMPLEMENT_MPY    0 zipcpu
chparam -set IMPLEMENT_DIVIDE 0 zipcpu
chparam -set EARLY_BRANCHING  0 zipcpu
chparam -set OPT_CIS          1 zipcpu
chparam -set OPT_PIPELINED    0 zipcpu

lowlogic:
chparam -set OPT_CIS 0 zipcpu
--

prep -top zipcpu</code></pre></figure>

<p>Now, just the one command</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% sby <span class="nt">-f</span> zipcpu.sby</code></pre></figure>

<p>will attempt to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
the entire
<a href="/about/zipcpu.html">ZipCPU</a> in <em>all</em> of these various
configurations.  For each configuration,
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
will create a directory,
such as <code class="language-plaintext highlighter-rouge">zipcpu_dcache</code>, <code class="language-plaintext highlighter-rouge">zipcpu_full</code>, or <code class="language-plaintext highlighter-rouge">zipcpu_lowlogic</code>.  Within this
directory, you’ll find the <code class="language-plaintext highlighter-rouge">logfile.txt</code> containing the standard output from
the run.  You can use this to find out whether your design passed that proof,
or if not what assertion or cover statement failed.  You’ll also find an
<code class="language-plaintext highlighter-rouge">engine_0</code> directory with any trace files within it.  (Why <code class="language-plaintext highlighter-rouge">engine_0</code>?
Because I tend to only ever use one
<a href="/blog/2017/10/19/formal-intro.html">formally verification</a>
engine.  Otherwise you might have other engines as well.)</p>

<h2 id="using-make-to-drive-symbiyosys">Using Make to drive SymbiYosys</h2>

<p>There’s one other thing
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
provides that is very valuable from a scripting standpoint.  Upon
completion,
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
will create an empty file in the newly created results
directory indicating the results of the run.  Example files include
<code class="language-plaintext highlighter-rouge">ERROR</code>, <code class="language-plaintext highlighter-rouge">FAIL</code>, <code class="language-plaintext highlighter-rouge">PASS</code>, and <code class="language-plaintext highlighter-rouge">UNKNOWN</code>.  This file makes it easy to create a
<a href="https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html">Makefile</a>.
to support several
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
runs, and we only need use the <code class="language-plaintext highlighter-rouge">PASS</code> file to do it.</p>

<p>Let’s pick an example component to verify, such as the <a href="/zipcpu/2018/04/17/ziptimer.html">ZipTimer
that we discussed earlier</a>.
The <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">timer itself</a>
has no real configuration options, so to verify it we could just place the
following two lines into our
<a href="https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html">Makefile</a>.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">ziptimer</span><span class="o">:</span>
	sby <span class="nt">-f</span> ziptimer.sby</code></pre></figure>

<p><a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>,
however, will make a directory called <code class="language-plaintext highlighter-rouge">ziptimer</code> upon every run.
Once this directory exists, <a href="https://www.gnu.org/software/make">make</a> will no longer run our proof.  However, if
we tell <a href="https://www.gnu.org/software/make">make</a> that <code class="language-plaintext highlighter-rouge">ziptimer</code> is just a
name of something to do and not a file, we can create the functionality we want.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">ziptimer</span>
<span class="nl">ziptimer</span><span class="o">:</span>
	sby <span class="nt">-f</span> ziptimer.sby</code></pre></figure>

<p><a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/formal/Makefile">This Makefile</a>
will now command a
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>,
proof everytime we try to <a href="https://www.gnu.org/software/make">make</a> the <code class="language-plaintext highlighter-rouge">ziptimer</code> target.</p>

<p>But what if the
<a href="/zipcpu/2018/04/17/ziptimer.html">ZipTimer</a>
hasn’t changed?  Why should we re-verify it if <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">the code within
it</a>
hasn’t changed, and if it passed the last time?</p>

<p>Here is where <a href="https://www.gnu.org/software/make">make</a> starts to shine.  Since <code class="language-plaintext highlighter-rouge">ziptimer/PASS</code> is a file, created
upon successful completion of the
<a href="/blog/2017/10/19/formal-intro.html">formally verification</a>
pass, we can tell
<a href="https://www.gnu.org/software/make">make</a>
that this file is created from the files the
<a href="/zipcpu/2018/04/17/ziptimer.html">ZipTimer</a>.
depends upon.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">ziptimer</span>
<span class="nl">ziptimer</span><span class="o">:</span> <span class="nf">ziptimer/PASS</span>
<span class="nl">ziptimer/PASS</span><span class="o">:</span> <span class="nf">../../rtl/peripherals/ziptimer.v</span>
	sby <span class="nt">-f</span> ziptimer.sby</code></pre></figure>

<p>Now, anytime the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">ziptimer.v file</a>
changes, <a href="https://www.gnu.org/software/make">make</a> will attempt to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
it again.  Further, should the proof fail, the <code class="language-plaintext highlighter-rouge">PASS</code> file will not get
created, and so the next time we call
<a href="https://www.gnu.org/software/make">make</a> it will attempt to create this
file again until our proof passes.</p>

<p>What if we wanted to
<a href="/blog/2017/10/19/formal-intro.html">verify</a>
a lot of things?  Rather than running 
<a href="https://www.gnu.org/software/make">make</a> many times, once per target, we might
instead start our
<a href="https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html">Makefile</a>
with a list of proofs, containing both the components as well as larger proofs.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">TESTS </span><span class="o">:</span>  <span class="nf">ziptimer</span>
<span class="nv">TESTS</span> <span class="o">+=</span> zipcpu
<span class="nl">all</span><span class="o">:</span> <span class="nf">$(TESTS)</span></code></pre></figure>

<p>Now, if <code class="language-plaintext highlighter-rouge">all</code> is the default <a href="https://www.gnu.org/software/make">make</a> target,
as defined by being the first target within our
<a href="https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html">Makefile</a>,
then all of the tests named in <code class="language-plaintext highlighter-rouge">$(TESTS)</code> will get built, er … verified.</p>

<p>Let’s clean this up a little more with some definitions.  Since I like to keep
my <a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
<a href="https://github.com/ZipCPU/zipcpu/tree/master/bench/formal">scripts</a>
separate from <a href="https://github.com/ZipCPU/zipcpu/tree/master/rtl">my Verilog
files</a>, it might help
to use a name for that path to simplify it.  Here, we use <code class="language-plaintext highlighter-rouge">RTL</code>.  Once
defined, this value will get substituted anytime we reference <code class="language-plaintext highlighter-rouge">$(RTL)</code>.
Likewise we’ll shorten the name of our target <code class="language-plaintext highlighter-rouge">ziptimer</code> to <code class="language-plaintext highlighter-rouge">$(TMR)</code>.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nv">RTL</span> <span class="o">:=</span> ../../rtl

<span class="nv">TMR</span> <span class="o">:=</span> ziptimer</code></pre></figure>

<p>We can also define the names of our <a href="/zipcpu/2017/11/07/wb-formal.html">formal wishbone
property sets</a>.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nv">MASTER</span> <span class="o">:=</span> <span class="nv">$(RTL)</span>/ex/fwb_master.v
<span class="nv">SLAVE</span>  <span class="o">:=</span> <span class="nv">$(RTL)</span>/ex/fwb_slave.v</code></pre></figure>

<p>Putting all this together, the script now says that …</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">$(TMR)</code> is a “phony” target that doesn’t build a file.</li>
</ol>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">$(TMR)</span></code></pre></figure>

<ol start="2">
  <li>To build <code class="language-plaintext highlighter-rouge">$(TMR)</code> we need to first build <code class="language-plaintext highlighter-rouge">$(TMR)/PASS</code>.  Why the extra step?
Just so that we can run <code class="language-plaintext highlighter-rouge">make ziptimer</code> later, rather than <code class="language-plaintext highlighter-rouge">make
ziptimer/PASS</code> or worse <code class="language-plaintext highlighter-rouge">make ziptimer_timerconfiguration/PASS</code> for
every
<a href="/zipcpu/2018/04/17/ziptimer.html">timer</a>
configuration we might have.</li>
</ol>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">$(TMR)</span><span class="o">:</span> <span class="nf">$(TMR)/PASS</span></code></pre></figure>

<ol start="3">
  <li>Finally, we can call
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
to <a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
our <a href="/zipcpu/2018/04/17/ziptimer.html">timer</a>.
This proof is dependent upon not only the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">code for the timer
itself</a>,
but also a <a href="/zipcpu/2017/11/07/wb-formal.html">list of formal wishbone
properties</a>.
These are called dependency files, or sometimes just dependencies
for short, because the validity of our proof <em>depends</em> upon these files.
By listing these dependencies to the right of the <code class="language-plaintext highlighter-rouge">:</code>,
<a href="https://www.gnu.org/software/make">make</a> will only
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
our <a href="/zipcpu/2018/04/17/ziptimer.html">timer</a>
if either the <code class="language-plaintext highlighter-rouge">$(TMR)/PASS</code> file is missing, or if one of the
dependency files is newer than the <code class="language-plaintext highlighter-rouge">$(TMR)/PASS</code> file.</li>
</ol>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">$(TMR)/PASS</span><span class="o">:</span> <span class="nf">$(TMR).sby $(RTL)/peripherals/$(TMR).v $(SLAVE)</span>
	sby <span class="nt">-f</span> <span class="nv">$(TMR)</span>.sby</code></pre></figure>

<p>This is exactly what we want from a
<a href="https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html">Makefile</a>!
Running  <a href="https://www.gnu.org/software/make">make</a> will run all of our <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a> proofs,
but once all the logic is
<a href="/blog/2017/10/19/formal-intro.html">verified</a>,
running
<a href="https://www.gnu.org/software/make">make</a> will just return a message telling
us it has nothing to do.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make
make: Nothing to be <span class="k">done for</span> <span class="s1">'all'</span><span class="nb">.</span>
<span class="err">$</span></code></pre></figure>

<p>But how shall we handle the multiple configurations we discussed earlier?</p>

<p>Why not set up one proof per configuration?</p>

<p>Let’s examine the proof of the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">core</a>
itself.  Remember how we had so many configurations above?  What if the
<code class="language-plaintext highlighter-rouge">PASS</code> file associated with each configuration was a
<a href="https://www.gnu.org/software/make">make</a> target?</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nv">CPU</span> <span class="o">:=</span> zipcpu
<span class="c"># ...
</span>
<span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">$(CPU)</span>
<span class="c"># Proofs to build
</span><span class="nl">$(CPU)</span><span class="o">:</span> <span class="nf">$(CPU)_dcache/PASS $(CPU)_piped/PASS</span>
<span class="nl">$(CPU)</span><span class="o">:</span> <span class="nf">$(CPU)_nopipe/PASS $(CPU)_lowlogic/PASS $(CPU)_ice40/PASS</span>
<span class="c"># Files the proofs depend upon
</span><span class="nv">CPUDEPS</span><span class="o">:=</span> <span class="nv">$(RTL)</span>/core/<span class="nv">$(CPU)</span>.v <span class="nv">$(RTL)</span>/core/cpuops.v <span class="nv">$(RTL)</span>/core/idecode.v <span class="se">\</span>
	<span class="nv">$(RTL)</span>/core/pipemem.v <span class="nv">$(RTL)</span>/core/memops.v			  <span class="se">\</span>
	<span class="nv">$(RTL)</span>/ex/wbdblpriarb.v <span class="nv">$(RTL)</span>/ex/fwb_counter.v <span class="nv">$(RTL)</span>/cpudefs.v  <span class="se">\</span>
	f_idecode.v abs_div.v abs_prefetch.v abs_mpy.v <span class="nv">$(MASTER)</span> <span class="nv">$(SLAVE)</span> <span class="se">\</span>
	<span class="nv">$(CPU)</span>.sby
<span class="c"># Now one line for each proof, to build the respective &lt;sbydir&gt;/PASS files
</span><span class="nl">$(CPU)_dcache/PASS</span><span class="o">:</span> <span class="nf">$(CPUDEPS)</span>
	sby <span class="nt">-f</span> <span class="nv">$(CPU)</span>.sby dcache

<span class="nl">$(CPU)_piped/PASS</span><span class="o">:</span> <span class="nf">$(CPUDEPS)</span>
	sby <span class="nt">-f</span> <span class="nv">$(CPU)</span>.sby piped

<span class="nl">$(CPU)_nopipe/PASS</span><span class="o">:</span> <span class="nf">$(CPUDEPS)</span>
	sby <span class="nt">-f</span> <span class="nv">$(CPU)</span>.sby nopipe

<span class="err">#</span> <span class="err">You</span> <span class="err">should</span> <span class="err">get</span> <span class="err">the</span> <span class="err">idea</span> <span class="err">by</span> <span class="err">this</span> <span class="err">point</span></code></pre></figure>

<p>Once accomplished, one simple command,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% make</code></pre></figure>

<p>will run all of the proofs we have described within our
<a href="https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html">Makefile</a>.
This includes calling <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
to <a href="/blog/2017/10/19/formal-intro.html">verify</a> every one of
the <a href="/about/zipcpu.html">ZipCPU</a>’s various configurations.</p>

<p>Once completed, or even before, you can run</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% make <span class="nt">-n</span></code></pre></figure>

<p>to see what proofs have yet to be completed, or equivalently which proofs have
failed–assuming in the latter case that
<a href="https://www.gnu.org/software/make">make</a> has completed.</p>

<p>Of course, the problem with using <code class="language-plaintext highlighter-rouge">make -n</code> to determine which proofs have
failed is what happens after only one proof fails.  After the first proof
fails, <a href="https://www.gnu.org/software/make">make</a> will give you no
information about whether or not the remaining proofs might pass.
Alternatively, if you don’t want
<a href="https://www.gnu.org/software/make">make</a> to stop on the first failed proof,
you can instead run,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% make <span class="nt">-k</span></code></pre></figure>

<p>Want to use all of your host processors multiple cores?  You could specify
<code class="language-plaintext highlighter-rouge">make -k -j &lt;ncpus&gt;</code> to use all <code class="language-plaintext highlighter-rouge">&lt;ncpus&gt;</code> of them.  However, this might
leave some of your build cores overloaded during induction.  For
this reason, I’ve considered running <code class="language-plaintext highlighter-rouge">make -n -j &lt;ncpus/2&gt;</code> instead.</p>

<p>What’s all this good for?  Well, for me this means I can verify my brand new
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data cache</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v">instruction cache</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/idecode.v">instruction decoder</a>,
several arbiters, … and the <a href="/about/zipcpu.html">ZipCPU</a>
itself
from one <code class="language-plaintext highlighter-rouge">make</code> command.  If the <code class="language-plaintext highlighter-rouge">make</code> command fails, I can go back and
examine the respective <code class="language-plaintext highlighter-rouge">logfile.txt</code>s to see why.  Likewise, if I want
to know what proofs need to be re-accomplished, I can just type <code class="language-plaintext highlighter-rouge">make -n</code>
to see what <code class="language-plaintext highlighter-rouge">make</code> would try to build if you ran it again.</p>

<p>With a little more work, I could split the list of Verilog files, <code class="language-plaintext highlighter-rouge">$(CPUDEPS)</code>,
into a more finer grained list, so that all of the CPU configurations
don’t need to be re-verified every time one file, used only by some
configurations, changes.</p>

<h2 id="conclusions">Conclusions</h2>

<p>When I first started using this approach of testing multiple configurations
automatically using
<a href="https://www.gnu.org/software/make">make</a>,
I immediately found several errors within code that I had assumed was working.
The first bug was in the <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/memops.v">memory
component</a>,
where it wasn’t properly handling a misaligned address exception (an option
that wasn’t checked by default).  The second bug was within the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pfcache.v">I-cache</a>,
that I am hoping to blog about soon.  Since I had only verified the safety
properties within it, that is the <code class="language-plaintext highlighter-rouge">assert()</code>s given the assumptions, I hadn’t
noticed that certain assumptions rendered the <a href="https://en.wikipedia.org/wiki/Vacuous_truth">proof
vacuous</a>.
Now, using these multiple configurations, I can both prove the assertions
and run cover to be even more certain that the various
<a href="/about/zipcpu.html">ZipCPU</a> components work.</p>

<p>So even though I’ve only started using this approach in the most recent
<a href="https://github.com/ZipCPU/zipcpu">release of the ZipCPU</a>, because of the
bugs I’ve found with it using this new approach, I now like it so much that
I’m likely to slowly modify all of the
<a href="https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html">Makefile</a>s
within my <a href="/projects.html">various projects</a> to use this
approach as I have opportunity.  Even if the core in question isn’t
configurable, I’m going to make certain I do this in order to guarantee that
the <code class="language-plaintext highlighter-rouge">cover()</code> checks run automatically.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Then I saw, and considered it well: I looked upon it, and received instruction. (Prov 24:32)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
