<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>AutoFPGA's linker script support gets an update</title>
  <meta name="description" content="It’s been a while since I’ve discussedAutoFPGA.  If youremember from my introduction toit, it’s a System ona Chip composition tool designed to compose a desi...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2018/12/22/autofpga-ld.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">AutoFPGA's linker script support gets an update</h1>
    <p class="post-meta"><time datetime="2018-12-22T00:00:00-05:00" itemprop="datePublished">Dec 22, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>It’s been a while since <a href="/zipcpu/2017/10/05/autofpga-intro.html">I’ve discussed
AutoFPGA</a>.  If you
remember from <a href="/zipcpu/2017/10/05/autofpga-intro.html">my introduction to
it</a>, it’s a System on
a Chip composition tool designed to compose a design together from multiple
components.  While most of the work it does consists of copying tags from a
configuration file to one of several output files, it will also assign
addresses to peripherals on a bus and create an interconnect to connect
those peripherals together.</p>

<p>I’ve now used <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> on several of <a href="/projects.html">my projects</a>.  I used it
first on my <a href="https://github.com/ZipCPU/videozip">VideoZip</a>
<a href="/projects.html">project</a>.  I maintain a
<a href="https://github.com/ZipCPU/zbasic">ZipCPU simulation test capability in ZBasic</a>,
another project that uses <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.  My iCE40 designs, both
<a href="https://github.com/ZipCPU/icozip">ICOZip</a> for the
<a href="http://www.icoboard.org">icoboard</a> and
<a href="https://github.com/ZipCPU/tinyzip">TinyZip</a> for the
<a href="https://tinyfpga.com">TinyFPGA BX</a>, both use
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.  Even
<a href="https://github.com/ZipCPU/openarty">OpenArty</a> is slowly getting an
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
<a href="https://github.com/ZipCPU/openarty/tree/dev">upgrade</a>.</p>

<p>Why?  Because (when done right) it makes it <em>easy</em> to compose systems from
other components.  Components may be added to or removed from a design simply
by adding or removing them from the 
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
command line and rebuilding.</p>

<p>Why not other tools?  Because I really didn’t want to learn another language
besides the <a href="/tutorial">Verilog</a>,
<a href="http://www.cplusplus.com/doc/tutorial">C++</a>,
<a href="https://www.gnu.org/software/make">make</a>,
and so forth that I already work with.  But aren’t
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
scripts a new language in themselves?
To some extent this is true, although the purpose of 
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
remains being a tool that does its job and gets out of the way.</p>

<p>However, when I went to build a design for the
<a href="/blog/2018/10/05/tinyfpga.html">TinyFPGA BX</a>, I
discovered a big hole in
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>’s
capabilities.  While it has always created linker scripts,
the script it has created hasn’t had the flexibility required to handle
such diverse designs as the very spartan
<a href="/blog/2018/10/05/tinyfpga.html">TinyFPGA BX</a>
as well as the more full featured <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications">Nexys
Video</a>
board from <a href="https://store.digilentinc.com">Digilent</a>.</p>

<h2 id="understanding-the-problem">Understanding the problem</h2>

<p>To understand the problem, we’ll need to take a look at how memory is used
within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
<a href="https://en.wikipedia.org/wiki/System_on_a_chip">SoC</a>
design.</p>

<p>The
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
within an <a href="https://en.wikipedia.org/wiki/System_on_a_chip">SoC</a>
needs access to memory for several purposes.  It needs
a <a href="https://en.wikipedia.org/wiki/Code_segment">place to store its instructions</a>,
another space for <a href="https://wikipedia.org/wiki/Data_segment">global data
structures</a>,
another space for allocable data structures commonly called a
<a href="https://wikipedia.org/wiki/Data_segment#Heap">heap</a>, and finally
a <a href="https://wikipedia.org/wiki/Data_segment#Stack">stack space</a>
to support local variables.</p>

<table align="center" style="float: right"><caption>Fig 1. A common address space layout</caption><tr><td><img src="/img/ld-segments.svg" alt="" width="240" /></td></tr></table>

<p>One common arrangement of the address space to support these <a href="https://wikipedia.org/wiki/Memory_segmentation">various
purposes</a>
contains a keep out region near
zero, followed by
<a href="https://en.wikipedia.org/wiki/Code_segment">code instructions</a>,
<a href="https://wikipedia.org/wiki/Data_segment">data structures</a>,
the <a href="https://wikipedia.org/wiki/Data_segment#Heap">heap</a>, and then a
<a href="https://wikipedia.org/wiki/Data_segment#Stack">stack</a>
in that order, as shown in Fig 1.  The
<a href="https://wikipedia.org/wiki/Data_segment#Stack">stack</a>
typically starts at the
end of memory and grows upwards with each subroutine call, whereas the
<a href="https://wikipedia.org/wiki/Data_segment#Heap">heap</a>
typically starts at the end of global variable memory and grows downwards
with each <code class="highlighter-rouge">malloc()</code> call.</p>

<p>However, <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
systems tend not to have one monolithic type of memory.  They
typically have several memory types within any design.  These basic
memories include:</p>

<ul>
  <li>
    <p><a href="/blog/2018/08/16/spiflash.html">Flash memory</a></p>

    <p>This is a slow non-volatile memory.  It is great for initial instructions
to get a program off the ground.  Since it is slow to access, it may not
be ideal to execute programs from, although small designs may need to do
just that.</p>

    <p>The two big details you need to know are that
<a href="/blog/2018/08/16/spiflash.html">flash</a>
is slow, and it is very difficult to write to as part of a program.
This makes it really good as a
<a href="https://en.wikipedia.org/wiki/Read-only_memory">ROM</a> memory, but not so
great for other purposes.</p>
  </li>
  <li>
    <p><a href="/zipcpu/2018/07/13/memories.html">Block RAM</a></p>

    <p>This is the ideal type of
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
you’d want to use in any system.  It is fast.  It’s simple to use and
create.  The cost to access one part of
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>
is the same as the cost to access any other part of
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.</p>

    <p>The big downside of
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>?
You only have a limited amount of it.  For
example, the iCE40HX8k FPGA typically has only about 8kB of usable
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.
Yes, the data sheet will claim 16kB of
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.
Realistically, some of that 16kB will be used <a href="/2018/07/21/zipcpu-icoboard.html">elsewhere in the
design</a>, so the most
you are likely to get is probably going to be about 8kB of
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Static_random-access_memory">Static RAM (SRAM)</a></p>

    <p>This is similar to
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>,
but not quite as fast or as simple to work with.  Like
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>,
it is volatile.  However, it tends to be off chip, slower to access,
fairly easy to build <a href="https://github.com/zipCPU/icozip/blob/master/rtl/icozip/sramdev.v">a
controller</a> for,
and it also cheap enough that you can have more memory than
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.
The drawback is the technology within:
<a href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a>
tends to use more power and take more room than the <a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">dynamic types of
RAM</a>.</p>

    <p>One cool feature of
<a href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a>
is that if you ignore it, and don’t cut the power,
the memory doesn’t change.  As a result,
<a href="https://store.digilentinc.com">Digilent</a>
once had a <a href="https://store.digilentinc.com/nexys-4-artix-7-fpga-trainer-board-limited-time-see-nexys4-ddr/">Nexys board design</a>
that allowed you to load the
<a href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a>
with one
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
configuration, and then swap
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
configurations.  Sadly, the <a href="https://store.digilentinc.com/nexys-4-artix-7-fpga-trainer-board-limited-time-see-nexys4-ddr/">board with this
capability</a>
is no longer actively marketed and there may only be a small number of
<a href="https://store.digilentinc.com/nexys-4-artix-7-fpga-trainer-board-limited-time-see-nexys4-ddr/">these boards</a>
left.  As I understand the story, <a href="https://store.digilentinc.com">Digilent</a>
struggled to get the
<a href="https://en.wikipedia.org/wiki/Static_random-access_memory">SRAM</a> chips they
needed to continue manufacturing the boards, and so they were forced to
switch to
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>.</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">Synchronous, Dynamic Random Access Memory (SDRAM)</a></p>

    <p>The big grandaddy of all RAM devices tend to be the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>s.</p>

    <p>By this I’m going to include not only the simpler
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>s,
but also the
<a href="https://en.wikipedia.org/wiki/DDR_SDRAM">DDR</a>,
<a href="https://en.wikipedia.org/wiki/DDR2_SDRAM">DDR2</a>, and
<a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>s.
Since these
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
devices are built out of capacitors,
the memory can be made compact, and so they are inexpensive to manufacture,
and therefore some of the cheapest
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a> devices
to purchase.  The
biggest drawbacks to
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
are that the controllers tend to be complex,
and the access latency tends to be high.  How hard are the controllers?  Well,
let’s just say that I have yet to complete my first working
<a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>
<a href="https://opencores.org/projects/wbddr3">controller</a>.  I know it’s possible,
since <a href="https://www.librecores.org/enjoy-digital/litedram">LiteDRAM</a> has
built some awesome
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
controllers.
Other than that,
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>s
tend to be high volume low cost devices.</p>
  </li>
  <li>
    <p><a href="https://www.cypress.com/products/hyperram-memory">Hyperram</a></p>

    <p>A newcomer to the digital design space are the
<a href="https://www.cypress.com/products/hyperram-memory">Hyperram chips</a>.
These really belong in the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
category above, since they tend to be built from
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>s
internally.  The big difference is that
<a href="https://www.cypress.com/products/hyperram-memory">HyperRAM</a>s
have a simpler interface that is easy to build a controller for.  Likewise,
<a href="https://www.cypress.com/products/hyperram-memory">HyperRAM</a>s
tend to have lower latencies than many other DDR
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
solutions, since the complex
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
array control is handled within the
<a href="https://www.cypress.com/products/hyperram-memory">HyperRAM</a>
chip itself.</p>
  </li>
</ul>

<p>Ok, so that’s what we have to play with.  What might an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
<a href="https://en.wikipedia.org/wiki/Address_space">address space</a>
look like with these various types of
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>s?</p>

<h4 id="block-ram-only">Block RAM Only</h4>

<p>The simplest memory configuration we might build would be a
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a> only
configuration.  This configuration would be built as though there were no
other memories in the system.  It would typically consist of a keep-out
address range near zero, addresses for the various peripherals, then the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>
address itself.</p>

<table align="center" style="float: none"><caption>Fig 2. Block RAM and peripherals only</caption><tr><td><img src="/img/ld-bkram.svg" alt="" width="780" /></td></tr></table>

<p>Of course, the problem with this configuration is that
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>
is both limited and volatile:
it won’t have the values we need within it when we power up our new design, or
later when we reset our design.  Still, this is a great memory model if you
are first bringing up your
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
and you haven’t yet debugged any other types of memory.</p>

<p>I’ll admit I’ve even thought about segmenting the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>
into both a read only component, or block ROM if you will, and a volatile
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>
component.</p>

<table align="center" style="float: none"><caption>Fig 3. Block RAM and Block ROM</caption><tr><td><img src="/img/ld-bkrom.svg" alt="" width="780" /></td></tr></table>

<p>Why would I do this?  Because it seems like few processors measure their
<a href="https://en.wikipedia.org/wiki/Dhrystone">Dhrystone</a>
performance in the absence of their bus.  Were I to build a system
like this, I might be able to measure the speed of the
<a href="/about/zipcpu.html">ZipCPU</a>s
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">instruction set</a>
independent of the bus implementation.</p>

<p>Of course, the problem with both of these designs is that
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a> is scarce.
What else might we use?</p>

<h4 id="block-ram-and-flash-rom-together">Block RAM and Flash ROM together</h4>

<p>Most <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s,
have a <a href="/blog/2018/08/16/spiflash.html">SPI flash</a>
of some type which can be used as a
<a href="https://en.wikipedia.org/wiki/Read-only_memory">ROM</a>.
The <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> itself exists for the
purpose of storing the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>’s
power up configuration, but typically there’s 75% of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
left over once that is done.  Hence, you get this
<a href="https://en.wikipedia.org/wiki/Read-only_memory">ROM memory</a>.
for “free” with the price of your board.</p>

<p>When
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>
isn’t enough, or alternatively when you want your program to
run from non-volatile memory, this
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
is available to you.  Indeed, some
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
boards don’t really have much more than
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a> and
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
devices to act as memories as discussed above.  Examples of these boards
include the <a href="/blog/2018/10/05/tinyfpga.html">TinyFPGA BX</a>, the
<a href="https://www.crowdsupply.com/1bitsquared/icebreaker-fpga">iCEBreaker board</a>,
and the <a href="https://store.digilentinc.com/cmod-s6-breadboardable-spartan-6-fpga-module">CMod
S6</a>.
This leads to a memory space such as Fig. 4 below.</p>

<table align="center" style="float: none"><caption>Fig 4. Flash (ROM) and Block RAM</caption><tr><td><img src="/img/ld-flash.svg" alt="" width="780" /></td></tr></table>

<p>The original linker script I used for <a href="https://github.com/ZipCPU/s6soc">my CMod S6
design</a> placed all of the
<a href="https://en.wikipedia.org/wiki/Code_segment">CPU instructions</a>
in <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> following the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>’s
configuration, and all the
<a href="https://wikipedia.org/wiki/Data_segment">data memory</a> into the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.
This configuration is shown in Fig. 5 below.</p>

<table align="center" style="float: none"><caption>Fig 5. Flash based instruction layout</caption><tr><td><img src="/img/ld-flash-loaded.svg" alt="" width="780" /></td></tr></table>

<p>In this figure, the ‘D’ below the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a> represents
<a href="https://wikipedia.org/wiki/Data_segment">global data</a>,
‘H’ represents the <a href="https://wikipedia.org/wiki/Data_segment#Heap">heap</a>, and
the ‘S’ represents the 
<a href="https://wikipedia.org/wiki/Data_segment#Stack">Stack</a> memory.
Likewise the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
memory area would start following the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>’s
configuration data, shown here as <code class="highlighter-rouge">FPGA</code>.
This would then be followed by a bootloader ‘B’, traditional instructions
<code class="highlighter-rouge">Insns</code> and any constant program data <code class="highlighter-rouge">Const</code>.  The purpose of the bootloader
was to move any pre-initialized global data, shown here as <code class="highlighter-rouge">D</code>, to
the beginning of the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.</p>

<p>When the design failed to meet my real-time speed requirements, driven by the
need for an audio output, I then came back and placed certain instructions,
those in critical sections of my code that needed to run at high speed, into the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>–copying
them from their original location
in <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  This new configuration
is shown in Fig 6 below, with the <code class="highlighter-rouge">K</code> section denoting these high speed
instructions that needed to be copied to
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>
by the bootloader <code class="highlighter-rouge">B</code>.</p>

<table align="center" style="float: none"><caption>Fig 6. Placing critical instructions in Block RAM</caption><tr><td><img src="/img/ld-flash-kernel.svg" alt="" width="420" /></td></tr></table>

<p>While I managed to solve this challenge, it was a challenge that needed to be
solved and the solution I found won’t necessarily work for all designs.
Imagine, for example, if I wanted to load the C-library into 
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.  It’s not
going to fit no matter how you try to squeeze it.  (It’s not a pair of Levi’s)
Therefore, given that <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
is slow, you might wish to move up to a faster
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a> type:
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>.</p>

<h4 id="flash-and-sdram">Flash and SDRAM</h4>

<p>Some of my larger devices, such as my
<a href="https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists">Arty A7</a>
or my
<a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications">Nexys Video</a>
boards, have a
<a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>
as well.  The <a href="https://github.com/ZipCPU/xulalx25soc">XuLA2-LX25 SoC</a>
I have also works with an
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>,
just not a <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>.
Either way, an
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
chip provides a lot of memory, allowing programs to copy themselves from the
<a href="/blog/2018/08/16/spiflash.html">flash device</a>
to the
<a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM device</a>.
This could easily fit the model above, only we would now replace the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a> with
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>.
Not only that, for speed we could copy our instructions from the extremely slow
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
onto the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>.</p>

<table align="center" style="float: none"><caption>Fig 7. Copying all data to the SDRAM</caption><tr><td><img src="/img/ld-sdram.svg" alt="" width="780" /></td></tr></table>

<p>But what about that
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>?
How might we use it now?</p>

<p>The classic answer would be to use all of the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>
on your device as caches for the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
This would mitigate the latency found within the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>.</p>

<h4 id="flash-block-ram-and-sdram">Flash, Block RAM, and SDRAM</h4>

<p>Alternatively, we could place certain memories, at our discretion, within the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.
I’ve often done this with the stack memory, but you could also do
this with any kernel memory that needed to be low-latency as well.</p>

<table align="center" style="float: none"><caption>Fig 8. Placing the stack and critical instructions into Block RAM</caption><tr><td><img src="/img/ld-sdram-kernel.svg" alt="" width="780" /></td></tr></table>

<h4 id="flash-block-ram-and-hyperram">Flash, Block RAM, and HyperRAM</h4>

<p>Now, just when you think you have everything figured out, someone will give you
an auxiliary memory chip, such as this
<a href="https://1bitsquared.com/products/pmod-hyperram">Hyperram from one bit-squared</a>,
and you’ll wonder how to integrate it with the rest of your system.
It may never be a permanent fixture to any given design, or it may be the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
the <a href="https://www.crowdsupply.com/1bitsquared/icebreaker-fpga">iCEBreaker</a> was
was lacking.  Either way, you now need to quickly and easily
reconfigure the design you once had working.</p>

<p>My whole point is that, in the realm of reconfigurable memory spaces, the
place where you want to keep all the various parts of your software programs
will likely keep changing.</p>

<p><a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
was just given an upgrade to handle just that issue.</p>

<h2 id="the-basic-linker-script-file">The basic Linker Script File</h2>

<p>The <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker scripts</a>
that I build tend to have four parts to them.  First, the
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">script</a>
describes a pointer to the first instruction the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
will execute.  The <a href="https://sourceware.org/binutils/docs/ld/MEMORY.html">second block declares the various
memories</a>
on board.
The third part declares some fixed pointers that can then be referenced
from within my code.  Finally, the <a href="https://sourceware.org/binutils/docs/ld/SECTIONS.html">fourth part describes how the various
components of my design will be laid out in
memory</a>.  Let’s take a
look at what this might look like.</p>

<p>The
<a href="https://github.com/ZipCPU/openarty/blob/dev/sw/board/bkram.ld">following</a>
is an <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
<a href="https://github.com/ZipCPU/openarty/blob/dev/sw/board/bkram.ld">generated script</a>
to handle a
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a> only
configuration on the
<a href="https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists">Arty</a> platform.</p>

<p><a href="https://sourceware.org/binutils/docs/ld/Scripts.html">Binutils</a>
supports <a href="https://sourceware.org/binutils/docs/ld/Script-Format.html">script comments delimited by <code class="highlighter-rouge">/*</code> and
<code class="highlighter-rouge">*/</code></a>.
<a href="https://github.com/ZipCPU/openarty/blob/dev/sw/board/bkram.ld">The generated
script</a>
therefore begins with a block of legalese comments, followed by
the entry point for your program.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">/*******************************************************************************
*
* Filename:	./bkram.ld
*
* Project:	OpenArty, an entirely open SoC based upon the Arty platform
*
*---- Skipped comments
/*******************************************************************************
*/
ENTRY(_start)</code></pre></figure>

<p>The important part of this section is the <code class="highlighter-rouge">ENTRY()</code> command, which 
specifies that the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
entry point will be <code class="highlighter-rouge">_start</code>.  This label will be set
by the linker to point to the entry point in your code.  For the
<a href="/about/zipcpu.html">ZipCPU</a>,
this is always the first instruction in the instruction address space.</p>

<p>As for the legalese, if you don’t like my legalese then feel free to replace it
with your own.  The legalese in the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> output
files is copied from a file I typically call
<a href="https://github.com/ZipCPU/openarty/blob/dev/auto-data/legalgen.txt">legalgen.txt</a>,
and introduced through
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
via a <code class="highlighter-rouge">@LEGAL=</code> tag in the
<a href="https://github.com/ZipCPU/openarty/blob/dev/auto-data/global.txt">global.txt</a>
file.  Further, as the owner of
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>, I assert
no ownership rights over the designs you create with it, just over the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
code itself–which is released under
<a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GPLv3</a>.</p>

<p>The second section is the <code class="highlighter-rouge">MEMORY</code> section.  This section lists the address
location and length of every physical memory component within the system.
The comment you see in this section below was added by
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.
It is one of many throughout the various
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
generated files to help guide you through the process of creating and updating
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
configuration files.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">MEMORY
{
	/* To be listed here, a slave must be of type MEMORY.  If the slave
	* has a defined name in its @LD.NAME tag, it will be listed here
	* under that name.  The permissions are given by the @LD.PERM tag.
	* If no permission tag exists, a permission of 'r' will be assumed.
	*/
	   bkram(wx) : ORIGIN = 0x05000000, LENGTH = 0x00020000
	   flash(rx) : ORIGIN = 0x06000000, LENGTH = 0x01000000
	   sdram(wx) : ORIGIN = 0x08000000, LENGTH = 0x08000000
}</code></pre></figure>

<p>This <code class="highlighter-rouge">MEMORY</code> section contains a list of all peripherals that contained
a <code class="highlighter-rouge">@SLAVE.TYPE</code> key with a <code class="highlighter-rouge">MEMORY</code> value.  If you recall,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
works off of configuration files containing
<code class="highlighter-rouge">@KEY=VALUE</code> statements.  The <code class="highlighter-rouge">@SLAVE.TYPE</code> key currently supports one of
four types of peripherals: <code class="highlighter-rouge">SINGLE</code>, <code class="highlighter-rouge">DOUBLE</code>, <code class="highlighter-rouge">OTHER</code>, and <code class="highlighter-rouge">MEMORY</code>.
What makes <code class="highlighter-rouge">MEMORY</code> peripherals different is that they are included in the
linker script <code class="highlighter-rouge">MEMORY</code> section above.  You can read more about this in my
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
<a href="https://github.com/ZipCPU/autofpga/blob/master/doc/icd.txt">icd.txt</a> file.</p>

<p>The <code class="highlighter-rouge">ORIGIN</code> value is assigned by
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> when
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> assigns
addresses.  The <code class="highlighter-rouge">LENGTH</code> value, indicating the
size of the peripheral, is given by the <code class="highlighter-rouge">@NADDR</code> tag times the byte-width
of the bus the peripheral is on.  Hence an <code class="highlighter-rouge">@NADDR</code> of <code class="highlighter-rouge">0x8000</code> will create
a <code class="highlighter-rouge">LENGTH</code> of <code class="highlighter-rouge">0x20000</code> as shown above for a 32-bit wide bus.</p>

<p>The names given above come from either the <code class="highlighter-rouge">@LD.NAME</code> tag within the peripheral,
or the peripheral’s name itself as found within its <code class="highlighter-rouge">@PREFIX</code> tag.</p>

<p>The point is that as your design is composed, and the memories given addresses,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
supports this reconfiguration by creating and populating the <code class="highlighter-rouge">MEMORY</code> section
of the linker script.</p>

<p>The <a href="https://sourceware.org/binutils/docs/ld/Simple-Assignments.html">next section contains a variety of symbol declarations and
assignments</a>.
These symbol names, if defined and used within your C/C++ code, will be
replaced with the values given below.</p>

<p>First, all of the <code class="highlighter-rouge">MEMORY</code> peripherals are given names and values pointing
to the beginning of their memory regions.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">/* For each defined memory peripheral, we also define a pointer to that
* memory.  The name of this pointer is given by the @LD.NAME tag within
* the memory peripheral's configuration
*/
_bkram    = ORIGIN(bkram);
_flash    = ORIGIN(flash);
_sdram    = ORIGIN(sdram);</code></pre></figure>

<p>Second, if there is an <code class="highlighter-rouge">LD.DEFNS</code> tag within the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> script,
its value will be copied into this section as well.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">/* LD.DEFNS */
_kram  = 0; /* No high-speed kernel RAM */
_ram   = ORIGIN(bkram);
_rom   = 0;
_top_of_stack = ORIGIN(bkram) + LENGTH(bkram);</code></pre></figure>

<p>Together, the sections above tell the linker that we have three types of
memories,
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>,
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, and
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>.
It identifies the origins of those memories, their lengths, and then
creates symbols so that your code can access these values.</p>

<p>Next, the <code class="highlighter-rouge">_kram</code>, <code class="highlighter-rouge">_ram</code>, <code class="highlighter-rouge">_rom</code>, and <code class="highlighter-rouge">_top_of_stack</code> symbols are used by
the <a href="https://github.com/ZipCPU/openarty/blob/dev/sw/zlib/crt0.c">ZipCPU’s
bootloader</a>
to load items from
<a href="https://en.wikipedia.org/wiki/Read-only_memory">ROM</a>
into a high-speed kernel
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a> (i.e. 
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>, if used)
or otherwise into regular
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
(i.e. an <a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>).
Finally, the top of the
<a href="https://wikipedia.org/wiki/Call_stack">stack</a>
is set to be the end of the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a> section
in this design.</p>

<p>These are just symbols assigned to values.  We haven’t described any real
linking yet.  Those instructions are found in the next section.</p>

<p>This <a href="https://sourceware.org/binutils/docs/ld/SECTIONS.html">last section describes where the various segments of your program
need to be placed into
memory</a>.  In <a href="https://github.com/ZipCPU/openarty/blob/dev/sw/board/bkram.ld">this
example</a>,
I define a new memory section starting at the origin of the
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>,
aligned on units of 4 octets, and filled with a series of segments.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">/* LD.SCRIPT */
SECTIONS
{
       .ramcode ORIGIN(bkram) : ALIGN(4) {
               _boot_address = .;
               _kram_start = .;
               _kram_end = .;
       		_ram_image_start = . ;
               *(.start) *(.boot)
               *(.kernel)
               *(.text.startup)
               *(.text*)
               *(.rodata*) *(.strings)
               *(.data) *(COMMON)
               }&gt; bkram
       _ram_image_end = . ;
       .bss : ALIGN_WITH_INPUT {
               *(.bss)
               _bss_image_end = . ;
               } &gt; bkram
       _top_of_heap = .;
}</code></pre></figure>

<p>There are also a series of assignments in this section as well.  These define
both values that will be used by the
<a href="https://github.com/ZipCPU/openarty/blob/dev/sw/zlib/crt0.c">bootloader</a>,
such as <code class="highlighter-rouge">_ram_image_start</code> and <code class="highlighter-rouge">_bss_image_end</code>, as well as an ending value
which will then be the pointer to the beginning of the heap, <code class="highlighter-rouge">_top_of_heap</code>.</p>

<p>A <a href="https://github.com/ZipCPU/openarty/blob/dev/sw/zlib/bootloader.h">simple pair of lines within your C++
code</a>,
such as,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">extern</span> <span class="kt">int</span> <span class="n">_top_of_heap</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="n">_top_of_heap</span><span class="p">;</span></code></pre></figure>

<p>will allow you to get the value of this <code class="highlighter-rouge">_top_of_heap</code> value, and to initialize
the <code class="highlighter-rouge">heap</code> pointer with it.</p>

<p>But what about those sections?  Here are some of their basic meanings:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">*(.start) *(.boot)</code>: These two segments are
 <a href="/about/zipcpu.html">ZipCPU</a>
 specific segments.  The <code class="highlighter-rouge">*(.start)</code> segment is used by the
 <a href="/about/zipcpu.html">ZipCPU</a>
 to make certain the startup code is the first set of instructions
 following the reset address–which is typically the beginning of
 the <code class="highlighter-rouge">SECTIONS</code> area although not in this case.  The most important part of
 this startup code is that it sets the
 <a href="https://wikipedia.org/wiki/Call_stack">stack pointer</a> that everything
 else will depend upon, and then jumps to the
 <a href="https://github.com/ZipCPU/openarty/blob/dev/sw/zlib/crt0.c">bootloader</a>.
 When the
 <a href="https://github.com/ZipCPU/openarty/blob/dev/sw/zlib/crt0.c">bootloader</a>
 returns, it then jumps to your <code class="highlighter-rouge">main()</code> function.  When <code class="highlighter-rouge">main()</code> returns,
 it halts the <a href="/about/zipcpu.html">CPU</a>.</p>

    <p>The <code class="highlighter-rouge">*(.boot)</code> code is another <a href="/about/zipcpu.html">ZipCPU</a>
 section where I place the
 <a href="https://github.com/ZipCPU/openarty/blob/dev/sw/zlib/crt0.c">bootloader</a>
 instructions.</p>

    <p>Both of these need to come early in the code order, primarily for the times
 when I need to copy instructions from
 <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
 to
 <a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>–although
 they aren’t necessarily used in this example.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">*(.kernel)</code>: I created this
 <a href="/about/zipcpu.html">ZipCPU</a> specific section to support my
 <a href="https://github.com/ZipCPU/s6soc">S6SoC project</a>.  Any code
 placed in this section will be copied to the fastest
 <a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
 in the project (<a href="/zipcpu/2018/07/13/memories.html">block
 RAM</a>), in case the
 <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
 has code that must run at high speed.</p>

    <p>Both the <code class="highlighter-rouge">*(.kernel)</code> section as well as the <code class="highlighter-rouge">*(.start)</code> and <code class="highlighter-rouge">*(.boot)</code>
 sections are unknown to the
 <a href="https://www.gnu.org/software/binutils">binutils linker</a>
 or <a href="https://gcc.gnu.org">GCC</a>.  The code to be placed
 in these sections must specifically be marked as such.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">*(.text*)</code>: These sections contain the instructions for the program in
 question.  Now that we have all the nastiness above out of the way, we can
 actually place these sections, with the <code class="highlighter-rouge">*(.text.startup)</code> section among
 these placed into memory first.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">*(.rodata*) *(.strings) *(.data) *(COMMON)</code>: These sections contain the
 read-only (i.e. <code class="highlighter-rouge">const</code>) data used by my program, any strings within the
 program, and finally any global data structures with initial values.</p>

    <p>The <a href="https://github.com/ZipCPU/openarty/blob/dev/sw/zlib/crt0.c">bootloader</a>
 needs to copy these sections into their places, but nothing else is required.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">*(.bss)</code>: The final section is the
 <a href="https://wikipedia.org/wiki/.bss">BSS segment</a>.
 Unlike the other segments above, where the
 <a href="https://github.com/ZipCPU/openarty/blob/dev/sw/zlib/crt0.c">bootloader</a>
 just needs to copy them into place, the
 <a href="https://wikipedia.org/wiki/.bss">BSS segment</a>
 needs to be cleared to all zeros.  This is where any uninitialized
 global variables within your program will be placed.</p>
  </li>
</ul>

<p>There’s one other thing you need to know about this section, the <code class="highlighter-rouge">}&gt; bkram</code>
notation.  This means that the section just described should be allocated
a place in the <code class="highlighter-rouge">bkram</code> device.  Something else you might see is
<code class="highlighter-rouge">}&gt; bkram AT&gt;flash</code>.  This means that the section needs to be placed into
<code class="highlighter-rouge">bkram</code>, and that your code needs to be linked as though the section were
placed into <code class="highlighter-rouge">bkram</code>.  However, it is first placed into the <code class="highlighter-rouge">flash</code> memory
area, and left there for your
<a href="https://github.com/ZipCPU/openarty/blob/dev/sw/zlib/crt0.c">bootloader</a>
to copy it into <code class="highlighter-rouge">bkram</code>.</p>

<p>Now that you know what the various sections of this file are, and how the
segments within your program will be allocated among them, what happens if
we want to do something else?</p>

<h4 id="multiple-linker-configurations">Multiple Linker Configurations</h4>

<p>Originally, <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
created one linker script, called <code class="highlighter-rouge">board.ld</code>, and adjusted it based upon
the peripherals available to it.  For example, it could handle designs with
<a href="/blog/2018/08/16/spiflash.html">Flash</a> and
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>,
but couldn’t really do much with
<a href="/blog/2018/08/16/spiflash.html">Flash</a> and
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>s.
This worked great for some designs, such as those with a massive amount of
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
as shown in Fig. 7 or 8 above, but horrible for others, such as Fig. 2
through 6 above.</p>

<p>As an example, if I wanted a design to run from
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a> alone,
such as to test the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
itself apart from its memory peripherals with
the form in Fig. 2 above, this one size fits all
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>
would have be inadequate.  Likewise, if I had a design that didn’t have enough
room in <a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
to copy the various program segments into (imagine the C-library here), the
stock linker script wouldn’t work either.  While I could create a script by
hand for each of these scenarios, such as I was <a href="https://github.com/ZipCPU/tinyzip/blob/master/sw/board/boardram.ld">starting to
do</a>
in my <a href="https://github.com/ZipCPU/tinyzip">TinyZip design</a>, that script would
then need to be updated by hand every time the addresses in
the <code class="highlighter-rouge">MEMORY</code> region changed.</p>

<p>This was getting annoying.</p>

<p>To deal with this, I just recently created some new
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> tags for
creating <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker scripts</a>:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">@LD.FILE</code>: If present in a given configuration file,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
will create a 
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>
and write it out to the named file.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">@LD.DEFNS</code>: If present, these definitions will be added to the definitions
section of the new linker script.</p>

    <p>Well, sort of.  What if a design has multiple linker script configuration
files?  In this case, the components that have no <code class="highlighter-rouge">@LD.FILE</code> tags will have
their <code class="highlighter-rouge">@LD.DEFNS</code> tags copied to all linker scripts, while the components
with an <code class="highlighter-rouge">@LD.FILE</code> tag will have their <code class="highlighter-rouge">@LD.DEFNS</code> tag copied
into the linker script defined by that component only.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">@LD.SCRIPT</code>: This tag, containing the <code class="highlighter-rouge">SECTION</code> component above,
will be copied into the linker script associated with the <code class="highlighter-rouge">@LD.FILE</code> tag
in the same component verbatim, although with variable substitution
applied.  So, for example, if our design creates a <code class="highlighter-rouge">RESET_ADDRESS</code>
tag within the peripheral named <code class="highlighter-rouge">zip</code> (i.e. having a <code class="highlighter-rouge">PREFIX</code> tag
of <code class="highlighter-rouge">zip</code>, then we might reference <code class="highlighter-rouge">@$(zip.RESET_ADDRESS)</code> to get a
copy of what that address was here in this location.</p>
  </li>
</ul>

<p>Several former linker tags have kept their functionality, but now have new
names.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">@LD.NAME</code>: This is the name of the memory component, as found in the
linker script.  In the example above, we had names of <code class="highlighter-rouge">bkram</code>, <code class="highlighter-rouge">flash</code>,
and <code class="highlighter-rouge">sdram</code>.  This tag used to be called <code class="highlighter-rouge">@LDSCRIPT.NAME</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">@LD.PERM</code>: The <code class="highlighter-rouge">MEMORY</code> section of a linker script requires a permission
string.  The <a href="https://sourceware.org/binutils/docs/ld/MEMORY.html#MEMORY">binutils
documentation</a>
calls this a set of attributes.  So far, I’ve only used <code class="highlighter-rouge">rx</code> and <code class="highlighter-rouge">wx</code> for
executable <a href="https://en.wikipedia.org/wiki/Read-only_memory">ROM</a>
and executable
<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a>
respectively.  <a href="https://sourceware.org/binutils/docs/ld/MEMORY.html#MEMORY">Other possible attributes are defined can be
found in the binutils
documentation</a>.
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> does
nothing more than copy then from your design file to the
<code class="highlighter-rouge">MEMORY</code> section of the
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>.</p>

    <p>Remember, <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>  is primarily a copy-paste tool with the ability to compose bus interconnects,
and a limited variable substitution and expression evaluation capability
sprinkled within.  Similarly, another of the goals of
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> was
that when it’s work was done, the computer generated files would be
comprehensible, rather than your more typical computerese.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">@LD.ENTRY</code>: If present, this will define the entry symbol for a given
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>.
If not specified, this will default to the <code class="highlighter-rouge">_start</code> symbol as above.</p>
  </li>
</ul>

<p>This updated method of generating custom
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>
has now worked so well for me that I have several
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker scripts</a>
defined for the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> upgrade to
my <a href="https://github.com/ZipCPU/openarty/tree/dev/">OpenArty</a> project:
<a href="https://github.com/ZipCPU/openarty/tree/dev/mem_bkram_only.txt">one for block RAM
only</a>,
another for <a href="https://github.com/ZipCPU/openarty/tree/dev/mem_flash_bkram.txt">flash plus block
RAM</a>,
and I’ll be adding a third for flash, block RAM, and SDRAM support.
Even better, using this approach, adding
support for a
<a href="https://github.com/ZipCPU/wbhyperram/tree/dev">HyperRAM controller</a>
should be just as simple as copying the controller components to my
RTL directory (or a subdirectory of it) and
adding the
<a href="https://github.com/ZipCPU/wbhyperram/tree/dev">HyperRAM</a>
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
linker script configuration to my design.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Working with one
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
design across many different hardware components and
capabilities can be a challenge.  It can be difficult to take a basic
design and rapidly configure it for a new set of hardware, or to maintain
support across several different hardware implementations.
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
can handle many of these reconfiguration needs, to make reconfiguring
designs from one hardware configuration to another easier.</p>

<p>Even better,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>’s
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>
generation just got an upgrade to help it deal with the need for multiple
different memory configurations–either between designs or even within the
same design.</p>

<p>Of course, the unwritten reality of this article is that I don’t really want to
spend my time writing
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>.  I would
rather be spending my time getting my new
<a href="https://github.com/ZipCPU/wbhyperram/tree/dev">HyperRAM</a>
to work.  This is just my way of trying to simplify the massive configuration
challenges I have along the way.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Let him that stole steal no more: but rather let him labour, working with his hands the thing which is good, that he may have to give to him that needeth. (Eph 4:28)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
