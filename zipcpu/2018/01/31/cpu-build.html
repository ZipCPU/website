<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>ZipCPU toolchain and initial test</title>
  <meta name="description" content="Please accept my apologies for taking so long to put this article together.I’ve made a lot of changes to theZipCPUin order to formallyprovethe components.  I...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2018/01/31/cpu-build.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">ZipCPU toolchain and initial test</h1>
    <p class="post-meta"><time datetime="2018-01-31T00:00:00-05:00" itemprop="datePublished">Jan 31, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Please accept my apologies for taking so long to put this article together.
I’ve made a lot of changes to the
<a href="/about/zipcpu.html">ZipCPU</a>
in order to <a href="/blog/2018/01/22/formal-progress.html">formally
prove</a>
the components.  I’ve also cleaned out all of the issues in the issue-tracker
on <a href="https://github.com/ZipCPU/zipcpu">Github</a>.  These changes have now been
integrated into <a href="https://github.com/ZipCPU/zipcpu">the baseline</a>.
They have been confirmed to build within
<a href="http://www.clifford.at/yosys/">yosys</a>,
<a href="https://www.xilinx.com/products/design-tools/ise-design-suite.html">ISE</a>,
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>,
and
<a href="https://veripool.org/wiki/verilator">Verilator</a>.
Further, the new changes have been proven on the
<a href="https://github.com/ZipCPU/zbasic">ZBasic</a> distribution–just not within an
actual <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
(yet).  Further, when measuring the
<a href="https://en.wikipedia.org/wiki/Logic_block">LUT</a>
usage impact of the changes that
have been made, they appear to require no more than four extra
<a href="https://en.wikipedia.org/wiki/Logic_block">LUT</a>s–suggesting the
<a href="/about/zipcpu.html">ZipCPU</a>
remains on target to be a low-logic
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.</p>

<p>Integration with
<a href="https://github.com/olofk/fusesoc">FuseSoC</a>
is still now, perhaps more firmly than ever, on my to-do list.</p>

<p>With that aside, let’s look into how you might get started.</p>

<h2 id="introduction">Introduction</h2>

<p>Let’s spend a couple of posts discussing how to fire up the
<a href="/about/zipcpu.html">ZipCPU</a>
and run it.  Our goal will be to show how the
<a href="/about/zipcpu.html">ZipCPU</a>
can be used to control a signal processing application.  That, however,
will take a couple of posts to get to.  For this first post, let’s
just discuss how to get the
<a href="/about/zipcpu.html">ZipCPU</a>
tool chain up and running, and then how to test and know that the
<a href="/about/zipcpu.html">CPU</a>
itself works.</p>

<p>If you look at the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/master/README.md">README file</a>, you’ll
read that the
<a href="/about/zipcpu.html">ZipCPU</a>
is only one component of a (potentially) much larger system.  For example,
consider the
<a href="https://github.com/ZipCPU/zbasic">ZBasic</a>
system in the figure below.</p>

<table align="center" style="float: none"><caption>Fig 1. ZBasic Components and Peripherals</caption><tr><td><img src="/img/zbasic/zbasic-blok.svg" alt="" width="730" /></td></tr></table>

<p><a href="https://github.com/ZipCPU/zbasic">This system</a>
was designed to be a generic system that could demonstrate the
<a href="/about/zipcpu.html">ZipCPU</a>’s
capabilities.  If you notice, the
<a href="/about/zipcpu.html">ZipCPU</a>
is only a small part of this full system.  Likewise, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>,
a container for the <a href="/about/zipcpu.html">ZipCPU</a>
with some peripherals connected close to the
<a href="/about/zipcpu.html">CPU</a>,
is still only a small portion of any full design.  To make a full design from
just a <a href="/about/zipcpu.html">CPU</a>, the
<a href="https://github.com/ZipCPU/zbasic">ZBasic</a>
project also contains a
<a href="https://github.com/ZipCPU/wbuart32">serial port</a>, a <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">block
RAM</a>, a <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/wbqspiflash.v">flash (ROM)
controller</a>,
an (optional)
<a href="https://github.com/ZipCPU/sdspi">SPI-mode SD-Card controller</a>, and
(currently) a
<a href="https://github.com/ZipCPU/wbscope">scope</a> for the
<a href="https://github.com/ZipCPU/sdspi">SD-card controller</a>
as well.  There are also some smaller components, such as a
<a href="https://github.com/ZipCPU/rtcclock">real-time clock</a>, a
<a href="https://github.com/ZipCPU/zbasic/blob/master/auto-data/pwrcount.txt">counter-since-power
up</a>,
a second <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v">interrupt
controller</a>,
the <a href="https://github.com/ZipCPU/zbasic/blob/master/auto-data/version.txt">date of the last time the system was
built</a>
 and so forth.</p>

<p>As with all of my designs, the <a href="https://github.com/ZipCPU/zbasic">ZBasic design</a>
also has a <a href="/blog/2017/06/05/wb-bridge-overview.html">debugging bus
controller</a>
that can be used to control the bus within the core from an external
<a href="https://github.com/ZipCPU/wbuart32">serial port</a>.  This version of the
debugging bus controller, however, multiplexes two 7-bit
channels onto an 8-bit serial port channel–unlike the <a href="/blog/2017/06/05/wb-bridge-overview.html">one we discussed
earlier</a>.
This creates a
<a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/wbconsole.v">console port</a>
for the <a href="/about/zipcpu.html">CPU</a>, in addition to the
<a href="/blog/2017/06/05/wb-bridge-overview.html">debugging bus controller</a>.
This makes it possible to experiment with the
<a href="https://github.com/ZipCPU/zbasic">ZBasic</a>
module on any
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
board having only a
<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">QSPI</a>
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> and a
<a href="https://github.com/ZipCPU/wbuart32">serial port</a>.  The
<a href="https://github.com/ZipCPU/sdspi">SDCard</a> port is optional, and by using
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>, the block RAM can easily be
resized.</p>

<p>Our eventual goal in this series of articles will be to show how to run
this <a href="https://github.com/ZipCPU/zbasic">ZBasic design</a>,
while simulating all of the components, from within
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>.  As
part of this goal, we’ll also add a
<a href="https://github.com/ZipCPU/wbpmic">MEMs based audio A/D</a>
and may possibly even add an <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM
controller</a>.
We’ll even use the <a href="https://sourceware.org/newlib">C-library</a> to demonstrate a
<a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c">Hello World
example</a>,
and possibly even to play <a href="https://github.com/ZipCPU/tttt">4x4x4 Tic-Tac-Toe</a>.</p>

<p>That will be the goal of this series.</p>

<p>Today’s goal, however, will just be to examine the
<a href="/about/zipcpu.html">ZipCPU</a>
by itself.  To do so, we’ll trace a piece
<a href="/about/zipcpu.html">ZipCPU</a> history,
and run the very first piece of software ever written for the
<a href="/about/zipcpu.html">ZipCPU</a>.</p>

<h2 id="the-initial-zipcpu-test-software">The Initial ZipCPU Test Software</h2>

<p>The very first  piece of software I wrote for the
<a href="/about/zipcpu.html">ZipCPU</a>
just demonstrated each of the
<a href="/about/zipcpu.html">CPU</a>’s
instructions, and its ability to execute them.</p>

<p>The initial version of this test was created by a test generator piece of
software that at one time wrote a couple of machine code instructions
into a binary file which would then describe the block RAM memory image
for the <a href="/about/zipcpu.html">CPU</a>.
I was so excited to get this simple code to work!  Little did I know how
much more work would be involved in finding all the corner cases within any
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
This piece of code, however, is now only relic-ware.  Indeed, it is not only
a couple of <a href="/zipcpu/2018/01/01/zipcpu-isa.html">instruction set
architecture</a>
versions out of date, but since it was causing build errors for users it has
since been removed from the repository entirely.</p>

<p>With the introduction of the first
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm">assembler</a>,
the program that generated machine code was replaced with an <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">assembly
file</a>.
Even though that
<a href="https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm">initial assembler</a>
has now also become relic-ware, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">assembly
file</a>
test has been maintained to the point that it can still
be assembled using the <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/sw/gas-zippatch.patch">version of
binutils</a>.
Unlike the
<a href="https://github.com/ZipCPU/zipcpu/tree/master/sw/zasm">original assembler</a>,
<a href="https://www.gnu.org/software/binutils">binutils</a>
provides several valuable capabilities–such as the ability to link multiple
files together, the ability to follow a script describing where memory and/or
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
are located, the ability to place an initial RAM image in
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
and even the ability to integrate with <a href="https://gcc.gnu.org">GCC</a>.</p>

<p>This <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">remaining piece of
software/testware</a>
starts with a branch-always followed by break test–just to make certain the
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a>
works.  It then continues by testing some basic register setting commands.
It was meant to be run within a <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">monitor
program</a>.
Using this program, you can step through this software one clock cycle at a
time–just like <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">we discussed
earlier</a>.</p>

<p>Let’s build and run
<a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">this program</a>
today, to give us some confidence that the
<a href="/about/zipcpu.html">CPU</a>
itself continues to work.</p>

<h2 id="building-the-tools">Building the tools</h2>

<p>The first step in converting any
<a href="https://en.wikipedia.org/wiki/Assembly_language">assembly file</a> into <a href="https://en.wikipedia.org/wiki/Machine_code">machine
code</a>
is to acquire (or build) an <a href="https://www.gnu.org/software/binutils">assembler and
linker</a>.  The
<a href="/about/zipcpu.html">ZipCPU</a>
has backend support for <a href="https://www.gnu.org/software/binutils">binutils (assembler and
linker)</a>, the
<a href="https://gcc.gnu.org">GCC C-compiler</a>, and
<a href="https://sourceware.org/newlib">newlib</a>.  Although only
<a href="https://www.gnu.org/software/binutils">binutils</a>
is required for this <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">testing
program</a>,
all of the tools are built from the same command, so let’s build them together.</p>

<p>To build the
<a href="/about/zipcpu.html">ZipCPU</a>
tool-suite, first make sure you have the prerequisites
for <a href="https://gcc.gnu.org">GCC</a>.  For debian based systems, this will look like:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>apt <span class="nb">install </span>flex bison libbison-dev libgmp-dev libmpfr-dev libmpc-dev bc
<span class="nb">sudo </span>apt <span class="nb">install </span>texinfo</code></pre></figure>

<p>You’ll notice several <code class="language-plaintext highlighter-rouge">*-dev</code> components.  These are different from their non
<code class="language-plaintext highlighter-rouge">-dev</code> counterparts, in that they allow you to build components using these
libraries rather than just using binary components already built.  In other
words, installing <code class="language-plaintext highlighter-rouge">gmp</code> isn’t good enough, you’ll need to install <code class="language-plaintext highlighter-rouge">libgmp-dev</code>.</p>

<p>You are also going to need <a href="https://www.veripool.org/wiki/verilator">Verilator</a>
to translate
the <a href="/about/zipcpu.html">ZipCPU</a>’s Verilog source code into
the C++ necessary to simulate it,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>apt <span class="nb">install </span>verilator</code></pre></figure>

<p>The <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation</a>
driver needs
<a href="http://www.mr511.de/software/english.html">libelf</a> in order to know
where to load programs and program components into memory,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>apt <span class="nb">install </span>libelf-dev</code></pre></figure>

<p>Please note that, as with the earlier components, this package is the
development version of
<a href="http://www.mr511.de/software/english.html">libelf</a>.  We’ll need that version
to build a program that uses it that can read and process an ELF file.</p>

<p>Many of my distributions depend upon <a href="http://ctags.sourceforge.net">ctags</a>,
and the <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation control
program</a>
is written using
<a href="https://www.gnu.org/software/ncurses">ncurses</a>, so let’s get those as well:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>apt <span class="nb">install </span>ncurses-dev ctags</code></pre></figure>

<p>If you are using Windows,
<a href="/blog/2017/07/28/cygwin-fpga.html">these instructions</a>
should get you started using these tools via <a href="https://cygwin.com">cygwin</a>.
Since I’m not using Windows regularly, please let me know if you have any
problems building with <a href="https://cygwin.com">cygwin</a>–I’ll probably never notice
the problem otherwise.</p>

<p>One you have these prerequisites, it is now time to actually clone
the <a href="/about/zipcpu.html">ZipCPU</a>
repository,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git clone <span class="nt">--depth</span> 1 https://github.com/ZipCPU/zipcpu
<span class="nb">cd </span>zipcpu</code></pre></figure>

<p>While you may have cloned repositories without the <code class="language-plaintext highlighter-rouge">depth</code> command, doing so
with the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu">repository</a> will also download a history
containing several versions of <a href="https://gcc.gnu.org">GCC</a>.  In other words,
you’ll be spending a lot of bandwidth downloading more of the
<a href="https://github.com/ZipCPU/zipcpu">repository</a> than you need.</p>

<p>At this point, you <em>should</em> be able to just type “make”.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">make</code></pre></figure>

<p>This will orchestrate a
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>-based
make of the “<a href="https://github.com/ZipCPU/zipcpu/tree/master/rtl">rtl/</a>”
directory, and a build of the simulation
directory, “<a href="https://github.com/ZipCPU/zipcpu/tree/master/sim/verilator">sim/verilator</a>”.  It will also trigger a build of the
<a href="/about/zipcpu.html">ZipCPU</a>
tool-suite that we’ll need to turn the <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">simulation test
file</a>
from <a href="/zipcpu/2018/01/01/zipcpu-isa.html">assembly</a> into
<a href="https://en.wikipedia.org/wiki/Machine_code">object code</a>.</p>

<p>The current version of the tools will be built and placed into a “sw/install”
directory within the cloned repository of the
<a href="/about/zipcpu.html">ZipCPU</a>.
Before going further, you will need to make certain that this directory
is a part of your path.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:&lt;your-path-to-zipcpu&gt;/sw/install/cross-tools/bin</code></pre></figure>

<p>I am very interested in any struggles you may have during this process.
Please create an issue on
<a href="https://github.com/ZipCPU/zipcpu">GitHub</a> if you have any errors up to this
point.</p>

<h2 id="running-the-test-file">Running the test file</h2>

<p>Now that you have the tool suite, and now that your <code class="language-plaintext highlighter-rouge">PATH</code> environment
variable has been modified so that <code class="language-plaintext highlighter-rouge">zip-as</code> and <code class="language-plaintext highlighter-rouge">zip-cpp</code> are in
your path, then it is now time to build the <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">simulation test
file</a>.
For this, we’ll change into the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm">bench/asm</a>,
and run <code class="language-plaintext highlighter-rouge">make simtest</code>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd </span>bench/asm
make simtest</code></pre></figure>

<p>You can also build a disassembly file of the result, in case you are ever
interested in what the original instructions actually build into, by</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">make simtest.txt</code></pre></figure>

<p>Once built, we can change into the <a href="https://github.com/ZipCPU/zipcpu/tree/master/sim/verilator/">Verilator based simulation
directory</a>,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> ../..
<span class="nb">cd </span>sim/verilator</code></pre></figure>

<p>From here, you can run the automated tests.  There are two such tests,
both based off of the same <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">simulated test</a> instructions.</p>

<p>The first automated test just runs the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">test</a>
file, using the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="/zipcpu/2017/08/25/hw-debugging.html">debug interface</a>
and particularly the <em>step</em> instruction provided by that interface–the
same <em>step</em> control that the
<a href="/about/zipcpu.html">CPU</a>
would use were it placed on actual hardware.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./zipsys_tb <span class="nt">-s</span> ../../bench/asm/simtest</code></pre></figure>

<p>To know when the test is complete, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">test file</a>
has been designed to “end” in one of two states.  It will either end with
1) a halt instruction (successful exit), or 2) a BUSY instruction (error exit).
The <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator</a>
will detect this interface, and return an appropriate value to the shell.</p>

<p>The second automated test simulates how the
<a href="/about/zipcpu.html">CPU</a> would run if it were actually
running on the device without the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugging interface</a>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./zipsys_tb <span class="nt">-a</span> ../../bench/asm/simtest</code></pre></figure>

<p>These two tests are so valuable to me, that I have a make target set up
just to run both of them,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">make <span class="nb">test</span></code></pre></figure>

<p>There’s a third way to run the test as well–the interactive test.  Although
starting the run is just as simple,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">make itest</code></pre></figure>

<p>there are more details involved in commanding it, which we’ll get into in the
next section.</p>

<p>Further, no matter how you run this
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator</a>,
it will (currently) always create a
<a href="/blog/2017/07/31/vcd.html">VCD trace file</a>.  You are
welcome to open this file in a waveform viewer to see the internal signals
within the <a href="/about/zipcpu.html">ZipCPU</a> if you would like.
This isn’t true of the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator</a>
within the
<a href="https://github.com/ZipCPU/zbasic">ZBasic</a> repository–since the trace files
for <a href="https://github.com/ZipCPU/zbasic/blob/master/sim/verilated/automaster_tb.cpp">that simulator</a>
can easily grow to many Gigabytes in length, that one is turned off by default.
In this case, though, the <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">simtest
file</a>
is short enough that the
<a href="/blog/2017/07/31/vcd.html">VCD trace file</a>
should remain within a reasonable size.</p>

<h2 id="interactive-commands">Interactive Commands</h2>

<p>Now that you know how to start the <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation based
debugger</a>
let’s spend some time describing how to work operate it.  As you’ll recall
from the last section, starting the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation based
debugger</a> is easy.
Just run</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">make itest</code></pre></figure>

<p>from the “<a href="https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated">sim/verilated</a>”
subdirectory.</p>

<p>This will apply the
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation</a>
to the <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">simtest
file</a>.
To start it with another file you can run,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./zipsys_tb &lt;your-executable-file&gt;</code></pre></figure>

<p>Knowing what to do next isn’t quite as simple.  Sure, either hitting the
escape key or ‘q’ will exit, but you can do a lot more.  Here’s a cheat sheet
so you’ll know what to do.  Specifically, the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator</a>
understands the following command keys:</p>

<ul>
  <li>‘h’ Halts the <a href="/about/zipcpu.html">CPU</a></li>
  <li>‘g’ tells the <a href="/about/zipcpu.html">CPU</a>
to <em>go</em> until given another command.</li>
  <li>‘G’ does the same thing, but only updates the screen any time a user types
a character.  It’s useful for moving quickly through a long simulation if
necessary.</li>
  <li>‘r’ gives the <a href="/about/zipcpu.html">CPU</a> the reset command,
sending it back to supervisor mode and the reset address</li>
  <li>’s’ <em>steps</em> the <a href="/about/zipcpu.html">CPU</a> using the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugging interface</a>
that will exist within the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
implementation</li>
  <li>‘t’ <em>ticks</em> the clock.  It steps the
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation</a>
by one clock tick, but done in such a fashion that the
<a href="/about/zipcpu.html">CPU</a>’s
Verilog logic doesn’t know it’s being stepped.</li>
  <li>‘T’ releases the
<a href="/about/zipcpu.html">CPU</a>
from the <a href="/zipcpu/2017/08/25/hw-debugging.html">hardware debugging
mode</a>.  This is
useful if you’ve been giving it the <em>step</em> command (separate from ticking
the clock), and you want the
<a href="/about/zipcpu.html">CPU</a> to continue without being given
explicit <em>step</em> instructions.</li>
  <li>‘q’ quits the simulation</li>
  <li>Ctrl-L redraws the screen.  This used to be really important when running
a <a href="https://www.gnu.org/software/ncurses">curses</a>
program over a modem connection–any time someone else in the house
would pick up the phone, you’d get a bunch of garbage on the screen and your
computer would need to re-sync.  While it’s not as necessary today, I did
find it necessary to add this capability in–specifically for the case
where I have
<a href="https://gtkwave.sourceforge.net">GTKWave</a>
running in the background spewing warnings over my screen anytime I
update the display.</li>
  <li>‘u’ switches the performance times to show user mode performance</li>
  <li>‘m’ switches the performance times to show global machine performance</li>
</ul>

<p>If this is your first experience with the
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator</a>,
just remember three
characters: ‘t’ steps it forward, ‘r’ restarts it, and ‘q’ exits.  You might
just wish to press ‘t’ several times and watch what happens.  If that gets
boring, try typing ‘g’–you can stop the
<a href="/about/zipcpu.html">ZipCPU</a>
anytime by typing ‘t’ later to return to single-clock-tick mode.</p>

<p>The <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator</a>
also has the ability to adjust and change registers.  You
can move around the display using the arrow keys.  When you get to a register
you wish to adjust, press the enter key, type the new number, and then press
enter (to set the value) or escape (to leave the mode).</p>

<h2 id="understanding-the-interactive-display">Understanding the Interactive Display</h2>

<p>So let’s look at what this interface tells us.</p>

<p>When you initially start the
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator</a>,
you’ll see a screen looking like Fig 2 below.</p>

<table align="center" style="float: none"><caption>Fig 2, Initial Simulator Screen</caption><tr><td><img src="/img/cpu-build/zipsim-initial.png" alt="" width="562" /></td></tr></table>

<p>Let’s break down the components of this view, so that you can understand what’s
going on.  Fig 3. therefore shows the basic sections of the
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation</a>
screen.</p>

<table align="center" style="float: none"><caption>Fig 3. Components of the simulation screen</caption><tr><td><img src="/img/cpu-build/zipsim-overview.svg" alt="" width="562" /></td></tr></table>

<p>Starting at the top are two lines describing the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>
<a href="https://github.com/ZipCPU/zipcpu/tree/master/peripherals">peripherals</a>.  These
<a href="https://github.com/ZipCPU/zipcpu/tree/master/peripherals">peripherals</a>
are shown in the blue box of Fig 1 above, they consist of an <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v">interrupt
controller (PIC)</a>, a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">watchdog timer (WDT)</a>, a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbwatchdog.v">bus watchdog (WBUS)</a>, and the second
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v">interrupt control register (PIC2)</a>.  Judging from these
<a href="https://github.com/ZipCPU/zipcpu/tree/master/peripherals">peripherals</a>,
you can tell if (for example) interrupts are enabled, or an interrupt is
pending.  On the next line are the three
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">count-down timers (TMRA-TMRC)</a>, and
a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipjiffies.v">Jiffies</a>
peripheral for controlling absolute rather than relative programmable
interrupt timing.  (This would be useful for real-time task scheduling.)</p>

<p>The next line, starting with <code class="language-plaintext highlighter-rouge">MTSK</code>, shows the values of four
<a href="https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v">performance counters</a>.  The first counts the number clock ticks, and the last counts
the number of instructions retired.  The two in the middle count how often the
operands stage of the
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a> is stalled,
and how often the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
is stalled.  These are global counters.  They count whether the
<a href="/about/zipcpu.html">CPU</a>
is in <a href="/zipcpu/2018/01/01/zipcpu-isa.html">supervisor mode or user
mode</a>.  There’s a
second set of identical
<a href="https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v">counters</a>,
revealed by typing <code class="language-plaintext highlighter-rouge">u</code> within the
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation</a>,
showing the same basic values–but this second set only increments
while in user mode.  This makes it possible to measure per user-task statistics.</p>

<p>Further information regarding these
<a href="https://github.com/ZipCPU/zipcpu/tree/master/peripherals">peripherals</a>,
and the <a href="https://github.com/ZipCPU/zipcpu/blob/master/peripherals/zipcounter.v">performance
counters</a>
may be found within the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf">reference manual</a>.</p>

<p>The third section of the display in Fig 3 is the
<a href="/about/zipcpu.html">CPU</a>
register section.  As you may
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">recall</a>, the
<a href="/about/zipcpu.html">ZipCPU</a>
has two sets of sixteen 32-bit registers.  These are shown in this section.
The registers range from R0 to R12, and then the
<a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer (SP)</a>,
<a href="https://en.wikipedia.org/wiki/Status_register">condition codes register (CC)</a>,
and <a href="https://en.wikipedia.org/wiki/Program_counter">program counter (PC)</a>.
The supervisor set is shown on top, the user set underneath.  The set that
is highlighted indicates which mode the
<a href="/about/zipcpu.html">CPU</a>
is currently in–in this case, the
<a href="/about/zipcpu.html">CPU</a>
is in supervisor mode.</p>

<p>The fourth section, coming down from the top, tells you about the bus.
The <code class="language-plaintext highlighter-rouge">PF BUS</code> line gives you information about the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
unit, and the <code class="language-plaintext highlighter-rouge">MEMBUS</code> line tells you about the memory module.  The third line
shows the result of the output of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v">arbiter</a>,
and which of these units actually has access to the bus.</p>

<p>The final section shows the <a href="/zipcpu/2017/08/23/cpu-pipeline.html">instruction
pipeline</a>.  As you may
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">remember</a>, the
<a href="/about/zipcpu.html">ZipCPU</a>
has a basic five stage <a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a>.  The bottom of the display shows only four
lines.  These are the output of the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a> (<code class="language-plaintext highlighter-rouge">I</code>), the
output of the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v">instruction
decoder</a>
(<code class="language-plaintext highlighter-rouge">Dc)</code>, the output of the read operands section (<code class="language-plaintext highlighter-rouge">Op</code>) and the result of the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a> (<code class="language-plaintext highlighter-rouge">Al</code>).</p>

<p>Indeed, this section is <em>so</em> important for understanding how the
<a href="/about/zipcpu.html">CPU</a> works, that we should take a deeper
look at it.  If you hold and press the ‘t’ key for a while, you’ll come across
the state shown in Fig 4 below.</p>

<table align="center" style="float: none"><caption>Fig 4, Instruction Pipeline</caption><tr><td><img src="/img/cpu-build/zipsim-insns.png" alt="" width="662" /></td></tr></table>

<p>The first two columns on the left will show <code class="language-plaintext highlighter-rouge">Ck</code> to indicate that the <a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a>
stage’s <code class="language-plaintext highlighter-rouge">CE</code> line is high, or <code class="language-plaintext highlighter-rouge">Stl</code>, to show that the particular stage is
<em>stalled</em>.  Most instructions will be followed by a <code class="language-plaintext highlighter-rouge">:</code>, although the first
half of any compressed instruction will be followed by a <code class="language-plaintext highlighter-rouge">/</code>.  Following
the decode stage, either an <code class="language-plaintext highlighter-rouge">A</code> (ALU), <code class="language-plaintext highlighter-rouge">M</code> (memory), or <code class="language-plaintext highlighter-rouge">I</code> (illegal)
character may follow the <code class="language-plaintext highlighter-rouge">;</code> (or <code class="language-plaintext highlighter-rouge">/</code>).  Immediately after this (optional)
character, is the address the instruction was read from.
If an instruction follows, as with all of the stages in Fig 4
above, then the particular
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a>
stage has valid values within it.
If the instruction is highlighted, its being run in supervisor mode.
These instructions, therefore, are being run from user mode.</p>

<p>Is this making any sense?  Perhaps you might then be interested in the homework
section that follows.</p>

<h2 id="interactive-homework">Interactive Homework</h2>

<p>One of the really fun parts of
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">this simulation</a>.
is watching how the performance
of the <a href="/about/zipcpu.html">CPU</a>
is impacted by how well the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
mechanism works.  This is primarily controlled by some <code class="language-plaintext highlighter-rouge">define</code>s within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v">cpudefs.v</a> file.</p>

<p>Since you’ve already looked at how the
<a href="/about/zipcpu.html">CPU</a>
operates in its default configuration with a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">prefetch and cache</a>
enabled,
let’s see how it does with some other
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
module’s enabled.  Hence, for a second test, let’s uncomment the
<code class="language-plaintext highlighter-rouge">OPT_DOUBLE_FETCH</code> define within
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v">cpudefs.v</a>,</p>

<figure class="highlight"><pre><code class="language-verilator" data-lang="verilator">define OPT_DOUBLE_FETCH</code></pre></figure>

<p>You will then need to re-run make in the
“<a href="https://github.com/ZipCPU/zipcpu/tree/master/rtl">rtl/</a>” directory,
as well as the
“<a href="https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated">sim/verilated</a>”
directory.</p>

<p>This will switch the CPU from using the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a> and
<a href="https://en.wikipedia.org/wiki/CPU_cache">I-cache</a>
of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">pfcache</a>
module, to using a module that fetches two instructions at a time:
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">dblfetch</a>.
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">dblfetch</a>
was designed to be a simpler
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
than the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">pfcache</a>
module, but also to have better performance than the single instruction at a
time <a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">module</a>–especially
when reading instructions from
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>Speaking of the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">single prefetch</a>
module, why don’t we give that one a try?
To see how the
<a href="/about/zipcpu.html">CPU</a>
performs with a
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
module that only retrieves one instruction at a time, go ahead and uncomment
the <code class="language-plaintext highlighter-rouge">OPT_SINGLE_FETCH</code> line from within
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v">cpudefs.v</a>,</p>

<figure class="highlight"><pre><code class="language-verilator" data-lang="verilator">define OPT_SINGLE_FETCH</code></pre></figure>

<p>and then rerun make in the
“<a href="https://github.com/ZipCPU/zipcpu/tree/master/rtl">rtl/</a>” directory,
and
“<a href="https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated">sim/verilated</a>”
directories again.</p>

<p>See the difference?</p>

<p>With the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">prefetch + cache</a>, the
<a href="/about/zipcpu.html">CPU</a>
has to pause any time the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
line needs to be re-filled.  This is particularly pronounced at the beginning
of the
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation</a>
where you have to wait many clocks for the
<a href="/about/zipcpu.html">CPU</a>
to fill the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>.
You may also notice the effects of
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">this prefetch</a>
any time the
<a href="/about/zipcpu.html">CPU</a>
hits a
branch instruction, whether a
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">branch always <code class="language-plaintext highlighter-rouge">BRA</code></a>
or a conditional branch
(<a href="/zipcpu/2018/01/01/zipcpu-isa.html">nominally a conditional ADD
instruction</a>)–the
two will have different effects within the
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator</a>.
The
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">branch always</a>
instruction will suffer a single stall, and then (appear to) replace the
branch instruction moving through the
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a> with the
instruction prior to the
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
target.  This is primarily an effect within the
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator viewer</a>,
the
<a href="/about/zipcpu.html">CPU</a>
doesn’t actually execute this other instruction, but it does send the
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>’s
target address through the
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a>–leading to
the misleading view.  The
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">conditional branch</a>,
on the other hand, will clear the
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a>
anytime it is taken.  If the result is in the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>,
then the new instructions will start filling the (now empty)
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a>
following the branch.</p>

<p>On the other hand, with the
<a href="/zipcpu/2017/11/07/wb-formal.html">single prefetch</a>
module, the
<a href="/about/zipcpu.html">CPU</a>
is unable to fill its
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a>.
It seems to be forever fetching the next instruction, while spending
very little time actually executing instructions.</p>

<p>When I first saw this difference, I suddenly learned a lot about how
important the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
is to
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
performance.  It was for this purpose that I wanted to share
this demonstration with you–I just found it very valuable.</p>

<h2 id="next-time">Next Time</h2>

<p>Our next step, now that you’ve built the
<a href="/about/zipcpu.html">ZipCPU</a>
toolchain, will be to run the
<a href="/about/zipcpu.html">CPU</a>
<a href="https://github.com/ZipCPU/zbasic/blob/master/sw/board/cputest.c">test program</a>
program from within the
<a href="https://github.com/ZipCPU/zbasic">ZBasic</a>
repository.  This goes beyond testing just the
<a href="/about/zipcpu.html">CPU</a>–it involves testing a
<a href="https://github.com/ZipCPU/zbasic/blob/master/sw/verilated/qspiflashsim.cpp">simulated flash</a>
and a <a href="https://github.com/ZipCPU/zbasic/blob/master/sw/verilated/dbluartsim.cpp">simulated serial
port</a>–together
with their controllers.  If time permits, I’ll even add the instructions
to play <a href="https://github.com/ZipCPU/tttt">4x4x4 tic-tac-toe</a>
within that demonstration–it’s a fun game and a nice way to relieve the
stress of getting something new working.</p>

<p>Beyond that, I’ve still got a couple of blogging articles planned along
this line.  The next article I have planned will show how to add a
<a href="https://github.com/ZipCPU/wbpmic">microphone controller</a>
component to
<a href="/zipcpu/2017/11/07/wb-formal.html">wishbone bus</a>
within the
<a href="https://github.com/ZipCPU/zbasic">ZBasic</a>
implementation using
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>.  I’d also like to show
how you can profile a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
running
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">Dhrystone</a>
within a
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulator</a>,
using a capability similar to the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/pdump.cpp">pdump</a>
program.  This was also very instructive to me, since it helped me
understand where and when the
<a href="/about/zipcpu.html">CPU</a>
ended up stalling, and what it would stall for under a reasonable load.</p>

<p>So, stick around, there’s more coming!</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Shall the axe boast itself against him that heweth therewith? or shall the saw magnify itself against him that shaketh it? as if the rod should shake itself against them that lift it up, or as if the staff should lift up itself, as if it were no wood. (Isaiah 10:15)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
