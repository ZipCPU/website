<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A Quick Introduction to the ZipCPU Instruction Set</title>
  <meta name="description" content="Fig 1: The ZipCPU">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2018/01/01/zipcpu-isa.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">A Quick Introduction to the ZipCPU Instruction Set</h1>
    <p class="post-meta"><time datetime="2018-01-01T00:00:00-05:00" itemprop="datePublished">Jan 1, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1: The ZipCPU</caption><tr><td><img src="/img/zipcpu.png" alt="" width="360" /></td></tr></table>

<p>If you aren’t familiar with the
<a href="/about/zipcpu.html">ZipCPU</a>, then you should know that it
is my attempt at improving the publicly available
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">softcore CPU</a>
architectures.  It has been designed from the ground up to be a truly
<a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer"><em>Reduced</em> instruction set computer, or
RISC</a>
machine, to have
a simple
<a href="https://en.wikipedia.org/wiki/Instruction_pipelining">pipeline</a>
implementation, and yet to be able to run a multi-tasking
<a href="https://en.wikipedia.org/wiki/Operating_System">operating system</a>
if desired.  Unlike many of the other more common
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core CPU</a>s,
such as
<a href="https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf">MicroBlaze</a>
or the <a href="https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf">NiosII</a>,
the <a href="/about/zipcpu.html">ZipCPU</a> has been created in a
completely open source fashion.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> was also designed to
run on the cheaper, more commodity,
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
hardware platforms.
Indeed, in many ways this has always been the philosophy behind the
<a href="/about/zipcpu.html">ZipCPU</a>: be small and simple, yet
fully and completely functional.  I judged, as I built it this way, that not
only would it be easier to build and debug a simpler
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
but also that it would be easier to add to an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
project as an afterthought if it was small.</p>

<table align="center" style="float: left"><caption>Fig 2: A Cheaper CPU: Teensy LC</caption><tr><td><a href="https://www.pjrc.com/teensy/"><img src="/img/teensy.jpg" alt="A Picture of the Teensy CPU" width="120" /></a></td></tr></table>
<p>Consider, for a moment: if you bought an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
you did so for a purpose.  If you wanted a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
instead then there are many other
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
that you could have bought that would have run faster, and cost less, than
the <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
you purchased.  As an example, Fig 2 shows a picture of the <a href="https://www.pjrc.com/teensy">TeensyLC</a>–a small
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
that sells for only $15USD.  Since you didn’t purchase a
<a href="https://www.pjrc.com/teensy">TeensyLC</a>, you must have purchased that
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
for a reason–to perform a task that you couldn’t do with an off-the-shelf
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
Indeed, I would imagine you want as much of your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
available to complete that task as possible.
If, in the process, you find yourself needing a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> on the same
chip as your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>–then
you want that
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
to stay out of the way, and to consume as few resources as possible.</p>

<p>This is, and was, the purpose of the
<a href="/about/zipcpu.html">ZipCPU</a>.</p>

<p>We’ve already discussed several of the parts and pieces of the
<a href="/about/zipcpu.html">ZipCPU</a> across many articles over
the last year.  For example, we discussed the divide unit when we discussed
<a href="/blog/2017/06/12/minimizing-luts.html">minimizing FPGA resource
allocation</a>.
We discussed the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
unit when describing how a <a href="/zipcpu/2017/08/11/simple-alu.html">simple ALU might be
structured</a>.
We discussed the <a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">debugging needs of a
CPU</a> in general,
as well as how to meet those needs in both
<a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">simulation</a> and
in the <a href="/zipcpu/2017/08/25/hw-debugging.html">hardware</a>.  More
recently, we <a href="/zipcpu/2017/11/18/wb-prefetch.html">presented and formally verified a simple prefetch
engine</a> for the
<a href="/zipcpu/2017/11/07/wb-formal.html">wishbone bus</a>.  Indeed,
my recent post about the <a href="/zipcpu/2017/12/28/ugliest-bug.html">ugliest
bug</a>
I’ve ever encountered was also based upon my experiences with the
<a href="/about/zipcpu.html">ZipCPU</a>.</p>

<p>Today, let’s take a look at how the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/raw/master/spec.pdf">instruction set</a> is
laid out, and discuss a few of the ways it is different from some of the
other, more common,
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core CPU</a>s
of today.  Our intention will by no means be to present a complete description
of the <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">ISA</a>,
but rather an overview.  The
<a href="https://github.com/ZipCPU/zipcpu/raw/master/doc/spec.pdf">ZipCPU specification</a>should provide any missing details–if not, please let me know if you find
something missing and I can add it in.</p>

<h2 id="the-basic-operations">The Basic Operations</h2>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> was designed around a set
of instructions all having the very simple form,</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	OP.X #+Rb,Ra</code></pre></figure>

<table align="center" style="float: right"><caption>Fig 3: Generic ZipCPU Instruction Operation</caption><tr><td><img src="/img/zipcpu-op-logic.svg" alt="Ra &lt;= (if X) Ra (op) #+Rb" width="480" /></td></tr></table>

<p>You can read this generic instruction as: if <code class="highlighter-rouge">X</code> is true, then <code class="highlighter-rouge">OP</code> is applied
to the number <code class="highlighter-rouge">#</code> plus the value of register <code class="highlighter-rouge">Rb</code>, and the register <code class="highlighter-rouge">Ra</code>,
and the result is placed into <code class="highlighter-rouge">Ra</code>.  Here I’m using <code class="highlighter-rouge">#</code> to refer to an
immediate value–a fixed number encoded within the instruction stream.</p>

<p>Fig 3 attempts to show this operation graphically.  Two registers are read
from the register file, noted here as <code class="highlighter-rouge">Ra</code> and <code class="highlighter-rouge">Rb</code>.  An immediate is added
to register <code class="highlighter-rouge">Rb</code>, or alternatively the immediate replaces <code class="highlighter-rouge">Rb</code> entirely,
and the result joins <code class="highlighter-rouge">Ra</code> to be operated upon.</p>

<p>For <a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
instructions, the result is only written back if the condition is
true.</p>

<p>Memory instructions are just a touch different.  In the case of a memory
instruction, the <code class="highlighter-rouge">#+Rb</code> value (immediate number plus the value of register
<code class="highlighter-rouge">Rb</code>) is used as the address for the memory operation.  Further, the
operation only begins if the condition is true.  <code class="highlighter-rouge">Ra</code> is used as the
data source for a store operation, or the data result of a load operation.</p>

<table align="center" style="float: right"><caption>Fig 4: ZipCPU Instruction Format(s)</caption><tr><td><img src="/img/zipcpu-insn-form.png" alt="1'b0, 4'b Ra, 5'b Op, etc." width="633" /></td></tr></table>

<p>The encoding for this and other <a href="/about/zipcpu.html">ZipCPU</a> instructions are shown
in Fig 4 on the right.  Four bits are used to encode the destination register,
<code class="highlighter-rouge">Ra</code>, five bits are used to encode the opcode, <code class="highlighter-rouge">OP</code>, three bits are used to
encode the condition, <code class="highlighter-rouge">X</code>, and the remaining bits are used to encode whether
or not <code class="highlighter-rouge">Rb</code> is used and what immediate offset is used by the instruction.</p>

<p>Two instructions have special formats: the <code class="highlighter-rouge">MOV</code> (move) and <code class="highlighter-rouge">LDI</code> (load
immediate) instructions, we’ll come back to these further on.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> can also support
compressed instructions, with their format shown at the bottom of Fig 4.
While we’ll only touch on the <em>Compressed Instruction Set</em>
today, you can read all about these two-for-one instructions in the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/raw/master/doc/spec.pdf">specification</a> if you are
interested.</p>

<p>Indeed, the <a href="/about/zipcpu.html">ZipCPU</a> <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">instruction set
architecture</a>
 is just about that simple.  Still, let’s dig into some more details.</p>

<h2 id="the-basic-operations-in-more-detail">The Basic Operations, in more detail</h2>

<p>Most <a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">RISC</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
today tend to support a six bit opcode or larger.  This allows
these machines to support up to 64 basic instructions–or even more.
Not the <a href="/about/zipcpu.html">ZipCPU</a>.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> was designed to be a truly
<a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer"><em>Reduced</em> instruction set
computer</a>.
As a result, it doesn’t have nearly as many instructions as its competitors:
the <a href="http://www.latticesemi.com/~/media/LatticeSemi/Documents/UserManuals/JL/LatticeMico32ProcessorReferenceManual37.pdf">lm32 processor</a>,
<a href="https://raw.githubusercontent.com/openrisc/doc/master/archive/openrisc_arch.pdf">OpenRISC</a>,
<a href="https://riscv.org">RISC-V</a>,
<a href="https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf">NiosII</a>,
and <a href="https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf">MicroBlaze</a>.  We can go over some of these differences later.</p>

<table align="center" style="float: right"><caption>Fig 5: ZipCPU Instructions</caption><tr><td><img src="/img/zipcpu-insns.png" alt="(A chart of the [ZipCPU](/about/zipcpu.html) instructions)" width="378" /></td></tr></table>

<p>For now, let’s take a quick look at the <a href="/about/zipcpu.html">ZipCPU</a> instruction cheat sheet, shown
in Fig 5.  From here, you can see that the <a href="/about/zipcpu.html">ZipCPU</a> supports 25 basic
instructions.
It has four special instructions, <code class="highlighter-rouge">BREAK</code>, <code class="highlighter-rouge">LOCK</code>, <code class="highlighter-rouge">NOOP</code>, and <code class="highlighter-rouge">SIM</code>,
and another six instructions reserved for a floating point co-processor–these
are the <code class="highlighter-rouge">FP</code> instructions.  Further, eight instructions have been chosen to
also have a compressed representation.</p>

<p>That’s it.  There are no more or hidden instructions, although a lot of
the instructions within this list have some special functionality.</p>

<p>Shall we walk through these instructions, and discuss what each does in turn?</p>

<ul>
  <li>
    <p><strong>SUB</strong>tract, subtracts <code class="highlighter-rouge">#+Rb</code> from the value in <code class="highlighter-rouge">Ra</code>, leaving the result in
<code class="highlighter-rouge">Ra</code>.</p>

    <p>I’ll write this as <code class="highlighter-rouge">Ra &lt;= Ra - (#+Rb)</code> to facilitate a simpler notation,
since just about all of the instructions will have this form.</p>
  </li>
  <li>
    <p><strong>AND</strong>, <code class="highlighter-rouge">Ra &lt;= Ra &amp; (#+Rb)</code></p>
  </li>
  <li>
    <p><strong>ADD</strong>, <code class="highlighter-rouge">Ra &lt;= Ra + (#+Rb)</code></p>
  </li>
  <li>
    <p><strong>OR</strong>, <code class="highlighter-rouge">Ra &lt;= Ra | (#+Rb)</code></p>
  </li>
  <li>
    <p><strong>XOR</strong>, <code class="highlighter-rouge">Ra &lt;= Ra ^ (#+Rb)</code></p>
  </li>
  <li>
    <p><strong>LSR</strong>, <code class="highlighter-rouge">Ra &lt;= Ra &gt;&gt; (#+Rb)</code> (assumes Ra is unsigned)</p>

    <p>In all of the
<a href="/about/zipcpu.html">ZipCPU</a>’s
shift instructions, the last bit shifted out of <code class="highlighter-rouge">Ra</code> is placed into the
Carry flag.</p>

    <p>Further, these shift instructions accept requests for shifts outside of the
reasonable bounds <code class="highlighter-rouge">0--31</code>, permitting instead any shift amount between
<code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">2^31</code>–not that you’d need these extra amounts.</p>
  </li>
  <li>
    <p><strong>LSL</strong>, <code class="highlighter-rouge">Ra &lt;= Ra &lt;&lt; (#+Rb)</code></p>
  </li>
  <li>
    <p><strong>ASR</strong>, <code class="highlighter-rouge">Ra &lt;= Ra &gt;&gt; (#+Rb)</code></p>

    <p>This instruction implements an <a href="https://en.wikipedia.org/wiki/Arithmetic_shift">Arithmetic right
shift</a>.  This is
done by first assuming that <code class="highlighter-rouge">Ra</code> is
signed, and then propagating the sign bit from the MSB down.</p>
  </li>
  <li>
    <p><strong>BREV</strong>, This is the “bit-reverse” instruction.  For this instruction,
<code class="highlighter-rouge">Ra</code> is assigned the value of <code class="highlighter-rouge">(#+Rb)</code> but not until <code class="highlighter-rouge">(#+Rb)</code> has been
“bit-reversed”.  That is, bit 0 of <code class="highlighter-rouge">(#+Rb)</code> becomes bit 31 of <code class="highlighter-rouge">Ra</code>,
bit 1 becomes bit 30, etc.</p>

    <p>This instruction is very unique to the <a href="/about/zipcpu.html">ZipCPU</a>, and yet it is also very
fundamental to how the <a href="/about/zipcpu.html">ZipCPU</a> operates.  By using a <strong>BREV</strong> instruction,
the <a href="/about/zipcpu.html">ZipCPU</a> can load any
18-bit value into the upper bits of a register.  If it is then followed by
a <strong>LDILO</strong>, the pair of instructions can then load any 32-bit value into
a register.</p>

    <p>The <strong>BREV</strong> instruction is also very useful for bit-reversed addressing and
bit-manipulation functions–such as counting trailing zeros in a number.
It’s also used for the <strong>CLR</strong> (clear register) derived instruction.</p>
  </li>
  <li>
    <p><strong>LDILO</strong>, or Load Immediate Lo, assigns the lower 16 bits of <code class="highlighter-rouge">Ra</code> to the
lower 16 bits of <code class="highlighter-rouge">(#+Rb)</code></p>
  </li>
  <li>
    <p><strong>MPYUHI</strong>, or multiply unsigned values and return the upper 32-bits, sets
<code class="highlighter-rouge">Ra</code> to <code class="highlighter-rouge">(Ra*(#+Rb)) &gt;&gt;32</code>.  The multiplication involved assumes both
<code class="highlighter-rouge">Ra</code> and <code class="highlighter-rouge">(#+Rb)</code> are unsigned numbers.</p>
  </li>
  <li>
    <p><strong>MPYSHI</strong>, or multiply signed values and return the upper 32-bits, is
identical to <code class="highlighter-rouge">MPYUHI</code>, with the exception that the multiplication is done
assuming both <code class="highlighter-rouge">Ra</code> and <code class="highlighter-rouge">(#+Rb)</code> are signed numbers.</p>
  </li>
  <li>
    <p><strong>MPY</strong>, a 32x32-bit multiply which returns the lower bits of the result.
Basically, this is given by <code class="highlighter-rouge">Ra &lt;= Ra * (#+Rb)</code>, with the exception that
<code class="highlighter-rouge">Ra</code> is set to the lower 32-bits of the product.</p>
  </li>
  <li>
    <p><strong>DIVU</strong>, a 32x32-bit unsigned divide.  <code class="highlighter-rouge">Ra &lt;= Ra / (#+Rb)</code></p>
  </li>
  <li>
    <p><strong>DIVS</strong>, a 32x32-bit signed divide. <code class="highlighter-rouge">Ra &lt;= Ra / (#+Rb)</code></p>
  </li>
  <li>
    <p><strong>CMP</strong>, Compare.  Sets the flags according to <code class="highlighter-rouge">Ra - (#+Rb)</code>.  This
instruction is implemented identically to the <strong>SUB</strong> instruction above,
save that <em>only</em> the flags are affected by a <strong>CMP</strong> instruction.  <code class="highlighter-rouge">Ra</code>
is not written back to the register file.</p>
  </li>
  <li>
    <p><strong>TEST</strong>, is identical to the <strong>AND</strong> instruction, save that like the <strong>CMP</strong>
instruction, <strong>TEST</strong> only sets the flags register and leaves <code class="highlighter-rouge">Ra</code> untouched.</p>
  </li>
</ul>

<p>Two more basic instructions have subtly different forms.</p>

<ul>
  <li>
    <p><strong>MOV</strong>, a move instruction, <code class="highlighter-rouge">Ra &lt;= (#+Rb)</code>.  In this case, the move
instruction always has an <code class="highlighter-rouge">Rb</code> register.  If you want to move just the
constant into a register, then use the <strong>LDI</strong> instruction instead.</p>

    <p>The <strong>MOV</strong> instruction has the additional capability of moving values
between register sets–something we’ll need to get to later.  As a result,
the range of the immediate values supported by the move instruction (13-bits)
is not quite as many as those supported by the rest of the instructions
above (either 14-bits or 18-bits).</p>
  </li>
  <li>
    <p><strong>LDI</strong>, or load immediate, has a little bit of a different form.  The
<strong>LDI</strong> instruction has no <code class="highlighter-rouge">Rb</code> register option.  It is used for loading
arbitrary values into <code class="highlighter-rouge">Ra</code>, and written as <code class="highlighter-rouge">Ra &lt;= #</code>.</p>

    <p>This instruction has
also been stripped to its bare essentials to be able to load the largest
value into a register as possible.  As a result, it can load any 23-bit
signed value into a register.  Anything more requires a combination of a
<code class="highlighter-rouge">BREV</code> instruction and an <code class="highlighter-rouge">LDILO</code> instruction.</p>
  </li>
</ul>

<p>The next six instructions are memory instructions.  These are written a little
differently, but they still read from left to right.  For example,</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	SW.X Ra,#(Rb)</code></pre></figure>

<p>stores the value of <code class="highlighter-rouge">Ra</code> into the address given by <code class="highlighter-rouge">#</code> plus the <code class="highlighter-rouge">Rb</code> register,
while</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	LW.X #(Rb),Ra</code></pre></figure>

<p>loads the value of <code class="highlighter-rouge">Ra</code> based upon the contents of memory given by the address
in <code class="highlighter-rouge">Rb</code> plus the offset, <code class="highlighter-rouge">#</code>.  Both of these can be executed conditionally,
if the condition <code class="highlighter-rouge">X</code> is true.  (More on that later.)</p>

<p>Both of these instructions operate on a word, hence their mnemonic is
<em>store word</em> or <em>load word</em> respectively.  The <a href="/about/zipcpu.html">ZipCPU</a> supports four other
memory instructions:</p>

<ul>
  <li><strong>LH</strong> or load halfword.  This instruction loads a 16-bit value from memory
into <code class="highlighter-rouge">Ra</code> and then clears the upper 16-bits to get the result to fit
into 32-bits.</li>
  <li><strong>SH</strong> or store halfword.  This instruction stores the bottom 16-bits of a
register into memory.</li>
  <li><strong>LB</strong> or load byte.  The upper 24-bits are cleared.</li>
  <li><strong>SB</strong> or store byte</li>
</ul>

<p>These are all of the basic <a href="/about/zipcpu.html">ZipCPU</a> instructions.</p>

<table align="center" style="float: left"><caption>Fig 6: ZipCPU Instructions</caption><tr><td><img src="/img/zipcpu-insns-derived.png" alt="(A chart of several of the ZipCPU's derived instructions)" width="454" /></td></tr></table>
<p>See anything missing?  If you are familiar with other
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s,
you may notice <em>a lot</em> of missing instructions.  None of these,
however, are truly required as combinations of the instructions
above can be used to implement almost any
instruction you might need.  For example, Fig 6 shows several examples of
instructions the
<a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembler</a>
understands, yet whose implementation is derived from the instructions above.</p>

<p>Let’s back up a bit, though, and discuss the registers on the <a href="/about/zipcpu.html">ZipCPU</a>.</p>

<h2 id="the-basic-zipcpu-register-set">The Basic ZipCPU Register Set</h2>

<table align="center" style="float: right"><caption>Fig 7: ZipCPU Register Set</caption><tr><td><img src="/img/zipcpu-registers.png" alt="[ZipCPU](/about/zipcpu.html) registers: R0 (or LR), R1-R11, R12 (or FP), SP, CC, and PC.  There are two sets of these, one prefixed with u for user, the other prefixed with s for supervisor" width="360" /></td></tr></table>
<p>The <a href="/about/zipcpu.html">ZipCPU</a> supports sixteen 32-bit registers in two sets, but
we’ll come back to issue of the different register sets later.  For now,
each set of sixteen registers is organized into registers <code class="highlighter-rouge">R0</code>-<code class="highlighter-rouge">R15</code>.  From
the hardware standpoint, all but the last two are general purpose, whereas
the compiler treats all but four of these registers as general purpose
registers.</p>

<p>Of these sixteen registers, the hardware treats the last two as special purpose
registers.  <code class="highlighter-rouge">R15</code> is the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>,
or <code class="highlighter-rouge">PC</code>.  This register maintains
the address of the next instruction the <a href="/about/zipcpu.html">ZipCPU</a> will execute within it.
<code class="highlighter-rouge">R14</code> also has a special purpose–it is the <a href="https://en.wikipedia.org/wiki/Status_register">condition code and
status register</a>,
or <code class="highlighter-rouge">CC</code>.  Flags, such as whether or not the result of the last
operation was zero or not, are stored in the bottom four bits of the <code class="highlighter-rouge">CC</code>
register.</p>

<p>While the <a href="/about/zipcpu.html">ZipCPU</a> instruction set
doesn’t have any
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
instructions per se, three of the basic instructions above can be
applied to the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>
in order to create
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
instructions.</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">LDI #,PC</code> loads a 23’bit signed immediate value into the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>,
<code class="highlighter-rouge">PC</code>.  It can be used any time the absolute address of the destination
is known by the
<a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembler</a>
before linking–which isn’t very often.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ADD #,PC</code> adds an amount to the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>,
<code class="highlighter-rouge">PC</code>.  This will execute
a local <a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>,
causing the
<a href="/about/zipcpu.html">CPU</a>
to read its next instruction <code class="highlighter-rouge">#</code> words
earlier or later depending on the sign of <code class="highlighter-rouge">#</code>.  Since this is such a common
instruction, this is often abbreviated with by a
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
always instruction, <code class="highlighter-rouge">BRA &lt;address label&gt;</code>.</p>

    <p>The <code class="highlighter-rouge">BRA</code> instruction is often used for jumping between locations within a
given function–such as when executing a loop or an if.  It is used anytime
the <a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembler</a>
can tell that the distance to the target will fit within 18-bits.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">LW (PC),PC</code> followed by a new address, reads a new value of the program
counter from the next
word in instruction memory.  This instruction is used heavily by the linker,
since the next address in memory can later be simply set to any value once
that value is known.  This is also known as a <em>long jump</em> instruction,
and so the
<a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembler</a>
understands the <code class="highlighter-rouge">LJMP &lt;address label&gt;</code> mnemonic,
where <code class="highlighter-rouge">&lt;address label&gt;</code> is an
<a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembly</a>
label of where you wish to jump to.</p>

    <p>When the <a href="/about/zipcpu.html">ZipCPU</a> is built with the
early <a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branching</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v">option</a>, for
a cost of about 80 LUTs, and the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">prefetch with instruction
cache</a>,
this instruction only costs three clock cycles.</p>
  </li>
</ul>

<p>The <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/sw/gcc-zippatch.patch">port</a>
of <a href="https://gcc.gnu.org">GCC</a>
treats <code class="highlighter-rouge">R0</code>, <code class="highlighter-rouge">R14</code>, and (sometimes) <code class="highlighter-rouge">R13</code> as special registers.
<code class="highlighter-rouge">R0</code> is known as the link register, <code class="highlighter-rouge">LR</code>, where the return address to a
subroutine is kept.  This leads to two other instructions:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">MOV 8(PC),R0</code> followed by <code class="highlighter-rouge">LJMP &lt;function&gt;</code> is how the
<a href="/about/zipcpu.html">ZipCPU</a> implements
a long jump to subroutine command, <strong>LJSR</strong>–a shorter jump can be
implemented with the <code class="highlighter-rouge">BRA</code> instruction–but only if the destination is
known at
<a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembly</a>
time to be in range.  The
<a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembler</a>
handles all of the constants, and selects between the instruction forms
for you, so you may find these instruction pairs written in
<a href="https://en.wikipedia.org/wiki/Assembly_language">assembly</a>
as either <code class="highlighter-rouge">JSR &lt;function&gt;</code> or <code class="highlighter-rouge">LJSR &lt;function&gt;</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">MOV R0,PC</code> loads the link register back into the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>.  This
is often the last instruction in any function.  Indeed, it is so common
that the
<a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembler</a>
will also accept the <strong>RETN</strong> mnemonic for this instruction.</p>
  </li>
</ul>

<p>The <a href="https://gcc.gnu.org">GCC</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/sw/gcc-zippatch.patch">back
end</a>
uses <code class="highlighter-rouge">R14</code> as the <a href="https://en.wikipedia.org/wiki/Stack_register">stack
pointer</a>, <code class="highlighter-rouge">SP</code>.  Hence, you
might see <code class="highlighter-rouge">SW R0,(SP)</code> which will store <code class="highlighter-rouge">R0</code> onto the
<a href="https://en.wikipedia.org/wiki/Call_stack">stack</a>.
If you choose not to optimize your code, and sometimes even if you do,
the compiler will use <code class="highlighter-rouge">R13</code> as a frame pointer, <code class="highlighter-rouge">FP</code>.  This register is
similar to the <a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a>,
and used to reference local variables within a function.  In
general, I’ve tried to keep the compiler from using <code class="highlighter-rouge">R13</code> as a frame
pointer though–since it further limits the 14 general purpose registers.</p>

<p>It’s for these reasons that, at the beginning of any function, you’ll often
see code looking like:</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">function_name:
	SUB 12,SP
	SW  R0,(SP)
	SW  R1,4(SP)
	; etc</code></pre></figure>

<p>This allocates three words on the
<a href="https://en.wikipedia.org/wiki/Call_stack">stack</a>.
of four bytes each, and then uses the first two of them
to store <code class="highlighter-rouge">R0</code> and <code class="highlighter-rouge">R1</code> respectively–presumably because the compiled routine
is going to clobber those registers and wants to use their values or restore
them later.</p>

<p>You may then find, at the end that function, code that looks like,</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	LW  (SP),R0
	LW  4(SP),R1
	ADD 12,SP
	RETN	; Implemented as MOV R0,PC</code></pre></figure>

<p>This code loads the original values of <code class="highlighter-rouge">R0</code> and <code class="highlighter-rouge">R1</code> back from the
<a href="https://en.wikipedia.org/wiki/Call_stack">stack</a>,
restores the <a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a>,
to its original value, and then finally returns
to the place where it was called from.</p>

<h2 id="conditions">Conditions</h2>

<p>When I introduced the form of the
<a href="/about/zipcpu.html">ZipCPU</a> instructions above, I mentioned
that almost all instructions had the form <code class="highlighter-rouge">OP.X #+Rb,Ra</code>.  We’ve examined
the various operations, <code class="highlighter-rouge">OP</code>, and the various registers that <code class="highlighter-rouge">Ra</code> and <code class="highlighter-rouge">Rb</code>
can take on, but we haven’t discussed the conditions, <code class="highlighter-rouge">X</code>.
It is the condition <code class="highlighter-rouge">X</code> that allows almost every
<a href="/about/zipcpu.html">ZipCPU</a>
instruction to be executed <em>conditionally</em>.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> supports 8 conditions,
or possibly values for the <code class="highlighter-rouge">X</code>, as shown in Fig 8.</p>

<table align="center" style="float: none"><caption>Fig 8: ZipCPU Conditions</caption><tr><td><img src="/img/zipcpu-conditions.png" alt="[ZipCPU](/about/zipcpu.html) supports eight conditions: (none), if zero, if less than, if greater than or equal, if overflow, and negations of these for all but overflow" width="360" /></td></tr></table>

<ul>
  <li>
    <p>If no condition is specified with the instruction, then the
<a href="/about/zipcpu.html">ZipCPU</a> will always perform the
indicated instruction.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Z</code>, or the zero condition, will cause an instruction to only execute if
the <code class="highlighter-rouge">Z</code> flag in the
<a href="https://en.wikipedia.org/wiki/Status_register">condition codes</a> is set.</p>

    <p>If you are not familiar with
<a href="https://en.wikipedia.org/wiki/Status_register">condition codes</a>,
the basic idea is that if the
result of the last instruction was a <code class="highlighter-rouge">Z</code>ero, then the <code class="highlighter-rouge">Z</code> bit will be set.
Hence, if you compare (i.e. subtract) two registers and the result is zero,
then you know the registers are equal and you can use the <code class="highlighter-rouge">Z</code> bit to
do logic assuming the registers were equal.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">LT</code>, the less than condition, will cause an instruction to execute <em>only</em>
if the result of the last instruction was less than zero.  This is a
signed comparison result, focusing on the <code class="highlighter-rouge">N</code>egative bit in the
<a href="https://en.wikipedia.org/wiki/Status_register">condition codes</a>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">C</code>, will cause an instruction to execute only if the
<a href="https://en.wikipedia.org/wiki/Status_register">carry bit</a>
is set.</p>

    <p>This is also how the <a href="https://gcc.gnu.org">compiler</a>
implements an <em>unsigned less than</em> condition.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">V</code>, will cause an instruction to execute only if the
<a href="https://en.wikipedia.org/wiki/Status_register">o<code class="highlighter-rouge">V</code>erflow bit</a>
is set.  The <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/sw/gcc-zippatch.patch">port</a>
of <a href="https://gcc.gnu.org">GCC</a> doesn’t yet use this
<a href="https://en.wikipedia.org/wiki/Status_register">flag</a>,
but it may do so in the future.</p>
  </li>
</ul>

<p>The last three
<a href="https://en.wikipedia.org/wiki/Status_register">flags</a>
are just negations of the earlier
<a href="https://en.wikipedia.org/wiki/Status_register">flags</a>.
There’s <code class="highlighter-rouge">NZ</code>, or not zero, <code class="highlighter-rouge">GE</code>, or greater than or equal to, and there’s
<code class="highlighter-rouge">NC</code> to test if the carry bit is not set (i.e., unsigned greater than or
equal to).</p>

<p>The most common use of these conditions is in
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branching</a>
operators.  For
example, <code class="highlighter-rouge">ADD.Z #,PC</code> will cause the
<a href="/about/zipcpu.html">CPU</a>
to jump <em>only</em> if the <code class="highlighter-rouge">Z</code>ero bit is set.  Since this is also a
very common operation, the
<a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembler</a>
understands seven
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
instruction implementing <code class="highlighter-rouge">ADD.X</code>: <code class="highlighter-rouge">BZ</code>
(<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
if zero), <code class="highlighter-rouge">BNZ</code>
(<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
if not zero), <code class="highlighter-rouge">BLT</code>
(<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
if less than), <code class="highlighter-rouge">BGE</code>
(<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
if greater than or equal), <code class="highlighter-rouge">BC</code>
(<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
if carry is set), <code class="highlighter-rouge">BNC</code>
(<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
if carry is not set), and finally <code class="highlighter-rouge">BV</code>
(<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
on overflow).</p>

<p>You can also use these conditions to test multiple things at once.  For
example, suppose you wanted to know if registers <code class="highlighter-rouge">R0</code>, <code class="highlighter-rouge">R1</code>, <code class="highlighter-rouge">R2</code>, <em>and</em>
<code class="highlighter-rouge">R3</code> were all zero, and you wish to
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>
to some target if they are all zero.  In this case, you might write:</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	CMP 0,R0
	CMP.Z 0,R1
	CMP.Z 0,R2
	CMP.Z 0,R3
	BZ all_zero</code></pre></figure>

<p>You could also do a test of whether or not just one of them was zero,
such as:</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	CMP 0,R0
	CMP.NZ 0,R1
	CMP.NZ 0,R2
	CMP.NZ 0,R3
	BNZ one_of_these_is_nonzero</code></pre></figure>

<p>These work because the <code class="highlighter-rouge">CMP</code> and <code class="highlighter-rouge">TST</code> instructions <em>always</em> set the
<a href="https://en.wikipedia.org/wiki/Status_register">condition codes</a>–even
when executed conditionally.  Other instructions,
when executed conditionally, don’t affect the
<a href="https://en.wikipedia.org/wiki/Status_register">condition codes</a>–allowing
strings of conditional instructions to all depend upon the same condition.</p>

<p>A good example of multiple instructions depending upon a single condition
would be an integer absolute value calculation.
Suppose you wanted to calculate the absolute value of <code class="highlighter-rouge">R0</code> and leave the
result in <code class="highlighter-rouge">R0</code>.  You might then write,</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	TEST R0
	XOR.LT -1,R0
	ADD.LT 1,R0</code></pre></figure>

<p>The first instruction <code class="highlighter-rouge">AND</code>’s <code class="highlighter-rouge">R0</code> with <code class="highlighter-rouge">-1</code>–the default value if no other
value is given to <code class="highlighter-rouge">TEST</code>.  Since this is a <code class="highlighter-rouge">TEST</code> instruction, <code class="highlighter-rouge">R0</code> is
left unchanged and only the
<a href="https://en.wikipedia.org/wiki/Status_register">flags</a> are affected.
In this case, the <code class="highlighter-rouge">N</code> flag will be set if <code class="highlighter-rouge">R0</code> is negative.  We can then
complement every bit and add one to <code class="highlighter-rouge">R0</code> to negate it.
Notice how, in this process, the <code class="highlighter-rouge">XOR</code> instruction didn’t affect the
<a href="https://en.wikipedia.org/wiki/Status_register">flags</a>, making it possible
to string the <code class="highlighter-rouge">ADD</code> function to this chain as well–all operating only if
<code class="highlighter-rouge">R0</code> was negative.</p>

<p>Why are conditional instructions a good thing?  There is a real method and
purpose to this madness.  Conditional
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branches</a>
on the <a href="/about/zipcpu.html">ZipCPU</a>
cost about 5-clocks, whereas conditionally executed
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
instructions still cost only one clock.  Hence, the absolute value calculation
above costs 3-clocks (ignoring
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
stalls), whereas the alternative</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="n">TEST</span> <span class="n">R0</span>
	<span class="n">BGE</span>	<span class="n">dont_negate</span>
	<span class="n">XOR</span>	<span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">R0</span>
	<span class="n">ADD</span>	<span class="mi">1</span><span class="p">,</span><span class="n">R0</span>
<span class="n">dont_negate</span><span class="o">:</span></code></pre></figure>

<p>would cost four clocks if <code class="highlighter-rouge">R0</code> needed to be negated, and six clocks if it
didn’t.  This is in comparison to the three clocks for both conditions
presented above.</p>

<p>You may notice that for all of the extra functionality in this section and
the last, the <a href="/about/zipcpu.html">ZipCPU</a> still only offers the same basic 25-instructions.
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">Branches</a>,
jumps, and subroutine calls are just special cases of these same
instructions.</p>

<p>There are also some subtle details here as well.  For example, some
instructions aren’t allowed to set the
<a href="https://en.wikipedia.org/wiki/Status_register">condition codes</a>.
These include <code class="highlighter-rouge">MOV</code>, <code class="highlighter-rouge">BREV</code>, <code class="highlighter-rouge">LDILO</code> instructions and anything that
writes to the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>, <code class="highlighter-rouge">PC</code> or the
<a href="https://en.wikipedia.org/wiki/Status_register">condition code register</a>, <code class="highlighter-rouge">CC</code>.
In a similar fashion, any conditionally executed instruction, with the
exception of <code class="highlighter-rouge">CMP</code> and <code class="highlighter-rouge">TEST</code>, will not affect thew
<a href="https://en.wikipedia.org/wiki/Status_register">condition codes</a>.</p>

<p>Well, not quite.  The <a href="/about/zipcpu.html">ZipCPU</a> does
have four more <em>special</em> instructions that we need to discuss in the next
section.</p>

<h2 id="special-instructions">Special Instructions</h2>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> also supports four special
instructions: <code class="highlighter-rouge">BREAK</code>, <code class="highlighter-rouge">LOCK</code>, <code class="highlighter-rouge">SIM</code>, and <code class="highlighter-rouge">NOOP</code>.
Other special instructions, such as <code class="highlighter-rouge">RTU</code>, <code class="highlighter-rouge">STEP</code>, <code class="highlighter-rouge">WAIT</code>, or <code class="highlighter-rouge">HALT</code>, are
derived instructions from the basic instructions listed above.  We’ll
come back to the <code class="highlighter-rouge">RTU</code> instruction in the next section when we discuss
the purpose for the two separate register sets.</p>

<p>The <code class="highlighter-rouge">BREAK</code> instruction was built for the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugger</a>.
By replacing any instruction with a <code class="highlighter-rouge">BREAK</code> instruction, the currently
running code will halt at that instruction–without executing it.  This will
leave the
<a href="/about/zipcpu.html">CPU</a>
in a state where the debugger can then examine what’s going on within it,
single step over the break, and then continue until the next break.</p>

<p>The <code class="highlighter-rouge">LOCK</code> instruction is used to support
<a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> accesses.
<a href="https://en.wikipedia.org/wiki/Linearizability">Atomic</a>
instructions are ones where you want to read something from the bus, operate
upon it, and then return the modified value.  For example, an
<a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a>
increment might look like,</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	LOCK
	LW	(R0),R1
	ADD	1,R1
	SW	R1,(R0)</code></pre></figure>

<p>The <code class="highlighter-rouge">LOCK</code> function works by disabling
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>
and then making sure that
the <a href="/doc/wbspec_b4.pdf">wishbone</a> <code class="highlighter-rouge">CYC</code> line is not
lowered between the <code class="highlighter-rouge">LW</code> (load word) and <code class="highlighter-rouge">SW</code> (store word) instructions.
After three instructions, the number shown above, the lock is released.</p>

<p>The <code class="highlighter-rouge">NOOP</code> and <code class="highlighter-rouge">SIM</code> instructions are very similar, although they look
different on the surface.  <code class="highlighter-rouge">NOOP</code> is a simple
no-operation instruction–an instruction that doesn’t do anything.  When the
<a href="/about/zipcpu.html">ZipCPU</a> encounters a <code class="highlighter-rouge">NOOP</code> instruction,
it does nothing.  When the <a href="/about/zipcpu.html">ZipCPU</a>
encounters a <code class="highlighter-rouge">SIM</code> instruction, while running in hardware, the
<a href="/about/zipcpu.html">ZipCPU</a> halts with an illegal
instruction exception.</p>

<p>These two instructions have some other capabilities when used within the
simulator: they can be used to send values to the simulation terminal via
either <code class="highlighter-rouge">SOUT</code> (a SIM) or <code class="highlighter-rouge">NOUT</code> (a NOOP).
For example, you can print either a single character to the terminal,
<code class="highlighter-rouge">NOUT 'c'</code>, a register’s value, <code class="highlighter-rouge">NDUMP R0</code>, or even the full register bank to
the terminal, <code class="highlighter-rouge">NDUMP</code>, using the
lower bits of these commands.  The
<a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">assembler</a>
also understands mnemonics allowing you to string together multiple
characters into a single
<a href="https://en.wikipedia.org/wiki/Assembly_language">assembly</a>
command, either <code class="highlighter-rouge">NSTR</code> or <code class="highlighter-rouge">SSTR</code>, to print to the terminal.</p>

<p>In the case of the <code class="highlighter-rouge">NOOP</code> instructions, once placed onto the actual hardware
these simulation only capabilities will be quietly ignored.</p>

<h2 id="interrupts">Interrupts</h2>

<p>Let’s now come back to those two register sets, since they are used to
help the <a href="/about/zipcpu.html">ZipCPU</a> handle
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>.
Indeed, the <a href="/about/zipcpu.html">ZipCPU</a> has a fairly
unique <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
architecture.  For example, the <a href="/about/zipcpu.html">ZipCPU</a>
only recognizes one type of
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.
When the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
recognizes an <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>,
the <a href="/about/zipcpu.html">ZipCPU</a> just switches from user
to supervisor register sets.</p>

<table align="center" style="float: right"><caption>Fig 9: ZipCPU Operating Modes</caption><tr><td><img src="/img/zipcpu-modes.svg" alt="Reset -&gt; [ supervisor -&gt; user ]*" width="360" /></td></tr></table>

<p>Basically, it works like this: upon any reboot, the
<a href="/about/zipcpu.html">ZipCPU</a> boots into
<em>supervisor</em> mode.  This mode uses one set of sixteen registers—the
supervisor set.  When the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is ready to enable <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>s,
it switches to <em>user</em> mode where the other set of registers are used—the
user set.  Then, on any
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>, user trap,
or <a href="https://en.wikipedia.org/wiki/Trap_(computing)">processing exception</a>,
the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
returns to supervisor mode.</p>

<p>To make this possible, the <code class="highlighter-rouge">MOV</code> instruction has been given a special
capability.  It can be used to <code class="highlighter-rouge">MOV</code> registers between the two register
sets–but only when the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is in supervisor mode.</p>

<p>This means that
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>
for the <a href="/about/zipcpu.html">ZipCPU</a> are handled
differently from other processors as well, and so programming the
<a href="/about/zipcpu.html">ZipCPU</a>
is a little different for that reason as well.</p>

<p>For example, on most processors, an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
will:</p>

<ol>
  <li>
    <p>Automatically place a couple of user registers
(the <a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>,
<a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a>,
etc.) into a special place.  This may either be onto the
<a href="https://en.wikipedia.org/wiki/Call_stack">stack</a>,
in older <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">ISA</a>s,
or in a couple of special purpose registers–as on more recent
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s.</p>
  </li>
  <li>
    <p>The address of an <a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt service routine
(ISR)</a>
is then loaded from an <a href="https://en.wikipedia.org/wiki/Interrupt_vector_table">interrupt
table</a>, and the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
jumps to this address.</p>

    <p>This <a href="https://en.wikipedia.org/wiki/Interrupt_vector_table">table</a>
needs to be carefully set by a
<a href="https://en.wikipedia.org/wiki/Microcontroller">microcontroller</a>,
often in a special memory location or special purpose register.  Any
mistake in this process and the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
will try to execute instructions from a non-existent memory address.</p>
  </li>
  <li>
    <p>An <a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt service
routine</a> then runs to
“handle” the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.</p>

    <p><a href="https://en.wikipedia.org/wiki/Interrupt_handler">These routines</a>
are often built with very special rules.  This often
forces these routines to be built in
<a href="https://en.wikipedia.org/wiki/Assembly_language">assembly</a>.</p>
  </li>
  <li>
    <p>A special instruction such as an IRET instruction (interrupt return) is
issued at the end of the
<a href="https://en.wikipedia.org/wiki/Interrupt_handler">ISR</a>
to return to the previously running program.</p>
  </li>
</ol>

<p>This is not how
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>
work on the <a href="/about/zipcpu.html">ZipCPU</a>, nor does it
reflect how the <a href="/about/zipcpu.html">ZipCPU</a> is programmed.</p>

<p>As shown above in Fig 9, the <a href="/about/zipcpu.html">ZipCPU</a>
starts its processing in supervisor mode.  Before the
<a href="/about/zipcpu.html">CPU</a>
can switch to user mode, it creates a set of registers for
user mode.  These are either loaded via
the <a href="https://en.wikipedia.org/wiki/Assembly_language">assembly</a>.
<code class="highlighter-rouge">MOV</code> instructions, or by the <code class="highlighter-rouge">zip_restore_context(int *)</code> C-language
built-in.  This latter function call loads and sets all of the
<a href="/about/zipcpu.html">ZipCPU</a> registers from a memory array.
It can then switch to user mode via an <code class="highlighter-rouge">RTU</code> instruction.  The <code class="highlighter-rouge">RTU</code>
instruction itself is implemented by an <code class="highlighter-rouge">OR</code> instruction that just sets the
global <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
enable (<code class="highlighter-rouge">GIE</code>) bit in the
<a href="https://en.wikipedia.org/wiki/Status_register"><code class="highlighter-rouge">CC</code> register</a>.
A C-language built-in, <code class="highlighter-rouge">zip_rtu()</code>, can also be used to execute this jump
from C.</p>

<p>Once the <code class="highlighter-rouge">RTU</code> instruction is issued, the
<a href="/about/zipcpu.html">ZipCPU</a> starts executing instructions
using the user register set.</p>

<ul>
  <li>
    <p>If an <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
takes place while the <a href="/about/zipcpu.html">ZipCPU</a> is
in user mode, it will automatically switch back to supervisor mode.</p>
  </li>
  <li>
    <p>If an <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
is pending in supervisor mode, the <code class="highlighter-rouge">RTU</code> instruction will have no effect
and will leave the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
in supervisor mode.</p>
  </li>
  <li>
    <p>If the user program needs to return to supervisor mode, it can can clear
the <code class="highlighter-rouge">GIE</code> bit with either an <code class="highlighter-rouge">AND</code> or an <code class="highlighter-rouge">LDI</code> instruction.  This will send
the <a href="/about/zipcpu.html">ZipCPU</a> back into supervisor mode
as well.</p>
  </li>
  <li>
    <p>Other program errors, such as
<a href="https://en.wikipedia.org/wiki/Bus_error">bus errors</a>, illegal
instructions, division by zero exceptions, etc.,  encountered in user
mode will also return the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
to supervisor mode.</p>
  </li>
  <li>
    <p>The special <code class="highlighter-rouge">WAIT</code> instruction will cause the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
to enter into user mode (if it isn’t in user mode already), but then
sleep until the next interrupt.  This instruction is also implemented
via a basic <code class="highlighter-rouge">OR</code> instruction.  The <code class="highlighter-rouge">HALT</code> instruction acts in an identical
fashion when executed in user mode.  When executed in supervisor mode it
will actually <code class="highlighter-rouge">HALT</code> the CPU.</p>
  </li>
</ul>

<p>Once the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
returns from user mode, it will return to the supervisor
code where it left off.  You can see this in the multi-tasking code
found in the <a href="https://github.com/ZipCPU/s6soc">S6Soc</a>
<a href="https://github.com/ZipCPU/s6soc/blob/master/sw/zipos/kernel.c">kernel</a>
software.  From a high level, that code looks like:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">kernel_entry</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// ...
</span>	<span class="c1">// Set up a series of user tasks, and initialize their registers.
</span>	<span class="n">tasklist</span> <span class="o">=</span> <span class="n">ksetup</span><span class="p">();</span>

	<span class="c1">// Pick a current task, and load its registers into the user
</span>	<span class="c1">// register set
</span>	<span class="n">current</span> <span class="o">=</span> <span class="n">tasklist</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">restore_context</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>

	<span class="c1">// Enable interrupts ...
</span>	<span class="c1">// ...
</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="c1">// ....
</span>		<span class="n">SET_WATCHDOG</span><span class="p">;</span>
		<span class="n">zip_rtu</span><span class="p">();</span>

		<span class="c1">// Get interrupt information
</span>		<span class="n">pic</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">-&gt;</span><span class="n">io_pic</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pix</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// We came here because of an interrupt
</span>			<span class="c1">// ...
</span>			<span class="c1">// Handle any interrupts
</span>			<span class="c1">// ...
</span>		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">zip_ucc</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">CC_TRAPBIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// The user program has made a system call
</span>			<span class="c1">// ...
</span>			<span class="c1">// Handle any system calls
</span>			<span class="c1">// ...
</span>		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">zip_ucc</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CC_EXCEPTION</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// The user task encountered an exception
</span>			<span class="c1">// ...
</span>			<span class="c1">// Deal with any user exceptions
</span>			<span class="c1">// ...
</span>		<span class="p">}</span>

		<span class="c1">// Check if we need to switch tasks
</span>		<span class="c1">// ...
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">!=</span> <span class="n">last_context</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// If so, swap contexts
</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context_has_been_saved</span><span class="p">)</span>
				<span class="n">save_context</span><span class="p">(</span><span class="n">last_context</span><span class="p">);</span>
			<span class="n">restore_context</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Wow!  Did you catch that?  That’s the core code of a multi-tasking
<a href="https://en.wikipedia.org/wiki/Operating_System">operating system</a>!
Not only that, it was all written in C–no
<a href="https://en.wikipedia.org/wiki/Assembly_language">assembly</a>
instructions were required in the task swapping code above.</p>

<p>Did you notice where the return to userspace <code class="highlighter-rouge">RTU</code> instruction was?  That
was the <code class="highlighter-rouge">zip_rtu()</code> instruction.  Between when this instruction is issued
and when it returns, any user space program might run.</p>

<p>How about <a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>?
Did you notice where the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>
were handled?
<code class="highlighter-rouge">pic = _sys-&gt;io_pic</code> grabbed the current state of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v">interrupt controller</a>
(an external module), which could then be queried to see if the reason for
<code class="highlighter-rouge">zip_rtu()</code> returning was because of an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.</p>

<p>Indeed, once I realized how easy it was to swap between different tasks
in a multi-task concept, I found myself personally rather excited by the
possibilities that the <a href="/about/zipcpu.html">ZipCPU</a>
offered for studying
<a href="https://en.wikipedia.org/wiki/Operating_System">Operating System</a>
fundamentals from C.</p>

<p>Now, if I could just get enough time to finish integrating the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v">MMU</a>,
I might manage to even run a full
<a href="https://en.wikipedia.org/wiki/Operating_System">O/S</a>
on the <a href="/about/zipcpu.html">ZipCPU</a>.
<a href="https://en.wikipedia.org/wiki/Linux">Linux</a>
anyone?</p>

<h2 id="differences-between-other-cpus">Differences between other CPU’s</h2>

<p>Okay, so that’s what the <a href="/about/zipcpu.html">ZipCPU</a> instruction set looks like.  But how does
it compare to other
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft processors</a>?
In particular, the <a href="/about/zipcpu.html">ZipCPU</a>
instruction set could easily be compared to many other
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core CPU</a>s,
such as the <a href="http://www.latticesemi.com/~/media/LatticeSemi/Documents/UserManuals/JL/LatticeMico32ProcessorReferenceManual37.pdf">lm32 processor</a>,
<a href="https://raw.githubusercontent.com/openrisc/doc/master/archive/openrisc_arch.pdf">OpenRISC</a>,
<a href="https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf">NiosII</a>,
and <a href="https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf">MicroBlaze</a>.
Let’s take a look at some of the key differences between the <a href="/about/zipcpu.html">ZipCPU</a>
and some of these other processors.</p>

<p>The first big difference is that the
<a href="/about/zipcpu.html">ZipCPU</a> does not support three operand
instructions.  An example of such an instruction might be to set register
<code class="highlighter-rouge">Rd</code> to the sum of <code class="highlighter-rouge">Ra</code> plus <code class="highlighter-rouge">Rb</code>, or <code class="highlighter-rouge">ADD Rd,Ra,Rb</code>.  Did you notice how
this instruction read right to left?  This is common with other instruction
sets as well.</p>

<p>Why doesn’t the <a href="/about/zipcpu.html">ZipCPU</a> offer three operand instructions?  Simply because
it would complicate the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v">instruction
decode</a>
logic.
In particular, you’d need to decode more than just the four basic instruction
formats above.  Most of these processors, for example, have instructions that
take zero operands, instructions that take one operand and an immediate
(<code class="highlighter-rouge">LDI</code>), instructions that take two registers and an immediate, and
instructions that take three registers and then have barely any room
for any immediate values (11’bits).</p>

<p>The next thing you’ll notice is that the <a href="/about/zipcpu.html">ZipCPU</a> has a 5-bit opcode
to select among the various instructions.  These other processors use a
6-bit opcode, and when that isn’t enough they steal bits (as in the case
of the <a href="https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf">MicroBlaze</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>)
from their immediate space.  The resulting reality is that
the <a href="/about/zipcpu.html">ZipCPU</a> actually has a more
<a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer"><em>Reduced</em> instruction set</a>
than these other processors.</p>

<p>When it comes to special registers, the
<a href="/about/zipcpu.html">ZipCPU</a> is actually very unique.
In contrast to
<a href="https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf">MicroBlaze</a>’s
25 special registers, or the 65+ special registers of either
<a href="https://openrisc.io">OpenRISC</a> or
<a href="https://riscv.org">RISC-V</a>,
the <a href="/about/zipcpu.html">ZipCPU</a> has only two special
hardware registers–the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>
and the
<a href="https://en.wikipedia.org/wiki/Status_register">condition codes register</a>.
Other functionality, such as the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v">interrupt controller</a>,
or even the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">direct memory access (DMA) engine</a>’s
control registers, are placed on an <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">external bus
near</a>
the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>,
so that these pieces may be added (or removed) according to the
needs (and logic scarcity) of your particular environment and application.</p>

<p>A fifth way the <a href="/about/zipcpu.html">ZipCPU</a> is unique is in the number of registers.  The <a href="/about/zipcpu.html">ZipCPU</a>
offers 14 general purpose registers to user space.  Most of these other
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
offer 32 registers–but only with a lot of caveats.
For example, you can’t use <code class="highlighter-rouge">R0</code> since the compiler
depends upon it to be equal to zero.  Another register may be used to form
constants in the assembler, and so its off limits to the compiler.  By the
time you drill down further, you’ll discover that perhaps only 24 registers
are available.  Of these 24, a rough half of them are assumed to be clobbered
on any function call and need to be saved on the stack anyway.  Further,
saving registers to the stack is really the limiting factor in any choice of
register size.  As a result, the
<a href="/about/zipcpu.html">ZipCPU</a>’s
14 general purpose registers really don’t limit the
<a href="/about/zipcpu.html">ZipCPU</a>’s performance significantly
in comparison to these other
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s.</p>

<p>When you start looking at actual instructions, the
<a href="/about/zipcpu.html">ZipCPU</a> might initially appear
less capable.  For example,
the <a href="/about/zipcpu.html">ZipCPU</a>
has no <code class="highlighter-rouge">ADDC</code> or <code class="highlighter-rouge">SUBC</code> instructions (add or
subtract with carry), neither does the
<a href="/about/zipcpu.html">ZipCPU</a> offer any <code class="highlighter-rouge">RSUB</code> reverse
subtract instruction, <code class="highlighter-rouge">SEXT</code> sign extension instructions, <code class="highlighter-rouge">CLZ</code> count leading
(or trailing) zero instructions, <code class="highlighter-rouge">ROL</code> rotate
left (or right) instructions and more.  However, these are all fairly rare
instructions and workarounds are easy to come by.  Indeed, the
<a href="/about/zipcpu.html">ZipCPU</a>
once had a rotate left instruction.  That instruction was later removed
because 1) the compiler never used it, 2) very simple alternative
instruction combinations were already available, and
the <a href="/about/zipcpu.html">ZipCPU</a> needed to support
8-bit bytes in order to be POSIX compliant.</p>

<p>Of course, the next place the
<a href="/about/zipcpu.html">ZipCPU</a> shines is with
its simplified bus architecture.  I’m not sure if you saw
<a href="https://forum.digilentinc.com/topic/4930-arty-microblaze-speed-question">this thread</a>
or not, but it shows that the
<a href="/about/zipcpu.html">ZipCPU</a>–even without a data cache,
can still outperform a
<a href="https://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf">MicroBlaze</a>
simply due to (what I believe is) its simplified bus architecture.</p>

<h2 id="next-lesson">Next Lesson</h2>

<p>There are actually many other features contained with the
<a href="/about/zipcpu.html">ZipCPU</a>, and even
other differences between it and other
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">softcore CPU</a>s,
then this simple post could discuss.  For example, the
<a href="/about/zipcpu.html">ZipCPU</a> can
<a href="/zipcpu/2017/08/25/hw-debugging.html">single step code</a>
from either supervisor or user mode and more.</p>

<p>Further, time wouldn’t permit discussing the various I/O peripherals that
can be optionally added to the
<a href="/about/zipcpu.html">ZipCPU</a>–peripherals such as an
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/icontrol.v">interrupt controller</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v">performance counters</a>, a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA controller</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/ziptimer.v">simplified timers</a>,
and more.  At least, time today won’t permit it.  These components are all
fair game for future blog posts.</p>

<p>Some parts of the <a href="/about/zipcpu.html">ZipCPU</a>,
however, remain a work in progress.  For example, while an
<a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v">exists</a>,
I have yet to integrate it into the rest of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>.
In particular, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">prefetch cache</a>
will need to know when to invalidate cache lines due to writes, something
I haven’t gotten to yet.  Likewise, while a
<a href="https://en.wikipedia.org/wiki/Cache_(computing)">data cache</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">implementation
exists</a>, it
also has yet to be integrated and has since become a touch out of date.  Once
those two are integrated, my next plan is to host
<a href="https://en.wikipedia.org/wiki/Linux">Linux</a>
from the <a href="/about/zipcpu.html">ZipCPU</a>–I just haven’t
gotten that far yet.  Perhaps the reason is … I haven’t needed to.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> “as is” is already a
very capable <a href="https://en.wikipedia.org/wiki/Microcontroller">microcontroller</a>,
just as it was designed to be.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Know ye not, that to whom ye yield yourselves servants to obey, his servants ye are to whom ye obey; whether of sin unto death, or of obedience unto righteousness? (Rom 6:16)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
