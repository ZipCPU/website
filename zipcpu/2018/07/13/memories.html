<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Formally Verifying Memory and Cache Components</title>
  <meta name="description" content="While I was in Italy forORCONF 2016I started scribbling out adata cachefor theZipCPU.  In many ways Ihad to.  TheZipCPUcompared nicely to many othersoft-core...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2018/07/13/memories.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/#training">Formal training</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Formally Verifying Memory and Cache Components</h1>
    <p class="post-meta"><time datetime="2018-07-13T00:00:00-04:00" itemprop="datePublished">Jul 13, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>While I was in Italy for
<a href="https://orconf.org/2016">ORCONF 2016</a>
I started scribbling out a
<a href="https://en.wikipedia.org/wiki/CPU_cache">data cache</a>
for the
<a href="/about/zipcpu.html">ZipCPU</a>.  In many ways I
had to.  The
<a href="/about/zipcpu.html">ZipCPU</a>
compared nicely to many other
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core CPU</a>
architectures in all but two important comparisons–the
<a href="/about/zipcpu.html">ZipCPU</a>
had neither
<a href="https://en.wikipedia.org/wiki/CPU_cache">data cache</a> nor
<a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>.</p>

<p>That was almost two years ago.</p>

<p>Since that time, I rewrote that
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data cache draft</a>
many times over, but never managed to bring my effort to the finish line.
The design was just never complete.  Indeed, I never got so far as to write
the bench test for it.</p>

<p>Two months ago, I tried again.  This time, I had a trick up my sleeve that I
never had before: I now understood how to
<a href="/blog/2017/10/19/formal-intro.html">formally</a>
describe a memory controller.  Using
<a href="http://www.clifford.at/yosys">Yosys</a>,
the design became much easier to build.  I could move quickly from one fault
to another, fixing one problem after another until I had a strong
confidence that the design would work.  No, I haven’t tested it on hardware
yet, but I know that when I do it will be close to all it needs to be.</p>

<p>How much of the design did I evaluate?  Using
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>,
I only ever needed to evaluate about 20 clocks worth of the design.
I evaluated both the first 20 clocks of the design, as well as an
arbitrary set of 20 clock periods somewhere in the middle of time.  That was it.
Put together, I now know
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">this data cache</a>
will maintain it’s
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
for all time.</p>

<p>This is in strong contrast to using a <a href="https://en.wikipedia.org/wiki/Bus_Functional_Model">Bus Functional Model
(BFM)</a>
to test whether a memory interface design works.  Consider, for example, this
<a href="https://opencores.org/project/wishbone_bfm">Wishbone BFM</a> by
Andrew Mulcock and posted on <a href="https://opencores.org">OpenCores</a>.  It is built
around a series of canned memory operations that can be applied to any
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>.  It
then uses random numbers and thousands (millions?) of randomly generated tests
to verify that a design works.</p>

<p>Wouldn’t you rather just check two sets of twenty steps, and then know that
your design will work for all time?</p>

<p>This is the benefit of
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>.</p>

<p>When dealing with memories, though, there is a simple trick you need to know
to make this happen.  That trick will be the focus of this article.  First,
I’ll explain the trick in the next section, we’ll then discuss how the trick
can be applied to
<a href="https://en.wikipedia.org/wiki/CPU_cache">caches</a>,
finally we’ll walk through the design of a
<a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">block RAM</a>
controller connected to the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>
as an example of how this trick can be applied.</p>

<h2 id="formal-verifying-memory-like-components">Formal Verifying Memory-like Components</h2>

<p>Okay, so here’s the trick to
<a href="/blog/2017/10/19/formal-intro.html">formally verifying</a>
memory-like components: assume an arbitrary address, construct the data at
that address, and then verify that transactions to/from this one arbitrary
address all match the data at this address.</p>

<p>Yes, it is that simple–<a href="/blog/2017/10/19/formal-intro.html">formally
verifying</a>
one <em>arbitrary</em> address is sufficient to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
the entire memory space.</p>

<p>Let’s walk through this concept a bit more.  We’ll start with an arbitrary
address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="p">(</span><span class="o">*</span> <span class="n">anyconst</span> <span class="o">*</span><span class="p">)</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_addr</span><span class="o">;</span></code></pre></figure>

<p>Since we want the solver to pick any constant address, we’ll use
<a href="http://www.clifford.at/yosys">Yosys</a>’s
<code class="highlighter-rouge">anyconst</code> attribute to capture this property.</p>

<p>We’re also going to need to start with the piece of data at that address.
In this case, we’ll just declare <code class="highlighter-rouge">f_data</code> as a register and initialize it
to the initial value of the memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">reg</span>	<span class="p">[</span><span class="n">DW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_data</span><span class="o">;</span>

<span class="k">initial</span> <span class="n">f_data</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Given these two values, we can now make our only assumption about them and
our memory.  After setting <code class="highlighter-rouge">f_data</code> to its initial value, we’ll then assert
that these two values match for the rest of time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>We’ll also want to assert that any memory read from this address must also
return <code class="highlighter-rouge">f_data</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span>
		<span class="c1">// A wishbone transaction
</span>		<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span>
		<span class="c1">// Reading from our memory
</span>		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
		<span class="c1">// At this address
</span>		<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_addr</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">)))</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">o_wb_data</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>That’s all that’s required for read only memories.</p>

<p>For memories with a write capability we’ll also need to change
our <code class="highlighter-rouge">f_data</code> value on any memory write.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="c1">// A wishbone transaction
</span><span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span>
		<span class="c1">// writing to our memory
</span>		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span>
		<span class="c1">// At this address
</span>		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_addr</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">))</span>
	<span class="c1">// Then overwrite f_data
</span>	<span class="n">f_data</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="o">;</span></code></pre></figure>

<p>That’s all it takes to
<a href="/blog/2017/10/19/formal-intro.html">formally</a>
describe and verify a memory.  Pretty simple, no?</p>

<h3 id="properties-of-a-read-only-cache">Properties of a read-only cache</h3>

<p>But what about a
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>?
I began this post by talking about implementing a
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a> for the
<a href="/about/zipcpu.html">ZipCPU</a>.
What does it take to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a> a
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>?</p>

<p>In the case of a read only
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>,
such as an instruction
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>,
the same basic principle applies.  You will need to support three basic
properties–roughly mirroring exactly those same basic properties that
we just discussed above.</p>

<ol>
  <li>
    <p>On any read resulting from a
<a href="https://en.wikipedia.org/wiki/CPU_cache#CACHE-MISS">cache miss</a>
for address <code class="highlighter-rouge">f_addr</code> from memory, <code class="highlighter-rouge">f_data</code> is the <em>assumed</em> result.</p>
  </li>
  <li>
    <p>If <code class="highlighter-rouge">f_addr</code> is currently a valid address within the
<a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a>,
then you’ll need to <em>assert</em> that <code class="highlighter-rouge">f_data</code> is the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
value at that location.</p>
  </li>
  <li>
    <p>On any return from the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
where <code class="highlighter-rouge">f_addr</code> is the address of the value
returned, then <em>assert</em> that <code class="highlighter-rouge">f_data</code> is result.</p>
  </li>
</ol>

<p>Remember the rule: assume inputs, assert local state and outputs.</p>

<p>Let’s look at an example of each of these properties.</p>

<p>The first property is to assume that the response from a bus transaction,
reading from <code class="highlighter-rouge">f_addr</code>, must return <code class="highlighter-rouge">f_data</code>.</p>

<p>Having done this a couple of times, I often find it valuable to create a wire
just to capture the logic of whether the current return is the return of
interest.  Not only does this logic simplify the assumption, but it also
has the additional property of creating a value in the trace
file, making it easier to trouble shoot what may be end up being very complex
logic.  In this case, let’s use <code class="highlighter-rouge">f_this_return</code> to represent if the <code class="highlighter-rouge">f_addr</code>
value is the current one being returned from the bus.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">wire</span>	<span class="n">f_this_return</span><span class="o">;</span></code></pre></figure>

<p>What value should this wire have?  Well, if you are incrementing <code class="highlighter-rouge">o_wb_addr</code>
with every address, and if <code class="highlighter-rouge">f_outstanding</code> captures how many requests are
outstanding, then the logic describing whether or not the current return
from the bus is the <code class="highlighter-rouge">f_addr</code> value might look like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">f_this_return</span> <span class="o">=</span> <span class="p">(</span><span class="n">o_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_ack</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_wb_addr</span><span class="o">-</span><span class="n">f_outstanding</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Of course, your logic might vary with your needs in your own
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a> design.</p>

<p>Using this <code class="highlighter-rouge">f_this_return</code> value, we then want to assume that any response
from the bus when <code class="highlighter-rouge">f_this_return</code> is true must equal <code class="highlighter-rouge">f_data</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">f_this_return</span><span class="p">)</span>
	<span class="k">assume</span><span class="p">(</span><span class="n">i_wb_data</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>That’s step one–<em>assume</em> that the input matches.</p>

<p>For the second property, we’ll need to <em>assert</em>
that if our arbitrary address is found within the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>,
then the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
value at that location must be <code class="highlighter-rouge">f_data</code>.
You’ll need this assertion in order to get your design to pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<p>This idea is a little bit more difficult to communicate–especially to someone
who hasn’t dealt with
<a href="https://en.wikipedia.org/wiki/CPU_cache">caches</a>
before.  (<a href="https://www.blueletterbible.org/kjv/jas/4/15">If the Lord is
willing</a>,
we’ll come back and discuss how to build a
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
like this later.)</p>

<p>In the two
implementations that I’ve built, all <a href="https://en.wikipedia.org/wiki/CPU_cache#Direct-mapped_cache">direct mapped
caches</a>,
I’ve split the address into
three basic sections, all shown below in Fig 1.  The
bottom <code class="highlighter-rouge">CS</code> bits are used to describe a location within the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a> memory, and
the bottom <code class="highlighter-rouge">LS</code> of those bits are used to describe a location within a
given
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
line.  I like to think of these values as the “cache size”
and the “line size” respectively, even though they are really the
log based two of those sizes.</p>

<p>The third component of the address is the “tag”.  This is the top portion of the
address, from <code class="highlighter-rouge">LS</code> on upwards.</p>

<p>You can see an address broken down into these separate components in
Fig 1 below.</p>

<table align="center" style="float: none"><caption>Fig 1. Components of a Cache Address</caption><tr><td><img src="/img/cache-tag.svg" alt="" width="640" /></td></tr></table>

<p>In this picture, you can see how the lowest two bits aren’t really part of the
word address.  These are the octet address bits, describing an octet’s position
within a 32-bit data word.  We’ll ignore these
sub-word address bits at this stage, though, focusing only on word addresses.</p>

<p>Second, you can see how the lowest <code class="highlighter-rouge">LS</code> bits are the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
line address.  These bits are not part of the tag, since all of the bits
within a given
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
line will share the same
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a> tag bits.</p>

<p>The <a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
itself is maintained as three arrays.  The first, simply called
<code class="highlighter-rouge">cache</code> below, uses the lower <code class="highlighter-rouge">CS</code> bits to address word sized memory values.
This is the block RAM data structure containing the values within the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a> itself.
The second array is a bit vector of <code class="highlighter-rouge">CS-LS</code> bits called <code class="highlighter-rouge">cache_line_valid</code>.
This tells you which
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
lines have valid values within them.
The third array is also indexed by the upper <code class="highlighter-rouge">CS-LS</code> bits of the <code class="highlighter-rouge">CS</code> bit
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
address.  This is an array of “tags”, called <code class="highlighter-rouge">cache_tag</code> below.
Hence, any time 1) a
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
line is valid, and 2) its tag matches <code class="highlighter-rouge">f_addr</code>,
then 3) the value within the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
must match <code class="highlighter-rouge">f_data</code> as well.</p>

<p>Here’s how we’d express that.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="c1">// If the cache line itself is valid
</span><span class="k">if</span> <span class="p">((</span><span class="n">cache_line_valid</span><span class="p">[</span><span class="n">f_addr</span><span class="p">[</span><span class="n">CS</span><span class="o">-</span><span class="n">LS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
	<span class="c1">//
</span>	<span class="c1">// and if this valid cache line's tag matches the top
</span>	<span class="c1">// "tag" bits of our address
</span>	<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">cache_tag</span><span class="p">[</span><span class="n">CS</span><span class="o">-</span><span class="n">LS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">f_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">LS</span><span class="p">]))</span>
	<span class="c1">//
</span>	<span class="c1">// then assert that this is the value in the cache
</span>	<span class="k">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">[</span><span class="n">f_addr</span><span class="p">[</span><span class="n">CS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>We’ll have to come back to this later and provide a proper description of
how to build a
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>.  For
now, this is the basics of how you would test
first that <code class="highlighter-rouge">f_addr</code> is in the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>, and second that
the value <code class="highlighter-rouge">f_data</code> is found at that location within the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>.</p>

<p>We now move on to the third
<a href="/blog/2017/10/19/formal-intro.html">formal property</a>
for read-only
<a href="https://en.wikipedia.org/wiki/CPU_cache">caches</a>,
that upon any return from the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
that comes from the <code class="highlighter-rouge">f_addr</code> address, the value returned should be <code class="highlighter-rouge">f_data</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">if</span> <span class="p">((</span><span class="n">output_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">output_address</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">))</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">output_word</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>These three properties, the assumption regarding the input, the assertion
regarding the internal state of the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>,
and the assertion about the output, are all that is needed to
<a href="/blog/2017/10/19/formal-intro.html">formally</a>
describe the required functionality of any read-only
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>.
That said, you might need to adjust how you express
these properties for your design, as not all
<a href="https://en.wikipedia.org/wiki/CPU_cache">caches</a>
have the same structure or the same register and memory names.</p>

<p>If you recall, we discussed these properties earlier–in our
<a href="/zipcpu/2018/03/21/dblfetch.html">pipelined prefetch
article</a>.  That article
discussed a simple two-element rolling instruction
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
design.</p>

<h3 id="properties-of-a-read-write-cache">Properties of a read-write cache</h3>

<p>What about a read-write
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>,
such as the
<a href="/about/zipcpu.html">ZipCPU</a>’s (brand new)
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data cache</a>
that I referenced above?  In this case, all of the properties of a read-only
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>,
listed above, still need to hold.  In addition, we also need to require that
<code class="highlighter-rouge">f_data</code> change upon any write as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">((</span><span class="n">write_request</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">write_address</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">))</span>
	<span class="n">f_data</span> <span class="o">&lt;=</span> <span class="n">write_value</span><span class="o">;</span></code></pre></figure>

<p>If your data value is
<a href="/zipcpu/2017/05/29/select-lines.html">octet addressable</a>,
and your word size is 32-bits,
you’ll need to do a bit more work–but we’ll get to that below.</p>

<p>You may also need to be careful with the timing of this write–it will need to
match the timing of any actual write to the
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a> memory or the second property
will fail.</p>

<p>That’s basically it.  These simple and basic properties are all that is needed
to <a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
any type of memory–whether it be block RAM, an external
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
or <a href="https://en.wikipedia.org/wiki/Flash_memory">flash device</a>,
a read-only
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>
or even a read-write
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>.
The approach is <em>very</em> versatile.</p>

<h2 id="block-ram">Block RAM</h2>

<p>Just to drive this lesson home, let’s work through the example of a <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">block RAM
memory controller</a>,
using this same approach, and let’s verify this block RAM responds
as it should.</p>

<p>If you’ve been building
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designs for long, you’ll know that creating a basic <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">block RAM
component</a>,
in Verilog consists of only a few lines of code.</p>

<p>First, we’ll need to declare our memory.  In this declaration <code class="highlighter-rouge">DW</code> is the
width of the data words contained in the memory, and <code class="highlighter-rouge">AW</code> is the number of
bits required to address it.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">DW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">mem</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">AW</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">;</span></code></pre></figure>

<p>Reading from memory is as simple as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">o_wb_addr</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">i_wb_addr</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>and writing to memory is only a touch more difficult.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_sel</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
		<span class="n">mem</span><span class="p">[</span><span class="n">w_addr</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w_data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span><span class="o">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_sel</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
		<span class="n">mem</span><span class="p">[</span><span class="n">w_addr</span><span class="p">][</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w_data</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span><span class="o">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_sel</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">mem</span><span class="p">[</span><span class="n">w_addr</span><span class="p">][</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w_data</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">8</span><span class="p">]</span><span class="o">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_sel</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">mem</span><span class="p">[</span><span class="n">w_addr</span><span class="p">][</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
<span class="k">end</span></code></pre></figure>

<p>Notice how we needed to check whether or not each individual octet was
being written, and then <a href="/zipcpu/2017/05/29/select-lines.html">only set that octet to the new
value</a> if so.</p>

<p>We’ve discussed both of these operations before.</p>

<p>I maintain a <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">block RAM
controller</a>
based upon these principles in the
<a href="https://github.com/ZipCPU/zbasic">ZBasic repository</a>.  We’ll examine
use this design for today’s discussion.</p>

<p>There are a couple of differences in <a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">this block RAM
controller</a> from
what we’ve just discussed above, although most of them are fairly superficial.
These come from the many years that I’ve worked with this controller.  For
example, on one high speed design I discovered I couldn’t get the request
from a corner of the chip to the dedicated block RAM on-chip hardware in
the center of the chip.  I managed to solve this by adding an extra clock
to memory, but made that extra clock optional–controlled by the parameter,
<code class="highlighter-rouge">EXTRACLOCK</code>.  Recently I added a preload option controlled by the parameter,
<code class="highlighter-rouge">HEXFILE</code>, and even a ROM option, <code class="highlighter-rouge">OPT_ROM</code> should you ever wish to create a
read-only memory instead of the more general purpose block RAM.</p>

<p>The basic controller that we just outlined above still remains within that
<a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">design</a>.  Indeed,
even with the little feature bloat discussed above, the 
<a href="https://github.com/ZipCPU/zbasic/blob/master/rtl/memdev.v">design</a>
remains quite simple and very readable.</p>

<h2 id="formal-properties">Formal Properties</h2>

<p>So what does it take to verify this controller?  We’ll skip through
some of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
properties and jump straight to the arbitrary address declaration.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="p">(</span><span class="o">*</span> <span class="n">anyconst</span> <span class="o">*</span><span class="p">)</span>	<span class="kt">wire</span>	<span class="p">[(</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_addr</span><span class="o">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">f_data</span><span class="o">;</span></code></pre></figure>

<p>These two values are assigned as we discussed above.</p>

<p>We then need to make certain that our RAM, at address <code class="highlighter-rouge">f_addr</code>, starts with
the initial data found in `f_data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="k">assume</span><span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>This guarantees that, should the memory be pre-loaded like a ROM, that the
two values start out identical.</p>

<p>Next, just as we adjusted our memory value on any write, <code class="highlighter-rouge">mem[f_addr]</code>,
we also need to adjust our data value, <code class="highlighter-rouge">f_data</code>, upon any write to <code class="highlighter-rouge">f_addr</code> as
well.  The code below is just a touch more complicated then we presented above,
simply because the code below only updates <code class="highlighter-rouge">f_data</code> if the ROM option,
<code class="highlighter-rouge">OPT_ROM</code>, is clear.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_ROM</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">F_MATCH_WRITES</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">w_wstb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_addr</span> <span class="o">==</span> <span class="n">w_addr</span><span class="p">))</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">w_sel</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
				<span class="n">f_data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w_data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span><span class="o">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">w_sel</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
				<span class="n">f_data</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w_data</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span><span class="o">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">w_sel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">f_data</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w_data</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">]</span><span class="o">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">w_sel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="n">f_data</span><span class="p">[</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w_data</span><span class="p">[</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">]</span><span class="o">;</span>
		<span class="k">end</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>In the case of a ROM, things are just a touch different.
First, we actually need to assign <code class="highlighter-rouge">f_data</code> to be <code class="highlighter-rouge">mem[f_addr]</code>.
This piece caught me by surprise.  It appears as though a value that isn’t
assigned is given an unknown value, <code class="highlighter-rouge">x</code>, that can change on every clock tick.
Hence, we make certain we assign it here.</p>

<p>Likewise, we assert that this value should never change–this is the ROM option
after all.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">f_data</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]</span><span class="o">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_past_valid</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_data</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">f_data</span><span class="p">))</span><span class="o">;</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>We conclude our proof by asserting that the memory at our our address <code class="highlighter-rouge">f_addr</code>,
<code class="highlighter-rouge">mem[f_addr]</code>, must always contain the value <code class="highlighter-rouge">f_data</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">mem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]</span> <span class="o">==</span> <span class="n">f_data</span><span class="p">)</span><span class="o">;</span>
<span class="cp">`endif</span>
<span class="k">endmodule</span></code></pre></figure>

<h2 id="conclusion">Conclusion</h2>

<p>Really, that’s all it takes–just a small number of assumptions and assertions
and you can verify that any memory controller will return the right data given
any address.  Further, notice how these same properties can be applied to both
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">instruction</a>
and
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data caches</a>,
to
<a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM</a> and
flash memory controllers, as well as our examples above.  Indeed, it was the
ease of describing how a
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data cache</a>
should work that made it so much easier to test when I finally finished
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">building it</a>
two months ago.</p>

<p>Would you believe this approach works for
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipmmu.v">MMU verification</a>
as well?  We may have to come back and discuss that later as well.  The approach
really is <em>very</em> flexible!</p>

<p>Now that you know the basics, we can come back to this topic later and discuss
how to build a basic
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">instruction</a>
or <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/dcache.v">data cache</a>,
such as the <a href="/about/zipcpu.html">ZipCPU</a> has.  That article
is still coming up.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Then will I remember my covenant with Jacob, and also my covenant with Isaac, and also my covenant with Abraham will I remember; and I will remember the land. (Lev 26:42)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
