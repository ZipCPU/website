<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Introducing the ArrowZip ZipCPU design, featuring the Max-1000</title>
  <meta name="description" content="Fig 1. The Max 1000">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2019/03/12/arrowzip.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Introducing the ArrowZip ZipCPU design, featuring the Max-1000</h1>
    <p class="post-meta"><time datetime="2019-03-12T00:00:00-04:00" itemprop="datePublished">Mar 12, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. The Max 1000</caption><tr><td><img src="/img/max1k/max1k-picture.png" alt="" width="320" /></td></tr></table>

<p>Some time ago, I
<a href="/blog/2017/12/16/max1k.html">wrote about the Max-1000 board</a>
sold by <a href="https://shop.trenz-electronic.de">Trenz</a> and distributed
in the US by <a href="https://www.arrow.com">Arrow</a>.  In
<a href="/blog/2017/12/16/max1k.html">that post</a>, I discussed
some of the problems associated with getting a design running on the
board, but also discussed its utility.</p>

<p>Indeed, <a href="https://www.arrow.com/en/campaigns/max1000">for $30, the Max-1000
board</a> is a nice entry board
for beginners — once you get past the difficulty associated with building
and loading a design onto the board, and once you get past the difficulty of
getting an <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/wbsdram.v">SDRAM
controller</a>
to work on the board.</p>

<p>For all of these reasons and more, I thought it might be a fun board to build
a demonstration design with.  Better yet, as of last week, <a href="https://github.com/ZipCPU/arrowzip">the
design</a> appears to be working!  Yes,
working:
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/dualflexpress.v">flash controller</a>,
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/wbsdram.v">SDRAM controller</a>,
and indeed everything but the
<a href="https://www.st.com/resource/en/datasheet/cd00274221.pdf">accelerometer</a>.
(That’s still on my TODO list.)</p>

<p>Shall we take a walk through the various parts of <a href="https://github.com/ZipCPU/arrowzip">the
repository</a>?</p>

<h2 id="lets-play">Let’s Play!</h2>

<p>Let’s start out with a quick list of things you can do (currently) with the
<a href="/about/zipcpu.html">ZipCPU</a> as found in <a href="https://github.com/ZipCPU/arrowzip">the ArrowZip
repository</a> of mine.</p>

<p>First, there’s the <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/cputest.c">CPU
test</a>.
We’ve <a href="/zipcpu/2018/02/12/zbasic-intro.html">met this program
before</a>.
It’s somewhat of a relic of time past when I used it to verify that the
<a href="/about/zipcpu.html">ZipCPU</a> worked at all.  Now, most
of the CPU testing is done via
<a href="/blog/2018/04/02/formal-cpu-bugs.html">formal methods</a>, but
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/cputest.c">this test</a>
remains.  It’s usually the first program I will place onto a new
<a href="/about/zipcpu.html">ZipCPU</a>
design.  As such, it runs from
<a href="/zipcpu/2018/07/13/memories.html">block RAM</a>
only.  To run this <a href="/blog/2018/08/22/what-is-simulation.html">from
simulation</a>,
build the design (i.e. run <a href="https://www.gnu.org/software/make">make</a>
in the root directory) and then go into the
<a href="https://github.com/ZipCPU/arrowzip/tree/master/sim/verilated">sim/verilated</a>
directory, and run:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% main_tb ../../sw/board/cputest</code></pre></figure>

<p>It will take a moment to run, and a bit longer to handle the multiplication
test, but pretty soon you’ll see the “All tests passed.  Halting CPU.” line.</p>

<table align="center" style="center"><caption>Fig 2. The Basic ZipCPU Self-Test Output</caption><tr><td><a href="/img/arrowzip-cputest.png"><img src="/img/arrowzip-cputest.png" alt="" width="540" /></a></td></tr></table>

<p>If you want to capture a trace of the entire run, just add “-d” to the
<code class="language-plaintext highlighter-rouge">main_tb</code> command line and run,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% main_tb <span class="nt">-d</span> ../../sw/board/cputest</code></pre></figure>

<p>This will create a <code class="language-plaintext highlighter-rouge">trace.vcd</code> file in your current directory that you can
view using <a href="http://gtkwave.sourceforge.net">GTKWave</a>.  Be prepared for it
to take a while, and to use more than 25GB of your hard drive.</p>

<p>On the other hand, if you want to load and test the design on
<a href="https://www.arrow.com/en/campaigns/max1000">the FPGA board</a>
itself, you’ll need to first build and load the design <a href="/blog/2017/12/16/max1k.html">as discussed
earlier</a>,
and then run
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/netuart.cpp">netuart</a>
to <a href="/blog/2017/06/17/why-network-debugging.html">bridge the serial port to a pair of network
ports</a>.  If we
assume the serial port connected to this device is at <code class="language-plaintext highlighter-rouge">/dev/ttyUSB0</code>, then you
would run
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/netuart.cpp">netuart</a>
from the <a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/host">sw/host
directory</a> as:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% netuart /dev/ttyUSB0</code></pre></figure>

<p>While <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/netuart.cpp">this
program</a>
is running, you will be able to <a href="/blog/2017/06/26/dbgbus-verilator.html">access the design through
the debugging bus</a>
on <a href="/blog/2017/06/17/why-network-debugging.html">TCP port <code class="language-plaintext highlighter-rouge">6955</code> and the serial port on TCP
port <code class="language-plaintext highlighter-rouge">6956</code></a>.
Hence, to interact with the design, you’ll want to telnet to port 6956.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% telnet localhost 6956</code></pre></figure>

<p>We can now load the <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/cputest.c">CPU
test</a>
into the <a href="/about/zipcpu.html">ZipCPU</a> and start it,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% ./zipload <span class="nt">-r</span> ../board/cputest</code></pre></figure>

<p>You’ll notice that the <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/cputest.c">CPU
test</a>
finishes almost instantaneously now–once it finishes getting loaded onto
the board.</p>

<p>This is interesting, but what else can we do?</p>

<p>We can test our <a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM
memory</a>
using a <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/memtest.c">memory test
program</a>
created just for that purpose.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% ./zipload <span class="nt">-r</span> ../board/memtest</code></pre></figure>

<p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/memtest.c">This program</a>
is a bit more confusing than the <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/cputest.c">CPU
test</a>,
since it doesn’t use the serial port
interface.  It works by writing to memory and then reading back from memory
as part of one of four tests.  After each test, the LEDs are adjusted, and
after the last test the fourth LED is toggled and the test is restarted.  If
at any time the value read from the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
doesn’t match the pseudorandom data that was written to it, all LEDs will be set
and the <a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a> will halt.
I would then bring up the
<a href="/about/zipcpu.html">ZipCPU</a> in the (very basic)
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugger</a>
to see what happened, although by now it should “just work” in case you wish
to try it.</p>

<p>The third piece of <a href="/about/zipcpu.html">ZipCPU</a> software is
“<a href="https://en.wikipedia.org/wiki/&quot;Hello,_World!&quot;_program">Hello World</a>.”</p>

<p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/hello.c">This program</a>
runs from
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
As before, the <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/zipload.cpp">zipload</a> program can be used to load this program into the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% ./zipload <span class="nt">-r</span> ../board/hello</code></pre></figure>

<p>It will take some time to program this design into the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.  To understand this
extended time, remember that
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/flashdrvr.cpp">driver</a>
works by:</p>

<ol>
  <li>First searching for any sectors (64kB each) that need to be erased (i.e. bits
that need to be flipped from zero to one), and then</li>
  <li>Erasing those sectors, and so turning all the bits to ones.</li>
  <li>Once the erase is complete, the
  <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
  <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/flashdrvr.cpp">driver</a>
  will re-read from the
  <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
  device to make certain that the erase has been successful.</li>
  <li>If the erase was successful, the
  <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/flashdrvr.cpp">driver</a>
  will proceed page by page, i.e. 256 bytes at a time) through the
  <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
  If any bit needs to be “programmed”, that is if it needs to be flipped from
  a one to a zero, then the whole 256-byte page will be programmed and then</li>
  <li>Read back again to verify the
  <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
  design load.</li>
</ol>

<p>This is a bit of a challenge on the low-logic serial port interface I call the
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">Hexbus</a>.  Each byte
needs to be read either once or twice to check the erase,
and then read twice and written once for the program section.  While the reads
are done 32-bits at a time, transmitted using more than 80 bit intervals, the
writes are done 8-bits at a time and transmitted using more than 80 bit
intervals per byte.  This is horribly inefficient, and I’m already considering
ways to optimize this in the future.</p>

<p>Once the <a href="/about/zipcpu.html">ZipCPU</a> program,
“<a href="https://en.wikipedia.org/wiki/&quot;Hello,_World!&quot;_program">Hello World</a>,”
is written to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
<a href="https://github.com/ZipCPU/arrowzip">the design</a> will
start running, and will write out,</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Hello, World!</code></pre></figure>

<p>to the serial port and thus to the TCP/IP port 6956.</p>

<p>These are the three current <a href="/about/zipcpu.html">ZipCPU</a>
examples I’ve written to date for this design.</p>

<p>There’s a lot more that can be done with this design that I haven’t (yet) done
with it.  For example, the
<a href="https://www.arrow.com/en/campaigns/max1000">MAX-1000 board</a>
has a <a href="https://www.st.com/resource/en/datasheet/cd00274221.pdf">3-axis nano accelerometer</a> on board.  I’ve thought about using
<a href="https://www.st.com/resource/en/datasheet/cd00274221.pdf">this accelerometer</a>
to create a level sensor.  I’ve also thought about using this design as an
unlicensed
<a href="https://github.com/ZipCPU/wbfmtx">FM transmitter</a>.  Last time I did that,
I used a <a href="https://github.com/ZipCPU/xulalx25soc">XuLA-LX25 board</a> to do it,
and struggled with maintaining a non-standard configuration of my project.</p>

<p>Perhaps I should just teach the design to play <a href="https://github.com/ZipCPU/tttt">4x4x4
Tic-Tac-Toe</a> as we did with
the <a href="/blog/2019/01/12/demoaxilite.html">ZBasic (simulation only)
design</a> before it?</p>

<p>The possibilities are endless!</p>

<h2 id="command-line-access">Command line access</h2>

<p><a href="https://github.com/ZipCPU/arrowzip/">The design</a> and the components within it
can also be accessed externally via <a href="/blog/2017/06/29/sw-dbg-interface.html">C++
calls</a>.  It’s been
a while since <a href="/blog/2017/07/08/getting-started-with-wbscope.html">I
discussed</a>
the <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/devbus.h">DEVBUS
interface</a>
that I use, but since that time <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/devbus.h">the
interface</a> has
hardly changed.  My design still supports reading from and writing
to the memory and peripheral address space within the design from external
C++ host programs.</p>

<p>For example, there’s a
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/dumpflash.cpp">dumpflash</a>
program in the <a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/host">sw/host</a>
directory.  <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/dumpflash.cpp">This
program</a>
reads and dumps the state of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
to a file on your host system.  It is centered around a single line calling the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/devbus.h">DEVBUS
interface</a>:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define	DUMPMEM		FLASHBASE
#define	DUMPWORDS	(FLASHLEN&gt;&gt;2)
</span><span class="c1">//</span>
<span class="c1">// ...</span>
<span class="c1">//</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vector_read</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// One single call to the DEVBUS interface to read from the</span>
		<span class="c1">// flash in the design</span>
                <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readi</span><span class="p">(</span><span class="n">DUMPMEM</span><span class="p">,</span> <span class="n">BUFLN</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">DEVBUS</span><span class="o">::</span><span class="n">BUSW</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">byteswapbuf</span><span class="p">(</span><span class="n">BUFLN</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">DEVBUS</span><span class="o">::</span><span class="n">BUSW</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span></code></pre></figure>

<p>Alternatively, we could split our massively long 8MB data read into multiple
reads, and read (and dump) one portion of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
at a time.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">        <span class="err">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Alternatively</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">BUFLN</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">DEVBUS</span><span class="o">::</span><span class="n">BUSW</span>    <span class="n">word</span><span class="p">;</span>

                        <span class="n">word</span> <span class="o">=</span> <span class="n">m_fpga</span><span class="o">-&gt;</span><span class="n">readio</span><span class="p">(</span><span class="n">DUMPMEM</span><span class="o">+</span><span class="n">i</span><span class="p">);</span>
                        
                        <span class="n">buf</span><span class="p">[</span><span class="n">i</span>  <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">;</span>
                        <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">;</span>
                        <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span><span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">;</span>
                        <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">word</span>    <span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0ff</span><span class="p">;</span>

                        <span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="o">&amp;</span><span class="mh">0x01ffc</span><span class="p">)</span><span class="o">==</span><span class="mh">0x01ffc</span><span class="p">)</span>
                                <span class="n">fwrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="o">&amp;~</span><span class="mh">0x1ffc</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">8192</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span> <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span></code></pre></figure>

<p><a href="https://github.com/ZipCPU/arrowzip">The design</a>
also supports a command line interface using the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/wbregs.cpp">wbregs command</a> we
<a href="/blog/2017/06/29/sw-dbg-interface.html">spoke of before</a>.
Basically, “wbregs address” will read from the given address
and return the result to the command line.  “wbregs address data” will similarly
write the value “data” to the given “address”.  What might you do with this?</p>

<p>The first thing I did with this was to try to debug my brand new <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/dualflexpress.v">flash
controller</a>.  <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/dualflexpress.v">This
controller</a> is part of my new
<a href="https://github.com/ZipCPU/qspiflash">“Universal flash controller”
project</a>, and now marks the second
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
chip that works with this
<a href="https://github.com/ZipCPU/qspiflash">new controller design</a>.
You can see the string of test commands I sent to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
in the <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/flashid.sh">flashid.sh</a>
script.  Only once I got the <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/dualflexpress.v">flash
controller</a>
to the point where I could successfully read the
manufacturer’s ID from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
did I then move towards replacing this script with a <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/flashid.cpp">C++ program to do the
same thing–only faster</a>.</p>

<p>We could also have some fun and play with our <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/rtcstopwatch.v">stopwatch
peripheral</a>.
Writing a <code class="language-plaintext highlighter-rouge">1</code> to the LSB starts the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/rtcstopwatch.v">stopwatch</a>,
writing <code class="language-plaintext highlighter-rouge">0</code> to the LSB stops it, and
writing bit 1 (i.e. a two) will clear the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/rtcstopwatch.v">stopwatch</a>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./wbregs stopwatch 1    <span class="c"># Start the stopwatch peripheral</span>
00800048 <span class="o">(</span>STOPWATCH<span class="o">)</span>-&gt; 00000001
<span class="nv">$ </span><span class="nb">sleep </span>2 <span class="c"># Wait two seconds</span>
<span class="nv">$ </span>./wbregs stopwatch    <span class="c"># Read from the stopwatch</span>
00800048 <span class="o">(</span>STOPWATCH<span class="o">)</span> : <span class="o">[</span>....] 80000202
<span class="nv">$ </span><span class="nb">sleep </span>6 <span class="c"># Wait six more seconds</span>
<span class="nv">$ </span>./wbregs stopwatch    <span class="c"># Read from the stopwatch again</span>
00800048 <span class="o">(</span>STOPWATCH<span class="o">)</span> : <span class="o">[</span>....] 80000806
<span class="nv">$ </span><span class="nb">sleep </span>2 <span class="c"># Wait another two seconds</span>
<span class="nv">$ </span>./wbregs stopwatch 0  <span class="c"># Stop the stopwatch</span>
<span class="nv">$ </span>./wbregs stopwatch    <span class="c"># Read, now that it has stopped</span>
00800048 <span class="o">(</span>STOPWATCH<span class="o">)</span> : <span class="o">[</span>....] 00001009
<span class="nv">$ </span>./wbregs stopwatch 2  <span class="c"># Clear the stop watch</span>
00800048 <span class="o">(</span>STOPWATCH<span class="o">)</span>-&gt; 00000002
<span class="nv">$ </span>./wbregs stopwatch    <span class="c"># and read it one final time</span>
00800048 <span class="o">(</span>STOPWATCH<span class="o">)</span> : <span class="o">[</span>....] 00000000</code></pre></figure>

<p>This is a
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">Binary-Coded Decimal (BCD)</a>
based
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/rtcstopwatch.v">stopwatch</a>.
The numbers given are in the form of HHMMSSmm,
or hours, minutes, and seconds, followed by tens of milliseconds.</p>

<p>We could also set the <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/rtctimer.v">timer</a> associated with the
<a href="https://github.com/ZipCPU/rtcclock">real-time clock</a>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>./wbregs timer 0x00130  <span class="c"># Set the timer to count-down a minute and a half</span>
00800044 <span class="o">(</span>   TIMER<span class="o">)</span>-&gt; 00000130
<span class="nv">$ </span>./wbregs timer          <span class="c"># Immediately read how far its counted</span>
00800044 <span class="o">(</span>   TIMER<span class="o">)</span> : <span class="o">[</span>...0] 01000130
<span class="nv">$ </span><span class="nb">sleep </span>75                <span class="c"># Wait 75 seconds</span>
<span class="nv">$ </span>./wbregs timer          <span class="c"># ... and read again</span>
00800044 <span class="o">(</span>   TIMER<span class="o">)</span> : <span class="o">[</span>....] 01000015
<span class="nv">$ </span><span class="nb">sleep </span>15                <span class="c"># Wait 15 seconds for it to finish</span>
<span class="nv">$ </span>./wbregs timer          <span class="c"># Now read, and notice the alarm bit is set</span>
00800044 <span class="o">(</span>   TIMER<span class="o">)</span> : <span class="o">[</span>....] 02000000</code></pre></figure>

<p>For now, let’s back up and discuss a bit more about the composition of the
<a href="https://github.com/ZipCPU/arrowzip">ArrowZip repository</a>
and the files within it, especially since this repository mirrors so many of
my other <a href="/projects.html">project</a>
repositories–should you be interested in wandering around and exploring.</p>

<h2 id="autofpga-scripts">AutoFPGA Scripts</h2>

<p><a href="https://github.com/ZipCPU/arrowzip">The ArrowZip repository</a>
is one of now several demonstration
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
repositories [<a href="https://github.com/ZipCPU/zbasic">1</a>]
[<a href="https://github.com/ZipCPU/icozip">2</a>]
[<a href="https://github.com/ZipCPU/tinyzip">3</a>]
[<a href="https://github.com/ZipCPU/videozip">4</a>]
[<a href="https://github.com/ZipCPU/openarty/tree/dev">5</a>].  You can find the basic
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
configuration scripts in the
<a href="https://github.com/ZipCPU/arrowzip/tree/master/auto-data">auto-data/</a>
directory.  As you may recall from my <a href="/zipcpu/2017/10/05/autofpga-intro.html">introduction to AutoFPGA
article</a>,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
connects independent components together into a design.  The goal is to compose
a design from components that can be added or removed from the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
command line,
with the details of how to connect a component found in the various
configuration files.  Don’t want a component?  Remove it from the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
command line!  Want to add one in?  Add a configuration file, and add it to the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
command line.</p>

<p>Indeed, if you look at the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/Makefile">Makefile</a>
found within the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
<a href="https://github.com/ZipCPU/arrowzip/tree/master/auto-data">configuration
directory</a>,
you’ll find a series of components used by the design.</p>

<p>I recently rebuilt how these files were placed onto the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
command line.  Here’s the current list of components in a
<a href="https://www.gnu.org/software/make">Makefile</a> format.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nv">BASE</span>    <span class="o">:=</span> global.txt dlyarbiter.txt
<span class="nv">AUX</span>     <span class="o">:=</span> version.txt buserr.txt pic.txt pwrcount.txt
<span class="nv">IO</span>      <span class="o">:=</span> spio.txt
<span class="nv">RTC</span>     <span class="o">:=</span> rtclight.txt
<span class="nv">DBGBUS</span>  <span class="o">:=</span> hbconsole.txt
<span class="nv">MEMORY</span>  <span class="o">:=</span> bkram.txt flexpress.txt sdram.txt
<span class="nv">CPU</span>     <span class="o">:=</span> zipbones.txt
<span class="nv">SCOPES</span>  <span class="o">:=</span> <span class="c"># flashscope.txt # sdramscope.txt # cpuscope.txt</span>
<span class="nv">LDSCRIPT</span><span class="o">:=</span> mem_all.txt mem_flash_bkram.txt mem_bkram_only.txt mem_sdram_bkram.txt
<span class="nv">DATA</span> <span class="o">:=</span> clock.txt <span class="nv">$(BASE)</span> <span class="nv">$(AUX)</span> <span class="nv">$(IO)</span> <span class="nv">$(RTC)</span>			<span class="se">\</span>
	<span class="nv">$(DBGBUS)</span> <span class="nv">$(MEMORY)</span> <span class="nv">$(CPU)</span> <span class="nv">$(SCOPES)</span> <span class="nv">$(LDSCRIPT)</span>

<span class="nv">AUTOFPGA</span> <span class="o">:=</span> autofpga
<span class="nl">$(AUTOFPGA)</span><span class="o">:</span>

<span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">data</span>
<span class="nl">data</span><span class="o">:</span> <span class="nf">$(AUTOFPGA) $(DATA)</span>
	<span class="nv">$(AUTOFPGA)</span> <span class="nt">-d</span> <span class="nt">-o</span> <span class="nb">.</span> <span class="nv">$(DATA)</span></code></pre></figure>

<p>The components of this design are:</p>

<ul>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/global.txt">global.txt</a>:
A set of global variable declarations, applying to the whole design</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/dlyarbiter.txt">dlyarbiter.txt</a>:
For timing reasons, both the
<a href="/about/zipcpu.html">ZipCPU</a> and the
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>
can’t drive the bus at the same time without a
<a href="/blog/2017/09/18/clocks-for-sw-engineers.html">single clock delay</a>.  This component
includes a
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/cpu/wbpriarbiter.v">bus arbitration core</a>
to determine which of the two
<a href="/blog/2017/06/08/simple-wb-master.html">bus masters</a>
gets access to the bus, followed by a
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/cpu/busdelay.v">bus delay</a>
to keep the <a href="/blog/2017/09/18/clocks-for-sw-engineers.html">clock speed up</a>.</p>

    <p>I’ll admit, this is a bit clumsy, so I’m now investigating whether or not I
can use <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
to connect multiple masters up to a full
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">crossbar</a>
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>.</p>

    <p>I’ll keep you posted on that project as it moves along.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/version.txt">version.txt</a>:
Ever had a time when you became quite frustrated that a design
wasn’t working, only to discover you never loaded the changes onto the
device?  The
<a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/version.txt">version.txt</a>
configuration places two single-address register components on the bus,
allowing me to determine when the design was built, as well as whether
the design is running in simulation or on the hardware.</p>

    <p>Yes, I did get burned multiple times when testing this design.  I was first
burned by not reloading the “program device” dialogue box in
<a href="https://www.intel.com/content/www/us/en/software/programmable/quartus-prime/overview.html">Quartus</a>, and
so it would continue reloading the prior design.  I was burned again later
after making changes and then loading a design onto the board, only to see
no changes to the design.  In that case, I was <a href="/blog/2017/06/17/why-network-debugging.html">interacting
with</a> the
<a href="/blog/2018/08/22/what-is-simulation.html">simulated</a>
design, which hadn’t gotten updated.
Ever since, this read-only register has been modified with a flag telling
me that it is <a href="/blog/2018/08/22/what-is-simulation.html">running in
simulation</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/buserr.txt">buserr.txt</a>:
One of the frustrating parts of debugging is trying to figure
out what caused the last
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
This component simply records the address
of the last
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
allowing me to read it out later.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/pic.txt">pic.txt</a>:
<a href="https://www.arrow.com/en/campaigns/max1000">The MAX-1000</a>
is a rather small
FPGA.  Normally, I would place a <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/cpu/icontrol.v">programmable interrupt controller
(PIC)</a>
right next to the <a href="/about/zipcpu.html">ZipCPU</a> and ship it
with what I call the
“<a href="/zipcpu/2018/02/12/zbasic-intro.html">ZipSystem</a>”,
containing a
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/cpu/icontrol.v">PIC</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA</a>,
<a href="/zipcpu/2018/04/17/ziptimer.html">timers</a>, <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/zipcounter.v">performance
counters</a>
and more.  However, if space is tight, I have to rapidly
<a href="/blog/2017/06/12/minimizing-luts.html">shed weight</a>.  After
<a href="/blog/2017/06/12/minimizing-luts.html">sheding the weight</a>,
the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
system that remains has only one
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/cpu/icontrol.v">PIC</a>,
and that is external to the
<a href="/about/zipcpu.html">CPU</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/pwrcount.txt">pwrcount.txt</a>:
Sometimes you need to sequence things on startup.  The
<code class="language-plaintext highlighter-rouge">pwrcount</code> component is nothing more than a 32-bit counter that keeps track
of the number of clocks since startup.  Once the counter overflows, the MSB
is held high and the rest of the counter just keeps going.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/spio.txt">spio.txt</a>:
Here’s where I will place any <a href="/blog/2017/08/09/series-debouncing.html">button</a>, switch, and/or LED
processing.  In the case of the
<a href="https://www.arrow.com/en/campaigns/max1000">MAX-1000</a>,
there are two buttons, 8-LEDs, and no switches.  Of those two buttons, only
one is user accessible, and so that’s the one coming into <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/spio.v">this design
component</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/rtclight.txt">rtclight.txt</a>:
Offers me access to a basic
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">BCD</a>
<a href="https://github.com/ZipCPU/rtcclock">real-time clock</a>,
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/rtctimer.v">count-down timer</a>,
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/rtcstopwatch.v">stopwatch</a>,
(with 10ms precision), and
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/rtcalarm.v">alarm</a>.</p>

    <p>The basic <a href="https://github.com/ZipCPU/rtcclock">real-time core</a> has been
around for quite some time, however I only recently took the time to split
it into its various component structures and to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
that all of them work.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/hbconsole.txt">hbconsole.txt</a>:
This component adds the
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>
to the design, offering me access
into the design to read from or write to any component.</p>

    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/hbconsole.txt">This configuration file</a>
also defines a console port that will be multiplexed with the
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>
over the serial port.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/bkram.txt">bkram.txt</a>:
The <a href="https://www.arrow.com/en/campaigns/max1000">MAX-1000</a>
has three types of memory available to it.  The
<a href="/zipcpu/2018/07/13/memories.html">block RAM memory</a>,
defined by <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/bkram.txt">this configuration
file</a>,
is of course the fastest but most limited
memory.  As currently configured, the
<a href="https://github.com/ZipCPU/arrowzip">ArrowZip design</a>
supports only 32768 bytes of memory, although
adjustments to this <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/bkram.txt">configuration
file</a>
can easily adjust that number down.</p>

    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/memdev.v">This block RAM component</a>
<a href="/zipcpu/2018/07/13/memories.html">has been formally
verified</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/flexpress.txt">flexpress.txt</a>:
This defines the interface to the (new)
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/dualflexpress.v">controller</a>.
This also marks only the second time I’ve used my brand-new
<a href="https://github.com/ZipCPU/qspiflash">“Universal” flash controller</a>
in a project.</p>

    <p>Yes, this
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/dualflexpress.v">controller</a>
has been <a href="/blog/2017/10/19/formal-intro.html">formally
verified</a>.</p>

    <p><a href="https://www.blueletterbible.org/kjv/jas/4/15">If the Lord wills</a>, I’m hoping
to post about this “Universal”
<a href="https://github.com/ZipCPU/qspiflash">flash controller</a>
design in an upcoming article.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/sdram.txt">sdram.txt</a>:
This configures the <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/wbsdram.v">SDRAM controller</a>.  When attached, the design
has access to the <a href="https://www.winbond.com/resource-files/w9864g6jt_a03.pdf">8MB SDRAM
chip</a> on the
board.  Yes, the design works.</p>

    <p>Even better, this
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/wbsdram.v">SDRAM controller</a>
has also been <a href="/blog/2017/10/19/formal-intro.html">formally
verified</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/zipbones.txt">zipbones.txt</a>:
Remember how I said this wasn’t the
<a href="/zipcpu/2018/02/12/zbasic-intro.html">ZipSystem</a>
distribution?
Without all of the peripherals kept next to the
<a href="/about/zipcpu.html">ZipCPU</a>, I call the
<a href="/about/zipcpu.html">CPU</a>
wrapper and interface to the rest of the design the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
since it is a bare-bones implementation of the
<a href="/about/zipcpu.html">ZipCPU</a>.  This <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/zipbones.txt">configuration file
component</a>,
therefore connects the <a href="/about/zipcpu.html">ZipCPU</a> with
the rest of the design.</p>

    <p>The <a href="/about/zipcpu.html">ZipCPU</a> has been <a href="/blog/2018/04/02/formal-cpu-bugs.html">formally
verified</a>,
although I have not done the same with either the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a> or the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>
wrappers yet.</p>
  </li>
  <li>
    <p><a href="/blog/2017/07/08/getting-started-with-wbscope.html">Scopes</a>:
As I was working with this design to get it to work, I used one
of three
<a href="/blog/2017/06/08/simple-scope.html">Wishbone Scope</a>
configurations.  <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/flashscope.txt">One was for the flash</a>,
<a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/sdramscope.txt">one for the SDRAM</a>,
and <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/zipscope.txt">another for the CPU</a>.
Since these aren’t permanent additions to the
design, they are currently commented out in the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/Makefile">Makefile</a>.</p>

    <p>Well, not quite.  I haven’t yet needed to use the <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/zipscope.txt">scope for the
ZipCPU</a>
within <a href="https://github.com/ZipCPU/arrowzip">this project</a>.</p>
  </li>
  <li>
    <p><a href="/zipcpu/2018/12/22/autofpga-ld.html">Linker scripts</a>:
There are four linker-script configuration files for the <a href="https://github.com/ZipCPU/arrowzip">ArrowZip
repository</a>, based upon four separate
memory configurations.  These were
designed to support first the <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/mem_bkram.txt">minimal required memory necessary to test that
the CPU would work, <code class="language-plaintext highlighter-rouge">mem_bkram.txt</code></a>, the next step up <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/mem_flash_bkram.txt">adding flash,
<code class="language-plaintext highlighter-rouge">mem_flash_bkram.txt</code></a>,
<a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/mem_sdram_bkram.txt">SDRAM and block RAM only, <code class="language-plaintext highlighter-rouge">mem_sdram_bkram.txt</code></a>, and
finally the <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/mem_all.txt">entire memory architecture on the board, <code class="language-plaintext highlighter-rouge">mem_all.txt</code></a>.</p>
  </li>
</ul>

<p>Given all of <a href="https://github.com/ZipCPU/arrowzip/tree/master/auto-data">these various configuration
files</a>,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
creates the following files:</p>

<ul>
  <li>
    <p>The <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/topleve.v">toplevel.v file</a>
of <a href="https://github.com/ZipCPU/arrowzip/">the design</a>.  This contains both
simulatable and non-simulatable components, and sometimes even vendor
specific components.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/main.v">The main.v file</a>
of the design is the top level
<a href="/blog/2018/08/22/what-is-simulation.html">simulatable</a>
component.  This is the file upon which
<a href="/blog/2017/06/21/looking-at-verilator.html">verilator</a>
is run.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sim/verilated/main_tb.cpp">sim/main_tb.cpp</a> and
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sim/verilated/testb.h">sim/testb.h</a>
are the two main simulation files which, when coupled with simulators for the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sim/verilated/dbluartsim.cpp">serial port</a>,
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sim/verilated/flashsim.cpp">flash</a>,
and the <a href="https://github.com/ZipCPU/arrowzip/blob/master/sim/verilated/sdramsim.cpp">SDRAM</a>
form the basis for <a href="/blog/2018/08/22/what-is-simulation.html">simulating the design in a cycle accurate
fashion</a> using
<a href="/blog/2017/06/21/looking-at-verilator.html">verilator</a>.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/zlib/board.h">sw/zlib/board.h</a>
describes the various peripherals within
<a href="https://github.com/ZipCPU/arrowzip/">the design</a> in a C-language friendly
way for any <a href="/about/zipcpu.html">ZipCPU</a> programs to use.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/regdefs.h">sw/host/regdefs.h</a>
maps C-language identifiers to their corresponding addresses within
<a href="https://github.com/ZipCPU/arrowzip/">the design</a>.  A similar
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/regdefs.cpp">sw/host/regdefs.cpp</a>
file matches command-line identifiers to these C-language identifiers, so
you can read from or write to
peripheral memory on a command line using
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/wbregs.cpp">wbregs</a>.</p>
  </li>
</ul>

<p>Removing any one of the component files will update the files above, and leave
behind a working design without that component.  Likewise, adding a component
will do the same.</p>

<p>At least, that’s how simple it is <em>supposed</em> to be.  Unfortunately, I’ve
discovered several important parts of a design that don’t fit into this
methodology very well.  The biggest/worst culprit is clock generation.  If
your design needs multiple clocks, you’ll usually want to generate them from
a common/single PLL (if possible).  However, PLLs can be limited, and this
form of design generation would place all of the PLLs in separate component
files.  To handle this, there is a
<a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/clock.txt">clock.txt</a>
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
configuration file to generate all of the clocks used within the design.
<a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/">This design</a>
uses only two clocks–one for the system, and one for the external
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
memory interface.</p>

<p>The second problem the approach currently has is that it doesn’t handle
multiple
<a href="/blog/2017/06/08/simple-wb-master.html">bus masters</a>s
very well (yet).  As such, the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/dlyarbiter.txt">dlyarbiter.txt</a>
handles merging the two
<a href="/blog/2017/06/08/simple-wb-master.html">bus masters</a>s,
the <a href="/about/zipcpu.html">ZipCPU</a> and the
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>,
into a single
<a href="/blog/2017/06/08/simple-wb-master.html">bus master</a>.
Were <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/dlyarbiter.txt">this component</a>
removed, <a href="https://github.com/ZipCPU/arrowzip/">the design</a>
would be broken and unable to operate.</p>

<p>Still, I like how easy it is to reconfigure things using
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.</p>

<h2 id="verilog-components">Verilog Components</h2>

<table align="center" style="float: right"><caption>Fig 3. ArrowZips HDL directory structure</caption><tr><td><img src="/img/arrowzip-rtld.svg" alt="" width="180" /></td></tr></table>

<p>All of the various HDL (i.e. Verilog) components within the design can be
found in the <a href="https://github.com/ZipCPU/arrowzip/tree/master/rtl">rtl</a>
directory.</p>

<p>Building the components of this system took a couple passes, though.  So the
first (very basic) designs can be found in the
<a href="https://github.com/ZipCPU/arrowzip/tree/master/rtl/simple">rtl/simple</a>
directory.  The demonstration design there includes not only an HDL based
“<a href="https://en.wikipedia.org/wiki/&quot;Hello,_World!&quot;_program">Hello World</a>,”
but also a very basic <a href="/blog/2017/05/20/knight-rider.html">Knight-Rider LED display
demo</a>.</p>

<p>I needed those to prove that the vendor toolchain worked, and that I could
successfully load a design onto the board in the first place.</p>

<p>Ever afterwards, I was able to start in on the main design, kept in the
<a href="https://github.com/ZipCPU/arrowzip/tree/master/rtl/arrowzip">rtl/arrowzip</a>
directory, with common files to both kept in the
<a href="https://github.com/ZipCPU/arrowzip/tree/master/rtl/common">rtl/common</a>
directory.  Within the
<a href="https://github.com/ZipCPU/arrowzip/tree/master/rtl/arrowzip">arrowzip</a>
directory are several other subproject
directories, to include ones for both the
<a href="https://github.com/ZipCPU/arrowzip/tree/master/rtl/arrowzip/cpu">ZipCPU</a>
and the <a href="https://github.com/ZipCPU/arrowzip/tree/master/rtl/arrowzip/hexbus">debugging
bus</a>.
The <a href="https://github.com/ZipCPU/arrowzip/tree/master/rtl/arrowzip/cpu">CPU</a>
code is itself copied almost verbatim from the
<a href="https://github.com/ZipCPU/zbasic/tree/master/rtl/cpu">ZBasic repository</a>,
which itself is copied (minus the formal properties) from the
<a href="/about/zipcpu.html">ZipCPU</a> repository.</p>

<p>Yes, if you scan my <a href="https://github.com/ZipCPU">github repositories</a>,
you’ll find a lot of duplication and reuse.</p>

<p>For example, when moving <a href="/about/zipcpu.html">the CPU</a>
from one design to the next, I usually only adjust the <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/cpu/cpudefs.v">CPU configuration
file</a>
and the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">CPU
parameters</a>,
with the latter being set by the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">zipbones.txt</a>
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
configuration file.</p>

<h2 id="simulation-files">Simulation Files</h2>

<p>I also maintain a <a href="https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated/">sim/verilated</a>
directory, where the basic simulation sources for the design are stored.  The
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sim/verilated/automaster_tb.cpp">main simulation file,
automaster_tb.cpp</a>,
is used to start and drive the simulation.  Unlike some of my <a href="/blog/2018/11/29/llvga.html">graphical
simulation work</a>, this
design has only the straight text interface for the time being.</p>

<p>We’ve discussed many of the useful parts of building a simulation before, and
in this directory you’ll find me using all of them.  For example, there’s a
<a href="https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated/dbluartsim.cpp">bridge from the simulated serial port to a TCP/IP port</a>.  It’s not all that
different from when I <a href="/blog/2017/06/17/why-network-debugging.html">originally presented the
concept</a>.
The biggest difference is that I’ve realized many individuals only ever
have the one serial port in the design.  Therefore, I’ve split the serial
port into two streams based upon the high order bit.  If the high bit is set,
the serial port connects to the
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>,
otherwise the console port.  The <a href="https://github.com/ZipCPU/zipcpu/tree/master/sim/verilated/dbluartsim.cpp">serial port
bridge</a>
splits these two streams apart, connecting the design’s one serial port to the
two TCP/IP ports–the
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>,
and the console port.</p>

<p>This allows me to both load the <a href="/about/zipcpu.html">ZipCPU</a>
as well as to interact with the <a href="/about/zipcpu.html">ZipCPU</a>
over the same serial port, although the end-result is that the two ports will
only even supports 7-bit serial instead of the full 256-possible characters
typically associated with 8-bit serial.</p>

<p>There are also other various simulation components within this directory.  For
example, there’s a <a href="https://github.com/ZipCPU/arrowzip/blob/master/sim/verilated/flashsim.cpp">flash simulator tuned for Dual SPI
operation</a>,
as well as an <a href="https://github.com/ZipCPU/arrowzip/blob/master/sim/verilated/sdramsim.cpp">SDRAM
simulator</a>.
This way, the <a href="/blog/2017/06/17/why-network-debugging.html">host software can interact with the simulator and not
realize that anything is
different</a>.</p>

<p>Another very useful component, used both by the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/zipload.cpp">zipload</a>
program in the
<a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/host/">sw/host</a>
directory as well as the program loader in the simulation directory, is the
<a href="https://github.com/ZipCPU/arrowzip/tree/master/sim/verilated/zipelf.cpp">zipelf</a> module.
This software module a wrapper on top of
libelf,
allowing me to easily decompose a design into the various components that
need to be loaded in order to run, where each component consists of a (word
aligned) <a href="https://github.com/ZipCPU/arrowzip/tree/master/sim/verilated/zipelf.h">starting address, a length, and a data
section</a>.
Other parts of the <a href="https://www.skyfree.org/linux/references/ELF_Format.pdf">ELF data
structure</a> have been
stripped out for simplicity, since they are not needed by the loader.</p>

<h2 id="software">Software</h2>

<p><a href="https://github.com/ZipCPU/xulalx25soc">One of my earlier designs</a> had only
the one software subdirectory.  This directory contained only host support
programs for the repository.  Imagine my surprise when a confused user tried
to load a host support program, compiled for either the PC or the ARM, onto
the board in order to have the
<a href="/about/zipcpu.html">ZipCPU</a> run it!</p>

<table align="center" style="float: right"><caption>Fig 4. ArrowZips Software directory structure</caption><tr><td><img src="/img/arrowzip-swd.svg" alt="" width="180" /></td></tr></table>

<p>Since that time, I’ve typically split my software directories into two or three
subdirectories.  One contains <a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/host">host software</a> for running on your PC connected to the FPGA board,
<a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/board">another</a>
contains <a href="/about/zipcpu.html">ZipCPU</a> programs
for running within the
<a href="/about/zipcpu.html">ZipCPU</a> contained within the design,
and a <a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/zlib">third</a>
contains the missing portions of the
<a href="https://www.sourceware.org/newlib/">C-library</a>–more on that in a moment.</p>

<h4 id="host-programs">Host Programs</h4>

<p>The <a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/host">sw/host</a>
directory contains a variety of programs that you can run from your
host machine, typically a PC.  These programs communicate with the either
the design or the simulation over the same
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging port</a>.  This
can be very helpful in case I need to debug some interaction or other, since <a href="/blog/2017/06/17/why-network-debugging.html">I
can then run the same (broken) program in the simulation as I can on the design
itself</a>.</p>

<p>We’ve discussed many of the basic host programs already.  They are, again:</p>

<ul>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/zipload.cpp">zipload</a>:  Used to load a <a href="/about/zipcpu.html">ZipCPU</a> design into
memory, whether into
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, <a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
or <a href="/zipcpu/2018/07/13/memories.html">block RAM</a>.
Passing ‘-r’ to this program will also start the
<a href="/about/zipcpu.html">ZipCPU</a> once it is loaded.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/zipdbg.cpp">zipdbg</a>:
This is the <a href="/about/zipcpu.html">ZipCPU</a>’s debugger.
We’ve <a href="/zipcpu/2017/08/25/hw-debugging.html">discussed how this works before</a>.
It basically halts the
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a>, and <a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">then tells you
what registers had what values within
them</a>.
It’s not a <a href="https://en.wikipedia.org/wiki/Debugger">source level debugger</a>,
so if you want to use it make sure you have a copy of your program’s
(dis)assembly on hand.</p>

    <p>Yes, one of my “TODO” items is to get <a href="https://www.gnu.org/software/gdb/">gdb</a>
up and running on the <a href="/about/zipcpu.html">ZipCPU</a>.
Instead, I’ve been spending so much time just enjoying
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
and proving new design components that I haven’t gotten that far along yet.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/wbregs.cpp">wbregs</a>:
This is my basic access program for command line interaction with a
(perhaps not yet working) design.  I use it to command actions by hand, to
see what will happen and then to read results back.  It’s really useful for
ad-hoc interaction, but after using this program for a while  I will typically
write any real interaction I want into C++.  My fingers can only type so fast,
and I often like to go faster.</p>
  </li>
</ul>

<table style="float: none"><caption>Fig 5: A Network Based Controller</caption><tr><td><img src="/img/netdbg.svg" alt="A Network Based FPGA Controller" width="720" /></td></tr></table>

<ul>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/netuart.cpp">netuart</a>:
We discussed this above.  It connects to the serial port of the
design, and <a href="/blog/2017/06/17/why-network-debugging.html">bridges between that serial port and a pair of TCP/IP
ports</a>,
as shown in Fig 5 above.  As mentioned above, the serial port carries
both <a href="/blog/2017/06/26/dbgbus-verilator.html">debugging bus
commands</a> as well
as user serial port commands, and a separate TCP/IP port accesses each
of these.  The two streams are also 7-bit only, since they use the eighth
bit to determine which stream is in use.</p>

    <p>Key to this design is the baud rate, set in the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
configuration file(s), captured by the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/regdefs.h">regdefs.h</a>
file, which is then used to set the baud rate on this interface.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/zipstate.cpp">zipstate</a>:
Sometimes, it can be hard to know if the
<a href="/about/zipcpu.html">CPU</a> is doing something, or if the
program it was running has somehow crashed and halted it.  The
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/zipstate.cpp">zipstate</a> 
program reads the <a href="/zipcpu/2017/08/25/hw-debugging.html">CPU status
register</a>
and tries to decode it into a (semi-legible) line of text.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/dumpflash.cpp">dumpflash</a>:
Reads and then dumps the flash of the device onto a file.  When
using the <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">Hexbus</a>
debugging bus implementation, dumping the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
can take a <em>LONG</em> time.  Sadly, there’s not enough room on the design
for my <a href="/blog/2017/06/05/wb-bridge-overview.html">higher performance bus
bridge</a>, so
another solution may be needed.  Perhaps capturing the first 64kB or so from
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>, and then loading a
<a href="/about/zipcpu.html">ZipCPU</a>
program to compress the rest?</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/flashid.cpp">flashid</a>:
Used to read the manufacturer’s ID off of the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory chip</a>.</p>

    <p>This was a very important part of the debugging the <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/dualflexpress.v">flash
controller</a>,
because the read-manufacturer-ID command produces a
<em>known answer</em>.  Therefore I could use it to tell if my
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/dualflexpress.v">controller</a>
reads were working at all, or if for example they were off by a bit or two.</p>
  </li>
</ul>

<p>Finally, the directory contains a series of C++ files supporting the <a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone
Scope</a>.
A <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/flashscope.cpp">flashscope</a>
file for debugging the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/dualflexpress.v">flash controller</a>’s interaction with the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> chip,
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/sdramscope.cpp">sdramscope</a>
for debugging the <a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/wbsdram.v">SDRAM
controller</a>.
While there is a
<a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/zipscope.txt">configuration file</a>
in the <a href="https://github.com/ZipCPU/arrowzip/tree/master/auto-data/">auto-data configuration
directory</a>
to create a third scope for the
<a href="/about/zipcpu.html">CPU</a>,
I haven’t (yet) needed it within this design.  So far, everything has worked.</p>

<p>Yeah, right, I know.  Okay, so everything <em>almost</em> worked.  I found a subtle
bug in the <a href="/about/zipcpu.html">CPU</a>
associated with what was essentially an endless logic loop, when using the
early branching functionality with <a href="/about/zipcpu.html">CPU</a>
configured into its non-pipelined mode.  That I found and fixed first with
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
and then I left a formal property in the
<a href="/about/zipcpu.html">CPU</a>
to keep it from happening again later.</p>

<h4 id="zlib-the-c-library-stubs">ZLib: The C-Library Stubs</h4>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> currently supports the
<a href="https://www.sourceware.org/newlib/">newlib C-library</a>.  This is a highly
configurable version of the
<a href="https://en.wikipedia.org/wiki/C_standard_library">C-library</a>
that is very appropriate for
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a>
experimentation, new
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s,
<a href="https://en.wikipedia.org/wiki/Embedded_system">embedded CPU</a>s,
etc.  <a href="https://www.sourceware.org/newlib/">The library</a>, however,
depends upon several functionality stubs that need to be provided by the
implementation.</p>

<p>Two particular stubs are critical to the
<a href="/about/zipcpu.html">ZipCPU</a> operation: the serial port
input stub, <code class="language-plaintext highlighter-rouge">_inbyte</code>, and the output stub, <code class="language-plaintext highlighter-rouge">_outbyte</code>.  These are really all
the I/O the <a href="/about/zipcpu.html">ZipCPU</a> currently supports
using the <a href="https://www.sourceware.org/newlib/">newlib C-library</a>.</p>

<p>Other projects, such as
<a href="https://openrisc.io/">OpenRISC</a>, use symbols that can be resolved at link
time for their I/O accesses.  To tell if the peripheral is present within the
design, these projects will check if the symbol’s value is NULL before
attempting to access the peripheral.  The really neat part of this approach is
that the same <a href="https://en.wikipedia.org/wiki/C_standard_library">C-library</a>
and <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
dependent stubs may be used across many projects.</p>

<p>In my infinite wisdom, or perhaps more likely my utter folly, I chose a
different path for the <a href="/about/zipcpu.html">ZipCPU</a>.
I didn’t really want my peripheral drivers to need to check if the peripheral
was available in run time.  That seemed to make more sense to me to be done
at build time, rather than run time.  As a result, when you build the
<a href="/about/zipcpu.html">ZipCPU</a>’s version of the
<a href="https://www.sourceware.org/newlib/">newlib C-library</a>,
you won’t get a complete library.  You still need to build the component stubs.</p>

<p>Most of these stubs are copied from one implementation to the next, with only
little adjustment beyond the address of the peripheral used.  You can find
them in the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/zlib/syscalls.c">syscalls</a>
file.</p>

<p>There’s also a
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/zlib/crt0.c">bootloader</a> in
<a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/zlib/">this same directory</a>
as well.  <a href="/zipcpu/2018/02/12/zbasic-intro.html">We’ve discussed
it before</a>.
It basically copies program instructions and data from any
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
to the volatile RAM memory within the design.</p>

<p>I’ll admit, I was somewhat surprised when I built my first
<a href="https://en.wikipedia.org/wiki/Booting">bootloader</a>.  A
<a href="https://en.wikipedia.org/wiki/Booting">bootloader</a>
had been a big black box to me, and I didn’t understand how it worked.  Once
I had the opportunity to build my own, I was surprised at how simple
it was.  Indeed, a <a href="https://en.wikipedia.org/wiki/Booting">bootloader</a>
is <em>nothing more than a glorified memory copy!</em>  The
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/zlib/crt0.c">bootloader</a>
performs up to three memory copies.  First, it copies any high-speed
instructions, those that need to be loaded into block RAM instead of
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
into the block RAM.  It then copies the rest of the design into
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>.
Finally, the third copy is really more of a
<a href="http://www.cplusplus.com/reference/cstring/memset/">memset</a>:
it zeros all of the <a href="https://wikipedia.org/wiki/.bss">global data structures that don’t have
initial values</a>.</p>

<p>All of these choices have consequences, however, which we’ll start
discussing in the next section.</p>

<h4 id="the-swboard-directory-where-zipcpu-programs-reside">The sw/board directory, where ZipCPU programs reside</h4>

<p>We’ve finally gotten to <a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/board/">the directory
containing the</a>
<a href="/about/zipcpu.html">ZipCPU</a>’s demonstration
programs, the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/cputest.c">CPU test</a>,
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/memtest.c">memory test</a>,
and
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/hello.c">hello world</a>.
While I’ve  tried to keep
<a href="https://github.com/ZipCPU/arrowzip/tree/master/sw/board/">this directory</a>
simple, there are quite the few surprises in it for
someone who might not be familiar with programming a device that may, or
may not, have the memory on it that you expect.</p>

<p>Most of this complexity is hidden in the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/Makefile">Makefile</a>.
It’s set up so that you can just type</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make</code></pre></figure>

<p>to build the demonstration programs.</p>

<p>That’s great, until you want to build your own.  So let’s dig through this
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/Makefile">Makefile</a>
a bit to understand how it works.</p>

<p>Years ago, I worked on a program where I needed to build the same design
for multiple architectures.  In that environment, I learned to create an
object directory for partial compilation products (i.e. <a href="https://en.wikipedia.org/wiki/Object_file">object
files</a>).
Since then, I’ve gone through several rounds of learning to put <a href="https://en.wikipedia.org/wiki/Object_file">object
files</a>
into such a directory.</p>

<p>The first step is to define a directory to place
<a href="https://en.wikipedia.org/wiki/Object_file">object files</a>, with the
computer architecture name as part of the directory name.  I like to usee
<code class="language-plaintext highlighter-rouge">obj-zip</code> for 
<a href="/about/zipcpu.html">ZipCPU</a> object files, <code class="language-plaintext highlighter-rouge">obj-arm</code>
for ARM files, and <code class="language-plaintext highlighter-rouge">obj-pc</code> for your basic x86-64 files.
Once defined, we’ll then build an object file directory with that name.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nv">OBJDIR</span> <span class="o">:=</span> obj-zip
<span class="c">#
# .... sometime later
#
</span><span class="err">define</span>	<span class="err">mk-objdir</span>
	<span class="err">@bash</span> <span class="err">-c</span> <span class="err">"if</span> <span class="err">[</span> <span class="err">!</span> <span class="err">-e</span> <span class="err">$(OBJDIR)</span> <span class="err">];</span> <span class="err">then</span> <span class="err">mkdir</span> <span class="err">-p</span> <span class="err">$(OBJDIR)/;</span> <span class="err">fi</span>
<span class="err">endef</span></code></pre></figure>

<p>This make function silently calls a command-line bash script, to check if the
<code class="language-plaintext highlighter-rouge">$(OBJDIR)</code> directory exists.  If not, it creates the directory silently.</p>

<p>The second step is to set up a series of C-flags that can be used to compile
any program.  I like to use <code class="language-plaintext highlighter-rouge">-O3</code>, mostly because I end up staring at
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">assembly</a> often and
I get really annoyed by less-than optimal code.  I also want to reference
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>’s generated
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/zlib/board.h">board.h</a>
file, containing all of the decisions going into creating the design–what
peripherals are located at what memory addresses, etc., as well as the
design.h file which can be used to adjust which peripherals are
actually built or not.  This means I need to capture these two directories
in my <code class="language-plaintext highlighter-rouge">$(CFLAGS)</code>.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nv">CFLAGS</span> <span class="o">:=</span> <span class="nt">-O3</span> <span class="nt">-I</span> ../zlib <span class="nt">-I</span>../../rtl/arrowzip</code></pre></figure>

<p>With this definition, I can build
<a href="https://en.wikipedia.org/wiki/Object_file">object files</a>
from C code.  The following generic rule, will make a
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://en.wikipedia.org/wiki/Object_file">object file</a>
from any corresponding .c file.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">$(OBJDIR)/%.o</span><span class="o">:</span> <span class="nf">%.c</span>
	<span class="err">$</span><span class="o">(</span>mk-objdir<span class="o">)</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nt">-c</span> <span class="nv">$&lt;</span> <span class="nt">-o</span> <span class="nv">$@</span></code></pre></figure>

<p>Yea, I know it looks cryptic.  Yes, I will confess I visit the <a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">Makefile
documentation page</a>
more often than not to look up the strange symbols such
as <code class="language-plaintext highlighter-rouge">$&lt;</code> (the first dependency, i.e. the .c file) and <code class="language-plaintext highlighter-rouge">$@</code> (the file
<a href="https://www.gnu.org/software/make">make</a> is
trying to build, i.e. the
<a href="https://en.wikipedia.org/wiki/Object_file">object file</a>).
Notice, though, that it automatically checks if the <code class="language-plaintext highlighter-rouge">obj-zip</code> directory
exists prior to trying to build anything, and that it creates the
directory if not.</p>

<p>You might also notice a similar script, right next to that primary build
script.</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nl">$(OBJDIR)/%.s</span><span class="o">:</span> <span class="nf">%.c</span>
	<span class="err">$</span><span class="o">(</span>mk-objdir<span class="o">)</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nv">$(DUMPRTL)</span> <span class="nt">-S</span> <span class="nv">$&lt;</span> <span class="nt">-o</span> <span class="nv">$@</span></code></pre></figure>

<p>If you’ve ever needed to debug <a href="https://gcc.gnu.org">GCC</a>, you’ll recognize
the</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nv">DUMPRTL</span> <span class="o">:=</span> <span class="nt">-fdump-rtl-all</span></code></pre></figure>

<p><a href="https://gcc.gnu.org">GCC</a> option.  It tells <a href="https://gcc.gnu.org">GCC</a> to
dump the output from all of its intermediate stage, one stage
at a time, from the time it starts getting specific with
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">assembly</a>.</p>

<p>What this rule really does is to compile my .c file into
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">ZipCPU assembly</a>
and then stop–that’s the meaning of the <code class="language-plaintext highlighter-rouge">-S</code> flag.  This can be really
useful when you need to debug the
<a href="https://en.wikipedia.org/wiki/Compiler">compiler</a>,
or alternatively when your program isn’t doing what you think it should and
you don’t know why.</p>

<p>Of course, all of these bugs have finally been worked out of the
<a href="/about/zipcpu.html">ZipCPU</a>, right?  Right??</p>

<p>Ahem, moving right along, let’s move to the
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>.  If you
are familiar with basic <a href="https://en.wikipedia.org/wiki/Compiler">compiler</a>
options, you’ll be expecting to build a program with a line similar to,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>zip-gcc program.c <span class="nt">-o</span> program</code></pre></figure>

<p>This really only works when you already know where in your
<a href="https://en.wikipedia.org/wiki/Address_space">address space</a> you want
to place all the parts of your design.  This is accomplished by way of a
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>.  For
almost all of the <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
I’ve ever worked with before FPGA-based
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft microprocessors</a>,
this script was built into the
<a href="https://en.wikipedia.org/wiki/Compiler">compiler</a>
and I never saw it until I tried to create a
<a href="https://en.wikipedia.org/wiki/Compiler">compiler</a> back end for the
<a href="/about/zipcpu.html">ZipCPU</a>
However, for an
FPGA
based
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">CPU</a>
where the memory size might change from one build to the next, this is not
nearly as reasonable.</p>

<p>For this reason, the <a href="https://github.com/ZipCPU/arrowzip/tree/master/auto-data/">AutoFPGA
scripts</a>
have directed
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
to build several
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker scripts</a>
for us.  There’s a
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/bkram.ld">block RAM only script,
<code class="language-plaintext highlighter-rouge">bkram.ld</code></a>,
a <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/flash.ld">block RAM with flash script, <code class="language-plaintext highlighter-rouge">flash.ld</code></a>,
a <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/sdram.ld">block RAM with SDRAM script, <code class="language-plaintext highlighter-rouge">sdram.ld</code></a>,
and a <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/board.ld">basic use them all script,
<code class="language-plaintext highlighter-rouge">board.ld</code></a>.
To select between these,
<a href="https://gcc.gnu.org">GCC</a> accepts a <code class="language-plaintext highlighter-rouge">-T ldscript.ld</code>
command line option, changing our basic build command to something like,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>zip-gcc <span class="nt">-T</span> board.ld program.c <span class="nt">-o</span> program</code></pre></figure>

<p>Of course, if we’ve already placed our component
<a href="https://en.wikipedia.org/wiki/Object_file">object file</a>
into <code class="language-plaintext highlighter-rouge">obj-zip</code>, it might look more like</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>zip-gcc <span class="nt">-T</span> board.ld obj-zip/program.o <span class="nt">-o</span> program</code></pre></figure>

<p>This only gets us part of the way.  We still need to include the
<a href="https://en.wikipedia.org/wiki/C_standard_library">C-library</a>.
Normally, this
<a href="https://en.wikipedia.org/wiki/C_standard_library">library</a>
would be included for you in the default options built
into the compiler.  It would be integrated in such a way that when you type,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>zip-gcc <span class="nt">-T</span> board.ld obj-zip/program.o <span class="nt">-o</span> program</code></pre></figure>

<p>you’ll automatically get something closer to,</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>zip-gcc <span class="nt">-T</span> board.ld <span class="nt">-L</span> ../zlib/ obj-zip/program.o <span class="nt">-lc</span> <span class="nt">-lgcc</span> <span class="nt">-o</span> program</code></pre></figure>

<p>What are these extra arguments?  We’ve already discussed the <code class="language-plaintext highlighter-rouge">-T</code> argument
to specify a
<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a>.  The
<code class="language-plaintext highlighter-rouge">-L ../zlib</code> argument tells <a href="https://gcc.gnu.org">GCC</a> where to look for
any libraries.  <code class="language-plaintext highlighter-rouge">-lc</code> tells <a href="https://gcc.gnu.org">GCC</a> to include the
<a href="https://en.wikipedia.org/wiki/C_standard_library">C-library</a>,
and <code class="language-plaintext highlighter-rouge">-lgcc</code> tells it to include the <a href="https://wiki.osdev.org/Libgcc">soft-operator library, such as the
soft-floating point support</a> for the
<a href="/about/zipcpu.html">ZipCPU</a>.</p>

<p>However, since in my wonderful wisdom (or folly) I insisted on leaving parts
of the library undefined and board dependent, we’ll need to provide the
remaining command line information.  As a result, here’s the rule to build
“<a href="https://en.wikipedia.org/wiki/&quot;Hello,_World!&quot;_program">Hello World</a>.”</p>

<figure class="highlight"><pre><code class="language-make" data-lang="make"><span class="nv">LFLAGS</span>  <span class="o">:=</span> <span class="nt">-T</span> <span class="nv">$(LDSCRIPT)</span> <span class="nt">-L</span>../zlib
<span class="nv">LIBS</span>    <span class="o">:=</span> <span class="nt">-lc</span> <span class="nt">-lzarrow</span> <span class="nt">-lgcc</span>
<span class="c">#
# ...
#
</span><span class="nl">hello</span><span class="o">:</span> <span class="nf">$(OBJDIR)/hello.o board.ld $(LIB)</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nv">$(LFLAGS)</span> <span class="nv">$&lt;</span> <span class="nv">$(LIBS)</span> <span class="nt">-o</span> <span class="nv">$@</span></code></pre></figure>

<p>This captures most of the confusing parts of the
<a href="/about/zipcpu.html">ZipCPU</a> software
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/Makefile">Makefile</a>.</p>

<p>This should also give you the insight you need to build your own
<a href="/about/zipcpu.html">ZipCPU</a> programs for the
<a href="https://github.com/ZipCPU/arrowzip/">ArrowZip project</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>While the <a href="https://github.com/ZipCPU/arrowzip/">ArrowZip design</a>
could really use some better demo’s, it’s complete enough to
work with as is.  That said, I still have two big problems with it.</p>

<p>First, it looks like I got a bit greedy with the system.  Of the
8,064 logic elements, I’ve used 5,566 or roughly 69% of them.
The <a href="/about/zipcpu.html">ZipCPU</a>’s
reason for being was always to be low logic and out of the way.
Using 69% of the logic resources on a given board is hardly “out of the way.”</p>

<p><a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/cpu/cpudefs.v">Removing the multiply, divide, compressed instruction set support,
dual-instruction prefetch, and early branching
support</a> from the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/cpu/zipcpu.v">CPU</a>
brings the total logic usage down to 4,602 logic elements, or about 57% of the
available logic elements.  Removing the <a href="https://github.com/ZipCPU/rtcclock">real-time
clock</a> as well brings the logic
usage down to 4,066 logic elements, or 52% of the device.  The problem with
removing multiplies, divides, and compressed instructions, though, is that
it means the <a href="https://www.sourceware.org/newlib/">library support</a>
needs to be rebuilt without these instructions.  While doable, it would mean
I’d need a different main <a href="https://www.sourceware.org/newlib/">library</a>
build for different designs–those with and those without these special
instructions.</p>

<p>My second criticism of this design as currently implemented is that writing
to the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> and verifying
the result is painfully slow.  Looking over the current transaction, it seems
quite wasteful to transfer the same
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
values back and forth over the
<a href="/blog/2017/06/16/dbg-bus-forest.html">debugging bus</a>
so many times.  A short <a href="/about/zipcpu.html">ZipCPU</a>
helper program, working in conjunction with the <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/flashdrvr.cpp">flash
driver</a>,
should be able to mitigate that problem.</p>

<p>Finally, I’d still like to implement an interface to the
<a href="https://www.st.com/resource/en/datasheet/cd00274221.pdf">accelerometer</a>.
While this isn’t really that hard to do, I haven’t yet decided on the ideal
interface for doing so.  Therefore, after the upgrades to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/host/flashdrvr.cpp">driver</a>,
this will probably be my next goal/focus with this device.  Well, that and I’d
still like to build this project using <a href="https://www.clifford.at/yosys/">Yosys</a>.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And unto man he said, Behold, the fear of the LORD, that is wisdom; and to depart from evil is understanding. (Job 28:28)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
