<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Technology Debt and AutoFPGA, the bill just came due</title>
  <meta name="description" content="I’m currently working on a fun SONAR project where I need a data collector.The project involves transmitting SONAR data through the thick hull of a deeplysub...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2019/08/22/tech-debt.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Technology Debt and AutoFPGA, the bill just came due</h1>
    <p class="post-meta"><time datetime="2019-08-22T00:00:00-04:00" itemprop="datePublished">Aug 22, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I’m currently working on a fun SONAR project where I need a data collector.
The project involves transmitting SONAR data through the thick hull of a deeply
submerged underwater object, without drilling holes in the hull to do it.</p>

<p>Understanding the transmission path through the hull will be a challenge,
so it becomes important to store the incoming signal to memory, download
it to <a href="https://www.gnu.org/software/octave">Octave</a>, and study it there
before building the downstream processing logic.</p>

<table align="center" style="float: none"><caption>Fig 1. Sonar Signal Processing Chain</caption><tr><td><a href="/img/autofpga/signalpath.svg"><img src="/img/autofpga/signalpath.svg" alt="Sonar signal path: transmitter, hull, copy to memory, to SD card, then analyzed in Octave" width="720" /></a></td></tr></table>

<p>My plan is to collect this information at high speed (800Msps),
to dump it to memory, and then to an <a href="https://github.com/ZipCPU/sdspi">SD-Card</a>.</p>

<p>If you’ve used Xilinx cores before, you may remember that they offer
an <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_datamover/v5_1/pg022_axi_datamover.pdf">AXI Stream to Memory Mapped DataMover
core</a>
to handle this sort of data to memory processing, but I’ve always liked the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a> and
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>–the
<a href="https://www.youtube.com/watch?v=en8JMz7v3LU">fastest simulator on the market</a>,
and one that’s easy to integrate an <a href="https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/sdsdpisim.cpp">SD-Card simulator
into</a>.
Creating a similar
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
core took me only a couple hours one morning to both build and verify.  Having
the <a href="/zipcpu/2017/11/07/wb-formal.html">formal properties for the Wishbone
bus</a> on hand
definitely helped.</p>

<p>That was the easy part.  Indeed, I’d like blog about this new core soon as well
(once I decide where to put it).</p>

<p>The harder part was integrating this new core with
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.</p>

<p>The problem is simple and basic:
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.
as currently designed can handle the logic necessary to connect a
<em>single Wishbone</em> master to all of the slaves within a design.</p>

<ul>
  <li>This approach is light on logic, as desired.  The <a href="/blog/2017/06/22/simple-wb-interconnect.html">necessary interconnect
logic is cheap and easy to
build</a>.</li>
</ul>

<table align="center" style="float: right"><caption>Fig 2. ZipCPU and AutoFPGA bus structure</caption><tr><td><img src="/img/autofpga/zipbus.svg" alt="Four bus masters, three bus arbiters" width="480" /></td></tr></table>

<ul>
  <li>
    <p>For the <a href="/about/zipcpu.html">ZipCPU</a>, this logic
represents a bit of a <a href="/zipcpu/2019/02/09/cpu-blinky.html">speed
bump</a>.  Internally, the
<a href="/about/zipcpu.html">ZipCPU</a>
has two memory ports, one for instructions and one for data, and after
generating them I <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v">arbitrate them together</a> into a single bus interface.  While
this slows down the <a href="/about/zipcpu.html">CPU</a>,
I’ve accepted the consequences of this to date because it helps simplify the
rest of the design.  Sadly, the <a href="/about/zipcpu.html">ZipCPU</a>
gets slowed down again when its bus control signals have to be arbitrated
against the DMA peripheral, and then again when they are arbitrated against
the debugging bus.</p>

    <p>All of this costs time and capability.  Indeed, in order to meet timing each
of the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbarbiter.v">bus
arbiters</a>
has required <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v">delaying bus accesses by a
cycle</a>.</p>

    <p>I’ve dreamed of rewriting the
<a href="/about/zipcpu.html">CPU</a>
so that it has two independent bus ports, removing the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA</a>
from the
<a href="/about/zipcpu.html">CPU</a>
to the main design, and then allowing all four bus masters
(<a href="/zipcpu/2018/03/21/dblfetch.html">CPU instructions</a>,
CPU data,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA</a>
and <a href="/zipcpu/2017/05/20/which-came-first.html">debugging interface</a>)
to interact with the bus at the same time through a
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>.
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
can’t handle this (yet).  We’ll discuss this more in a moment.</p>
  </li>
</ul>

<table align="center" style="float: none"><caption>Fig 3. A better bus design, this time using a crossbar interconnect</caption><tr><td><img src="/img/autofpga/crossbarbus.svg" alt="All bus masters are now equals entering  the bus, all delays are internal to the crossbar" width="720" /></td></tr></table>

<ul>
  <li>
    <p>This also has consequences for anyone who would like to use
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.  For
example, I’d like it to be able to handle interconnecting
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>,
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite</a>,
and even <a href="/doc/wbspec_b4.pdf">Wishbone classic</a> signals.
However, as built today,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
can only ever create the logic for
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone pipeline</a>
signaling.</p>

    <p>To solve this, I’ve recently created a series of
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> bus
arbiters–<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">AXI</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilxbar.v">AXI-lite</a>, and
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbxbar.v">Wishbone (pipeline)</a>,
with the goal and intent that
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
should just be able to reference such an arbiter and not need
to know much more about the bus.</p>
  </li>
</ul>

<p>… and now I want to add a <a href="/blog/2017/06/08/simple-wb-master.html">new bus
master</a>, a
<a href="/blog/2017/08/14/strategies-for-pipelining.html">stream</a>
to <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
bus master.</p>

<p>It’s not quite that simple either.  A second SONAR project I’m working on will
require a transmit controller that will want to read instructions from the bus.
Indeed, this is why I like and use
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.  It
allows me to easily and rapidly reconfigure a master base design, <a href="https://github.com/ZipCPU/videozip">such as this
one</a> for the <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications">Nexys Video
board</a>,
from one configuration and application to another.</p>

<table align="center" style="float: none"><caption>Fig 4. Two different AutoFPGA Configurations, built from the same base design</caption><tr><td><img src="/img/autofpga/dualconfig.svg" alt="Two design shown, one with recording components and one with transmitter components" width="720" /></td></tr></table>

<p>While the new SONAR transmit controller component is not a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>, I found the idea
of re-using <a href="/zipcpu/2018/03/21/dblfetch.html">my instruction fetch
code</a> just too tempting.
Indeed, should the <a href="https://www.blueletterbible.org/kjv/jas/4/15">Lord be
willing</a>, I’m hoping to discuss
how to build something like this in my (to be written) <a href="/blog/2019/08/16/intermediate.html">intermediate
tutorial</a>, with a music
box as an application, but we’ll have to come back to that on another day.</p>

<p>What I’d like to do today is to use the same <a href="https://github.com/ZipCPU/videozip">basic FPGA
design</a> for both applications, as shown
in Fig. 4 above: the stream to memory controller, as well as the scripted
SONAR transmit controller.  Ideally, I’d just make a small change or two
and the design would suddenly go from working on one project to working
on a second project.</p>

<p>Again, that’s the purpose of
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
in the first place.</p>

<p>Sadly, this leaves me with a choice: I can either upgrade my <a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect
logic</a> generator
within <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
to handle multiple bus masters, or I can slow the bus down (again) by
manually adding in one more arbiter to transform the problem back to a
known solution–the single bus master.</p>

<p>This time (yes, there were others), I chose to update
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.</p>

<h2 id="updates-in-progress">Updates in Progress</h2>

<p>The updates to
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
are still a work in progress, or I’d share them on
<a href="https://github.com/ZipCPU/autofpga">github</a>.  (No one really wants to try
to build code that will just
<a href="https://en.wikipedia.org/wiki/Segmentation_fault">segfault</a>, and that’s
where I spent most of my day yesterday.)  Here’s some of what’s coming, though:</p>

<ol>
  <li>First and foremost, my immediate goal is to create multiple bus master
support, through a
<a href="/blog/2019/07/17/crossbar.html">crossbar interconnect</a>,
so that adding (or removing) a
<a href="/blog/2017/06/08/simple-wb-master.html">bus master</a>
is as easy as adjusting the line in the Makefile identifying
which masters are to be included in the design.</li>
</ol>

<table align="center" style="float: none"><caption>Fig 5. A Crossbar can support multiple masters</caption><tr><td><img src="/img/autofpga/multimaster.svg" alt="Block logic for 3 master connected to a crossbar driving 6 slaves" width="720" /></td></tr></table>

<p>One of the advantages of using
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
over a proprietary solution like
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
or <a href="https://www.intel.com/content/www/us/en/programmable/products/design-software/fpga-design/quartus-prime/features/qts-platform-designer.html">Quartus</a>
is that all of the project files are user-supplied text files, and so they
can easily be examined and fixed (if necessary).  Even better, you’ll never
need to “rebuild” your project from the ground up after updating your vendor
tool set, although you might need to make some adjustments when updating
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.
I’ll discuss why below.</p>

<ol start="2">
  <li>
    <p>The <a href="/blog/2019/07/17/crossbar.html">crossbar
interconnect</a>
logic is not currently a part of
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>.
This creates both opportunities and problems.</p>

    <p><em>The opportunity:</em> You can easily replace
<a href="/blog/2019/07/17/crossbar.html">my arbiter logic</a>
with yours by just matching the interface and then swapping the
arbiter logic.</p>

    <p>The problem comes from licensing.  While
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
is licensed under <a href="https://www.gnu.org/licenses/gpl.html">GPL</a>, it asserts
no license over the code it creates.  I treat it sort of like a
<a href="https://www.gnu.org/software/gcc">GCC</a>: the code
<a href="https://www.gnu.org/software/gcc">GCC</a>
produces remains under the license it started with.  I’ve done this to try
to make <a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
usable by all in any context.</p>

    <p>If I want to keep
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
usable in this new context, I may need to release any bus-logic sub-cores
under a very permissive license.  Given the amount of time that went into
creating them, I am reluctant to do so, but needs may require this.</p>
  </li>
  <li>
    <p>As mentioned above, this new
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
upgrade has multiple bus protocol
support.  This currently includes
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite</a>
support as well as
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
support.  Even better, the
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite</a>
will be high speed straight from the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilxbar.v">arbiter</a>
arbiter–rather than <a href="/formal/2018/12/28/axilite.html">crippled like Xilinx’s
support</a> was.</p>

    <p>My eventual goal will be to automatically insert crossbars and bus protocol
(and clock) bridges as needed by the design.  While other tools already exist
to do this, not all of them are open–making it difficult to use the <a href="https://www.youtube.com/watch?v=en8JMz7v3LU">fastest
simulator on the market</a>.  My
current goal is just to be able to handle different bus protocols–bus
bridges and clock crossings can be added manually for the time being.</p>
  </li>
  <li>
    <p>I’ve also been burned by the previous
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
approach to integrating bus components into a design.  Specifically, in
order to integrate a bus component before,
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
would create wires based upon the bus name (not type):
<code class="language-plaintext highlighter-rouge">wb_cyc</code>, <code class="language-plaintext highlighter-rouge">wb_stb</code>, <code class="language-plaintext highlighter-rouge">wb_we</code> and so on.  To connect a slave, you’d need to
create a <code class="language-plaintext highlighter-rouge">@MAIN.INSERT</code> tag to outline code that would be simply inserted
into the main project design.  This code would then pass <code class="language-plaintext highlighter-rouge">wb_cyc</code>,
and <code class="language-plaintext highlighter-rouge">wb_we</code> directly to the peripheral design, and the design would return
something like <code class="language-plaintext highlighter-rouge">flash_ack</code>, <code class="language-plaintext highlighter-rouge">flash_stall</code>, and <code class="language-plaintext highlighter-rouge">flash_data</code> (assuming it
was a <a href="/blog/2019/03/27/qflexpress.html">flash controller</a>.
Further, rather than passing <code class="language-plaintext highlighter-rouge">wb_stb</code> to the slave, the design would <a href="/blog/2017/06/22/simple-wb-interconnect.html">decode
addresses</a>
to determine which slave was being addressed, and so you’d then pass
<code class="language-plaintext highlighter-rouge">wb_stb &amp; flash_sel</code>.  That is, you’d pass the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
strobe (i.e.  transaction request) ANDed with the slave selection drawn
from the bus address.</p>

    <p>While I like this design approach in general, since it allows you to connect
to the bus any way you want, there’s been more than one time I’ve 
connected a <a href="/blog/2018/01/22/formal-progress.html">formally
verified</a>
core to the bus and gotten this logic wrong.</p>

    <p>As an example, I once got careless and just passed <code class="language-plaintext highlighter-rouge">wb_stb</code> directly to
the core rather than <code class="language-plaintext highlighter-rouge">wb_stb &amp; slave_sel</code>.  The result wasn’t pretty,
but caused multiple returns from the bus (I wasn’t filtering returns based
upon the active slave) and so <a href="/blog/2018/02/09/first-cyclonev.html">crashed Intel’s AXI interface (it had gone
through an AXI to Avalon bridge …)</a>.</p>

    <p>Worse, when you try to integrate with something like
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>,
you end up needing to mention and connect <em>every single I/O wire</em> just to
get it right.</p>

    <p>The easy answer would be to define a tag in
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>,
we’ll call it <code class="language-plaintext highlighter-rouge">@SLAVE.PORTLIST</code>, which would contain a string containing
all the logic (i.e. a list of I/O ports) that can be used to connect your
slave to the bus.  A similar tag, <code class="language-plaintext highlighter-rouge">@SLAVE.ANSIPORTLIST</code>, would reference
a string containing all the logic necessary to connect a peripheral to a
bus using ANSI notation.  Similar tags, <code class="language-plaintext highlighter-rouge">@MASTER.PORTLIST</code> and <code class="language-plaintext highlighter-rouge">@MASTER.ANSIPORTLIST</code>, would define this
logic for bus masters.  (There are already other <code class="language-plaintext highlighter-rouge">@*PORTLIST</code> tags used
to define external I/O connections, the <code class="language-plaintext highlighter-rouge">SLAVE</code> and <code class="language-plaintext highlighter-rouge">MASTER</code> prefix would
designate these port lists specific to the bus at hand.)</p>

    <p>Creating these strings will simplify my design efforts, and help to
standardize things as well.</p>

    <p>One unintended consequence of this adjusting a core from one interface
type to another would only require adjusting the <code class="language-plaintext highlighter-rouge">@SLAVE.BUS.TYPE</code>
tag–of course, you’ll still need to adjust the core.</p>
  </li>
</ol>

<ul>
  <li>
    <p>Peripheral classes</p>

    <p>To keep the logic light, I’ve defined two subsets of the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
protocol, subsets I call <code class="language-plaintext highlighter-rouge">SINGLE</code> and <code class="language-plaintext highlighter-rouge">DOUBLE</code>.  I created them when I
noticed that I had a lot of peripherals with nearly the same logic, and
it just made sense to aggregate the control logic together across peripherals.</p>

    <p>Neither of these two sub-classes, <code class="language-plaintext highlighter-rouge">SINGLE</code> nor <code class="language-plaintext highlighter-rouge">DOUBLE</code>, are allowed to
stall the bus, neither are they allowed to return
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.
<code class="language-plaintext highlighter-rouge">SINGLE</code> peripherals create their acknowledgments on the same clock cycle
they are accessed, and <code class="language-plaintext highlighter-rouge">DOUBLE</code> peripherals create their acknowledgments
one cycle later.</p>

    <p>– A <code class="language-plaintext highlighter-rouge">SINGLE</code> peripheral is one that contains a single register only,
   and it’s useful for your basic control register.</p>

    <p>– A <code class="language-plaintext highlighter-rouge">DOUBLE</code> peripheral is one that contains multiple registers.  It uses
   one clock in a case statement to select among multiple values to return.</p>

    <p>I’ve found these bus classes to be quite common across many design elements.
Because their logic is simple, I’ve had no problem creating designs with
30+ peripherals and then adding or removing those peripherals via
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
as projects have required.</p>
  </li>
</ul>

<table align="center" style="float: none"><caption>Fig 6. Special slave classes: SINGLE and DOUBLE</caption><tr><td><img src="/img/autofpga/sdiobus.svg" alt="SINGLE slaves and DOUBLE slaves each form a class of I/O where the control logic is shared between them" width="560" /></td></tr></table>

<ul>
  <li>
    <p>Here’s the good news: When I started creating the
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a> support, I
realized that I needed to continue to support these two subclasses.  The
need for them wasn’t specific to
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> peripherals.
Therefore, the
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a> support
will support these two subclasses.  To give you an idea how these might
work, here are the assumptions required for these simplified peripherals.</p>

    <p>– <code class="language-plaintext highlighter-rouge">SINGLE</code> requires that <code class="language-plaintext highlighter-rouge">C_S_AXI_ADDR_WIDTH == 0</code>, or a slave having one
   address only.  That allows the address lines to be dropped.  The
   <code class="language-plaintext highlighter-rouge">DOUBLE</code> class will allow a peripheral to support multiple addresses, and
   so different address widths as well.</p>

    <p>– Write interface</p>

    <ol>
      <li>
        <p>The slave must guarantee that <code class="language-plaintext highlighter-rouge">AWREADY = WREADY = 1</code>.</p>

        <p>This will allow the interconnect to ignore these inputs.</p>
      </li>
      <li>
        <p>The slave must also guarantee that <code class="language-plaintext highlighter-rouge">BVALID == $past(AWVALID)</code> for
<code class="language-plaintext highlighter-rouge">SINGLE</code> peripherals, and that <code class="language-plaintext highlighter-rouge">BVALID == $past(AWVALID,2)</code> for
<code class="language-plaintext highlighter-rouge">DOUBLE</code> peripherals.</p>

        <p>This will allow the interconnect to automatically generate a common
<code class="language-plaintext highlighter-rouge">BVALID</code> for all of the peripherals in the set without needing the
logic to check every peripheral for this condition individually.</p>
      </li>
      <li>
        <p>The controller (i.e interconnect) will guarantee that
<code class="language-plaintext highlighter-rouge">AWVALID == WVALID</code>.</p>

        <p>This means that you can connect <code class="language-plaintext highlighter-rouge">AWVALID</code> to <code class="language-plaintext highlighter-rouge">WVALID</code> when connecting
your core, and also that you don’t need to handle synchronizing these
two channels together within your core.</p>
      </li>
      <li>
        <p>The controller will also guarantee that <code class="language-plaintext highlighter-rouge">BREADY == 1</code>.</p>

        <p>That is also required for the interconnect to ignore <code class="language-plaintext highlighter-rouge">BVALID</code>.</p>
      </li>
    </ol>

    <p>– Read interface</p>

    <p>These rules pretty much follow the write interface above.</p>

    <ol>
      <li>The slave must guarantee that <code class="language-plaintext highlighter-rouge">ARREADY == 1</code></li>
      <li>The slave must also guarantee that <code class="language-plaintext highlighter-rouge">RVALID == $past(ARVALID)</code> for
<code class="language-plaintext highlighter-rouge">SINGLE</code> peripherals, or equivalently that <code class="language-plaintext highlighter-rouge">RVALID == $past(ARVALID,2)</code>
for <code class="language-plaintext highlighter-rouge">DOUBLE</code> peripherals.</li>
      <li>The controller will guarantee that <code class="language-plaintext highlighter-rouge">RREADY == 1</code>.</li>
    </ol>

    <p>Together, these assumptions will greatly simplify creating
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a> slaves.
The control logic to support this is pretty easy to build and verify
as well, so it’s likely I’ll do something similar when I get to building
the full <a href="/blog/2019/05/29/demoaxi.html">AXI</a> support.</p>

    <p>I’m sure we’ll discuss more about this on the blog as time goes along.</p>
  </li>
</ul>

<p>All of these are wonderful, great, and (insert your favorite superlative
here) ideas.</p>

<p>There’s one problem I discovered when integrating these changes into my design:
I had used the knowledge of how the interconnect worked when building some of
my cores.  This is now causing these otherwise “working” cores to break.</p>

<h2 id="technology-debt-the-bill-comes-due">Technology Debt: The bill comes due</h2>

<p>Wikipedia (today) defines <a href="https://en.wikipedia.org/wiki/Technical_debt">technology
debt</a> as,</p>

<blockquote>
  <p>Technical debt is a concept in software development that reflects
the implied cost of additional rework caused by choosing an easy or
limited solution now instead of using a better approach that would take
longer.</p>
</blockquote>

<p>Two of my cores that are now suffering from this debt are my RMII/RGMII
network cores, and my wonderful new <a href="/blog/2019/03/27/qflexpress.html">“Universal” QSPI flash
controller</a>.</p>

<table align="center" style="float: left"><caption>Fig 7. Abusing the bus protocol</caption><tr><td><img src="/img/autofpga/qspiports.svg" alt="Shared signals: CYC, WE, ADDR, bus separate STB signals.  Bus returns share ACK, STALL, and DATA signals.  The result is not protocol compliant." width="420" /></td></tr></table>

<p>Both of these cores have both a memory interface and a control interface,
as shown in Fig. 7 on the left.  For the network core, the memory interface is
to either the to-be-transmitted or the already-received packet memory
contained within the core.  For the
<a href="/blog/2019/03/27/qflexpress.html">flash controller</a>,
the interface is between the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash
memory</a> and the control register.</p>

<p>In both cases, I abused the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> protocol knowing how the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
would handle things.</p>

<p>You can see how this affects the port list for the
flash controller
below,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">qflexpress</span><span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="n">i_reset</span><span class="p">,</span>
		<span class="n">i_wb_cyc</span><span class="p">,</span> <span class="n">i_wb_stb</span><span class="p">,</span> <span class="n">i_cfg_stb</span><span class="p">,</span> <span class="n">i_wb_we</span><span class="p">,</span> <span class="n">i_wb_addr</span><span class="p">,</span> <span class="n">i_wb_data</span><span class="p">,</span>
			<span class="n">o_wb_ack</span><span class="p">,</span> <span class="n">o_wb_stall</span><span class="p">,</span> <span class="n">o_wb_data</span><span class="p">,</span>
		<span class="n">o_qspi_sck</span><span class="p">,</span> <span class="n">o_qspi_cs_n</span><span class="p">,</span> <span class="n">o_qspi_mod</span><span class="p">,</span> <span class="n">o_qspi_dat</span><span class="p">,</span> <span class="n">i_qspi_dat</span><span class="p">);</span></code></pre></figure>

<p>Rather than defining two (properly separate) interfaces, I just created a
single interface with two strobe signals: <code class="language-plaintext highlighter-rouge">i_wb_stb</code> for reading from memory,
and <code class="language-plaintext highlighter-rouge">i_cfg_stb</code> for reading from the control port.  Results were returned
through a common return port of <code class="language-plaintext highlighter-rouge">o_wb_ack, o_wb_stall,</code> and <code class="language-plaintext highlighter-rouge">o_wb_data</code>.</p>

<p>If first hit a problem with this interface when I tried to handle
acknowledgments.  Since the simple
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
I was using just OR’d all of the acknowledgment signals together in order to
generate an ACK signal to return to the
<a href="/blog/2017/06/08/simple-wb-master.html">bus master</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">wb_ack</span> <span class="o">&lt;=</span> <span class="o">|{</span> <span class="n">flash_memory_ack</span><span class="p">,</span> <span class="n">memory_ack</span><span class="p">,</span> <span class="n">etc_ack</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>there was never any problem with OR’ing two acknowledgment signals together
within the slave.  Indeed, it spared bus logic in the return.  Similarly, since
the <a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
selected the data to be returned based upon which slave set its
acknowledgment signal,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">case</span><span class="p">(</span><span class="o">{</span><span class="n">flash_memory_ack</span><span class="p">,</span> <span class="n">memory_ack</span><span class="p">,</span> <span class="n">other_ack</span><span class="p">,</span> <span class="n">etc_ack</span> <span class="o">}</span><span class="p">)</span>
	<span class="c1">// No line to accept flash_config_data</span>
<span class="mb">4'b1???</span><span class="o">:</span> <span class="n">wb_data</span> <span class="o">&lt;=</span> <span class="n">flash_memory_data</span><span class="p">;</span>
<span class="mb">4'b01??</span><span class="o">:</span> <span class="n">memory_ack</span><span class="p">;</span>
<span class="c1">// etc.</span></code></pre></figure>

<p>a slave interface that hadn’t been referenced could validly set it’s
acknowledgment signal and then return data via the other slave interface port.</p>

<p>Both of these are an abuse of
the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
protocol.</p>

<p>As you might expect, I then ran into problems when I wanted to update my
interconnect to drop the <a href="/zipcpu/2019/03/28/return-decoding.html">poorly designed return
logic</a>, since I
wanted to now create an index register for a multiplexer that would identify
which core should receive the returned data.
(If that’s confusing, I explain
the concept <a href="/zipcpu/2019/03/28/return-decoding.html">here</a>.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">wb_stb</span><span class="p">)</span>
	<span class="n">wb_index</span> <span class="o">&lt;=</span> <span class="n">wb_addr</span><span class="p">[</span><span class="n">LOW_BITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">case</span><span class="p">(</span><span class="n">wb_index</span><span class="p">)</span>
<span class="mi">0</span><span class="o">:</span> <span class="n">wb_data</span> <span class="o">&lt;=</span> <span class="n">flash_memory_data</span><span class="p">;</span>
<span class="c1">// This port will never return valid data, since there was no defined</span>
<span class="c1">// flash configuration port defining a flash_config_data value</span>
<span class="mi">1</span><span class="o">:</span> <span class="n">wb_data</span> <span class="o">&lt;=</span> <span class="n">flash_config_data</span><span class="p">;</span>
<span class="mi">2</span><span class="o">:</span> <span class="n">wb_data</span> <span class="o">&lt;=</span> <span class="n">memory_data</span><span class="p">;</span>
<span class="c1">// etc.</span></code></pre></figure>

<p>Once the selected channel stopped returning the correct value under
this new logic implementation, I then started to learn the error of my ways.</p>

<p>Note the key word “started”.  Rather than fixing the problem properly by
creating two separate bus interfaces, I cheated.  I returned the same data
on both channels.  This would work because the returned acknowledgment was
still the OR of all the acknowledgments.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span> <span class="n">flash_config_data</span> <span class="o">=</span> <span class="n">flash_memory_data</span><span class="p">;</span></code></pre></figure>

<p>Now the bill is coming due again, since in order to support multiple masters
it is now possible that two masters will each try to access the two peripheral
interfaces, both at the same time, and so combining values in the return port
is no longer possible under any stretch.</p>

<p>That means I’ll need to change the <a href="/blog/2019/03/27/qflexpress.html">“Universal” QSPI flash
controller</a> port list to be
something closer to,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">qflexpress</span><span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="n">i_reset</span><span class="p">,</span>
		<span class="n">i_wb_cyc</span><span class="p">,</span> <span class="n">i_wb_stb</span><span class="p">,</span> <span class="n">i_wb_we</span><span class="p">,</span> <span class="n">i_wb_addr</span><span class="p">,</span> <span class="n">i_wb_data</span><span class="p">,</span>
			<span class="n">o_wb_ack</span><span class="p">,</span> <span class="n">o_wb_stall</span><span class="p">,</span> <span class="n">o_wb_data</span><span class="p">,</span>
		<span class="n">i_cfg_cyc</span><span class="p">,</span> <span class="n">i_cfg_stb</span><span class="p">,</span> <span class="n">i_cfg_we</span><span class="p">,</span> <span class="n">i_cfg_addr</span><span class="p">,</span> <span class="n">i_cfg_data</span><span class="p">,</span>
			<span class="n">o_cfg_ack</span><span class="p">,</span> <span class="n">o_cfg_stall</span><span class="p">,</span> <span class="n">o_cfg_data</span><span class="p">,</span>
		<span class="n">o_qspi_sck</span><span class="p">,</span> <span class="n">o_qspi_cs_n</span><span class="p">,</span> <span class="n">o_qspi_mod</span><span class="p">,</span> <span class="n">o_qspi_dat</span><span class="p">,</span> <span class="n">i_qspi_dat</span><span class="p">);</span></code></pre></figure>

<p>like it probably should’ve been in the beginning.</p>

<p>There’s another problem that I’m likely to struggle from as well: all of the
bus wire names are changing.  Creating a bus structure where every wire is
prefixed by <code class="language-plaintext highlighter-rouge">wb_</code>, as in <code class="language-plaintext highlighter-rouge">wb_cyc</code>, <code class="language-plaintext highlighter-rouge">wb_stb</code>, <code class="language-plaintext highlighter-rouge">wb_we</code>, etc., is great when only
one master will ever control this bus.  Creating multi-master support is going
to require changing all of these wire names so that each peripheral can be
interacted with separately.  This will result in an annoying
incompatibility between
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
versions.  While I think the benefit outweighs the problems, it will take
some time to upgrade all of my separate projects to get things to work again
with the new version.</p>

<h2 id="conclusion">Conclusion</h2>

<p>My conclusion from this whole affair is that I’m learning some hard lessons
about design.  In particular, be careful not to use the knowledge of how the
other end of an interface is working to violate the rules of that interface.
Sure, the result might work for your first project, but by doing so you are
incurring a debt–one that will need to be paid eventually when you use the
core later in a different environment.</p>

<p>Some time ago, I remember consulting with a particular technology company
about this issue.  They shared with me their own struggles, sounding very
similar to this one, where they had all kinds of cores written in house but
each of which had abused the bus protocol in some fashion or other.
The result was that drawing a core out from their library to use in a new
project incurred an update cost any time the new environment was different.
Worse, because of the tyranny of the urgent, the didn’t fix the issue properly.
Instead, they had chosen the quick and easy solution of modifying the library
core to fit the new need.  As a result, their core IP library was filled with
many similar cores–but all having subtly different (abused) interfaces.</p>

<p>It’s fun for me to consult and discuss the “way out” of a problem like that.
I’m sure you, like me, enjoy telling other people how to live their lives.
It becomes quite a different matter when you find yourself stuck in the same
mire.</p>

<blockquote>
  <p>Behold, thou … makest the boast of God, And knowest his will, and
approvest the things that are more excellent, being instructed out of
the law; And art confident that thou thyself art a guide of the blind,
a light of them which are in darkness, An instructor of the foolish, a
teacher of babes, which hast the form of knowledge and of the truth in
the law.  <strong>Thou therefore which teachest another, teachest thou not
thyself?</strong> thou that preachest a man should not steal, dost thou steal?
(From <a href="https://www.blueletterbible.org/kjv/rom/2/17-21">Romans 2:17-21</a>)</p>
</blockquote>

<p>Ouch.  That hurts.  So true though.</p>

<p>So I’m going to try to start paying off this debt today, together with whatever
interest may have accrued.  I’d still like to come back later,
<a href="https://www.blueletterbible.org/kjv/jas/4/15">Lord willing</a>,
and discuss that stream to Wishbone converter–but that’ll have to wait for
another day.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>The rich ruleth over the poor, and the borrower is servant to the lender. (Prov 22:7)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
