<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Connecting lots of slaves to a bus without using a lot of logic</title>
  <meta name="description" content="Fig 1. A Minimal Bus Implementation">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2019/08/30/subbus.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Connecting lots of slaves to a bus without using a lot of logic</h1>
    <p class="post-meta"><time datetime="2019-08-30T00:00:00-04:00" itemprop="datePublished">Aug 30, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. A Minimal Bus Implementation</caption><tr><td><img src="/img/bus-doubles/minimal-crossbar.svg" alt="" width="360" /></td></tr></table>

<p>I’m not quite sure why, but most of the time when I examine a design on-line
that someone has posted to a forum, there are very few bus components.  There’s
typically a CPU (Microblaze, Nios2, or ARM), some kind of SDRAM memory, perhaps
a flash device, and then one or two other peripherals.  Perhaps these would be
an SD-card controller and an ethernet controller, as shown in Fig. 1.</p>

<p>I’ve never quite understood this.  Many of my own designs will have those same
peripherals, but then perhaps another 25 more.  Why not create more peripherals
than just a few?</p>

<table align="center" style="float: none"><caption>Fig 2. Adding more peripherals</caption><tr><td><img src="/img/bus-doubles/massive-crossbar.svg" alt="" width="720" /></td></tr></table>

<p>Perhaps I’m adding in the kitchen sink at this point, but why not?  If you can,
and if you have the peripheral and the space, why not add it into your design?
Maybe I’m just becoming a logic hoarder–I’ll add logic from every peripheral
I’ve ever worked on into a design and then more.  I’ll then even add lots
of <a href="/blog/2017/06/08/simple-scope.html">wishbone scopes</a>
just to debug the whole.</p>

<p>Large numbers of items on the bus has yet to become a crippling problem for
anything I’ve wanted to do.</p>

<p>So why don’t I see block designs with even half as many components when browsing
<a href="https://forums.xilinx.com">Xilinx’s forums</a>?</p>

<p>My guess is that it costs most folks too much logic.</p>

<p>To understand the issue, let’s just say that we want to connect four masters
(CPU instructions, CPU data, DMA, and <a href="/blog/2017/06/16/dbg-bus-forest.html">debugging
bus</a>) to a bus
with 32 slave peripherals on it.  Just the
<a href="/blog/2019/07/17/crossbar.html">crossbar interconnect</a>
alone, before adding any peripherals, would require 5,571 LUTs for a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbxbar.v">WB
interconnect</a>,
and (gasp!) 10,341 LUTs for an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">AXI
interconnect</a>!
It doesn’t help that the size of the
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> goes up at a rate
faster than the product of the number of masters times the number of slaves.
Worse, these numbers say nothing of the difficulty associated with getting
such a massive design to pass timing for all the paths within such an behemoth
of a <a href="/blog/2019/07/17/crossbar.html">crossbar interconnect</a>
either.</p>

<p>Perhaps this is why I’ve never seen more than a couple of slaves in any
particular design: the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
alone might take nearly half the part, if not more!  (Depending upon your
FPGA size, of course.)</p>

<p>This of course leads to the interesting question, how is it that I haven’t
suffered from this problem when adding 20+ peripherals to a design?</p>

<h2 id="the-two-simple-slaves">The Two Simple Slaves</h2>

<p><a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
simplifies this complex bus interconnect logic via the creation of two simpler
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave protocols</a>.
I’ll call these sub-protocols, since for each of the simpler protocols the
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a>
can still be <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
compliant, it just has a couple of extra features.
The first sub-protocol is appropriate for a
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a>
that consists of just a single register.  This register may always be read
immediately.  The second peripheral class takes a single clock cycle to return
the data of interest.
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
uses a slave type tag to describe these two sub-protocol classes.  The first
class would have a <code class="language-plaintext highlighter-rouge">@SLAVE.TYPE=SINGLE</code> tag, and the second would be
<code class="language-plaintext highlighter-rouge">@SLAVE.TYPE=DOUBLE</code>.
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> would
then use this information to simplify how such a
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a>
might connect to the <a href="/blog/2017/06/22/simple-wb-interconnect.html">automatically generated bus
structure</a>.</p>

<p>Let’s take a look at each of these simplified protocol classes from a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
standpoint, and then see how we might use this in an
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite</a> or even from an
<a href="/blog/2019/05/29/demoaxi.html">AXI</a> (full) standpoint.</p>

<p>In <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>,
the <code class="language-plaintext highlighter-rouge">SINGLE</code>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a>
type must have only a single register assigned to it.  It must never stall the
bus, and the register must always be available to be read.  It’s as though all
the internal logic were summarized as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">o_wb_ack</span>   <span class="o">=</span> <span class="n">i_wb_stb</span><span class="p">;</span>
	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="n">o_wb_data</span>  <span class="o">=</span> <span class="n">internal_register</span><span class="p">;</span>
	<span class="n">o_wb_err</span>   <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">end</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_stb</span> <span class="o">&amp;&amp;</span> <span class="n">i_wb_we</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_sel</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_sel</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_sel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_wb_data</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_sel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_wb_data</span><span class="p">[</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">];</span>
<span class="k">end</span></code></pre></figure>

<p>It’s really simple.  Now, what if the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
could just ignore <code class="language-plaintext highlighter-rouge">o_wb_stall</code> (always zero), and <code class="language-plaintext highlighter-rouge">o_wb_ack</code> (always
<code class="language-plaintext highlighter-rouge">i_wb_stb</code>), set the <code class="language-plaintext highlighter-rouge">STB</code> line (<code class="language-plaintext highlighter-rouge">i_wb_stb</code>) dependent upon which
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a>
it was talking to, and then use a big case statement based
upon the current address to determine the return value?</p>

<p>The <code class="language-plaintext highlighter-rouge">DOUBLE</code> type is very similar.  In this case, though, the <code class="language-plaintext highlighter-rouge">ACK</code> line takes
another cycle to return.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// Delay the acknowledgement by one cycle, so we can accomplish our logic</span>
<span class="k">initial</span> <span class="n">o_wb_ack</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">o_wb_ack</span>   <span class="o">=</span> <span class="n">i_wb_stb</span><span class="p">;</span></code></pre></figure>

<p>This extra cycle makes it possible to for the
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a>
to select from among several possible internal registers you might wish
to return before returning the result.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">case</span><span class="p">(</span><span class="n">i_wb_addr</span><span class="p">)</span>
<span class="mi">0</span><span class="o">:</span> <span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">internal_register</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="mi">1</span><span class="o">:</span> <span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">internal_register</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="mi">2</span><span class="o">:</span> <span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">internal_register</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="mi">3</span><span class="o">:</span> <span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">internal_register</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">// ...</span>
<span class="k">endcase</span></code></pre></figure>

<p>This would again simplify the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
since it would no longer need to wait for <code class="language-plaintext highlighter-rouge">!STALL</code>, nor would it need
to check <code class="language-plaintext highlighter-rouge">ACK</code> to know if the resulting data was valid.</p>

<p>Because the logic for both <code class="language-plaintext highlighter-rouge">SINGLE</code> and <code class="language-plaintext highlighter-rouge">DOUBLE</code>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slaves</a>
is a <em>subset</em> of the
full <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
protocol, the
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a>
can still be a valid
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a>
in its own right, while also allowing for the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
to optimize its bus access.  This means that the
<a href="/zipcpu/2017/05/29/simple-wishbone.html">slave</a>
should still work in a non-optimized
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
context as well as the optimized one, so you lose nothing there.</p>

<p>I’ve now used this approach within
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a>
for some time with great success–but only for
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> peripherals
so far, and only with a <a href="/blog/2017/06/22/simple-wb-interconnect.html">very simplified interconnect
structure</a>.</p>

<p>The reason this has come to light is that I’m now
in the process of <a href="/zipcpu/2019/08/22/tech-debt.html">upgrading
AutoFPGA</a>
to use a full
<a href="/blog/2019/07/17/crossbar.html">crossbar interconnect</a>.
As part of this upgrade, I came across this little optimization and wondered if
I should keep it or throw it out.  I almost threw it out, but then got to
thinking some more about it.</p>

<p>To see the impact, consider the design shown above in Fig. 2.  Had I collected
<code class="language-plaintext highlighter-rouge">SINGLE</code> and <code class="language-plaintext highlighter-rouge">DOUBLE</code> slaves together for interconnect purposes, the design
might’ve been simplified to the one in Fig. 3 below.</p>

<table align="center" style="float: none"><caption>Fig 3. Creating slave groups by type, SINGLE and DOUBLE</caption><tr><td><img src="/img/bus-doubles/divided.svg" alt="" width="720" /></td></tr></table>

<p>My current thought is, can or should this be done with
<a href="/blog/2019/05/29/demoaxi.html">AXI peripherals</a>,
and if so how?</p>

<h2 id="simplifying-axi">Simplifying AXI</h2>

<p>So, if we were to totally simplify
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>
to create simpler slaves and to gather eliminate any common bus logic between
them together, how would we do it?</p>

<p>Here’s my current working proposal:</p>

<ol>
  <li>
    <p>The interconnect guarantees that the core receives no back-pressure, leaving
<code class="language-plaintext highlighter-rouge">BREADY</code> and <code class="language-plaintext highlighter-rouge">RREADY</code> both high.</p>

    <p>This may require one (or more) <a href="/blog/2019/05/22/skidbuffer.html">skid
buffers</a>, or perhaps
even small FIFOs within the interconnect, but this should still be quite
doable.</p>
  </li>
  <li>
    <p>The slave can then guarantee that it will keep all of the slave generated
<code class="language-plaintext highlighter-rouge">*READY</code> signals high as well: <code class="language-plaintext highlighter-rouge">AWREADY</code>, <code class="language-plaintext highlighter-rouge">WREADY</code>, and <code class="language-plaintext highlighter-rouge">ARREADY</code>.</p>

    <p>Sorry, but this property will keep you from using many of <a href="/formal/2019/05/13/axifull.html">Xilinx’s
peripherals</a>, since
they tend to idle with their <code class="language-plaintext highlighter-rouge">*READY</code> signals low.</p>
  </li>
  <li>
    <p>The interconnect guarantees that <code class="language-plaintext highlighter-rouge">AWVALID == WVALID</code>.  This will save
the slave from the hassle of needing to implement incoming
<a href="/blog/2019/05/22/skidbuffer.html">skid buffers</a>
just to synchronize these two signals.</p>

    <p>Even better, if the slave logic is done right, the synthesis tool should
be able to remove the <a href="/blog/2019/05/22/skidbuffer.html">skid
buffer</a> logic from an
otherwise fully <a href="/blog/2019/05/29/demoaxi.html">AXI</a>
compliant core.</p>
  </li>
  <li>
    <p>The slave can then guarantee that <code class="language-plaintext highlighter-rouge">BVALID == $past(AWVALID)</code> and
<code class="language-plaintext highlighter-rouge">RVALID == $past(ARVALID)</code> for <code class="language-plaintext highlighter-rouge">SINGLE</code> peripherals.  For <code class="language-plaintext highlighter-rouge">DOUBLE</code>
peripherals, the slave would guarantees that <code class="language-plaintext highlighter-rouge">BVALID == $past(AWVALID,2)</code>
and <code class="language-plaintext highlighter-rouge">RVALID == $past(ARVALID,2)</code>.</p>
  </li>
</ol>

<p>The neat thing about all of this is that these rules would work for
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite</a> as well as for
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>.</p>

<p>With just a little more work, we could guarantee the ability to connect
an <a href="/blog/2019/01/12/demoaxilite.html">AXI-lite</a> slave to a
simplified <a href="/blog/2019/05/29/demoaxi.html">AXI</a> interconnect
without the need for any further simplification logic.</p>

<p>To do this using a fully
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>
capable slave, we’d need a couple other bus simplifying rules as well.</p>

<ol>
  <li>
    <p>The interconnect must guarantee that <code class="language-plaintext highlighter-rouge">AxLEN == 0</code> any time <code class="language-plaintext highlighter-rouge">AxVALID</code> is
true for both channels.</p>

    <p>This means that the interconnect will need to break apart any bursts into
individual beats before they ever reach the slave.</p>

    <p>This doesn’t mean that the interconnect will no longer support bursting
at a rate of one beat of the transfer per clock cycle, but rather that each
individual beat will be given its own address from the interconnect.</p>
  </li>
  <li>
    <p>The interconnect would also then guarantees that <code class="language-plaintext highlighter-rouge">WLAST == 1</code> any time
<code class="language-plaintext highlighter-rouge">WVALID</code> is true.</p>

    <p>This just follows from guaranteeing that <code class="language-plaintext highlighter-rouge">AxLEN == 0</code>.</p>
  </li>
  <li>
    <p>The interconnect guarantees that <code class="language-plaintext highlighter-rouge">AxID = 0</code>, and then ignores <code class="language-plaintext highlighter-rouge">xID</code> on the
return channel.</p>

    <p>Yes, I understand that there are reasons for using the ID field–just not
in this simplified version of
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>.</p>

    <p>Also, having a known response time from the slave makes the conversion
from <a href="/blog/2019/05/29/demoaxi.html">AXI</a> to
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite</a>
a lot easier–without requiring any loss in burst speed.  To see how
difficult the conversion can be, consider <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilite.v">this full speed
bridge</a>
and notice the challenge of matching up the return ID with the requested
burst, as well generating <code class="language-plaintext highlighter-rouge">BVALID</code> or even <code class="language-plaintext highlighter-rouge">RVALID &amp; RLAST</code> signals with
the end of the burst.  It wasn’t easy to do, certainly not while <a href="/img/tweets/axi2axil-write-burst.svg">maintaining
a high throughput</a>,
and it was even harder to verify.</p>
  </li>
  <li>
    <p>The interconnect guarantees that <code class="language-plaintext highlighter-rouge">AxSIZE = $clog(C_AXI_DATA_WIDTH)-3</code>, and
then leaves it constant.</p>

    <p>This also follows from setting <code class="language-plaintext highlighter-rouge">AxLEN == 0</code>.</p>
  </li>
  <li>
    <p>The slave ignores <code class="language-plaintext highlighter-rouge">AxBURST</code>, <code class="language-plaintext highlighter-rouge">AxCACHE</code>, <code class="language-plaintext highlighter-rouge">AxPROT</code>, <code class="language-plaintext highlighter-rouge">AxQOS</code>, and
so on.  (The master guarantees these values are zero, in case the slave
doesn’t quite want to ignore them.)</p>
  </li>
  <li>
    <p>The slave might still support <code class="language-plaintext highlighter-rouge">AxLOCK</code> if desired, or ignore it if not.  I
haven’t decided if that would be useful or not.</p>
  </li>
</ol>

<p>Finally, if the interconnect does its job right, you wouldn’t lose any burst
support, but still be able to retire beats at a rate of one per clock.</p>

<p>Indeed, the <a href="/blog/2019/05/29/demoaxi.html">AXI</a>
slave logic might easily be simplified to something like the following for
the <code class="language-plaintext highlighter-rouge">SINGLE</code> type peripheral:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">//</span>
<span class="c1">// Simplified AXI (SINGLE) write logic</span>
<span class="c1">//</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_AWVALID</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">[</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">];</span>
<span class="k">end</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="n">S_AXI_BRESP</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span>

<span class="c1">//</span>
<span class="c1">// Simplified AXI (SINGLE) read logic</span>
<span class="c1">//</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="n">S_AXI_RDATA</span> <span class="o">=</span> <span class="n">internal_register</span><span class="p">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="n">S_AXI_RRESP</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">DOUBLE</code> type peripheral logic would also be similarly simplified.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">//</span>
<span class="c1">// Simplified AXI (DOUBLE) write logic</span>
<span class="c1">//</span>
<span class="k">assign</span>	<span class="n">wreg</span> <span class="o">=</span> <span class="n">S_AXI_AWADDR</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">];</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_AWVALID</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="n">wreg</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">24</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="n">wreg</span><span class="p">][</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="n">wreg</span><span class="p">][</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span> <span class="mi">8</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">internal_register</span><span class="p">[</span><span class="n">wreg</span><span class="p">][</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_AXI_WDATA</span><span class="p">[</span> <span class="mi">7</span><span class="o">:</span> <span class="mi">0</span><span class="p">];</span>
<span class="k">end</span>

<span class="c1">//</span>
<span class="c1">// Simplified AXI (DOUBLE) read logic</span>
<span class="c1">//</span>
<span class="k">assign</span>	<span class="n">rreg</span> <span class="o">=</span> <span class="n">S_AXI_ARADDR</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">];</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
<span class="k">case</span><span class="p">(</span><span class="n">rreg</span><span class="p">)</span>
<span class="mi">0</span><span class="o">:</span> <span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">internal_register</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="mi">1</span><span class="o">:</span> <span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">internal_register</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="mi">2</span><span class="o">:</span> <span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">internal_register</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="mi">3</span><span class="o">:</span> <span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">internal_register</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">// ...</span></code></pre></figure>

<p>Yes, this eliminates a lot of the logic necessary to deal with the
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>
protocol.  All of that ugly logic would be aggregated into one <code class="language-plaintext highlighter-rouge">axisingle</code>
or one <code class="language-plaintext highlighter-rouge">axidouble</code> module that would then handle all of the full
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>
protocol interaction in order to create this simplified protocol.  You can see
an example of such an
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsingle.v"><code class="language-plaintext highlighter-rouge">axilsingle</code> peripheral on
github</a>,
should you be interested in how this might work.</p>

<p>This approach allows the bus interconnect to simplify its logic drastically.
Instead of a 10k LUT
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>,
it should now be possible to connect the design together using a 3.4k LUT
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>,
Such a <a href="/blog/2019/07/17/crossbar.html">crossbar</a>
might support 4 masters and 8 slaves, where one of those slaves controls
the <code class="language-plaintext highlighter-rouge">SINGLE</code> peripherals and one controls the <code class="language-plaintext highlighter-rouge">DOUBLE</code> peripherals.  The
logic in the slaves might even be as low as 600 LUTs (based upon a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsingle.v"><code class="language-plaintext highlighter-rouge">SINGLE</code>
peripheral drawn from an AXI-lite
example</a>).</p>

<p>Yes, there would be some distinct differences in this approach.  For
example, only one master could ever command a read (or write) port of a
<code class="language-plaintext highlighter-rouge">SINGLE</code> or <code class="language-plaintext highlighter-rouge">DOUBLE</code> peripheral at a time–rather than allowing a separate
master to connect to every simplified peripheral.  This isn’t really that
much of a problem, since if you anticipated contention, you might split the
<code class="language-plaintext highlighter-rouge">SINGLE</code> (or <code class="language-plaintext highlighter-rouge">DOUBLE</code>) peripherals into two groups–and so avoid
the contention.  You might also place any high demand peripherals into
their own peripheral slot in the interconnect and just ignore the potential
optimizations–indeed, how you group slaves into <code class="language-plaintext highlighter-rouge">SINGLE</code> or
<code class="language-plaintext highlighter-rouge">DOUBLE</code> peripheral locations is completely application dependent.</p>

<p>This is also a very different approach from the more common approach of using
an AHB slave as a “lite” slave.  First, AHB has no support for simultaneous
reads and writes.  That would force the read and write channels to be
synchronous prior to handling an AHB slave.  Second, because AHB permits
arbitrary stall amounts, the master/interconnect can’t simplify the returns
among a group of peripherals, but instead is required to check for the return
from each individual peripheral.  Similarly, while it is possible to generate
an AHB interconnect, and so group peripheral returns, such groups of multiple
slaves under the same AHB port would just slow everything down–since AHB is
primarily a combinatorial logic bus.</p>

<p>Unlike that AHB approach, this approach maintains the high clock speed and
multiple inflight transactions that
<a href="/blog/2019/05/29/demoaxi.html">AXI</a> is known for already.
It also maintains the separate read and write channels, as well as full/burst
speed–unlike many of the <a href="/formal/2018/12/28/axilite.html">AXI-lite
implementations</a> I’ve seen.</p>

<h2 id="conclusions">Conclusions</h2>

<p>As you may remember, <a href="/zipcpu/2019/08/22/tech-debt.html">I’m in the process of upgrading
AutoFPGA</a> so that it can
handle multiple bus types.  My current upgrade plans include both full
<a href="https://github.com/ZipCPU/autofpga/blob/master/sw/bus/wb.cpp">WB</a> support as
well as
<a href="https://github.com/ZipCPU/autofpga/blob/master/sw/bus/axil.cpp">AXI-lite</a>
support, although once I get that far
AXI
shouldn’t be much harder.  Indeed, most of the
AXI
work has already been done in either the <a href="https://github.com/ZipCPU/autofpga/blob/master/sw/bus/axil.cpp">AXI-lite bus logic
generator</a>,
or the <a href="/blog/2019/07/17/crossbar.html">AXI crossbar</a>.</p>

<p>Of course, <a href="https://github.com/ZipCPU/autofpga/tree/dev">my current work to this end is still quite
preliminary</a>, but this at least
outlines how I intend to get the bus to be able to handle large numbers of
slaves without breaking the piggy bank to get there.  My goal is also to make
the generated logic usable for all, rather than encumbered by copyrights,
so that I could then use it in a vendor-independent basis for an <a href="/blog/2019/08/16/intermediate.html">intermediate
digital design tutorial</a>.</p>

<p><a href="https://www.blueletterbible.org/kjv/heb/6/3">If the Lord wills</a>,
I’d love to have the opportunity to come back and blog about the success
of this work.  We’ll see what future the
<a href="https://www.blueletterbible.org/kjv/heb/6/3">Lord brings</a>.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And whosoever shall fall on this stone shall be broken: but on whomsoever it shall fall, it will grind him to powder. (Matt 21:44)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
