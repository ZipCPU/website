<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>The ZipCPU meets blinky</title>
  <meta name="description" content="If you’ve never heard of “blinky” before, it’s the name given to a piece ofsoftware or even an FPGA design that simply blinks an LED.  We’ve discussedbuildin...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2019/11/23/multithreaded-blinky.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">The ZipCPU meets blinky</h1>
    <p class="post-meta"><time datetime="2019-11-23T00:00:00-05:00" itemprop="datePublished">Nov 23, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>If you’ve never heard of “blinky” before, it’s the name given to a piece of
software or even an FPGA design that simply blinks an LED.  <a href="/blog/2017/05/19/blinky.html">We’ve discussed
building blinky before</a>,
as well the <a href="/blog/2017/05/20/knight-rider.html">more advanced (but no less fun) project
of moving an active LED back and forth across a set of
LEDs</a> like one of my
<a href="https://en.wikipedia.org/wiki/Knight_Rider">favorite TV shows as a kid, “Knight Rider”</a>.</p>

<p>Even better, we’ve also discussed how to create a <a href="https://github.com/ZipCPU/arrowzip/blob/195b77dc144d6ed7d4280f506c35b2204f13908c/rtl/arrowzip/wbgpio.v">general purpose I/O
controller</a>,
which could then be used to <a href="/zipcpu/2019/02/09/cpu-blinky.html">run a blinky program from within a
CPU</a>.
In that particular article, we also measured how fast a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
could toggle an I/O pin as part of such a <a href="https://github.com/ZipCPU/zbasic/blob/e7b39a56ee515d1cabe8427f30c7add0592bfab1/sw/board/gpiotoggle.c">blinky
program</a>.  The resulting toggle rates, between
1 and 47MHz, are fairly impressive for a soft-core running within an FPGA
with a 100MHz system clock.</p>

<p>Today, let’s return to blinky again, but this time let’s compare and contrast
several approaches to the problem of toggling four separate LEDs: one at <code class="language-plaintext highlighter-rouge">1Hz</code>,
one at <code class="language-plaintext highlighter-rouge">2Hz</code>, one at <code class="language-plaintext highlighter-rouge">3Hz</code>, and a fourth one at <code class="language-plaintext highlighter-rouge">5Hz</code>.</p>

<h2 id="fpga-blinky">FPGA blinky</h2>

<p>The easiest way to toggle four separate LEDs at once on an FPGA is to create
four separate blinky modules.  Each module would have a counter of some number
of bits, say <code class="language-plaintext highlighter-rouge">MSB+1</code> bits, so it might be defined as <code class="language-plaintext highlighter-rouge">reg [MSB:0] counter;</code>.
We could then add a different step in each module, where the step size
is <code class="language-plaintext highlighter-rouge">2^(MSB+1)/CLOCK_FREQUENCY * BLINK_FREQUENCY</code>, and so create blinking LEDs
at any frequency we want.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">parameter</span> <span class="n">STEP</span> <span class="o">=</span> <span class="n">BLINK_FREQUENCY</span> <span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">CLOCK_FREQUENCY</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
<span class="k">always</span> <span class="o">@</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">counter</span> <span class="o">+</span> <span class="n">STEP</span><span class="p">;</span>
<span class="k">assign</span>	<span class="n">o_led</span> <span class="o">=</span> <span class="n">counter</span><span class="p">[</span><span class="n">MSB</span><span class="p">];</span></code></pre></figure>

<table align="center" style="float: right"><caption>Fig 1. Four counters, each driving LED's</caption><tr><td><img src="/img/multithreaded-blinky/fpgax4.svg" alt="" width="280" /></td></tr></table>

<p>Internally, this might look something like Fig. 1 on the right.  Fig. 1 shows
four separate logic blocks, each similar to the block above, and each toggling
an LED at its own rate.</p>

<p>Of course, this doesn’t tie our LEDs together in phase.  What if we wanted
all of them to have the same phase, so that they all turned on together at the
top of a second?</p>

<p>In that case, we’d need to multiply a common counter, set to step at
<code class="language-plaintext highlighter-rouge">2^(MSB+1)/CLOCK_FREQUENCY</code>, by our blink frequency to get the result.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">parameter</span> <span class="n">STEP</span> <span class="o">=</span> <span class="n">BLINK_FREQUENCY</span> <span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">CLOCK_FREQUENCY</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">counter</span> <span class="o">+</span> <span class="n">STEP</span><span class="p">;</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">counter_1hz</span> <span class="o">&lt;=</span> <span class="n">counter</span><span class="p">;</span>
	<span class="n">counter_2hz</span> <span class="o">&lt;=</span> <span class="n">counter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">counter_3hz</span> <span class="o">&lt;=</span> <span class="n">counter</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">counter_5hz</span> <span class="o">&lt;=</span> <span class="n">counter</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">end</span>

<span class="k">assign</span> <span class="n">o_led_1hz</span> <span class="o">=</span> <span class="o">!</span><span class="n">counter_1hz</span><span class="p">[</span><span class="n">MSB</span><span class="p">];</span>
<span class="k">assign</span> <span class="n">o_led_2hz</span> <span class="o">=</span> <span class="o">!</span><span class="n">counter_2hz</span><span class="p">[</span><span class="n">MSB</span><span class="p">];</span>
<span class="k">assign</span> <span class="n">o_led_3hz</span> <span class="o">=</span> <span class="o">!</span><span class="n">counter_3hz</span><span class="p">[</span><span class="n">MSB</span><span class="p">];</span>
<span class="k">assign</span> <span class="n">o_led_5hz</span> <span class="o">=</span> <span class="o">!</span><span class="n">counter_5hz</span><span class="p">[</span><span class="n">MSB</span><span class="p">];</span></code></pre></figure>

<table align="center" style="float: left"><caption>Fig 2. Generating synchronized blinks from a counter</caption><tr><td><img src="/img/multithreaded-blinky/fpga-sync.svg" alt="" width="320" /></td></tr></table>

<p>If you’ve never built a design like this before, then I would encourage you
to try this.  Remember to formally verify it first, and then run it in
simulation.  The <a href="/tutorial/">tutorial</a> should help you
there if you have any questions.</p>

<p>For a next level challenge, consider removing the multiplies and replacing them
with shifts and adds.  Since we’re only multiplying by 2, 3, or 5 above,
this should be fairly easy.</p>

<p>If you work with FPGAs at all, this test should be fairly basic–perhaps
even too easy.  If you haven’t, this is a fun place to start.</p>

<p>Today, though, let’s take it up a notch.</p>

<h2 id="cpu-blinky-polled">CPU Blinky, polled</h2>

<table align="center" style="float: right"><caption>Fig 3. Placing a CPU within an FPGA</caption><tr><td><img src="/img/multithreaded-blinky/fpgawcpu.svg" alt="" width="480" /></td></tr></table>

<p>Moving from simple logic to a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
is a big step within an FPGA.  Even if we use a resource minimized
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
such as the
<a href="/about/zipcpu.html">ZipCPU</a>,
you’ll still need a lot of additional infrastructure.  At a minimum,
you’ll need a ROM to store startup instructions (I like using a <a href="/blog/2019/03/27/qflexpress.html">flash
memory device</a>), a
<a href="/zipcpu/2018/07/13/memories.html">RAM to hold any local variables</a>, a
<a href="/zipcpu/2018/04/17/ziptimer.html">timer</a>
to determine what 1Hz is and a GPIO controller to actually set any LED values.
We’ll also use a <a href="/zipcpu/2019/04/02/icontrol.html">Programmable Interrupt Controller
(PIC)</a>
as part of our solution.  Tying all of these together will require some type
of <a href="/zipcpu/2017/11/07/wb-formal.html">memory and peripheral bus (I like
Wishbone)</a>, such as
is shown in Fig. 3 on the right.</p>

<p>When we <a href="/zipcpu/2019/02/09/cpu-blinky.html">last discussed blinking an LED from a
CPU</a>, we discussed
how to turn the LED on by <a href="/blog/2018/11/03/soc-fpga.html">writing to a particular register from a C
program</a>,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="o">*</span><span class="n">_gpio</span> <span class="o">=</span> <span class="n">LED_ON</span><span class="p">;</span></code></pre></figure>

<p>and then writing again to turn it off.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="o">*</span><span class="n">_gpio</span> <span class="o">=</span> <span class="n">LED_OFF</span><span class="p">;</span></code></pre></figure>

<table align="center" style="float: left"><caption>Fig 4. Blinking with a counter</caption><tr><td><img src="/img/multithreaded-blinky/cpu-wait-counter.svg" alt="" width="240" /></td></tr></table>

<p>If you wanted to toggle an LED across some time period, you could wait in a for
loop, and then toggle your LED–as shown below and in Fig. 4 on the left.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">WAITTIME</span><span class="p">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="o">*</span><span class="n">_gpio</span> <span class="o">=</span> <span class="n">LED_ON</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">WAITTIME</span><span class="p">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="p">;</span>
	<span class="o">*</span><span class="n">_gpio</span> <span class="o">=</span> <span class="n">LED_OFF</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Getting the value for WAITTIME just right might take some work.  Worse,
<a href="https://en.wikipedia.org/wiki/CPU_cache">cache</a>s are notorious for
providing fast but unpredictable wait times for both instructions and data.</p>

<table align="center" style="float: right"><caption>Fig 5. Triggering off of a 1ms hardware counter</caption><tr><td><img src="/img/multithreaded-blinky/cpu-polled.svg" alt="" width="240" /></td></tr></table>

<p>But how might we handle four LEDs each toggling at a different rates?</p>

<p>We could use a timer!  Remember our work building an
<a href="/zipcpu/2018/04/17/ziptimer.html">interval timer</a> some time
ago?  Let’s use it now.  We’ll suppose the address of this timer is kept in the
<a href="/blog/2018/11/03/soc-fpga.html">constant pointer <code class="language-plaintext highlighter-rouge">_timer</code></a>,
and we’ll have it create a repeating interval of one millisecond.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">_timer</span> <span class="o">=</span> <span class="mh">0x80000000</span> <span class="o">+</span> <span class="p">(</span><span class="mh">0x8000</span><span class="n">_0000</span><span class="o">/</span><span class="n">CPU_FREQUENCY_HZ</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">;</span></code></pre></figure>

<p>We can then use our <a href="/zipcpu/2019/04/02/icontrol.html">interrupt
controller</a>, with a
<a href="/blog/2018/11/03/soc-fpga.html">register addresss</a>
at <code class="language-plaintext highlighter-rouge">_pic</code>, to determine if this timer has tripped:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">// Turn off all interrupt sources, and clear</span>
	<span class="c1">// all active interrupt indications</span>
	<span class="n">_pic</span> <span class="o">=</span> <span class="mh">0x7fff7fff</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">picv</span> <span class="o">=</span> <span class="o">*</span><span class="n">_pic</span><span class="p">;</span>
		<span class="c1">// Reset any tripped interrupts</span>
		<span class="n">_pic</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mh">0x0ffff</span> <span class="o">&amp;</span> <span class="n">picv</span><span class="p">);</span></code></pre></figure>

<p>If the <a href="/zipcpu/2019/04/02/icontrol.html">interrupt</a>
has tripped, we know a millisecond has passed, so we can increment our
millisecond counter, <code class="language-plaintext highlighter-rouge">count_ms</code>, and then toggle each of our LEDs.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Poll the interrupt timer to check</span>
		<span class="c1">// if the interrupt has tripped</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">picv</span> <span class="o">&amp;</span> <span class="n">INT_TIMER</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// if it has, adjust our LEDs</span>
			<span class="c1">// based upon the millisecond</span>
			<span class="c1">// counter, count_ms</span>
			<span class="n">count_ms</span> <span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count_ms</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span>
				<span class="n">count_ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">toggleled</span><span class="p">(</span><span class="n">count_ms</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">toggleled</span><span class="p">(</span><span class="n">count_ms</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">toggleled</span><span class="p">(</span><span class="n">count_ms</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">toggleled</span><span class="p">(</span><span class="n">count_ms</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span> </code></pre></figure>

<p>Of course, polling the <a href="/zipcpu/2019/04/02/icontrol.html">interrupt
controller</a>
like this is really the wrong way to do this, but let’s come back to
this thought in the next section when we discuss how to do this with
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>.</p>

<p>One of the neat things about this approach compared to the uncalibrated
<code class="language-plaintext highlighter-rouge">for</code> loop above is that we can now know <em>exactly</em> how many clocks take
place between <a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>.
We also know that, should the
<a href="/about/zipcpu.html">CPU</a>,
be late in processing an LED fast enough, at least the sequence will maintain
its frequency rather than randomly getting later and later and so slower–since
the <a href="/zipcpu/2018/04/17/ziptimer.html">timer</a>
restarts itself every ms in this case.</p>

<p>For now, let’s look at this <code class="language-plaintext highlighter-rouge">toggle_leds_on_ms()</code> function.  How should this
function work?  The same way as before!  We’ll multiply our counter by
the toggle rate, divide by the number of counts per second, and then
grab the resulting bit of interest from the number of times the counter
wraps.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>	<span class="nf">toggle_leds_one_ms</span><span class="p">(</span><span class="kt">int</span> <span class="n">count_ms</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rate_hz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">which_led</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">mpy</span><span class="p">;</span>

	<span class="c1">// count_ms is the number of milliseconds from the top of our</span>
	<span class="c1">// second, ranging from 0 to 999.</span>
	<span class="c1">//</span>
	<span class="c1">// count_ms times our rate will give us a counter that overflows</span>
	<span class="c1">// (rate) times per second.  Twice that creates a counter that</span>
	<span class="c1">// overflows (2*rate) times per second--enough for us to turn on</span>
	<span class="c1">// and then off the LED.</span>
	<span class="n">mpy</span> <span class="o">=</span> <span class="n">count_ms</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rate_hz</span><span class="p">);</span>
	<span class="n">mpy</span> <span class="o">=</span> <span class="n">mpy</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="c1">// mpy &amp; 1 now contains what we want our counter value to be</span>
	<span class="c1">//</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mpy</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Turn this LED on</span>
		<span class="o">*</span><span class="n">_gpio</span> <span class="o">=</span> <span class="p">(</span><span class="n">which_led</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">which_led</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Turn this LED off</span>
		<span class="o">*</span><span class="n">_gpio</span> <span class="o">=</span> <span class="p">(</span><span class="n">which_led</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Remember <a href="/zipcpu/2019/02/09/cpu-blinky.html">the way we constructed our GPIO
controller</a>: the
top 16 bits on read are any inputs to our design, while the bottom 16 bits
are outputs.  To be able to set particular output bits and not others, we write
a mask of the outputs we wish to adjust to the top 16 bits of the
register–hence the <code class="language-plaintext highlighter-rouge">(which_led &lt;&lt; 16)</code> logic from above.  That way we can
leave the other I/O registers alone, while just adjusting only the ones
we want to change.</p>

<h2 id="interrupt-driven-cpu-blinky">Interrupt driven CPU Blinky</h2>

<p>What if we could shut the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
down, though, when nothing was changing?</p>

<table align="center" style="float: left"><caption>Fig 6. Using the ZipCPU WAIT instruction</caption><tr><td><img src="/img/multithreaded-blinky/wait-for-timer.svg" alt="" width="360" /></td></tr></table>

<p>This it the purpose of the <a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="/zipcpu/2018/01/01/zipcpu-isa.html"><code class="language-plaintext highlighter-rouge">WAIT</code> instruction</a>.
We can get access to it from C without needing any assembly by calling the
built-in <code class="language-plaintext highlighter-rouge">zip_wait()</code> function.  This instruction sets the <code class="language-plaintext highlighter-rouge">SLEEP</code> bit in the
<a href="/about/zipcpu.html">ZipCPU</a>’s <a href="/zipcpu/2018/01/01/zipcpu-isa.html">control
register</a>.
Further, if the <a href="/about/zipcpu.html">ZipCPU</a>
isn’t already in <a href="/zipcpu/2018/01/01/zipcpu-isa.html">user mode (interrupts are enabled only in user
mode)</a>, it puts the
<a href="/about/zipcpu.html">ZipCPU</a>
into <a href="/zipcpu/2018/01/01/zipcpu-isa.html">user mode</a>.
Then, when an <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
trips, the <a href="/about/zipcpu.html">ZipCPU</a> will return to
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">supervisor mode (where interrupts are
disabled)</a> so that we
can process the <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/doc//spec.pdf">specification</a>
discusses how to do this using a <code class="language-plaintext highlighter-rouge">wait_for_interrupt</code>
function.  This function primarily deals with setting up the <a href="/zipcpu/2019/04/02/icontrol.html">interrupt
controller</a>,
but once done it issues a <code class="language-plaintext highlighter-rouge">zip_wait()</code> instruction for exactly this purpose.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>	<span class="nf">wait_for_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">interruptmask</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Turn off all interrupts, while acknowledging none of them</span>
	<span class="o">*</span><span class="n">_pic</span> <span class="o">=</span> <span class="mh">0x7fff0000</span><span class="p">;</span>
	<span class="c1">// Turn on only this interrupt</span>
	<span class="o">*</span><span class="n">_pic</span> <span class="o">=</span> <span class="p">(</span><span class="n">interruptmask</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="mh">0x80008000</span><span class="p">;</span>

	<span class="c1">// Be careful not to adjust any interrupts that have</span>
	<span class="c1">// already tripped (the bottom 16 bits of the</span>
	<span class="c1">// _pic), lest we miss the interrupt we are</span>
	<span class="c1">// looking for</span>

	<span class="c1">// Wait for the interrupt, forcing the CPU to sleep</span>
	<span class="c1">// until the next interrupt</span>
	<span class="n">zip_wait</span><span class="p">();</span>

	<span class="c1">// We won't clear the interrupt here,</span>
	<span class="c1">// lest we destroy some information the</span>
	<span class="c1">// calling function needs.</span>
<span class="p">}</span></code></pre></figure>

<p>Now we can rewrite our code from above to wait for an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.
Once done, the <a href="/about/zipcpu.html">CPU</a>
will sleep between its top-of-the-millisecond
computations.  The biggest difference in the code below is that
we now issue a <code class="language-plaintext highlighter-rouge">wait_for_interrupt()</code> call at the top of every loop.
Following that call, things should look about the same as before.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">_pic</span> <span class="o">=</span> <span class="mh">0xffff7fff</span><span class="p">;</span> <span class="c1">// Clear all interrupts</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_for_interrupt</span><span class="p">(</span><span class="n">INT_TIMER</span><span class="p">);</span>

		<span class="c1">// Now check for any tripped interrupts</span>
		<span class="kt">int</span>	<span class="n">picv</span> <span class="o">=</span> <span class="o">*</span><span class="n">_pic</span><span class="p">;</span>

		<span class="c1">// Reset any tripped interrupts</span>
		<span class="n">_pic</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mh">0x0ffff</span> <span class="o">&amp;</span> <span class="n">picv</span><span class="p">);</span>

		<span class="c1">// Check if the timer interrupt has tripped</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">picv</span> <span class="o">&amp;</span> <span class="n">INT_TIMER</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// if it has, adjust our LEDs</span>
			<span class="c1">// based upon the millisecond</span>
			<span class="c1">// counter, count_ms</span>
			<span class="n">count_ms</span> <span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count_ms</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span>
				<span class="n">count_ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">toggle_leds_one_ms</span><span class="p">(</span><span class="n">count_ms</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">toggle_leds_one_ms</span><span class="p">(</span><span class="n">count_ms</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">toggle_leds_one_ms</span><span class="p">(</span><span class="n">count_ms</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">toggle_leds_one_ms</span><span class="p">(</span><span class="n">count_ms</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span> </code></pre></figure>

<p>Not bad, huh?</p>

<p>This program now functions exactly the same as the last one, save that the
<a href="/about/zipcpu.html">ZipCPU</a>
is inactive while waiting for the
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.
This can have two advantages.  First, the
<a href="/about/zipcpu.html">ZipCPU</a>
will stop using the bus, allowing any non-CPU logic to transfer
data without contention from the
<a href="/about/zipcpu.html">ZipCPU</a>.  Second, since the
<a href="/about/zipcpu.html">ZipCPU</a>
will stop issuing instructions, it can be placed into a lower power state.
Stopping the CPU clock at this point might even be an option to lower power–as
long as any <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
source kept clocking, and as long as the <a href="/zipcpu/2019/04/02/icontrol.html">interrupt
controller</a>
could restart the CPU’s clock.  Still, it is doable, although it does depend
upon how much work you want to do to keep your power down.</p>

<p>What if we wanted to get really fancy, though, and create a <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/intdemo.c">multitasking
blinky</a>?
One where we had a separate program to toggle each of several various LEDs?</p>

<h2 id="multi-blinky">Multi Blinky</h2>

<p>To build the multi-tasking blinky, let’s step back and just look at the question
of how to run multiple software programs on a piece of hardware.</p>

<table align="center" style="float: right"><caption>Fig 7. Blinking an LED with four separate CPUs</caption><tr><td><img src="/img/multithreaded-blinky/cpux4.svg" alt="" width="360" /></td></tr></table>

<p>The easiest way to do this, software-wise, might be to build multiple
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s, as shown in
Fig. 7 on the right.  Easy, that is, until the two programs need to
communicate with each other …  but that’s a story for another day. Each
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
might then run a separate program toggling an LED.</p>

<p>Let’s build such a program now.  We’ll start by removing the counter
from our <code class="language-plaintext highlighter-rouge">toggle_leds_one_ms()</code> function.  Instead, we’ll make the total number
of milliseconds that have passed into a global variable.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span>	<span class="n">milliseconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>We’ll then adjust our <code class="language-plaintext highlighter-rouge">toggle_leds_one_ms</code> function so that it just reads and
references this global <code class="language-plaintext highlighter-rouge">milliseconds</code> counter.  We’ll call this new function
<code class="language-plaintext highlighter-rouge">toggleled</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>    <span class="nf">toggleled</span><span class="p">(</span><span class="kt">int</span> <span class="n">led_bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>     <span class="n">ms</span> <span class="o">=</span> <span class="n">milliseconds</span><span class="p">,</span> <span class="n">led</span><span class="p">;</span>
		<span class="n">ms</span> <span class="o">=</span> <span class="n">ms</span> <span class="o">*</span> <span class="p">(</span><span class="n">rate</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">led</span> <span class="o">=</span> <span class="p">(</span><span class="n">ms</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">led</span><span class="p">)</span>
			<span class="c1">// LED was on.  Turn it off</span>
			<span class="o">*</span><span class="n">_spio</span> <span class="o">=</span> <span class="p">(</span><span class="n">led_bits</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="c1">// LED was off.  Turn it on</span>
			<span class="o">*</span><span class="n">_spio</span> <span class="o">=</span> <span class="p">(</span><span class="n">led_bits</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">led_bits</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Notice our care to only read the global <code class="language-plaintext highlighter-rouge">milliseconds</code> value once.  Since reads
are atomic and since we copied the <code class="language-plaintext highlighter-rouge">milliseconds</code> value, we don’t have to worry
about it changing mid-routine as a result of any routine that might
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
this processing.</p>

<p>A second thing to notice is that <a href="https://github.com/ZipCPU/arrowzip">the
design</a> we are basing this off of has a
<a href="https://github.com/ZipCPU/arrowzip/blob/master/rtl/arrowzip/spio.v"><em>Special Purpose I/O</em>
register</a>,
<code class="language-plaintext highlighter-rouge">_spio</code>.  Setting LED’s in this <code class="language-plaintext highlighter-rouge">_spio</code> register is just like using the <code class="language-plaintext highlighter-rouge">_gpio</code>
register above, save that the LED area is now the lower 8-bits, and the
“adjust-these-bits” area is the 8-bits above that.  Hence, our reference
above to <code class="language-plaintext highlighter-rouge">_spio</code> and <code class="language-plaintext highlighter-rouge">(led_bits&lt;&lt;8)</code>.</p>

<p>Finally, as long as something exists to count and keep the <code class="language-plaintext highlighter-rouge">milliseconds</code>
counter for us, we can write a program to toggle our first LED at 1 Hz
as simple as,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>    <span class="nf">one_hz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">toggleled</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Now if each CPU on our circuit board had such a program, they could all
toggle their LEDs together.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>    <span class="nf">two_hz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">toggleled</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>    <span class="nf">three_hz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">toggleled</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>    <span class="nf">five_hz</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">toggleled</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>There are a couple of problems with this approach.  First and foremost, the
<a href="/about/zipcpu.html">ZipCPU</a>
project has been built around small FPGAs and low logic.  (I never really had
the budget for much more.)  Four
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s,
whether on four circuit boards, four chips on the same circuit board, or four
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
within the same FPGA, has never been within my budget.  I’d like to
run each of these four separate programs on the same
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
instead.</p>

<p>The solution to this problem is to virtually switch CPUs over time, as shown
in Fig. 8 below, through a process called
<a href="https://en.wikipedia.org/wiki/Time-sharing">time-sharing</a>.</p>

<table align="center" style="float: none"><caption>Fig 8. Blinking an LED with four separate CPUs</caption><tr><td><img src="/img/multithreaded-blinky/timeslice.svg" alt="" width="560" /></td></tr></table>

<p>Here’s how it works: First, the
<a href="/about/zipcpu.html">CPU</a> will start out running one
program–we’ll call this context 1 or <code class="language-plaintext highlighter-rouge">C1</code> for short.  Then, after some
period of time, we’ll call it a <em>quanta</em> and set it to <code class="language-plaintext highlighter-rouge">1ms</code>, an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
will return the
<a href="/about/zipcpu.html">CPU</a> to its supervisory task, <code class="language-plaintext highlighter-rouge">S</code>.
The supervisory task will switch programs to the second context, <code class="language-plaintext highlighter-rouge">C2</code>, which
will then run for the next <em>quanta</em>.</p>

<table align="center" style="float: left"><caption>Fig 9. Contexts contain CPU Register sets</caption><tr><td><img src="/img/multithreaded-blinky/contexts.svg" alt="" width="360" /></td></tr></table>

<p>The key to the whole operation is that each “program” needs to
believe that it owns the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
In order to support this,
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
are typically designed so that their entire state is captured within a set of
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>.
This
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>
set, defining what the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
is up to, is called a <em>context</em>.  Each <em>context</em> contains its own
set of <a href="https://en.wikipedia.org/wiki/Processor_register">register</a>s,
<code class="language-plaintext highlighter-rouge">R0</code>-<code class="language-plaintext highlighter-rouge">R15</code> on the
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">ZipCPU</a>,
to include the
<a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer <code class="language-plaintext highlighter-rouge">SP</code></a>
(also known as <code class="language-plaintext highlighter-rouge">R13</code>), <a href="https://en.wikipedia.org/wiki/Status_register">condition codes
<code class="language-plaintext highlighter-rouge">CC</code></a>
(also known as <code class="language-plaintext highlighter-rouge">R14</code>), and the address of the next instruction, often called
the <a href="https://en.wikipedia.org/wiki/Program_counter">program counter <code class="language-plaintext highlighter-rouge">PC</code></a>
or equivalently <code class="language-plaintext highlighter-rouge">R15</code> on the
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">ZipCPU</a>.
Therefore, in order to switch from running one program to another all the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> needs to do
is to write the current context (i.e.
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a> set)
to memory, and to then to read the stored context for the next program
from memory.  This is often called a <a href="https://en.wikipedia.org/wiki/Context_switch">context
switch</a>.</p>

<p>To facilitate <a href="https://en.wikipedia.org/wiki/Context_switch">context
switching</a>, the
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">ZipCPU</a>
maintains two copies of its
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a> set:
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">one for the supervisor and one for user
programs</a>.  Of these
two, the supervisor context is never swapped.  Indeed, it is the supervisor
context that swaps user contexts.</p>

<table align="center" style="float: right"><caption>Fig 10. Each context needs its own stack area</caption><tr><td><img src="/img/multithreaded-blinky/memlayout.svg" alt="" width="360" /></td></tr></table>

<p>Outside of the <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
each context will also need an area of memory for its local variables.
This is called <a href="https://en.wikipedia.org/wiki/Call_stack">the stack</a>,
and the <a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a>
will point to a location within this memory–starting at the end of the memory.
As memory is allocated, the <a href="https://en.wikipedia.org/wiki/Stack_register">stack
pointer</a> will grow towards lower
memory as shown by the upwards arrow in Fig. 10.</p>

<p>We can use a simple array of integers to capture the information contained in
a <a href="/zipcpu/2018/01/01/zipcpu-isa.html">ZipCPU</a>
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a> set.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span>	<span class="k">struct</span>	<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">r</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">}</span> <span class="n">task_context</span><span class="p">;</span></code></pre></figure>

<p>To <a href="https://en.wikipedia.org/wiki/Context_switch">swap between one program and
the next</a>, we’ll just swap
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a> sets.
The two programs will never know what happened, because when the next program
is activated, all of its data will be right there in its
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>s
just as it was when it left off.</p>

<p>Let’s walk through how we might do this.</p>

<p>The first step will be to assign a
<a href="https://en.wikipedia.org/wiki/Call_stack">stack</a>
to each task, as shown in Fig. 10 above.  This is a place of
memory designed to hold each task’s local variables.</p>

<table align="center" style="float: left"><caption>Fig 11. The heap grows downwards</caption><tr><td><img src="/img/multithreaded-blinky/heap.svg" alt="" width="280" /></td></tr></table>

<p>Normally, I’d use <code class="language-plaintext highlighter-rouge">malloc()</code> to do this or even the C++ <code class="language-plaintext highlighter-rouge">new</code> operator.
Today, we’re going to try to do this without the C-library.  As a result,
we’ll need an alternative.  I’m going to call that alternative <code class="language-plaintext highlighter-rouge">ugly_malloc()</code>.
It will act the same as <code class="language-plaintext highlighter-rouge">malloc()</code>, except that there’s no <code class="language-plaintext highlighter-rouge">free()</code> call and
so the memory will never return.</p>

<p>This <code class="language-plaintext highlighter-rouge">ugly_malloc()</code> function is built around a pointer to the end of our
program’s fixed memory locations.  The <a href="/zipcpu/2018/12/22/autofpga-ld.html">AutoFPGA linker
scripts</a> define this
pointer as <code class="language-plaintext highlighter-rouge">_top_of_heap</code>.  We can grab that here,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">extern</span>	<span class="kt">char</span>	<span class="n">_top_of_heap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kt">unsigned</span>	<span class="n">_heap</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">_top_of_heap</span><span class="p">;</span></code></pre></figure>

<p>Just getting to the point where <code class="language-plaintext highlighter-rouge">_heap</code> even gets this value takes a lot of
work, much of which we will skip here.  That work starts in the
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> <a href="https://github.com/ZipCPU/arrowzip/blob/master/auto-data/sdram.ld">configuration
script</a>
that describes where the <a href="/about/zipcpu.html">ZipCPU</a>’s
memory is even located on a particular hardware architecture.  That script
defines the <code class="language-plaintext highlighter-rouge">_top_of_heap</code> pointer and makes certain it’s aligned.  The next
step takes place in the
<a href="/zipcpu/2018/02/12/zbasic-intro.html">bootloader</a>,
since <code class="language-plaintext highlighter-rouge">_heap</code> is a variable whose value might change.  Such variables need to
be set initially.  So, this
<a href="/zipcpu/2018/02/12/zbasic-intro.html">bootloader</a>
copies the initial value into <code class="language-plaintext highlighter-rouge">_heap</code> before starting <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/intdemo.c">our
program</a>.</p>

<p>Finally, we can now write this <code class="language-plaintext highlighter-rouge">ugly_malloc()</code> function.  This function works
by just grabbing the next <code class="language-plaintext highlighter-rouge">nbytes</code> from the heap, and then incrementing our
<code class="language-plaintext highlighter-rouge">_heap</code> pointer to the next unallocated section of memory.  Since the
<a href="/about/zipcpu.html">ZipCPU</a>
cannot (yet) read from unaligned memory, we’ll also need to make certain this
pointer remains aligned.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>    <span class="o">*</span><span class="nf">ugly_malloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Get the pointer to the next unallocated piece of memory</span>
	<span class="c1">// This is where our returned memory will be located..</span>
        <span class="kt">void</span>    <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">_heap</span><span class="p">;</span>

	<span class="c1">// Advance our _heap pointer to the next available piece</span>
	<span class="c1">// of memory, while also guaranteeing that the pointer</span>
	<span class="c1">// remains aligned.</span>
        <span class="n">_heap</span> <span class="o">=</span> <span class="n">_heap</span> <span class="o">+</span> <span class="p">((</span><span class="n">nbytes</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>

	<span class="c1">// And return the result--the value of _heap when we entered</span>
        <span class="k">return</span>  <span class="n">r</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Using this <code class="language-plaintext highlighter-rouge">ugly_malloc()</code> function, we can now allocate some local
variable space for each of our programs.  This will be the <a href="https://en.wikipedia.org/wiki/Call_stack">“stack”
space</a>
used by these programs, and so we’ll use this to set the <a href="https://en.wikipedia.org/wiki/Stack_register"><code class="language-plaintext highlighter-rouge">SP</code>
register</a>
for each of the programs.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span>     <span class="o">*</span><span class="nf">new_stack_ptr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nbytes</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">ugly_malloc</span><span class="p">(</span><span class="n">nbytes</span><span class="p">);</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">[((</span><span class="n">nbytes</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Thus function allocates a section of memory <code class="language-plaintext highlighter-rouge">nbytes</code> in length, and then
returns a pointer to the end of it.  Our tasks won’t actually write to this
end value, but will instead back up
<a href="https://en.wikipedia.org/wiki/Stack_register">this pointer</a>
by however much space they need as they need it.  This is illustrated in
Fig. 11 by an upwards arrow within each task’s
<a href="https://en.wikipedia.org/wiki/Call_stack">stack memory area</a>
showing that the <a href="https://en.wikipedia.org/wiki/Call_stack">stack</a>
grows upwards towards low memory.</p>

<p>The astute observer will notice that the <a href="https://en.wikipedia.org/wiki/Call_stack">stack
spaces</a>, which are
illustrated in Fig. 10, both for the supervisor and each of the user contexts,
are not unlimited.  If they grow too far, the
<a href="https://en.wikipedia.org/wiki/Call_stack">stack</a> will
<a href="https://en.wikipedia.org/wiki/Stack_overflow">overflow</a> into other memory
regions causing … lots of problems.  Picking how much space to allocate for
the <a href="https://en.wikipedia.org/wiki/Call_stack">stack</a> is therefore quite
important, and a problem for which I don’t (yet) have a good solution for.</p>

<p>Since we’ve chosen not to use any system libraries for this code, we’ll need
to write our own <code class="language-plaintext highlighter-rouge">memzero</code> routine so that we can start our tasks off with a
clean slate.  This <code class="language-plaintext highlighter-rouge">memzero()</code> (should-be a) library function is also
pretty basic,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>    <span class="nf">memzero</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span>    <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cp</span><span class="o">++</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Much as one might expect.</p>

<p>Incidentally, we could do this operation four times faster if we took
advantage of the fact that our memory is both word aligned and an integer
number of words.  For now, we’ll leave this as an exercise for the student
to try later.</p>

<p>Now that we have this background under our belt, it’s time to build
our <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/intdemo.c">multi-tasking blinky</a>.</p>

<p>Starting at the top, the
<a href="/about/zipcpu.html">CPU</a>
will begin by executing a
<a href="/zipcpu/2018/02/12/zbasic-intro.html">bootloader</a>.
<a href="/zipcpu/2018/02/12/zbasic-intro.html">This function</a>
copies our program into memory (if necessary), and then initializes
any global variables.  Once complete, the
<a href="/zipcpu/2018/02/12/zbasic-intro.html">bootloader</a>
will call our <code class="language-plaintext highlighter-rouge">main()</code> function–giving the appearance that this is where our
program starts.  Once in <code class="language-plaintext highlighter-rouge">main()</code>, we will first define all of our
tasks (i.e. contexts), as well as a <code class="language-plaintext highlighter-rouge">current</code> task pointer to point
to the task that is currently active.  The tasks themselves in this simple
example consist of nothing more than the <code class="language-plaintext highlighter-rouge">task_context</code> structure we defined
above containing the
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>
values of each running program.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span>	<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// **s</span>
        <span class="kt">unsigned</span>        <span class="n">heartbeats</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">task_context</span>    <span class="n">tasks</span><span class="p">[</span><span class="n">NTASKS</span><span class="p">];</span>
        <span class="n">task_context</span>    <span class="o">*</span><span class="n">current</span><span class="p">;</span>

        <span class="n">memzero</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">task_context</span><span class="p">)</span><span class="o">*</span> <span class="n">NTASKS</span><span class="p">);</span></code></pre></figure>

<p>I’ve also declared a <code class="language-plaintext highlighter-rouge">heartbeats</code> variable as well.  We’ll use this to debug
our program and to determine if anything has gone wrong and we need to enter
into the <a href="/zipcpu/2017/08/25/hw-debugging.html">debugger</a>.
Specifically, if ever the <code class="language-plaintext highlighter-rouge">heartbeats</code> counter stops
counting, we’ll know our program is dead.</p>

<p>There’s actually a couple ways of implementing this <code class="language-plaintext highlighter-rouge">heartbeats</code> idea.</p>

<ol>
  <li>
    <p>One way, shown above, is to create a variable on the stack to hold this
value.</p>

    <p>The first problem with this approach is that the compiler might move this
variable into a
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>.  When it’s in
a <a href="https://en.wikipedia.org/wiki/Processor_register">register</a>, we’ll need
to use the <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugging interface</a>
to read it in order to know if the <code class="language-plaintext highlighter-rouge">heartbeats</code> have ever stopped, rather
than reading this value from memory using the
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus</a>.</p>

    <p>There two big problems with this approach.  The first is knowing whether
<code class="language-plaintext highlighter-rouge">heatbeats</code> is in a
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>
vs being in memory.  The second problem is knowing which
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>
<code class="language-plaintext highlighter-rouge">heartbeats</code> is kept within.  Until the
<a href="/about/zipcpu.html">ZipCPU</a> supports a <a href="https://en.wikipedia.org/wiki/Debugger">source-level
debugger</a>, this will require
examining some (dis)assembly to see how the compiler allocated it.  You
can use <code class="language-plaintext highlighter-rouge">zip-objdump -D intdemo &gt; intdemo.txt</code> to examine this (dis)assembly.
Since I find myself doing this so often, there’s a <code class="language-plaintext highlighter-rouge">make</code> option in the
<a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/Makefile">Makefile</a>
to <code class="language-plaintext highlighter-rouge">make intdemo.txt</code> which does almost exactly this.  The <code class="language-plaintext highlighter-rouge">make</code> option
puts some other information into <code class="language-plaintext highlighter-rouge">intdemo.txt</code> as well, so feel free to try
it out yourself and see what you think.</p>
  </li>
  <li>
    <p>A second way to handle the <code class="language-plaintext highlighter-rouge">heartbeats</code> value would be to declare it as a
<code class="language-plaintext highlighter-rouge">volatile unsigned</code> value.  If we do that, the <code class="language-plaintext highlighter-rouge">heartbeats</code> value will be
forced into <a href="https://en.wikipedia.org/wiki/Call_stack">local (stack) memory</a>.
We can then use our <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging
bus</a> to read it even
while the <a href="/about/zipcpu.html">CPU</a> is running.</p>

    <p>The problem is, which memory address will <code class="language-plaintext highlighter-rouge">heartbeats</code> get placed into?
Typically, as long as <code class="language-plaintext highlighter-rouge">heartbeats</code> is the first value declared in <code class="language-plaintext highlighter-rouge">main()</code>,
it’ll always be at the same place on the
<a href="https://en.wikipedia.org/wiki/Call_stack">stack</a>,
but finding this place the first time might take some work.</p>
  </li>
  <li>
    <p>A third option would be to declare <code class="language-plaintext highlighter-rouge">heartbeats</code> as a global variable.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">unsigned</span>	<span class="n">heartbeats</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span>	<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// **s</span>
	<span class="c1">// ... code follows</span></code></pre></figure>

<p>Were we to do this instead, <code class="language-plaintext highlighter-rouge">wbregs</code> has an option where, if given a map file,
you can read this value by name.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% wbregs <span class="nt">-m</span> obj-zip/intdemo.map heartbeats</code></pre></figure>

<p>But let’s get back to <a href="https://github.com/ZipCPU/arrowzip/blob/master/sw/board/intdemo.c">our
program</a>.
We just created memory to hold <code class="language-plaintext highlighter-rouge">NTASKS</code>
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>
sets (contexts).  Now let’s give them some initial values.  The most
important values to provide are the
<a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a> and the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Define a void function pointer type</span>
<span class="k">typedef</span> <span class="nf">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">voidfn</span><span class="p">)();</span>	<span class="c1">//*</span>

<span class="c1">// ...</span>
<span class="kt">int</span>	<span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// **s</span>
	<span class="c1">// ...</span>
	<span class="c1">// returning back to our main() function ...</span>
	<span class="c1">//</span>

	<span class="c1">// Give each task a stack, and a program counter</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NTASKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="c1">// Allocate 256-bytes of local memory for each task</span>
		<span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">new_stack_ptr</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>

	<span class="c1">// Set the "Program Counter" for each context, giving each</span>
	<span class="c1">// task a function to start processing on entry</span>
	<span class="n">tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)((</span><span class="n">voidfn</span><span class="p">)</span><span class="n">one_hz</span><span class="p">);</span>
	<span class="n">tasks</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)((</span><span class="n">voidfn</span><span class="p">)</span><span class="n">two_hz</span><span class="p">);</span>
	<span class="n">tasks</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)((</span><span class="n">voidfn</span><span class="p">)</span><span class="n">three_hz</span><span class="p">);</span>
	<span class="n">tasks</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)((</span><span class="n">voidfn</span><span class="p">)</span><span class="n">five_hz</span><span class="p">);</span></code></pre></figure>

<p>Once we’ve done all that, we’ve almost finished our startup processing.  There
are only a couple steps left.</p>

<p>The first is to choose to start the first task, and then to load the user
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>s
from that task pointer.  The
<a href="/about/zipcpu.html">ZipCPU</a> toolchain provides a
<code class="language-plaintext highlighter-rouge">zip_restore_context()</code> function to make things easier.  This function expands
into some code to copy the
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>
values from the address given, in this case a pointer to <code class="language-plaintext highlighter-rouge">current-&gt;r[0]</code>,
into the user
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>
set, <code class="language-plaintext highlighter-rouge">uR0</code> through <code class="language-plaintext highlighter-rouge">uPC</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="n">current</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">zip_restore_context</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span></code></pre></figure>

<p>Once done, we can then issue a “return-to-usermode” instruction, assembly
<code class="language-plaintext highlighter-rouge">RTU</code> or <code class="language-plaintext highlighter-rouge">zip_rtu()</code> from C, to switch from supervisor to user mode.</p>

<p>Only, we can’t do that just yet.
<a href="/about/zipcpu.html">ZipCPU</a>
programs only exit user mode on
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>s,
exceptions (i.e. faults), and traps (system calls).  Since our
program shouldn’t be creating any exceptions (if it works), and since
we’re not issuing any system calls, we’ll need another way to grab control
back from userspace: <a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>.</p>

<p>Let’s therefore set our
<a href="/zipcpu/2018/04/17/ziptimer.html">timer</a> to
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
us every millisecond.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="o">*</span><span class="n">_bustimer</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x80000000</span><span class="p">)</span><span class="o">|</span><span class="p">((</span><span class="n">CLKFREQHZ</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span><span class="p">);</span>
	<span class="c1">// Enable interrupts, and our interrupt in particular</span>
	<span class="o">*</span><span class="n">_buspic</span> <span class="o">=</span> <span class="mh">0x80008000</span> <span class="o">|</span> <span class="n">BUSPIC_BUSTIMER</span> <span class="o">|</span> <span class="p">(</span><span class="n">BUSPIC_BUSTIMER</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span></code></pre></figure>

<p>It’s now time to write out main logic loop.  We’ll start out by clearing
every other LED, and incrementing our <code class="language-plaintext highlighter-rouge">heartbeats</code> counter.  We can then
run the user task.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">               <span class="kt">int</span>     <span class="n">picv</span><span class="p">;</span>

                <span class="o">*</span><span class="n">_spio</span> <span class="o">=</span> <span class="mh">0xaa00</span><span class="p">;</span>
                <span class="n">heartbeats</span><span class="o">++</span><span class="p">;</span>

		<span class="c1">// Run the user task, via a "return-to-userspace" insn</span>
                <span class="n">zip_rtu</span><span class="p">();</span></code></pre></figure>

<p>Once we issue the <code class="language-plaintext highlighter-rouge">RTU</code> instruction, the
<a href="/about/zipcpu.html">ZipCPU</a>
will switch to using the user-register set.  Since everything is captured by
this <em>context</em>, switching to this user-register set will feel like switching
which program is running.</p>

<p>Unlike many other
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
which have a single register set, the
<a href="/about/zipcpu.html">ZipCPU</a>
maintains the supervisor’s context while running in user mode.  That means
that the supervisor
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>,
<a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a>,
and indeed all of the <a href="/zipcpu/2018/01/01/zipcpu-isa.html">supervisor
registers</a> are
maintained until the <a href="/about/zipcpu.html">CPU</a>
returns to supervisor mode from user mode.  What that means is that, on an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>,
the <a href="/about/zipcpu.html">CPU</a>
will continue running this supervisor function where it left off.</p>

<p>The more traditional approach would be for the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
to suddenly jump to an <em><a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt service
routine</a></em>.  The address
of such a <a href="https://en.wikipedia.org/wiki/Interrupt_handler">routine</a> would be
kept in a <a href="https://en.wikipedia.org/wiki/Interrupt_vector_table">special memory
location</a> that the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> could
look up and start from when the context switch needed to take place.</p>

<p>By just switching register sets, the
<a href="/about/zipcpu.html">ZipCPU</a> is
kind of unique in this way.  I personally find it easier
to write multi-tasking programs as a result.</p>

<p>On our return, the first thing we’ll do is set those LEDs we just cleared–every
other LED is now set to indicate we are in supervisor mode.  I’ve found this to
be a really useful way of debugging what goes wrong when things don’t work: if
these LEDs are on, the
<a href="/about/zipcpu.html">CPU</a>
is in supervisor mode, else it is in user mode.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">		<span class="c1">// Turn on LED's 1, 3, 5, 7, ...</span>
                <span class="o">*</span><span class="n">_spio</span> <span class="o">=</span> <span class="mh">0xaaaa</span><span class="p">;</span></code></pre></figure>

<p>We’ll turn these off again before we leave supervisor mode.</p>

<p>Our next step is to check the user-mode <a href="https://en.wikipedia.org/wiki/Status_register"><code class="language-plaintext highlighter-rouge">CC</code>
register</a> to see if we left user
mode as a result of some form of exception.  If so, we’ll call a <code class="language-plaintext highlighter-rouge">panic()</code>
function–more on that later.  It’s important to enter the <code class="language-plaintext highlighter-rouge">panic()</code> function
as soon as possible once we detect an exception, so that we can debug anything
that went wrong with as little change to the system as possible.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">                <span class="k">if</span> <span class="p">(</span><span class="n">zip_ucc</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CC_EXCEPTION</span><span class="p">))</span>
                        <span class="n">panic</span><span class="p">();</span></code></pre></figure>

<p>At long last, it’s now finally time to check the <a href="/zipcpu/2019/04/02/icontrol.html">interrupt
controller</a>
to see if an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
has taken place.  If so, we’ll increment the <code class="language-plaintext highlighter-rouge">milliseconds</code> counter
that all of the tasks are using.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">		<span class="c1">// Read the current state from the interrupt controller</span>
                <span class="n">picv</span> <span class="o">=</span> <span class="o">*</span><span class="n">_buspic</span><span class="p">;</span>

		<span class="c1">// Check if the timer has triggered an interrupt</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">picv</span> <span class="o">&amp;</span> <span class="n">BUSPIC_BUSTIMER</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// Timer interrupt triggered</span>

			<span class="c1">// Increment our millisecond counter</span>
                        <span class="n">milliseconds</span> <span class="o">=</span> <span class="n">milliseconds</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">milliseconds</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span>
                                <span class="n">milliseconds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>We’ll then want to acknowledge this
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>,
so we don’t get interrupted again until the next millisecond
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">                	<span class="c1">// Reset the interrupt</span>
                	<span class="o">*</span><span class="n">_buspic</span> <span class="o">=</span> <span class="n">BUSPIC_BUSTIMER</span><span class="p">;</span>
                <span class="err">}</span></code></pre></figure>

<p>Our last step is to <a href="https://en.wikipedia.org/wiki/Context_switch">swap tasks</a>.
This is done in three parts.  The first part copies the
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">user mode registers</a>
into the <code class="language-plaintext highlighter-rouge">task_context</code> memory.  In this case, since we’ve kept a
pointer to our <code class="language-plaintext highlighter-rouge">current</code> task context this is fairly straightforward.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">                <span class="c1">// Swap tasks</span>
                <span class="n">zip_save_context</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span></code></pre></figure>

<p>The second step is to decide which task to call next.  This is often called
“CPU scheduling” or “task scheduling”, and many articles have been written
on this topic.  We’ll just keep it simple here and move to the “next” task in
our list.  In hind sight, it might’ve been easier to maintain a current
<code class="language-plaintext highlighter-rouge">task_id</code> index as well, but I’ll leave that to you to do.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NTASKS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                                <span class="n">current</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tasks</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">NTASKS</span><span class="p">)</span><span class="o">?</span><span class="mi">0</span><span class="o">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
                                <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                <span class="p">}</span></code></pre></figure>

<p>The final step in a
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a>
is to restore the registers from the new “current” task
back into the user register set.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">                <span class="n">zip_restore_context</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
        <span class="err">}</span>
<span class="err">}</span></code></pre></figure>

<p><a href="https://en.wikipedia.org/wiki/Context_switch">Task swapping</a> like this is more
often an assembly function, and so these two builtin-function calls simply
implement what would be those assembly instructions.  They are easily
identifiable from the <a href="/about/zipcpu.html">ZipCPU</a>
disassembly since these are the only instructions that will reference the
<a href="/zipcpu/2018/01/01/zipcpu-isa.html"><code class="language-plaintext highlighter-rouge">uR</code> register set</a>.  If
you are really interested in actually seeing their
definition, you can <a href="https://github.com/ZipCPU/zipcpu/blob/752bcc9485609f1f094100719262a7c2d386d6b7/sw/gcc-zippatch.patch">find it in the GCC ZipCPU
patchset</a>.  <a href="https://github.com/ZipCPU/zipcpu/blob/752bcc9485609f1f094100719262a7c2d386d6b7/sw/gcc-zippatch.patch#L10099-L10148">Here it is for saving the
context</a>, and <a href="https://github.com/ZipCPU/zipcpu/blob/752bcc9485609f1f094100719262a7c2d386d6b7/sw/gcc-zippatch.patch#L10149-L10193">here again for
restoring the context</a>.
The function basically works by reading four registers from either
memory or the user register set, then writing them to the user register set
or memory.  Indeed, the function is little more than a memory copy.</p>

<p>That leaves us with only one loose end to return to: the <code class="language-plaintext highlighter-rouge">panic()</code> function.</p>

<p>The purpose of this function is just to tell us that something has gone
wrong, and we need to do some debugging. It also helps us start that
process by helping us identify which problem has taken place.  I mean,
we’re writing a blinky function therefore it should be obvious if there’s
a problem–the LEDs won’t blink like they should.  But how to start debugging
next?</p>

<ol>
  <li>
    <p>We’ve chosen to set certain LEDs to indicate we are in supervisor mode
(interrupts disabled), and others to indicate we are in user mode (interrupts
enabled).</p>

    <p>This supervisor mode indicator LEDs should blink so fast that they appear
to be lit dimly.  If they ever turn off, or start shining brightly,
then we can therefore identify which mode we were in when the
<a href="/about/zipcpu.html">CPU</a> stopped.</p>
  </li>
  <li>
    <p>The purpose of the <code class="language-plaintext highlighter-rouge">panic()</code> function is to help us diagnose what happened
to a broken subtask.  In this case, if we just stop the LEDs from blinking,
we might not be able to tell the difference from a CPU freeze above.</p>

    <p>Therefore we’ll blink all of our LEDs, either all on or all off together,
to indicate a user exception took place.</p>
  </li>
</ol>

<p>This particular implementation of <code class="language-plaintext highlighter-rouge">panic()</code> uses a <a href="https://github.com/ZipCPU/arrowzip/blob/195b77dc144d6ed7d4280f506c35b2204f13908c/rtl/arrowzip/main.v#L888-L894">system power-up
counter</a>.
This counter increases on every system clock, starting at power up, until
the top bit is set.  Once the top bit is set, the power up counter keeps
that bit set and becomes a rolling 31-bit counter with the other bits.</p>

<p>We can grab bit 28 of this counter as an indication that we need to change
the LEDs.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>    <span class="nf">panic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>     <span class="n">v</span><span class="p">;</span>
		<span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">_pwrcount</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">;</span>
		<span class="n">v</span> <span class="o">&amp;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span>
			<span class="o">*</span><span class="n">_spio</span> <span class="o">=</span> <span class="mh">0x0ffff</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">_spio</span> <span class="o">=</span> <span class="mh">0x0ff00</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>While we could’ve used the
<a href="/zipcpu/2018/04/17/ziptimer.html">timer</a> for this,
understand that we are in a <code class="language-plaintext highlighter-rouge">panic()</code> situation.  We want to leave the
<a href="/about/zipcpu.html">CPU</a> state as un-changed as possible
so that we can diagnose whatever fault took place.  In particular, we’ll want
to leave the user register set untouched.  We also don’t know if the
fault was associated with interrupt processing or task swapping or something
else.  For all of these reasons, this code is has been kept as simple as
possible.</p>

<p>Another thing we could’ve done in this <code class="language-plaintext highlighter-rouge">panic()</code> routine would’ve been to
issue a simulation <code class="language-plaintext highlighter-rouge">NHALT</code> (hardware NOOP) instruction to halt any simulator
at the fault itself.  By turning tracing on and then running the simulator
like this, it’s fairly easy to figure out what went wrong.  (Easy, perhaps,
but still pretty intense–examining a trace is not trivial.)  Alternatively,
we could’ve triggered any CPU-focused <a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone
Scope</a>.
This is typically how I debug the CPU if a bug makes it to hardware and the
user register set doesn’t tell me enough to know the cause of any fault.</p>

<h2 id="video">Video</h2>

<p>Want to see how we did?  Check out the video below.</p>

<table align="center" style="float: none"><caption>Fig 12. The LED's blink!  Multitasking at work</caption><tr><td><video width="480" height="360" controls=""><source src="/img/multithreaded-blinky/iled-video.mp4" type="video/mp4" /></video></td></tr></table>

<p>In this video you’ll see a MAX-1000 board with 8-LED’s.  Half of the
LEDs are toggling at rates of 1Hz, 2Hz, 3Hz, and 5Hz.  These are the far left
LED, and every other LED to the right.  The other four LEDs are shining dimly,
indicating that the
<a href="/about/zipcpu.html">CPU</a>
truly is handling
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>s
and
<a href="https://en.wikipedia.org/wiki/Context_switch">swapping tasks</a>
as desired.</p>

<h2 id="conclusions">Conclusions</h2>

<p>Since we’ve already covered both <a href="/blog/2017/05/19/blinky.html">how to make an LED blink from
Verilog</a>,
<a href="/zipcpu/2019/02/09/cpu-blinky.html">as well as from C</a>,
it only made sense that we’d discuss how to blink an LED in some
more advanced fashions–such as by using an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
or from a multi-tasking program.</p>

<p>While blinking an LED might seem like an exceptionally trivial task, let’s
consider what we’ve learned: We learned how easy it was to blink an LED
from Verilog.  Even synchronizing multiple blinking LEDs to within a clock
period was fairly easy.  Blinking an LED on a CPU has the advantage that
it doesn’t typically take (much) more logic resources–but only after you’ve
already paid for the CPU, it’s boot code, it’s bootloader, memory, the
<a href="/zipcpu/2017/11/07/wb-formal.html">system bus</a> and the
<a href="/blog/2019/07/17/crossbar.html">interconnect/crossbar</a>
used to hold everything together.</p>

<p>Of course, this would be more valuable if we were doing something more than
just blinking an LED.  Still, we’ve demonstrated how to build an
<a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>
driven task, as well as how to split the CPU’s time across
multiple independent task contexts,
by using an <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a> to tell us
when to
<a href="https://en.wikipedia.org/wiki/Context_switch">switch contexts</a>.
Both of these capabilities are very powerful and can be used outside
of a simple LED context.</p>

<p>Where the CPU starts to have an advantage over the FPGA fabric is where
you need something to perform complex sequencing operations–such as
performing a complicated startup script, or performing a complex script
periodically.  Depending on the complexity of the task, adding it to what
a CPU is already doing might be cheaper than performing it in the fabric
of the FPGA.  At the same time, adding a CPU to an FPGA just to blink an
LED is truly overkill.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For my thoughts are not your thoughts, neither are your ways my ways, saith the LORD.  For as the heavens are higher than the earth, so are my ways higher than your ways, and my thoughts than your thoughts.  (Is 55:8-9)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
