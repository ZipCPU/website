<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building Formal Assumptions to Describe Wishbone Behaviour</title>
  <meta name="description" content="No part of any system is as critical as thebus that connects all of thecomponents together.  One misbehaving peripheral, or one tyrannical master,and thebusc...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2017/11/07/wb-formal.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building Formal Assumptions to Describe Wishbone Behaviour</h1>
    <p class="post-meta"><time datetime="2017-11-07T00:00:00-05:00" itemprop="datePublished">Nov 7, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>No part of any system is as critical as the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> that connects all of the
components together.  One misbehaving peripheral, or one tyrannical master,
and the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
can be locked up until the next power cycle or internal reset.</p>

<p>Making matters worse is the fact that it is very difficult to create a test
bench for every possible
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interaction.  Questions like, what happens if the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
request is abandoned, what happens if there’s a reset in the middle of the
request, what happens if … are all things that are difficult to capture
with a test bench.  This is simply due to the fundamental limitation of
test benches: they prove one path through your code, but not all paths
through your code.  From my own experience, test benches prove the “normal” path
through the code, whereas the formal methods will check for validity even
in the presence of abnormal things taking place.</p>

<p>As a result,
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interactions are ideal candidates for <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>.
Doing so, though, requires
<a href="/blog/2017/10/19/formal-intro.html">formal rules</a>
defining how the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interaction <em>must</em> take place–rules which, if a peripheral or
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master fails to follow, will cause the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
to fail in some fashion.</p>

<p>Generating those rules for the <a href="/doc/wbspec_b4.pdf">Wishbone
bus</a> will be our task today.
Specifically, we’ll be looking at the <a href="/doc/wbspec_b4.pdf">B4 version of the Wishbone
specification</a>,
and the pipeline form of interaction within
<a href="/doc/wbspec_b4.pdf">it</a>.
Our presentation will start with a discussion of how the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
operates in general, and then a quick comparison between the
<a href="/doc/wbspec_b4.pdf">B4</a>
and <a href="http://opencores.org/cdn/downloads/wbspec_b3.pdf">B3</a>
versions of the Wishbone specification.  We’ll then mention two other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
and point out some of the differences between the
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
and these other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>.
Finally, we’ll present a list of
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
properties that can be used to verify the functionality of
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a> master.</p>

<h2 id="how-wishbone-works">How Wishbone Works</h2>

<p>If you are not familiar with how a
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
works, it is perhaps one of the simpler
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
implementations out there.
Here on <a href="https://zipcpu.com/">this blog</a>
we’ve already discussed <a href="/zipcpu/2017/05/29/simple-wishbone.html">how to build a Wishbone
slave</a>.  We’ve
even walked through <a href="/blog/2017/06/08/simple-wb-master.html">how to build a Wishbone bus
master</a>, and a basic
<a href="/blog/2017/06/22/simple-wb-interconnect.html">Wishbone
interconnect</a>
as part of our <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus
implementation</a> series.</p>

<table style="float: right"><caption>Fig 1: A Wishbone has two channels</caption><tr><td><img src="/img/bus-wb-channels.svg" alt="Two channels in a Wishbone bus" width="420" /></td></tr></table>

<p>From a high level standpoint, the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
supports two channels of
information: a request channel which can be used to request either a read
or a write, and an acknowledgement channel which acknowledges the
transaction.  Further, while the request channel can be stalled at the slave’s
request, the response channel cannot.</p>

<p>In order to dig in further, we’ll choose to examine the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
from the perspective of the master.  That means we’ll use the terms
given in Fig 2 for our <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
components:</p>

<table style="float: left; padding: 15px"><caption>Fig 2: Wishbone Bus terms</caption><tr><td><img src="/img/bus-wb-terms.svg" alt="Wishbone logic names" width="480" /></td></tr></table>

<p>This name translation is mostly about conforming to <a href="/about/gisselquist-technology.html">Gisselquist
Technology</a>’s
strict naming conventions: inputs begin with <code class="language-plaintext highlighter-rouge">i_</code>, outputs with <code class="language-plaintext highlighter-rouge">o_</code>,
in/outs with <code class="language-plaintext highlighter-rouge">io_</code>.  After that, I group all of the wires associated
with a particular interface together, and hence the <code class="language-plaintext highlighter-rouge">_wb_</code>.  For those
components I’ve worked on with two Wishbone interfaces, such as <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v">this delay by
one clock IP
component</a>,
I’ll give the other <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
another name such as <code class="language-plaintext highlighter-rouge">_dly_</code> for the delayed
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.  Later on in this
post, I may reference bus wires by the specification name but drop the <code class="language-plaintext highlighter-rouge">_O</code>
or <code class="language-plaintext highlighter-rouge">_I</code> suffix when it is clear what I am referencing.</p>

<p>By way of an introduction, let’s walk through a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
request, such as the one shown in Fig 3.</p>

<table style="float: left"><caption>Fig 3: A single Wishbone bus request</caption><tr><td><img src="/img/prefetch.svg" alt="The trace for a single Wishbone bus request, as drawn from the ZipCPU prefetch" width="420" /></td></tr></table>

<p>This example is drawn from the single-instruction
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">prefetch</a>.
That particular <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">prefetch
module</a>
is the simplest of the four prefetch modules the
<a href="/about/zipcpu.html">ZipCPU</a>
supports, in that it only handles a single request at a time–perfect
for an introductory discussion!</p>

<p>So, let’s walk through the steps in this request.</p>

<ol>
  <li>
    <p>The
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
starts out idle.  This idle is defined by <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> and <code class="language-plaintext highlighter-rouge">o_wb_stb</code>
both being low.</p>

    <p>While the bus is idle, none of the other signals are relevant–save that
the <a href="/doc/wbspec_b4.pdf">specification</a> insists that
the <code class="language-plaintext highlighter-rouge">ACK</code> line be low.</p>
  </li>
  <li>
    <p>When the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master chooses to start a transaction, it raises the
<code class="language-plaintext highlighter-rouge">o_wb_cyc</code> line.  On the same clock, the master places a request on the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
This means that the <code class="language-plaintext highlighter-rouge">o_wb_stb</code> is raised and the address is placed on
<code class="language-plaintext highlighter-rouge">o_wb_addr.</code> Since this is a read request, <code class="language-plaintext highlighter-rouge">o_wb_we</code> is held low.</p>

    <p>Had this been a write request, <code class="language-plaintext highlighter-rouge">o_wb_we</code> would’ve been raised, the data
to be written would be placed on <code class="language-plaintext highlighter-rouge">o_wb_data</code>, and <code class="language-plaintext highlighter-rouge">o_wb_sel</code> would be
filled out with one bit per byte in <code class="language-plaintext highlighter-rouge">o_wb_data</code> indicating which bytes
are actually going to be written.</p>
  </li>
  <li>
    <p>From here we move to the slave.  The slave has the opportunity to tell the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master that it’s not (yet) ready to receive the request.  It
does this by holding the <code class="language-plaintext highlighter-rouge">i_wb_stall</code> line high.  As soon as
<code class="language-plaintext highlighter-rouge">o_wb_stb</code> is true and <code class="language-plaintext highlighter-rouge">i_wb_stall</code> is false, the request has been
accepted.</p>

    <p>There are many reasons why a slave might not be ready to receive a request,
but most of the ones I’ve dealt with surround either the slave being busy
with its initialization sequence or processing another interaction.
For example, the <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM
controller</a>
for the
<a href="https://github.com/ZipCPU/xulalx25soc">XuLA-LX25 SoC project</a> requires
over 20k clocks to start up.  Once started, it can only transmit 16-bits
to or from the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
at a time.  For this reason, after startup, the <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM
controller</a>
needs to stall the bus during every other incoming transaction so as to
allow <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">the SDRAM
controller</a>
time to send (or receive) both 16-bit halves of any 32-bit transaction.</p>
  </li>
  <li>
    <p>Once the master has made its request of the slave, it
drops <code class="language-plaintext highlighter-rouge">o_wb_stb</code> on the first clock after <code class="language-plaintext highlighter-rouge">(o_wb_stb)&amp;&amp;(!i_wb_stall)</code>,
since at this point it knows that the slave has received its request.</p>
  </li>
  <li>
    <p>When the slave’s response is ready, the slave will raise the <code class="language-plaintext highlighter-rouge">i_wb_ack</code>
line and places the data that’s been read (if this were a response to a read
request) onto the <code class="language-plaintext highlighter-rouge">i_wb_data</code> line.</p>
  </li>
  <li>
    <p>When the master sees the <code class="language-plaintext highlighter-rouge">i_wb_ack</code> high, it ends the request by dropping
the <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> line and the transfer is complete.</p>
  </li>
</ol>

<p>Simple, no?
Let’s try another example.</p>

<table style="float: left"><caption>Fig 4: A pair of Wishbone bus requests</caption><tr><td><img src="/img/dblfetch-ram.svg" alt="The trace for a pair of Wishbone bus requests, as drawn from the ZipCPU prefetch named dblfetch" width="420" /></td></tr></table>

<p>Fig 4 shows an example, drawn from the
<a href="/about/zipcpu.html">ZipCPU</a>’s <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">dblfetch
module</a>.
This is another one of the
<a href="/about/zipcpu.html">ZipCPU</a>’s prefetch modules, with the
difference being that this one makes two back to back requests of the slave.</p>

<p>This example starts out just like the last example.  However, once into
the example, there are some differences.</p>

<ol>
  <li>
    <p>Instead of dropping <code class="language-plaintext highlighter-rouge">o_wb_stb</code> after the first time
<code class="language-plaintext highlighter-rouge">(o_wb_stb)&amp;&amp;(!i_wb_stall)</code>, the master leaves <code class="language-plaintext highlighter-rouge">o_wb_stb</code> high and
initiates a second request.  A new address is placed into <code class="language-plaintext highlighter-rouge">o_wb_addr</code> for
this second request as well.  Only after the second time
<code class="language-plaintext highlighter-rouge">(o_wb_stb)&amp;&amp;(!i_wb_stall)</code> is true does <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">this
master</a>
release the <code class="language-plaintext highlighter-rouge">o_wb_stb</code> line, having now finished making both requests.</p>

    <p>Since this example is being drawn from a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">prefetch</a>
module, the <code class="language-plaintext highlighter-rouge">o_wb_we</code> line
is kept low.  Had this been a write request to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
<code class="language-plaintext highlighter-rouge">o_wb_we</code> would’ve been kept high for this second request, and
<code class="language-plaintext highlighter-rouge">o_wb_data</code> and <code class="language-plaintext highlighter-rouge">o_wb_sel</code> would’ve been set as appropriate for a second
write request.</p>
  </li>
  <li>
    <p>The slave now response with two clocks with <code class="language-plaintext highlighter-rouge">i_wb_ack</code> high.  The first
time <code class="language-plaintext highlighter-rouge">i_wb_ack</code> is high, <code class="language-plaintext highlighter-rouge">i_wb_data</code> is set to the result of reading the
first address request.  On the second <code class="language-plaintext highlighter-rouge">i_wb_ack</code>, <code class="language-plaintext highlighter-rouge">i_wb_data</code> contains
the results of reading from the second address.</p>

    <p>It’s worth noting here that the two acknowledgements do not need to come
back to back.  On slower peripherals they may be separated by one or more
clocks.</p>

    <p>Also, had the request been a write request instead of a read request,
everything would be the same at this step except that the <code class="language-plaintext highlighter-rouge">o_wb_data</code>
information would’ve been relevant when <code class="language-plaintext highlighter-rouge">(o_wb_stb)&amp;&amp;(!i_wb_stall)</code> while
the <code class="language-plaintext highlighter-rouge">i_wb_data</code> returned information would’ve been ignored.</p>
  </li>
  <li>
    <p>Once <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">the
master</a>
has received the responses from both requests, as evidenced
by the second <code class="language-plaintext highlighter-rouge">i_wb_ack</code> being returned, it ends the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle by lowering <code class="language-plaintext highlighter-rouge">o_wb_cyc</code>.  Once done, the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
becomes idle again.</p>
  </li>
</ol>

<p>That’s really all there is to it.  The whole of this is really quite simple.</p>

<p>Or is it?  Once I started trying to
<a href="/blog/2017/10/19/formal-intro.html">formally prove</a>
that a master and a slave were properly “behaving”, the formal solver started
to find more and more cases of interest.  For example,</p>

<ol>
  <li>
    <p>What happens when the master drops the <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> line mid-request?</p>
  </li>
  <li>
    <p>What happens when the slave never responds?</p>
  </li>
  <li>
    <p>What happens when the master wishes to change the request mid-cycle?</p>
  </li>
</ol>

<p>All of these are questions that will need to be answered in order to develop
a list of
<a href="/blog/2017/10/19/formal-intro.html">formal</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">Wishbone
properties</a>
to describe this interaction.</p>

<h2 id="wishbone-classic">Wishbone Classic</h2>

<p>The <a href="/doc/wbspec_b4.pdf">Wishbone specification</a>
also defines another type of interaction, this one
known as “Wishbone classic”.  It is defined in both the
<a href="/doc/wbspec_b4.pdf">Wishbone B4</a> version of the standard,
as well as the original
<a href="http://opencores.org/cdn/downloads/wbspec_b3.pdf">Wishbone B3</a>
version.</p>

<p>When using the Wishbone classic version of the
<a href="/doc/wbspec_b4.pdf">specification</a>,
the master is required to wait until the slave acknowledges the request
before it can start a new request, as shown in Fig 5 below.</p>

<table align="center" style="float: none"><caption>Fig 5: Wishbone Classic</caption><tr><td><img src="/img/wb-classic.svg" alt="Wishbone classic trace of four requests" width="680" /></td></tr></table>

<p>Unlike the pipelined version of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
found in
<a href="/doc/wbspec_b4.pdf">Wishbone B4</a>, there are no stall
or strobe lines in the classic mode.  Instead, the lack of an acknowledgement
acts as a stall request.</p>

<table style="float: right"><caption>Fig 6: Wishbone Pipeline</caption><tr><td><img src="/img/wb-pipeline.svg" alt="Wishbone pipeline trace of four requests" width="360" /></td></tr></table>

<p>The unfortunate consequence of this
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
implementation is that it takes
a <em>minimum</em> of three clocks per transaction.  To illustrate this difference,
compare Fig 5 above to Fig 6 at the right showing a
<a href="/doc/wbspec_b4.pdf">Wishbone</a> <em>pipeline</em>
interaction.  The pipeline mode can issue and receive the return from
one request per clock.</p>

<p>Hence, the best case classic performance is <code class="language-plaintext highlighter-rouge">N</code> transactions in <code class="language-plaintext highlighter-rouge">3N</code> clocks,
whereas for the pipeline mode you can achieve <code class="language-plaintext highlighter-rouge">N</code> transactions in <code class="language-plaintext highlighter-rouge">N+1</code> clocks.</p>

<p>The problem is compounded when you add circuit timing into the mix, since the
classic mode makes it very difficult to place synchronous/clocked components,
such as routers,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v">arbiters</a>,
or <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v">delays</a>,
between the master and slave without slowing down the overall system clock
speed–not just the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
throughput.</p>

<p>The author(s) of the
<a href="http://opencores.org/cdn/downloads/wbspec_b3.pdf">Wishbone B3 specification</a>
recognized this problem and so they offered a means of
extending the classic mode.  They extended Wishbone classic with
tag lines, both input and output, that can be optionally included with the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Chief among these extra lines are the <em>cycle type indicator</em> or <code class="language-plaintext highlighter-rouge">CTI</code>,
and the <em>burst length indicator</em>.  Using these extra lines allows components
to interact from one side of a design to another.  For example, a slave can
start issuing <code class="language-plaintext highlighter-rouge">ACK</code> after <code class="language-plaintext highlighter-rouge">ACK</code> without waiting for new requests if it knows
that further requests will be coming and that they will have incrementing
addresses.</p>

<p>Understanding all of these other wires and indicators can add additional
complexity to a <a href="/doc/wbspec_b4.pdf">Wishbone</a> master.
For example, the master now needs to know which slaves support these
extra request wires and transaction types and which do not.  Likewise, the
any router or
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v">arbiter</a>
will need to know when these wires are relevant and when they are not, and
how shall they know this unless they decode all this extra logic?</p>

<p>All of these are reasons the
<a href="/about/zipcpu.html">ZipCPU</a>
uses the
<a href="/doc/wbspec_b4.pdf">Wishbone B4</a>
pipeline standard: it creates a single, efficient
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction standard.  If
all of the peripherals follow this same standard, then the
<a href="/about/zipcpu.html">ZipCPU</a> (or any other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master)
doesn’t need to keep track of which components interact in one fashion of the
interface and which interact in another, and slave’s don’t need to worry about
whether or not the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master will be sending additional requests or not–until
they are ready to see if an additional request is incoming.</p>

<h2 id="whats-missing-an-abort-capability">What’s missing: an Abort Capability</h2>

<p>There are two situations missing from the
<a href="/doc/wbspec_b4.pdf">Wishbone standard</a>
that will need definition before we can discuss
<a href="/blog/2017/10/19/formal-intro.html">formally proving</a>
that a master or a slave conforms to the standard.  The first is how a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
is handled, and the second is how a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction may be aborted.</p>

<p>We’ll start with
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.
There are several possible causes of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
The most obvious one is an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
generated by the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
when the given address doesn’t reference a
known slave.  Some slaves, notably those that contain
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
within them but not exclusively, may also generate
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.
Further, on those
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
where security protections are in place, a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
may be generated by a security fault.  The question is, how shall a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
be handled?</p>

<table style="float: right"><caption>Fig 7: Possible return signals</caption><tr><td><img src="/img/wb-return.svg" alt="Waveform diagram illustrating how all Wishbone requests result in either an ACK, RTY, or ERR return signal" width="288" /></td></tr></table>

<p>The <a href="/doc/wbspec_b4.pdf">Wishbone specification</a>
states only that the response from a slave shall
either be an acknowledgement, a retry, or an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
signal–never more than one
of these three for any transaction.  An example of this concept is shown
in Fig 7.  Fig 7 shows two transaction requests, the first ending in an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
and the second in an acknowledgement.</p>

<p>The problem with this approach is that an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
indicates that a problem has or is taking place.  It isn’t immediately clear
how a successful transaction might follow one that is in
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
As a result, the acknowledgement following an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
doesn’t really make sense.  Instead, the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction really needs to be immediately terminated.</p>

<table style="float: left; padding: 15px"><caption>Fig 8: A different approach to Wishbone bus errors</caption><tr><td><img src="/img/wb-return-err.svg" alt="Waveform diagram illustrating how an error should abort a transaction" width="288" /></td></tr></table>

<p>For this reason, I recommend that any time <code class="language-plaintext highlighter-rouge">i_wb_err</code> goes high, it should
remain high until the end of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle when <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> drops, as illustrated in Fig 8.
Further, to minimize the uncertainty associated with which transactions are
complete and which ones ended in an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
the stall line should be raised
together with <code class="language-plaintext highlighter-rouge">i_wb_err</code> and also held high until <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> is dropped.</p>

<p>Alternatively, the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction may be <em>aborted</em> following an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
But how?  The <a href="/doc/wbspec_b4.pdf">Wishbone spec</a> doesn’t
discuss aborting transactions that have already been issued.</p>

<p>Perhaps it may not seem all that important to implement a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort.  This is not the case at all.  Two particular cases come to mind where a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort might be very useful.  The first is the case of a misbehaving peripheral.
Should a peripheral misbehave and not return an acknowledgement, it would
make sense to have a timeout following which the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction would be aborted.  The second case is that of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master that is given a warm reset
signal, while the rest of the items on the bus are not reset.  An example of
this might be the
<a href="/about/zipcpu.html">ZipCPU</a>
needing to abort an ongoing
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA</a>
transaction.  A third case, albeit a simple one, is that it would make sense
to abort a transaction following a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
as we discussed above.</p>

<table style="float: right"><caption>Fig 9: Wishbone Abort</caption><tr><td><img src="/img/wb-abort.svg" alt="A trace showing a Wishbone transaction being aborted" width="360" /></td></tr></table>

<p>For the purpose of our
<a href="/blog/2017/10/19/formal-intro.html">formal</a> development
below, we’ll simply adopt the standard that any
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
transaction may be aborted by dropping the <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> line, as shown in Fig 9.</p>

<p>In this figure, four
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction requests are issued, two acknowledgements
are received, and then the master aborts the transaction.  Let’s just dig
into this idea a little deeper.</p>

<p>We’ll start with the simple: those transactions that have been acknowledged
prior to the abort (i.e.  the dropping of <code class="language-plaintext highlighter-rouge">o_wb_cyc</code>), will have been
completed.  In Fig 9, transactions <code class="language-plaintext highlighter-rouge">A0</code> and <code class="language-plaintext highlighter-rouge">A1</code> have completed.
All other outstanding requests have been left in an uncertain state: they
may or may not have been completed.</p>

<p>Further, since the <code class="language-plaintext highlighter-rouge">i_wb_ack</code> line is registered, <code class="language-plaintext highlighter-rouge">A2</code>’s acknowledgement still
comes back–just on the clock after <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> is dropped.  This acknowledgement
is the result of clocked logic: it cannot be canceled until a clock after the
abort.  However, the master knows nothing about the <code class="language-plaintext highlighter-rouge">A2</code> request being
completed–since the return took place after the <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> line was
dropped and the transaction aborted.  Likewise, the <code class="language-plaintext highlighter-rouge">A3</code> transaction may
or may not have been completed, but the master received no feedback regarding
these transactions as a result.</p>

<p>Since the standard really doesn’t discuss how
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>
<em>should</em> be handled, nor
does it describe how to deal with the case where <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> is dropped
mid-transaction, one might argue that these two capabilities are not <em>changes</em>
in <a href="/doc/wbspec_b4.pdf">the specification</a>, but rather just
<em>clarifications</em> of it.</p>

<h2 id="other-bus-standards">Other bus standards</h2>

<p>Two other common
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
standards warrant some quick comments: the <a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon
bus</a> and the
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>.</p>

<table style="float: right"><caption>Fig 10: Avalon bus has two basic channels, like the Wishbone</caption><tr><td><img src="/img/bus-avalon-channels.svg" alt="The Avalon Bus has separate read/write channels" width="420" /></td></tr></table>

<p>Of these two, the
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon bus</a>
is the closest to the
<a href="/doc/wbspec_b4.pdf">Wishbone B4</a>
pipeline
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
in its definition.  Indeed, some of the wires, such as the
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon</a>
<code class="language-plaintext highlighter-rouge">waitrequest</code> and the <a href="/doc/wbspec_b4.pdf">Wishbone</a>
<code class="language-plaintext highlighter-rouge">stall</code> lines, are virtually identical.  The chief differences from a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
translation standpoint, however, are:</p>

<ol>
  <li>
    <p>The <a href="/doc/wbspec_b4.pdf">Wishbone bus</a> has a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle line, <code class="language-plaintext highlighter-rouge">o_wb_cyc</code>, whereas the
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon bus</a>
does not.  This cycle line delimits when a particular transaction begins and
ends.  It is especially useful for <a href="https://github.com/ZipCPU/zipcpu/master/master/rtl/ex/wbpriarbiter.v">bus
arbiters</a>
that need to
know when they can switch a slave from being connected to one
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master to another.</p>
  </li>
  <li>
    <p>The <a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon
specification</a>
requires acknowledgements that distinguish between read and write
transactions.  Whereas the <a href="/doc/wbspec_b4.pdf">Wishbone</a>’s
<code class="language-plaintext highlighter-rouge">i_wb_ack</code> line indicates a valid response from a slave for either read or
write, the <a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon
specification</a>
requires either a <code class="language-plaintext highlighter-rouge">readdatavalid</code> or a <code class="language-plaintext highlighter-rouge">writeresponsevalid</code> from the slave
for every transaction.</p>
  </li>
</ol>

<p>The <a href="https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf">Avalon specification</a> also defines support
for burst or block interactions, much like the part of the
<a href="/doc/wbspec_b4.pdf">Wishbone B4 specification</a>
that the <a href="/about/zipcpu.html">ZipCPU</a>
has never needed.</p>

<table style="float: left"><caption>Fig 11: The AXI4 bus requires five independent channels</caption><tr><td><img src="/img/bus-axi-channels.svg" alt="Illustration, showing the five separate channels of the AXI4 bus" width="420" /></td></tr></table>

<p>The other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
in common usage today is the
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AMBA AXI4 bus</a>.
This bus appears to have every feature a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
could have.  First, the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
has not one, not two, but <em>five</em> separate channels associated with it, each of
which can be individually stalled, as illustrated in Fig 11.  These channels
are: a read address channel, a read data channel, a write address channel,
a write data channel, and a write acknowledgement channel.  Second, the
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>
can (optionally) return items out of order–and so
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
requests need to be given identifiers so they can properly be reordered
(or routed) upon return.  The
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>
also maintains the concept of a burst, so that the address <em>channel</em> can
announce a burst of some length, and the logic implementing the associated data
channel then needs to count items and their responses in order to support it.
There’s more too: “last” transaction indicators, privilege violations,
multiple types of
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
codes, cacheable transaction attributes, and more.
Unlike the simple <a href="/doc/wbspec_b4.pdf">Wishbone bus</a> outlined
here, the <a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>
is <em>much more complicated</em>–really more so than it needs to be in my humble
opinion.</p>

<p>One good thing about having both read and write channels, though, is that an
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4</a>
based <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> doesn’t
need intermediate memory: it can read directly from one channel while writing
to another—assuming it’s not reading from and writing to the same peripheral,
such as memory.</p>

<p>Yes, there is a simplified version of the
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a> that’s often called
AXI-lite.  While it can be much simpler to build a component slave
that responds to the AXI-lite protocol, certain features still make it more
difficult to work with than the other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
discussed above.  As an example, the
write request is issued across two channels, the write address and write
data channels, even though most slaves need these pieces of information on
the same clock cycle in order to work with them.  (The official solution
to this problem is to have the slave to stall the address line until both
address and data are available.)  A second difficult piece of complexity is
that, AXI-Lite requires a hand-shake on the return path, or <code class="language-plaintext highlighter-rouge">ACK</code> path, as
well as the request path.  Internally, this means is that an AXI peripheral
needs to be aware of stalls on this return path and either buffer any
responses within some form of FIFO, or stall the request path.</p>

<p>If you are interested in reading further on this topic, consider comparing
the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">logic necessary to bridge</a>
from the <a href="/doc/wbspec_b4.pdf">Wishbone bus</a>,
to an
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>,
or <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axim2wbsp.v">viceversa</a>.
Neither IP component is simple.</p>

<p>My point here is specifically this: if you are a hobbyist working from a
limited budget, then it doesn’t really make sense to implement a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
that requires lots of logic per
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> master or
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
slave peripheral, rather than
implementing a simple <a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
interface across all masters and peripherals.</p>

<h2 id="further-simplifying-the-wishbone">Further Simplifying the Wishbone</h2>

<p>For anyone who has followed the
<a href="/about/zipcpu.html">ZipCPU</a>’s
development, you’ll know that I have been trying to keep the logic required
for any <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interaction simple.  Why?  Simple because
<a href="/blog/2017/06/12/minimizing-luts.html">logic costs money</a>.
As such, I’ve simplified the
<a href="/doc/wbspec_b4.pdf">Wishbone</a> signals that the
<a href="/about/zipcpu.html">ZipCPU</a> issues,
and that its peripherals respond to.</p>

<ol>
  <li>
    <p>Everything I have created to interact with the
<a href="/about/zipcpu.html">ZipCPU</a> does so in
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
pipeline mode <em>only</em>.  It’s both simpler and faster than the classic mode.</p>
  </li>
  <li>
    <p>There are no retry signals nor tag signals.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">CYC</code> signal is equivalent to the <code class="language-plaintext highlighter-rouge">LOCK</code> signal.  Once the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
grants a master access of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
based upon the <code class="language-plaintext highlighter-rouge">CYC</code> line, that master owns the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
until the <code class="language-plaintext highlighter-rouge">CYC</code> line is dropped.</p>
  </li>
  <li>
    <p>Slaves do not create
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>, the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
does.</p>

    <p>I haven’t found a need for a slave to produce a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.
ROM’s, for example, can quietly acknowledge write’s without performing any
action.  The consequence of this is merely that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master interacting with a particular peripheral is responsible for
interacting with that peripheral appropriately.</p>
  </li>
  <li>
    <p>CYC may not be held indefinitely.</p>

    <p>Although <a href="/doc/wbspec_b4.pdf">the specification</a>
explicitly allows a master to hold the <code class="language-plaintext highlighter-rouge">CYC</code> line high
indefinitely, doing so would prevent a second master from ever accessing
the same
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Hence, <code class="language-plaintext highlighter-rouge">CYC</code> needs to be dropped as soon as the transaction is
complete–assuming that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
isn’t being held open as part of a condition requiring a lock.</p>
  </li>
</ol>

<p>These rules are now sufficient enough that we can write a formal description
of a <a href="/doc/wbspec_b4.pdf">Wishbone bus</a>, one that we can then
use to formally verify a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master (or slaves) functionality.</p>

<h2 id="the-formal-rules">The Formal Rules</h2>

<p>To capture all of this <a href="/doc/wbspec_b4.pdf">Wishbone</a>
functionality, let’s create a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal Verilog
module</a>
containing only assumptions and assertions together with any other logic
necessary to express those assumptions or assertions.  The goal of
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">this module</a>
will be such that, if dropped into a
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
master IP component, this <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal properties
module</a>
can then be used to verify that the master’s interaction with the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
is done properly.  (Other application specific properties may
still be required.)</p>

<p>You can find a copy of <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">this module
here</a>,
should you wish to follow along in the discussion below.</p>

<p>The first thing to note about
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">this module</a>
are the ports.  <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">This
module</a>
contains all the ports necessary for a full
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interface, whether master or slave, together with the traditional clock and
(synchronous) reset ports.  In order to keep the state of the
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
transaction, as viewed by the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master, in sync with the state as seen by any other <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal
properties</a>
within the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master, three additional signals are in this port list
as well.  These are the count of the number of requests that have been made,
the number of acknowledgements received, and the number of outstanding
transactions.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">fwb_master</span><span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="n">i_reset</span><span class="p">,</span>
		<span class="c1">// The Wishbone bus</span>
		<span class="n">i_wb_cyc</span><span class="p">,</span> <span class="n">i_wb_stb</span><span class="p">,</span> <span class="n">i_wb_we</span><span class="p">,</span> <span class="n">i_wb_addr</span><span class="p">,</span> <span class="n">i_wb_data</span><span class="p">,</span> <span class="n">i_wb_sel</span><span class="p">,</span>
			<span class="n">i_wb_ack</span><span class="p">,</span> <span class="n">i_wb_stall</span><span class="p">,</span> <span class="n">i_wb_idata</span><span class="p">,</span> <span class="n">i_wb_err</span><span class="p">,</span>
		<span class="n">f_nreqs</span><span class="p">,</span> <span class="n">f_nacks</span><span class="p">,</span> <span class="n">f_outstanding</span><span class="p">);</span></code></pre></figure>

<p>A parameter, <code class="language-plaintext highlighter-rouge">F_LGDEPTH</code>, controls the number of bits in these last three
signals.</p>

<p>Internal to the module, we’ll create a helper variable, <code class="language-plaintext highlighter-rouge">f_request</code>, to contain
all the details of any
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
transaction request.  We’ll come back to this and use it later.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">STB_BIT</span> <span class="o">=</span> <span class="mi">2</span><span class="o">+</span><span class="n">AW</span><span class="o">+</span><span class="n">DW</span><span class="o">+</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="n">STB_BIT</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_request</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">f_request</span> <span class="o">=</span> <span class="o">{</span> <span class="n">i_wb_stb</span><span class="p">,</span> <span class="n">i_wb_we</span><span class="p">,</span> <span class="n">i_wb_addr</span><span class="p">,</span> <span class="n">i_wb_data</span><span class="p">,</span> <span class="n">i_wb_sel</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>With these two parts aside, we can turn our attention to the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal
properties</a>
associated with creating
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transactions.</p>

<p>The first property to assert will be that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
is initialized in a reset condition–no requests are being made, and the
reset line is high.  Further, we’ll assume that the <code class="language-plaintext highlighter-rouge">ACK</code> and <code class="language-plaintext highlighter-rouge">ERR</code> lines
are also low upon startup.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Assume we start from a reset condition</span>
	<span class="k">initial</span> <span class="k">assert</span><span class="p">(</span><span class="n">i_reset</span><span class="p">);</span>
	<span class="k">initial</span> <span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">);</span>
	<span class="k">initial</span> <span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stb</span><span class="p">);</span>
	<span class="c1">//</span>
	<span class="k">initial</span>	<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_ack</span><span class="p">);</span>
	<span class="k">initial</span>	<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_err</span><span class="p">);</span></code></pre></figure>

<p>In general, we’ll <em>assume</em> that any <em>inputs</em> to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master obey the master’s formal properties below, while <em>asserting</em> that
any of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master’s <em>outputs</em> follow their properties.  A similar <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_slave.v">companion
module</a>,
appropriate for a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
slave, will <em>assume</em> the <em>inputs</em> to the bus slave from the master and
<em>assert</em> the outputs of a bus slave–but that’s not the perspective we’ll
be using below.</p>

<p>We also assert, on the clock following any <code class="language-plaintext highlighter-rouge">i_reset</code> request, that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
has returned to this same idle state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stb</span><span class="p">);</span>
		<span class="c1">//</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_ack</span><span class="p">);</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_err</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Further, we’ll insist that all signals coming into or out of our <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal
property
module</a>
can <em>only</em> change on the positive edge of the clock.  Everything,
whether input or output, must be synchronous with the clock.  (A later upgrade
might be to create an asynchronous reset signal.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_clk</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_reset</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">f_request</span><span class="p">));</span> <span class="c1">// The entire request should be stable</span>
		<span class="c1">//</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_ack</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_stall</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_idata</span><span class="p">));</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_err</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>Now let’s work through the basics of creating a transaction request.</p>

<p>First, as we discussed above, we’ll insist that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master drop the <code class="language-plaintext highlighter-rouge">CYC</code> line following any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> signal.
This will abort any ongoing transaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_err</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">);</span></code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a>
isn’t very clear about what can happen to the <code class="language-plaintext highlighter-rouge">STB</code> line
when <code class="language-plaintext highlighter-rouge">CYC</code> is low.  Indeed, it is somewhat contradictory.  However, if we
insist that <code class="language-plaintext highlighter-rouge">STB</code> can <em>only</em> be high when <code class="language-plaintext highlighter-rouge">CYC</code> is also high, then it
simplifies the slave’s logic–as I discussed at
<a href="https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf.pdf">ORCONF 2016</a>.
Since this logic is usually easy to guarantee within the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master–requiring no extra logic cost, we’ll insist upon it as a
formal property here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">);</span></code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a> is silent regarding
whether or not the bus request has any meaning while the <code class="language-plaintext highlighter-rouge">STALL</code> line is high.
However, some slaves need to peek at the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
to know how to handle the next transaction.
For these slaves, we insist that once a request is placed onto the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
it cannot be changed until it is accepted.  Hence, if a request has been made
but the stall line remains high, then that same request must not change
on the next clock cycle–at least not until either an abort or the request
is accepted.</p>

<p>The exception is that, on a read, the request data lines are don’t cares.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stall</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">i_wb_we</span>   <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">i_wb_addr</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_addr</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">i_wb_sel</span>  <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_sel</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_we</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">i_wb_data</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_data</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a> says nothing about
whether read and write requests can be mixed or not.  However, I am not
familiar of any situation where that makes any sense.  Therefore, we’ll
specifically prohibit the <code class="language-plaintext highlighter-rouge">WE</code> (write enable) line from changing between
one request and the next.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">))</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">i_wb_we</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">));</span></code></pre></figure>

<p>To go one step further, we’ll insist that the <code class="language-plaintext highlighter-rouge">WE</code> only change when there are
no outstanding requests–such as in a “read-modify-write” cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Within any given bus cycle, the direction may *only* change when</span>
	<span class="c1">// there are no further outstanding requests.</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">i_wb_we</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">));</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">SEL</code> (byte select) line(s) are an indication of which bytes within a word
should be written to the device.  To be meaningful, any write transaction
should assert one or more of these bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">|</span><span class="n">i_wb_sel</span><span class="p">);</span></code></pre></figure>

<p>From here, let’s move on to the lines returned from the slave–primarily the
<code class="language-plaintext highlighter-rouge">ACK</code> and <code class="language-plaintext highlighter-rouge">ERR</code> lines.</p>

<p>We’ll start by insisting that these two signals should never
be asserted unless the master is in the middle of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle and <code class="language-plaintext highlighter-rouge">CYC</code> is high.</p>

<p>The one exception to this rule is in the case of an abort, where <code class="language-plaintext highlighter-rouge">CYC</code> goes
low before the slave has a chance to respond.  Thus, if <code class="language-plaintext highlighter-rouge">CYC</code> was low
(i.e. no <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle and no abort), then both <code class="language-plaintext highlighter-rouge">ACK</code> and <code class="language-plaintext highlighter-rouge">ERR</code> should be low on the next clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_ack</span><span class="p">);</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_err</span><span class="p">);</span>
		<span class="c1">// ...</span>
	<span class="k">end</span></code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a>
makes it clear that both <code class="language-plaintext highlighter-rouge">ACK</code> and <code class="language-plaintext highlighter-rouge">ERR</code> signals may
never be true on the same clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">((</span><span class="o">!</span><span class="n">i_wb_ack</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_err</span><span class="p">));</span></code></pre></figure>

<p>The next two properties get into counting.  They have to deal with how
long a slave can take to accept a request, and how long the slave can take
to respond to the request once accepted.  Both are predicated upon some
parameterized number of counts.  If the respective count parameter is non-zero,
then the time limit property is applied.</p>

<p>For the first property, we’ll assume that the slave can only stall the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
for <code class="language-plaintext highlighter-rouge">F_MAX_STALL</code> counts–no more.  The purpose of this is just to
help to limit the search space for the formal verifier.  It is optional and
not strictly necessary, but you may find it to be useful.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_MAX_STALL</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">MXSTALL</span>
		<span class="c1">// ...</span>
		<span class="kt">reg</span>	<span class="p">[(</span><span class="n">DLYBITS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">f_stall_count</span><span class="p">;</span>

		<span class="k">initial</span>	<span class="n">f_stall_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_stall</span><span class="p">))</span>
				<span class="n">f_stall_count</span> <span class="o">&lt;=</span> <span class="n">f_stall_count</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">f_stall_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">)</span>
				<span class="k">assume</span><span class="p">(</span><span class="n">f_stall_count</span> <span class="o">&lt;</span> <span class="n">F_MAX_STALL</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>The next optional property is the number of cycles to wait until the next
acknowledgement is received.  If <code class="language-plaintext highlighter-rouge">F_MAX_ACK_DELAY</code> is greater than zero,
these cycles will be counted and an assumption will limit this count so that
there are always this many or fewer cycles between acknowledgements.  The
rule, though, is that we don’t need to count this delay if nothing is pending.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_MAX_ACK_DELAY</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">MXWAIT</span>
		<span class="kt">reg</span>	<span class="p">[(</span><span class="n">DLYBITS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">f_ackwait_count</span><span class="p">;</span>

		<span class="k">initial</span>	<span class="n">f_ackwait_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stb</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_err</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">f_ackwait_count</span> <span class="o">&lt;=</span> <span class="n">f_ackwait_count</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">f_ackwait_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stb</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_ack</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_err</span><span class="p">)</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">assume</span><span class="p">(</span><span class="n">f_ackwait_count</span> <span class="o">&lt;</span> <span class="n">F_MAX_ACK_DELAY</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>When I initially started proving bus properties, these two parameters,
<code class="language-plaintext highlighter-rouge">F_MAX_STALL</code> and <code class="language-plaintext highlighter-rouge">F_MAX_ACK_DELAY</code> were very important for limiting how many
states the formal solver needed to examine.  In hind sight, I think the
three output ports can remove the need for these two properties–but I’ve left
these checks in place for the time being.</p>

<p>We still need two more counters.  The first, <code class="language-plaintext highlighter-rouge">f_nreqs</code>, will count the number
of requests that have been made and accepted by the slave, while the second,
<code class="language-plaintext highlighter-rouge">f_nacks</code>, will count the number of acknowledgements returned.  Both of these
counters will be returned to our parent module as outputs of this module.</p>

<p>The number of requests accepted starts at zero, and returns to zero
upon any reset or the end of any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle.  While the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle is active, this number will accumulate any time the <code class="language-plaintext highlighter-rouge">STB</code> is true
and the <code class="language-plaintext highlighter-rouge">STALL</code> signal is not–the indication that a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction request has been made.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_nreqs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">))</span>
		<span class="n">f_nreqs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stall</span><span class="p">))</span>
		<span class="n">f_nreqs</span> <span class="o">&lt;=</span> <span class="n">f_nreqs</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">f_nacks</code> counter is almost identical to the <code class="language-plaintext highlighter-rouge">f_nreqs</code> counter, save that
the number of acknowledgements increments any time <code class="language-plaintext highlighter-rouge">i_wb_ack</code> or <code class="language-plaintext highlighter-rouge">i_wb_err</code>
is true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_nacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">f_nacks</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">)</span>
		<span class="n">f_nacks</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_wb_ack</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_wb_err</span><span class="p">))</span>
		<span class="n">f_nacks</span> <span class="o">&lt;=</span> <span class="n">f_nacks</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>The difference between the number of requests and the number of
acknowledgements is the number of outstanding requests.  Since <code class="language-plaintext highlighter-rouge">f_nreqs</code>
and <code class="language-plaintext highlighter-rouge">f_nacks</code> are both
registered, we avoid a second delay here by not registering <code class="language-plaintext highlighter-rouge">f_outstanding</code>.
The result, though, is that we may need to trim it suddenly to zero anytime
<code class="language-plaintext highlighter-rouge">i_wb_cyc</code> is dropped.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">f_outstanding</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">f_nreqs</span> <span class="o">-</span> <span class="n">f_nacks</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Some <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
masters are known to only ever request a fixed number of values on
any transaction.  For example, the
<a href="/about/zipcpu.html">ZipCPU</a>
has a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">prefetch
module</a>
that will only ever request one item from the bus, a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">dblfetch
module</a>
that will only ever request two items, and a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">pfcache
module</a>
that will always request exactly one cache line.</p>

<p>For these masters, the <code class="language-plaintext highlighter-rouge">F_MAX_REQUESTS</code> parameter can be used to limit the
formal proof and force this maximum request limit.
If the <code class="language-plaintext highlighter-rouge">F_MAX_REQUESTS</code> variable has been set to a value greater than zero,
then we insist that the number of requests and the number of acknowledgements
are always both less than this value.  This assertion is set into two parts.
First, if <code class="language-plaintext highlighter-rouge">STB</code> is on then a new request is pending so the number
of requests must be less than <code class="language-plaintext highlighter-rouge">F_MAX_REQUESTS</code>.  Second, if <code class="language-plaintext highlighter-rouge">STB</code> is false,
then the full number of requests may have been issued.  Further, we’ll also
insist that the number of outstanding requests remains one less than
<code class="language-plaintext highlighter-rouge">(1&lt;&lt;F_LGDEPTH)</code>, where <code class="language-plaintext highlighter-rouge">F_LGDEPTH</code> is the number of bits in our counters.
This guarantees that <code class="language-plaintext highlighter-rouge">f_outstanding</code> will never roll over.  It also requires,
however, that the log, based two, of the maximum number of outstanding
transactions must be passed to our core in <code class="language-plaintext highlighter-rouge">F_LGDEPTH</code>.</p>

<p>If <code class="language-plaintext highlighter-rouge">F_MAX_REQUESTS</code> is not specified, we’ll assume that the number of
outstanding requests is not allowed to roll over the maximum value and
back to zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">F_MAX_REQUESTS</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">f_nreqs</span> <span class="o">&lt;</span> <span class="n">F_MAX_REQUESTS</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">f_nreqs</span> <span class="o">&lt;=</span> <span class="n">F_MAX_REQUESTS</span><span class="p">);</span>
			<span class="k">assume</span><span class="p">(</span><span class="n">f_nacks</span> <span class="o">&lt;=</span> <span class="n">f_nreqs</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">F_LGDEPTH</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">end</span> <span class="k">else</span>
			<span class="k">assume</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">F_LGDEPTH</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a>
makes it very clear that there shall only be one acknowledgement (at most)
per request.  To capture this requirement, we simply insist within our formal
proof that if there are no outstanding requests, then there shall be no
incoming acknowledgements.  The same goes for
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>
as well: there can be no error, nor any acknowledgement, without
first receiving a request.</p>

<p>One update since I first wrote this article is that the error or
acknowledgement can be asserted on the same clock that <code class="language-plaintext highlighter-rouge">(STB)&amp;&amp;(!STALL)</code>
is true.  There need not be a one-cycle delay from request to
acknowledgement.  The following logic captures this requirement if
<code class="language-plaintext highlighter-rouge">F_OPT_MINCLOCK_DELAY</code> is false, as well as the requirement of
no responses from the bus without a request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_cyc</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">begin</span>
			<span class="c1">// If nothing is outstanding, then there should be</span>
			<span class="c1">// no acknowledgements ... however, an acknowledgement</span>
			<span class="c1">// *can* come back on the same clock as the stb is</span>
			<span class="c1">// going out.</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">F_OPT_MINCLOCK_DELAY</span><span class="p">)</span>
			<span class="k">begin</span>
				<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_ack</span><span class="p">);</span>
				<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_err</span><span class="p">);</span>
			<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
				<span class="k">assume</span><span class="p">((</span><span class="o">!</span><span class="n">i_wb_ack</span><span class="p">)</span><span class="o">||</span><span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stall</span><span class="p">)));</span>
				<span class="c1">// The same is true of errors.  They may not be</span>
				<span class="c1">// created before the request gets through</span>
				<span class="k">assume</span><span class="p">((</span><span class="o">!</span><span class="n">i_wb_err</span><span class="p">)</span><span class="o">||</span><span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stall</span><span class="p">)));</span>
			<span class="k">end</span>
		<span class="k">end</span></code></pre></figure>

<p>Here we switch from requirements for all
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
masters to the first of several optional properties.  These options are
controlled by parameters to the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal master properties
module</a>.
The options insist upon properties not required by the protocol, but which may
be worth asserting for some masters.  As such, they are convenience properties
only, and therefore default to not being part of the test.</p>

<p>The first of these is the source option.  If a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master is the <em>source</em> of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
request, as opposed to being an
<a href="https://en.wikipedia.org/wiki/Arbiter_(electronics)#Bus_arbiter">arbiter</a>
or adapter mid stream, then the request should start with both <code class="language-plaintext highlighter-rouge">CYC</code> and
<code class="language-plaintext highlighter-rouge">STB</code> lines going high together.  Since the
<a href="/doc/wbspec_b4.pdf">specification</a>
doesn’t require this, we list it here as optional.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_OPT_SOURCE</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">SRC</span>
		<span class="c1">// ...</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">))</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">F_OPT_SOURCE</code> is a master only parameter option, however.  By the time a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interaction gets to the slave, the <code class="language-plaintext highlighter-rouge">CYC</code> line may go high or low without
actually affecting the <code class="language-plaintext highlighter-rouge">STB</code> line of the slave.</p>

<p>The next option is the read-modify-write option, <code class="language-plaintext highlighter-rouge">F_OPT_RMW_BUS_OPTION</code>.  If
this option is not set, the master must drop the <code class="language-plaintext highlighter-rouge">CYC</code> line following the last
acknowledgement.</p>

<p>This doesn’t apply, though, to those
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
that may wish to hold the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
open (locked) between two transactions–such as a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> requesting an
<a href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)">atomic</a>
increment operation.  For these masters, the option should be left on.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">F_OPT_RMW_BUS_OPTION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">F_OPT_RMW_BUS_OPTION</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// ...</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">f_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">assert</span><span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">));</span>
		<span class="c1">// ...</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>In many ways, the master doesn’t care what happens on the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
return
lines if the cycle line is low or if there’s no acknowledgement coming back,
so restricting these wires to known values makes a lot of sense.  This is the
purpose of the <code class="language-plaintext highlighter-rouge">F_OPT_SHORT_CIRCUIT_PROOF</code> option.  If set, it helps to limit
the formal search space and thus it is intended to make the proof simpler.</p>

<p>On the other hand, if something within the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master <em>does</em> depend upon these values (when it shouldn’t), then we might want
to know about it.  For this reason, the option default is not to short circuit
the slave’s responses.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">F_OPT_SHORT_CIRCUIT_PROOF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_OPT_SHORT_CIRCUIT_PROOF</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_wb_cyc</span><span class="p">)</span>
			<span class="k">begin</span>
				<span class="n">restrict</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stall</span><span class="p">);</span>
				<span class="n">restrict</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_idata</span><span class="p">));</span>
			<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_ack</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_ack</span><span class="p">))</span>
				<span class="n">restrict</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_wb_idata</span><span class="p">));</span>
		<span class="k">end</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>While not all masters are likely to make discontinuous requests, some might.
Therefore, we allow an option, <code class="language-plaintext highlighter-rouge">F_OPT_DISCONTINUOUS</code>, that can be set to
allow discontinuous requests.  If this option is not set, then once the
<code class="language-plaintext highlighter-rouge">STB</code> line is dropped, we’ll insist that it cannot be raised again without
also dropping the <code class="language-plaintext highlighter-rouge">CYC</code> line.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_OPT_DISCONTINUOUS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="k">generate</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">F_OPT_DISCONTINUOUS</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">F_OPT_RMW_BUS_OPTION</span><span class="p">))</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">INSIST_ON_NO_DISCONTINUOUS_STBS</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_cyc</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)))</span>
				<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_wb_stb</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">endgenerate</span>

<span class="k">endmodule</span></code></pre></figure>

<p>Since any master that implements a “read-modify-write” cycle will need to
raise the <code class="language-plaintext highlighter-rouge">STB</code> line after it has been initially dropped,
the generate above attempts to capture these conditions.</p>

<p>Put together, any <a href="/doc/wbspec_b4.pdf">Wishbone</a> master
core, having the properties listed above, is guaranteed to interact properly
with a <a href="/doc/wbspec_b4.pdf">Wishbone B4</a>, pipelined
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This post has been written following the lessons I’ve learned making
formal proofs for the
<a href="/about/zipcpu.html">ZipCPU</a>
prefetch modules
[<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">1</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">2</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">3</a>].  I’ve
also now tested other interactions with these properties, such as those of a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v">priority
arbiter</a>
or those of a
Wishbone
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v">bus delay</a>
component, and I’ve adjusted many of these components with the lessons
I’ve learned in this process.  As a result, we may yet come back to this topic
of formally verifying a <a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
master, but now that we’ve presented the basics any following posts will
reflect how these basics are applied to particular application-specific
situations.</p>

<p>Until then, here’s a fun thought: on a <a href="http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;No=1046">recent application</a>
I have been working on, I had the option of using an
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon bus</a>.
Since all of my tools are (so far) written for the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>,
I needed to either rebuild my tools, or to build a bridge to cross from
the one to the other.  Every transaction needed to go through this bridge,
so it is a very critical component of this design.
<a href="/blog/2017/10/19/formal-intro.html">Formal methods</a>,
such as the ones we’ve discussed today, have given me confidence, even
before placing this bridge onto actual hardware, that it will work in
practice when I do.</p>

<p>At some point, I may switch from this
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon</a>
to
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
bridge to an
<a href="https://github.com/ZipCPU/wb2axisp">AXI to Wishbone bridge</a> I built some
time ago, but I haven’t quite finished the proof of that component (yet).</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Every word of God is pure: he is a shield unto them that put their trust in him. (Prov 30:5)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
