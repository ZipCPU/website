<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building Formal Assumptions to Describe Wishbone Behaviour</title>
  <meta name="description" content="No part of any system is as critical as thebus that connects all of thecomponents together.  One misbehaving peripheral, or one tyrannical master,and thebusc...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2017/11/07/wb-formal.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building Formal Assumptions to Describe Wishbone Behaviour</h1>
    <p class="post-meta"><time datetime="2017-11-07T00:00:00-05:00" itemprop="datePublished">Nov 7, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>No part of any system is as critical as the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> that connects all of the
components together.  One misbehaving peripheral, or one tyrannical master,
and the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
can be locked up until the next power cycle or internal reset.</p>

<p>Making matters worse is the fact that it is very difficult to create a test
bench for every possible
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interaction.  Questions like, what happens if the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
request is abandoned, what happens if there’s a reset in the middle of the
request, what happens if … are all things that are difficult to capture
with a test bench.  This is simply due to the fundamental limitation of
test benches: they prove one path through your code, but not all paths
through your code.  From my own experience, test benches prove the “normal” path
through the code, whereas the formal methods will check for validity even
in the presence of abnormal things taking place.</p>

<p>As a result,
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interactions are ideal candidates for <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>.
Doing so, though, requires
<a href="/blog/2017/10/19/formal-intro.html">formal rules</a>
defining how the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interaction <em>must</em> take place–rules which, if a peripheral or
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master fails to follow, will cause the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
to fail in some fashion.</p>

<p>Generating those rules for the <a href="/doc/wbspec_b4.pdf">Wishbone
bus</a> will be our task today.
Specifically, we’ll be looking at the <a href="/doc/wbspec_b4.pdf">B4 version of the Wishbone
specification</a>,
and the pipeline form of interaction within
<a href="/doc/wbspec_b4.pdf">it</a>.
Our presentation will start with a discussion of how the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
operates in general, and then a quick comparison between the
<a href="/doc/wbspec_b4.pdf">B4</a>
and <a href="http://opencores.org/cdn/downloads/wbspec_b3.pdf">B3</a>
versions of the Wishbone specification.  We’ll then mention two other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
and point out some of the differences between the
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
and these other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>.
Finally, we’ll present a list of
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
properties that can be used to verify the functionality of
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a> master.</p>

<h2 id="how-wishbone-works">How Wishbone Works</h2>

<p>If you are not familiar with how a
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
works, it is perhaps one of the simpler
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
implementations out there.
Here on <a href="https://zipcpu.com/">this blog</a>
we’ve already discussed <a href="/zipcpu/2017/05/29/simple-wishbone.html">how to build a Wishbone
slave</a>.  We’ve
even walked through <a href="/blog/2017/06/08/simple-wb-master.html">how to build a Wishbone bus
master</a>, and a basic
<a href="/blog/2017/06/22/simple-wb-interconnect.html">Wishbone
interconnect</a>
as part of our <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus
implementation</a> series.</p>

<table style="float: right"><caption>Fig 1: A Wishbone has two channels</caption><tr><td><img src="/img/bus-wb-channels.svg" alt="Two channels in a Wishbone bus" width="420" /></td></tr></table>

<p>From a high level standpoint, the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
supports two channels of
information: a request channel which can be used to request either a read
or a write, and an acknowledgement channel which acknowledges the
transaction.  Further, while the request channel can be stalled at the slave’s
request, the response channel cannot.</p>

<p>In order to dig in further, we’ll choose to examine the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
from the perspective of the master.  That means we’ll use the terms
given in Fig 2 for our <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
components:</p>

<table style="float: left; padding: 15px"><caption>Fig 2: Wishbone Bus terms</caption><tr><td><img src="/img/bus-wb-terms.svg" alt="Wishbone logic names" width="480" /></td></tr></table>

<p>This name translation is mostly about conforming to <a href="/about/gisselquist-technology.html">Gisselquist
Technology</a>’s
strict naming conventions: inputs begin with <code class="highlighter-rouge">i_</code>, outputs with <code class="highlighter-rouge">o_</code>,
in/outs with <code class="highlighter-rouge">io_</code>.  After that, I group all of the wires associated
with a particular interface together, and hence the <code class="highlighter-rouge">_wb_</code>.  For those
components I’ve worked on with two Wishbone interfaces, such as <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v">this delay by
one clock IP
component</a>,
I’ll give the other <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
another name such as <code class="highlighter-rouge">_dly_</code> for the delayed
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.  Later on in this
post, I may reference bus wires by the specification name but drop the <code class="highlighter-rouge">_O</code>
or <code class="highlighter-rouge">_I</code> suffix when it is clear what I am referencing.</p>

<p>By way of an introduction, let’s walk through a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
request, such as the one shown in Fig 3.</p>

<table style="float: left"><caption>Fig 3: A single Wishbone bus request</caption><tr><td><img src="/img/prefetch.svg" alt="The trace for a single Wishbone bus request, as drawn from the ZipCPU prefetch" width="420" /></td></tr></table>

<p>This example is drawn from the single-instruction
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">prefetch</a>.
That particular <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">prefetch
module</a>
is the simplest of the four prefetch modules the
<a href="/about/zipcpu.html">ZipCPU</a>
supports, in that it only handles a single request at a time–perfect
for an introductory discussion!</p>

<p>So, let’s walk through the steps in this request.</p>

<ol>
  <li>
    <p>The
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
starts out idle.  This idle is defined by <code class="highlighter-rouge">o_wb_cyc</code> and <code class="highlighter-rouge">o_wb_stb</code>
both being low.</p>

    <p>While the bus is idle, none of the other signals are relevant–save that
the <a href="/doc/wbspec_b4.pdf">specification</a> insists that
the <code class="highlighter-rouge">ACK</code> line be low.</p>
  </li>
  <li>
    <p>When the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master chooses to start a transaction, it raises the
<code class="highlighter-rouge">o_wb_cyc</code> line.  On the same clock, the master places a request on the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
This means that the <code class="highlighter-rouge">o_wb_stb</code> is raised and the address is placed on
<code class="highlighter-rouge">o_wb_addr.</code> Since this is a read request, <code class="highlighter-rouge">o_wb_we</code> is held low.</p>

    <p>Had this been a write request, <code class="highlighter-rouge">o_wb_we</code> would’ve been raised, the data
to be written would be placed on <code class="highlighter-rouge">o_wb_data</code>, and <code class="highlighter-rouge">o_wb_sel</code> would be
filled out with one bit per byte in <code class="highlighter-rouge">o_wb_data</code> indicating which bytes
are actually going to be written.</p>
  </li>
  <li>
    <p>From here we move to the slave.  The slave has the opportunity to tell the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master that it’s not (yet) ready to receive the request.  It
does this by holding the <code class="highlighter-rouge">i_wb_stall</code> line high.  As soon as
<code class="highlighter-rouge">o_wb_stb</code> is true and <code class="highlighter-rouge">i_wb_stall</code> is false, the request has been
accepted.</p>

    <p>There are many reasons why a slave might not be ready to receive a request,
but most of the ones I’ve dealt with surround either the slave being busy
with its initialization sequence or processing another interaction.
For example, the <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM
controller</a>
for the
<a href="https://github.com/ZipCPU/xulalx25soc">XuLA-LX25 SoC project</a> requires
over 20k clocks to start up.  Once started, it can only transmit 16-bits
to or from the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
at a time.  For this reason, after startup, the <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM
controller</a>
needs to stall the bus during every other incoming transaction so as to
allow <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">the SDRAM
controller</a>
time to send (or receive) both 16-bit halves of any 32-bit transaction.</p>
  </li>
  <li>
    <p>Once the master has made its request of the slave, it
drops <code class="highlighter-rouge">o_wb_stb</code> on the first clock after <code class="highlighter-rouge">(o_wb_stb)&amp;&amp;(!i_wb_stall)</code>,
since at this point it knows that the slave has received its request.</p>
  </li>
  <li>
    <p>When the slave’s response is ready, the slave will raise the <code class="highlighter-rouge">i_wb_ack</code>
line and places the data that’s been read (if this were a response to a read
request) onto the <code class="highlighter-rouge">i_wb_data</code> line.</p>
  </li>
  <li>
    <p>When the master sees the <code class="highlighter-rouge">i_wb_ack</code> high, it ends the request by dropping
the <code class="highlighter-rouge">o_wb_cyc</code> line and the transfer is complete.</p>
  </li>
</ol>

<p>Simple, no?
Let’s try another example.</p>

<table style="float: left"><caption>Fig 4: A pair of Wishbone bus requests</caption><tr><td><img src="/img/dblfetch-ram.svg" alt="The trace for a pair of Wishbone bus requests, as drawn from the ZipCPU prefetch named dblfetch" width="420" /></td></tr></table>

<p>Fig 4 shows an example, drawn from the
<a href="/about/zipcpu.html">ZipCPU</a>’s <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">dblfetch
module</a>.
This is another one of the
<a href="/about/zipcpu.html">ZipCPU</a>’s prefetch modules, with the
difference being that this one makes two back to back requests of the slave.</p>

<p>This example starts out just like the last example.  However, once into
the example, there are some differences.</p>

<ol>
  <li>
    <p>Instead of dropping <code class="highlighter-rouge">o_wb_stb</code> after the first time
<code class="highlighter-rouge">(o_wb_stb)&amp;&amp;(!i_wb_stall)</code>, the master leaves <code class="highlighter-rouge">o_wb_stb</code> high and
initiates a second request.  A new address is placed into <code class="highlighter-rouge">o_wb_addr</code> for
this second request as well.  Only after the second time
<code class="highlighter-rouge">(o_wb_stb)&amp;&amp;(!i_wb_stall)</code> is true does <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">this
master</a>
release the <code class="highlighter-rouge">o_wb_stb</code> line, having now finished making both requests.</p>

    <p>Since this example is being drawn from a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">prefetch</a>
module, the <code class="highlighter-rouge">o_wb_we</code> line
is kept low.  Had this been a write request to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
<code class="highlighter-rouge">o_wb_we</code> would’ve been kept high for this second request, and
<code class="highlighter-rouge">o_wb_data</code> and <code class="highlighter-rouge">o_wb_sel</code> would’ve been set as appropriate for a second
write request.</p>
  </li>
  <li>
    <p>The slave now response with two clocks with <code class="highlighter-rouge">i_wb_ack</code> high.  The first
time <code class="highlighter-rouge">i_wb_ack</code> is high, <code class="highlighter-rouge">i_wb_data</code> is set to the result of reading the
first address request.  On the second <code class="highlighter-rouge">i_wb_ack</code>, <code class="highlighter-rouge">i_wb_data</code> contains
the results of reading from the second address.</p>

    <p>It’s worth noting here that the two acknowledgements do not need to come
back to back.  On slower peripherals they may be separated by one or more
clocks.</p>

    <p>Also, had the request been a write request instead of a read request,
everything would be the same at this step except that the <code class="highlighter-rouge">o_wb_data</code>
information would’ve been relevant when <code class="highlighter-rouge">(o_wb_stb)&amp;&amp;(!i_wb_stall)</code> while
the <code class="highlighter-rouge">i_wb_data</code> returned information would’ve been ignored.</p>
  </li>
  <li>
    <p>Once <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">the
master</a>
has received the responses from both requests, as evidenced
by the second <code class="highlighter-rouge">i_wb_ack</code> being returned, it ends the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle by lowering <code class="highlighter-rouge">o_wb_cyc</code>.  Once done, the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
becomes idle again.</p>
  </li>
</ol>

<p>That’s really all there is to it.  The whole of this is really quite simple.</p>

<p>Or is it?  Once I started trying to
<a href="/blog/2017/10/19/formal-intro.html">formally prove</a>
that a master and a slave were properly “behaving”, the formal solver started
to find more and more cases of interest.  For example,</p>

<ol>
  <li>
    <p>What happens when the master drops the <code class="highlighter-rouge">o_wb_cyc</code> line mid-request?</p>
  </li>
  <li>
    <p>What happens when the slave never responds?</p>
  </li>
  <li>
    <p>What happens when the master wishes to change the request mid-cycle?</p>
  </li>
</ol>

<p>All of these are questions that will need to be answered in order to develop
a list of
<a href="/blog/2017/10/19/formal-intro.html">formal</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">Wishbone
properties</a>
to describe this interaction.</p>

<h2 id="wishbone-classic">Wishbone Classic</h2>

<p>The <a href="/doc/wbspec_b4.pdf">Wishbone specification</a>
also defines another type of interaction, this one
known as “Wishbone classic”.  It is defined in both the
<a href="/doc/wbspec_b4.pdf">Wishbone B4</a> version of the standard,
as well as the original
<a href="http://opencores.org/cdn/downloads/wbspec_b3.pdf">Wishbone B3</a>
version.</p>

<p>When using the Wishbone classic version of the
<a href="/doc/wbspec_b4.pdf">specification</a>,
the master is required to wait until the slave acknowledges the request
before it can start a new request, as shown in Fig 5 below.</p>

<table align="center" style="float: none"><caption>Fig 5: Wishbone Classic</caption><tr><td><img src="/img/wb-classic.svg" alt="Wishbone classic trace of four requests" width="680" /></td></tr></table>

<p>Unlike the pipelined version of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
found in
<a href="/doc/wbspec_b4.pdf">Wishbone B4</a>, there are no stall
or strobe lines in the classic mode.  Instead, the lack of an acknowledgement
acts as a stall request.</p>

<table style="float: right"><caption>Fig 6: Wishbone Pipeline</caption><tr><td><img src="/img/wb-pipeline.svg" alt="Wishbone pipeline trace of four requests" width="360" /></td></tr></table>

<p>The unfortunate consequence of this
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
implementation is that it takes
a <em>minimum</em> of three clocks per transaction.  To illustrate this difference,
compare Fig 5 above to Fig 6 at the right showing a
<a href="/doc/wbspec_b4.pdf">Wishbone</a> <em>pipeline</em>
interaction.  The pipeline mode can issue and receive the return from
one request per clock.</p>

<p>Hence, the best case classic performance is <code class="highlighter-rouge">N</code> transactions in <code class="highlighter-rouge">3N</code> clocks,
whereas for the pipeline mode you can achieve <code class="highlighter-rouge">N</code> transactions in <code class="highlighter-rouge">N+1</code> clocks.</p>

<p>The problem is compounded when you add circuit timing into the mix, since the
classic mode makes it very difficult to place synchronous/clocked components,
such as routers,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v">arbiters</a>,
or <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v">delays</a>,
between the master and slave without slowing down the overall system clock
speed–not just the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
throughput.</p>

<p>The author(s) of the
<a href="http://opencores.org/cdn/downloads/wbspec_b3.pdf">Wishbone B3 specification</a>
recognized this problem and so they offered a means of
extending the classic mode.  They extended Wishbone classic with
tag lines, both input and output, that can be optionally included with the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Chief among these extra lines are the <em>cycle type indicator</em> or <code class="highlighter-rouge">CTI</code>,
and the <em>burst length indicator</em>.  Using these extra lines allows components
to interact from one side of a design to another.  For example, a slave can
start issuing <code class="highlighter-rouge">ACK</code> after <code class="highlighter-rouge">ACK</code> without waiting for new requests if it knows
that further requests will be coming and that they will have incrementing
addresses.</p>

<p>Understanding all of these other wires and indicators can add additional
complexity to a <a href="/doc/wbspec_b4.pdf">Wishbone</a> master.
For example, the master now needs to know which slaves support these
extra request wires and transaction types and which do not.  Likewise, the
any router or
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v">arbiter</a>
will need to know when these wires are relevant and when they are not, and
how shall they know this unless they decode all this extra logic?</p>

<p>All of these are reasons the
<a href="/about/zipcpu.html">ZipCPU</a>
uses the
<a href="/doc/wbspec_b4.pdf">Wishbone B4</a>
pipeline standard: it creates a single, efficient
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction standard.  If
all of the peripherals follow this same standard, then the
<a href="/about/zipcpu.html">ZipCPU</a> (or any other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master)
doesn’t need to keep track of which components interact in one fashion of the
interface and which interact in another, and slave’s don’t need to worry about
whether or not the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master will be sending additional requests or not–until
they are ready to see if an additional request is incoming.</p>

<h2 id="whats-missing-an-abort-capability">What’s missing: an Abort Capability</h2>

<p>There are two situations missing from the
<a href="/doc/wbspec_b4.pdf">Wishbone standard</a>
that will need definition before we can discuss
<a href="/blog/2017/10/19/formal-intro.html">formally proving</a>
that a master or a slave conforms to the standard.  The first is how a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
is handled, and the second is how a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction may be aborted.</p>

<p>We’ll start with
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.
There are several possible causes of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
The most obvious one is an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
generated by the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
when the given address doesn’t reference a
known slave.  Some slaves, notably those that contain
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
within them but not exclusively, may also generate
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.
Further, on those
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
where security protections are in place, a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
may be generated by a security fault.  The question is, how shall a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
be handled?</p>

<table style="float: right"><caption>Fig 7: Possible return signals</caption><tr><td><img src="/img/wb-return.svg" alt="Waveform diagram illustrating how all Wishbone requests result in either an ACK, RTY, or ERR return signal" width="288" /></td></tr></table>

<p>The <a href="/doc/wbspec_b4.pdf">Wishbone specification</a>
states only that the response from a slave shall
either be an acknowledgement, a retry, or an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
signal–never more than one
of these three for any transaction.  An example of this concept is shown
in Fig 7.  Fig 7 shows two transaction requests, the first ending in an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
and the second in an acknowledgement.</p>

<p>The problem with this approach is that an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
indicates that a problem has or is taking place.  It isn’t immediately clear
how a successful transaction might follow one that is in
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
As a result, the acknowledgement following an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
doesn’t really make sense.  Instead, the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction really needs to be immediately terminated.</p>

<table style="float: left; padding: 15px"><caption>Fig 8: A different approach to Wishbone bus errors</caption><tr><td><img src="/img/wb-return-err.svg" alt="Waveform diagram illustrating how an error should abort a transaction" width="288" /></td></tr></table>

<p>For this reason, I recommend that any time <code class="highlighter-rouge">i_wb_err</code> goes high, it should
remain high until the end of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle when <code class="highlighter-rouge">o_wb_cyc</code> drops, as illustrated in Fig 8.
Further, to minimize the uncertainty associated with which transactions are
complete and which ones ended in an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
the stall line should be raised
together with <code class="highlighter-rouge">i_wb_err</code> and also held high until <code class="highlighter-rouge">o_wb_cyc</code> is dropped.</p>

<p>Alternatively, the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction may be <em>aborted</em> following an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
But how?  The <a href="/doc/wbspec_b4.pdf">Wishbone spec</a> doesn’t
discuss aborting transactions that have already been issued.</p>

<p>Perhaps it may not seem all that important to implement a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort.  This is not the case at all.  Two particular cases come to mind where a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort might be very useful.  The first is the case of a misbehaving peripheral.
Should a peripheral misbehave and not return an acknowledgement, it would
make sense to have a timeout following which the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction would be aborted.  The second case is that of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master that is given a warm reset
signal, while the rest of the items on the bus are not reset.  An example of
this might be the
<a href="/about/zipcpu.html">ZipCPU</a>
needing to abort an ongoing
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">DMA</a>
transaction.  A third case, albeit a simple one, is that it would make sense
to abort a transaction following a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
as we discussed above.</p>

<table style="float: right"><caption>Fig 9: Wishbone Abort</caption><tr><td><img src="/img/wb-abort.svg" alt="A trace showing a Wishbone transaction being aborted" width="360" /></td></tr></table>

<p>For the purpose of our
<a href="/blog/2017/10/19/formal-intro.html">formal</a> development
below, we’ll simply adopt the standard that any
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
transaction may be aborted by dropping the <code class="highlighter-rouge">o_wb_cyc</code> line, as shown in Fig 9.</p>

<p>In this figure, four
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction requests are issued, two acknowledgements
are received, and then the master aborts the transaction.  Let’s just dig
into this idea a little deeper.</p>

<p>We’ll start with the simple: those transactions that have been acknowledged
prior to the abort (i.e.  the dropping of <code class="highlighter-rouge">o_wb_cyc</code>), will have been
completed.  In Fig 9, transactions <code class="highlighter-rouge">A0</code> and <code class="highlighter-rouge">A1</code> have completed.
All other outstanding requests have been left in an uncertain state: they
may or may not have been completed.</p>

<p>Further, since the <code class="highlighter-rouge">i_wb_ack</code> line is registered, <code class="highlighter-rouge">A2</code>’s acknowledgement still
comes back–just on the clock after <code class="highlighter-rouge">o_wb_cyc</code> is dropped.  This acknowledgement
is the result of clocked logic: it cannot be canceled until a clock after the
abort.  However, the master knows nothing about the <code class="highlighter-rouge">A2</code> request being
completed–since the return took place after the <code class="highlighter-rouge">o_wb_cyc</code> line was
dropped and the transaction aborted.  Likewise, the <code class="highlighter-rouge">A3</code> transaction may
or may not have been completed, but the master received no feedback regarding
these transactions as a result.</p>

<p>Since the standard really doesn’t discuss how
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>
<em>should</em> be handled, nor
does it describe how to deal with the case where <code class="highlighter-rouge">o_wb_cyc</code> is dropped
mid-transaction, one might argue that these two capabilities are not <em>changes</em>
in <a href="/doc/wbspec_b4.pdf">the specification</a>, but rather just
<em>clarifications</em> of it.</p>

<h2 id="other-bus-standards">Other bus standards</h2>

<p>Two other common
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
standards warrant some quick comments: the <a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon
bus</a> and the
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>.</p>

<table style="float: right"><caption>Fig 10: Avalon bus has two basic channels, like the Wishbone</caption><tr><td><img src="/img/bus-avalon-channels.svg" alt="The Avalon Bus has separate read/write channels" width="420" /></td></tr></table>

<p>Of these two, the
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon bus</a>
is the closest to the
<a href="/doc/wbspec_b4.pdf">Wishbone B4</a>
pipeline
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
in its definition.  Indeed, some of the wires, such as the
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon</a>
<code class="highlighter-rouge">waitrequest</code> and the <a href="/doc/wbspec_b4.pdf">Wishbone</a>
<code class="highlighter-rouge">stall</code> lines, are virtually identical.  The chief differences from a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
translation standpoint, however, are:</p>

<ol>
  <li>
    <p>The <a href="/doc/wbspec_b4.pdf">Wishbone bus</a> has a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle line, <code class="highlighter-rouge">o_wb_cyc</code>, whereas the
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon bus</a>
does not.  This cycle line delimits when a particular transaction begins and
ends.  It is especially useful for <a href="https://github.com/ZipCPU/zipcpu/master/master/rtl/ex/wbpriarbiter.v">bus
arbiters</a>
that need to
know when they can switch a slave from being connected to one
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master to another.</p>
  </li>
  <li>
    <p>The <a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon
specification</a>
requires acknowledgements that distinguish between read and write
transactions.  Whereas the <a href="/doc/wbspec_b4.pdf">Wishbone</a>’s
<code class="highlighter-rouge">i_wb_ack</code> line indicates a valid response from a slave for either read or
write, the <a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon
specification</a>
requires either a <code class="highlighter-rouge">readdatavalid</code> or a <code class="highlighter-rouge">writeresponsevalid</code> from the slave
for every transaction.</p>
  </li>
</ol>

<p>The <a href="https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf">Avalon specification</a> also defines support
for burst or block interactions, much like the part of the
<a href="/doc/wbspec_b4.pdf">Wishbone B4 specification</a>
that the <a href="/about/zipcpu.html">ZipCPU</a>
has never needed.</p>

<table style="float: left"><caption>Fig 11: The AXI4 bus requires five independent channels</caption><tr><td><img src="/img/bus-axi-channels.svg" alt="Illustration, showing the five separate channels of the AXI4 bus" width="420" /></td></tr></table>

<p>The other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
in common usage today is the
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AMBA AXI4 bus</a>.
This bus appears to have every feature a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
could have.  First, the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
has not one, not two, but <em>five</em> separate channels associated with it, each of
which can be individually stalled, as illustrated in Fig 11.  These channels
are: a read address channel, a read data channel, a write address channel,
a write data channel, and a write acknowledgement channel.  Second, the
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>
can (optionally) return items out of order–and so
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
requests need to be given identifiers so they can properly be reordered
(or routed) upon return.  The
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>
also maintains the concept of a burst, so that the address <em>channel</em> can
announce a burst of some length, and the logic implementing the associated data
channel then needs to count items and their responses in order to support it.
There’s more too: “last” transaction indicators, privilege violations,
multiple types of
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
codes, cacheable transaction attributes, and more.
Unlike the simple <a href="/doc/wbspec_b4.pdf">Wishbone bus</a> outlined
here, the <a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>
is <em>much more complicated</em>–really more so than it needs to be in my humble
opinion.</p>

<p>One good thing about having both read and write channels, though, is that an
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4</a>
based <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> doesn’t
need intermediate memory: it can read directly from one channel while writing
to another—assuming it’s not reading from and writing to the same peripheral,
such as memory.</p>

<p>Yes, there is a simplified version of the
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a> that’s often called
AXI-lite.  While it can be much simpler to build a component slave
that responds to the AXI-lite protocol, certain features still make it more
difficult to work with than the other
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
discussed above.  As an example, the
write request is issued across two channels, the write address and write
data channels, even though most slaves need these pieces of information on
the same clock cycle in order to work with them.  (The official solution
to this problem is to have the slave to stall the address line until both
address and data are available.)  A second difficult piece of complexity is
that, AXI-Lite requires a hand-shake on the return path, or <code class="highlighter-rouge">ACK</code> path, as
well as the request path.  Internally, this means is that an AXI peripheral
needs to be aware of stalls on this return path and either buffer any
responses within some form of FIFO, or stall the request path.</p>

<p>If you are interested in reading further on this topic, consider comparing
the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">logic necessary to bridge</a>
from the <a href="/doc/wbspec_b4.pdf">Wishbone bus</a>,
to an
<a href="http://www.gstitt.ece.ufl.edu/courses/fall15/eel4720_5721/labs/refs/AXI4_specification.pdf">AXI4 bus</a>,
or <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axim2wbsp.v">viceversa</a>.
Neither IP component is simple.</p>

<p>My point here is specifically this: if you are a hobbyist working from a
limited budget, then it doesn’t really make sense to implement a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
that requires lots of logic per
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> master or
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
slave peripheral, rather than
implementing a simple <a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
interface across all masters and peripherals.</p>

<h2 id="further-simplifying-the-wishbone">Further Simplifying the Wishbone</h2>

<p>For anyone who has followed the
<a href="/about/zipcpu.html">ZipCPU</a>’s
development, you’ll know that I have been trying to keep the logic required
for any <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interaction simple.  Why?  Simple because
<a href="/blog/2017/06/12/minimizing-luts.html">logic costs money</a>.
As such, I’ve simplified the
<a href="/doc/wbspec_b4.pdf">Wishbone</a> signals that the
<a href="/about/zipcpu.html">ZipCPU</a> issues,
and that its peripherals respond to.</p>

<ol>
  <li>
    <p>Everything I have created to interact with the
<a href="/about/zipcpu.html">ZipCPU</a> does so in
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
pipeline mode <em>only</em>.  It’s both simpler and faster than the classic mode.</p>
  </li>
  <li>
    <p>There are no retry signals nor tag signals.</p>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">CYC</code> signal is equivalent to the <code class="highlighter-rouge">LOCK</code> signal.  Once the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
grants a master access of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
based upon the <code class="highlighter-rouge">CYC</code> line, that master owns the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
until the <code class="highlighter-rouge">CYC</code> line is dropped.</p>
  </li>
  <li>
    <p>Slaves do not create
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>, the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
does.</p>

    <p>I haven’t found a need for a slave to produce a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.
ROM’s, for example, can quietly acknowledge write’s without performing any
action.  The consequence of this is merely that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master interacting with a particular peripheral is responsible for
interacting with that peripheral appropriately.</p>
  </li>
  <li>
    <p>CYC may not be held indefinitely.</p>

    <p>Although <a href="/doc/wbspec_b4.pdf">the specification</a>
explicitly allows a master to hold the <code class="highlighter-rouge">CYC</code> line high
indefinitely, doing so would prevent a second master from ever accessing
the same
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Hence, <code class="highlighter-rouge">CYC</code> needs to be dropped as soon as the transaction is
complete–assuming that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
isn’t being held open as part of a condition requiring a lock.</p>
  </li>
</ol>

<p>These rules are now sufficient enough that we can write a formal description
of a <a href="/doc/wbspec_b4.pdf">Wishbone bus</a>, one that we can then
use to formally verify a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master (or slaves) functionality.</p>

<h2 id="the-formal-rules">The Formal Rules</h2>

<p>To capture all of this <a href="/doc/wbspec_b4.pdf">Wishbone</a>
functionality, let’s create a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal Verilog
module</a>
containing only assumptions and assertions together with any other logic
necessary to express those assumptions or assertions.  The goal of
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">this module</a>
will be such that, if dropped into a
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
master IP component, this <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal properties
module</a>
can then be used to verify that the master’s interaction with the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
is done properly.  (Other application specific properties may
still be required.)</p>

<p>You can find a copy of <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">this module
here</a>,
should you wish to follow along in the discussion below.</p>

<p>The first thing to note about
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">this module</a>
are the ports.  <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">This
module</a>
contains all the ports necessary for a full
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interface, whether master or slave, together with the traditional clock and
(synchronous) reset ports.  In order to keep the state of the
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
transaction, as viewed by the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master, in sync with the state as seen by any other <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal
properties</a>
within the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master, three additional signals are in this port list
as well.  These are the count of the number of requests that have been made,
the number of acknowledgements received, and the number of outstanding
transactions.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">module	fwb_master(i_clk, i_reset,
		// The Wishbone bus
		i_wb_cyc, i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel,
			i_wb_ack, i_wb_stall, i_wb_idata, i_wb_err,
		f_nreqs, f_nacks, f_outstanding);</code></pre></figure>

<p>A parameter, <code class="highlighter-rouge">F_LGDEPTH</code>, controls the number of bits in these last three
signals.</p>

<p>Internal to the module, we’ll create a helper variable, <code class="highlighter-rouge">f_request</code>, to contain
all the details of any
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
transaction request.  We’ll come back to this and use it later.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	localparam	STB_BIT = 2+AW+DW+DW/8-1;
	wire	[STB_BIT:0]	f_request;
	assign	f_request = { i_wb_stb, i_wb_we, i_wb_addr, i_wb_data, i_wb_sel };</code></pre></figure>

<p>With these two parts aside, we can turn our attention to the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal
properties</a>
associated with creating
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transactions.</p>

<p>The first property to assert will be that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
is initialized in a reset condition–no requests are being made, and the
reset line is high.  Further, we’ll assume that the <code class="highlighter-rouge">ACK</code> and <code class="highlighter-rouge">ERR</code> lines
are also low upon startup.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	// Assume we start from a reset condition
	initial assert(i_reset);
	initial assert(!i_wb_cyc);
	initial assert(!i_wb_stb);
	//
	initial	assume(!i_wb_ack);
	initial	assume(!i_wb_err);</code></pre></figure>

<p>In general, we’ll <em>assume</em> that any <em>inputs</em> to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master obey the master’s formal properties below, while <em>asserting</em> that
any of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master’s <em>outputs</em> follow their properties.  A similar <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_slave.v">companion
module</a>,
appropriate for a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
slave, will <em>assume</em> the <em>inputs</em> to the bus slave from the master and
<em>assert</em> the outputs of a bus slave–but that’s not the perspective we’ll
be using below.</p>

<p>We also assert, on the clock following any <code class="highlighter-rouge">i_reset</code> request, that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
has returned to this same idle state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(i_reset)))
	begin
		assert(!i_wb_cyc);
		assert(!i_wb_stb);
		//
		assume(!i_wb_ack);
		assume(!i_wb_err);
	end</code></pre></figure>

<p>Further, we’ll insist that all signals coming into or out of our <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal
property
module</a>
can <em>only</em> change on the positive edge of the clock.  Everything,
whether input or output, must be synchronous with the clock.  (A later upgrade
might be to create an asynchronous reset signal.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @($global_clock)
	if ((f_past_valid)&amp;&amp;(!$rose(i_clk)))
	begin
		assert($stable(i_reset));
		assert($stable(i_wb_cyc));
		assert($stable(f_request)); // The entire request should be stable
		//
		assume($stable(i_wb_ack));
		assume($stable(i_wb_stall));
		assume($stable(i_wb_idata));
		assume($stable(i_wb_err));
	end</code></pre></figure>

<p>Now let’s work through the basics of creating a transaction request.</p>

<p>First, as we discussed above, we’ll insist that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master drop the <code class="highlighter-rouge">CYC</code> line following any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> signal.
This will abort any ongoing transaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;($past(i_wb_err))&amp;&amp;($past(i_wb_cyc)))
		assert(!i_wb_cyc);</code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a>
isn’t very clear about what can happen to the <code class="highlighter-rouge">STB</code> line
when <code class="highlighter-rouge">CYC</code> is low.  Indeed, it is somewhat contradictory.  However, if we
insist that <code class="highlighter-rouge">STB</code> can <em>only</em> be high when <code class="highlighter-rouge">CYC</code> is also high, then it
simplifies the slave’s logic–as I discussed at
<a href="https://github.com/ZipCPU/zipcpu/blob/master/doc/orconf.pdf">ORCONF 2016</a>.
Since this logic is usually easy to guarantee within the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master–requiring no extra logic cost, we’ll insist upon it as a
formal property here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
		if (i_wb_stb)
			assert(i_wb_cyc);</code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a> is silent regarding
whether or not the bus request has any meaning while the <code class="highlighter-rouge">STALL</code> line is high.
However, some slaves need to peek at the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
to know how to handle the next transaction.
For these slaves, we insist that once a request is placed onto the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
it cannot be changed until it is accepted.  Hence, if a request has been made
but the stall line remains high, then that same request must not change
on the next clock cycle–at least not until either an abort or the request
is accepted.</p>

<p>The exception is that, on a read, the request data lines are don’t cares.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(i_reset))&amp;&amp;($past(i_wb_stb))
			&amp;&amp;($past(i_wb_stall))&amp;&amp;(i_wb_cyc))
	begin
		assert(i_wb_stb);
		assert(i_wb_we   == $past(i_wb_we));
		assert(i_wb_addr == $past(i_wb_addr));
		assert(i_wb_sel  == $past(i_wb_sel));
		if (i_wb_we)
			assert(i_wb_data == $past(i_wb_data));
	end</code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a> says nothing about
whether read and write requests can be mixed or not.  However, I am not
familiar of any situation where that makes any sense.  Therefore, we’ll
specifically prohibit the <code class="highlighter-rouge">WE</code> (write enable) line from changing between
one request and the next.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
		if ((f_past_valid)&amp;&amp;($past(i_wb_stb))&amp;&amp;(i_wb_stb))
			assert(i_wb_we == $past(i_wb_we));</code></pre></figure>

<p>To go one step further, we’ll insist that the <code class="highlighter-rouge">WE</code> only change when there are
no outstanding requests–such as in a “read-modify-write” cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	// Within any given bus cycle, the direction may *only* change when
	// there are no further outstanding requests.
	always @(posedge i_clk)
		if ((f_past_valid)&amp;&amp;(f_outstanding &gt; 0))
			assert(i_wb_we == $past(i_wb_we));</code></pre></figure>

<p>The <code class="highlighter-rouge">SEL</code> (byte select) line(s) are an indication of which bytes within a word
should be written to the device.  To be meaningful, any write transaction
should assert one or more of these bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
		if ((i_wb_stb)&amp;&amp;(i_wb_we))
			assert(|i_wb_sel);</code></pre></figure>

<p>From here, let’s move on to the lines returned from the slave–primarily the
<code class="highlighter-rouge">ACK</code> and <code class="highlighter-rouge">ERR</code> lines.</p>

<p>We’ll start by insisting that these two signals should never
be asserted unless the master is in the middle of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle and <code class="highlighter-rouge">CYC</code> is high.</p>

<p>The one exception to this rule is in the case of an abort, where <code class="highlighter-rouge">CYC</code> goes
low before the slave has a chance to respond.  Thus, if <code class="highlighter-rouge">CYC</code> was low
(i.e. no <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle and no abort), then both <code class="highlighter-rouge">ACK</code> and <code class="highlighter-rouge">ERR</code> should be low on the next clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if ((f_past_valid)&amp;&amp;(!$past(i_wb_cyc))&amp;&amp;(!i_wb_cyc))
	begin
		assume(!i_wb_ack);
		assume(!i_wb_err);
		// ...
	end</code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a>
makes it clear that both <code class="highlighter-rouge">ACK</code> and <code class="highlighter-rouge">ERR</code> signals may
never be true on the same clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
		assume((!i_wb_ack)||(!i_wb_err));</code></pre></figure>

<p>The next two properties get into counting.  They have to deal with how
long a slave can take to accept a request, and how long the slave can take
to respond to the request once accepted.  Both are predicated upon some
parameterized number of counts.  If the respective count parameter is non-zero,
then the time limit property is applied.</p>

<p>For the first property, we’ll assume that the slave can only stall the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
for <code class="highlighter-rouge">F_MAX_STALL</code> counts–no more.  The purpose of this is just to
help to limit the search space for the formal verifier.  It is optional and
not strictly necessary, but you may find it to be useful.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	generate if (F_MAX_STALL &gt; 0)
	begin : MXSTALL
		// ...
		reg	[(DLYBITS-1):0]		f_stall_count;

		initial	f_stall_count = 0;
		always @(posedge i_clk)
			if ((!i_reset)&amp;&amp;(i_wb_stb)&amp;&amp;(i_wb_stall))
				f_stall_count &lt;= f_stall_count + 1'b1;
			else
				f_stall_count &lt;= 0;
		always @(*)
			if (i_wb_cyc)
				assume(f_stall_count &lt; F_MAX_STALL);
	end endgenerate</code></pre></figure>

<p>The next optional property is the number of cycles to wait until the next
acknowledgement is received.  If <code class="highlighter-rouge">F_MAX_ACK_DELAY</code> is greater than zero,
these cycles will be counted and an assumption will limit this count so that
there are always this many or fewer cycles between acknowledgements.  The
rule, though, is that we don’t need to count this delay if nothing is pending.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	generate if (F_MAX_ACK_DELAY &gt; 0)
	begin : MXWAIT
		reg	[(DLYBITS-1):0]		f_ackwait_count;

		initial	f_ackwait_count = 0;
		always @(posedge i_clk)
			if ((!i_reset)&amp;&amp;(i_wb_cyc)&amp;&amp;(!i_wb_stb)
					&amp;&amp;(!i_wb_ack)&amp;&amp;(!i_wb_err)
					&amp;&amp;(f_outstanding &gt; 0))
				f_ackwait_count &lt;= f_ackwait_count + 1'b1;
			else
				f_ackwait_count &lt;= 0;

		always @(*)
		if ((!i_reset)&amp;&amp;(i_wb_cyc)&amp;&amp;(!i_wb_stb)
					&amp;&amp;(!i_wb_ack)&amp;&amp;(!i_wb_err)
					&amp;&amp;(f_outstanding &gt; 0))
			assume(f_ackwait_count &lt; F_MAX_ACK_DELAY);
	end endgenerate</code></pre></figure>

<p>When I initially started proving bus properties, these two parameters,
<code class="highlighter-rouge">F_MAX_STALL</code> and <code class="highlighter-rouge">F_MAX_ACK_DELAY</code> were very important for limiting how many
states the formal solver needed to examine.  In hind sight, I think the
three output ports can remove the need for these two properties–but I’ve left
these checks in place for the time being.</p>

<p>We still need two more counters.  The first, <code class="highlighter-rouge">f_nreqs</code>, will count the number
of requests that have been made and accepted by the slave, while the second,
<code class="highlighter-rouge">f_nacks</code>, will count the number of acknowledgements returned.  Both of these
counters will be returned to our parent module as outputs of this module.</p>

<p>The number of requests accepted starts at zero, and returns to zero
upon any reset or the end of any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle.  While the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
cycle is active, this number will accumulate any time the <code class="highlighter-rouge">STB</code> is true
and the <code class="highlighter-rouge">STALL</code> signal is not–the indication that a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
transaction request has been made.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	f_nreqs = 0;
	always @(posedge i_clk)
	if ((i_reset)||(!i_wb_cyc))
		f_nreqs &lt;= 0;
	else if ((i_wb_stb)&amp;&amp;(!i_wb_stall))
		f_nreqs &lt;= f_nreqs + 1'b1;</code></pre></figure>

<p>The <code class="highlighter-rouge">f_nacks</code> counter is almost identical to the <code class="highlighter-rouge">f_nreqs</code> counter, save that
the number of acknowledgements increments any time <code class="highlighter-rouge">i_wb_ack</code> or <code class="highlighter-rouge">i_wb_err</code>
is true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	f_nacks = 0;
	always @(posedge i_clk)
	if (i_reset)
		f_nacks &lt;= 0;
	else if (!i_wb_cyc)
		f_nacks &lt;= 0;
	else if ((i_wb_ack)||(i_wb_err))
		f_nacks &lt;= f_nacks + 1'b1;</code></pre></figure>

<p>The difference between the number of requests and the number of
acknowledgements is the number of outstanding requests.  Since <code class="highlighter-rouge">f_nreqs</code>
and <code class="highlighter-rouge">f_nacks</code> are both
registered, we avoid a second delay here by not registering <code class="highlighter-rouge">f_outstanding</code>.
The result, though, is that we may need to trim it suddenly to zero anytime
<code class="highlighter-rouge">i_wb_cyc</code> is dropped.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assign	f_outstanding = (i_wb_cyc) ? (f_nreqs - f_nacks):0;</code></pre></figure>

<p>Some <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
masters are known to only ever request a fixed number of values on
any transaction.  For example, the
<a href="/about/zipcpu.html">ZipCPU</a>
has a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">prefetch
module</a>
that will only ever request one item from the bus, a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">dblfetch
module</a>
that will only ever request two items, and a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">pfcache
module</a>
that will always request exactly one cache line.</p>

<p>For these masters, the <code class="highlighter-rouge">F_MAX_REQUESTS</code> parameter can be used to limit the
formal proof and force this maximum request limit.
If the <code class="highlighter-rouge">F_MAX_REQUESTS</code> variable has been set to a value greater than zero,
then we insist that the number of requests and the number of acknowledgements
are always both less than this value.  This assertion is set into two parts.
First, if <code class="highlighter-rouge">STB</code> is on then a new request is pending so the number
of requests must be less than <code class="highlighter-rouge">F_MAX_REQUESTS</code>.  Second, if <code class="highlighter-rouge">STB</code> is false,
then the full number of requests may have been issued.  Further, we’ll also
insist that the number of outstanding requests remains one less than
<code class="highlighter-rouge">(1&lt;&lt;F_LGDEPTH)</code>, where <code class="highlighter-rouge">F_LGDEPTH</code> is the number of bits in our counters.
This guarantees that <code class="highlighter-rouge">f_outstanding</code> will never roll over.  It also requires,
however, that the log, based two, of the maximum number of outstanding
transactions must be passed to our core in <code class="highlighter-rouge">F_LGDEPTH</code>.</p>

<p>If <code class="highlighter-rouge">F_MAX_REQUESTS</code> is not specified, we’ll assume that the number of
outstanding requests is not allowed to roll over the maximum value and
back to zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
		if ((i_wb_cyc)&amp;&amp;(F_MAX_REQUESTS &gt; 0))
		begin
			if (i_wb_stb)
				assert(f_nreqs &lt; F_MAX_REQUESTS);
			else
				assert(f_nreqs &lt;= F_MAX_REQUESTS);
			assume(f_nacks &lt;= f_nreqs);
			assert(f_outstanding &lt; (1&lt;&lt;F_LGDEPTH)-1);
		end else
			assume(f_outstanding &lt; (1&lt;&lt;F_LGDEPTH)-1);</code></pre></figure>

<p>The <a href="/doc/wbspec_b4.pdf">specification</a>
makes it very clear that there shall only be one acknowledgement (at most)
per request.  To capture this requirement, we simply insist within our formal
proof that if there are no outstanding requests, then there shall be no
incoming acknowledgements.  The same goes for
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>
as well: there can be no error, nor any acknowledgement, without
first receiving a request.</p>

<p>One update since I first wrote this article is that the error or
acknowledgement can be asserted on the same clock that <code class="highlighter-rouge">(STB)&amp;&amp;(!STALL)</code>
is true.  There need not be a one-cycle delay from request to
acknowledgement.  The following logic captures this requirement if
<code class="highlighter-rouge">F_OPT_MINCLOCK_DELAY</code> is false, as well as the requirement of
no responses from the bus without a request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(*)
		if ((i_wb_cyc)&amp;&amp;(f_outstanding == 0))
		begin
			// If nothing is outstanding, then there should be
			// no acknowledgements ... however, an acknowledgement
			// *can* come back on the same clock as the stb is
			// going out.
			if (F_OPT_MINCLOCK_DELAY)
			begin
				assume(!i_wb_ack);
				assume(!i_wb_err);
			end else begin
				assume((!i_wb_ack)||((i_wb_stb)&amp;&amp;(!i_wb_stall)));
				// The same is true of errors.  They may not be
				// created before the request gets through
				assume((!i_wb_err)||((i_wb_stb)&amp;&amp;(!i_wb_stall)));
			end
		end</code></pre></figure>

<p>Here we switch from requirements for all
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
masters to the first of several optional properties.  These options are
controlled by parameters to the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/fwb_master.v">formal master properties
module</a>.
The options insist upon properties not required by the protocol, but which may
be worth asserting for some masters.  As such, they are convenience properties
only, and therefore default to not being part of the test.</p>

<p>The first of these is the source option.  If a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master is the <em>source</em> of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
request, as opposed to being an
<a href="https://en.wikipedia.org/wiki/Arbiter_(electronics)#Bus_arbiter">arbiter</a>
or adapter mid stream, then the request should start with both <code class="highlighter-rouge">CYC</code> and
<code class="highlighter-rouge">STB</code> lines going high together.  Since the
<a href="/doc/wbspec_b4.pdf">specification</a>
doesn’t require this, we list it here as optional.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	generate if (F_OPT_SOURCE)
	begin : SRC
		// ...
		always @(posedge i_clk)
			if ((f_past_valid)&amp;&amp;(!$past(i_wb_cyc))&amp;&amp;(i_wb_cyc))
				assert(i_wb_stb);
	end endgenerate</code></pre></figure>

<p><code class="highlighter-rouge">F_OPT_SOURCE</code> is a master only parameter option, however.  By the time a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interaction gets to the slave, the <code class="highlighter-rouge">CYC</code> line may go high or low without
actually affecting the <code class="highlighter-rouge">STB</code> line of the slave.</p>

<p>The next option is the read-modify-write option, <code class="highlighter-rouge">F_OPT_RMW_BUS_OPTION</code>.  If
this option is not set, the master must drop the <code class="highlighter-rouge">CYC</code> line following the last
acknowledgement.</p>

<p>This doesn’t apply, though, to those
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">buses</a>
that may wish to hold the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
open (locked) between two transactions–such as a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> requesting an
<a href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)">atomic</a>
increment operation.  For these masters, the option should be left on.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	parameter [0:0]		F_OPT_RMW_BUS_OPTION = 1;
	// ...
	generate if (!F_OPT_RMW_BUS_OPTION)
	begin
		// ...
		always @(*)
			if (f_outstanding == 0)
				assert((i_wb_stb)||(!i_wb_cyc));
		// ...
	end endgenerate</code></pre></figure>

<p>In many ways, the master doesn’t care what happens on the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
return
lines if the cycle line is low or if there’s no acknowledgement coming back,
so restricting these wires to known values makes a lot of sense.  This is the
purpose of the <code class="highlighter-rouge">F_OPT_SHORT_CIRCUIT_PROOF</code> option.  If set, it helps to limit
the formal search space and thus it is intended to make the proof simpler.</p>

<p>On the other hand, if something within the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
master <em>does</em> depend upon these values (when it shouldn’t), then we might want
to know about it.  For this reason, the option default is not to short circuit
the slave’s responses.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	parameter [0:0]		F_OPT_SHORT_CIRCUIT_PROOF = 0;
	// ...
	generate if (F_OPT_SHORT_CIRCUIT_PROOF)
	begin
		always @(posedge i_clk)
		begin
			if (!i_wb_cyc)
			begin
				restrict(!i_wb_stall);
				restrict($stable(i_wb_idata));
			end else if ((!$past(i_wb_ack))&amp;&amp;(!i_wb_ack))
				restrict($stable(i_wb_idata));
		end
	end endgenerate</code></pre></figure>

<p>While not all masters are likely to make discontinuous requests, some might.
Therefore, we allow an option, <code class="highlighter-rouge">F_OPT_DISCONTINUOUS</code>, that can be set to
allow discontinuous requests.  If this option is not set, then once the
<code class="highlighter-rouge">STB</code> line is dropped, we’ll insist that it cannot be raised again without
also dropping the <code class="highlighter-rouge">CYC</code> line.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	parameter	[0:0]	F_OPT_DISCONTINUOUS = 0;
	// ...
	generate if ((!F_OPT_DISCONTINUOUS)&amp;&amp;(!F_OPT_RMW_BUS_OPTION))
	begin : INSIST_ON_NO_DISCONTINUOUS_STBS
		always @(posedge i_clk)
			if ((f_past_valid)&amp;&amp;($past(i_wb_cyc))&amp;&amp;(!$past(i_wb_stb)))
				assert(!i_wb_stb);
	end endgenerate

endmodule</code></pre></figure>

<p>Since any master that implements a “read-modify-write” cycle will need to
raise the <code class="highlighter-rouge">STB</code> line after it has been initially dropped,
the generate above attempts to capture these conditions.</p>

<p>Put together, any <a href="/doc/wbspec_b4.pdf">Wishbone</a> master
core, having the properties listed above, is guaranteed to interact properly
with a <a href="/doc/wbspec_b4.pdf">Wishbone B4</a>, pipelined
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This post has been written following the lessons I’ve learned making
formal proofs for the
<a href="/about/zipcpu.html">ZipCPU</a>
prefetch modules
[<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">1</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">2</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">3</a>].  I’ve
also now tested other interactions with these properties, such as those of a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarbiter.v">priority
arbiter</a>
or those of a
Wishbone
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/busdelay.v">bus delay</a>
component, and I’ve adjusted many of these components with the lessons
I’ve learned in this process.  As a result, we may yet come back to this topic
of formally verifying a <a href="/doc/wbspec_b4.pdf">Wishbone bus</a>
master, but now that we’ve presented the basics any following posts will
reflect how these basics are applied to particular application-specific
situations.</p>

<p>Until then, here’s a fun thought: on a <a href="http://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;No=1046">recent application</a>
I have been working on, I had the option of using an
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon bus</a>.
Since all of my tools are (so far) written for the
<a href="/doc/wbspec_b4.pdf">Wishbone bus</a>,
I needed to either rebuild my tools, or to build a bridge to cross from
the one to the other.  Every transaction needed to go through this bridge,
so it is a very critical component of this design.
<a href="/blog/2017/10/19/formal-intro.html">Formal methods</a>,
such as the ones we’ve discussed today, have given me confidence, even
before placing this bridge onto actual hardware, that it will work in
practice when I do.</p>

<p>At some point, I may switch from this
<a href="https://www.altera.com/literature/manual/mnl_avalon_spec.pdf">Avalon</a>
to
<a href="/doc/wbspec_b4.pdf">Wishbone</a>
bridge to an
<a href="https://github.com/ZipCPU/wb2axisp">AXI to Wishbone bridge</a> I built some
time ago, but I haven’t quite finished the proof of that component (yet).</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Every word of God is pure: he is a shield unto them that put their trust in him. (Prov 30:5)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
