<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Debugging your soft-core CPU within an FPGA</title>
  <meta name="description" content="We’ve already looked at the requirements for debugging a CPU ingeneral, aswell as how to debug a CPU within a Verilator basedsimulation.Let’s now return to t...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2017/08/25/hw-debugging.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Debugging your soft-core CPU within an FPGA</h1>
    <p class="post-meta"><time datetime="2017-08-25T00:00:00-04:00" itemprop="datePublished">Aug 25, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>We’ve already looked at the requirements for <a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">debugging a CPU in
general</a>, as
well as <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">how to debug a CPU within a Verilator based
simulation</a>.
Let’s now return to this topic and take a look at how to modify your
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core CPU</a>
so that you can debug it once it is placed within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<table style="float: right"><caption>Fig 1: Soft-Core CPU H/W Debugging Needs</caption><tr><td><img src="/img/cpu-dbg-inhw.svg" alt="Needs of a Soft-Core Hardware Debugger" width="320" /></td></tr></table>

<p>When we discussed the <a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">general needs of a
debugger</a>,
we used a figure similar to Fig 1. to describe a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
debugging needs.
We addressed the left column,
debugging the <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
while in simulation, <a href="/zipcpu/2017/07/26/cpu-sim-debugger.html">in a
previous post</a>.
Today, the figure at the right has been modified to highlight todays
discussion and focus: how to add the necessary logic into a
<a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft-core CPU</a>
to support debugging.</p>

<p>As shown in the diagram, the basic operations we’re going to need to support
are resetting, starting, halting, and stepping a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
as well as examining
and changing
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
state
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>.
You may wish to review how the <a href="/zipcpu/2017/08/23/cpu-pipeline.html">ZipCPU handles pipeline
control</a>,
since the logic we shall discuss today needs to fit nicely into that context.</p>

<h2 id="that-hw-debugging-interface">That H/W Debugging Interface</h2>

<p>If you’ve never done this before, please don’t start by trying to implement
<a href="https://www.gnu.org/software/gdb">GDB</a>’s <a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">remote serial
protocol</a>
within Verilog.  The protocol is very powerful, and we’ll discuss how to use
it later to connect your
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
to <a href="https://www.gnu.org/software/gdb">GDB</a>.
The problem is that the protocol is complex, and it will take a lot of work to
process it within hardware.  Keep reading, there’s an easier way.</p>

<p>As a first step, think for a moment about what <a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">debugging your CPU
will require</a>.
In particular, you’ll want to be able to read and write both
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>
and memory.</p>

<ul>
  <li>
    <p><a href="/digilent/2017/05/22/moving-to-memory.html">Reading from
memory</a>
requires the address you wish to read from as well as a strobe signal to
indicate your desire to read</p>

    <p>If your address space is big enough, this <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">same sort of command and
interface</a> can work for
reading
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>
just like it does for memory.</p>
  </li>
  <li>
    <p><a href="/zipcpu/2017/05/23/simplebus.html">Writing to memory</a>
requires an address, a value, and a strobe to tell you
when to write the value to the given address.</p>

    <p>As with reading, if you can allocate an address for each
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a> within your
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
the same interface you used for reading
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>
could also work to writing
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a> within your
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.</p>

    <p>The approach can even be expanded to include not only
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>
values, but also internal (debugging) state variables from within your
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.</p>
  </li>
</ul>

<p>As a third example, a control register could also be used to tell the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> when
to execute an instruction, and when to hold in reset.</p>

<table style="float: right"><caption>Fig 2: Placing a CPU on the Debugging Bus</caption><tr><td><img src="/img/hw-debug-structure.svg" alt="Block diagram of a CPU placed on a Debugging Bus" width="320" /></td></tr></table>

<p>All of these interactions, therefore, are easily understood as things that
could take place across a
“<a href="/zipcpu/2017/05/23/simplebus.html">bus</a>”
with both memory and <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped
peripherals</a> on it.
Therefore, one might consider giving the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> a <a href="/zipcpu/2017/05/29/simple-wishbone.html">bus slave
interface</a>, and
hooking it up to the <a href="https://github.com/ZipCPU/dbgbus">debugging
bus</a> we’ve been working with (or something
similar) as shown in Fig 2.</p>

<p>This approach has a couple of advantages.  First, the
<a href="https://github.com/ZipCPU/dbgbus">debugging bus</a>
can be used to <a href="/zipcpu/2017/05/20/which-came-first.html">debug both the peripherals and the
memory</a>
the <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
will need to work with later.  Second, if the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
and <a href="https://github.com/ZipCPU/dbgbus">debugging
bus</a> are each given the same view of the
peripheral set, then no separate address map and decoder needs to be created.
Third, this approach creates a means, independent of the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
of reading and writing to memory.  This could be very important later when
building a
program loader for the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
since it would then allow you to load the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
program into memory and test it, without relying on any internal
<a href="https://en.wikipedia.org/wiki/Read-only_memory">ROM</a>
within the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
that would cause the design to need to be resynthesized anytime
something changes.</p>

<p>The downside of this approach is that, depending upon your implementation, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbpriarb.v">bus arbiter</a>
may slow the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
access to memory by a clock (or two).</p>

<table style="float: right"><caption>Fig 3: ZipCPU's debugging interface</caption><tr><td><img src="/img/bare-cpu-debug-iface.svg" alt="ZipCPU's bare debugging interface" width="320" /></td></tr></table>

<p>This was the approach taken by the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>, as shown in Fig 3, so we’ll use the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
as our example of this approach in our discussion below.  The
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> was
given two address locations on the debugging bus: a control and data
location.  (These are both discussed and defined in the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf">specification
document</a>.)
A small wrapper around the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">ZipCPU
proper</a>, called
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>,
connects to the control register of the debug slave port and controls the
reset and halt lines into the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>.
These are used to implement reset, halt,
start, and step operations as we’ll see shortly.</p>

<p>The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
also has a second wrapper with more functionality to it, called
the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>,
but since the logic within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
is simpler, we’ll focus on it.</p>

<p>Our discussion will focus on the reads and writes of these two locations,
the control and data ports, although you may wish to give your own
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
more registers than just these two.</p>

<h2 id="reseting-halting-and-stepping-the-cpu">Reseting, halting, and stepping the CPU</h2>

<p>Let’s look at the control register for the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> for a moment.  Writes to
this control register have the side-effect of controlling the
<code class="language-plaintext highlighter-rouge">i_halt</code> and <code class="language-plaintext highlighter-rouge">i_rst</code> (reset) lines within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>.
These side effects will cause the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">ZipCPU</a>
to run, halt, step, or even reset as requested.</p>

<p>The first side effect to be discussed is the reset.  Like many digital
logic cores, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">ZipCPU</a>
has a reset line going into it.  Controlling this reset is also quite
possibly the simplest interaction with the bus.  Specifically, any time
the control register is written with the reset bit set, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is reset.  Further, this reset line into the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is initialized high, to make sure
that the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
always starts from a reset state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">cmd_reset</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">cmd_reset</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">dbg_cmd_write</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_dbg_data</span><span class="p">[</span><span class="cp">`RESET_BIT</span><span class="p">]));</span></code></pre></figure>

<p>Inside the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">ZipCPU</a>,
this reset line causes the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">ZipCPU</a>
to reboot.  While it only (re-)initializes a minimum of variables, it is
enough to get the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
start from (nearly) known conditions.
In particular, all error conditions, cache valid indications, and pipeline
valid flags are cleared on reset.  Further, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is sent to a pre-programmed address.  What doesn’t happen is that the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>
are not re-initialized (the program counter and flags registers are though).
This allows some amount of fault recovery in software, if desired, prior to
setting all of the
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>
to known conditions.</p>

<p>The second control line going into the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is a master halt line, <code class="language-plaintext highlighter-rouge">i_halt</code>.  This line, if set, will cause the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
to halt in such a way that no instructions will go
into the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v">memory</a>
or <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a>
units, but instructions that have already
entered these units will be allowed to finish.  It does this by setting the
stall logic associated with units, as we discussed during our
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">CPU pipeline signaling
post</a>.</p>

<p>The neat thing about the master halt line concept is that the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is designed to halt at a stopping point between instructions when using it.
Instructions that have entered the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v">memory</a>
or <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a>
stages are allowed to complete, but further instructions are not allowed
to enter these stages.  As a result, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
can be started, stepped, or halted by adjusting this master enable (i.e.
<code class="language-plaintext highlighter-rouge">i_halt</code>) line.</p>

<p>This <code class="language-plaintext highlighter-rouge">i_halt</code> line into the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is calculated from a couple of pieces of logic in the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
wrapper.  The first is the <code class="language-plaintext highlighter-rouge">cmd_halt</code> register which is controlled by writes
to the control register.  On a reset, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
will start in a halted mode (if the boolean parameter <code class="language-plaintext highlighter-rouge">START_HALTED</code> is set to
true).  Ever afterwards, any write to the halt bit in the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
status register will set or clear this bit with two exceptions:
<code class="language-plaintext highlighter-rouge">cmd_step</code> and <code class="language-plaintext highlighter-rouge">cpu_break</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`define</span>	<span class="n">STEP_BIT</span>	<span class="mi">8</span>
<span class="cp">`define</span>	HALT_BIT	10<span class="cp">
</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_rst</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">cmd_reset</span><span class="p">))</span>
		<span class="n">cmd_halt</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">START_HALTED</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dbg_cmd_write</span><span class="p">)</span>
		<span class="n">cmd_halt</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="n">i_dbg_data</span><span class="p">[</span><span class="cp">`HALT_BIT</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_dbg_data</span><span class="p">[</span><span class="cp">`STEP_BIT</span><span class="p">]));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cmd_step</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">cpu_break</span><span class="p">))</span>
		<span class="n">cmd_halt</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>The first exception is the <code class="language-plaintext highlighter-rouge">cmd_step</code> logic.  If the halt bit is set
at the same time the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is instructed to step forward by one clock, then the halt request is ignored
until the <code class="language-plaintext highlighter-rouge">cmd_step</code> has been true for one cock.  We’ll come back to this
exception in a moment.</p>

<p>The second exception is the <code class="language-plaintext highlighter-rouge">cpu_break</code> signal.  This is shown in Fig. 3 as
the hardware break signal.  This is the signal the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
creates when it has encountered an unrecoverable fault–such as trying
to execute an unimplemented instruction while in the supervisor
(i.e. interrupt) state.  Other faults within the supervisor state
will also cause the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
to fault as well, such as the break instruction, a divide by zero fault from
within supervisor mode, or a
<a href="/doc/wbspec_b4.pdf">wishbone bus</a>
error.  This <code class="language-plaintext highlighter-rouge">cmd_halt</code> state captures that fault, and then holds the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
in a halted state for the debugger to come by and examine it.  (Alternatively,
the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
could be programmed to just reboot.)</p>

<p>On that note, let’s return to looking at the step bit.  If the step bit is ever
set, the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
wrapper will release the halt line for one clock and then set it immediately
again.  This will cause one instruction to enter the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>/memory pipeline stage.
It works in conjunction with the <code class="language-plaintext highlighter-rouge">cmd_halt</code> bit above, so that if the step
register is ever true, the <code class="language-plaintext highlighter-rouge">cmd_halt</code> register will get set on the next
instruction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">cmd_step</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">cmd_step</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">dbg_cmd_write</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_dbg_data</span><span class="p">[</span><span class="cp">`STEP_BIT</span><span class="p">]);</span></code></pre></figure>

<p>While this description may sound simple, the devil is in the details.
For example, what happens when the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is in the middle of an atomic operation?
What if an interrupt comes in while the debugger has the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
halted?  (It gets ignored.) What if the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is in the middle of executing a pair of instructions from a compressed
instruction set word?  (The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
has no ability to restart a compressed instruction word mid-way through …)
What if the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is loading a cache line, and the memory is slow to respond? (i.e. broken)</p>

<p>All of these details can make this halt line difficult to implement.</p>

<h2 id="clearing-the-cache">Clearing the Cache</h2>

<p>Before we move on to gaining access to
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>,
the control register offers one more big capability–that of
clearing the cache.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">cmd_clear_pf_cache</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">cmd_clear_pf_cache</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">dbg_cmd_write</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_dbg_data</span><span class="p">[</span><span class="cp">`CLEAR_CACHE_BIT</span><span class="p">];</span></code></pre></figure>

<p>This is one of those annoying details that you may not think of initially.
If the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is halted, the debugger is free to change memory, right?  Hence,
the debugger might wish to swap a normal instruction for a <code class="language-plaintext highlighter-rouge">BREAK</code>
instruction or vice versa.  The problem lies in whether the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
has already read that instruction into its cache.  If the instruction the
debugger wishes to change is already in the cache, then the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
might not notice the fact that the debugger has changed that memory.
(The <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">ZipCPU</a>
cache has no bus snooping capability … yet.)</p>

<p>This command also clears the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>’s
pipeline for essentially the same reason–lest the instruction the debugger
wished to change was also within the pipeline already and just waiting to
execute.  We discussed how this was done earlier, when we discussed how
the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
implemented its
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline logic</a>.</p>

<h2 id="reading-and-setting-registers">Reading and Setting Registers</h2>

<p>While a proper bus protocol makes sense for reading from
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>,
as we discussed above,
the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>’s
debug implementation isn’t quite a full bus implementation. Perhaps this
interaction is ready for redesign.  For now, I’ll just explain it as it is.</p>

<p>The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> control register contains a
set of six address bits.  Writes to the control register can be used to set
these six address bits as well other flags such as those we discussed above.
These then become the
<a href="/doc/wbspec_b4.pdf">wishbone</a>
address of a register within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>.
Ever after, reads from (or writes to) the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
data register will adjust the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>.
<a href="https://en.wikipedia.org/wiki/Processor_register">register</a>,
addressed by these six address bits.</p>

<p>Remember how <a href="/zipcpu/2017/05/23/simplebus.html">we discussed
earlier</a>
that a register read from a bus is just a big case statement?  The same is true
of the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>.
The only difference within the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
is that 28 of the 32 <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
<a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>,
are stored in an on-chip RAM while the other four are collected from a
set of control and status bits, and the two program counters.  Reading from
the bus, therefore, is almost the same as the big case statement
<a href="/zipcpu/2017/05/23/simplebus.html">we discussed earlier</a>:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// 28 registers are normal, and can be read from a memory</span>
	<span class="n">o_dbg_reg</span> <span class="o">&lt;=</span> <span class="n">regset</span><span class="p">[</span><span class="n">i_dbg_reg</span><span class="p">];</span>

	<span class="c1">// The PC is a bit different</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_dbg_reg</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="cp">`CPU_PC_REG</span><span class="p">)</span>
		<span class="n">o_dbg_reg</span> <span class="o">&lt;=</span> <span class="n">w_debug_pc</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_dbg_reg</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="cp">`CPU_CC_REG</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// As is the flags register</span>
		<span class="n">o_dbg_reg</span><span class="p">[</span><span class="mi">14</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_dbg_reg</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">?</span><span class="n">w_uflags</span><span class="o">:</span><span class="n">w_iflags</span><span class="p">;</span>
		<span class="n">o_dbg_reg</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">o_dbg_reg</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">23</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w_cpu_info</span><span class="p">;</span>
		<span class="n">o_dbg_reg</span><span class="p">[</span><span class="cp">`CPU_GIE_BIT</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">gie</span><span class="p">;</span>
	<span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Writes are a touch more difficult, since the debugger needs to insert any
register writes into the processing chain of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>.</p>

<p>The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>.
handles such writes by creating a module parallel with the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
and <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v">memory</a>.
This module (really only a register and about 4 lines of code) is only active
if the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
is halted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">dbgv</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">i_rst</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_halt</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_dbg_we</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">r_halted</span><span class="p">);</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">dbg_val</span> <span class="o">&lt;=</span> <span class="n">i_dbg_data</span><span class="p">;</span></code></pre></figure>

<p>Likewise, the register (and value) the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a> would’ve written
upon completion is modified during a halt as well:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adf_ce_unconditional</span><span class="p">)</span>
		<span class="c1">// A normal register write, if the CPU is running</span>
		<span class="n">alu_reg</span> <span class="o">&lt;=</span> <span class="n">op_R</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_halt</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_dbg_we</span><span class="p">))</span>
		<span class="c1">// A debug register write, requiring the CPU to be halted</span>
		<span class="n">alu_reg</span> <span class="o">&lt;=</span> <span class="n">i_dbg_reg</span></code></pre></figure>

<p>This then sets the write values on the clock before writeback.  (The
<code class="language-plaintext highlighter-rouge">adf_ce_unconditional</code> flag is a piece of the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>’s
pipeline logic that we may come back and address in more detail later in
a post on pipelining.)</p>

<p>Finally, so that the debugger can know that this write has occurred, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> holds the stall register high
any time it the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
hasn’t completely halted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">o_dbg_stall</span> <span class="o">=</span> <span class="o">!</span><span class="n">r_halted</span><span class="p">;</span></code></pre></figure>

<p>You may notice, if you look at the code, that there’s no acknowledgement line.
Indeed, the acknowledgement line is generated at the bottom of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>
file based upon the fact that any request made to the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>, as long
as the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
isn’t stalled, is successful.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You may notice that the logic above only depends upon a couple of wires,
and that these wires have a very simple amount of logic assicated with them.
This is how digital design should be.  The trick to every problem is knowing
how to make the problem simple.</p>

<p>In our case, this problem is simplified by first creating some form of
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus</a>
to get a bus access point to our hardware and peripherals, as well as
understanding several various <a href="/blog/2017/08/14/strategies-for-pipelining.html">pipeline
strategies</a>,
and then second understanding how a simple <a href="/zipcpu/2017/08/23/cpu-pipeline.html">CPU can use such a
strategy</a>.</p>

<p>This still leaves us with many more
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
topics to discuss, such as how to add or remove peripherals by simply
adding or removing parameters from an
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
command line.
However, we are going to postpone that discussion until after I have the
opportunity to discuss
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
at <a href="http://www.orconf.org">ORCONF</a> this year.</p>

<p>In the meantime, then, I’d like to turn this blog’s attention to the
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">DSP</a>
topics of both sine wave generation and
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filtering</a>.
We’ll come back to the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
later–if for no other reason than I’ve been asked to discuss how to modify
<a href="https://gcc.gnu.org">GCC</a>
to support a new
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
backend.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>No man can serve two masters: for either he will hate the one, and love the other; or else he will hold to the one, and despise the other. Ye cannot serve God and mammon.  (Matt 6:24)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
