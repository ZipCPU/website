<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>The ZipCPU's pipeline logic</title>
  <meta name="description" content="Now that we’ve discussed some general pipelinestrategies,it’s time to take a look at how pipelining can work within a simple, in order,pipelined CPU.Let’s ta...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zipcpu.com/zipcpu/2017/08/23/cpu-pipeline.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="http://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">The ZipCPU's pipeline logic</h1>
    <p class="post-meta"><time datetime="2017-08-23T00:00:00-04:00" itemprop="datePublished">Aug 23, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Now that we’ve discussed some <a href="/blog/2017/08/14/strategies-for-pipelining.html">general pipeline
strategies</a>,
it’s time to take a look at how pipelining can work within a simple, in order,
pipelined <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
Let’s take a look, therefore, at the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
and see how it handles its pipeline logic.
What you’ll see is that the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
uses a variant of the <a href="/blog/2017/08/14/strategies-for-pipelining.html">handshaking strategy we discussed
earlier</a>.</p>

<p>If you are unfamiliar with the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
has five pipeline stages, as shown in Fig 1.</p>

<table style="float: right"><caption>Fig 1: The ZipCPU Pipeline Structure</caption><tr><td><img src="/img/zipcpu.png" alt="ZipCPU Pipeline Structurre" width="380" /></td></tr></table>

<p>There’s the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">prefetch and instruction
cache</a>
stage, an <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v">instruction
decode</a> stage,
a read operands stage, an
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
stage and a writeback stage.  The
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
stage is also placed parallel to a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v">memory operations
unit</a>, a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a> unit,
and a space for (a still undefined) floating point unit.</p>

<p>As currently built, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
is an in-order processor.  It’s pipeline structure requires that
values going into the write-back unit be strictly in order.</p>

<p>If you choose to look through the main
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">processor’s
code</a>,
you may find it not as simple to read.  That’s because the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
was written to thread a fine line between two separate purposes.  The first,
stated purpose, is to be a simple
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>–as
measured by the amount of logic used by the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
The second purpose is to be a fast
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
These two purposes are often in conflict.  Therefore, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> implementation allows you to
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v">select the performance you
want</a>, and
adjust as necessary to fit the amount of logic you have available for a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
within your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<p>Let’s use this as an example, though, in how a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
pipeline can be created within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<h2 id="instruction-overview">Instruction Overview</h2>

<p>In order to make the following examples make sense, it might help to
understand how the various pipeline stages are supposed to interact.
This will make examples easier to understand.</p>

<p>First, almost all
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
instructions have the form:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">   OP.C Ra,Rb+I</code></pre></figure>

<p>In this example, <code class="highlighter-rouge">OP</code> is the operation.  It’s a 5-bit field identifying
which instruction is described by this instruction.  Think of this as <em>what</em>
the <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
is being asked to do.  Indeed, four of the five <code class="highlighter-rouge">OP</code> bits form the
multiplexer selection input within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a> as
<a href="/zipcpu/2017/08/11/simple-alu.html">we discussed earlier</a>.</p>

<p>The <code class="highlighter-rouge">C</code> term is the condition.  This controls whether or not any value
is written back from the instruction.  For example, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
supports a <code class="highlighter-rouge">Z</code> condition which will cause the instruction to only write back
its results if the <code class="highlighter-rouge">Z</code> flag is set.  The other seven supported conditions are
discussed within the <a href="https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf">ZipCPU
specification</a>.</p>

<p>The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
is primarily a two operand machine.  It has no three operand instructions.
Hence, every
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
instruction provides two inputs to the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>,
<code class="highlighter-rouge">Ra</code> and <code class="highlighter-rouge">Rb+I</code> and the output gets written back into register <code class="highlighter-rouge">Ra</code>.</p>

<p>Finally, and this becomes important for the following discussion, almost
all instructions allow an immediate, usually 14-bits, to be added
to the second register, <code class="highlighter-rouge">Rb</code>.  Alternatively, an 18-bit immediate value, <code class="highlighter-rouge">I</code>,
may replace the ALU’s <code class="highlighter-rouge">Rb</code> input so that <code class="highlighter-rouge">Rb</code> is not used at all.</p>

<p>So, how does this impact pipelining?</p>

<ol>
  <li>
    <p>In the first stage, <strong>prefetch</strong>, an instruction is read from memory.</p>

    <p>The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
can run with one of several prefetch modules.
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/prefetch.v">[1]</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dblfetch.v">[2]</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipefetch.v">[3]</a>,
and
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">[4]</a>.
Each of these modules has roughly the same interface, although the logic
within them can differ greatly.</p>
  </li>
  <li>
    <p>In the second stage, the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/idecode.v">instruction
decode</a>
stage, the parts of the instruction are drawn from from the instruction word
produced by the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pfcache.v">prefetch</a>
stage.</p>

    <p>As an example, this stage determines whether or not the instruction even has
registers <code class="highlighter-rouge">Ra</code> and <code class="highlighter-rouge">Rb</code> encoded within it that need to be read from the
register set.  At the end of this stage the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>,
knows:</p>

    <p>a. what registers it needs to read (<code class="highlighter-rouge">dcd_A</code>, and <code class="highlighter-rouge">dcd_B</code>),</p>

    <p>b. if it needs to read from any register (<code class="highlighter-rouge">dcd_rA</code>, and <code class="highlighter-rouge">dcd_rB</code>)</p>

    <p>c. what the immediate value is (<code class="highlighter-rouge">dcd_I</code>), and if that value is zero
   (<code class="highlighter-rouge">dcd_Iz</code>)</p>

    <p>d. etc.</p>
  </li>
  <li>
    <p>The third stage, the read operands stage, not only reads <code class="highlighter-rouge">Ra</code> and <code class="highlighter-rouge">Rb</code> from
the register file, but also adds <code class="highlighter-rouge">I</code> to <code class="highlighter-rouge">Rb</code>.</p>
  </li>
  <li>
    <p>The fourth stage calculates the <code class="highlighter-rouge">OP</code> function on the values from <code class="highlighter-rouge">Ra</code> and
<code class="highlighter-rouge">Rb+I</code>.</p>

    <p>If this is an
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>,
instruction, the <code class="highlighter-rouge">OP</code> field controls which potential output from the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>,
<a href="/zipcpu/2017/08/11/simple-alu.html">will be selected</a>.</p>

    <p>If this is a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v">memory
operation</a>,
a store will place the value <code class="highlighter-rouge">Ra</code> into
memory location <code class="highlighter-rouge">Rb+I</code>.  A load will read from memory
<code class="highlighter-rouge">Rb+I</code> and present the result to the writeback unit.</p>

    <p>Memory accesses, divides, and multiplies may all take longer than a single
clock in this stage.  We’ll need to come back and discuss how to handle
this later.</p>

    <p>If done well, the outputs of this stage, whether from the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
or the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v">memory
unit</a>
can go directly back into this stage as inputs if so desired, as shown
in Fig 2.</p>

    <table align="center" style="float: none"><caption>Fig 2: Answers go back into the ALU</caption><tr><td><img src="/img/cpu-bypass.svg" alt="Answers go back into the ALU" width="580" /></td></tr></table>

    <p>This will take place any time the output of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
stage forms the input for the next instruction.  Indeed, this is a key
requirement for a high speed
pipelined <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.</p>

    <p>However, if the output of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
gets placed into the <code class="highlighter-rouge">Rb</code> register input of the next instruction, <em>and</em>
if that instruction
has an immediate, <code class="highlighter-rouge">I</code>, that needs to be added to it (<code class="highlighter-rouge">dcd_zI</code> is non-zero),
then the output cannot go directly back into the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>.
It will instead need to go back to the read operands stage, causing
a pipeline bubble in the process.  This other path is shown by the dotted
line in Fig 2.</p>
  </li>
  <li>
    <p>Finally, in the writeback unit, if the <code class="highlighter-rouge">C</code> condition matches, the result
is written back into the register set.</p>

    <p>Conditional branches are detected in this stage.  We’ll have to come back
and discuss how to handle this within the pipeline later as well.</p>
  </li>
</ol>

<p>This is nominally how the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
handles and uses its pipeline.  This simple pipeline, though, has all kinds
of hazards—many of which we’ll discuss below.</p>

<h2 id="pipeline-stalls-and-bubbles">Pipeline Stalls and Bubbles</h2>

<p>Before diving into pipeline specifics, let’s define a
<a href="https://en.wikipedia.org/wiki/Bubble_(computing)">pipeline stall</a>.</p>

<p>According to <a href="https://en.wikipedia.org/wiki/Bubble_(computing)">wikipedia</a>,
a <a href="https://en.wikipedia.org/wiki/Bubble_(computing)">pipeline stall</a>
is a condition where there’s no valid instruction within a particular pipeline
stage.  <a href="https://en.wikipedia.org">Wikipedia</a> declares a
<a href="https://en.wikipedia.org/wiki/Bubble_(computing)">pipeline stall</a>
to be synonymous with a
<a href="https://en.wikipedia.org/wiki/Bubble_(computing)">pipeline bubble</a>.</p>

<p>As the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> uses the term, a
<a href="https://en.wikipedia.org/wiki/Bubble_(computing)">pipeline stall</a>
takes place when there <em>is</em> a valid instruction within a particular pipeline
stage, but when that instruction cannot move forward.</p>

<p>For example, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a>
takes roughly 32-clocks to complete.  During these 32-clocks, instructions in
the prior stage, the read operands stage, will be stuck there until the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a>
completes.   Likewise, the writeback stage will be idle during this time,
being reserved for writing back the results of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a>
instruction.</p>

<p><a href="https://en.wikipedia.org">Wikipedia</a>’s definition declares the condition
where no valid data is within a pipeline stage to be called a stall.  This
seems to me to be more of a consequence of a stall, than a stall itself.
The <strong>pipeline bubble</strong> term describes this better, although
<a href="https://en.wikipedia.org">Wikipedia</a> declares the two terms to be synonymous.</p>

<p>If you watch the pipeline, such as within the demonstration we’ll discuss
later, you can visually see <strong>bubble</strong>s form within it where there are no valid
instructions.</p>

<h2 id="unique-pipeline-needs">Unique Pipeline Needs</h2>

<p>There are two basic goals that a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
has with respect to pipelining.  These two goals are common among
many pipeline systems:</p>

<ol>
  <li>
    <p>Keep every stage filled.</p>

    <p>For example, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
is capable of completing and retiring one
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
instruction per clock.  All of the pipeline logic within the
<a href="https://github.com/ZipCPU/zipcpu">CPU</a>
has been designed so as to keep one instruction completing on every clock.</p>

    <p>This is a common goal of any high speed pipeline.</p>
  </li>
  <li>
    <p>Satisfy any pre-requisites for instruction operations.</p>

    <p>An <a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
operation cannot complete if its values haven’t finished being produced
from other parts of the <a href="https://github.com/ZipCPU/zipcpu">CPU</a>.
For example, if
register <code class="highlighter-rouge">R0</code>  is read from slow memory in one instruction and then
immediately used on the next instruction, the pipeline logic will need to
stall the second instruction, waiting for the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>,
until <code class="highlighter-rouge">R0</code> is available.</p>

    <p>This problem is even worse if an immediate is to be added to the value
read from memory prior to heading into the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>.
In that case, it’s not just the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
that needs to stall, but the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
also needs to stall the read operands stage where that immediate addition
takes place.  (We discussed this with Fig 2 above)</p>
  </li>
</ol>

<p>A <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
though, has some other pipeline needs beyond the more traditional data flow
processing pipeline.  Specifically,
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
need to be able to jump from one instruction in memory to another.  This
creates some unusual pipeline requirements.</p>

<p>At its most basic level, a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
needs be able to flush or clear its pipeline any time a branch renders
the work done in a prior stage irrelevant.
The worst case scenario is when a branch takes place that can’t be
caught prior to the writeback stage.  In that case, the whole pipeline will
need to be flushed, costing the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
one clock per pipeline stage that cannot be completed.
The <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">ZipCPU</a>
captures this logic with the <code class="highlighter-rouge">clear_pipeline</code> signal.</p>

<p>Other things can cause sudden pipeline changes as well.  For example, what
happens on an interrupt (peripheral initiated), a trap (user initiated), or
a fault?  The
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
will need to start processing instructions from a new location in the
instruction stream–that of the interrupt service routine (ISR).
The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
handles this condition by flushing the pipeline on any change of interrupt
status.
The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> is also unique in that the
interrupt address is kept within an alternate register set.  (See the <a href="https://github.com/ZipCPU/zipcpu/blob/master/doc/spec.pdf">ZipCPU
specification</a>
for details.</p>

<p>Indeed, lots of things need to change within the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
every time it switches to an interrupt context, or back again.
If you want to trace this logic, feel free to
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">look for</a>
the <code class="highlighter-rouge">w_switch_to_interrupt</code> and <code class="highlighter-rouge">w_release_from_interrupt</code> wires.  The first
will be true any time the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
switches to an interrupt context, the second will be true anytime the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
switches back.</p>

<p>Now, with all that as background, we can discuss the logic necessary to handle
a pipeline handshake.</p>

<h2 id="cpu-handshake">CPU Handshake</h2>

<table style="float: right"><caption>Fig 3: ZipCPU Pipeline Signals</caption><tr><td><img src="/img/pipeline-blocks-cpu.svg" alt="ZipCPU Pipeline Signals" width="380" /></td></tr></table>

<p>The
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
pipeline is controlled primarily with three logic signals per stage:
<code class="highlighter-rouge">stalled</code>, <code class="highlighter-rouge">valid</code>, and <code class="highlighter-rouge">CE</code>, as shown in Fig 3 to the right.  The logic is
designed around the idea of processing the data from the previous stage any
time a <code class="highlighter-rouge">CE</code> line is set.  The basic logic is this: if a stage is not stalled,
and if the previous stage is valid, then the <code class="highlighter-rouge">CE</code> line will be set.  The <code class="highlighter-rouge">CE</code>
control signal is used to determine when to clock the data from the last stage
forward.</p>

<p>Let’s walk though that for a moment.</p>

<p>First, each stage has a condition (or set of conditions) that might stall the
prior stage from entering this stage.  This is the stall logic for this stage.</p>

<p>For example, the read operands stage will stall any time the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
is already busy, the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v">memory
unit</a> is busy
with a read, or the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a> is busy.
The lines <code class="highlighter-rouge">alu_busy</code>, <code class="highlighter-rouge">mem_busy</code>, and <code class="highlighter-rouge">div_busy</code> are used to capture these
conditions.  An exception is made if the memory unit is busy <em>writing</em> a value
over the bus.  In this case, <code class="highlighter-rouge">mem_rdbusy</code> captures the idea that the memory
is busy with a read and not a write.  Likewise, the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
will also stall if the external halt request line is true.  (We’ll come back and
discuss this when discussing how to debug a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> later.)
Another, less common, example is that the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
will stall any time the condition codes are written to manually–lest the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
write a value back according to the wrong conditions.</p>

<p>In general, though, the stall logic looks like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">assign	stage[n]_stalled = (stage[n]_valid)&amp;&amp;((stage[n+1]_stalled)
		||(things that would stall this stage));</code></pre></figure>

<p>In this case, I’m using <code class="highlighter-rouge">stage[n]_stalled</code> to describe the <code class="highlighter-rouge">stalled</code> variable
for this stage.  If you look within the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>,
you’ll find variables named <code class="highlighter-rouge">pf_stalled</code>, <code class="highlighter-rouge">dcd_stalled</code>, <code class="highlighter-rouge">op_stalled</code>,
<code class="highlighter-rouge">alu_stalled</code>, and <code class="highlighter-rouge">mem_stalled</code>.  These variables capture this
logic, together with all of the more obscure reasons why the <code class="highlighter-rouge">stalled</code> line
might be made true as well–such as on a debugging <code class="highlighter-rouge">BREAK</code> instruction.</p>

<p>Second, if any stage is not stalled, and if the prior stage has valid data
within it, then we can step that stage forward.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">assign	stage[n]_ce = (stage[n-1]_valid)&amp;&amp;(!stage[n]_stalled);</code></pre></figure>

<p>If you pay close attention, you might find this looks a lot like the
handshake signal, <code class="highlighter-rouge">(i_ce)&amp;&amp;(!o_busy)</code>, that we discussed in our <a href="/blog/2017/08/14/strategies-for-pipelining.html">last post on
pipelining</a>.</p>

<p>Inside the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>,
these various pipeline variables are named
<code class="highlighter-rouge">dcd_ce</code>, <code class="highlighter-rouge">op_ce</code>, <code class="highlighter-rouge">alu_ce</code>, <code class="highlighter-rouge">mem_ce</code>, and <code class="highlighter-rouge">div_ce</code>.  There’s also a similar
<code class="highlighter-rouge">master_ce</code> which is controlled from the external debugging interface–something
we’ll get to later.</p>

<p>With these signals out of the way, we can start working through the pipeline
signals.  The first registered signal is the <code class="highlighter-rouge">valid</code> signal.  This signal
indicates whether or not a particular stage has valid data within it.
To get valid data into a stage, the prior stage must have valid data, and
this stage cannot be stalled.  Hence, we have the following logic:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	// On any reset or clear pipeline, we clear the stage valid
	// register
	if ((i_reset)||(clear_pipeline))
	begin
		stage[n]_valid &lt;= 1'b0;
	end if (stage[n]_ce)
	begin
		// Otherwise, we accept the data from the previous
		// stage, and operate upon it if necessary.
		stage[n]_valid &lt;= stage[n-1]_valid;
	end else if (stage[n+1]_ce)
		// If there's nothing valid to come in, but the next stage
		// has taken our data, then we are no longer valid here anymore.
		stage[n]_valid &lt;= 1'b0;</code></pre></figure>

<p>Within the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>,
the basic valid registers are called <code class="highlighter-rouge">pf_valid</code>, <code class="highlighter-rouge">dcd_valid</code>, <code class="highlighter-rouge">op_valid</code>.
The <code class="highlighter-rouge">op_valid</code> signal is also broken into three separate signals, depending
upon which stage the read operands stage moves to next:
<code class="highlighter-rouge">op_valid_alu</code>, <code class="highlighter-rouge">op_valid_mem</code>, and  <code class="highlighter-rouge">op_valid_div</code>.  Finally, the output
of the ALU/MEM/DIV stage is captured by the <code class="highlighter-rouge">alu_valid</code>, <code class="highlighter-rouge">mem_valid</code>, and
<code class="highlighter-rouge">div_valid</code> signals.  Indeed, these signals are used to determine whether
or not valid data is ready to be written back.</p>

<p>One particular difficulty with this language is the idea of an illegal
instruction.  Within the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>,
a stage containing an illegal instruction has the <code class="highlighter-rouge">valid</code> line set high.
This is because an illegal instruction needs to be processed like any other
instruction, and the <code class="highlighter-rouge">valid</code> line controls when processing moves forward.
The alternative, moving instructions forward any time <code class="highlighter-rouge">valid</code> <em>or</em>
<code class="highlighter-rouge">illegal</code> were true, just costs more logic than required.</p>

<p>Each stage has many more logic lines beyond the ones we just discussed.
These can often be treated in a much simpler fashion, though.  As a result,
these other signals are often sate based upon the simple <code class="highlighter-rouge">stage[n]_ce</code> signal:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	if (stage[n]_ce)
		stage[n]_data &lt;= ... // function of stage[n-1]_data</code></pre></figure>

<p>Those are the basics of how the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
handles pipelining.  Be aware, though, <em>the devil is in the details</em>.
There are all kinds of pipeline hazards that you may not expect when first
building a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.</p>

<p>My best advice for others, when trying to find these pipeline problems, is
to methodically debug your
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
using
<a href="https://www.veripool.org/wiki/verilator">Verilator</a> and some small programs.
Use <a href="https://gcc.gnu.org">GCC</a>
both all optimizations turned on, as well as with all
optimizations turned off.  The two environments create very different pipeline
environments, and programs working in the one may not work in the other.  My
second piece of advice would be to create a program containing every pipeline
hazard you can think of, and to turn this program into a test program for the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
You can find the <a href="https://github.com/ZipCPU/zipcu">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/openarty/blob/master/sw/board/cputest.c">CPU testing
program</a>
within the <a href="https://github.com/ZipCPU/openarty">OpenArty</a> distribution.</p>

<h2 id="demonstration">Demonstration</h2>

<p>I have a wonderful demonstration of all of this that I would like to post, but
to see it I may need some help from my readers.</p>

<p>Specifically, the demonstration involves building the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> distribution, and then running the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/asm/simtest.s">simtest</a>
program within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/zipcpu_tb.cpp">simulator</a>.</p>

<p>The <a href="https://github.com/ZipCPU/zipcpu/blob/master/sim/verilated/zipcpu_tb.cpp">simulator</a>
allows you to watch how well the pipeline is filled at any given clock, as
well as the ability to “watch” the signals discussed above.  Further, by
adjusting the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/cpudefs.v">pipeline
parameters</a>,
you can see how the pipeline and
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>
are affected as the logic within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">CPU</a>,
is increased or decreased.  Indeed, you can watch the <code class="highlighter-rouge">valid</code>, <code class="highlighter-rouge">CE</code>, and
<code class="highlighter-rouge">stall</code> lines as they get set and adjusted on a clock by clock basis.</p>

<p>Nominally, the instructions to do this would require something like:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Install packages necessary to build the simulator</span>
sudo apt-get install bc verilator
<span class="c"># Install packages necessary to build GCC</span>
sudo apt-get install flex bison libncurses5-dev
sudo apt-get install libmpfr-dev libmpc-dev libgmp-dev libmpfr-doc
<span class="c"># Install libelf.  libelf is used to load executable files into both</span>
<span class="c"># the simulator and onto any actual FPGA H/W</span>
sudo apt-get install libelf-dev
<span class="c">#</span>
git clone https://github.com/ZipCPU/zipcpu
<span class="nb">cd </span>zipcpu
make
<span class="k">if</span> <span class="o">[[</span> ! -x sw/install/cross-tools/bin/zip-gcc <span class="o">]]</span>;
<span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"GCC failed to build"</span>
<span class="k">else
  if</span> <span class="o">[[</span> ! -x sim/verilator/zipsys_tb <span class="o">]]</span>;
  <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"The simulator failed to build"</span>
  <span class="k">else
    </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/sw/install/cross-tools/bin/zip-gcc
    <span class="nb">cd </span>bench/asm
    make simtest
    <span class="nb">cd</span> ../../sim/verilator
    <span class="c"># Run the demo</span>
    zipsys_tb ../../bench/asm/simtest
    <span class="c"># Press the 't' key to create a system clock 'tick's until things stop</span>
    <span class="c">#   changing</span>
    <span class="c">#   Watch how instructions work their way through the various pipeline</span>
    <span class="c">#   stages at the bottom of the screen</span>
    <span class="c"># 'q' can be used to quit.</span>
    <span class="c"># 'r' can be used to 'reboot' the computer, and start the simulation over</span>
  <span class="k">fi
fi</span></code></pre></figure>

<p>This is notional only, the above script has not been “tested” … but I think
it captures the idea of what I would have you do.</p>

<p>My specific problem is that, while the design works nicely on my own system,
I’d love to have some help from others who would like to try running the
design on their own systems–so as to get some redundance across operating
systems and version differences.  If you are interested in trying this,
please write be at the address below if you have problems, or perhaps
just to tell me of your success.  Enough successes, and I’ll write a more
complete post about how to watch the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
pipeline in action.</p>

<p>(Instructions for installing the prerequisites on a Windows machine, using
<a href="https://cygwin.com">Cygwin</a>, can be found
<a href="/blog/2017/07/28/cygwin-fpga.html">here</a>)</p>

<h2 id="conclusion">Conclusion</h2>

<p>That’s it!  The
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
basically uses the <a href="/blog/2017/08/14/strategies-for-pipelining.html">handshake
approach</a>
to handling pipeline stalls that <a href="/blog/2017/08/14/strategies-for-pipelining.html">we discussed
earlier</a>.
A couple extra variables for logic expression allow the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
to be able to detect and respond appropriately to pipeline hazards, stalling the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
anytime it is necessary to do so.</p>

<p>Now that we’ve gone through this example, I’d like to come back and discuss
how to debug a <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
running within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
in general.  That post has been mostly written for some time, but has been
waiting for this background beneath it to be explained.</p>

<p>I’d also like to post more complete instructions for the pipeline demonstration
above, outlining how data moves through the
various stages of the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
pipeline.  I’ll hold off on the demonstration, post, until I have some
confidence that it will work on the greatest number of computers.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For I know that my redeemer liveth, and that he shall stand at the latter day upon the earth (Job 19:25)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
