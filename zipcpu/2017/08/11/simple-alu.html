<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A Simple ALU, drawn from the ZipCPU</title>
  <meta name="description" content="Many digital logic design courses end with a discussion of how to build aCPU.The common lesson tends to focus on the arithmetic logic unit(ALU) as the work h...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2017/08/11/simple-alu.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">A Simple ALU, drawn from the ZipCPU</h1>
    <p class="post-meta"><time datetime="2017-08-11T00:00:00-04:00" itemprop="datePublished">Aug 11, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Many digital logic design courses end with a discussion of how to build a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
The common lesson tends to focus on the <a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">arithmetic logic unit
(ALU)</a> as the work horse
within the center of the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.</p>

<p>Since <a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">ALU</a>s
tend to be very simple, they are easy to look at and examine.</p>

<p>For this post, we’ll look at the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
found within the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>.
Unlike many of the “classroom”
<a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">ALU</a>s
you may have come across, this simple
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
is also complete enough to support the
<a href="https://sourceware.org/newlib">newlib C library</a>.
As a result, you might find a couple of features within this
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
that you are not expecting.</p>

<h2 id="a-basic-alu">A Basic ALU</h2>

<p>If you’ve never seen how to build an
<a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">ALU</a>
before, the logic to build one is actually very simple.  It’s basically
a big huge case statement that selects from among several possible outputs.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">case</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
	<span class="mb">4'b0000</span><span class="o">:{</span><span class="n">c</span><span class="p">,</span><span class="n">o_c</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="mb">1'b0</span><span class="p">,</span><span class="n">i_a</span><span class="o">}-{</span><span class="mb">1'b0</span><span class="p">,</span><span class="n">i_b</span><span class="o">}</span><span class="p">;</span><span class="c1">// SUB</span>
	<span class="mb">4'b0001</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">i_a</span> <span class="o">&amp;</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// And</span>
	<span class="mb">4'b0010</span><span class="o">:{</span><span class="n">c</span><span class="p">,</span><span class="n">o_c</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="n">i_a</span> <span class="o">+</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// Add</span>
	<span class="mb">4'b0011</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">i_a</span> <span class="o">|</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// Or</span>
	<span class="mb">4'b0100</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">i_a</span> <span class="o">^</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// Xor</span>
	<span class="c1">// ....</span>
	<span class="nl">default:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// MOV, LDI</span></code></pre></figure>

<p>In this example, taken from the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>, the
two inputs, <code class="language-plaintext highlighter-rouge">i_a</code> and <code class="language-plaintext highlighter-rouge">i_b</code>, are both 32-bit values.  The input to the
routine also includes a number, <code class="language-plaintext highlighter-rouge">i_op</code>, identifying the operation that
needs to be calculated.  The result is placed into an output register, <code class="language-plaintext highlighter-rouge">o_c</code>.
The <code class="language-plaintext highlighter-rouge">c</code> bit you see above is associated with the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>’s carry logic–something we’ll
come back to later in this post.</p>

<p>Structurally, within an FPGA, the logic looks like Fig 1 below.</p>

<table style="float: left"><caption>Fig 1: ALU Hardware Structure</caption><tr><td><img src="/img/alu-simple.svg" alt="ALU Structure" width="400" /></td></tr></table>

<p>Each of the blocks in this figure takes up logic when implemented within
hardware.  As a result, even if <code class="language-plaintext highlighter-rouge">i_op</code> requests that the two values be
subtracted, all of the other operations (addition, and, or, xor, etc.) will
still be calculated.  These other results, though, are just ignored.  Thus,
on the final clock of the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>,
<em>all</em> of the operations have been calculated, but <em>only</em> the result of
the selected operation is stored into the output register.</p>

<p>So that’s what an <a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">ALU</a>
looks liike in general.  Let’s now turn our attention to the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>.</p>

<h2 id="the-zipcpu-alu">The ZipCPU ALU</h2>

<p>The actual case statement within the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
has sixteen operations that the instruction selects from among, not just the
six shown above.  In this section,
we’ll look at all of that logic save the multiply.  (Although the multiply
takes up most of the code space within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">cpuops.v</a>
file, it doesn’t fit into this lesson very well.)  Put together, the full
case statement for the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
looks like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">c</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">)</span>
	<span class="mb">4'b0000</span><span class="o">:{</span><span class="n">c</span><span class="p">,</span><span class="n">o_c</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="mb">1'b0</span><span class="p">,</span><span class="n">i_a</span><span class="o">}-{</span><span class="mb">1'b0</span><span class="p">,</span><span class="n">i_b</span><span class="o">}</span><span class="p">;</span><span class="c1">// CMP/SUB</span>
	<span class="mb">4'b0001</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">i_a</span> <span class="o">&amp;</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// BTST/And</span>
	<span class="mb">4'b0010</span><span class="o">:{</span><span class="n">c</span><span class="p">,</span><span class="n">o_c</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="n">i_a</span> <span class="o">+</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// Add</span>
	<span class="mb">4'b0011</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">i_a</span> <span class="o">|</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// Or</span>
	<span class="mb">4'b0100</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">i_a</span> <span class="o">^</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// Xor</span>
	<span class="mb">4'b0101</span><span class="o">:{</span><span class="n">o_c</span><span class="p">,</span><span class="n">c</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="n">w_lsr_result</span><span class="p">[</span><span class="mi">32</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// LSR</span>
	<span class="mb">4'b0110</span><span class="o">:{</span><span class="n">c</span><span class="p">,</span><span class="n">o_c</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="n">w_lsl_result</span><span class="p">[</span><span class="mi">32</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// LSL</span>
	<span class="mb">4'b0111</span><span class="o">:{</span><span class="n">o_c</span><span class="p">,</span><span class="n">c</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="n">w_asr_result</span><span class="p">[</span><span class="mi">32</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// ASR</span>
	<span class="mb">4'b1000</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">w_brev_result</span><span class="p">;</span>	<span class="c1">// BREV</span>
	<span class="mb">4'b1001</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">i_a</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">16</span><span class="p">],</span> <span class="n">i_b</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span> <span class="c1">// LODILO</span>
	<span class="mb">4'b1010</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">mpy_result</span><span class="p">[</span><span class="mi">63</span><span class="o">:</span><span class="mi">32</span><span class="p">];</span>	<span class="c1">// MPYHU</span>
	<span class="mb">4'b1011</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">mpy_result</span><span class="p">[</span><span class="mi">63</span><span class="o">:</span><span class="mi">32</span><span class="p">];</span>	<span class="c1">// MPYHS</span>
	<span class="mb">4'b1100</span><span class="o">:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">mpy_result</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// MPY</span>
	<span class="nl">default:</span>   <span class="n">o_c</span>   <span class="o">&lt;=</span> <span class="n">i_b</span><span class="p">;</span>		<span class="c1">// MOV, LDI</span>
	<span class="k">endcase</span>
<span class="k">end</span> <span class="k">else</span> <span class="c1">// if (mpydone)</span>
	<span class="c1">// set the carry based upon a multiply result</span>
	<span class="n">o_c</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">mpyhi</span><span class="p">)</span><span class="o">?</span><span class="n">mpy_result</span><span class="p">[</span><span class="mi">63</span><span class="o">:</span><span class="mi">32</span><span class="p">]</span><span class="o">:</span><span class="n">mpy_result</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span></code></pre></figure>

<p>Let’s walk through each of these operations.</p>

<p>The first operation, <code class="language-plaintext highlighter-rouge">4'h0</code> supports either a compare or a subtract
instruction.  This instruction subtracts two numbers in order to produce its
result.  The difference between the <code class="language-plaintext highlighter-rouge">CMP</code> and <code class="language-plaintext highlighter-rouge">SUB</code> instructions is that the
compare doesn’t write the results back to any registers in the end while the
subtract does–but since that’s external to the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
implementation, you won’t see that difference here.</p>

<p>You may notice that the subtract that is taking place is a 33-bit subtract
rather than a 32-bit subtract.  The reason for this is the carry, <code class="language-plaintext highlighter-rouge">c</code>, bit.
In the case of a subtract, this bit will be true if <code class="language-plaintext highlighter-rouge">i_b</code> had to <em>borrow</em>
from the (unspecified) high order bit in order to complete.  We’ll discuss
this flag in more detail further down.</p>

<p>The <code class="language-plaintext highlighter-rouge">TST</code> and <code class="language-plaintext highlighter-rouge">AND</code> instructions are similar to the <code class="language-plaintext highlighter-rouge">CMP</code> and <code class="language-plaintext highlighter-rouge">SUB</code>
instructions.  If the operation is an <code class="language-plaintext highlighter-rouge">AND</code>, then both the result
and the flags will be set during writeback, whereas only the flags are set in
the case of the <code class="language-plaintext highlighter-rouge">TST</code> operation.  Again, this difference is external to the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
implementation itself.</p>

<p>The <code class="language-plaintext highlighter-rouge">ADD</code>, <code class="language-plaintext highlighter-rouge">OR</code>, and <code class="language-plaintext highlighter-rouge">XOR</code> instructions should need no further explanation.
(<a href="https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation">XOR Ref</a>)
The <code class="language-plaintext highlighter-rouge">c</code> bit is set on the <code class="language-plaintext highlighter-rouge">ADD</code>, though, if the result of adding unsigned
<code class="language-plaintext highlighter-rouge">i_a</code> to <code class="language-plaintext highlighter-rouge">i_b</code> overflows 32-bits.  This bit then makes it possible to string
32-bit additions together to create a 64-bit or larger operation.</p>

<p>The shift instruction(s) needs some additional discussion.  The <a href="https://en.wikipedia.org/wiki/Logical_shift">logical
shift</a> left, or <code class="language-plaintext highlighter-rouge">LSL</code>, is
what the compiler creates from an <code class="language-plaintext highlighter-rouge">A = B &lt;&lt; C</code> instruction.  The result is
created by shifting all of the bits in <code class="language-plaintext highlighter-rouge">B</code> to the left by one and filling
the results in with zeros.
The <a href="https://en.wikipedia.org/wiki/Logical_shift">logical shift</a>
right, or <code class="language-plaintext highlighter-rouge">LSR</code>, comes from an <code class="language-plaintext highlighter-rouge">A = B &gt;&gt; C</code> instruction in C, but only when
<code class="language-plaintext highlighter-rouge">B</code> is unsigned.  In this case, all the bits shift to the right and the
upper bits are filled in with zeros.</p>

<p>If <code class="language-plaintext highlighter-rouge">B</code> is signed, however, the compiler will create an
<a href="https://en.wikipedia.org/wiki/Arithmetic_shift">arithmetic shift</a>
right, <code class="language-plaintext highlighter-rouge">ASR</code>, instruction instead.  The <code class="language-plaintext highlighter-rouge">ASR</code> is similar to the <code class="language-plaintext highlighter-rouge">LSR</code>
instruction with one exception: the <code class="language-plaintext highlighter-rouge">ASR</code> instruction propagates the high order
bit during the shift.  Hence the incoming <code class="language-plaintext highlighter-rouge">i_a[31]</code> will always set the
outgoing <code class="language-plaintext highlighter-rouge">o_c[31]</code> bit.  So while
<a href="https://en.wikipedia.org/wiki/Logical_shift">logically shifting</a> a
<code class="language-plaintext highlighter-rouge">32'hffff_fffe</code> to the right by one bit will create a <code class="language-plaintext highlighter-rouge">32'7fff_ffff</code>,
<a href="https://en.wikipedia.org/wiki/Arithmetic_shift">arithmetically shifting</a> a
<code class="language-plaintext highlighter-rouge">32'hffff_fffe</code> to the right by one bit will create a <code class="language-plaintext highlighter-rouge">32'hffff_ffff</code>.
The sign bit, <code class="language-plaintext highlighter-rouge">i_a[31]</code> propagates on an <code class="language-plaintext highlighter-rouge">ASR</code>.</p>

<p>Where things get interesting is what happens when you shift farther than
the number of bits in a register.  For example, what should be the result of
<code class="language-plaintext highlighter-rouge">32'h0000_ffff</code> when shifted left by 32?  <code class="language-plaintext highlighter-rouge">32'h0000_0000</code>, right?  Sure.  Now
what happens when you shift left by 34 bits?  Some
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
examine only the lower 5 bits of the shift amount, and require the compiler
to make certain the shift is within bounds.  The
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>,
however, examines all 32-bits of the shift request contained in <code class="language-plaintext highlighter-rouge">i_b</code>.
Hence, any attempt to logically shift more than 32-bits on the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> results in a zero.</p>

<p>The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
handles shifts with one further difference that isn’t necessarily
used by the compiler: the carry bit is set to the last bit shifted off the
register.</p>

<p>Now that all that is said, the <code class="language-plaintext highlighter-rouge">LSR</code> logic is given by:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>  <span class="n">w_lsr_result</span> <span class="o">=</span>
	<span class="c1">// Check if the shift amount will overflow, return 33'h00 if it does</span>
	<span class="p">((</span><span class="o">|</span><span class="n">i_b</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">6</span><span class="p">])</span><span class="o">||</span><span class="p">(</span><span class="n">i_b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_b</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)))</span><span class="o">?</span> <span class="mh">33'h00</span>
	<span class="c1">// On a shift of 32 exactly, keep i_a[31] in the carry</span>
				<span class="o">:</span><span class="p">((</span><span class="n">i_b</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="o">?{</span><span class="mh">32'h0</span><span class="p">,</span><span class="n">i_a</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span><span class="o">}</span>
	<span class="c1">// Otherwise just shift the results by i_b</span>
				<span class="o">:</span> <span class="p">(</span> <span class="o">{</span> <span class="n">i_a</span><span class="p">,</span> <span class="mb">1'b0</span> <span class="o">}</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i_b</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span> <span class="p">));</span><span class="c1">// LSR</span></code></pre></figure>

<p>The logic for the <code class="language-plaintext highlighter-rouge">LSL</code> and <code class="language-plaintext highlighter-rouge">ASR</code> instructions is quite similar.</p>

<p>A second unique
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
instruction is the <a href="https://en.wikipedia.org/wiki/Bit-reversal_permutation">bit
reverse</a> instruction,
<code class="language-plaintext highlighter-rouge">BREV</code>.  This is a zero cost instruction that does nothing but re-order the
wires from the <code class="language-plaintext highlighter-rouge">i_b</code> input:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">genvar</span>	<span class="n">k</span><span class="p">;</span> <span class="k">generate</span>
<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">begin</span> <span class="o">:</span> <span class="n">bit_reversal_cpuop</span>
	<span class="k">assign</span> <span class="n">w_brev_result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_b</span><span class="p">[</span><span class="mi">31</span><span class="o">-</span><span class="n">k</span><span class="p">];</span>
<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>This particular instruction is not found in other
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s.
It was placed into the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> in order to support the
<a href="https://en.wikipedia.org/wiki/Bit-reversal_permutation">bit reversed</a>
addressing required by a <a href="https://en.wikipedia.org/wiki/Cooley-Tukey_FFT_algorithm">Fast Fourier
transform</a>.
It has since become integral to the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>’s instruction set.  Here’s why:</p>

<p>Every <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
needs an ability to load a value with as many bits as a register into
a register.  That is to say, a 32-bit
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
needs the ability to load a 32-bit immediate value into a 32-bit
register–<a href="https://www.gnu.org/software/binutils">binutils</a>, and particularly
the linker within
it, requires this capability.  Since instructions are 32-bits wide, you can’t
fit both an instruction and a 32’bit value into the same instruction.  While
the <a href="https://en.wikipedia.org/wiki/X86">x86</a> solved this problem by storing
the 32’bit value directly in the instruction stream following this instruction,
this risks mis-aligning the instruction stream and therefore adding
complication to the instruction decoder.  To avoid this extra complication,
<a href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">RISC</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
tend to handle this problem with a two instruction load: the first instruction
loads the upper half of the register, while the second instruction loads
the lower half of the register.</p>

<p>In the case of the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>,
the <code class="language-plaintext highlighter-rouge">BREV</code> instruction is the first instruction in this pair–it can be used to
load the upper 18-bits of a register.  The other instruction, shown in the
code above as <code class="language-plaintext highlighter-rouge">LDILO</code> (load immediate into lower 16-bits), loads the lower
16-bits of any 32-bit value.  <a href="https://gcc.gnu.org">GCC</a> requires that neither
of these operations affect the flags, something we can come back and discuss
another time.  Together, these two instructions allow the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
to load <em>any</em> 32-bit immediate value into a register.  Since the extra cost
of <a href="https://en.wikipedia.org/wiki/Bit-reversal_permutation">bit reversing</a>
a 32-bit value is handled by the
<a href="https://www.gnu.org/software/binutils">assembler and linker</a> (there’s no
hardware cost for doing this), there’s no performance penalty to the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> for having this instruction.</p>

<p>That leaves two pieces of logic we haven’t discussed within the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>.
The first is the flag generation logic which we will come to next.  The
other piece of logic within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
that we haven’t discussed is the multiply.  The multiply logic in the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">cpuops.v</a>
file is particularly complicated for the sole reason that the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
can support a 32x32-bit multiply across a wide variety of hardware
architectures.  Some of these architectures can do a multiply in a single
clock, while other FPGAs require two, three, or even four clocks to execute a
multiply.</p>

<p>Let’s look at calculating the flags next.</p>

<h2 id="the-flags-results">The Flags Results</h2>

<p>The <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
creates and outputs a set of flags from the operation.  Many instructions will
cause these to be placed into the <a href="https://en.wikipedia.org/wiki/Status_register">condition codes
register</a>.
The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
supports all four of the common condition codes, or flags as we’ll call them
here: <code class="language-plaintext highlighter-rouge">Z</code> (zero), <code class="language-plaintext highlighter-rouge">C</code> (carry), <code class="language-plaintext highlighter-rouge">N</code> (negative) and <code class="language-plaintext highlighter-rouge">V</code> (overflow).</p>

<p>The <code class="language-plaintext highlighter-rouge">Z</code> flag is set whenever the result is zero:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">o_c</span> <span class="o">==</span> <span class="mh">32'h0000</span><span class="p">);</span></code></pre></figure>

<p>The compiler uses this flag whenever two numbers need to be tested and compared
for equality.</p>

<p>The <code class="language-plaintext highlighter-rouge">C</code> or “carry” flag was set above whenever an addition or subtraction
required a carry.  I also mentioned above how the carry flag on the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
is also set for shift operations.  All other operations clear the carry flag.</p>

<p>The compiler uses this flag whenever two numbers need to be tested and compared
for an unsigned <em>less than</em>, or whenever an extended 64-bit addition (or
subtraction) needs to be carried out.  (Unlike many other
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
doesn’t have either “add with carry” or “subtract with carry” instructions.)</p>

<p>The <code class="language-plaintext highlighter-rouge">N</code> flag is perhaps the simplest to discuss.  This is set whenever the
sign bit is set on the output:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">o_c</span><span class="p">[</span><span class="mi">31</span><span class="p">]);</span></code></pre></figure>

<p>Well, not quite.</p>

<p>It turns out that there’s an ugly problem associated with setting the <code class="language-plaintext highlighter-rouge">N</code>
flag to the outgoing sign bit.  Specifically,
if you wish to compare whether or not <code class="language-plaintext highlighter-rouge">A&lt;B</code> when <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> are large and
signed then <code class="language-plaintext highlighter-rouge">o_c[31]</code> isn’t sufficient.  To do this comparison, the <code class="language-plaintext highlighter-rouge">CMP</code>
instruction will enter the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
via a subtract, <code class="language-plaintext highlighter-rouge">A-B</code>.  The result of this subtraction will then be checked
to determine whether or not the result is less than zero.  However, if the
result overflows the sign bit, then you still want to continue to set the
<code class="language-plaintext highlighter-rouge">N</code> flag appropriately.  If you don’t, then <code class="language-plaintext highlighter-rouge">32'h8000_0000</code> won’t be less
than <code class="language-plaintext highlighter-rouge">32'h7fff_ffff</code>.</p>

<p>As proof, consider what happens on a subtraction overflow:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">  32'h7fff_ffff ( 2^(31)-1)
- 32'h8000_0000 (-2^(31)  )
---------------
= 32`hffff_ffff</code></pre></figure>

<p>The result of this subtraction <em>should</em> be a positive <code class="language-plaintext highlighter-rouge">2^(32)-1</code>.  However,
since an overflow took place, the MSB no longer reflects the correct sign.
We’re going to need to adjust <code class="language-plaintext highlighter-rouge">N</code> therefore to reflect that this result is
positive and not negative.</p>

<p>While there may be a simpler way, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a>
solves this problem in three steps.  The first is to keep track of
the original sign of <code class="language-plaintext highlighter-rouge">i_a</code> in a register called <code class="language-plaintext highlighter-rouge">pre_sign</code>.  The second part
is to determine if that sign needs to be kept on an overflow.
Then, on any overflow, the sign is flipped when determining <code class="language-plaintext highlighter-rouge">N</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span> <span class="c1">// 1 LUT</span>
	<span class="k">begin</span>
		<span class="n">pre_sign</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_a</span><span class="p">[</span><span class="mi">31</span><span class="p">]);</span>
		<span class="n">keep_sgn_on_ovfl</span><span class="o">&lt;=</span>
			<span class="p">(((</span><span class="n">i_op</span><span class="o">==</span><span class="mh">4'h0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_a</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i_b</span><span class="p">[</span><span class="mi">31</span><span class="p">]))</span><span class="c1">//SUB&amp;CMP</span>
			<span class="o">||</span><span class="p">((</span><span class="n">i_op</span><span class="o">==</span><span class="mh">4'h2</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_a</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">==</span> <span class="n">i_b</span><span class="p">[</span><span class="mi">31</span><span class="p">])));</span> <span class="c1">// ADD</span>
	<span class="k">end</span>

<span class="k">assign</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">o_c</span><span class="p">[</span><span class="mi">31</span><span class="p">])</span>
	<span class="o">^</span> <span class="p">((</span><span class="n">keep_sgn_on_ovfl</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">pre_sign</span> <span class="o">!=</span> <span class="n">o_c</span><span class="p">[</span><span class="mi">31</span><span class="p">]));</span></code></pre></figure>

<p>When to keep a sign on overflow needs a touch more explanation:</p>

<ol>
  <li>
    <p>If you add two values with the same sign, then the result should also
have the same sign regardless of any overflow.  Hence, two positive numbers
should yield a positive result in spite of any overflow.  In this case,
the sign should be given by <code class="language-plaintext highlighter-rouge">i_a</code>’s sign, captured here in <code class="language-plaintext highlighter-rouge">pre_sign</code>.</p>
  </li>
  <li>
    <p>The same is true of subtract, save only that the sign needs to be
preserved any time the initial values have opposite signs.  In particular,
if you negate the second value, a subtract becomes the same as an addition,
and then the addition rule above applies again.</p>
  </li>
</ol>

<p>Now, if the sign changes but yet was supposed to be kept, then the resulting
<code class="language-plaintext highlighter-rouge">N</code> flag needs to be swapped–hence the
<a href="https://en.wikipedia.org/wiki/Exclusive_or">exclusive OR</a>
in the code above.</p>

<p>The <code class="language-plaintext highlighter-rouge">N</code> bit is used by the compiler to test whether or not <code class="language-plaintext highlighter-rouge">i_a &lt; i_b</code> when
both numbers are signed.  By preserving the meaning of this bit in spite
of overflow, the compiler does what you would expect it to do–even when
comparing large numbers.</p>

<p>The final flag bit, the overflow or <code class="language-plaintext highlighter-rouge">V</code> bit, requires a touch more logic
as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span> <span class="c1">// 1 LUT</span>
		<span class="n">set_ovfl</span><span class="o">&lt;=</span><span class="p">(((</span><span class="n">i_op</span><span class="o">==</span><span class="mh">4'h0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_a</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i_b</span><span class="p">[</span><span class="mi">31</span><span class="p">]))</span><span class="c1">//SUB&amp;CMP</span>
			<span class="o">||</span><span class="p">((</span><span class="n">i_op</span><span class="o">==</span><span class="mh">4'h2</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_a</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">==</span> <span class="n">i_b</span><span class="p">[</span><span class="mi">31</span><span class="p">]))</span> <span class="c1">// ADD</span>
			<span class="o">||</span><span class="p">(</span><span class="n">i_op</span> <span class="o">==</span> <span class="mh">4'h6</span><span class="p">)</span> <span class="c1">// LSL</span>
			<span class="o">||</span><span class="p">(</span><span class="n">i_op</span> <span class="o">==</span> <span class="mh">4'h5</span><span class="p">));</span> <span class="c1">// LSR</span></code></pre></figure>

<p>The <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
sets the overflow flag on one of four conditions:</p>

<ol>
  <li>
    <p>If this is an addition, and the signs of both operands are the same, then
the result should be positive and the overflow bit will be set if the
signs don’t match.</p>

    <p>This alone is almost identical to the <code class="language-plaintext highlighter-rouge">N</code> logic above.</p>
  </li>
  <li>
    <p>The second case is the case for the subtract.  If the incoming signs are
identical, and the outgoing sign is different, then the overflow bit
needs to be set.  This is also very similar to the <code class="language-plaintext highlighter-rouge">N</code> logic above.</p>
  </li>
  <li>
    <p>The last two cases regard shifts.  In particular, the
<a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>
sets the overflow if either of the <a href="https://en.wikipedia.org/wiki/Logical_shift">logical
shift</a>
instructions changes the sign of the output.</p>
  </li>
</ol>

<p>Put together, this yields the following logic for the <code class="language-plaintext highlighter-rouge">V</code> bit:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">set_ovfl</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">pre_sign</span> <span class="o">!=</span> <span class="n">o_c</span><span class="p">[</span><span class="mi">31</span><span class="p">]);</span></code></pre></figure>

<p>Since the C language doesn’t have a way to test for overflow within the
language, this flag has gone largely unused.  Further, the compiler support
for overflow checking for those other languages that do use it hasn’t
been implemented yet.</p>

<h2 id="conclusion">Conclusion</h2>

<p>That’s basically how an
<a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">ALU</a>
works: it’s a series of operations whose output is selected via a case
statement.  While every
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
will support different instructions, at some level all
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
will have a case statement selecting between various operations within them.</p>

<p>In the case of a <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
with a <a href="https://en.wikipedia.org/wiki/Status_register">condition codes
register</a>.
such as the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>, these codes are also
easily calculated within the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/cpuops.v">ALU</a> as well.</p>

<p>Turning a simple <a href="https://en.wikipedia.org/wiki/Arithmetic_logic_unit">ALU</a>
into a full blown <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
such as the <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a>,
takes a bit more work than we presented above.  In fact, it takes a <em>lot</em>
more work.  Let’s consider that a good thing, though, because it will give
us something to learn on another day.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>In all thy ways acknowledge him, and he shall direct thy paths. (Prov 3:6)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
