<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Bus Select Lines</title>
  <meta name="description" content="In a previous post, I discussed how to build a simple wishbone busslave.  That posteliminated a lot of the bus lines so as to make building a simple bus slav...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zipcpu.com/zipcpu/2017/05/29/select-lines.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="http://zipcpu.com/feed.xml">
</head>


  <body>

    <header class="site-header">
  <div id="banner">
  <a href="/about/"><picture>
    <img height=120 src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>
<li><a HREF="/about/">About Us</a>
<li><a HREF="/projects.html">Some Projects</a>
<li><a HREF="/topics.html">Coming Topics</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Bus Select Lines</h1>
    <p class="post-meta"><time datetime="2017-05-29T00:00:00-04:00" itemprop="datePublished">May 29, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>In a previous post, I discussed how to build a <a href="/zipcpu/2017/05/29/simple-wishbone.html">simple wishbone bus
slave</a>.  That post
eliminated a lot of the bus lines so as to make building a simple bus slave
easy.</p>

<p>As a result, that bus as built could not handle 8-bit bytes.</p>

<p>This post will describe how to add the appearance of 8-bit addressing to a
wishbone bus slave.</p>

<h2 id="bus-word-size">Bus Word Size</h2>

<p>The word size of any bus is given by by the number of data lines contained
within that bus.  The speed of the bus is constrained to be one transaction
per clock, at most, and hence any bus design can at most read (or write)
one bus word at a time.  Hence, increasing the width of the bus will increase
the throughput of that bus.</p>

<p>The consequence of this, though, is that addresses on the bus don’t reference
octets (8-bit bytes), but rather words.  Instead, a wider bus represents an
array of words, not an array of bytes.</p>

<p>The problem with word references is that most software is built with the
legacy understanding that memory exists as a series of octets (8-bit bytes).</p>

<p>So … although the bus exists as an array of words, modern computer software
considers it to be an array of octets.</p>

<p>How shall this illusion be kept?</p>

<h2 id="select-lines">Select lines</h2>

<p>The answer to the question of how to make an array of words look like an array
of bytes is the bus select lines.</p>

<p>Remember how we defined how a memory would access a bus <a href="/zipcpu/2017/05/23/simplebus.html">earlier</a>?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	if (i_wr)
		memory[i_addr] &lt;= i_data;</code></pre></figure>

<p>Or how <a href="/zipcpu/2017/05/29/simple-wishbone.html">we discussed</a> what this would look like for the <a href="http://opencores.org/cdn/downloads/wbspec_b4.pdf">wishbone bus</a>?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	if ((i_wb_stb)&amp;&amp;(i_wb_we))
		memory[i_addr] &lt;= i_data;</code></pre></figure>

<p>Adding select lines to this transaction is fairly easy.  In particular, the
four select lines indicate which byte on the bus has valid data within it.
What we do, therefore, is to gate each of the individual byte writes by this
select line:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	reg	[(BUS_WIDTH-1):0]	mem	[(0:((1&lt;&lt;(ADDRESS_WIDTH)-1)];
	always @(posedge i_clk)
	begin
		if ((i_wb_stb)&amp;&amp;(i_wb_we)&amp;&amp;(w_sel[3]))
			mem[i_wb_addr][31:24] &lt;= i_wb_data[31:24];
		if ((i_wb_stb)&amp;&amp;(i_wb_we)&amp;&amp;(w_sel[2]))
			mem[i_wb_addr][23:16] &lt;= i_wb_data[23:16];
		if ((i_wb_stb)&amp;&amp;(i_wb_we)&amp;&amp;(w_sel[1]))
			mem[i_wb_addr][15: 8] &lt;= i_wb_data[15:8];
		if ((i_wb_stb)&amp;&amp;(i_wb_we)&amp;&amp;(w_sel[0]))
			mem[i_wb_addr][ 7: 0] &lt;= i_wb_data[7:0];
	end</code></pre></figure>

<p>Format here is important.  Just a subtle change in this formula, and the
synthesis tool may no longer infer a block RAM.  If this happens, your LUT
usage is likely to massively increase.  To deal with this issue, know where
to find the guide that specifies how block RAM’s are inferred.  For example,
<a href="https://www.xilinx.com/support/documentation/white_papers/wp231.pdf">here’s a link</a> to the guide for Xilinx.</p>

<p>If you can’t get your synthesis tool to recognize a memory with select lines,
you may have to do this final bus decoding yourself:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">reg	[(7-1):0]	mem_a	[(0:((1&lt;&lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_b	[(0:((1&lt;&lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_c	[(0:((1&lt;&lt;(ADDRESS_WIDTH)-1)];
reg	[(7-1):0]	mem_d	[(0:((1&lt;&lt;(ADDRESS_WIDTH)-1)];

always @(posedge i_clk)
begin
	if ((i_wb_stb)&amp;&amp;(i_wb_we)&amp;&amp;(w_sel[3]))
		mem_a[i_wb_addr] &lt;= i_wb_data[31:24];
	if ((i_wb_stb)&amp;&amp;(i_wb_we)&amp;&amp;(w_sel[2]))
		mem_b[i_wb_addr] &lt;= i_wb_data[23:16];
	if ((i_wb_stb)&amp;&amp;(i_wb_we)&amp;&amp;(w_sel[1]))
		mem_c[i_wb_addr] &lt;= i_wb_data[15:8];
	if ((i_wb_stb)&amp;&amp;(i_wb_we)&amp;&amp;(w_sel[0]))
		mem_d[i_wb_addr] &lt;= i_wb_data[7:0];
end</code></pre></figure>

<p>If you have to do this decoding yourself, reading from the bus would also
change to:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	o_wb_data &lt;= { mem_a[i_wb_addr], mem_b[i_wb_addr],
		mem_c[i_wb_addr], mem_d[i_wb_addr] };</code></pre></figure>

<p>But I tend to avoid this approach if at all possible–it just seems and feels
messier.</p>

<h2 id="what-about-reading-from-the-bus">What about reading from the bus?</h2>

<p>The only time you need to worry about the select lines when reading from a 
wishbone bus is when you are the master and you want to decode the result
from the bus.  Hence, the bus master will just read a whole word, and then
grab the byte (or bytes) necessary when the bus request returns its data.</p>

<p>In other words, nothing changes in the slave when you read less than a word
size from the bus.</p>

<h2 id="do-all-peripherals-need-to-offers-8-bit-support">Do all peripherals need to offers 8-bit support?</h2>

<p>Not at all.  If you read through device specification sheets, it’s not uncommon
for the designer to say that accesses of less than a word size are not
supported, and that their results are undefined.  This is the hardware
designer’s way of saying that the select lines may not be relied upon.</p>

<p>In other words: when building your peripheral, you don’t need to provide select
line support.</p>

<p>However, in order for the various string libraries to work, memory peripherals
<em>must</em> have select line support.</p>

<h2 id="examples">Examples</h2>

<p>Few of my generic peripherals support memory byte selection, but all of my
memory peripherals now do.  You can find an example block RAM memory device 
<a href="https://github.com/ZipCPU/openarty/blob/master/rtl/memdev.v">here</a>, showing
all the required pieces of what it takes to interact with a bus slave.</p>

<p>If this is interesting to you, then stick around: discussing how to build a
wishbone bus master is next!</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    
    <em>Let both grow together until the harvest: and in the time of harvest I will say to the reapers, Gather ye together first the tares, and bind them in bundles to burn them: but gather the wheat into my barn. (Mat 13:30)</em>
    

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">zipcpu</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and CPU design. This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
