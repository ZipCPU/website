<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a simple bus</title>
  <meta name="description" content="Busses consist of both bus masters, and bus slaves.  Masters command whichaddresses need to be read from or written to, while slaves respond to therequests o...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2017/05/23/simplebus.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/#training">Formal training</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building a simple bus</h1>
    <p class="post-meta"><time datetime="2017-05-23T00:00:00-04:00" itemprop="datePublished">May 23, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Busses consist of both bus masters, and bus slaves.  Masters command which
addresses need to be read from or written to, while slaves respond to the
requests of the bus master(s).  For this article, we’ll discuss the logic
necessary to implement a very simple bus slave.  Why?  Because at the core of
every memory mapped peripheral is just a touch of simple bus logic.</p>

<p>To understand this concept, let’s consider a very simple bus.  Three things
can only ever happen on this bus on any given clock cycle.  1) The vast majority
of the time, the bus will be idle.  2) You might write to the bus.  Or 3),
you might read from the bus.  On a simple bus, this type of interaction can
easily be understood with just a few simple wires:</p>

<ul>
  <li>
    <p><strong>i_wr</strong>: True any time a write is requested.  If true for two clocks in a row, then two writes should take place in a row.</p>
  </li>
  <li>
    <p><strong>i_rd</strong>: True any time a read is requested</p>
  </li>
  <li>
    <p><strong>i_addr</strong>: The address of the value to read/write</p>
  </li>
  <li>
    <p><strong>i_data</strong>: The data to be written on any write access</p>
  </li>
  <li>
    <p><strong>o_data</strong>: The data to be returned on any read access</p>
  </li>
</ul>

<h1 id="a-simple-write-cycle">A Simple Write Cycle</h1>

<p>Using these values, writing to a memory might be as simple as:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_wr</span><span class="p">)</span>
		<span class="n">memory</span><span class="p">[</span><span class="n">i_addr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="o">;</span></code></pre></figure>

<p>Writing to an arbitrary peripheral has much the same logic, but what it does
is a little bit different:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_wr</span><span class="p">)</span> <span class="k">case</span><span class="p">(</span><span class="n">i_addr</span><span class="p">)</span>
	<span class="mh">4'h0</span><span class="o">:</span> <span class="k">config</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="o">;</span>
	<span class="mh">4'h1</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span> <span class="c1">// A read only address
</span>	<span class="mh">4'h2</span><span class="o">:</span> <span class="k">begin</span> <span class="k">end</span> <span class="c1">// A read only address
</span>	<span class="mh">4'h3</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">transmitter_data</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="o">;</span>
		<span class="n">transmitter_stb</span>  <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span> <span class="k">else</span>
		<span class="n">transmitter_stb</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>Specifically, writes to a peripheral specify some logic to be done for each
possible address you might write to.</p>

<p>In this example, writing to address zero simply sets a configuration register.
Writes to
addresses one and two are ignored: these addresses reference read only
registers.  Finally, address three sets a strobe value indicating that
some action is to take place, together with the data necessary for that
action.</p>

<p>Indeed, from this perspective, the write cycle is pretty simple.</p>

<h1 id="a-simple-read-cycle">A Simple Read Cycle</h1>

<p>The read cycle isn’t really that much more complicated either.  For a simple
memory, it would look like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">o_data</span> <span class="o">&lt;=</span> <span class="n">memory</span><span class="p">[</span><span class="n">i_addr</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Within a more generic peripheral, where reads might have side-effects, the
read logic might look instead like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">case</span><span class="p">(</span><span class="n">i_addr</span><span class="p">)</span>
	<span class="mh">4'h0</span><span class="o">:</span> <span class="n">o_data</span> <span class="o">&lt;=</span> <span class="k">config</span><span class="o">;</span>
	<span class="mh">4'h1</span><span class="o">:</span> <span class="k">begin</span> <span class="n">o_data</span> <span class="o">&lt;=</span> <span class="n">w_internal_values</span><span class="o">;</span> <span class="n">advance_data_stb</span> <span class="o">&lt;=</span> <span class="n">i_rd</span><span class="o">;</span> <span class="k">end</span>
	<span class="mh">4'h2</span><span class="o">:</span> <span class="n">o_data</span> <span class="o">&lt;=</span> <span class="n">w_other_internal_values</span><span class="o">;</span>
	<span class="c1">// 4'h3: // A write only address
</span>	<span class="nl">defautl:</span> <span class="n">o_data</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">endcase</span> <span class="k">else</span>
		<span class="n">advance_data_stb</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>You may notice that o_data gets set any time the address changes.
What if nothing is being read?  In this case, it’s not a problem.  The right
answer is being placed on the bus either way.  However, if you have an input
queue, such as in a read FIFO, you might wish to advance that queue on reads
only.  This is the idea behind the advance_data_stb logic above.</p>

<h2 id="shared-data-lines">Shared data lines</h2>

<p>Having separate input data lines, i_data, and output data lines, o_data,
makes a lot of sense within an FPGA.</p>

<p>However, between components on a circuit board, cost may be measured in both
area and the number of wires routed from one place to another.</p>

<p>For this reason, when communicating over an external bus, the simple bus we
have been describing has one more step:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span> <span class="n">io_data</span> <span class="p">(</span><span class="n">i_rd</span><span class="p">)</span> <span class="o">?</span> <span class="mb">32'bzzzz_</span><span class="o">..</span><span class="mf">._</span><span class="n">zzzz</span> <span class="o">:</span> <span class="n">o_data</span><span class="o">;</span></code></pre></figure>

<p>This last step determines which of multiple digital pieces of logic drives
the bus.</p>

<h2 id="thats-it">That’s it!</h2>

<p>That’s all there is to working with a bus.  You need to read the address,
check if you are being read or written to, and return a value and act
appropriately.  At some level, every bus acts in this fashion.  Hence,
if you can understand how to interact with a bus like this, you’ve gone
through the first step of ever interacting with any bus.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Now if any man build upon this foundation gold, silver, precious stones, wood, hay, stubble; every man's work shall be made manifest: for the day shall declare it, because it shall be revealed by fire; and the fire shall try every man's work of what sort it is. (1Cor 3:12-13)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
