<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Using AutoFPGA to connect simple registers to a debugging bus</title>
  <meta name="description" content="My prior postregardingAutoFPGAdiscussed why I builtAutoFPGAand what I intended to accomplish with it.">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2017/10/06/autofpga-dataword.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/#training">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Using AutoFPGA to connect simple registers to a debugging bus</h1>
    <p class="post-meta"><time datetime="2017-10-06T00:00:00-04:00" itemprop="datePublished">Oct 6, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>My <a href="/zipcpu/2017/10/05/autofpga-intro.html">prior post</a>
regarding
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
discussed why I built
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
and what I intended to accomplish with it.</p>

<p>Today, let’s take a look at how to create some simple
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
component files that you can then use within a basic
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
design.  Specifically, let’s look at how to connect
wishbone components
having only a single data register to an
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
project.</p>

<p>To do this, we’ll start out by taking a look at
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>’s
configuration file format.  You’ll need that to understand the basics of how
to read the configuration files themselves.  We’ll then discuss briefly
the two Verilog files
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
generates,
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">toplevel.v</a> and
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>,
and then how the various
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
tags get placed within that structure.  This will then lead us to the point
where we can create the
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
configuration files necessary to read and write single registers
from a peripheral.</p>

<h2 id="autofpgas-configuration-file-format">AutoFPGA’s Configuration File Format</h2>

<p>Before we start discussing the details of how to write particular
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
cofiguration files, it only makes sense to pause to comment on the file
structure in general.  Indeed, <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>’s
configuration file structure is actually fairly simple, with its focus
primarily on staying out of the way.</p>

<h4 id="key-value-pairs">Key value pairs</h4>

<p><a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
configuration files consist of a series key value pairs.  Keys start at the
beginning of a line with an <code class="highlighter-rouge">@</code> sign and end with an <code class="highlighter-rouge">=</code> sign.  Hence, to
define the key <code class="highlighter-rouge">KEY</code> to have a value <code class="highlighter-rouge">VALUE</code>, you’d write:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@KEY=VALUE</code></pre></figure>

<p>If the <code class="highlighter-rouge">VALUE</code> fits within a single line, spaces will be trimmed from the ends
of it.</p>

<h4 id="multi-line-values">Multi-line values</h4>

<p>Value’s can also take up multiple lines, as in,</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@KEY=
/* The keys value will be given
 * by these series of lines.
 */</code></pre></figure>

<p>Any white space found within multiple line <code class="highlighter-rouge">VALUE</code>s will be left alone.</p>

<h4 id="comments">Comments</h4>

<p><a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
allows line based comments.  Comment lines begin with either a <code class="highlighter-rouge">#</code> and a
space, or two <code class="highlighter-rouge">##</code>s.  Other comment characters, such as <code class="highlighter-rouge">//</code> or <code class="highlighter-rouge">/* ... */</code>
will create comments within the result files that the <code class="highlighter-rouge">VALUE</code> gets pasted into.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># This is a comment within AutoFPGA
##This is also a comment
@KEY=
/* This comment will be copy/pasted into the source file this KEY's VALUE
 * will be pasted into.
 */
// This comment will also be copy/pasted as part of AutoFPGA's work</code></pre></figure>

<h4 id="unordered">Unordered</h4>

<p>Keys within an
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
configuration file are unordered, with the only exception being the
<code class="highlighter-rouge">@PREFIX</code> key that separates components within a given configuration file
(more on this key in a moment).
What this means is that you can place keys for the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top level module</a> before
those for the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>,
after the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>
keys, or interspersed between the two.</p>

<h4 id="substitution">Substitution</h4>

<p><code class="highlighter-rouge">VALUE</code>s from one <code class="highlighter-rouge">KEY</code> may be substituted into <code class="highlighter-rouge">VALUE</code>s from another, by
referencing the value by its keys name, as in <code class="highlighter-rouge">@$(KEY)</code>.</p>

<p>For example, if you define a key <code class="highlighter-rouge">@DEVID</code>,</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@DEVID=VERSION</code></pre></figure>

<p>You can later reference this key within another key’s value by using
<code class="highlighter-rouge">@$(DEVID</code> to reference it.  Hence,</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@REGS.0= 0 R_@$(DEVID) $(DEVID)</code></pre></figure>

<p>will get expanded into</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@REGS.0= 0 R_VERSION VERSION</code></pre></figure>

<h4 id="expressions">Expressions</h4>

<p><code class="highlighter-rouge">KEY</code>s that start with <code class="highlighter-rouge">@$</code> instead of <code class="highlighter-rouge">@</code> define integer valued expressions.
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> contains a simple expression
evaluator, allowing things like:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@$BAUDCLOCKS=@$(BAUDRATE)/@$(CLKFREQHZ)</code></pre></figure>

<p>In this case, if you’ve defined <code class="highlighter-rouge">BAUDRATE</code> as</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@BAUDRATE=1000000</code></pre></figure>

<p>or even</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@$BAUDRATE=1000000</code></pre></figure>

<p>and <code class="highlighter-rouge">CLKFREQHZ</code> as</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@$CLKFREQHZ=100000000</code></pre></figure>

<p>then</p>

<p><a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> would calculate the
<code class="highlighter-rouge">@BAUDCLOCKS</code> frequency to be 100 clocks.  If <code class="highlighter-rouge">@$(BAUDCLOCKS)</code> is used in
an string context, it will evaluate to the string <code class="highlighter-rouge">"100"</code>.  (The format
is adjustable via the <code class="highlighter-rouge">@BAUDCLOCKS.FORMAT</code> tag, but we’ll get to that later.)</p>

<h4 id="the-prefix-key">The @PREFIX key</h4>

<p>All
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> components begin with a
<code class="highlighter-rouge">@PREFIX</code> key.  This key defines both the beginning of the component’s keys
within a configuration file, as well as the end of any prior component that
may also be defined within the file.  The <code class="highlighter-rouge">@PREFIX</code> tag also creates a
sort of local variable namespace, since keys defined following a <code class="highlighter-rouge">@PREFIX</code>
key are quietly prefixed in the global key structure by the <code class="highlighter-rouge">@PREFIX</code>.</p>

<p>While there are a couple of other details to
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>’s
configuration files, those other details can wait until we need them later.</p>

<h2 id="autofpgas-rtl-file-structure">AutoFPGA’s RTL File Structure</h2>

<p>Before you integrate your component into
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>,
you’ll wnat to understand how
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
looks at RTL (Verilog) files.</p>

<p>In general,
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
insists that a design should have the structure shown in Fig 1.  In this
structure, the
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> generated files are marked with
a red star.</p>

<table align="center" style="float: none"><caption>Fig 1: AutoFPGA RTL Structure</caption><tr><td><img src="/img/auto-rtl.svg" alt="AutoFPGA RTL File Structure" width="480" /></td></tr></table>

<p>In this structure, there is a
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top level file</a>.
Within this <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top level file</a>
are any references to vendor specific components.
For example, MMCMs, PLLs, ISERDESE2 and OSERDESE2 components would be placed
either in the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top level</a>
itself,
or in the vendor specific files beneath it.  As an example, the
<a href="https://www.xilinx.com">Xilinx</a> Memory Interface Generator (MIG) code is
vendor specific, so it would belong at this top level.  Another example might
be the vendor specific components necessary for a
<a href="https://en.wikipedia.org/wiki/HDMI">HDMI</a> receiver.  The actual line of
demarkation is made by examining what
<a href="https://www.veripool.org/wiki/verilator">Verilator</a> can simulate.
Any components that <a href="https://www.veripool.org/wiki/verilator">Verilator</a>
can components can be placed in
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
and below, anything else goes into the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top level</a> or the vendor specific component set that it references.</p>

<p>Critical components of your design that don’t meet the criteria to be placed
into
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
may need external (C++ software) co-simulators.  We’ll come back to the concept
of simulation later.</p>

<p>Also within the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top level file</a>
is an instantiation of the main module.  The
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>
consists of one (or more) bus masters controlling a set of peripherals.
It can also contain items that are neither bus masters nor peripherals,
but these items won’t get attached to any bus.</p>

<p><a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> will build both the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top level</a>
module, as well as the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>
for you–connecting components together as the need to be for your design.</p>

<p>However, <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
has no knowledge of the vendor specific or vendor independent
component files.  All it knows how to do is to copy and paste items into these
two files to create your logic.  You tell it how to interface with the other
components, but that’s it.</p>

<p>Well, this isn’t <em>quite</em> true.
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> supports some
Makefile based tags which can be used to create a make include file.
You can use these tags to place a list of component items into a
list of Verilog files included in your project.  Some synthesizers, such as
<a href="https://www.clifford.at/yosys">yosys</a>
need this information in order to build the project.  Other synthesizers,
isuch as <a href="https://www.veripool.org/wiki/verilator">Verilator</a>,
just need to be told where to look.  We’ll come back to this topic later.</p>

<p>What I”m trying to say is that after
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> has created any
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top level</a> file
or <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>,
you’ll still need to synthesize your design from these module files.
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
doesn’t create make files, and it doesn’t build projects.  These
capabilities need to be part of the project that uses
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>.</p>

<h2 id="internal-rtl-file-structure">Internal RTL File Structure</h2>

<p><a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
is primarily a copy and paste utility, with some additional capabilities for
composing and connecting bus structures and interrupts.  What this means
when it comes to the two RTL files that it generates is that
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
will primarily copy snippets of Verilog code, provided by your
configuration file, into their proper places within these two files.</p>

<p>The majority of this work is done within
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
so let’s look at that first.</p>

<table style="float: right"><caption>Fig 2: Main module structure</caption><tr><td><img src="/img/auto-mainv.svg" alt="main.v structure" width="320" /></td></tr></table>

<p>Fig 2 shows the structure of the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>.</p>

<p>The <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>,
as shown in Fig 2, has several parts to it.  It starts like all
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
generated file with a legal notice, copied from the file whose name is
associated with the <code class="highlighter-rouge">@LEGAL</code> key.  After that, there’s a section where
components can define <code class="highlighter-rouge">ACCESS</code> keys.  These are pre-processor macros, that
will be used to handle component dependencies if necessary (<code class="highlighter-rouge">@DEPENDS</code> key).
Then comes a series of paste’d components from any <code class="highlighter-rouge">@MAIN.PORTLIST</code> keys,
then any parameter definitions captured in <code class="highlighter-rouge">@MAIN.PARAM</code> keys, and then any
declarations associated with <code class="highlighter-rouge">@MAIN.IODECL</code> keys.  The file continues,
defining any interrupt wires, wires defined within <code class="highlighter-rouge">@MAIN.DEFNS</code> tags,
interrupt vectors, and bus interaction wire components.
The big point to know here is that these keys are pasted into this file in
the order shown.  I’ve written the keys in all capitols in the positions
where their values will be pasted in within Fig 2, so you can see what goes
where.</p>

<p>The primary module for the component, where the actual bus interaction and
any I/O wire adjustment takes place, is placed within the value of the
<code class="highlighter-rouge">@MAIN.INSERT</code> tag for the component.  We’ll discuss many of the other details
as we go along.</p>

<table style="float: left; padding: 15px"><caption>Fig 3: Toplevel file structure</caption><tr><td><img src="/img/auto-topv.svg" alt="toplevel.v structure" width="320" /></td></tr></table>

<p>The <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top-level</a>
module has a similar, although simpler, structure as shown in Fig 3.</p>

<p>Unlike the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>,
fewer <code class="highlighter-rouge">KEY</code>s impact the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top-level</a>.
There’s the list of I/O ports for the module, their declarations, and any
other definitions you might wish to have.  After that, there’s the <code class="highlighter-rouge">KEY</code>
defining wires that need to be passed to the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>,
<code class="highlighter-rouge">@TOP.MAIN</code>, and any RTL code that needs to be
inserted into the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top-level</a>.
module via the
<code class="highlighter-rouge">@TOP.INSERT</code> key.</p>

<p>Not all components will need these
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top-level</a>
keys.  If no
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top-level</a>
keys are given, then any keys describing ports for the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>,
file will automatically be assumed to be
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">toplevel</a>,
ports as well, so they need not be defined twice if they are the same between
both levels.</p>

<p>So, let’s take a look at what it takes to put a configuration file together
that will specify how to impact the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/toplevel.v">top level</a>,
or <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>.
We’ll start with some simple examples, and then move to some more complex
examples.</p>

<p>Remember, as you go through these, that
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
is primarily a copy/paste utility, with some bus aggregation facilities
added into it.</p>

<h2 id="reading-a-simple-ad-hoc-value">Reading a simple ad-hoc value</h2>

<p>For our first example, let’s read a constant value from our bus.  The value
itself is arbitrary for this example, so we’ll just set it to
<code class="highlighter-rouge">32'h20170926</code>.  You can see the full configuration file for this example
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/fixdata.txt">here</a>.</p>

<p>The first step is to declare this item as a peripheral–as its own entity, and
to give it a name that will distinguish it from other peripherals within our
design.  This is done via the <code class="highlighter-rouge">@PREFIX</code> key.  Let’s give this fixed data
component the name <code class="highlighter-rouge">fixdata</code>, since that’s what we’ll be reading from it: fixed
data.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@PREFIX=fixdata</code></pre></figure>

<p>The <code class="highlighter-rouge">@PREFIX</code> key is required for all components.
It defines the beginning of the component, and ends any component definitions
prior to it.  (Yes, two components can be placed into a single configuration
file.  A good example of this would be the <a href="https://github.com/ZipCPU/zbasic/blob/master/auto-data/flash.txt">flash
component</a>
that has not only read-only flash memory, but also a set of program control
registers to control the erase circuitry, and any write-enable.)</p>

<p>We may also want an all-caps name for some of the contexts this peripheral
might be in.  This isn’t required, like the <code class="highlighter-rouge">@PREFIX</code> key is, but it makes
a nice illustration.  For this, we’ll create the key <code class="highlighter-rouge">DEVID</code>, and give it a
value of <code class="highlighter-rouge">FIXEDATA</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@DEVID=FIXEDATA</code></pre></figure>

<p>This is a classic example of a key that
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
knows nothing about.  It will have only the meaning we give it below.</p>

<p>If you want this peripheral to have a place on the bus, then
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
needs to know how many addresses to assign to it.
Let’s take just one bus address (four bytes for a 32-bit data bus–the
default), since we’re only going to be returning a single, pre-determined,
value.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@NADDR=1</code></pre></figure>

<p>Most of the example’s we’ll deal with today have only one address.</p>

<p>This particular peripheral is going to be a slave peripheral to the
main wishbone bus, <code class="highlighter-rouge">wb</code> within our design.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@SLAVE.BUS=wb</code></pre></figure>

<p>Once a component is declared to be a bus slave, a series of wires will be
defined for it within <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
as referenced in Fig 2 above.  For our component, these wires are given by,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">wire</span>	<span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">fixdata_data</span><span class="o">;</span>
<span class="kt">wire</span>		<span class="n">fixdata_ack</span><span class="o">,</span> <span class="n">fixdata_stall</span><span class="o">,</span> <span class="n">fixdata_sel</span><span class="o">;</span></code></pre></figure>

<p>although I’ll tend to reference these as <code class="highlighter-rouge">@$(PREFIX)_data</code>, <code class="highlighter-rouge">@$(PREFIX)_ack</code>,
etc., since these descriptions are more generic and can be used regardless
of what the peripherals name, given by the <code class="highlighter-rouge">@PREFIX</code> key, actually is.  The
first three of these are the slave return wires required by the
<a href="/doc/wbspec_b4.pdf">wishbone bus</a>.  The third wire,
<code class="highlighter-rouge">@$(PREFIX)_sel</code> will be true any time the address on the bus references this
component.</p>

<p>Because our value is already fixed, it won’t take any clocks to calculate
it–it’s already known.  Therefore this slave is of type <code class="highlighter-rouge">SINGLE</code>, since it
can return a result in a <code class="highlighter-rouge">SINGLE</code> clock cycle.  <code class="highlighter-rouge">SINGLE</code> peripherals don’t
need to define their wishbone acknowledgement wires, <code class="highlighter-rouge">@$(PREFIX)_ack</code>, or
their stall lines, <code class="highlighter-rouge">@$(PREFIX)_stall</code>, since they never stall and the ack
is true the same clock the peripheral is accessed.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@SLAVE.TYPE=SINGLE</code></pre></figure>

<p>Other peripheral types are <code class="highlighter-rouge">DOUBLE</code>, <code class="highlighter-rouge">OTHER</code>, and <code class="highlighter-rouge">MEMORY</code>.  <code class="highlighter-rouge">DOUBLE</code>
peripherals require a single clock to calculate their value, yet never
stall.  <code class="highlighter-rouge">OTHER</code> and <code class="highlighter-rouge">MEMORY</code> peripherals are more generic wishbone
peripherals–but we’ll discuss these more later.</p>

<p>It’s now time to return our value to the bus.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.INSERT=
	assign	@$(PREFIX)_data = 32'h20170926;</code></pre></figure>

<p>Normally a <a href="/doc/wbspec_b4.pdf">wishbone</a> slave also
needs to assign values to a <code class="highlighter-rouge">@$(PREFIX)_ack</code> and <code class="highlighter-rouge">@$(PREFIX)_stall</code> line.
However, these are trivially defined for a <code class="highlighter-rouge">SINGLE</code> peripheral type, so we
ignore them here.  (The <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> generated
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
file ignores these lines for <code class="highlighter-rouge">SINGLE</code> type peripherals as well.)</p>

<p>The last step in our peripheral definition is to give a name for this
peripheral to be used when accessing it via the debugging interface.  This is
where we’ll use the <code class="highlighter-rouge">@DEVID</code> key we defined earlier.  The first of the lines
below just specifies that this peripheral has only one named register.  The
second line says that, at an offset of zero words from the beginning of this
peripheral’s address is a register named <code class="highlighter-rouge">R_@$(DEVID)</code> with a user name of
<code class="highlighter-rouge">@$(DEVID)</code>.  These will be turned into <code class="highlighter-rouge">R_FIXEDATA</code> and <code class="highlighter-rouge">FIXEDATA</code>
respectively.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)</code></pre></figure>

<p>If you look in
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/regdefs.h">regdefs.h</a>,
or <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/regdefs.cpp">regdefs.cpp</a>,
for <code class="highlighter-rouge">R_FIXEDATA</code>, you’ll see the effects of these two lines.</p>

<table style="float: right"><caption>Fig 4: Software interface files and AutoFPGA</caption><tr><td><img src="/img/auto-host.svg" alt="Diagram showing that AutoFPGA creates regdefs.h and regdefs.cpp" width="320" /></td></tr></table>
<p>While we haven’t discussed it, these two files,
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/regdefs.h">regdefs.h</a>,
and <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/regdefs.cpp">regdefs.cpp</a>,
are part of the host-based software interface library specification shown in
Fig 4.  They are marked with red stars, since they are created by
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>, vice the <code class="highlighter-rouge">design.h</code> file
created by the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/Makefile">RTL Makefile</a>.</p>

<p>Once we include <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/fixdata.txt">this fixdata.txt configuration
file</a>
in our design, and build it, we can then run
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/sw/wbregs.cpp">wbregs</a></p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">wbregs FIXEDATA</code></pre></figure>

<p>to read from the peripheral–either in simulation or on our actual hardware.</p>

<h2 id="reading-a-fixed-version-number">Reading a Fixed Version number</h2>

<p>What if we want our number to be defined by an include file?</p>

<p>Many of my designs contain an include file, <code class="highlighter-rouge">builddate.v</code>, that is created
by a <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/mkdatev.pl">simple perl
script</a>.
This <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/builddate.v">include
file</a>
defines a value <code class="highlighter-rouge">DATESTAMP</code> containing the date when
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/mkdatev.pl">mkdatev.pl</a>
was last run.  I use this as a version number within my design–primarily
to make certain I’m not accidentally running an older design when I think
I’ve built and loaded a newer design.</p>

<p>Creating a register containing <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/builddate.v">this version
information</a>
is almost identical to the last exercise.  First, we declare our bus interface
as before, although this time with a different <code class="highlighter-rouge">@PREFIX</code> and <code class="highlighter-rouge">@DEVID</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@PREFIX=version
@DEVID=VERSION
@NADDR=1
@SLAVE.TYPE=SINGLE
@SLAVE.BUS=wb</code></pre></figure>

<p>At this point, though, we want to instruct our
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>
to include the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/mkdatev.pl">Perl-script generated</a>
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/builddate.v">build-date version
file</a>.
This is done through the <code class="highlighter-rouge">@MAIN.DEFNS</code> key, whose value then gets pasted at
the top of the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.DEFNS=
`include "builddate.v"</code></pre></figure>

<p>Remember,
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
is primarily a copy and paste utility.  You can place any Verilog you want
into your
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a> file
at this same location using this tag, although not all things you could
paste would make sense at the top of a module file and before the
module declaration.</p>

<p>Our bus interaction code within the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>,
given by the <code class="highlighter-rouge">@MAIN.INSERT</code> key, is going to change only slightly.  This
time, instead of returning <code class="highlighter-rouge">32'h20170926</code>, we’ll return our <code class="highlighter-rouge">DATESTAMP</code>
variable.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.INSERT=
	assign	@$(PREFIX)_data = `DATESTAMP;</code></pre></figure>

<p>The rest is just like the last example.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)</code></pre></figure>

<p>You can see the full configuration file for reading this <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/version.txt">version information
here</a>.</p>

<p>One thing to note is that
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
only creates <em>some</em> files.  It doesn’t create an entire project.  Hence, the
creation of the <code class="highlighter-rouge">builddate.v</code> file is done by the main
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/Makefile">Makefile</a>
calling the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/mkdatev.pl">mkdatev.pl</a>
program–both of which are outside of the configuration files that
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data">looks at</a> and
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated">creates</a>.</p>

<h2 id="read-access-to-an-internal-changing-register">Read access to an internal (changing) register</h2>

<p>Let’s create another single register within our design using
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>.  Suppose we wanted to
know how many clock ticks had taken place since we first initialized our
design, and whether the count had (eventually) rolled over.  To get this
value, we’d need to initialize a register and then count clocks with it.</p>

<p>The <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/pwrcount.txt">pwrcount.txt</a>
configuration file describes just how to build one of such a register.
We’ll walk through this file below.</p>

<p>Since this is a single value, again, the bus access declaration is the same as
before but with a new name, <code class="highlighter-rouge">pwrcount</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@PREFIX=pwrcount
@NADDR=1
@SLAVE.TYPE=SINGLE
@SLAVE.BUS=wb
@REGS.N=1
@REGS.0= 0 R_PWRCOUNT PWRCOUNT</code></pre></figure>

<p>Note that I didn’t use the <code class="highlighter-rouge">DEVID</code> this time.
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
doesn’t know that key, and so it won’t miss it when it isn’t there.  It’s just
an example of a key you can use if it helps you, or ignore if not.</p>

<p>At this point, I could just copy and paste a module reference into my
main module,</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.INSERT=
	powercounter @$(PREFIX)i(i_clk, @$(PREFIX)_data);</code></pre></figure>

<p>assuming I had a module named <code class="highlighter-rouge">powercounter</code>.
We’ll use that approach with a later example in this post for the
special purpose I/O peripheral,
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/spio.v">spio.v</a>,</p>

<p>Instead of doing things that way, though, let’s define a register,
<code class="highlighter-rouge">r_pwrcount_data</code>.  This register declaration will get placed at the top of the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>,
before any logic, so that it can be referenced by any logic below.  Before
doing so, though, we’ll replace <code class="highlighter-rouge">pwrcount</code> within that name by our <code class="highlighter-rouge">PREFIX</code>
key, so as to continue the perception of variables with a local scope.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.DEFNS=
	reg	[31:0]	r_@$(PREFIX)_data;</code></pre></figure>

<p>Now we can create the logic that defines this value.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.INSERT=
	initial	r_@$(PREFIX)_data = 32'h0;
	always @(posedge i_clk)
	if (r_@$(PREFIX)_data[31])
		r_@$(PREFIX)_data[30:0] &lt;= r_@$(PREFIX)_data[30:0] + 1'b1;
	else
		r_@$(PREFIX)_data[31:0] &lt;= r_@$(PREFIX)_data[31:0] + 1'b1;
	assign	@$(PREFIX)_data = r_@$(PREFIX)_data;</code></pre></figure>

<p>Note that when we we are done, we set <code class="highlighter-rouge">@$(PREFIX)_data</code> using an assign
statement rather than using <code class="highlighter-rouge">r_@$(PREFIX)_data</code>.  This is simply because
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
defines the bus variables for you as though you were going to create and
return them via a module–as wires, not registers.</p>

<h2 id="getting-the-address-of-the-last-bus-error">Getting the address of the last bus error</h2>

<p>In a similar fashion, we can place just about any logic we want within the
<code class="highlighter-rouge">@MAIN.INSERT</code> tag.  Remember,
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
is primarily a copy and paste utility.  All you need to do is to <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/buserr.txt">tell it how
to wire your code
up</a>
to the rest of the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@PREFIX=buserr
# ...
@MAIN.DEFNS=
	reg	[@$(SLAVE.BUS.AWID)-1:0]	r_@$(PREFIX)_addr;
@MAIN.INSERT=
	always @(posedge @$(SLAVE.BUS.CLOCK.WIRE))
		if (@$(SLAVE.BUS.NAME)_err)
			r_@$(PREFIX)_addr &lt;= @$(SLAVE.BUS.NAME)_addr;
	assign	@$(PREFIX)_data = { {(@$(SLAVE.BUS.WIDTH)-2-@$(SLAVE.BUS.AWID)){1'b0}},
			r_@$(PREFIX)_addr, 2'b00 };</code></pre></figure>

<p>This works based upon the fact that there are several wires defined for each
bus.  These wires are all prefixed by the name of the bus and an underscore.
Hence, for the <code class="highlighter-rouge">wb</code> bus, these wires will all have a <code class="highlighter-rouge">wb_</code> prefix.
Since this is a
<a href="/doc/wbspec_b4.pdf">wishbone B4 pipelined bus</a>, all of these
bus master wires will be defined as:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">wire</span>			<span class="n">wb_cyc</span><span class="o">,</span> <span class="n">wb_stb</span><span class="o">,</span> <span class="n">wb_we</span><span class="o">,</span> <span class="n">wb_err</span><span class="o">,</span> <span class="n">wb_stall</span><span class="o">,</span>
			<span class="n">wb_none_sel</span><span class="o">;</span>
<span class="kt">reg</span>			<span class="n">wb_many_ack</span><span class="o">;</span>
<span class="kt">wire</span>	<span class="p">[(</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">wb_addr</span><span class="o">;</span>
<span class="kt">wire</span>	<span class="p">[(</span><span class="n">DW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">wb_data</span><span class="o">;</span>
<span class="kt">reg</span>	<span class="p">[(</span><span class="n">DW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">wb_idata</span><span class="o">;</span>
<span class="kt">wire</span>	<span class="p">[(</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">wb_sel</span><span class="o">;</span>
<span class="kt">reg</span>			<span class="n">wb_ack</span><span class="o">;</span></code></pre></figure>

<p>where <code class="highlighter-rouge">AW</code> is the address width of the bus, and <code class="highlighter-rouge">DW</code> is the data width.
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
needs to be able to support multiple busses, however, of multiple types.
For this reason, the <code class="highlighter-rouge">@SLAVE.BUS</code> key is expanded into a series of keys:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="o">@</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">NAME</span><span class="o">=</span><span class="n">wb</span>
<span class="o">@</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">AWID</span><span class="o">=</span><span class="mi">16</span>
<span class="o">@</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">WIDTH</span><span class="o">=</span><span class="mi">32</span>
<span class="o">@</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">TYPE</span><span class="o">=</span><span class="n">wb</span>
<span class="o">@</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">CLOCK</span><span class="o">.</span><span class="n">NAME</span><span class="o">=</span><span class="n">clk</span>
<span class="o">@</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">CLOCK</span><span class="o">.</span><span class="n">WIRE</span><span class="o">=</span><span class="n">i_clk</span>
<span class="o">@</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">CLOCK</span><span class="o">.</span><span class="n">FREQUENCY</span><span class="o">=</span><span class="mi">1000000</span></code></pre></figure>

<p>This allows us to reference the bus clock using <code class="highlighter-rouge">@$(SLAVE.BUS.CLOCK.WIRE)</code>,
or even the <code class="highlighter-rouge">wb</code> prefix of the bus as <code class="highlighter-rouge">@$(SLAVE.BUS.NAME)</code>.  This means that
the address width of this slave is given by <code class="highlighter-rouge">@$(SLAVE.BUS.AWID)</code> and the
bus data width is given by <code class="highlighter-rouge">@$(SLAVE.BUS.WIDTH)</code>.</p>

<p>If you find these long key names tedious, you can rename them within your
component.  For example, we could have created a key <code class="highlighter-rouge">@CLK</code> and assigned
it to hold the value of <code class="highlighter-rouge">@$(SLAVE.BUS.CLOCK.WIRE)</code>, another key <code class="highlighter-rouge">@AW</code> and
assigned it to hold the value of <code class="highlighter-rouge">@$(SLAVE.BUS.AWID)</code>, and other keys <code class="highlighter-rouge">@BS</code>
and <code class="highlighter-rouge">@DW</code> as in,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="o">@</span><span class="n">CLK</span><span class="o">=</span> <span class="o">@</span><span class="p">$(</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">CLOCK</span><span class="o">.</span><span class="n">WIRE</span><span class="p">)</span>
<span class="o">@</span><span class="n">AW</span><span class="o">=</span> <span class="o">@</span><span class="p">$(</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">AWID</span><span class="p">)</span>
<span class="o">@</span><span class="n">BS</span><span class="o">=</span> <span class="o">@</span><span class="p">$(</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">NAME</span><span class="p">)</span>
<span class="o">@</span><span class="n">DW</span><span class="o">=</span> <span class="o">@</span><span class="p">$(</span><span class="n">SLAVE</span><span class="o">.</span><span class="n">BUS</span><span class="o">.</span><span class="n">WIDTH</span><span class="p">)</span></code></pre></figure>

<p>Had we done so, our <code class="highlighter-rouge">@MAIN.DEFNS</code> and <code class="highlighter-rouge">@MAIN.INSERT</code> tag might have been
simplified to</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.DEFNS=
	reg	[@$(AW)-1:0]	r_@$(PREFIX)_addr;
@MAIN.INSERT=
	always @(posedge @$(CLK))
		if (@$(BN)_err)
			r_@$(PREFIX)_addr &lt;= @$(BN)_addr;
	assign	@$(PREFIX)_data = { {(@$(DW)-2-@$(AW)){1'b0}},
			r_@$(PREFIX)_addr, 2'b00 };</code></pre></figure>

<p>What this particular configuration file does different from our previous
examples is to reference information about the <em>bus</em> using the keys defined
for any bus.  This allows the bus error address register, defined above, to
only have as many bits defined as necessary
(one for each address line, or <code class="highlighter-rouge">@$(AW)</code>).  Not only will this register size
be adjusted if the width of the address bus is adjusted, but it will also
be adjusted if the width of the data bus is adjusted–as illustrated by the
<code class="highlighter-rouge">@$(PREFIX)_data</code>’s dependence upon both <code class="highlighter-rouge">@$(DW)</code> and <code class="highlighter-rouge">@$(AW)</code>.  Had we worked
a little harder, we might’ve also set up the trailing two zero bits to
expand as necessary with any changing data width.</p>

<h2 id="write-support-for-the-same-value">Write support for the same value</h2>

<p>Now that you know how to read a value from the bus, what about writing to
registers on the bus?</p>

<p>The <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/rawreg.txt">raw register configuration
file</a>
shows how this might be done.  This example peripheral does nothing but set
a value you give to it upon any write, and then allow you to read that value
back later.</p>

<p>In many ways, this peripheral is almost identical to the <a href="">power counter
component</a>
we discussed earlier.  The difference is that this register can be set via
a bus write.  For this reason, the boiler plate setup is almost identical.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@PREFIX=rawreg
@DEVID=RAWREG
@NADDR=1
@SLAVE.TYPE=SINGLE
@SLAVE.BUS=wb
@REGS.N=1
@REGS.0= 0 R_@$(DEVID) @$(DEVID)
@MAIN.DEFNS=
	reg	[31:0]	r_@$(PREFIX)_data;</code></pre></figure>

<p>The difference is found within the <code class="highlighter-rouge">@MAIN.INSERT</code> tag describing how this
peripheral deals with the bus.  In this case, for any bus access, <code class="highlighter-rouge">wb_stb</code>,
that is also a write, <code class="highlighter-rouge">wb_we</code>, and that references this peripheral,
<code class="highlighter-rouge">@$(PREFIX)_sel</code>, we update our register.  (Remember how a <a href="/zipcpu/2017/05/29/simple-wishbone.html">generic wishbone
slave interacts with the bus</a>?)</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.INSERT=
	initial	r_@$(PREFIX)_data = 32'h0;
	always @(posedge i_clk)
		if ((wb_stb)&amp;&amp;(wb_we)&amp;&amp;(@$(PREFIX)_sel))
			r_@$(PREFIX)_data &lt;= wb_data;
	assign	@$(PREFIX)_data = r_@$(PREFIX)_data;</code></pre></figure>

<p>We could have made this module more generic by replacing the
<code class="highlighter-rouge">wb</code> prefixes with <code class="highlighter-rouge">@$(SLAVE.BUS.NAME)</code>.  Had we done that, we would have then
been able to use this across busses with different names.  For now, because
of how we’ve defined this, this component will always only ever read
it’s values from the bus with a <code class="highlighter-rouge">wb_</code> prefix.</p>

<h2 id="reading-values-from-external-ports">Reading values from external ports</h2>

<p>Let’s look at <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/spio.txt">one more
example</a>
along this same theme.  Suppose we wanted to add to our design a register
allowing us to:</p>

<ol>
  <li>
    <p>Read from the buttons in our design</p>
  </li>
  <li>
    <p>Read from any switches on our board</p>
  </li>
  <li>
    <p>Set any output LEDs</p>
  </li>
</ol>

<p>Unlike our previous examples, this example will require access to I/O
ports within our design, so we’ll have to deal with this when we get there.</p>

<p>We’ll start with the keys we’ve already defined above.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@PREFIX=spio
@NADDR=1
@DEVID=SPIO
@SLAVE.TYPE=SINGLE
@SLAVE.BUS=wb
@REGS.N=1
@REGS.0= 0 R_@$(DEVID)		@$(DEVID)</code></pre></figure>

<p>Now let’s walk through the new keys.</p>

<p>The first of these new keys is an <code class="highlighter-rouge">@ACCESS</code> key.  It’s an optional key, as you
can tell from the fact none of our other components above had this key.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@ACCESS=SPIO_ACCESS</code></pre></figure>

<p>This <code class="highlighter-rouge">@ACCESS</code> key, if present, will create a <code class="highlighter-rouge">define</code> line at the beginning
of our
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
file.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`define</span>	<span class="n">SPIO_ACCESS</span></code></pre></figure>

<p>The <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/Makefile">RTL
Makefile</a>
then includes instructions to copy this line from the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
file into a
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/design.h">design.h</a>
file, allowing any associated C++ files to know whether or not this component
is a part of our design.</p>

<p>The next new key is the <code class="highlighter-rouge">@MAIN.PORTLIST</code> key.  This key specifies values to be
placed at the top of
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
within the portlist for the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.PORTLIST=
		// @$(DEVID) interface
		i_sw, i_btnc, i_btnd, i_btnl, i_btnr, i_btnu, o_led</code></pre></figure>

<p>This key is unique in that the items within it are separated by commas,
but that the last item has no comma following it.  This allows
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
to put a comma between items, or not, as is necessary to compose
multiple component I/Os into a design.</p>

<p>Immediately following the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main module</a> declaration
is an opportunity to place parameters.  Let’s identify that this particular
design has five buttons, 8 LEDs, and 8 switches.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.PARAM=
	// @$(DEVID) interface
	localparam	NBTN=5,
			NLEDS=8,
			NSW=8;</code></pre></figure>

<p>Following any <code class="highlighter-rouge">@MAIN.PARAM</code> values, you can declare your I/O values.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.IODECL=
	input	wire	[(NSW-1):0]	i_sw;
	input	wire		i_btnc, i_btnd, i_btnl, i_btnr, i_btnu;
	output	wire	[(NLEDS-1):0]	o_led;</code></pre></figure>

<p>As with so many other keys, these values will simply be pasted into the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
file following any key-value substitutions.</p>

<p>In a like manner to the way we’ve defined variables before, we’ll define a
five valued logic vector to hold the inputs from each of our button values.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.DEFNS=
	wire	[(NBTN-1):0]	w_btn;</code></pre></figure>

<p>This will get placed with all of the wire and register declarations at the
top of the
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
file.</p>

<p>The next required piece is the <code class="highlighter-rouge">@MAIN.INSERT</code> key, telling
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
how we are going to interact with the bus.  In this case, we’ll compose
our five buttons into a quick vector, and then reference a special purpose
I/O module I call
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/spio.v">spio.v</a>.
This module handles bus writes and bus reads, and is a generic
<a href="/doc/wbspec_b4.pdf">wishbone</a>
peripheral.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@MAIN.INSERT=
	assign	w_btn = { i_btnc, i_btnd, i_btnl, i_btnr, i_btnu };

	spio #(.NBTN(NBTN), .NLEDS(NLEDS), .NSW(NSW)) @$(PREFIX)i(i_clk,
		wb_cyc, (wb_stb)&amp;&amp;(@$(PREFIX)_sel), wb_we, wb_data, wb_sel,
			@$(PREFIX)_ack, @$(PREFIX)_stall, @$(PREFIX)_data,
		i_sw, w_btn, o_led, spio_int);
@MAIN.ALT=
	assign	w_btn    = 0;
	assign	o_led    = 0;</code></pre></figure>

<p>Since this is a generic peripheral, it needs to return
<code class="highlighter-rouge">@$(PREFIX)_ack</code> and <code class="highlighter-rouge">@$(PREFIX)_stall</code> values–even though we’ll ignore
them since this is peripheral has a <code class="highlighter-rouge">SINGLE</code> bus interaction type.</p>

<p>The new key that we haven’t discussed yet is the <code class="highlighter-rouge">@MAIN.ALT</code> key.  This
key defines the logic that will be used in the case the <code class="highlighter-rouge">@ACCESS</code> component
defining <code class="highlighter-rouge">SPIO_ACCESS</code> is not defined.  Items within this keyword
are used for defining values external ports, such as <code class="highlighter-rouge">o_led</code>, should be
given should the primary logic for this component not be used.</p>

<p>This component contains one last tag, <code class="highlighter-rouge">@INT.SPIO.WIRE</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">@INT.SPIO.WIRE=spio_int</code></pre></figure>

<p>This tag identifies that <code class="highlighter-rouge">spio_int</code> is a single wire, and that it may be
assigned to an interrupt vector as the interrupt generated by this peripheral.</p>

<p>Feel free to take a look at the
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
generated
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-generated/main.v">main.v</a>
file and see how we did!</p>

<h2 id="more-to-come">More to come!</h2>

<p>The goal of
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
was to be able to have a simple command line interface–simply run
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
with a list of peripherals, and get output files.  You might wish to test
this by <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/Makefile">removing any of the above
files</a>
from the <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
command line to see how well we did, or even add some configuration files
of your own.</p>

<p>If you choose to try this, you’ll notice that the
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
<a href="https://github.com/ZipCPU/autofpga-demo">demo project</a>
contains more configuration files than the ones we’ve looked at today.
These are the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/bkram.txt">block RAM configuration
file</a>,
the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/clock.txt">clock
file</a>
that defines the clock and the reset wires,
the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/hexbus.txt">debugging bus configuration
file</a>,
and a <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/global.txt">global
configuration</a>
file. Of these, only the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/bkram.txt">block RAM configuration
file</a>
may be easily removed.  The <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/hexbus.txt">debugging bus configuration
file</a>
defines our bus master, and a bus doesn’t work very well without a master, so it
would make more sense to replace that one than to remove it if you wish to
change it.  The
<a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/clock.txt">clock file</a>
and <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/global.txt">global
configuration</a> file are not as easily replaced.</p>

<p>So, let’s come back and discuss the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/auto-data/bkram.txt">block RAM configuration
file</a>
at a later time.  Specifically, you’ll love how easy it is to change the
size of the <a href="https://github.com/ZipCPU/autofpga-demo/blob/master/rtl/memdev.v">block RAM</a>, and how well that size information is propagated throughout a
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>-based design.</p>

<p>We’ll also need to come back later to discuss how a
<a href="/about/wbspec_b4.pdf">wishbone bus</a>
<a href="/blog/2017/06/08/simple-wb-master.html">master</a>
can be connected using
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>.</p>

<p>Until that time, our
<a href="https://github.com/ZipCPU/autofpga-demo/">demonstration project</a>
plus this article should be enough to build and control most beginning
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
tasks.  Even better, and unlike most proprietary solutions, all of the code
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>
builds is availble for your inspection and learning pleasure.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>He answered and said, Whether he be a sinner or no, I know not: one thing I know, that, whereas I was blind, now I see</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
