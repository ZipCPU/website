<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Introducing the ZipCPU v3.0</title>
  <meta name="description" content="It’s time to announce a new version of theZipCPU:ZipCPU v3.0!">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2023/05/29/zipcpu-3p0.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Introducing the ZipCPU v3.0</h1>
    <p class="post-meta"><time datetime="2023-05-29T00:00:00-04:00" itemprop="datePublished">May 29, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>It’s time to announce a new version of the
<a href="/about/zipcpu.html">ZipCPU</a>:
<a href="/about/zipcpu.html">ZipCPU</a> v3.0!</p>

<p>For reference, here’s how the
<a href="/about/zipcpu.html">ZipCPU</a>’s
development has taken place over the years:</p>

<h2 id="zipcpu-v01">ZipCPU v0.1</h2>

<p>Way back in the beginning, the 
<a href="/about/zipcpu.html">ZipCPU</a> had four bit opcodes and only
16x16-bit multiplies.  It truly had a very limited instruction set.  That said,
the instruction set design was too limited to be very functional.</p>

<p>This original instruction set didn’t even last a half a year.</p>

<h2 id="zipcpu-v10">ZipCPU v1.0</h2>

<p>The <a href="/about/zipcpu.html">ZipCPU</a>,
v1.0, had 32-bit bytes and no octet level access.  If you wanted to read or
write an octet (8bit value) in memory, you needed to read a 32b word, modify
the 8b value within it, and write the 32b word back.</p>

<p>As a result, the <a href="/about/zipcpu.html">ZipCPU</a>, v1.0, did not
have C library support.</p>

<h2 id="zipcpu-v20">ZipCPU v2.0</h2>

<p><a href="/about/zipcpu.html">ZipCPU</a> v2.0 provided 8-bit byte support,
better compiler support, and full C-library support.  The instruction set
also included changes to the supported condition codes as well.</p>

<h2 id="now-announcing-zipcpu-v30">Now: Announcing ZipCPU v3.0</h2>

<p>The good news is that the
<a href="/about/zipcpu.html">ZipCPU</a>’s
instruction set, as shown in Fig. 1, has not changed as part of this release.</p>

<table align="center" style="float: right"><caption>Fig 1. The ZipCPU instruction set and encoding</caption><tr><td><img src="/img/zipcpuv3/nextgen.png" alt="" width="480" /></td></tr></table>

<p>Although there have been (essentially) no changes to the instruction set
with this release, it feels like everything else associated with the
<a href="/about/zipcpu.html">ZipCPU</a> has changed:</p>

<ul>
  <li>
    <p>This upgrade started with a core refactor, so that the
<a href="/about/zipcpu.html">ZipCPU</a>
could support more than just the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>.  As a
result, the <a href="/about/zipcpu.html">ZipCPU</a> can now support
<a href="/zipcpu/2018/03/21/dblfetch.html">Wishbone</a>,
<a href="/zipcpu/2021/04/17/axilops.html">AXI-Lite</a>, and <a href="/zipcpu/2021/09/30/axiops.html">(full)
AXI</a>.</p>
  </li>
  <li>
    <p>The new memory interfaces are now bus width independent, allowing the
<a href="/about/zipcpu.html">ZipCPU</a>
to work on buses larger than 32-bits.  Indeed, it’s since been used on
64-bit and 512-bit buses quite successfully.</p>
  </li>
  <li>
    <p>The core refactor led to better formal proofs, since the memory components
can now be verified independently.</p>
  </li>
  <li>
    <p>The DMA has also been rewritten for bus width independence.  This rewrite
provides even more capabilities along the way.</p>
  </li>
  <li>
    <p>The debug port has been rewritten.  This change is the one really
necessitating a new major release, as it won’t even appear to be backwards
compatible with prior releases.  Instead of two registers, the
rewritten <a href="/about/zipcpu.html">ZipCPU</a>
debug port is now accessed via 33 registers: a control
register and one debug register address per each of the 32 internal registers.</p>
  </li>
  <li>
    <p>The companion core configuration file has been replaced by parameter settings
at the CPU wrapper level.  Parameter names have been formalized across
wrappers, so common names configure common capabilities.</p>
  </li>
  <li>
    <p>The <a href="/about/zipcpu.html">ZipCPU</a> now has <a href="/zipcpu/2022/07/04/zipsim.html">its own
simulation infrastructure for CPU level
testing</a>.
This new infrastructure makes it possible to 1) test multiple configurations
of the CPU, 2) test the CPU in multi-processor environments, 3) verify that
the clock can be stopped and restarted, 4) verify the
<a href="/about/zipcpu.html">ZipCPU</a> in both
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
and AXI configurations, 5) verify the lock instructions, and 6) verify the
CPU’s new debugging port.  This new simulation infrastructure also includes
the ability to measure test coverage.</p>
  </li>
  <li>
    <p>In perhaps the only downgrade of capabilities, the NOOP/SIM instructions
NEXIT and SEXIT have lost their ability to exit a simulation with a given
exit code.</p>
  </li>
  <li>
    <p>Finally, the <a href="/about/zipcpu.html">ZipCPU</a>
has the ability to stop its clock if necessary.  Using this outside of the
simulator will likely require hardware level support, so for the time being
this may be a simulation only capability.</p>
  </li>
</ul>

<p>Put together, these are enough changes to warrant a new major release.</p>

<p>Let’s take a moment to discuss these changes.</p>

<h2 id="expanding-the-bus">Expanding the Bus</h2>

<p>Perhaps the one reason driving this upgrade more than any other was the bus,
both in width and in type.  I needed to test a variety of AXI peripherals I
was building and wanted (needed, really) a CPU that could speak both AXI and
AXI-Lite.  Some of these peripherals required bus sizes wider than 32-bits.
Worse, the prior version of the <a href="/about/zipcpu.html">ZipCPU</a>’s
core included the memory ports within the CPU core itself forcing the CPU
to be <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> only.</p>

<p>This proved to be a verification nightmare.  It meant that, in order to verify
the <a href="/about/zipcpu.html">ZipCPU</a>’s core functionality, I
needed to verify the <a href="/about/zipcpu.html">ZipCPU</a>
against every possible memory interface it might have.</p>

<p>To make matters worse, which memory model the
<a href="/about/zipcpu.html">ZipCPU</a>
used was determined not by parameter, but by macro.  This made the
<a href="/about/zipcpu.html">ZipCPU</a>
harder to configure or adjust in any design.</p>

<p>The fix was to refactor the <a href="/about/zipcpu.html">ZipCPU</a>.  In
the process, the interfaces to the prefetch, and the interface to the memory
unit, were both standardized as shown in Fig. 2 below.</p>

<table align="center" style="float: none"><caption>Fig 2. The ZipCPU's refactored architecture</caption><tr><td><img src="/img/tweets/zipcpu/cpu-verification.svg" alt="" width="780" /></td></tr></table>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> core
was then verified against a pair of formal interface specifications,
as were the instruction fetch and memory units.  This made it possible to
formally verify those units separate from
the <a href="/about/zipcpu.html">ZipCPU</a> core.</p>

<p>The refactor wasn’t quite seamless.  <a href="/zipcpu/2021/09/30/axiops.html">AXI exclusive
access</a> required a different
interface to the <a href="/about/zipcpu.html">ZipCPU</a> than
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
exclusive access (i.e. bus locking) required.  In
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>, all you need
to do is hold the cycle line high between any two accesses to do any sort of
“read-modify-write” routine.  In AXI, on the other hand, any
“read-modify-write” routine won’t know until the write return whether the
sequence was successful or not.  Then, if the sequence was not successful, the
“read-modify-write” routine needs to be repeated.  To add this new capability,
the core now provides the AXI module the instruction pointer at the beginning
of any “read-modify-write” sequence.  If the “read-modify-write” sequence then
fails, the memory module returns as if it were returning from a “load into the
program counter” access causing a jump to the beginning of the sequence.</p>

<p>The good news is that, once I had the AXI interface I needed, <a href="/zipcpu/2021/07/23/cpusim.html">I could then
test and demonstrate ASIC IP using this
approach</a>.  As a result, I’ve
used this upgraded <a href="/about/zipcpu.html">ZipCPU</a> to test both
a <a href="https://www.arasan.com/product/xspi-master-ip/">NOR flash controller</a>
and a <a href="https://www.arasan.com/product/xspi-psram-master/">hyperRAM controller</a>
using my <a href="http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists">Arty board</a>,
as well as an <a href="https://www.arasan.com/products/nand-flash/">ONFI flash
controller</a> (via simulation only).
This has provided me with the valuable ability of <a href="/zipcpu/2021/07/23/cpusim.html">debugging system software
entirely in simulation</a>–and
thus being able to answer why the device did (or did not) respond as expected.</p>

<h2 id="upgrading-the-dma">Upgrading the DMA</h2>

<p>Some time ago, someone contacted me to ask if I’d be willing to work with them
to build an “ideal-DMA”.  They had noticed that it seemed like every IP
component they integrated into their SOC required a DMA, and so it felt like
they had DMA’s running all through their SOC.  Wouldn’t it make more sense,
they asked, if we could just build one “better”/”ideal” DMA and not to keep
building all these special purpose DMAs throughout their SOC?</p>

<table align="center" style="float: left"><tr><td><img src="/img/zipcpuv3/one-dma.svg" alt="" width="240" /></td></tr></table>

<p>No, the deal didn’t go through.  I didn’t have the hours to spare at the time,
and we had some disagreements over the legal terms of working together.
However, this did leave me asking the question, what would constitute an ideal
DMA?</p>

<p>Then I needed to use <a href="https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/peripherals/wbdmac.v">my
DMA</a>
with one of these wider bus sizes.  Specifically, I was working on a <a href="https://github.com/ZipCPU/eth10g/">project
requiring a 512b bus
width</a>, and <a href="/zipcpu/2018/02/12/zbasic-intro.html">I use the DMA as part of
the process of loading CPU memory images from flash to RAM in the first
place</a>.
At this point, my <a href="https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/peripherals/wbdmac.v">one-32b-size-fits-all DMA</a>
just couldn’t connect to the bus.
It <em>needed</em> to be upgraded.  I no longer had a choice.</p>

<p>So, let’s think of all the lessons I’ve learned over the last couple of years
using the last DMA.  What would a better DMA look like?  Specifically, a DMA
is designed to move data around without CPU intervention.  What kinds of data
moves are required?</p>

<ul>
  <li>
    <p>The most obvious requirement is for a <code class="language-plaintext highlighter-rouge">memcpy()</code> type of data move, that
moves memory from one location to somewhere else.  Such a capability needs
to move memory as fast as possible (it <em>is</em> a DMA, right?), and so it really
needs to use the whole bus width.</p>

    <p>It also needs octet level alignment in order to be relevant–unaligned
requests need to be expected, and handled appropriately.</p>
  </li>
  <li>
    <p>What about peripherals?  Consider audio peripherals, for example.</p>

    <p>A microphone peripheral might capture 16b audio samples, generate an
interrupt after each sample is captured, and then need its sample to be read
and copied to memory.</p>

    <p>A D/A peripheral might be similar: generating an interrupt whenever it
consumes a sample and needs another.  The DMA should then need to read the
new sample from memory and write it to this peripheral.</p>

    <p>In both cases, the data source address for the microphone peripheral,
or the data destination address of the speaker, won’t change but the
address in memory will.</p>

    <p>To make matters worse, the audio peripheral might require 8b or 16b values
which would be packed in memory.  Hence the DMA needs to be able to read
or write less than a full bus word at a time.</p>
  </li>
  <li>
    <p>Years ago, I wrote a controller for an <a href="https://github.com/ZipCPU/openarty/blob/master/rtl/wboledrgb.v">RGB based OLED
peripheral</a>.
I demonstrated the capability of this controller by alternately placing the
Gisselquist Technology logo and my own mug onto the display.  In this case,
the peripheral understood 32b command and data words, but the data had to
be transferred one word at a time.  An interrupt would then tell the CPU
when it was time to transfer the next 32b word.  To use a DMA, the DMA
would need to wait for the interrupt, transfer the next word from memory
to a constant destination address, then wait for the next interrupt again.</p>
  </li>
  <li>
    <p>How about block peripherals?  For example, I have an
<a href="https://github.com/ZipCPU/sdspi">SDSPI peripheral</a>
which allows me access to an SD card via its (optional) SPI interface.  The
peripheral has two 32b data ports for transfers.  Each port leads to a 512B
FIFO, and the controller is expected to ping-pong between the two ports
for speed.</p>

    <p>Reading from the SD card will fill one of these FIFOs and then trigger
an interrupt.  At that point, a DMA needs to read (many times) from the
same 32b address, form wide bus words together, and then write the results
to memory.</p>

    <p>Writing to the same FIFO is similar, only the interrupt works in a different
fashion.  The CPU would first call the DMA to transfer a block (typically
512 bytes) of memory to the data port FIFO.  This block would need to be
read at whatever the bus size is, and then packaged into 32bit writes to fill
the FIFO.  Once the transfer is done, the CPU should be interrupted, and
the CPU can then instruct the
<a href="https://github.com/ZipCPU/sdspi">SDSPI peripheral</a>
to write the information to the external SD card.</p>
  </li>
</ul>

<table align="center" style="float: left; padding: 25px"><caption>Fig 3. Requirements of an upgraded DMA</caption><tr><td><img src="/img/zipcpuv3/betterdma.svg" alt="" width="480" /></td></tr></table>

<p>From these requirements alone, what does a good DMA need to do?</p>

<ul>
  <li>
    <p>(Optinally) Wait on an interrupt before starting any transfer.  Which
interrupt will need to be user selectable.</p>
  </li>
  <li>
    <p>Transfer a given per-interrupt amount, perhaps less than the whole transfer.</p>
  </li>
  <li>
    <p>Be able to read either 8b, 16b, 32b, or the full bus width at a time.</p>
  </li>
  <li>
    <p>Be able to write either 8b, 16b, 32b, or the full bus width at a time.</p>
  </li>
  <li>
    <p>Accessing peripheral memory may require that the DMA not increment the
source or destination address, whereas accesses to memory will require both
that the source/destination address increment and that accesses may (or may
not) be aligned.</p>
  </li>
</ul>

<p>The <a href="https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/zipdma/zipdma.v">new ZipDMA</a>
now offers all these abilities.  It’s an awesome DMA capability.</p>

<p>You can see the basic structure of this <a href="https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/zipdma/zipdma.v">new
DMA</a> in Fig. 4 below.</p>

<table align="center" style="float: none"><caption>Fig 4. The new ZipCPU DMA's structure</caption><tr><td><img src="/img/zipcpuv3/zipdma-blocks.svg" alt="" width="780" /></td></tr></table>

<p>Requests are made to the DMA, then sent to an FSM.  The FSM then breaks those
DMA requests into chunks.  Remember, unlike AXI,
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> can only operate
in one direction at a time.  Therefore, all operations need to take place in
chunks where data is first read, then written.  In terms of the chunk processing
itself, there’s a memory to stream processor to read data from the bus.  This
will read 8b, 16b, 32b, or the full bus width of data per clock cycle.  Data
are then packed by a gearbox prior to going into a FIFO.  Coming out of the
FIFO, the same data words are now unpacked into the user’s desired transfer
width: 8b, 16b, 32b, or the full width of the bus.  As the final per-chunk step,
this data is placed onto the bus and written.</p>

<p>The biggest problem with this new capability?  There’s only one ZipDMA.  If
it’s so good that every process needs it, there will be contention for it.
The second biggest problem?  This DMA capability is (currently) a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
<em>only</em> capability.  I don’t (yet) have an AXI version of it.  Further work on
this DMA will
concentrate on making sure all of the various capabilities within it are
properly verified–as I don’t yet have a good set of DMA focused test cases
for that purpose.</p>

<h2 id="a-better-debugging-interface">A Better Debugging Interface</h2>

<p>The original <a href="/about/zipcpu.html">ZipCPU</a> had only two
registers for its in-hardware debugging interface.  One register could be used
to <a href="/zipcpu/2017/08/25/hw-debugging.html">reset, start, stop, and step the
CPU</a>.  This same
register could be used to select which internal
<a href="/about/zipcpu.html">ZipCPU</a> register the
second register would access.  Reads and writes to this second register would
then either read or update the actual (selected) register within the
<a href="/about/zipcpu.html">ZipCPU</a>.  While this worked, it didn’t
work well.</p>

<p>To illustrate the problem, consider Fig. 5 below.</p>

<table align="center" style="float: right"><caption>Fig 5. Before the update: two round-trips per request</caption><tr><td><img src="/img/zipcpuv3/slowdbg.svg" alt="" width="420" /></td></tr></table>

<p>Reading any register from this interface required <em>two</em> accesses, and therefore
<em>two</em> round trips through the <a href="/blog/2017/06/05/wb-bridge-overview.html">debugging
bus</a> to the FPGA.</p>

<p>This interface struggled when I tried to debug
<a href="/about/zipcpu.html">ZipCPU</a> programs over my serial port
“<a href="/blog/2017/06/05/wb-bridge-overview.html">debugging bus</a>”.
The debugger wanted the ability to read all of the
<a href="/about/zipcpu.html">ZipCPU</a>’s
registers.  The two register interface then required that I first write the
to the first register, that write then needed to complete, then I would read
the data register, and that read would need to complete, all before I could
move on to reading the second CPU register.  That required two round trip
transactions just to read one register, or sixty four round trip transactions
to read all of the CPU’s registers.  (There are 16 supervisor register and
16 user registers.)</p>

<p>This could take a long time over a serial port.</p>

<p>My <a href="/blog/2017/06/05/wb-bridge-overview.html">debugging bus</a>
has another type of read command: one where you can read multiple sequential
addresses in a row.  This operation only requires sending
the request (read thirty two 32b registers) and then waiting for the results.
There’s no requirement for a round-trip handshake in the meantime.  Instead,
any handshaking is complete once the entire operation is complete.  The
CPU just needed a minor upgrade to provide enough addresses on the bus to do
this.</p>

<p>You can see how this operation is different in Fig. 6 below.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 6. After the update, one request yields all results</caption><tr><td><img src="/img/zipcpuv3/fastdbg.svg" alt="" width="420" /></td></tr></table>

<p>Even better, I formalized how the CPU was to respond to accesses.  Debug
register reads shouldn’t need to stop the CPU–that way you can monitor
registers while the CPU is running, at the risk of reading an incoherent set
of registers.  This might be useful to know that the CPU is running, or where
it might be in its processing.  Bus writes, on the other hand, do need to stop
the CPU.</p>

<h2 id="upgrading-the-simulation-environment">Upgrading the Simulation Environment</h2>

<p>The original <a href="/about/zipcpu.html">ZipCPU</a>’s
purpose was to be absolutely as light on resources as
possible.  However, depending on the project, the “lightest resource” CPU might
have too little power.  I therefore quickly learned that the
<a href="/about/zipcpu.html">ZipCPU</a>
would need the ability to expand or adjust its area to fit the available area,
while optimizing the CPU’s speed in that area.  Example configurations might
include whether or not the CPU used caches, or just very simple data accessing
routines, whether the hardware supported multiplies via hardware-specific
DSP elements, whether <a href="/zipcpu/2021/07/03/slowmpy.html">an all–RTL
multiply</a> was required, or
whether the CPU should be built with no capability for multiplies at all.  All
this led to an early on requirement that the
<a href="/about/zipcpu.html">ZipCPU</a> needed to be highly configurable.</p>

<p>My original approach to all this configurability was to create a separate
configuration file containing a set of macros in it.  The CPU’s configuration
would then depend on if or how those macros were configured.  I also had a
separate project, one I called <a href="https://github.com/ZipCPU/zbasic">ZBasic</a>,
which would be used to test the CPU.  Within the
<a href="https://github.com/ZipCPU/zbasic">ZBasic project</a>
was a piece of CPU testing software that could then
be used to test whether each of the CPU’s instructions worked.  All of this put
together worked great for testing a single configuration–the one described by
the macro file.  However I kept running into problems where I’d port the
<a href="/about/zipcpu.html">ZipCPU</a>
to some piece of hardware or other and it wouldn’t work.  Perhaps I had made
some change some time earlier, and only tested other configurations to prove
that change.  Whatever the cause, I was often left debugging the CPU in
hardware–the one place you don’t want to debug the CPU.</p>

<p>As it turns out, <a href="/zipcpu/2022/07/04/zipsim.html">it takes some engineering thought to build a test
setup that can check all configurations of a highly configurable
CPU</a>.</p>

<p>Version 3.0 of the <a href="/about/zipcpu.html">ZipCPU</a>
comes with such an infrastructure.  <a href="/zipcpu/2022/07/04/zipsim.html">I’ve written about
it before</a>.
It centers around a <a href="https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/sim_run.pl">Perl script</a>
and a <a href="https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/rtl/sim_testcases.txt">file describing a series of tests</a>.
Each test specifies a canned configuration, a piece of CPU software,
and one of two environments: a <a href="https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/rtl/wb_tb.v">Wishbone
environment</a>
and an <a href="https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/rtl/axi_tb.v">AXI environment</a>.
Each test can also include any parameter overrides, so the default environments
can be overridden for the test.  I override these defaults, for example, to
adjust the bus width for non-32bit bus testing.  All told, there are 105 tests
that take just over an hour to run under
<a href="https://www.veripool.org/verilator/">Verilator</a>, or just over five days when
using <a href="https://steveicarus.github.io/iverilog/">Icarus Verilog</a>.</p>

<p>Simulation testing, however, is perhaps the one place where the
<a href="/about/zipcpu.html">ZipCPU</a>’s
instruction set is now less capable than before.</p>

<p>As background, the <a href="/about/zipcpu.html">ZipCPU</a> had two
special instructions, the <code class="language-plaintext highlighter-rouge">NOOP</code> and <code class="language-plaintext highlighter-rouge">SIM</code> instructions, that took specialized
arguments when run in simulation.  In hardware, the <code class="language-plaintext highlighter-rouge">NOOP</code> instructions turned
into standard no-operation instructions, whereas the <code class="language-plaintext highlighter-rouge">SIM</code> instructions turned
into illegal instructions.  That functionality alone left 22-bits of instruction
space which I could use for additional functionality,
from which I had carved out sub-instructions to write characters or even
register values to the simulation log.  One special instruction would dump the
entire register set.  Another special instruction, encoded as either <code class="language-plaintext highlighter-rouge">NEXIT</code>
(NOOP based) or <code class="language-plaintext highlighter-rouge">SEXIT</code> (SIM based) was supposed to cause the simulation to
end with a given exit code.  It’s this x<code class="language-plaintext highlighter-rouge">EXIT</code> code’s functionality that’s
been lost.</p>

<p>The reason had to do with the implementation of these instructions.  They were
originally implemented by the
<a href="https://www.veripool.org/verilator/">Verilator</a>
C++ wrapper, and that wrapper required the ability to take a sneak-peek into the
<a href="/about/zipcpu.html">ZipCPU</a>’s internals to know when to
execute these instructions.  This lead to two problems.  First, the instructions
would never work in a more traditional simulator that didn’t have or need such
a wrapper–such as <a href="https://steveicarus.github.io/iverilog/">Icarus
Verilog</a> or a commercial simulator.
The second problem was that the interface used by the wrapper kept changing.
Since the features it depended upon weren’t standard Verilog
but rather depended upon <a href="https://www.veripool.org/verilator/">Verilator</a>’s
internals, the interface broke every time
<a href="https://www.veripool.org/verilator/">Verilator</a>
changed its internal data structure.</p>

<p>In the end, I resolved these problems by rewriting how the <code class="language-plaintext highlighter-rouge">NOOP</code> and <code class="language-plaintext highlighter-rouge">SIM</code>
instructions were handled, and the new rewrite was done entirely in Verilog.
Using Verilog only, I could guarantee that all Verilog compliant simulators
would correctly implement these instructions.  However, I could not properly
implement the exit code requirement of the <code class="language-plaintext highlighter-rouge">NEXIT</code> and <code class="language-plaintext highlighter-rouge">SEXIT</code> instructions.
Hence, while the CPU has gained the capability of executing NOOP and SIM
instructions under a general purpose Verilog simulator, it has lost the
capability to exit the simulation with a specific exit code.</p>

<p>In many ways, this is a small price to pay for better interoperability
between simulators, and the ability to simulate/test the CPU under a large
number of configurations.</p>

<h2 id="clock-gating">Clock Gating</h2>

<p>One of the <a href="/about/zipcpu.html">ZipCPU</a>’s
goals has always been low-logic.  A truly low logic CPU <em>should</em> also be able
to be a low-power CPU.  In ASIC designs, low power often means
<a href="/blog/2021/10/26/clkgate.html">clock gating</a>,
and the <a href="/about/zipcpu.html">ZipCPU</a> has had a plan for
<a href="/blog/2021/10/26/clkgate.html">clock gating</a>
since the beginning.</p>

<p>Here’s how it works: the <a href="/about/zipcpu.html">ZipCPU</a>
supports two special modes, a <code class="language-plaintext highlighter-rouge">HALT</code> mode and a <code class="language-plaintext highlighter-rouge">SLEEP</code> mode.  <code class="language-plaintext highlighter-rouge">SLEEP</code> will
cause the <a href="/about/zipcpu.html">ZipCPU</a> to stop executing
instructions until the next interrupt.  <code class="language-plaintext highlighter-rouge">HALT</code> causes the
<a href="/about/zipcpu.html">ZipCPU</a> to stop executing instructions
at all, and thus to come to a complete halt until either the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debug port</a> or an
external reset restarts the CPU.  These modes were originally envisioned to
allow the clock to be stopped by the CPU.</p>

<p>This <a href="/blog/2021/10/26/clkgate.html">clock gating capability</a>
is now a reality–in simulation at least.</p>

<p>I’ve also now used
<a href="/blog/2021/10/26/clkgate.html">clock gating</a>
several times, although never in actual
hardware.  The biggest lesson I’ve learned?  The
<a href="/zipcpu/2017/08/25/hw-debugging.html">debug port</a>
<em>must</em> automatically restart the clock to handle requests.  There’s been more
than once when I’ve tried to load a program into the CPU externally from the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugging port</a>,
only to find out later that the reason the CPU was non responsive was
because its clock was stopped.  The next biggest lesson?  Stopping the clock
<em>might</em> lower simulation time, but this isn’t a given.</p>

<p>The end result of this work is that the CPU now has a program to test its
ability to stop the clock.</p>

<h2 id="profiling">Profiling</h2>

<p>There was one more minor update to the
<a href="/about/zipcpu.html">ZipCPU</a>, this one having to do with
profiling.</p>

<p>Yes, I’ve profiled software–mostly benchmarks–running on the 
<a href="/about/zipcpu.html">ZipCPU</a>, although only in simulation.
My current approach involves recording, for every instruction in a given
program, both the number of times that instruction was executed and the
number of clock cycles used to execute that instruction.  The resulting data
has done wonders for speeding up the CPU.</p>

<p>While I’ve been using this data for quite some time, my previous method of
collecting it involved examining
<a href="https://www.veripool.org/verilator/">Verilator</a>’s internal data structures to
access it.  While that has worked in the past, it forces me to update the
<a href="/about/zipcpu.html">ZipCPU</a> every time
<a href="https://www.veripool.org/verilator/">Verilator</a> changes
their internal data structures.  (This was the same problem I had with the
simulation only instructions.)  The solution is to create a proper external
port, coming out of the <a href="/about/zipcpu.html">ZipCPU</a>,
containing this data.  It’s then there if you want to use it, or it can be
ignored if you do not.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a>’s simulation monitor
program had the same problem, where it was also accessing values internal
to the design.  Such values tend to move or get renamed with
<a href="https://www.veripool.org/verilator/">Verilator</a>
updates.  As with the profiler interface, this is easily solved by generating
proper Verilog ports to the CPU containing references to these values for
the monitor.</p>

<p>In both cases, I expect my updated solution to handling these values will
need less maintenance as I use (and maintain) the
<a href="/about/zipcpu.html">ZipCPU</a> over time.</p>

<h2 id="conclusion">Conclusion</h2>

<p>As with any project, the <a href="/about/zipcpu.html">ZipCPU</a>
remains a work in progress.  It will likely remain so for the foreseeable
future.  This is a good thing.  It means the CPU remains supported.</p>

<p>In the meantime, I’ve now used the
<a href="/about/zipcpu.html">ZipCPU</a> on a variety of commercial
projects.  I’ve written about some of them.  For example, it’s been used in
a couple of SONAR applications, and I’m now importing it into a
<a href="https://github.com/ZipCPU/eth10g">10Gb Ethernet switch</a>
application.  I’ve also used it to test, via both simulation and hardware,
pre-ASIC IP cores.  (I.e. IP cores designed for ASICs, but tested in FPGAs
first.)</p>

<p>At present, the <a href="/about/zipcpu.html">ZipCPU</a> has two
drawbacks that I’d still like to address in the future.</p>

<ol>
  <li>
    <p>It still doesn’t have a memory management unit (MMU) to give it access to
virtual memory.  Worse, the MMU I designed years ago for the
<a href="/about/zipcpu.html">ZipCPU</a>
is now abandonware.  It needs to be rebuilt.  Since all of the internal
interfaces have changed between the core and the memory components, the
MMU’s required interfaces have changed as well.  Worse, the
<a href="/about/zipcpu.html">ZipCPU</a>’s core infrastructure may
also need to be adjusted so that it can handle page faults.  For example,
what happens in a compressed instruction if the second half of the
instruction suffers from a page fault?  At present, compressed instructions
do not need to be, and therefore cannot be restarted mid-instruction.</p>

    <p>This upgrade will be required before I can truly run Linux on the
<a href="/about/zipcpu.html">ZipCPU</a>.</p>

    <p>The good news is that I don’t have any applications that require such an MMU
at present.</p>
  </li>
  <li>
    <p>Although the <a href="/about/zipcpu.html">ZipCPU</a> supports AXI,
it doesn’t really do so by the book.  AXI is, by the book,
<a href="https://en.wikipedia.org/wiki/Endianness">little endian</a>
whereas the <a href="/about/zipcpu.html">ZipCPU</a> remains a
<a href="https://en.wikipedia.org/wiki/Endianness">big-endian</a>
machine.  Yes, it now has options to run in a
<a href="https://en.wikipedia.org/wiki/Endianness">little endian</a>
fashion, but the
<a href="https://en.wikipedia.org/wiki/Endianness">little endian</a>
options within the tool chain haven’t been
tested, and so I have no confidence that they will work.  What this means
is that bytes within words are mis-ordered when using AXI.  The
<a href="/about/zipcpu.html">ZipCPU</a>
will still write byte zero to bits [31:24], and byte one to bits [23:16]
and so forth.</p>

    <p>This has lead me to no end of troubles when testing AXI IP that is properly
ordered.  Not only that, but I now have an optimized software routine for
byte-reordering–a patch, written instead of a proper upgrade.</p>
  </li>
</ol>

<p>I’ve imagined a third upgrade over the years as well: adding a floating point
capability to the CPU.  Moreover, I’ve reserved several instruction op-codes to
support 32-bit single precision floating point operations.  In hindsight,
however, I’m not sure to what extent I would use these instructions even if I
did implement them.  I don’t normally use <em>single</em> precision floating point.
I default to using <em>double</em> precision floating point.  Not only that, but the
<a href="/about/zipcpu.html">ZipCPU</a>
will never be a hard core floating point processing machine.  It just
doesn’t fit that role.  It will always be better as a fixed point system.
Hence, floating point is no longer one of my goals for the
<a href="/about/zipcpu.html">ZipCPU</a>.</p>

<p>This v3.0 release also marks the first time the
<a href="/about/zipcpu.html">ZipCPU</a>
has synthesized (with caches) on a Kintex-7 device with <em>200MHz clock</em>!</p>

<p>Yes, the <a href="/about/zipcpu.html">ZipCPU</a>
has been well used (by me), and remains well loved.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Every man's work shall be made manifest: for the day shall declare it, because it shall be revealed by fire; and the fire shall try every man's work of what sort it is.  (1Cor 3:13)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
