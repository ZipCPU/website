<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>What is a SwiC?</title>
  <meta name="description" content="Central to the motivation behind the development of theZipCPUis the concept of a System within a Chip (SwiC).  As I’m now preparing theZipCPU for a version3....">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2023/03/13/swic.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">What is a SwiC?</h1>
    <p class="post-meta"><time datetime="2023-03-13T00:00:00-04:00" itemprop="datePublished">Mar 13, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Central to the motivation behind the development of the
<a href="/about/zipcpu.html">ZipCPU</a>
is the concept of a System within a Chip (SwiC).  As I’m now preparing the
<a href="/about/zipcpu.html">ZipCPU</a> for a <a href="https://github.com/ZipCPU/zipcpu/tree/79a3f19a8ab8b7786319c71019700e86f5918075">version
3.0</a>
release, it’s worth revisiting this concept to see what it means and then to
compare that with how the <a href="/about/zipcpu.html">ZipCPU</a>
has been used in practice.</p>

<table align="center" style="float: right"><caption>Fig 1. A SwiC consists of a small CPU within a chip</caption><tr><td><img src="/img/swic/swic-concept.svg" alt="" width="360" /></td></tr></table>

<p>I have defined a SwiC to be a small soft-core CPU within a chip, but
specifically where the CPU is neither the purpose of the chip nor the main
application within it.  Key to this definition is the requirement that the
purpose of the chip is not the CPU nor the application the CPU is supporting,
but rather that the CPU is more incidental to the application.</p>

<p>Today, I’d like to examine this concept of a SwiC in light of the many years of
<a href="/about/zipcpu.html">ZipCPU</a>
application and development, to see how well it (or any other CPU for that
matter) lives up to this concept.</p>

<h2 id="the-initial-motivation-for-the-zipcpu-gps">The initial motivation for the ZipCPU: GPS</h2>

<p>The initial application that motivated the
<a href="/about/zipcpu.html">ZipCPU</a>
was that of a <a href="https://en.wikipedia.org/wiki/Global_Positioning_System">GPS</a>
correlator.  A <a href="https://en.wikipedia.org/wiki/Global_Positioning_System">GPS</a>
correlator consists of a data feed coming from an Analog to Digital Converter
(A/D), possibly entering via a DMA to memory, and correlation outputs–perhaps
even going as far as soft-bit outputs.  The hardware in this case is is
centered on the correlator.  The correlator just reads and then correlates the
data in memory with the spreading code of a GPS satellite.  It requires several
logic <a href="/dsp/2018/10/02/fft.html">FFTs</a> and a lot of internal
memory, together with whatever glueware is required to connect them
all together.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 2. Controlling a GPS correlator</caption><tr><td><img src="/img/swic/gps-correlator.svg" alt="" width="360" /></td></tr></table>

<p>An example of one such correlator is shown in Fig. 2 on the left.</p>

<p>So where does the CPU fit in?</p>

<p>My original plan for the CPU was to have it control which satellite’s ranging
code would be loaded into the correlator, together with estimating which
<a href="https://en.wikipedia.org/wiki/Doppler_effect">Doppler</a> offsets to search.</p>

<p>Determining which satellites to correlate against and which
<a href="https://en.wikipedia.org/wiki/Doppler_effect">Doppler</a> offsets to check
requires a CPU.  The CPU takes an estimate of where the system thinks the user
is on the ground, together with a coarse estimate of the
<a href="https://en.wikipedia.org/wiki/Ephemeris">ephemerides</a> for each
of the satellites in the constellation.  It then uses this information to
determine first which satellites are in view, and then second what
<a href="https://en.wikipedia.org/wiki/Doppler_effect">Doppler</a>
shifts can be expected from each of them.  The better the CPU can do this
task, the fewer correlations that need to be checked and so the sooner the
correlators will lock on to the various satellite signals.  Once lock has been
achieved, the CPU will continue to look for new satellites that might be in
view, and estimate what their
<a href="https://en.wikipedia.org/wiki/Doppler_effect">Doppler</a> offsets would be
given the receiver’s known location.</p>

<p>Sure, this task could be offloaded to an external CPU.  But what about the
task of loading the coefficients and setting things up given the satellite
number and the
<a href="https://en.wikipedia.org/wiki/Doppler_effect">Doppler</a> estimate?</p>

<p>Handling nuisance tasks like this isn’t a major portion of the design logic,
but it is a necessary part.  Further, since the CPU exists, it can also be
used to coordinate reporting and the control of the DMAs to move data around.
It could even be used to take the correlation estimates and turn them into
positions, but in my world that was always handled externally by a full
featured processor.</p>

<p>This is where I came up with the idea of a SwiC: it’s a small, disadvantaged
computer, occupying a minor portion of a chip which is devoted to another task
entirely.</p>

<p>As an added benefit to starting the
<a href="/about/zipcpu.html">ZipCPU</a>
project, the hardware required for a minimal CPU is also going to be minimal
and even cheap.  In contrast, the hardware required for the correlators
wouldn’t be cheap at all–especially since the algorithm I wanted to implement
was block RAM limited.  Indeed, it may have required a
<a href="https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html">VC707</a>–something I couldn’t
afford at the time, which kept the project from getting off the ground.
The CPU hardware on the other hand?  That would definitely form the cheaper
part of the project.  Indeed, the <a href="/about/zipcpu.html">ZipCPU</a>
even demonstrated its ability to run a small Operating System on a $60 Spartan
6 LX4 (smallest Spartan 6).  This made it easier to justify the business end of
getting started–but I’m getting ahead of myself.</p>

<h2 id="properties-of-a-swic">Properties of a SwiC</h2>

<p>A SwiC, therefore, must be a small CPU.  It must be small enough that it can
be added to a design as an after thought.  Ideally, it shouldn’t significantly
impact the logic or area requirements of the design, simply because it uses so
few resources.</p>

<p>That’s the most basic requirement: it must be small.</p>

<p>Must it be fast?  Not necessarily, although faster is usually better.</p>

<p>Must it be low power?  Maybe, maybe not.  Again, that depends on your
requirements.</p>

<p>Like all CPUs, however, a SwiC must be a bus master and it must be able
to communicate with the environment around it.  It must also be responsive
to <a href="/zipcpu/2019/04/02/icontrol.html">interrupts</a> that
may be generated by the application handler.  For example, an interrupt might
tell the CPU that one round of correlation processing had completed.</p>

<p>These are then the minimum requirements: 1) a small 2) bus master, that is 3)
responsive to <a href="/zipcpu/2019/04/02/icontrol.html">interrupts</a>.
Further requirements may insist that it be 3) fast and/or 4) low power, but
these are more ancillary than core requirements.</p>

<table align="center" style="float: right"><caption>Fig 3. Mandatory interfaces</caption><tr><td><img src="/img/swic/barecpu.svg" alt="" width="360" /></td></tr></table>

<p>After that, however, the requirements of a CPU in general start to dominate
the problem space.  To see how this is so, let’s start at the top.</p>

<ol>
  <li>
    <p>Instruction memory</p>

    <p>A CPU, by definition, processes instructions in a serial manner.  Therefore
a SwiC, like any CPU, must have access to memory containing instructions.
These instructions are generally constant, so one may often assume the
instruction stream is kept in a ROM.</p>

    <p>Sadly, there are enough exceptions to this rule to keep it from being
absolutely true.  For example, programs must be loaded, updated, and
modified over time.  It may also be advantageous to move the instruction
memory from an offline storage such as an SD Card into an accessible
memory.  A ROM therefore is a good approximation, but only an approximation.</p>
  </li>
  <li>
    <p>Data memory</p>

    <p>A CPU also needs the ability to store and process data in some kind of RAM.
This means the CPU must have access to a read and writable memory
somewhere, and not just the ROM containing the instructions.</p>
  </li>
  <li>
    <p>Application peripherals</p>

    <p>Finally, the CPU needs to interact with the part of the design it was
intended to control.  These are application specific peripherals that
may exist in some designs and not in others.  Optionally, these
peripherals may generate
<a href="/zipcpu/2019/04/02/icontrol.html">interrupts</a>
that the CPU is required to process.</p>
  </li>
</ol>

<p>This might leave you imagining a small bare bones CPU, such as the one shown
in Fig. 3 above.</p>

<p>At least, that’s what you might imagine before you try implementing such a CPU.</p>

<p>Reality starts to look more like Fig. 4 below.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 4. Mapping the SwiC to hardware</caption><tr><td><img src="/img/swic/naiive-flash.svg" alt="" width="360" /></td></tr></table>

<p>Let’s start with how we might go about implementing the instruction memory.
Marrying these requirements to commodity FPGA hardware lends to placing
the instruction memory into
<a href="/blog/2018/08/16/spiflash.html">flash memory</a>.
<a href="/blog/2018/08/16/spiflash.html">Flash memory</a>
tends to be slow, but generally abundant for these purposes.  The problem with
<a href="/blog/2018/08/16/spiflash.html">flash</a> is that
you need a way to program it before activating the CPU.  My general solution
to this problem has been to add a second bus master to any system, something
I call a <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus</a>.
This bus master can then access the
<a href="/blog/2018/08/16/spiflash.html">flash</a> to program
it.  As a bonus, the <a href="/zipcpu/2017/08/25/hw-debugging.html">debugging bus master can also reach into and control
and/or debug the CPU
itself</a>.
That’s actually important, since the CPU needs to be kept from accessing the
<a href="/blog/2018/08/16/spiflash.html">flash memory</a>
while it is being programmed.</p>

<p><a href="/blog/2018/08/16/spiflash.html">Flash memory</a>,
however, won’t pass for data memory.  While it is easy to read from, it is
hard to write to.  So we’ll still need some data memory.  Worse, unlike
<a href="/blog/2018/08/16/spiflash.html">flash memory</a> where the
common 16MB size is typically more than enough, a CPU’s data memory usage can
quickly expand beyond the capability of any nearby memory.  For example, while
the standard C library can greatly simplify working with a CPU, that same
standard C library may require a minimum of 16kB of memory, and often something
closer to 64kB of memory.  Over the course of the
<a href="/about/zipcpu.html">ZipCPU</a>’s
lifetime, this data memory has been provided by
<a href="https://github.com/ZipCPU/s6soc/blob/0d7b428abe5c9a02d86a0272e290baafae00f13f/rtl/memdev.v">block RAM</a>,
<a href="https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/sramdev.v">SRAM</a>, an
<a href="https://github.com/ZipCPU/arrowzip/blob/599d5fa02975c693849bb138995b15800d8a36e8/rtl/arrowzip/wbsdram.v">external SDRAM</a>,
or even an external DDR3 SDRAM–all depending on the development board hosting
the design.  That leaves us with a minimal system having two bus masters, the
debugging bus and the CPU, and a minimum of three items on the bus: the
<a href="/blog/2018/08/16/spiflash.html">flash</a>,
data memory, and any application peripherals.</p>

<p>Adding the application peripherals only makes this worse: we now need a <a href="/blog/2019/07/17/crossbar.html">bus
interconnect</a> that can handle
two bus masters and three or more peripherals.  Many applications also require
access to memory as well, via some form of automated memory transfer or more.
All of these accesses need to be arbitrated.  Hence, a CPU must now have a
general purpose
<a href="/blog/2019/07/17/crossbar.html">bus interconnect</a>–something
not necessarily obvious from our minimum requirements above.</p>

<table align="center" style="float: right"><caption>Fig 5. Minimum SwiC system</caption><tr><td><img src="/img/swic/minsystem.svg" alt="" width="360" /></td></tr></table>

<p>When implementing the <a href="/about/zipcpu.html">ZipCPU</a>, there has
been a small set of peripherals that also keep coming up over and over again.
Fig. 5 on the right shows an example setup including many of these common
peripherals.  The first of these is a console port, by which a user can
communicate with the CPU.  The second is a set of <a href="/zipcpu/2019/02/09/cpu-blinky.html">single bit input or output
wires, what I call a GPIO
peripheral</a>.
The next two important peripherals are one or more
<a href="/zipcpu/2018/04/17/ziptimer.html">timers</a> and an
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt controller</a>.</p>

<p>That means that our simple CPU from Fig. 3 above has now become a much more
complicated design component, even more than Fig. 4 suggested, as shown in
Fig. 5.</p>

<p>This also means that any minimum CPU can quickly become much more than the
bare minimum CPU we started our outline from.</p>

<h2 id="examples-of-the-vision">Examples of the Vision</h2>

<p>Now that you know the initial application that motivated the
<a href="/about/zipcpu.html">ZipCPU</a>,
let’s take a moment and look at some other applications.  I’ll start this list
off with a set of applications I’ve come across where a SwiC, such as the
<a href="/about/zipcpu.html">ZipCPU</a>, might do nicely.  Then, in the
next section, we’ll discuss the reality of how the
<a href="/about/zipcpu.html">ZipCPU</a> has actually been used.
Let’s start with the exceptionally simple.</p>

<ol>
  <li>
    <p>PLL controller</p>

    <p>Some time ago, a user asked on Xilinx’s forums what the easiest way would
to control a PLL with an AXI4 interface.  A kind helper replied that the
easiest way to control a PLL on chip would be with an AXI4 input driven
by a MicroBlaze computer.</p>

    <p>Herein lies the problem of the SwiC:  A simple SwiC having 20-100
instructions might’ve solved the problem nicely.  However, if the SwiC needs
access to RAM, <a href="/blog/2018/08/16/spiflash.html">flash</a>,
and an <a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
then … it might have been easier just to drive the PLL with a <a href="/blog/2021/12/30/dbgaxil.html">simple
state machine</a>
instead of a full blown CPU.  Still, a small SwiC might’ve solved this
problem nicely–even if it was a bit of overkill for the problem.</p>
  </li>
</ol>

<p>At this level, the SwiC competes with a state machine, and a good state machine
will easily use less area.  However, a good SwiC will only need to be written,
simulated, and verified once in order to know it might properly drive a PLL.
Still, the advantage here goes to the state machine.  Once you need to drive
many dissimilar peripherals, or alternatively once the interaction becomes
sufficiently complex, then a single SwiC might start to make sense again.</p>

<p>What other uses might one find for a SwiC?</p>

<ol start="2">
  <li>
    <p>Power Controller</p>

    <p>Digilent sells a <a href="https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/">small color OLEDrgb PMod</a>,
suitable for drawing any small image on it.
<a href="https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/">This OLEDrgb</a>,
however, has some very specific timing requirements associated with when the
various power rails of the OLEDrgb chip within it need to be turned on.
Once the power rails had been turned on properly, the
<a href="https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/">OLEDrgb</a>
then needed to be configured via a long string of SPI commands.</p>

    <p>In a system with a hardware
<a href="https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/">OLEDrgb</a>
controller, a small CPU could easily manage this power sequence, followed
by the required initialization sequence before getting out of the way
of the rest of the hardware.</p>

    <p>Yes, a state machine might have worked as well.  However, if you have a
state machine to control your PLL, and another one to control your
<a href="https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/">OLEDrgb</a>s
power and startup SPI, then the cost of the separate areas for these
separate state machines, and the cost of there respective memory areas, will
soon start adding up.  At some point, the SwiC becomes a cheaper
solution–especially if it can be kept small, and kept from dominating the
rest of the design.</p>
  </li>
  <li>
    <p><a href="/blog/2018/08/16/spiflash.html">Flash memory</a> startup
handler</p>

    <p>Many of my <a href="/blog/2019/03/27/qflexpress.html">flash controller
designs</a> begin the
interaction with the
<a href="/blog/2018/08/16/spiflash.html">flash</a> using <a href="https://github.com/ZipCPU/openarty/blob/b75249d6db61db041008a2a8eafcd62aa0f1d0b5/rtl/qflexpress.v#L388-L751">a small
startup script</a>.
This script is necessary to first reset the
<a href="/blog/2018/08/16/spiflash.html">flash</a>
into a known mode, and then second to issue sufficient commands to the
<a href="/blog/2018/08/16/spiflash.html">flash</a>
to place it into its highest speed mode–typically <a href="/blog/2019/03/27/qflexpress.html">QSPI with a high speed
clock</a>.</p>

    <p>This gets more difficult in an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> device where the
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> needs to be
manufactured before the
<a href="/blog/2018/08/16/spiflash.html">flash</a>
device is selected.  The more modern protocols allow for the
<a href="/blog/2018/08/16/spiflash.html">flash</a>
to be queried regarding which modes it supports, followed by issuing
appropriate commands to place the
<a href="/blog/2018/08/16/spiflash.html">flash</a> into a chosen high
speed mode.  This is a complicated enough exchange that it makes the
most sense to handle this in software.  A small SwiC, therefore, might be
useful for this purpose.</p>

    <p>Here, though, I would note that this should only be required for non–System
on a Chip (SOC) ASIC chips.  If you had a processor available to you on the
chip already, then a simpler solution would have been to start the processor
using <a href="/blog/2018/08/16/spiflash.html">flash memory</a> in
its default state (slow SPI), and then to read the necessary instructions
from the <a href="/blog/2018/08/16/spiflash.html">flash</a>
to move it into a higher speed state for operation normal operation.</p>
  </li>
  <li>
    <p><a href="/blog/2018/08/16/spiflash.html">Flash memory</a> programmer</p>

    <p>Yes, I once thought to use the <a href="/about/zipcpu.html">ZipCPU</a>
as a <a href="/blog/2018/08/16/spiflash.html">flash memory</a>
programmer on an FPGA.  The problem here lies in how a
<a href="/blog/2018/08/16/spiflash.html">flash memory</a> is operated.
Basically, a <a href="/blog/2018/08/16/spiflash.html">flash memory</a>
is divided into sectors and pages.  Writing to a
<a href="/blog/2018/08/16/spiflash.html">flash</a>
device means either erasing a sector (64k Bytes), whereby all
the bits in the sector are set to one, or programming a page (256 Bytes),
whereby one or more bits within that page are cleared.  This means that
programming the <a href="/blog/2018/08/16/spiflash.html">flash</a>
requires <a href="https://github.com/ZipCPU/openarty/blob/b75249d6db61db041008a2a8eafcd62aa0f1d0b5/sw/host/flashdrvr.cpp#L416-L444">first 1) reading a whole sector, 2) copying it somewhere, and then
3) determining if the sector needs to be erased as a whole, before 4) one
or more pages within it needs to be programmed</a>.</p>

    <p>While I normally <a href="/blog/2017/06/05/wb-bridge-overview.html">handle this over a serial
port</a>, the
<a href="/blog/2017/06/05/wb-bridge-overview.html">serial port</a>
can be quite slow for this purpose.  Why, for example, should a whole
sector’s worth of data be read and then written when one might just as easily
write the sector to the CPU’s memory and then have the CPU determine locally
if the sector needs to be fully erased, or only partially programmed?  What
if, even better, the data were compressed when going over the <a href="/blog/2017/06/05/wb-bridge-overview.html">serial
port</a>,
and a CPU on the other end uncompressed it?</p>

    <p>In my case, although I built the
<a href="/about/zipcpu.html">ZipCPU</a>
software necessary to do this, I never quite got annoyed enough to build
the host software that would interact with it in order to finish following
through with the experiment.  Instead, it’s still waiting for me to come
back to it and report on how well it works.</p>
  </li>
  <li>
    <p><a href="/blog/2021/11/15/ultimate-i2c.html">(Multi) I2C Sensor handler</a></p>

    <p>In one project involving a robotic SONAR device, something was needed to
periodically poll and report on multiple voltage level, temperature, and
accelerometer sensor readings and to create a telemetry stream from them.
A first cut of this project suggested the
<a href="/about/zipcpu.html">ZipCPU</a> could handle this task
quite nicely.  Indeed, communicating with the originally intended sensor
set based upon a Dallas Semiconductor 1–wire protocol would’ve required
something as complex as a CPU to handle this coordination and communication.</p>

    <p>In the end, I chose not to use the
<a href="/about/zipcpu.html">ZipCPU</a>.  The sensor readings needed
strict time stamps, and a minimum of logic was required to guarantee things
would be shut down if the voltage or temperature measurements were ever out
of normal limits.</p>
  </li>
  <li>
    <p>Hi-Res <a href="/dsp/2018/10/02/fft.html">FFT</a> test bench</p>

    <p>One of my earlier projects was to build a <a href="/dsp/freq-teaser.html">high resolution
FFT</a>.  The algorithm primarily
involved a special pre-processor that would take place before a
<a href="/dsp/2018/10/02/fft.html">traditional FFT</a>.  The results
on paper and in off-line testing, however, were
<a href="/dsp/freq-teaser.html">spectacular</a>.
One individual wrote me, after testing the <a href="/dsp/freq-teaser.html">hi-res FFT
algorithm</a> on a <a href="https://en.wikipedia.org/wiki/Frequency-shift_keying">frequency shift
keyed signal</a>, at his
amazement that the <a href="/dsp/freq-teaser.html">hi-res FFT</a>
could then distinguish between which “bit” was being sent.</p>

    <p>This project earns its place on this list, however, not because of the FFT,
nor because of the pre-processor’s implementation, but rather because of the
challenge associated with testing it.  My initial tests involved sending
a tone into the <a href="/dsp/2018/10/02/fft.html">FFT</a>
at a <a href="/dsp/2017/12/09/nco.html">programmable frequency</a>,
and then evaluating the sidelobes to see how well the tone was isolated.
The problem?  The amount of data getting sent back and forth rendered
sweeping the tone across all frequencies and examining the data from
it an exercise in patience.</p>

    <p>This project took place before the
<a href="/about/zipcpu.html">ZipCPU</a>.  Had I placed a small
CPU on board, this task might have become much easier: The CPU might have
<a href="/dsp/2017/12/09/nco.html">controlled the tone’s
frequency</a>, and then estimated
the maximum sidelobe–all taking place within the FPGA–reducing the data
requirement over the
<a href="/blog/2017/06/05/wb-bridge-overview.html">serial port</a>
to something much more reasonable, and speeding up the testing significantly.</p>
  </li>
</ol>

<p>This is just a short list of the sorts of ideas that have motivated my
interest in SwiCs in general.  At least, this describes the vision.  What
about the reality?</p>

<h2 id="zipcpu-the-reality">ZipCPU: The Reality</h2>

<p>Now that I’ve worked with the <a href="/about/zipcpu.html">ZipCPU</a>
over the course of several projects, it’s worth asking: how well has this
vision panned out to reality?  To answer that, I’d like to look through
several projects that have included a
<a href="/about/zipcpu.html">ZipCPU</a>, to see how well the vision
fits or doesn’t.</p>

<ol>
  <li>
    <p>Doorbell controller</p>

    <p>One of <a href="https://github.com/ZipCPU/s6soc">my earlier projects was a doorbell
controller</a>.  This probably fits more into
the category of SOC than SwiC, but the story is worth telling anyway.</p>
  </li>
</ol>

<table align="center" style="float: left; padding: 20px"><caption>Fig 6. Our beloved security officer</caption><tr><td><img src="/img/swic/security.svg" alt="" width="280" /></td></tr></table>

<p>The background behind this project was a 2AM visitor that … well, I have
   no idea who it was, or why they knocked on our door at 2AM.  (By the time
   I got to the door with my security officer, they were no longer there.)  But
   this got me thinking: it would’ve been nice to turn on the outdoor lights
   when this person rang the doorbell, and to make sure the lights were
   otherwise turned off automatically at night.</p>

<p>My thought was to use a small FPGA to control the doorbell and outdoor light
   together.  The outdoor light would be turned on initially at dusk, but
   eventually turned off–unless the doorbell rang.  If anyone rang the
   doorbell, the outdoor light would turn on for a period of time.
   That meant that the FPGA would need to know time of day–requiring user
   interaction to set, hence there was a small keypad and a 2–line LED display.</p>

<p>In <a href="https://github.com/ZipCPU/s6soc">this project</a>, the
   <a href="/about/zipcpu.html">ZipCPU</a>
   controlled the light, the keypad, the 2–line display, and the audio
   doorbell.</p>

<p>Wouldn’t a small microcontroller have been more appropriate?  Perhaps a
   <a href="https://www.raspberrypi.org/">Raspberry Pi</a> or even an
   <a href="https://www.arduino.cc/">Arduino</a>?  Absolutely.</p>

<p>However, my true purpose was to see how small a system containing the
   <a href="/about/zipcpu.html">ZipCPU</a> could be, and whether or not
   the <a href="/about/zipcpu.html">ZipCPU</a> could handle
   <a href="/zipcpu/2019/11/23/multithreaded-blinky.html">multi-tasking</a>.
   The answer was, <a href="/zipcpu/2021/03/18/zipos.html">yes it could handle multi-tasking</a>
   while <a href="/blog/2017/06/12/minimizing-luts.html">still fitting on Xilinx’s smallest
   Spartan 6</a>: the LX4.</p>

<p>(This project was internally funded …)</p>

<ol start="2">
  <li>
    <p><a href="/blog/2019/11/14/sdspi.html">Test recorder</a></p>

    <p>In another project, the customer wanted to generate a special communications
signal on an I/O pin.  Part of the project involved deciding what signaling
standard to use, so several were tried to include two different types of
on-off keying and two types of pulse position modulation.</p>

    <p>In this case, the application used only a small amount of logic within the
FPGA to generate these signals.</p>

    <p>A more substantial problem was how to record the results from a test like
this.  In this case, the ideal recorder was the FPGA: it had access to
the incoming signals, a large DDR3 SDRAM attached, as well as an SD Card
to make recordings with.  While an SD card can become an ideal medium
for recording data, the challenge is how to deal with the file system
present on the card.</p>

    <p>Enter the <a href="/about/zipcpu.html">ZipCPU</a>, the
<a href="https://github.com/ZipCPU/sdspi">SDSPI Controller</a>,
and the <a href="http://elm-chan.org/fsw/ff/00index_e.html">FATFS</a> library.</p>

    <p>The next challenge was how to deliver the
<a href="/about/zipcpu.html">ZipCPU</a>’s program to the customer,
who didn’t have the <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus
infrastructure</a>
available to him on his host computer in order to load the
<a href="/about/zipcpu.html">ZipCPU</a>.
<a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/">The particular board</a>
we had chosen for this project, however, permitted loading the FPGA from an
SD Card.  Therefore, we chose to load the board from this SD card, and I
placed a boot loader for the <a href="/about/zipcpu.html">ZipCPU</a>
into 64kB of ROM.  (The program required 168 bytes more than the 32kB,
forcing a 64kB ROM built out of block RAM.)  The boot loader would then
walk through a small script to start up the SD Card, and then read a file
from it into memory, before jumping to the first address of memory.</p>

    <p>Once loaded, the user could interact with the design via a CPU provided
menu, allowing the user to configure the test, capture data, and save any
data captured to a file on the SD card.</p>
  </li>
  <li>
    <p><a href="https://www.extremesonar.com/projects">Broadband High-Frequency Active
SONAR</a></p>

    <p>A more recent project involved the development of a controller for a SONAR
transmitter.  As with the last project, the amount of logic involved in the
transmitter turned out to be a small portion of the project.  Still, small
or not, it did need to be configured.  A small
<a href="/about/zipcpu.html">ZipCPU</a> program attached to
the serial port provided the customer with a way to control the transmitter,
to both turn it on and off, as well as to control the waveform produced by
the transmitter: frequency, pulse duration, pulse repetition rate, chirp,
pseudorandom noise pattern, etc.</p>
  </li>
  <li>
    <p>Video</p>

    <p>When first learning about HDMI video, I struggled to get the timing right
to lock onto the HDMI clock using the IDELAYE2 function on my FPGA.  (In
hindsight, I didn’t understand how the IDELAYE2 element worked, and could’ve
greatly simplified this problem …)  While
I couldn’t lock automatically, I could tell if things were locked.  My
solution was to use the <a href="/about/zipcpu.html">ZipCPU</a> to
<a href="https://github.com/ZipCPU/videozip/blob/6e4215b3b6ea96595a4083603636a88a5599604d/sw/board/hdmistest.c">measure whether or not the received HDMI signal quality was good enough,
and then to adjust the subsample delay timing until it
was</a>.</p>

    <p>Also, in <a href="https://github.com/ZipCPU/videozip">the same project</a>, I had to
deal with the challenge of the
<a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID</a>
display data.  The <a href="https://github.com/ZipCPU/videozip">project</a>
involved a pass through HDMI signal.  Therefore, the downstream
<a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID</a>
information needed to be read and forwarded upstream.  There was an
opportunity for software to adjust things in the middle.  In the end,
however, the <a href="/about/zipcpu.html">ZipCPU</a> <a href="https://github.com/ZipCPU/videozip/blob/6e4215b3b6ea96595a4083603636a88a5599604d/sw/board/hdmistart.c#L157-L158">just copied the
EDID information from the downstream monitor to the upstream RPi
source</a> and everything worked.</p>
  </li>
  <li>
    <p>One potential customer has asked me about the feasability of
<a href="https://github.com/ZipCPU/vgasim/blob/dev/rtl/axisvoverlay.v">overlaying</a>
graphical information, such as text and/or menus, onto a video stream.  The
FPGA would sample data from a camera, apply some special processing
algorithms to clean up the image, and then forward the results down stream.
It just needed an ability for user control and feedback somewhere. Here,
again, the majority of the processing will take place within the FPGA
logic.  Indeed, it might be possible to do all of the processing in the
FPGA logic without a CPU at all.  The problem was … the technology was
still in development.  While in development, it makes sense to be able to
reconfigure things.  Therefore, the CPU is present to be able to read
<a href="/dsp/2019/12/21/histogram.html">histogram</a> data,
operate on it, adjust scaling constants, and in general
to rearrange the configuration as necessary.</p>

    <p>In this last case, the CPU may evolve into a more necessary function as well.
Because the project is designed to be a “bump” in the video stream, i.e.
HDMI and power in, maybe a couple buttons, and then HDMI out, any user
feedback regarding the algorithm or its performance will need to be placed
onto the video output stream itself.  This can easily be done with a text
overlay, however a CPU will be required to determine what text to overlay
and where.  Perhaps I’ll even port the <a href="https://invisible-island.net/ncurses/announce.html">nCurses
library</a> to the
<a href="/about/zipcpu.html">ZipCPU</a>
and integrate that.  We’ll see, however, as this project develops–assuming
it gets funded in the first place.</p>
  </li>
  <li>
    <p><a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a> testing</p>

    <p>There’s another place where a small soft-core CPU can have a big impact,
and that’s in <a href="/zipcpu/2021/07/23/cpusim.html">simulation
testing</a>.  When building
and <a href="/zipcpu/2021/07/23/cpusim.html">testing an ASIC
peripheral</a> recently, it
helped to be able to simulate the peripheral’s interactions with a nearby
soft-core CPU.  This, of course, requires having a Verilog CPU nearby
which can stimulate the peripheral.</p>

    <p>Being an open source CPU, or perhaps more because the
<a href="/about/zipcpu.html">ZipCPU</a> was <a href="/blog/2020/01/13/reuse.html">internally
sourced</a>,
the <a href="/about/zipcpu.html">ZipCPU</a> fit this role quite 
nicely.</p>

    <p>The proposal ended up being a challenge on two fronts, however.  The
first was speed.  A Verilog test script will always beat a Verilog CPU
in processing speed.  The second was in maintainability.  At some point, I
needed to hand the software to someone else to maintain, and they weren’t
necessarily comfortable with the risk of needing to maintain the
<a href="/about/zipcpu.html">ZipCPU</a>’s tool base.  Doh!</p>
  </li>
</ol>

<p>As you can see from the above examples, the amount of CPU interaction with
the design has ranged from something that might be replaced by a <a href="https://github.com/ZipCPU/dbgbus/blob/9a83c98a0b2d27d5715813364391cd8860a906ff/hexbus/rtl/hbexecaxi.v">small
AXI4-lite state machine</a>,
to something rivaling an SOC in its own right.</p>

<h2 id="logic-usage">Logic Usage</h2>

<p>How about logic usage?  Let’s take a quick look at logic usage.  Does the
<a href="/about/zipcpu.html">ZipCPU</a> truly qualify as small enough
to be used in a SwiC?  This question isn’t so easy to answer, since CPU design
always involves a trade off between performance and area.  Specifically, you
can buy more, better, faster performance with more on-chip area.  That means
to compare logic usage, we’ll need to define a feature set to measure logic
usage from.  So let’s define and then compare a couple of configurations:</p>

<table align="center" style="float: right"><caption>Fig 7. Supporting multiple configurations is a hassle</caption><tr><td><img src="/img/swic/config-testing.svg" alt="" width="360" /></td></tr></table>

<ul>
  <li>
    <p><strong>ASM</strong>: If you strip the <a href="/about/zipcpu.html">ZipCPU</a> of
every single optional feature, you get to this ASM mode.  I call it the
“ASM” mode because it doesn’t include instructions that the toolchain would
require–such as multiplies, divides, or shifts of more than one bit.  Worse,
because this mode doesn’t include the <a href="/zipcpu/2018/01/01/zipcpu-isa.html">user
mode</a>, there’s no way
to trap on an unimplemented instruction–the
<a href="/about/zipcpu.html">ZipCPU</a> would either just halt
or restart–depending on its configuration.  This means that any
<a href="/about/zipcpu.html">ZipCPU</a> program using this mode will
likely need to be written in assembly.</p>
  </li>
  <li>
    <p><strong>TRAP</strong>: This is a compromise from the ASM support above.  In this mode,
shift instructions are now implemented, and there’s now a
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">user mode</a> that can
be used to trap unimplemented multiply or divide instructions.  Further,
the LOCK instruction is now implemented, allowing atomic access from
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">user mode</a>.</p>

    <p>For those buses that don’t support the LOCK instruction, such as the AXI-lite
bus, the LOCK instruction instead implements a interrupt block–preventing
the <a href="/about/zipcpu.html">ZipCPU</a> from responding to an
interrupt for three instructions.  Sadly, this includes all of the
Wishbone wrappers prior to the pipelined controller, since the LOCK
instruction would otherwise cause a dead lock: the data bus would hold
the Wishbone cycle line high during the lock operation, and so otherwise
it would lock out the instruction bus interface from fetching the next
instruction.</p>
  </li>
  <li>
    <p><strong>Minimum</strong>: This configuration includes support for <a href="/zipcpu/2018/01/01/zipcpu-isa.html">all
CPU instructions</a>.
In particular, it also supports the compressed instruction set not
supported by the TRAP configuration above.  This isn’t quite a full featured
configuration, however, since the
<a href="/about/zipcpu.html">ZipCPU</a> isn’t (yet) pipelined.
(That’s the next configuration.)
Instructions, therefore, take a minimum of four cycles to complete.</p>

    <p>The savings between this mode and the pipelined mode (next) is primarily
captured by the difference between the memory controllers, shared registers,
and some simplified pipeline signaling.</p>
  </li>
  <li>
    <p><strong>Pipelined</strong>: The <a href="/about/zipcpu.html">ZipCPU</a> was
originally designed to be a pipelined CPU.  This configuration turns
pipelining on, while also including a powerful memory controller that’s
not (yet) quite as capable as a cache.</p>
  </li>
  <li>
    <p><strong>Cached</strong>: This configuration adds a 4kB instruction and a 4kB data cache
to the CPU’s configuration.</p>

    <p>In general, cache sizes are configurable–but this configuration arbitrarily
uses 4kB caches.</p>
  </li>
  <li>
    <p><strong>Low Power</strong>: This final configuration adds both <a href="/blog/2021/10/26/clk-gate.html">clock
gating</a> (unusable on
most FPGAs, but we’ll ignore that for now), as well as zeroing unused
registers for the purpose of lowering the CPU’s power requirements.</p>
  </li>
</ul>

<p>Just for review, you can see these configurations compared in Fig. 8 below.</p>

<table align="center" style="float: none"><caption>Fig 8. Comparing the basic configuration options</caption><tr><td><img src="/img/swic/config-comparison.png" alt="" width="778" /></td></tr></table>

<p>That covers the configurations of the <a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/core/zipcore.v">core of the CPU</a>.</p>

<p>This isn’t sufficient, however, to measure the CPU’s logic usage, since the
CPU needs to be married to a wrapper containing the bus interface and memory
controllers.  Since the <a href="https://github.com/ZipCPU/zipcpu/tree/zipcore">new ZipCPU
distribution</a>
supports Wishbone <em>and</em> AXI-lite and AXI4, there are three basic wrappers:
the <a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipbones.v">ZipBones</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxil.v">Zip-AXIL</a>,
and <a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxi.v">ZipAXI</a>
wrappers.  A <a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v">fourth
wrapper</a>,
one I call the
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v">ZipSystem</a>,
connects the <a href="/about/zipcpu.html">ZipCPU</a>
to an immediate set of local peripherals: one or two
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt controller</a>s,
three <a href="/zipcpu/2018/04/17/ziptimer.html">timers</a>,
a <a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/zipjiffies.v">jiffies peripheral</a>,
some <a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/zipcounter.v">performance counters</a>,
and a <a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/wbdmac.v">Wishbone DMA</a>.
Each of these wrappers has a different logic requirement when attached to the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/core/zipcore.v">core</a>.  So examine them one at a time.</p>

<p>For accounting purposes, I’ll measure CPU usage in terms of both 4-LUTs on
an iCE40, and Xilinx 6-LUTs.  I will use <a href="http://www.clifford.at/yosys/">Yosys</a>
for the measurements, and <a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/usage.pl">this
script</a>
to make them automatically.</p>

<p>Let’s start with the
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipbones.v">ZipBones</a>
area usage, as shown in Fig. 9 on the left.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 9. ZipBones logic usage</caption><tr><td><img src="/img/swic/usage-zipbones.png" alt="" width="332" /></td></tr></table>

<p>As you can see from this table, the
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipbones.v">ZipBones</a>
configuration fits nicely in the smallest of areas.  Indeed, I was quite
pleased with myself that the CPU can be made to fit in as few as 576 6-LUTs.
No, it’s not very usable in that configuration, but that’s about as good as
I can get for low-area bragging rights.</p>

<p>The next wrapper we’re examining is the
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v">ZipSystem</a>.
As mentioned above, the
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v">ZipSystem</a>
is not a bare CPU, but rather includes includes several local peripherals:
three <a href="/zipcpu/2018/04/17/ziptimer.html">timers</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/wbdmac.v">a Wishbone DMA</a>,
<a href="/zipcpu/2019/04/02/icontrol.html">interrupt controller</a>s,
and more.  As one might expect, there’s a logic cost to these new features,
and this cost can be seen in the
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v">ZipSystem</a>’s
logic usage chart shown in Fig. 10 on the right.</p>

<table align="center" style="float: right"><caption>Fig 10. ZipSystem logic usage</caption><tr><td><img src="/img/swic/usage-zipsystem.png" alt="" width="332" /></td></tr></table>

<p>In general, the cost of these extra peripherals runs about 1150 6-LUTs or so.</p>

<p>The chart for the <a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxil.v">AXI-Lite wrapper</a>’s
logic usage is just a little different.  Specifically, I have yet to build any
AXI-_lite_ cache implementations.  (I have an AXI cache implemention …)
Therefore, the usage chart for AXI-lite shown in Fig. 11 doesn’t have any
cache options to it.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 11. ZipAXI4-Lite logic usage</caption><tr><td><img src="/img/swic/usage-zipaxil.png" alt="" width="346" /></td></tr></table>

<p>For reference, all of these AXI-Lite configurations, prior to the pipelined
one, make use of the <a href="/zipcpu/2021/04/17/axilops.html">AXI-lite memory controller we discussed some time
ago</a>.  As you might guess,
there’s no bus support for the LOCK instruction in this configuration since
AXI-Lite has no support for exclusive access.</p>

<p>That brings us to the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxi.v">final wrapper</a>,
showing the AXI4 (full) interface logic usage in Fig. 12 on the right.</p>

<table align="center" style="float: right"><caption>Fig 12. ZipAXI4 logic usage</caption><tr><td><img src="/img/swic/usage-zipaxi.png" alt="" width="332" /></td></tr></table>

<p>This includes the <a href="/zipcpu/2021/09/30/axiops.html">bare minimum AXI4 memory controller we
discussed</a>
for the minimum modes as well.  Since making this measurement, however, I’ve
added an exclusive access option to my <a href="https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/core/axidcache.v">AXI data cache
implementation</a>.
So, the numbers may not quite match the current performance.</p>

<p>Having this kind of information, though, is really cool.  That means that I
can now compare logic usage requirements between the various bus
implementations, as shown in Fig. 13 on the left.</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 13. Bus logic usage comparison</caption><tr><td><img src="/img/swic/usage-bus.png" alt="" width="520" /></td></tr></table>

<p>One of my contentions has always been that <a href="https://www.reddit.com/r/FPGA/comments/egkrce/is_axi_too_complicated/">AXI4 is unnecessarily
complicated</a>.
Here, you can see that, in spite of the extra complications of working with
the AXI4 bus, the CPU 6–LUT logic usage difference is only 100-200 LUTs
between the Wishbone and AXI4 implementations.  On an FPGA with 200k LUTs,
this difference isn’t a big deal.  On an FPGA with 1,500 LUTs?  A 200 LUT
difference could mean the difference between fitting and not.</p>

<p>While informative, this bus comparison really isn’t complete.  To be complete,
the comparison should also the cost of the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> and all of
the peripherals–each of which would magnify the differences shown here.</p>

<p>When comparing logic usage options, one of the things not shown in these
charts is the cost of a Finite State Machine bus controller such as one might
use instead of a CPU for relatively simple tasks.  For reference, therefore, a
<a href="https://github.com/ZipCPU/dbgbus/blob/9a83c98a0b2d27d5715813364391cd8860a906ff/hexbus/rtl/hbexecaxi.v">simple AXI-lite FSM–based bus
controller</a>,
reading from a (not-included) memory script, can be made as simple as 88~LUTs.</p>

<h2 id="comparison-to-socs">Comparison to SOCs</h2>

<p>So, how does a <a href="/about/zipcpu.html">ZipCPU</a>
compare against a full blown SOC?  Something like a Zynq, for example?</p>

<ol>
  <li>
    <p><strong>Hardware support</strong>.  The Zynq is bigger (i.e. more capable), and supports
more hardware out of the box.  It has hard macros for such things
as DDR3 memory, SD Cards, ethernet, displays, and more.  Further, because
the ARM CPU within the Zynq is implemented out of raw gates, rather than
FPGA fabric, it runs at a much higher clock speed.</p>

    <p>A SwiC isn’t going to compete well here.</p>

    <p>On the other hand, the <a href="/about/zipcpu.html">ZipCPU</a>’s
memory controller tends to <a href="/zipcpu/2019/02/09/cpu-blinky.html">compare favorably to the ARM when measuring
the raw bus access speed of the CPU accessing FPGA
logic</a>.  I can’t
explain this, but I have seen it multiple times over.</p>
  </li>
  <li>
    <p><strong>Logic Portability</strong>.  One problem with the Zynq, or any other SOC for that
matter, is that its peripherals are unique to it.  Some may have a device
independent interface, similar to <code class="language-plaintext highlighter-rouge">printf()</code> for the ability to interact
with a console, but getting to that interface takes a lot of work and
capability away from a raw CPU.  The
<a href="/about/zipcpu.html">ZipCPU</a>,
on the other hand, is a soft core CPU.  It can therefore (theoretically)
run on any hardware, and its peripherals can be ported from one piece of
hardware to another for a similar user experience across multiple vendors’
FPGAs.</p>
  </li>
  <li>
    <p><strong>Bare-Bones Programming</strong>.  The
<a href="/about/zipcpu.html">ZipCPU</a> runs quite well without
any operating system.  As <a href="/zipcpu/2019/11/23/multithreaded-blinky.html">we’ve discussed
earlier</a>,
it’s pretty easy to run multiple threads on the
<a href="/about/zipcpu.html">ZipCPU</a>–even without an operating
system.</p>

    <p>How does this compare the the ARM within a Zynq?  Frankly, I haven’t written
any bare bones software for the ARM to really know.  I know plenty of others
have, so I know it’s quite doable.  I’d personally be tempted to give
the <a href="/about/zipcpu.html">ZipCPU</a> the advantage here,
simply because of the <a href="/about/zipcpu.html">ZipCPU</a>’s
approach to interrupt handling, but my own subjective view of this matter
is hardly definitive and quite likely biased.</p>
  </li>
  <li>
    <p><strong>Simulation</strong>. What the Zynq cannot do, however, the
<a href="/about/zipcpu.html">ZipCPU</a> can:
<a href="/zipcpu/2021/07/23/cpusim.html">simulation</a>.  Since the
<a href="/about/zipcpu.html">ZipCPU</a> is an all Verilog CPU based
upon publicly available Verilog, it can easily be <a href="/blog/2017/06/21/looking-at-verilator.html">verilated into
C++</a>,
integrated into the host O/S of the simulator, and therefore offer more
realistic cycle by cycle simulation of a system under test.  If
<a href="/zipcpu/2021/07/23/cpusim.html">simulation</a>
is what you want, therefore, the
<a href="/about/zipcpu.html">ZipCPU</a> (or any other soft-core for
that matter) easily wins here.</p>
  </li>
  <li>
    <p><strong>ASIC</strong>.  If I ever need to build a CPU into an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>, the
<a href="/about/zipcpu.html">ZipCPU</a> will be my go to solution.
It’s proven,
<a href="/blog/2018/04/02/formal-cpu-bugs.html">verified</a>,
fits into a small (and controllable) area, and costs less than an ARM.</p>

    <p>(I might be a touch biased in this opinion.  Use your own discretion.)</p>
  </li>
</ol>

<h2 id="conclusions">Conclusions</h2>

<p>Having now reviewed the concept of a SwiC, and seen how such a device might
be used, what conclusions might we draw?</p>

<ol>
  <li>
    <p>For a single need, an FSM may make more sense</p>

    <p>Even at it’s lowest logic usage of 576 Xilinx 6–LUTs (plus the <a href="/blog/2019/03/27/qflexpress.html">flash
controller</a>, data
memory, and <a href="/blog/2019/07/17/crossbar.html">interconnect</a>
which we didn’t count), the <a href="/about/zipcpu.html">ZipCPU</a>
cannot compete with an 88 6-LUT <a href="https://github.com/ZipCPU/dbgbus/blob/9a83c98a0b2d27d5715813364391cd8860a906ff/hexbus/rtl/hbexecaxi.v">FSM based bus
controller</a>.</p>

    <p>Sorry, that’s just not going to happen.</p>
  </li>
  <li>
    <p>For multiple needs, an
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
and console become indispensable.  The measure of the CPU’s impact on the
rest of the system really needs to include these components.</p>

    <p>Simply put, the more things the CPU needs to control, the more things
it needs to be connected to.</p>

    <p>Why the console?  Simple: it’s really easy to use, and even easier to debug
with.  Debug by printf() is just so much easier than debug by debugger, or
even debug via <a href="/blog/2017/07/31/vcd.html">VCD trace</a>,
that I’d use it in a heartbeat any time I can.</p>

    <p>Unfortunately, the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a> and DDR3
SDRAM controller by themselves can easily be so costly as to void the whole
SwiC vision.  Why use a SwiC at all, then?  Why not a regular soft core?</p>
  </li>
  <li>
    <p>Even in the presence of big SOC+FPGA devices, small soft-core CPUs can still
have a big impact.</p>

    <p>While the impact might be reserved to <a href="/zipcpu/2021/07/23/cpusim.html">simulation and
testing</a>, or vendor
independence only, impacts are still impacts.</p>
  </li>
  <li>
    <p>In most of my actual, real-life use cases, the
<a href="/about/zipcpu.html">ZipCPU</a> hasn’t really fulfilled
my original vision of a SwiC.  Instead, it seems to grow and expand to
fill whatever space is left on my device.</p>

    <p>On the other hand, perhaps that was the vision–especially since I have
yet to come across a project where the
<a href="/about/zipcpu.html">ZipCPU</a> won’t fit.</p>
  </li>
</ol>

<p>The one thing I haven’t tried, though, is connecting the
<a href="/about/zipcpu.html">ZipCPU</a>’s fetch directly to a small
attached block RAM implemented as an instruction ROM.  Doing so would probably
both speed up the <a href="/about/zipcpu.html">ZipCPU</a> and lower its
memory usage.  Let me add this one to my to-do list as well.  It won’t be the
first item on my list, though–that’s still finalizing the
<a href="/about/zipcpu.html">ZipCPU</a> for it’s version 3.0 release.</p>

<p>Expect to hear more of this in the future.</p>

<table align="center" style="float: none"><caption>Fig 14. A short ZipCPU to do list</caption><tr><td><img src="/img/swic/zipcpu-todo.svg" alt="" width="640" /></td></tr></table>

<p>Of course, the sad part of this to-do list, like any good to-do list, is that
it just keeps on growing.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Were there is no vision, the people perish: but he that keepeth the law, happy is he.  (Prov 29:18)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
