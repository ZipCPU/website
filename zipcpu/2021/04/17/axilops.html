<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a Simple AXI-lite Memory Controller</title>
  <meta name="description" content="When I first built theZipCPU,I built it for theWishbone bus.Wishboneis very easy to work with, and a goodWishbonepipeline implementation shouldbe able to ach...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2021/04/17/axilops.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building a Simple AXI-lite Memory Controller</h1>
    <p class="post-meta"><time datetime="2021-04-17T00:00:00-04:00" itemprop="datePublished">Apr 17, 2021</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>When I first built the
<a href="/about/zipcpu.html">ZipCPU</a>,
I built it for the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>.
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
is very easy to work with, and a good
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
pipeline implementation should
be able to achieve (roughly) the same performance as AXI-lite.  At the time, I
had yet to build a
<a href="/blog/2019/07/17/crossbar.html">crossbar interconnect</a>,
so <a href="/blog/2017/06/22/simple-wb-interconnect.html">my basic interconnect
designs</a> were
fairly simple and depended upon the existence of no more than a single master.
This forced the <a href="/about/zipcpu.html">ZipCPU</a>
to have an <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v">internal
arbiter</a>,
and to only expose that one
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
interface.  You can see this basic structure in Fig. 1 below.</p>

<table align="center" style="float: none"><caption>Fig 1. Basic ZipCPU architecture</caption><tr><td><img src="/img/zipcpu.svg" alt="" width="560" /></td></tr></table>

<p>My <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v">first memory
controller</a> was
quite simple.  It could handle issuing a single
read or write at a time and waiting for the return.</p>

<p>When this <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/memops.v">memory
controller</a>
turned out to be a CPU performance bottleneck, I
chose to write a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v">pipelined memory
controller</a>.
To get there, I first noticed that the CPU
doesn’t need the results of any write operation, so nothing keeps the CPU from
continuing with further operations while the write operation is ongoing.
Even better, you could issue a string of write operations and as long as the
memory controller was able to issue further
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
requests, nothing kept the CPU from allowing many requests to be outstanding
only to be retired later.</p>

<p>I continued this reasoning to reads as well.  A string of memory reads could
be issued by the CPU, under the condition that none of those reads overwrote
either the base address register, from which the read addresses were being
determined, or the program counter.  When these conditions held, multiple read
requests could thn issued to be retired later–just like the write requests
above.</p>

<p>To see how this concept might work, consider Fig. 2 below showing a notional
subroutine.</p>

<table align="center" style="float: right"><caption>Fig 2. Memory operation sequences</caption><tr><td><img src="/img/axilops/membusy.svg" alt="" width="780" /></td></tr></table>

<p>In this notional example, the CPU starts out with a jump to the subroutine
instruction.  The subroutine then creates a
stack frame by subtracting from the stack pointer (<code class="language-plaintext highlighter-rouge">SUB</code>), and stores three
registers to the stack frame via three store-word (<code class="language-plaintext highlighter-rouge">SW</code>) instructions.  The
memory controller then becomes busy handling these three requests.  While the
requests are active, further requests of the same type are allowed.  Moreover,
since the requests are to store data to memory, the CPU can go on with other
instructions.  It doesn’t wait for the stores to complete, and so the
CPU issues first an <code class="language-plaintext highlighter-rouge">ADD</code> and then an <code class="language-plaintext highlighter-rouge">AND</code> instruction.
Once the CPU is finished, it clears up the stack frame by loading (<code class="language-plaintext highlighter-rouge">LW</code>) the
copies of the registers it used back from the stack.  These loads, however,
need to first wait for the stores to complete–and so they stall the CPU.
Once all the loads have been issued, we then add to the stack pointer to return
the stack frame to what it was.  However, since the CPU doesn’t keep track of
what load requests are
outstanding, it can’t tell if this ADD is to a value yet to be returned from
the LOAD.  Therefore, the CPU stalls again until all loads are complete.</p>

<p>While this might seem slow, consider the alternative.  What if the CPU had to
wait for every load or store to complete before issuing the next one?  Fig. 3
below gives a taste of what that might look like, save that we’ve allowed the
CPU to still continue while store operations are ongoing.</p>

<table align="center" style="float: right"><caption>Fig 3. Singleton operations only</caption><tr><td><img src="/img/axilops/memslow.svg" alt="" width="780" /></td></tr></table>

<p>There were a couple issues with this new approach, however.  One was that my
<a href="/blog/2017/06/22/simple-wb-interconnect.html">original interconnect</a>
implementation didn’t understand the concept of a currently active slave.
Any slave could respond to a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> request and the
<a href="/blog/2017/06/22/simple-wb-interconnect.html">interconnect</a>
would be none
the wiser.  Keeping the returns in order meant insisting that the memory
accesses were to incrementing addresses, and that slaves were sorted on the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
by how long they would take to respond to a request–so that the fastest
responding slaves were always at lower addresses.  I handled this by <a href="https://github.com/ZipCPU/zipcpu/blob/f45617713f0fb1390fa3675e8d05fb84d1369b52/rtl/core/idecode.v#L669-L758">insisting,
within the instruction decoder</a>,
that any string of memory operations had to be to
either the same address or subsequent addresses.</p>

<p>A second issue with this pipelined memory approach involved how to handle
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">errors</a>.
Once a CPU can issue requests without waiting for their responses, then it
becomes possible for the CPU to issue requests for multiple operations before
the first one returns a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
While this makes analyzing a program in <a href="/zipcpu/2017/08/25/hw-debugging.html">the
debugger</a> that much
more challenging, the speed benefit provided by this approach was really quite
tremendous, and often outweighed any drawbacks.</p>

<table align="center" style="float: right"><caption>Fig 4. Comparing several GPIO toggle rates</caption><tr><td><img src="/img/tweets/gpio.svg" alt="" width="360" /></td></tr></table>

<p>The result was a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v">basic pipelined memory
controller</a>.
As an example of the performance that could be achieved using this technique,
the <a href="/about/zipcpu.html">ZipCPU</a> can <a href="/zipcpu/2019/02/09/cpu-blinky.html">toggle an output pin at
47MHz while running the bus at
100MHz</a>,
whereas others have measured the Zynq running a 250MHz bus as only able to
toggle the same pin at 3.8MHz.  In percentages, the
<a href="/about/zipcpu.html">ZipCPU</a> was able to
demonstrate a 47% bus utilization using this technique vs. the Zynq’s 1.5%
bus utilization.</p>

<p><a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v">This pipelined
memory</a>
architecture worked quite well for the
<a href="/about/zipcpu.html">ZipCPU</a>.
Hand optimized loops could easily be unrolled for much better performance.
Without hand optimization, however, the greatest benefit of this technique was
when generating or recovering stack frames where the technique was an awesome
fit.</p>

<p>Indeed, I was a bit taken aback later when I finally built a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data cache</a>
only to discover the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/pipemem.v">pipelined memory
controller</a>
was often as fast or faster than the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data cache</a>.
What?? How could that happen?
Well, part of the problem was the time it took to load the cache in the first
place.  Loading the cache could generate more memory requests than necessary,
such as if the CPU only wanted a single value but had to load the entire cache
line, and so the cache might unnecessarily slow down the CPU.  The other problem
was that my original data cache implementation resorted to single operations
when accessing uncachable memory.  As a result, I had to go back and retrofit
the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data cache</a>
to handle pipelined operations for uncached memory just to recover the lost
performance.</p>

<p>Recently, however, I’ve found myself doing a lot of work with AXI and not
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.
How should the <a href="/about/zipcpu.html">ZipCPU</a>
be modified to handle AXI?  One approach would be to use my <a href="/blog/2020/03/23/wbm2axisp.html">Wishbone to AXI
bridge</a>.  This approach,
however, loses some of the benefits of AXI.  The
<a href="/blog/2020/03/23/wbm2axisp.html">Wishbone to AXI bridge</a>
will never allow both read and write transactions to be outstanding (nor will
the CPU …), neither will it allow the CPU to use <a href="/blog/2020/06/16/axiaddr-limits.html">AXI
bursts</a>
or to issue exclusive access requests.  The piece breaking the camel’s back,
however, is simply the <a href="http://zipcpu.com/blog/2019/04/27/axi-addr.html">lost performance going through a bus
bridge</a>.</p>

<p>To avoid any lost performance when driving an
<a href="/formal/2018/12/28/axilite.html">AXI</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> interface I would need to
make the <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
agnostic.</p>

<h2 id="bus-agnostic-cpu-design">Bus Agnostic CPU Design</h2>

<p>At present, I’m still in the process of making the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
agnostic.  As a result, I don’t (yet) have any good examples of completed
designs to show you how well (or poorly) the newly updated design works.
Expect those within the year.  For now, however, I’d like to discuss some of
the changes that have taken place.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a>
as originally written had two problems when it comes to building a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
agnostic implementation.  The first is that
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
was central to the CPU.  The
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interface therefore needed to be removed from
the CPU itself and made into <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/zipwb.v">a sort of
wrapper</a>.
The second problem was that the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/ex/wbdblpriarb.v">Wishbone
arbiter</a>
was integrated into the CPU.  This also needed to be removed from the CPU
core and placed into an external wrapper.</p>

<p>This naturally led to what I’m calling the
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/zipcore.v">ZipCore</a>.
The <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/zipcore.v">ZipCore</a>
is the logic left over after removing the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
logic from the original
<a href="/about/zipcpu.html">ZipCPU</a>.
The <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/zipcore.v">ZipCore</a>
is independent of any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
implementation.  Instead, it exports a custom interface to both the <a href="/zipcpu/2017/11/18/wb-prefetch.html">instruction
fetch</a> and the memory
controller.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 5. Separating the ZipCPU into independent proofs</caption><tr><td><img src="/img/tweets/zipcpu/cpu-verification.svg" alt="" width="360" /></td></tr></table>

<p>This also presented a wonderful opportunity to separate the <a href="/blog/2018/04/02/formal-cpu-bugs.html">formal verification
of the ZipCPU</a>
from the verification of the instruction and data
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
interfaces.
This is shown in Fig. 5 by the introduction of custom interface property sets
sitting between the CPU and these two sets of interface modules.  I now have
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/bench/formal/ffetch.v">one custom property set for verifying the instruction
fetch</a>,
and <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/bench/formal/fmem.v">another for verifying the memory controller
fetch</a>.
This means that any instruction fetch or memory controller meeting these
properties will then be able to work with the
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/zipcore.v">ZipCore</a>.
As a result, I no longer need to verify that the
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/zipcore.v">ZipCore</a>.
will work with a particular instruction fetch or a particular memory controller
implementation.  Instead, I just need to prove that those controllers will work
with the appropriate custom interface property set.  If they do, then they’ll
work with the CPU.</p>

<p>Of course, they’ll also need to work with the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
they are connected to, and so this requires a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> <a href="/formal/2020/06/12/four-keys.html">interface property
set</a>–either
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
or <a href="/formal/2018/12/28/axilite.html">AXI</a>, but
we’ll get to that in a bit.</p>

<p>For now, let’s look at what the
<a href="/about/zipcpu.html">ZipCPU</a>’s memory interface looks like.</p>

<h2 id="cpu-interface">CPU Interface</h2>

<p>The <a href="/about/zipcpu.html">ZipCPU</a>’s
memory controller interface can support one of two basic operations: read
and write.  Each leads to a slightly different sequence.  These are shown in
Fig. 6.</p>

<table align="center" style="float: right"><caption>Fig 6. Memory operation sequences</caption><tr><td><img src="/img/axilops/mem-tasks.svg" alt="" width="400" /></td></tr></table>

<p>In the case of a write, the CPU provides the address and the value to be written
to the controller.  The controller then becomes busy.  Once it finishes the
task, if all goes well, it quietly ceases to be busy.  If something went wrong,
the memory controller will instead return an error.</p>

<p>Reads are similar, with the difference that the result needs to be returned
to the CPU once the operation is complete.  In this case, the memory controller
sets a valid signal for the CPU, the value returned from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>, and then
returns to the CPU the register address that this value is to be written into.
At least the way the
<a href="/about/zipcpu.html">ZipCPU</a>
handles this interface, it is the memory controller
that keeps track of what register the result will be written into.  That’s
what happens if all goes well.  However, if the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> returns an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>, then the
controller will set an error flag instead of the valid flag.  It’s up to
the CPU then to determine what to do in case of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.</p>

<p>In general, the <a href="/about/zipcpu.html">ZipCPU</a>
will do one of two things on a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.  If the CPU
is in user mode, it will switch to supervisor mode.  If, on the other hand,
the CPU is in supervisor mode then it will halt.  If desired, an external
wrapper can reset the CPU as an attempt to recover from the
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>, but in
general it just halts and waits for the
<a href="/zipcpu/2017/08/25/hw-debugging.html">debugger</a>.  The <a href="https://github.com/ZipCPU/s6soc">S6SoC
project</a> was my one exception to this rule,
since <a href="/blog/2017/06/12/minimizing-luts.html">there was no room for an external debugging
bus</a> in that design.
In that case, the CPU would simply restart, dump the last CPU register contents,
and then attempt to continue a reboot from there.</p>

<p>No matter how the software handles the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>, the memory controller will
not return further results from any ongoing set of operations.  Returns from
outstanding reads following a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> will be ignored.  Outstanding
writes may, or may not be, completed–depending on their status within the
memory controller and the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> implementation.  At a
minimum, only one
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> will be returned.  Further
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> responses from any
outstanding accesses on the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
will not be returned to the CPU.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 7. The memory controller interface</caption><tr><td><img src="/img/axilops/mem-interface.svg" alt="" width="400" /></td></tr></table>

<p>Fig. 7 on the left shows the basic interface between the CPU core and it’s
memory controller used to implement these operations.  Let’s take a moment
before going any further to discuss the various signals in this interface.
Indeed, the basic interface is fairly simple:</p>

<ul>
  <li>
    <p>The <a href="/blog/2020/03/14/axi-reset.html">bus reset</a>,
<code class="language-plaintext highlighter-rouge">i_bus_reset</code>: This is just another name for the system reset
pin.  Everything resets when the
<a href="/blog/2020/03/14/axi-reset.html">bus reset</a> is asserted.</p>
  </li>
  <li>
    <p>The CPU reset, <code class="language-plaintext highlighter-rouge">i_cpu_reset</code>: With
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>,
it’s easy to reset the CPU
separate from the bus.  All you need to do is drop the <code class="language-plaintext highlighter-rouge">CYC</code> and <code class="language-plaintext highlighter-rouge">STB</code> lines.
With AXI, <a href="/blog/2020/03/14/axi-reset.html">this is a bit
harder</a>,
since you will still get responses back from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
from any requests that were made before your reset if you don’t
also reset the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
This is why the memory interface separates the CPU
reset from the system reset, so that the CPU can be reset separate from
the rest of the design.  It’s up to the memory controller to make sure
that the CPU doesn’t get any stale memory results from prior to the reset
request returning afterwards.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">i_stb</code>: This is the basic request line.  When the CPU raises <code class="language-plaintext highlighter-rouge">i_stb</code>, it
wants to initiate a memory operation.  For those familiar with the AXI
stream protocol, you can think of this as <code class="language-plaintext highlighter-rouge">TVALID &amp;&amp; TREADY</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">o_pipe_stalled</code>: This is the basic stall line.  When raised, the CPU
will not raise <code class="language-plaintext highlighter-rouge">i_stb</code> to make a request of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Continuing with the AXI stream analogy from above, this is similar to the
<code class="language-plaintext highlighter-rouge">!TREADY</code> signal in AXI stream.</p>
  </li>
</ul>

<table align="center" style="float: right"><caption>Fig 8. i_op encoding</caption><tr><td><img src="/img/axilops/iop-encoding.svg" alt="" width="400" /></td></tr></table>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">i_op</code>: This specifies the type of operation.  To keep logic counts low,
the bits to the memory operation are drawn directly from the instruction
word.  <code class="language-plaintext highlighter-rouge">i_op[0]</code> will be true for a write (store) instruction, and false for a
read (load) instruction.  <code class="language-plaintext highlighter-rouge">i_op[2:1]</code> then specifies the size of that
operation.  <code class="language-plaintext highlighter-rouge">2'b11</code> specifies a byte-wise read or write, <code class="language-plaintext highlighter-rouge">2'b10</code> a
half-word/short (16b) operation, and <code class="language-plaintext highlighter-rouge">2'b01</code> a full word operation.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">i_addr</code>: The address to be written to or read from.  This only has meaning
when <code class="language-plaintext highlighter-rouge">i_stb</code> is true.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">i_data</code>: The data to be written to the address above.  This only has meaning
when both <code class="language-plaintext highlighter-rouge">i_stb</code> and <code class="language-plaintext highlighter-rouge">i_op[0]</code>.  For 8’bit writes, only the lower 8-bits
have meaning.  Likewise for 16’bit writes only the lower 16-bits have any
meaning.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">i_oreg</code>: For reads, this specifies the register address that the read result
will be placed into upon completion.  The memory unit will hold onto this
value, and then return it to the CPU again later.  In the case of the
pipelined operators, this value will go into a FIFO to be returned later with
any read results.  This value is ignored in the case of writes.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">o_busy</code>: If the memory core is busy doing anything, it will set <code class="language-plaintext highlighter-rouge">o_busy</code>.
For example, if you issue a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
operation, then <code class="language-plaintext highlighter-rouge">o_busy</code> will go true.  If you later reset the CPU, <code class="language-plaintext highlighter-rouge">o_busy</code>
will remain true until the memory core can accept another operation.</p>

    <p><code class="language-plaintext highlighter-rouge">o_busy</code> is subtly different from <code class="language-plaintext highlighter-rouge">o_pipe_stalled</code> in that the CPU may issue
additional memory operations while <code class="language-plaintext highlighter-rouge">o_busy &amp;&amp; !o_pipe_stalled</code>.  However,
the CPU will not start a new string of memory operations, nor will it change
direction while the memory core asserts <code class="language-plaintext highlighter-rouge">o_busy</code>.</p>

    <p>It’s important to note that the CPU may move on to a non-memory instruction
if <code class="language-plaintext highlighter-rouge">o_busy</code> is true as long as <code class="language-plaintext highlighter-rouge">o_rdbusy</code> is low.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">o_rdbusy</code>: If the memory core is busy reading values from the memory, then
<code class="language-plaintext highlighter-rouge">o_rdbusy</code> will be set to indicate that a read is in progress and the CPU
should not proceed to any other instructions (other than additional reads).</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">o_valid</code>: Once a read value is returned, <code class="language-plaintext highlighter-rouge">o_valid</code> will be set to indicate
the need to write to the register file the value returned from the read.  If
all goes well, there will be exactly one <code class="language-plaintext highlighter-rouge">o_valid</code> for every
<code class="language-plaintext highlighter-rouge">i_stb &amp;&amp; !i_op[0]</code>, although CPU resets and
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>s may keep this count
from being exact.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">o_err</code>: This will be set following any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>, with two exceptions:
First, if the CPU is reset while operations are outstanding, then any
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> response for those
outstanding operations will not be returned.  Second, after the first
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>, the memory controller will
first flush any ongoing operations before returning any more
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>s to the CPU.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">o_wreg</code>: When returning a data value to the CPU, the <code class="language-plaintext highlighter-rouge">o_wreg</code> value tells
the CPU where to write the value.  This is basically the <code class="language-plaintext highlighter-rouge">i_oreg</code> value
given to the memory controller reflected back to the CPU, together with the
data value that goes with it.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">o_result</code>: The value from any read return is provided in <code class="language-plaintext highlighter-rouge">o_result</code>.
In the case of an 8-bit read, the upper 24-bits will be cleared.  Likewise,
for a 16’bit read, the upper 16’bits will be cleared.</p>

    <p>Some CPU’s sign extend byte reads to the full word size, some do not.  By
default, the <a href="/about/zipcpu.html">ZipCPU</a>
simply clears any upper bits.  Two following instructions,
a <code class="language-plaintext highlighter-rouge">TEST</code> instruction followed by a conditional <code class="language-plaintext highlighter-rouge">OR</code> can turn a zero extended
read into a sign extended read.  Alternatively, <a href="https://github.com/ZipCPU/zipcpu/blob/c8c2f9aa68c07bbd33276d3e198290bf9335ef4f/rtl/core/axilops.v#L706-L723">changing the memory
controller from one behavior to another is fairly easy to
do</a>.  Adjusting the GCC
toolchain and following support, however, can take a bit more work.</p>
  </li>
</ul>

<p>There are two other important signals in this interface.  These are signals
we won’t be addressing today, but they are important parts of the more
complex controller implementations.</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">i_clear_cache</code>: This is my way of dealing with cache’s and DMA’s.  The CPU
can issue a special instruction to clear the cache if the memory may have
changed independent of the CPU.  This input is also asserted if the
debug interface changes memory in a way the CPU is unaware of.  If raised,
the memory controller will mark any and all cached data as invalid–forcing
the cache to reload from scratch on the next request.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">i_lock</code>: This flag is used when implementing atomic memory instructions.
It will be raised by a <code class="language-plaintext highlighter-rouge">LOCK</code> instruction, and then lowered three instructions
later.  This allows for certain four instruction sequences: LOCK, LOAD,
(ALU operation), STORE.  A large variety of atomic instructions can be
implemented this way.  Examples include atomic adds, subtracts, or even the
classic test and set instruction.</p>
  </li>
</ul>

<table align="center" style="float: left; padding: 25px"><caption>Fig 9. Comparing ZipCPU and MicroBlaze test and set implementations</caption><tr><td><a href="/img/axilops/testnset.svg"><img src="/img/axilops/testnset.svg" alt="" width="460" /></a></td></tr></table>

<p>During these three instructions, the CPU is prevented from switching to
  supervisor mode on any interrupt until all three instructions following the
  lock have completed.</p>

<p>Atomic access requests are generally easy to implement when using
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.  The
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
cycle line is simply raised with the first LOAD instruction (LB, for load byte
in Fig. 9), and then held high between the LOAD and STORE instructions (SB, for
store byte in Fig. 9).  Things are a bit more complicated with AXI, however,
since AXI doesn’t allow a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
master to lock the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Instead, the CPU will only
discover if it’s atomic instruction was successful when/if the final store
operation fails.  In that case, the memory controller needs to tell the CPU to
back up to the lock instruction and start over.  How to make this happen,
however, is a longer discussion for the day we discuss the <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axiops.v">full AXI version
of this same memory
controller</a>.</p>

<p>To see how this interface might work when driving an
<a href="/formal/2018/12/28/axilite.html">AXI bus</a>, I thought I
might provide examples of both writing to and reading from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
Here’s the write example.</p>

<table align="center" style="float: none"><caption>Fig 10. An example write trace</caption><tr><td><a href="/img/axilops/writeop.svg"><img src="/img/axilops/writeop.svg" alt="" width="460" /></a></td></tr></table>

<p>Note the key steps:</p>

<ol>
  <li>
    <p>The CPU makes a request by setting <code class="language-plaintext highlighter-rouge">i_stb</code>, placing the data to be written
into <code class="language-plaintext highlighter-rouge">i_data</code>, and the address of the transaction into <code class="language-plaintext highlighter-rouge">i_addr</code>.</p>
  </li>
  <li>
    <p>The memory controller then becomes busy.  It raises both <code class="language-plaintext highlighter-rouge">M_AXI_AWVALID</code> and
<code class="language-plaintext highlighter-rouge">M_AXI_WVALID</code> to request a transaction of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
In this example, we
also raise <code class="language-plaintext highlighter-rouge">M_AXI_BREADY</code> as a bit in our state machine, to indicate that
we are expecting data to be returned from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> in the future.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">M_AXI_AWVALID</code> must remain high, and <code class="language-plaintext highlighter-rouge">M_AXI_AWADDR</code> must remain constant
until <code class="language-plaintext highlighter-rouge">M_AXI_AWREADY</code> is high.  In this highly compressed example,
<code class="language-plaintext highlighter-rouge">M_AXI_AWREADY</code> just happens to be high when <code class="language-plaintext highlighter-rouge">M_AXI_AWVALID</code> is set, so that
it <code class="language-plaintext highlighter-rouge">M_AXI_AWVALID</code> can be dropped on the next cycle.</p>

    <p>The same rule applies to <code class="language-plaintext highlighter-rouge">M_AXI_WVALID</code>.  <code class="language-plaintext highlighter-rouge">M_AXI_WVALID</code> must stay high
and <code class="language-plaintext highlighter-rouge">M_AXI_WDATA</code> and <code class="language-plaintext highlighter-rouge">M_AXI_WSTRB</code> must stay constant until <code class="language-plaintext highlighter-rouge">M_AXI_WREADY</code>.</p>

    <p>I’ve seen several beginner mistakes with this handshake.  Remember: this 
chart in Fig. 10 is only <em>representative!</em>  Some slaves will delay setting
<code class="language-plaintext highlighter-rouge">M_AXI_AWREADY</code> longer than others, some will set <code class="language-plaintext highlighter-rouge">M_AXI_AWREADY</code> before
<code class="language-plaintext highlighter-rouge">M_AXI_WREADY</code> and others will set them in a different order.  To be
compliant, an AXI master must be able to deal with all these situations.</p>
  </li>
  <li>
    <p>In this compressed example, <code class="language-plaintext highlighter-rouge">M_AXI_BVALID</code> is set on the clock immediately
following <code class="language-plaintext highlighter-rouge">M_AXI_AWVALID &amp;&amp; M_AXI_AWREADY &amp;&amp; M_AXI_WVALID &amp;&amp; M_AXI_WREADY</code>.</p>

    <p>Do not depend upon this condition!  I’ve seen beginner mistakes where
the beginner’s logic requires all four of these signals to be high at the
same time.  Remember, either one of these two channels might get accepted
before the other.</p>
  </li>
  <li>
    <p>Once <code class="language-plaintext highlighter-rouge">M_AXI_BVALID</code> has been received, the memory controller drops <code class="language-plaintext highlighter-rouge">o_busy</code>
to indicate that it is idle.  A new request may then be made on the same
cycle.</p>
  </li>
</ol>

<p>Now let’s take a look at a read example using this interface.</p>

<table align="center" style="float: none"><caption>Fig 11. An example read trace</caption><tr><td><a href="/img/axilops/readop.svg"><img src="/img/axilops/readop.svg" alt="" width="460" /></a></td></tr></table>

<p>While this example is very similar to the previous write example, there are some
key differences.  Therefore, let’s walk through it.</p>

<ol>
  <li>
    <p>The CPU indicates the desire to read from memory by raising <code class="language-plaintext highlighter-rouge">i_stb</code> and
placing the address to be read from in <code class="language-plaintext highlighter-rouge">i_addr</code>.  The register that will
be read into is also placed into <code class="language-plaintext highlighter-rouge">i_wreg</code>–the memory controller will need
to return this value back when the operation is complete.</p>

    <p>Not shown is the <code class="language-plaintext highlighter-rouge">i_op</code> input indicating the size of the read, whether
byte (8b), halfword (16b), or word (32b).</p>
  </li>
  <li>
    <p>Once the memory controller receives <code class="language-plaintext highlighter-rouge">i_stb</code>, it immediately sets
<code class="language-plaintext highlighter-rouge">M_AXI_ARVALID</code> and <code class="language-plaintext highlighter-rouge">M_AXI_ARADDR</code> with the information it is given.</p>

    <p>This controller also sets <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code> high at this point, as part of
its internal state tracking.  This is to indicate that a read return is
expected.</p>

    <p>Finally, the controller sets both <code class="language-plaintext highlighter-rouge">o_busy</code> and <code class="language-plaintext highlighter-rouge">o_rdbusy</code>.  The first
indicates that a memory operation is ongoing, and the second indicates
that we will be writing back to a register upon completion.  This latter
flag, <code class="language-plaintext highlighter-rouge">o_rdbusy</code>, is used to prevent the CPU from moving onto its next
operation and so helps avoid any pipeline hazard.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">M_AXI_ARVALID</code> must stay high and <code class="language-plaintext highlighter-rouge">M_AXI_ARADDR</code> constant until the slave
asserts <code class="language-plaintext highlighter-rouge">M_AXI_ARREADY</code>.  In this example, that happens immediately, but
this will not be the case with all slaves.</p>

    <p>Holding <code class="language-plaintext highlighter-rouge">M_AXI_ARVALID</code> high past <code class="language-plaintext highlighter-rouge">M_AXI_ARVALID &amp;&amp; M_AXI_ARREADY</code> will
request a second read.  Since we don’t want that here, we immediately drop
<code class="language-plaintext highlighter-rouge">M_AXI_ARVALID</code> upon seeing <code class="language-plaintext highlighter-rouge">M_AXI_ARREADY</code>.</p>
  </li>
  <li>
    <p>Once the slave accomplishes the read, it sets <code class="language-plaintext highlighter-rouge">M_AXI_RVALID</code> and
<code class="language-plaintext highlighter-rouge">M_AXI_RDATA</code>.  Since the memory controller is holding <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code> high,
these will only be set for a single cycle.</p>
  </li>
  <li>
    <p>The memory controller then copies the data from <code class="language-plaintext highlighter-rouge">M_AXI_RDATA</code> to <code class="language-plaintext highlighter-rouge">o_result</code>
to send it back to the CPU.  <code class="language-plaintext highlighter-rouge">o_valid</code> is set to indicate a result is valid.
<code class="language-plaintext highlighter-rouge">o_rdbusy</code> is dropped, since we are no longer in the middle of any operation.
Finally, <code class="language-plaintext highlighter-rouge">o_wreg</code> returns the register address that the CPU entrusted to the
memory controller.</p>
  </li>
</ol>

<p>These are examples drawn from <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">the controller we’ll be examining
today</a>.  Just
to prove that the throughput of this CPU interface isn’t
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> limited in general, here is
a trace drawn from <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilpipe.v">an AXI-lite memory controller capable of issuing multiple
ongoing operation</a>.</p>

<table align="center" style="float: none"><caption>Fig 12. An example pipelined read trace, from another controller</caption><tr><td><a href="/img/axilops/piperead.svg"><img src="/img/axilops/piperead.svg" alt="" width="460" /></a></td></tr></table>

<p>Just for the purposes of illustration, I dropped <code class="language-plaintext highlighter-rouge">M_AXI_ARREADY</code> on the
first cycle of the request for address <code class="language-plaintext highlighter-rouge">A3</code>, all this behavior is highly
slave dependent.  Doing this, however, helps to illustrate how a bus stall
will propagates through <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilpipe.v">that
controller</a>.
Notice how the CPU then suffers one stall, and that the result takes an extra
cycle to return the item from that address.  Beyond that, however, we’ll need
to save the examination of <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilpipe.v">that
controller</a>
for another day.  For now we’ll limit ourselves to <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">a
controller</a>
that can only handle a 33% <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
throughput at best.</p>

<p>33% throughput?  Is that the performance that can be expected from this type
of controller?  Well, not really.  That would be the performance you’d see if
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">this memory controller</a>
were connected directly to <a href="/blog/2019/05/29/demoaxi.html">a (good) block RAM
memory</a>.  If you connect it to
a <a href="/blog/2019/07/17/crossbar.html">crossbar interconnect</a>
instead, you can expect it to cost you two clock cycles going into the
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>, and another
clock cycle coming out.  Hence, to read from a block RAM memory, it will now
cost you 6 cycles, not 3, for a 16%
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
throughput.  Worse, if you
connect it to <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">Xilinx’s AXI block RAM controller</a>,
it’ll then take you an additional 4 clock cycles.  As a result, your
blazing fast <a href="/about/zipcpu.html">ZipCPU</a> would be crippled
down to one access for every 10 clock cycles simply due to a non-optimal
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
architecture.  Unfortunately, it only gets worse from there when you attach
your CPU to a slower AXI slave.</p>

<p>Here’s a trace showing what that whole operation, from CPU through
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
to <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">Xilinx’s AXI block RAM controller</a>
and back might look like.</p>

<table align="center" style="float: none"><caption>Fig 13. Adjacent single read requests through an interconnect and then Xilinx's AXI block RAM controller</caption><tr><td><a href="/img/axilops/rdloaded-an.svg"><img src="/img/axilops/rdloaded-an.svg" alt="" width="780" /></a></td></tr></table>

<p>In this trace, we have the outputs of our controller <code class="language-plaintext highlighter-rouge">M_AXI_ARVALID</code> and
<code class="language-plaintext highlighter-rouge">M_AXI_ARADDR</code> going into a
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>.  The
<a href="/blog/2019/07/17/crossbar.html">crossbar</a> forwards these
requests to <code class="language-plaintext highlighter-rouge">BRAM_AXI_ARVALID</code> and <code class="language-plaintext highlighter-rouge">BRAM_AXI_ARADDR</code>, the inputs to <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">Xilinx’s
AXI block RAM controller</a>.
<a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">This block RAM controller</a>
takes a clock cycle to raise <code class="language-plaintext highlighter-rouge">BRAM_ARREADY</code>, and then two more clock cycles
before it raises its output on the result pipe, <code class="language-plaintext highlighter-rouge">BRAM_RVALID</code> and <code class="language-plaintext highlighter-rouge">BRAM_RDATA</code>.
From here it will take another clock to go through the
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>.  This clock is
the minimum timing allowed by the <a href="/doc/axi-spec.pdf">AXI
spec</a>.  As a result, the read takes a
full 10 cycles.  The <a href="/about/zipcpu.html">ZipCPU</a>’s memory
interface will allow a second request as soon as this one returns, yielding a
maximum throughput of 11%.</p>

<p>As I mentioned above, fixing this horrendous throughput will require a
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilpipe.v">redesigned memory
controller</a>.
Of course, a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">better AXI block RAM
controller</a>
would also help as well.</p>

<p>We’ll get there.</p>

<p>For now, a <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">working AXI memory
controller</a>
is a good place to start from.  We can come back to this project and optimize
it later if we get the chance.</p>

<h2 id="basic-operator">Basic Operator</h2>

<p>Now that we know what our interface looks like, let’s peel the onion back
another layer deeper to see how we might implement these operations when using
AXI-lite.</p>

<p>First, let me answer the question of why AXI-lite and not AXI?  And, moreover,
what will the consequences be of not using the full AXI4 interface?  For
today’s discussion, I have several reasons for not using the full AXI4
interface:</p>

<ol>
  <li>
    <p>AXI-lite is simpler.</p>

    <p>This may be my biggest reason.</p>
  </li>
  <li>
    <p><a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilite2axi.v">AXI-lite can easily be converted to AXI (full) by just setting the missing
  signals</a>.</p>
  </li>
  <li>
    <p>The CPU memory unit doesn’t need AXI IDs.  While a CPU might use two
  separate AXI IDs, only one would ever be needed for any source.  Therefore,
  the fetch unit might use one ID and the memory controller another.  If a
  DMA were integrated into the CPU, it might use a third ID and so on.  There’s
  just no need for separate ID’s in the memory controller itself.</p>
  </li>
  <li>
    <p>Since we’re only implementing a single access at a time today, or in the
case of misaligned accesses two accesses at a time, there’s no reason
to use AXI bursts.</p>

    <p>When (if) we get to building an AXI
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/axiicache.v">instruction</a>
or <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/axidcache.v">data
cache</a>,
then bursts will make sense.  In such cases, a natural burst length will be
the size of a single cache line.</p>

    <p>While it might make sense to issue a burst request when dealing with
misaligned accesses later, AXI’s requirement that burst accesses never cross
4kB boundaries <a href="/blog/2020/06/16/axiaddr-limits.html">could make this a
challenge</a>.  By
leaving adjacent memory accesses as independent, we don’t need to worry
about this 4kB requirement.</p>
  </li>
</ol>

<p>There is one critical
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
capability that we will lose by implementing <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">this
memory controller for AXI4-lite</a> rather than AXI4 (full), and that is the
ability to implement atomic access instructions.  If for no other reason,
let’s consider this implementation only a first draft of a simple controller,
so that we can come back later with a more complicated and full featured
controller at a later time.  Indeed, if you compare <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">this
core</a> to a
comparable <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axiops.v">full AXI memory
controller</a>,
you’ll see the two mostly share the same structure.</p>

<p>For now, let’s work our way through a first draft of setting our various
AXI4-lite signals.</p>

<p>The first signals we’ll control will be the various <code class="language-plaintext highlighter-rouge">xVALID</code> and <code class="language-plaintext highlighter-rouge">xREADY</code>
signals associated with any AXI request.  As discussed above, we’ll use the
<code class="language-plaintext highlighter-rouge">xREADY</code> signals as internal state variables to know when something is
outstanding.  Hence, on a write request we’ll set <code class="language-plaintext highlighter-rouge">M_AXI_BREADY</code> and we’ll
clear it once the request is acknowledged.  We’ll treat read requests
similarly, only using <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code> for that purpose instead.</p>

<p>The first step will be to clear these signals on any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">M_AXI_WVALID</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">M_AXI_BREADY</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">M_AXI_RREADY</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>While it’s a little out of order, the next group in this block controls
how to handle an ongoing operation.  In general, if ever <code class="language-plaintext highlighter-rouge">AxREADY</code> then the
associated <code class="language-plaintext highlighter-rouge">AxVALID</code> signal will be cleared.  Likewise, once <code class="language-plaintext highlighter-rouge">BVALID</code> or
<code class="language-plaintext highlighter-rouge">RVALID</code> are returned, we can close up and finish our operation and clear
our <code class="language-plaintext highlighter-rouge">xREADY</code> signals.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span> <span class="o">||</span> <span class="n">M_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span> <span class="c1">// Something is outstanding</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWREADY</span><span class="p">)</span>
			<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WREADY</span><span class="p">)</span>
			<span class="n">M_AXI_WVALID</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARREADY</span><span class="p">)</span>
			<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">||</span> <span class="n">M_AXI_RVALID</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">M_AXI_BREADY</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
			<span class="n">M_AXI_RREADY</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">end</span></code></pre></figure>

<p>As I mentioned above, getting this signaling wrong is a common beginning
AXI mistake.  Remember, the <code class="language-plaintext highlighter-rouge">AW*</code> and <code class="language-plaintext highlighter-rouge">W*</code> channels are independent, and
that <code class="language-plaintext highlighter-rouge">VALID</code> cannot be lowered until <code class="language-plaintext highlighter-rouge">READY</code>.</p>

<p>The last step in controlling these signals is to set them on any request.
Assuming a request is incoming, we’ll want to set the various write
flags if <code class="language-plaintext highlighter-rouge">i_op[0]</code> is ever true–indicating a write operation request.
Otherwise, for read operations, we’ll want to set <code class="language-plaintext highlighter-rouge">M_AXI_ARVALID</code> and
<code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="c1">// New memory operation</span>
		<span class="c1">// Initiate a request</span>
		<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span>  <span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// Write request</span>
		<span class="n">M_AXI_WVALID</span>  <span class="o">&lt;=</span>  <span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// Write request</span>
		<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// Read request</span>

		<span class="c1">// Set BREADY or RREADY to accept the response.  These will</span>
		<span class="c1">// remain ready until the response is returned.</span>
		<span class="n">M_AXI_BREADY</span>  <span class="o">&lt;=</span>  <span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">M_AXI_RREADY</span>  <span class="o">&lt;=</span> <span class="o">!</span><span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span></code></pre></figure>

<p>Of course, that’s only if a request is being made on this cycle.  Hence,
let’s caveat these new values.  If there’s no request being made, then these
lines should be kept clear.  Likewise, if the request is for an unaligned
address then (in our first draft) we’ll return an error to the CPU and not
issue any request.  Finally, on either a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
or a CPU reset we’ll need
to make certain that we don’t start a new request that will immediately
be unwanted one the next cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span> <span class="o">||</span> <span class="n">o_err</span> <span class="o">||</span> <span class="o">!</span><span class="n">i_stb</span> <span class="o">||</span> <span class="n">w_misaligned</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">M_AXI_WVALID</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">M_AXI_BREADY</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">M_AXI_RREADY</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>Judging from the AXI requests associated with Xilinx forum posts that I’ve
examined, getting those five signals right tends to be half the battle.</p>

<p>There is another signal, however, that we’ll need to pay attention to, and
this is the one capturing whether or not the CPU was reset separate from the
system.  In such cases, we’ll need to flush any ongoing
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
operation without returning its results to the CPU at a later time.  To
handle this, we’re going to implement an <code class="language-plaintext highlighter-rouge">r_flushing</code> signal.  This
signal will capture the idea of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> begin busy,
even through the CPU isn’t expecting a result from it.</p>

<p>This signal will be cleared on any system reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">r_flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>The primary purpose of this signal is to let us know to flush any outstanding
returns following a CPU reset while a bus operation is ongoing without also
needing to reset the bus.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span> <span class="o">||</span> <span class="n">M_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span><span class="p">)</span>
			<span class="c1">// If only the CPU is reset, however, we have a problem.</span>
			<span class="c1">// The bus hasn't been reset, and so it is still active.</span>
			<span class="c1">// We can't respond to any new requests from the CPU</span>
			<span class="c1">// until we flush any transactions that are currently</span>
			<span class="c1">// active.</span>
			<span class="n">r_flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>There’s one caveat to this, however, and that is that we don’t want to set
<code class="language-plaintext highlighter-rouge">r_flushing</code> if the CPU is reset on the same cycle the outstanding value is
returned to the CPU.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">||</span> <span class="n">M_AXI_RVALID</span><span class="p">)</span>
			<span class="c1">// A request just came back, therefore we can clear</span>
			<span class="c1">// r_flushing</span>
			<span class="n">r_flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Otherwise if the bus is idle, we can leave the <code class="language-plaintext highlighter-rouge">r_flushing</code> signal at zero–no
matter whether the CPU is reset or not.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span>
		<span class="c1">// If nothing is active, we don't care about the CPU reset.</span>
		<span class="c1">// Flushing just stays at zero.</span>
		<span class="n">r_flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Handling the bus address for this simple controller is really easy.  As long
as we aren’t in the middle of any operations, we can set the address to the
CPU’s requested address.  Even better, we can use the same logic for both
read and write addresses.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">M_AXI_AWADDR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_BREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_RREADY</span><span class="p">)</span>
		<span class="n">M_AXI_AWADDR</span> <span class="o">&lt;=</span> <span class="n">i_addr</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">M_AXI_ARADDR</span> <span class="o">=</span> <span class="n">M_AXI_AWADDR</span><span class="p">;</span></code></pre></figure>

<p>AXI requires an <code class="language-plaintext highlighter-rouge">AxPROT</code> signal accompany any request.  Looking through the
AXI spec, it looks like <code class="language-plaintext highlighter-rouge">3'h0</code> will work nicely for us.  This will specify
an unprivileged, secure data access.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">M_AXI_AWPROT</span>  <span class="o">=</span> <span class="mh">3'h0</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_ARPROT</span>  <span class="o">=</span> <span class="mh">3'h0</span><span class="p">;</span></code></pre></figure>

<p>That brings us to setting <code class="language-plaintext highlighter-rouge">M_AXI_WDATA</code> and its associated <code class="language-plaintext highlighter-rouge">M_AXI_WSTRB</code>.
In general, we’re going to need to up shift these values based upon where
the data given us will fit on the bus.  I like to use <code class="language-plaintext highlighter-rouge">AXILSB</code> to capture the
number of address bits, in an AXI interface, necessary to define which octet
the address is referencing.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">AXILSB</span> <span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span></code></pre></figure>

<p>Remember not to copy Xilinx’s formula for this bus width, since <a href="/blog/2019/05/29/demoaxi.html">their
calculation is only valid for 16, 32, or 64-bit bus
widths</a>.  (You can see <a href="https://github.com/ZipCPU/wb2axip/blob/1a4f62693540e6a6c8f25a626a2fbec74f3974a2/bench/formal/xlnxdemo.v#L132">their
bug here</a>.  In their defense, this doesn’t really
matter in an AXI-lite interface, since Xilinx only allows AXI-lite to ever have
a data width of 32-bits.  Sadly, they <a href="https://github.com/ZipCPU/wb2axip/blob/1a4f62693540e6a6c8f25a626a2fbec74f3974a2/bench/formal/xlnxfull_2018_3.v#L234">made the same mistake in their AXI
full demonstrator</a>.)</p>

<p>We can now use this value to shift our data input by eight times the value of
these lower address bits to place our write data in its place on the bus.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="n">axi_wdata</span> <span class="c1">// Half-word store</span>
			<span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span> <span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">16</span><span class="p">)</span><span class="o">{</span> <span class="mb">1'b0</span> <span class="o">}}</span><span class="p">,</span> <span class="n">i_data</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span>
				<span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
		<span class="mb">2'b11</span><span class="o">:</span> <span class="n">axi_wdata</span> <span class="c1">// 8-bit (byte) store</span>
			<span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span> <span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">{</span>  <span class="mb">1'b0</span><span class="p">,</span> <span class="o">}}</span><span class="p">,</span> <span class="n">i_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span>
				<span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
		<span class="nl">default:</span> <span class="n">axi_wdata</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">endcase</span></code></pre></figure>

<p>We’ll come back in a moment and assign <code class="language-plaintext highlighter-rouge">M_AXI_WDATA</code> to be the same as
this <code class="language-plaintext highlighter-rouge">axi_wdata</code>.  For now, let’s just note that the logic for <code class="language-plaintext highlighter-rouge">axi_wstrb</code>
is almost identical.  In this case, we’re upshifting a series of <code class="language-plaintext highlighter-rouge">1</code>s,
one for each byte we wish to write, by subword address bits.  The second
big difference is that we aren’t multiplying the low order address bits by
eight like we did for the data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// next_wstrb, axi_wstrb</span>
		<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
		<span class="mb">2'b0?</span><span class="o">:</span> <span class="n">axi_wstrb</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span>
						<span class="mb">4'b1111</span><span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="n">axi_wstrb</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span>
						<span class="mb">4'b0011</span><span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
		<span class="mb">2'b11</span><span class="o">:</span> <span class="n">axi_wstrb</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span>
						<span class="mb">4'b0001</span><span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">endcase</span></code></pre></figure>

<p>There’s one last step here, and that is that we need to keep track of both the
operation size as well as the lower bits of the address.  We’re going to need
these later, on a read return to know how to grab the byte of interest from
the bus.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">r_op</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span> <span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">end</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">M_AXI_WSTRB</span><span class="p">,</span> <span class="n">M_AXI_WDATA</span> <span class="o">}</span> <span class="o">=</span> <span class="o">{</span> <span class="n">axi_wstrb</span><span class="p">,</span> <span class="n">axi_wdata</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>That leaves only one other signal required to generate a bus request, and that
signal is going to tell us if and when we need to abort the request due to
the fact that it will require two operations.  For this initial implementation,
we’ll simply return an error to the CPU in this case.  We’ll come back to this
in a moment to handle misaligned accesses, but this should be good enough
for a first pass.</p>

<p>An access is misaligned if the access doesn’t fit within a single bus word.
For a 4-byte request, if adding 3 to the address moves you into the next
word then the request is misaligned.  For a 2-byte request, if adding one
moves you to the next word then the request is misaligned.  Single byte
requests, however, cannot be misaligned.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
	<span class="c1">// Full word</span>
	<span class="mb">2'b0?</span><span class="o">:</span> <span class="n">w_misaligned</span> <span class="o">=</span> <span class="p">((</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">AXILSB</span><span class="p">));</span>
	<span class="c1">// Half word</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="n">w_misaligned</span> <span class="o">=</span> <span class="p">((</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">AXILSB</span><span class="p">));</span>
	<span class="c1">// Bytes are always aligned</span>
	<span class="mb">2'b11</span><span class="o">:</span> <span class="n">w_misaligned</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">endcase</span></code></pre></figure>

<p>Now, if this flag is ever true, we’ll skip issuing the request and instead
return a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
to the CPU.  (We’ll get to that in a moment.)</p>

<p>That’s what it takes to make a request of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.</p>

<p>The next request is to handle the return from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
and to forward it to the CPU.</p>

<p>The first part of any return to the CPU is returning a value.  We’ll have a
value to return if and when <code class="language-plaintext highlighter-rouge">RVALID</code> is true.  We’ll take a clock cycle
to set this <code class="language-plaintext highlighter-rouge">o_valid</code> flag, so as to allow us a clock cycle to shift <code class="language-plaintext highlighter-rouge">RDATA</code>
to the right value.</p>

<p>For now, notice that <code class="language-plaintext highlighter-rouge">o_valid</code> needs to be kept clear following a reset of
any type.  Further, it needs to be kept clear if we are flushing responses
as part of a CPU reset separate from an AXI bus reset.  Finally, we’ll set
the <code class="language-plaintext highlighter-rouge">o_valid</code> flag on <code class="language-plaintext highlighter-rouge">RVALID</code> as long as the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
didn’t return an <a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span> <span class="o">||</span> <span class="n">r_flushing</span><span class="p">)</span>
		<span class="n">o_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_valid</span> <span class="o">&lt;=</span> <span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_RRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span></code></pre></figure>

<p>We now turn our attention to the CPU
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> flag.  In general, a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
will be returned when either <code class="language-plaintext highlighter-rouge">BVALID</code> or <code class="language-plaintext highlighter-rouge">RVALID</code> and the response is an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.  We’ll also return a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
on any request to send something misaligned to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.  The exceptions,
however, are important.  If the CPU is reset, we don’t want to return an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
nor if we are waiting for that reset to complete.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_err</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span> <span class="o">||</span> <span class="n">r_flushing</span> <span class="o">||</span> <span class="n">o_err</span><span class="p">)</span>
		<span class="n">o_err</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span> <span class="o">&amp;&amp;</span> <span class="n">w_misaligned</span><span class="p">)</span>
		<span class="n">o_err</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_err</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_RRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span></code></pre></figure>

<p>We’ll also need to return some busy flags.  This core is busy if ever
<code class="language-plaintext highlighter-rouge">M_AXI_BREADY</code> or <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code> are true.  We’ll also set our
<code class="language-plaintext highlighter-rouge">o_pipe_stalled</code> flag to be equivalent to <code class="language-plaintext highlighter-rouge">o_busy</code> for this simple controller,
but that setting will be external to this logic.  Similarly, the CPU can
expect a response if <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code> is true and we aren’t flushing the result.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_busy</span>   <span class="o">=</span> <span class="n">M_AXI_BREADY</span> <span class="o">||</span> <span class="n">M_AXI_RREADY</span><span class="p">;</span> <span class="c1">// also pipe_stalled</span>
		<span class="n">o_rdbusy</span> <span class="o">=</span> <span class="n">M_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r_flushing</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>When returning a result to the CPU, we need to tell the CPU which register
to write the read result into.  Since this simple memory controller only
ever issues a single read or write request of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
we can choose to simply capture the register on any new request and know that
there will never be any other register to return.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span>
		<span class="n">o_wreg</span>    <span class="o">&lt;=</span> <span class="n">i_oreg</span><span class="p">;</span></code></pre></figure>

<p>That leaves us only one more signal to return to the CPU, the <code class="language-plaintext highlighter-rouge">o_result</code> from
a data read.  There are two parts to returning this value.  The first part
is that we’ll need to shift the value back down from (wherever) it is placed
in the return
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
word.  This was why we kept the subword address bits in our <code class="language-plaintext highlighter-rouge">r_op</code> register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// o_result</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="n">M_AXI_RDATA</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">r_op</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span></code></pre></figure>

<p>We also kept the size of our operation in the upper bits of <code class="language-plaintext highlighter-rouge">r_op</code>.  We can
use these now to zero extend octets and half words into 32-bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">casez</span><span class="p">(</span><span class="n">r_op</span><span class="p">[</span><span class="n">AXILSB</span> <span class="o">+:</span> <span class="mi">2</span><span class="p">])</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="n">o_result</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="mb">2'b11</span><span class="o">:</span> <span class="n">o_result</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
		<span class="k">endcase</span>
	<span class="k">end</span></code></pre></figure>

<p>Some CPU’s sign extend sub word values on reading.  Not the
<a href="/about/zipcpu.html">ZipCPU</a>.  The
<a href="/about/zipcpu.html">ZipCPU</a>
zero extends subword values to full words on any read.  This behavior,
however, is <a href="https://github.com/ZipCPU/zipcpu/blob/c8c2f9aa68c07bbd33276d3e198290bf9335ef4f/rtl/core/axilops.v#L706-L723">easy enough to adjust if you want a different
behavior</a>.</p>

<p>There you go, <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">a basic AXI-lite based CPU memory
controller</a>.</p>

<h3 id="handling-misaligned-requests">Handling Misaligned Requests</h3>

<p>Perhaps I should have been satisfied with that first draft of <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">a basic memory
controller</a>.</p>

<p>I wasn’t.</p>

<p>The draft controller will return a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
response to the CPU if you ever try to write a misaligned word to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.  Try, for example, to
write a 32-bit word to address three.  The operation will fail with a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.  This was by design.
Why?  Because otherwise you’d then need to write across multiple words.</p>

<p>Well, why can’t we build a controller that will read or write across multiple
words when requested?  Such a controller could handle misaligned requests.</p>

<p>So, let’s start again, using the design template above, and see if we can
adjust this controller to handle misaligned requests.</p>

<p>The first thing we are going to need are some flags to capture a bit of
state.  Let’s try these:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">misaligned_aw_request</code>: This is the first request of two <code class="language-plaintext highlighter-rouge">AW*</code> requests,
as a result of a misaligned write.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">misaligned_request</code>: This is the first request of either two <code class="language-plaintext highlighter-rouge">W*</code> requests,
or two <code class="language-plaintext highlighter-rouge">AR*</code> requests.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">misaligned_response_pending</code>: Two responses are expected.  As a result, if
<code class="language-plaintext highlighter-rouge">misaligned_response_pending</code> is ever true, then we still expect either
two <code class="language-plaintext highlighter-rouge">BVALID</code> returns or two <code class="language-plaintext highlighter-rouge">RVALID</code> returns.  (One might be present on this
clock cycle.)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">misaligned_read</code>: This signal is very similar to
<code class="language-plaintext highlighter-rouge">misaligned_response_pending</code>, except that it isn’t cleared on the first
read response.  It’s used at the end to let us know that two read results
need to be merged together into one before returning them to the CPU.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">pending_err</code>: Of our two responses, the first has returned an error.  Since
it is only the first of two, we haven’t returned the error response to the
CPU yet.  Hence, if <code class="language-plaintext highlighter-rouge">pending_err</code>, then we need to return a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
to the CPU on the next bus return–regardless of what status response is
returned with it.</p>
  </li>
</ul>

<p>We can now go back to the top and re-look at our <code class="language-plaintext highlighter-rouge">xVALID</code> and <code class="language-plaintext highlighter-rouge">xREADY</code>
handshaking request flags again.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">M_AXI_AWVALID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">M_AXI_WVALID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">M_AXI_ARVALID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">M_AXI_BREADY</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">M_AXI_RREADY</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">M_AXI_WVALID</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">M_AXI_BREADY</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="n">M_AXI_RREADY</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>The big difference here is in how we handle a return.  If a misaligned request
is outstanding, then you don’t want to drop <code class="language-plaintext highlighter-rouge">xVALID</code> on the first cycle–you
will want to wait for the second return.  The same applies to waiting for two
responses.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span> <span class="o">||</span> <span class="n">M_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span> <span class="c1">// Something is outstanding</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWREADY</span><span class="p">)</span>
			<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span> <span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">misaligned_aw_request</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WREADY</span><span class="p">)</span>
			<span class="n">M_AXI_WVALID</span>  <span class="o">&lt;=</span> <span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">misaligned_request</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARREADY</span><span class="p">)</span>
			<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="n">M_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">misaligned_request</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">M_AXI_BVALID</span> <span class="o">||</span> <span class="n">M_AXI_RVALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">misaligned_response_pending</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">M_AXI_BREADY</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
			<span class="n">M_AXI_RREADY</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">end</span></code></pre></figure>

<p>That’s the big change there.  The logic required to start a memory operation
won’t change.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="c1">// New memory operation</span>

		<span class="c1">// Initiate a request</span>
		<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span>  <span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// Write request</span>
		<span class="n">M_AXI_WVALID</span>  <span class="o">&lt;=</span>  <span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// Write request</span>
		<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="c1">// Read request</span>

		<span class="c1">// Set BREADY or RREADY to accept the response.  These will</span>
		<span class="c1">// remain ready until the response is returned.</span>
		<span class="n">M_AXI_BREADY</span>  <span class="o">&lt;=</span>  <span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">M_AXI_RREADY</span>  <span class="o">&lt;=</span> <span class="o">!</span><span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span> <span class="o">||</span> <span class="n">o_err</span> <span class="o">||</span> <span class="o">!</span><span class="n">i_stb</span> <span class="o">||</span> <span class="n">w_misalignment_err</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">M_AXI_WVALID</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">M_AXI_BREADY</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">M_AXI_RREADY</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">r_flushing</code> signal, indicating that shouldn’t forward results to the
CPU is a little more complex.  The big difference here is if a misaligned
response is pending.  In that case, we don’t want to clear our <code class="language-plaintext highlighter-rouge">r_flushing</code>
signal on a return, but rather on the next return.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_flushing</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="c1">// If everything is reset, then we don't need to worry about</span>
		<span class="c1">// or wait for any pending returns--they'll be canceled by the</span>
		<span class="c1">// global reset.</span>
		<span class="n">r_flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span> <span class="o">||</span> <span class="n">M_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span><span class="p">)</span>
			<span class="c1">// If only the CPU is reset, however, we have a problem.</span>
			<span class="c1">// The bus hasn't been reset, and so it is still active.</span>
			<span class="c1">// We can't respond to any new requests from the CPU</span>
			<span class="c1">// until we flush any transactions that are currently</span>
			<span class="c1">// active.</span>
			<span class="n">r_flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">||</span> <span class="n">M_AXI_RVALID</span><span class="p">)</span>
			<span class="c1">// A request just came back, therefore we can clear</span>
			<span class="c1">// r_flushing</span>
			<span class="n">r_flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">misaligned_response_pending</span><span class="p">)</span>
			<span class="c1">// ... unless we're in the middle of a misaligned</span>
			<span class="c1">// request.  In that case, there will be a second</span>
			<span class="c1">// return that we still need to wait for.  This request,</span>
			<span class="c1">// though, will clear misaligned_response_pending.</span>
			<span class="n">r_flushing</span> <span class="o">&lt;=</span> <span class="n">r_flushing</span> <span class="o">||</span> <span class="n">i_cpu_reset</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span>
		<span class="c1">// If nothing is active, we don't care about the CPU reset.</span>
		<span class="c1">// Flushing just stays at zero.</span>
		<span class="n">r_flushing</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Address handling gets just a touch more complicated as well.  In this case,
any time an address is accepted we’ll increment it to the next word address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">M_AXI_AWADDR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="n">OPT_LOWPOWER</span><span class="p">)</span>
		<span class="n">M_AXI_AWADDR</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_BREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span> <span class="c1">// Initial address</span>
		<span class="n">M_AXI_AWADDR</span> <span class="o">&lt;=</span> <span class="n">i_addr</span><span class="p">;</span>

	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span>
			<span class="o">||</span><span class="p">(</span><span class="n">M_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_ARREADY</span><span class="p">))</span>
	<span class="k">begin</span> <span class="c1">// Subsequent addresses</span>
		<span class="n">M_AXI_AWADDR</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">AXILSB</span><span class="p">]</span>
			<span class="o">&lt;=</span> <span class="n">M_AXI_AWADDR</span><span class="p">[</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">AXILSB</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="c1">// All subsequent addresses shall be aligned per spec</span>
		<span class="n">M_AXI_AWADDR</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>There’s a couple things to remember here.  First, when handling a misaligned
request, we must always move to the next word—that’s what a misaligned request
is.  Second, the low address bits should be zero.  This will be appropriate for
little endian systems.  It’s not necessarily appropriate for big endian
systems like the <a href="/about/zipcpu.html">ZipCPU</a>,
but at least it won’t hurt.</p>

<p>The next trick is the <code class="language-plaintext highlighter-rouge">M_AXI_WDATA</code> and <code class="language-plaintext highlighter-rouge">M_AXI_WSTRB</code> values indicating which
bytes to write to and the values to be written to them.  The trick to making
this work is to map the request onto two separate
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
words.  Once mapped to two words, we can then send the result to those words
one at a time.</p>

<p>We’ll add one intermediate step here, though, which is to create the
<code class="language-plaintext highlighter-rouge">M_AXI_WSTRB</code>
value combinatorially first.  This just simplifies writing the logic out,
but not much more.  Note that we are again shifting a set of ones up by
the address in the low order bits of <code class="language-plaintext highlighter-rouge">i_addr</code>–just like we did before, only
this time onto two words worth of byte enables instead of just one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">shifted_wstrb_word</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span>
						<span class="mb">4'b1111</span><span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">shifted_wstrb_halfword</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span>
						<span class="mb">4'b0011</span><span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">shifted_wstrb_byte</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span>
						<span class="mb">4'b0001</span><span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span></code></pre></figure>

<p>The next change is that we’ll add two new registers: <code class="language-plaintext highlighter-rouge">next_wdata</code> and
<code class="language-plaintext highlighter-rouge">next_wstrb</code>.  These will hold the <em>next</em> values of <code class="language-plaintext highlighter-rouge">M_AXI_WDATA</code> and
<code class="language-plaintext highlighter-rouge">M_AXI_WSTRB</code>–the values we’ll use for them on the second clock cycle
of any misaligned request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axi_wdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">axi_wstrb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">next_wdata</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">next_wstrb</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">axi_wdata</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">axi_wstrb</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">next_wdata</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">next_wstrb</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">r_op</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Here’s the first of the key steps with <code class="language-plaintext highlighter-rouge">next_wdata</code> and <code class="language-plaintext highlighter-rouge">next_wstrb</code>: their
logic is identical to the logic we used before, save that they are applied
across two bus words.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="o">{</span> <span class="n">next_wdata</span><span class="p">,</span> <span class="n">axi_wdata</span> <span class="o">}</span>
			<span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">16</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span>
			    <span class="n">i_data</span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
		<span class="mb">2'b11</span><span class="o">:</span> <span class="o">{</span> <span class="n">next_wdata</span><span class="p">,</span> <span class="n">axi_wdata</span> <span class="o">}</span>
			<span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span>
			    <span class="n">i_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
		<span class="nl">default:</span> <span class="o">{</span> <span class="n">next_wdata</span><span class="p">,</span> <span class="n">axi_wdata</span> <span class="o">}</span>
			<span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">-</span><span class="mi">32</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span>
			    <span class="n">i_data</span> <span class="o">}</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">endcase</span>

		<span class="c1">// next_wstrb, axi_wstrb</span>
		<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
		<span class="mb">2'b0?</span><span class="o">:</span> <span class="o">{</span> <span class="n">next_wstrb</span><span class="p">,</span> <span class="n">axi_wstrb</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="n">swapped_wstrb_word</span><span class="p">;</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="o">{</span> <span class="n">next_wstrb</span><span class="p">,</span> <span class="n">axi_wstrb</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="n">swapped_wstrb_halfword</span><span class="p">;</span>
		<span class="mb">2'b11</span><span class="o">:</span> <span class="o">{</span> <span class="n">next_wstrb</span><span class="p">,</span> <span class="n">axi_wstrb</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="n">swapped_wstrb_byte</span><span class="p">;</span>
		<span class="k">endcase</span>

		<span class="n">r_op</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span> <span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Given that <code class="language-plaintext highlighter-rouge">axi_wdata</code> and <code class="language-plaintext highlighter-rouge">axi_wstrb</code> are going to map directly to
<code class="language-plaintext highlighter-rouge">M_AXI_WDATA</code> and <code class="language-plaintext highlighter-rouge">M_AXI_WSTRB</code>, that just leaves handling the second
write cycle.  For that, we just copy <code class="language-plaintext highlighter-rouge">next_wdata</code> to <code class="language-plaintext highlighter-rouge">axi_wdata</code> as soon
as the channel isn’t stalled.  We’ll likewise do the same for <code class="language-plaintext highlighter-rouge">next_wstrb</code>
and <code class="language-plaintext highlighter-rouge">axi_wstrb</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_WREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">axi_wdata</span> <span class="o">&lt;=</span> <span class="n">next_wdata</span><span class="p">;</span>
		<span class="n">axi_wstrb</span> <span class="o">&lt;=</span> <span class="n">next_wstrb</span><span class="p">;</span>
	<span class="k">end</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">M_AXI_WSTRB</span><span class="p">,</span> <span class="n">M_AXI_WDATA</span> <span class="o">}</span> <span class="o">=</span> <span class="o">{</span> <span class="n">axi_wstrb</span><span class="p">,</span> <span class="n">axi_wdata</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>What about detecting a misalignment?  More than that, what if we want this
core to either generate a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> as before on misalignment,
or to issue multiple requests?</p>

<p>To handle both capabilities, we’ll create an single bit <code class="language-plaintext highlighter-rouge">OPT_ALIGNMENT_ERR</code>
parameter.  If this bit is set, misaligned requests will generate
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>s.  If not, misaligned
requests will be allowed to take place.</p>

<p>We’ll also split our misalignment signal into two.  The first signal,
<code class="language-plaintext highlighter-rouge">w_misaligned</code>, will simply indicate a misaligned request.  The second
signal, <code class="language-plaintext highlighter-rouge">w_misaligned_err</code>, will indicate that we want this misaligned
request to turn into a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
	<span class="c1">// Full word</span>
	<span class="mb">2'b0?</span><span class="o">:</span> <span class="n">w_misaligned</span> <span class="o">=</span> <span class="p">((</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">AXILSB</span><span class="p">));</span>
	<span class="c1">// Half word</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="n">w_misaligned</span> <span class="o">=</span> <span class="p">((</span><span class="n">i_addr</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">AXILSB</span><span class="p">));</span>
	<span class="c1">// Bytes are always aligned</span>
	<span class="mb">2'b11</span><span class="o">:</span> <span class="n">w_misaligned</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">endcase</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">w_misalignment_err</span> <span class="o">=</span> <span class="n">OPT_ALIGNMENT_ERR</span> <span class="o">&amp;&amp;</span> <span class="n">w_misaligned</span><span class="p">;</span></code></pre></figure>

<p>The next big component will be handling our new misalignment signals.
Obviously, if we are just generating errors on any misaligned request, then
we won’t need these signals and they can be kept at zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_ALIGNMENT_ERR</span><span class="p">)</span>
	<span class="k">begin</span>

		<span class="k">assign</span>	<span class="n">misaligned_request</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">misaligned_aw_request</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">assign</span>	<span class="n">misaligned_response_pending</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">assign</span>	<span class="n">misaligned_read</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">assign</span>	<span class="n">pending_err</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>This will allow the optimizer to simplify our logic when we just adjust the
<code class="language-plaintext highlighter-rouge">OPT_ALIGNMENT_ERR</code> parameter.</p>

<p>On the other hand, if we are generating misaligned requests, then we’ll need
to define these signals.  The first indicates that this is a misaligned
request, and a second <code class="language-plaintext highlighter-rouge">W*</code> or <code class="language-plaintext highlighter-rouge">AR*</code> operation is required.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="kt">reg</span>	<span class="n">r_misaligned_request</span><span class="p">,</span> <span class="n">r_misaligned_aw_request</span><span class="p">,</span>
			<span class="n">r_misaligned_response_pending</span><span class="p">,</span> <span class="n">r_misaligned_read</span><span class="p">,</span>
			<span class="n">r_pending_err</span><span class="p">;</span>

		<span class="k">initial</span>	<span class="n">r_misaligned_request</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">r_misaligned_request</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_cpu_reset</span><span class="p">)</span>
			<span class="n">r_misaligned_request</span> <span class="o">&lt;=</span> <span class="n">w_misaligned</span>
						<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">w_misalignment_err</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_WREADY</span><span class="p">)</span>
					<span class="o">||</span> <span class="p">(</span><span class="n">M_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_ARREADY</span><span class="p">))</span>
			<span class="n">r_misaligned_request</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">misaligned_request</span> <span class="o">=</span> <span class="n">r_misaligned_request</span><span class="p">;</span></code></pre></figure>

<p>Since the <code class="language-plaintext highlighter-rouge">AW*</code> and <code class="language-plaintext highlighter-rouge">W*</code> channels need to be handled independently, we need
a separate signal to handle the second request on the <code class="language-plaintext highlighter-rouge">AW*</code> channel.  This
signal is almost identical to <code class="language-plaintext highlighter-rouge">misaligned_request</code> above, save that it is
cleared on <code class="language-plaintext highlighter-rouge">AWREADY</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">r_misaligned_aw_request</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">r_misaligned_aw_request</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_cpu_reset</span><span class="p">)</span>
			<span class="n">r_misaligned_aw_request</span> <span class="o">&lt;=</span> <span class="n">w_misaligned</span> <span class="o">&amp;&amp;</span> <span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
					<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">w_misalignment_err</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_AWREADY</span><span class="p">)</span>
			<span class="n">r_misaligned_aw_request</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">misaligned_aw_request</span> <span class="o">=</span> <span class="n">r_misaligned_aw_request</span><span class="p">;</span></code></pre></figure>

<p>Knowing if a response will be the first of two expected is the purpose of
<code class="language-plaintext highlighter-rouge">misaligned_response_pending</code>.  It’s set much the same as the other two.
The big difference in this signal is that it is cleared on either <code class="language-plaintext highlighter-rouge">M_AXI_BVALID</code>
or <code class="language-plaintext highlighter-rouge">M_AXI_RVALID</code>–the first return of the misaligned response.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">r_misaligned_response_pending</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">r_misaligned_response_pending</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_cpu_reset</span><span class="p">)</span>
			<span class="n">r_misaligned_response_pending</span> <span class="o">&lt;=</span> <span class="n">w_misaligned</span>
						<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">w_misalignment_err</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">||</span> <span class="n">M_AXI_RVALID</span><span class="p">)</span>
			<span class="n">r_misaligned_response_pending</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">misaligned_response_pending</span>
				<span class="o">=</span> <span class="n">r_misaligned_response_pending</span><span class="p">;</span></code></pre></figure>

<p>The next signal, <code class="language-plaintext highlighter-rouge">misaligned_read</code>, simply tells us we will need to reconstruct
the read response from two separate read values before returning it to the
CPU.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">r_misaligned_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">r_misaligned_read</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_cpu_reset</span><span class="p">)</span>
			<span class="n">r_misaligned_read</span> <span class="o">&lt;=</span> <span class="n">w_misaligned</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
						<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">w_misalignment_err</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">misaligned_read</span> <span class="o">=</span> <span class="n">r_misaligned_read</span><span class="p">;</span></code></pre></figure>

<p>Finally, our last misalignment signal is the <code class="language-plaintext highlighter-rouge">pending_err</code> signal.  This signal
gets set on any write or read error, and then cleared when that error is
returned to the CPU.  Once set, we’ll clear it any time the interface
clears.  This guarantees that we’ll be clear following any request or response
to the CPU as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">r_pending_err</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_BREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_RREADY</span><span class="p">)</span>
				<span class="o">||</span> <span class="n">r_flushing</span><span class="p">)</span>
			<span class="n">r_pending_err</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="o">||</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_RRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
			<span class="n">r_pending_err</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">pending_err</span> <span class="o">=</span> <span class="n">r_pending_err</span><span class="p">;</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>The next several signals have only minor modifications.</p>

<p>The <code class="language-plaintext highlighter-rouge">o_valid</code> signal, indicating a valid read return to the CPU, needs to be
adjusted so that it waits for the second return of any misaligned response.
Similarly, we don’t return <code class="language-plaintext highlighter-rouge">o_valid</code> if either the current or past response,
in the case of a pair of responses, indicates a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.
In those cases, we’ll set <code class="language-plaintext highlighter-rouge">o_err</code> next.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_valid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span> <span class="o">||</span> <span class="n">r_flushing</span><span class="p">)</span>
		<span class="n">o_valid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_valid</span> <span class="o">&lt;=</span> <span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_RRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pending_err</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">misaligned_response_pending</span><span class="p">;</span></code></pre></figure>

<p>The error return is also quite similar.  There are only a few differences.
The first is that we don’t want to return an <code class="language-plaintext highlighter-rouge">o_err</code> response if there’s still
a response pending.  The second difference is that we’ll also return an <code class="language-plaintext highlighter-rouge">o_err</code>
response if the prior response indicated a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_err</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span> <span class="o">||</span> <span class="n">r_flushing</span> <span class="o">||</span> <span class="n">o_err</span><span class="p">)</span>
		<span class="n">o_err</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span> <span class="o">&amp;&amp;</span> <span class="n">w_misalignment_err</span><span class="p">)</span>
		<span class="n">o_err</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">M_AXI_BVALID</span> <span class="o">||</span> <span class="n">M_AXI_RVALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">misaligned_response_pending</span><span class="p">)</span>
		<span class="n">o_err</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="o">||</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_RRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="o">||</span> <span class="n">pending_err</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_err</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Our busy signal returns to the CPU don’t change.  Those are the same as before,
as is the <code class="language-plaintext highlighter-rouge">o_wreg</code> register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_busy</span>   <span class="o">=</span> <span class="n">M_AXI_BREADY</span> <span class="o">||</span> <span class="n">M_AXI_RREADY</span><span class="p">;</span> <span class="c1">// also pipe_stalled</span>
		<span class="n">o_rdbusy</span> <span class="o">=</span> <span class="n">M_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r_flushing</span><span class="p">;</span>
	<span class="k">end</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span>
		<span class="n">o_wreg</span>    <span class="o">&lt;=</span> <span class="n">i_oreg</span><span class="p">;</span></code></pre></figure>

<p>That leaves one complicated piece left of this–reconstructing the read
return.  This is sort of the reverse of <code class="language-plaintext highlighter-rouge">next_wdata, axi_wdata</code> from above,
save that this time we are using <code class="language-plaintext highlighter-rouge">M_AXI_RDATA, last_result</code>.  Note the
reverse ordering–the first value is always going to be on the right in a
little endian bus.</p>

<p>The first step is to construct the two-word wide return, and then to shift
it appropriately so the desired data starts at the bottom byte.  We handle
this with a separate logic block so that we don’t get lint errors when
shifting from a value of one size to another.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">misaligned_read</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">OPT_ALIGNMENT_ERR</span><span class="p">)</span>
			<span class="n">pre_result</span> <span class="o">=</span> <span class="o">{</span> <span class="n">M_AXI_RDATA</span><span class="p">,</span> <span class="n">last_result</span> <span class="o">}</span>
					<span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">r_op</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">pre_result</span> <span class="o">=</span> <span class="o">{</span> <span class="mh">32'h0</span><span class="p">,</span> <span class="n">M_AXI_RDATA</span> <span class="o">}</span>
						<span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">r_op</span><span class="p">[</span><span class="n">AXILSB</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">end</span></code></pre></figure>

<p>Now that we have this pre-result, we can construct our final value.
First, on any read return we copy the return to our <code class="language-plaintext highlighter-rouge">last_result</code> register–in
case this is a misaligned return.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">last_result</span> <span class="o">&lt;=</span> <span class="n">endian_swapped_rdata</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_ALIGNMENT_ERR</span><span class="p">)</span>
			<span class="n">last_result</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>The next step is to turn this <code class="language-plaintext highlighter-rouge">pre_result</code> value into the value we return
to the CPU.  If this is a half-word or octet request, we’ll zero the upper
bits as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="n">pre_result</span><span class="p">;</span>

		<span class="c1">// Fill unused return bits with zeros</span>
		<span class="k">casez</span><span class="p">(</span><span class="n">r_op</span><span class="p">[</span><span class="n">AXILSB</span> <span class="o">+:</span> <span class="mi">2</span><span class="p">])</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="n">o_result</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">16</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="mb">2'b11</span><span class="o">:</span> <span class="n">o_result</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
		<span class="k">endcase</span>
	<span class="k">end</span></code></pre></figure>

<p>In many ways, this second pass at this design illustrates the way most of my
development has taken place recently.  I’ll often draft a simple version of
a design, and then slowly layer on top of it more and more complicated
functionality until it’s everything I want.</p>

<p>In hindsight, the misalignment processing wasn’t nearly as complicated as I
was fearing.  I know, I tend to dread handling misaligned requests.  However,
it never seems to be that hard when I actually get down to building it.
Once you adjust the signaling to handle two requests, the remaining process
is fairly basic: place the data into a two word shift register and shift
it as appropriate, then deal with each half of that register.</p>

<p>If you look over <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">the design for this memory
controller</a>,
you might notice other options as well.  For example, there’s an <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code>
option that will force all unused signals to zero.  There’s a <code class="language-plaintext highlighter-rouge">OPT_SIGN_EXTEND</code>
option to sign extend the return data.  We’ve already mentioned the
<code class="language-plaintext highlighter-rouge">OPT_ALIGNMENT_ERR</code> option.  Finally, there are some experimental
<code class="language-plaintext highlighter-rouge">SWAP_ENDIANNESS</code> options that I’m still working with–as part of hoping that
I can somehow keep a big endian CPU running on a little endian bus without
massive changes.  (I’m not convinced any of these endianness parameters,
either the <code class="language-plaintext highlighter-rouge">SWAP_ENDIANNESS</code> or the <code class="language-plaintext highlighter-rouge">SWAP_WSTRB</code> options, will work–they’re
still part of my ongoing development.)</p>

<h2 id="formal-verification">Formal Verification</h2>

<p>At this point in my design, I’ve only formally verified <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">this memory
controller</a>.
I haven’t yet simulated it.  Yes, I’m expecting some problems when I get
to simulation, but, hey, one step at a time, right?</p>

<p>Let’s now take some time, though, to look over some of the major parts of that
proof.  These include the AXI-lite interface properties, the CPU interface
properties, and some cover checks to make sure the design works.  This follows
from <a href="/formal/2020/06/12/four-keys.html">what I’ve learned from previous experiences about what works for verifying
a design</a>.  Perhaps it
will work the first time I try it in simulation.  We’ll see.  (I’m still not
convinced the big-endian CPU will work with this little-endian controller,
formal proof or not … but we’ll see.)</p>

<h3 id="axi-lite-interface">AXI-lite interface</h3>

<p>Two years ago, <a href="/formal/2018/12/28/axilite.html">I posted a set of interface properties for working with
AXI-lite</a>.  At the time,
I was very excited about these properties.  By capturing <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">all the requirements
of an AXI-lite interface into a set of formal properties</a>,
I could simplify any future verification problems.  I predicted
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>
designs would become easy to build as a result.</p>

<p>I haven’t been disappointed.  While I’ve made small adjustments to <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">those
properties</a>
since that time, they’ve seen me through a lot.  Using them, I’ve been able
to very quickly check designs posted on Xilinx’s forums.  The check tends to
take about a half hour or so.  Even better, it’s pretty conclusive.</p>

<p>So how hard is it?  There are only a couple steps.  First, on any new
design, I start by instantiating my <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_master.v">AXI-lite master property set into the
design</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">faxil_master</span> <span class="p">#(</span>
		<span class="p">.</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">),</span>
		<span class="p">.</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="p">(</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="p">),</span>
		<span class="p">.</span><span class="n">F_OPT_ASSUME_RESET</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">),</span>
		<span class="p">.</span><span class="n">F_LGDEPTH</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="p">)</span>
	<span class="p">)</span> <span class="n">faxil</span><span class="p">(.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span> <span class="p">.</span><span class="n">i_axi_reset_n</span><span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_awready</span><span class="p">(</span><span class="n">M_AXI_AWREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awaddr</span><span class="p">(</span> <span class="n">M_AXI_AWADDR</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awcache</span><span class="p">(</span><span class="mh">4'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awprot</span><span class="p">(</span> <span class="n">M_AXI_AWPROT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awvalid</span><span class="p">(</span><span class="n">M_AXI_AWVALID</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_wready</span><span class="p">(</span><span class="n">M_AXI_WREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wdata</span><span class="p">(</span> <span class="n">M_AXI_WDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wstrb</span><span class="p">(</span> <span class="n">M_AXI_WSTRB</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wvalid</span><span class="p">(</span><span class="n">M_AXI_WVALID</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_bresp</span><span class="p">(</span> <span class="n">M_AXI_BRESP</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bvalid</span><span class="p">(</span><span class="n">M_AXI_BVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bready</span><span class="p">(</span><span class="n">M_AXI_BREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_arready</span><span class="p">(</span><span class="n">M_AXI_ARREADY</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_araddr</span><span class="p">(</span> <span class="n">M_AXI_ARADDR</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arcache</span><span class="p">(</span><span class="mh">4'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arprot</span><span class="p">(</span> <span class="n">M_AXI_ARPROT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arvalid</span><span class="p">(</span><span class="n">M_AXI_ARVALID</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_rresp</span><span class="p">(</span> <span class="n">M_AXI_RRESP</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rvalid</span><span class="p">(</span><span class="n">M_AXI_RVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rdata</span><span class="p">(</span> <span class="n">M_AXI_RDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rready</span><span class="p">(</span><span class="n">M_AXI_RREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">f_axi_rd_outstanding</span><span class="p">(</span><span class="n">faxil_rd_outstanding</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_axi_wr_outstanding</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_axi_awr_outstanding</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span><span class="p">));</span></code></pre></figure>

<p>I’ll then create a <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/bench/formal/axilops.sby">SymbiYosys script
file</a>.
These files are pretty basic, enough so that I now have a script to handle
generating just about all but three lines of the file.  At this point, I’ll
run the design and often find any bugs.</p>

<p>This design is almost that simple.  In this case, I also need to incorporate
a <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/bench/formal/fmem.v">CPU interface property
file</a> as
well, but we’ll get to that part in the next section.</p>

<p>At this point, SymbiYosys will either return a bug in 20 clock cycles in about
5 seconds, or there will likely not be a bug in the design at all.  Sometimes
I’ll just run it for 40-50 cycles if I’m not sure–or longer, depending on my
patience level.</p>

<p>Once I get that far, most of the bugs in the design are gone.</p>

<p>Perhaps I’m a bit of a perfectionist, but this is rarely enough for me.
I like to go further and verify these same properties for all time via
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.
This, to me, is just a <a href="/formal/2020/06/12/four-keys.html">part of being
complete</a>.</p>

<p>So let’s spend some time working through some properties we might use to
guarantee that this design passes an
<a href="/blog/2018/03/10/induction-exercise.html">induction</a> check.</p>

<p>In the case of the AXI-lite bus, this primarily consists of constraining the
three counters: <code class="language-plaintext highlighter-rouge">faxil_awr_outstanding</code>, <code class="language-plaintext highlighter-rouge">faxil_wr_outstanding</code>, and
<code class="language-plaintext highlighter-rouge">faxil_rd_outstanding</code>.  We’ll go a bit farther here, and constrain some of our
internal signals as well.</p>

<p>For example, if we are ever in a <code class="language-plaintext highlighter-rouge">misaligned_request</code>, then either <code class="language-plaintext highlighter-rouge">WVALID</code>
or <code class="language-plaintext highlighter-rouge">ARVALID</code> should be set since this is our signal that we are in the first
of two request cycles.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">misaligned_request</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">||</span> <span class="n">M_AXI_ARVALID</span><span class="p">);</span></code></pre></figure>

<p>Similarly, if <code class="language-plaintext highlighter-rouge">misaligned_aw_request</code> is ever true, then we are in the first
of two <code class="language-plaintext highlighter-rouge">AWVALID</code> cycles.  That means <code class="language-plaintext highlighter-rouge">M_AXI_AWVALID</code> had better be true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">misaligned_aw_request</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">M_AXI_AWVALID</span><span class="p">);</span></code></pre></figure>

<p>If no misaligned responses are pending, then we should be able to at least
limit the number of outstanding items.  If any of the request lines, whether
<code class="language-plaintext highlighter-rouge">M_AXI_AWVALID</code>, <code class="language-plaintext highlighter-rouge">M_AXI_WVALID</code>, or <code class="language-plaintext highlighter-rouge">M_AXI_ARVALID</code> are true, then, since
there’s no misaligned responses pending, there must be nothing outstanding.
In all other cases, with no misaligned responses pending the number of
outstanding items must be less than one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">misaligned_response_pending</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span>  <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">faxil_rd_outstanding</span>  <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_ARVALID</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span></code></pre></figure>

<p>Inequality constraints like this aren’t usually very effective, but they’re
often where I’ll start a proof.  Over time, I usually turn these inequalities
into exact descriptions–although I didn’t do so for <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">this
design</a>.
Indeed, this particular proof is unusual in that the
inequalities above are still important parts of my proof.  (If I remove them,
the proof fails …)</p>

<p>Of course, if there are no misaligned responses pending, then there can’t be
any misaligned requests.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">misaligned_request</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">misaligned_aw_request</span><span class="p">);</span></code></pre></figure>

<p>On the other hand, if a misaligned response is pending, and we are in a read
cycle, then the <code class="language-plaintext highlighter-rouge">misaligned_read</code> signal should be true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_RREADY</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">misaligned_read</span><span class="p">);</span></code></pre></figure>

<p>Now let’s turn our attention to flags specific to read cycles.</p>

<p>For example, if we aren’t in a read cycle then <code class="language-plaintext highlighter-rouge">ARVALID</code>, <code class="language-plaintext highlighter-rouge">misaligned_read</code>,
and the number of outstanding read requests should all be zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_RREADY</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARVALID</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">faxil_rd_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">misaligned_read</span> <span class="o">==</span> <span class="mb">1'b0</span><span class="p">);</span></code></pre></figure>

<p>On the other hand, if this is a read request then this can only be a misaligned
request if nothing else is outstanding.  After that, we do our best come up
with the correct read count.  (It’s still an inequality, but it’s enough …)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">misaligned_request</span><span class="p">)</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_rd_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">faxil_rd_outstanding</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">misaligned_read</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span>
		<span class="k">end</span></code></pre></figure>

<p>Let’s now turn our attention to write signals.  If we aren’t in the middle of
a write cycle, then the write signals should all be zero.  There should be
no writes outstanding, nor any being requested.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_BREADY</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">M_AXI_AWVALID</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WVALID</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span>  <span class="o">==</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>On the other hand, if we are within a write cycle, then what conclusions can
we draw?  If we are still within a request, then the number of outstanding
items must be zero.  Likewise, we will only ever have at most two requests
outstanding at a time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">misaligned_request</span><span class="p">)</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">misaligned_aw_request</span><span class="p">)</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">);</span></code></pre></figure>

<p>But once I got this far, I punted.
I just wasn’t certain how to constrain the write counters.
So, I fell back on an old trick I’ve come across: the case statement.  Using a
case statement, I can often work my way through all the possibilities of
something.  A case statement also forces me to think about each of the
possibilities of something happening individual.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">case</span><span class="p">(</span><span class="o">{</span><span class="n">misaligned_request</span><span class="p">,</span>
					<span class="n">misaligned_aw_request</span><span class="p">,</span>
					<span class="n">misaligned_response_pending</span><span class="o">}</span><span class="p">)</span>
			<span class="mb">3'b000</span><span class="o">:</span> <span class="k">begin</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span><span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span>
				<span class="k">end</span>
			<span class="mb">3'b001</span><span class="o">:</span> <span class="k">begin</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span><span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
				<span class="k">end</span>
			<span class="mb">3'b010</span><span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="mb">3'b011</span><span class="o">:</span> <span class="k">begin</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span><span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">M_AXI_AWVALID</span><span class="p">);</span>
				<span class="k">end</span>
			<span class="mb">3'b100</span><span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="mb">3'b101</span><span class="o">:</span> <span class="k">begin</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span><span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">));</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">M_AXI_WVALID</span><span class="p">);</span>
				<span class="k">end</span>
			<span class="mb">3'b110</span><span class="o">:</span> <span class="k">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="mb">3'b111</span><span class="o">:</span> <span class="k">begin</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">M_AXI_AWVALID</span><span class="p">);</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">M_AXI_WVALID</span><span class="p">);</span>
				<span class="k">end</span>
			<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
			<span class="k">endcase</span>
		<span class="k">end</span></code></pre></figure>

<p>As I’ve mentioned before on this blog, don’t worry about creating too many
assertions.  If you do, the worst that will happen is that there will be a
minor performance penalty–assuming that you have valid assertions.  If you
assert something that isn’t true, the formal tool will catch it, and you’ll
be patiently corrected.  Indeed, there’s no way through creating too many
assertions to get a design to pass an assertion that isn’t so.  The problem
isn’t usually too many assertions, rather it is not having enough assertions.</p>

<p>Moving on, and perhaps I should’ve asserted this earlier, we can either be in
a write cycle, a read cycle, or no cycle.  There should never be a time when
both <code class="language-plaintext highlighter-rouge">M_AXI_BREADY</code> and <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code> are true together.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Rule: Only one of the two xREADY's may be valid, never both</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">M_AXI_BREADY</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_RREADY</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Let’s put a quick constraint on <code class="language-plaintext highlighter-rouge">r_flushing</code>: if we aren’t <em>busy</em>, then we
shouldn’t be flushing any responses.  Since we’ve constrained <code class="language-plaintext highlighter-rouge">o_busy</code>
to only ever be true if either <code class="language-plaintext highlighter-rouge">M_AXI_BREADY</code> or <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code>, this also
effectively forces <code class="language-plaintext highlighter-rouge">r_flushing</code> to zero if nothing is outstanding and none
of the <code class="language-plaintext highlighter-rouge">AxVALID</code> or <code class="language-plaintext highlighter-rouge">WVALID</code> requests lines are active.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_busy</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">r_flushing</span><span class="p">);</span></code></pre></figure>

<p>When putting <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">this
core</a>
together, I made some of the signals combinatorial.  One example is <code class="language-plaintext highlighter-rouge">o_busy</code>,
which is set if either <code class="language-plaintext highlighter-rouge">M_AXI_BREADY</code> or <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code>
are true.  I may wish to come back later and adjust this design so that
<code class="language-plaintext highlighter-rouge">o_busy</code> is registered.  Indeed, this sort of task is common enough that it
forms the basis for a project I often use in my <a href="/tutorial/formal.html">formal
courseware</a>: given a working
design, with a working set of constraints, adjust a combinatorial value so
that it is now registered, and then prove that the design still works.  In
order to support this possibility later, I’ve included the combinatorial
descriptions of <code class="language-plaintext highlighter-rouge">o_busy</code> and <code class="language-plaintext highlighter-rouge">o_rdbusy</code> among my formal property set.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_busy</span> <span class="o">==</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span> <span class="o">||</span> <span class="n">M_AXI_RREADY</span><span class="p">));</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_rdbusy</span> <span class="o">==</span> <span class="p">(</span><span class="n">M_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r_flushing</span><span class="p">));</span></code></pre></figure>

<p>In general, I like to have one or more constraints forcing every register into
their correct setting with everything else.  Here, we constrain <code class="language-plaintext highlighter-rouge">pending_err</code>:
If we are busy, and there’s a misaligned response pending, then we haven’t
yet gotten our first response back in return.  Therefore, if we haven’t gotten
our first of the two responses back, <code class="language-plaintext highlighter-rouge">pending_err</code> should be zero.  It
shouldn’t get set until and unless one of our return responses comes back
in error.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_busy</span> <span class="o">&amp;&amp;</span> <span class="n">misaligned_response_pending</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">pending_err</span><span class="p">);</span></code></pre></figure>

<p>While I have more assertions in this section of <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">the
design</a>,
that’s probably enough to convince you that I’ve fully constrained the
various <code class="language-plaintext highlighter-rouge">faxil_*_outstanding</code> counters to the internal state of the design.</p>

<p>What we haven’t done yet, however, is constrain the other half of the design:
the CPU interface.  Let’s do that next.</p>

<h3 id="cpu-interface-1">CPU Interface</h3>

<p>One of the challenges associated with blindly attempting to formally verify
an AXI design you’ve never seen before is that many AXI designs, like this
one, are effectively bridges.  That means they have two or more interfaces to
them.  An <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">interface property
file</a>
will only provide you with instant properties for one of those interfaces.
You’ll still need to constrain the other interface.</p>

<table align="center" style="float: right"><caption>Fig 14. Bridges require two interfaces to be constrained</caption><tr><td><img src="/img/axilops/bridge-constraints.svg" alt="" width="460" />&lt;/A&gt;</td></tr></table>

<p>In the case of the
<a href="/about/zipcpu.html">ZipCPU</a>,
there are two interfaces to memory.  The
<a href="/about/zipcpu.html">ZipCPU</a>, also has many memory interface
implementations split across the two categories: instruction and data.
When it comes to instruction fetching, the
<a href="/about/zipcpu.html">ZipCPU</a>,
has a <a href="/zipcpu/2017/11/18/wb-prefetch.html">very simple and basic single instruction
fetch</a>, as well as a <a href="/zipcpu/2018/03/21/dblfetch.html">two
instruction pipeline fetch</a>
and an <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/pfcache.v">instruction fetch and
cache</a>.  In
a similar vein, the <a href="/about/zipcpu.html">ZipCPU</a>
has three basic
data interfaces: a <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/memops.v">basic single load or store
interface</a>, <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/pipemem.v">a
pipelined memory
controller</a>, and a
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/dcache.v">data cache</a>.  These
three categories have served the <a href="/about/zipcpu.html">ZipCPU</a>
well, allowing me to easily adjust the CPU to fit in smaller spaces, or to
use more logic in order to run faster in larger spaces.</p>

<p>Those original interfaces, however, are also all
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> interfaces.</p>

<p>When it came time to build an AXI interface, I stepped back to rethink
my verification approach.  The problem with each of those prior
memory controllers was that they each had their own assumptions about the
CPU within them.  When I then <a href="/blog/2018/04/02/formal-cpu-bugs.html">verified the
CPU</a>, I switched those
assumptions to assertions, but otherwise
<a href="/blog/2018/04/02/formal-cpu-bugs.html">verified the CPU</a>
with the memory interfaces intact within it.  The consequence of this approach
was that I needed to re-verify the CPU with every possible data interface it
might have.</p>

<p>This seemed rather painful, so I separated the instruction and data interface
assumptions from their respective controllers into one of two property files:
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/bench/formal/ffetch.v">one for the instruction
interface</a>,and <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/bench/formal/fmem.v">another for the data
interface</a>.
The property files therefore describe a contract between the
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/zipcore.v">CPU core</a> and
the instruction and data interfaces.  Anything the
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/zipcore.v">CPU core</a>
needs to assume
about those interfaces gets asserted when verifying the interface, or
assumed when verifying the CPU.  By capturing this contract into one place,
verifying new interfaces has become much easier.</p>

<p>All of the former
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
memory interfaces have now been re-verified using one of these two property
sets as appropriate.</p>

<p>Not only that, but now the
<a href="/about/zipcpu.html">ZipCPU</a>
has new AXI interfaces.  There’s an <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilfetch.v">AXI-lite
instruction fetch</a>
module that can 1) handle one outstanding transaction, 2) two outstanding
instruction fetch bus transactions, or even 3) an arbitrary number of
outstanding instruction fetch transactions.  I’ve also rebuilt the
<a href="/about/zipcpu.html">ZipCPU</a>’s <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axiicache.v">prefetch and instruction
cache</a>.
One neat feature about these new AXI or AXI-lite interfaces is that they are
all parameterized by
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
width.  That means that I won’t need to slow a 64-bit memory
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
down to a 32-bit width for the CPU anymore.</p>

<p>It’s not just instruction fetch interfaces, either.  This approach has made it
easy to build data interfaces in the same way.</p>

<p>For now, let’s take a look at how easy it is to use this new interface.</p>

<p>The first step is to declare some signal wires to be shared between the
memory module and the interface property set.  These extra (formal verification
only) signals are:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cpu_outstanding</code>: A count of how many requests the CPU thinks the memory is
working on.  This count will get cleared on a CPU reset, <code class="language-plaintext highlighter-rouge">i_cpu_reset</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">f_done</code>: This signal is generated by the memory controller to tell the
property set that an operation has completed–whether read or write.
Normally, something like this would be part of the interface between the
memory unit and the CPU, something like <code class="language-plaintext highlighter-rouge">o_valid</code> or <code class="language-plaintext highlighter-rouge">o_err</code> above.
However, there’s no means in this interface to announce the completion of
a write operation other than dropping <code class="language-plaintext highlighter-rouge">o_busy</code>, so <code class="language-plaintext highlighter-rouge">f_done</code> takes its
place.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">f_last_reg</code>: Is a copy of the last register target of any CPU load
operation.  This is important for the CPU pipeline, since there’s enough
room in the CPU pipeline to read into any register but the last one, and so
this last register needs to be tracked by the memory property set.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">f_addr_reg</code>: One of the rules of pipelined memory operations is that, in
any string of ongoing operations, they all need to use the same base address
register.  This keeps the CPU from needing to keep track of which
register will be written to by the operation.  In particular, the address
register shall not be written to by any operation–save perhaps the last one.
The CPU will insure this, by never issuing a read request into the address
register unless it waits for the memory controller to finish all of its
reads first.  The property set will accept this value as <code class="language-plaintext highlighter-rouge">f_areg</code>–again,
it’s not part of the CPU’s interface proper, so we just assume it’s presence
here.  The CPU will actually produce such a register, since it knows what it
is, and properties of that register will be asserted there–here they are
only assumed.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">f_pc</code>: This flag, returned from the memory property set, will be true if the
last read request is to read into either the program
counter or the condition codes, both of which might cause the CPU to branch.
Reads into the program counter or condition codes, if done at all, need to be
the last read in any string.  This return wire, from the property set,
helps to make sure that property is kept.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">f_gie</code>: The <a href="/about/zipcpu.html">ZipCPU</a>
has a lot of “GIE” flags all throughout it.  “GIE” in
this case stands for “Global Interrupt Enable”.  In supervisor mode, the
“GIE” bits are clear, whereas they are set in user mode–the only mode where
the <a href="/about/zipcpu.html">ZipCPU</a> can be interrupted.
These are also the most significant bit in any register address–since the
<a href="/about/zipcpu.html">ZipCPU</a> has one
register set for user mode (GIE=1) and one for supervisor mode (GIE=0).</p>

    <p>Any string of read (or write) operations must have the same GIE bit, so this
flag captures what that bit is.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">f_read_cycle</code>: This value, returned by the interface property set,
just keeps track of if we are in a read cycle vs a write cycle.  To avoid
hazards, the <a href="/about/zipcpu.html">ZipCPU</a> will only ever
do reads or writes–never both at the same time.  Knowing this value helps
keep track of what types of request are currently outstanding, so we can
make sure we don’t switch cycles.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">f_axi_write_cycle</code>: This one won’t get used below.  It’s a new one I had
to create to support exclusive access when using AXI.</p>

    <p>First, a brief overview of how AXI exclusive access works
when using the <a href="/about/zipcpu.html">ZipCPU</a>:
the CPU must first issues a <code class="language-plaintext highlighter-rouge">LOCK</code> instruction, and then a load instruction
of some size.  This load is treated as an AXI exclusive access read, so
<code class="language-plaintext highlighter-rouge">M_AXI_ARLOCK</code> will be set.  If the read comes back as <code class="language-plaintext highlighter-rouge">OKAY</code>, rather than
<code class="language-plaintext highlighter-rouge">EXOKAY</code>, a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> is returned to the CPU
indicating that the memory doesn’t support exclusive access.  Otherwise, an
ALU operation may (optionally) take place followed by a store instruction.  If
the store instruction fails, that is if the result is <code class="language-plaintext highlighter-rouge">OKAY</code> rather than
<code class="language-plaintext highlighter-rouge">EXOKAY</code> in spite of receiving the <code class="language-plaintext highlighter-rouge">EXOKAY</code> result from the previous read
access, than the memory controller returns a read result.  (From a write
operation?  Yes!)  That read result writes into the program counter a jump
back to the original LOCK instruction to start over.</p>

    <p>For this reason, an AXI exclusive access store instruction is the only
type of write instruction that will set <code class="language-plaintext highlighter-rouge">o_rdbusy</code>.</p>

    <p>That’s a long story, just to explain why this flag is necessary–to
explain why <code class="language-plaintext highlighter-rouge">o_rdbusy</code> might be set on a store instruction, and to help
guarantee that the result (if any) will either be written to the program
counter or quietly ignored if the write was successful.</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">cpu_outstanding</span><span class="p">;</span>
	<span class="kt">reg</span>		<span class="n">f_done</span><span class="p">;</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_last_reg</span><span class="p">,</span> <span class="n">f_addr_reg</span><span class="p">;</span>
	<span class="p">(</span><span class="o">*</span> <span class="n">anyseq</span> <span class="o">*</span><span class="p">)</span> <span class="kt">reg</span> <span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_areg</span><span class="p">;</span>
	<span class="kt">wire</span>		<span class="n">f_read_cycle</span><span class="p">,</span> <span class="n">f_pc</span><span class="p">,</span> <span class="n">f_gie</span><span class="p">;</span></code></pre></figure>

<p>One last step before instantiating this property set is to create the <code class="language-plaintext highlighter-rouge">f_done</code>
signal.  For this AXI interface, that’s pretty easy.  An operation is done
when we receive the <code class="language-plaintext highlighter-rouge">M_AXI_BVALID</code> or <code class="language-plaintext highlighter-rouge">M_AXI_RVALID</code> signal–with a couple
of exceptions.  We’re not done if a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> will be produced.
That’s another, separate, signal.  Neither are we done if there’s a pending
error, if this is the first of two responses, or if we are flushing requests
that a recently reset CPU wouldn’t know about.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_done</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="n">r_flushing</span> <span class="o">||</span> <span class="n">i_cpu_reset</span><span class="p">)</span>
		<span class="n">f_done</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">f_done</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_RRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="o">||</span> <span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_BRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pending_err</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">misaligned_response_pending</span><span class="p">;</span></code></pre></figure>

<p>Still, it’s not much more complicated than anything we’ve already done.</p>

<p>With that out of the way, we can simply instantiate the <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/bench/formal/fmem.v">formal memory property
interface</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">fmem</span>
	<span class="n">fcheck</span><span class="p">(</span>
		<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_bus_reset</span><span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_cpu_reset</span><span class="p">(</span><span class="n">i_cpu_reset</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_stb</span><span class="p">(</span><span class="n">i_stb</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_pipe_stalled</span><span class="p">(</span><span class="n">o_busy</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_clear_cache</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_lock</span><span class="p">(</span><span class="n">i_lock</span><span class="p">),</span> <span class="p">.</span><span class="n">i_op</span><span class="p">(</span><span class="n">i_op</span><span class="p">),</span> <span class="p">.</span><span class="n">i_addr</span><span class="p">(</span><span class="n">i_addr</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_data</span><span class="p">(</span><span class="n">i_data</span><span class="p">),</span> <span class="p">.</span><span class="n">i_oreg</span><span class="p">(</span><span class="n">i_oreg</span><span class="p">),</span> <span class="p">.</span><span class="n">i_busy</span><span class="p">(</span><span class="n">o_busy</span><span class="p">),</span>
			<span class="p">.</span><span class="n">i_areg</span><span class="p">(</span><span class="n">f_areg</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_rdbusy</span><span class="p">(</span><span class="n">o_rdbusy</span><span class="p">),</span> <span class="p">.</span><span class="n">i_valid</span><span class="p">(</span><span class="n">o_valid</span><span class="p">),</span> <span class="p">.</span><span class="n">i_done</span><span class="p">(</span><span class="n">f_done</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_err</span><span class="p">(</span><span class="n">o_err</span><span class="p">),</span> <span class="p">.</span><span class="n">i_wreg</span><span class="p">(</span><span class="n">o_wreg</span><span class="p">),</span> <span class="p">.</span><span class="n">i_result</span><span class="p">(</span><span class="n">o_result</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_outstanding</span><span class="p">(</span><span class="n">cpu_outstanding</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_pc</span><span class="p">(</span><span class="n">f_pc</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_gie</span><span class="p">(</span><span class="n">f_gie</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_read_cycle</span><span class="p">(</span><span class="n">f_read_cycle</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_last_reg</span><span class="p">(</span><span class="n">f_last_reg</span><span class="p">),</span> <span class="p">.</span><span class="n">f_addr_reg</span><span class="p">(</span><span class="n">f_addr_reg</span><span class="p">)</span>
	<span class="p">);</span></code></pre></figure>

<p>Now, with all this background out of the way, we can finally verify <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">this
memory core</a>.
As I mentioned in the AXI-lite verification section above, if it weren’t
for wanting to pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
these two property sets alone might well be sufficient to verify
all but the data path through the logic.</p>

<p>How well does it work?  Well, typically the formal tool takes less than twenty
seconds to return any bugs.  Even better, it points me directly to the
property that failed, and the exact timestep where it failed.</p>

<p>That’s not something you’ll get from simulation.</p>

<p>However, since I like to verify a design using
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
as well, I’ll often want to add some more properties.</p>

<p>Our first additional property just asserts that if we are every <code class="language-plaintext highlighter-rouge">r_flushing</code>,
then the CPU should’ve have just be reset so it shouldn’t be expecting
anything more.  If we aren’t flushing, then either this design is busy, or
it is in the process of returning a result or an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> to the CPU.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r_flushing</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">cpu_outstanding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">else</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">cpu_outstanding</span> <span class="o">==</span> <span class="p">(</span><span class="n">o_busy</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
			<span class="o">+</span> <span class="p">((</span><span class="n">f_done</span> <span class="o">||</span> <span class="n">o_err</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span></code></pre></figure>

<p>If <code class="language-plaintext highlighter-rouge">f_pc</code> is ever set, then our one (and only) output must be to either
the program counter, <code class="language-plaintext highlighter-rouge">o_wreg[3:0] == 4'hf</code>, or the condition codes
register, <code class="language-plaintext highlighter-rouge">o_wreg[3:0] == 4'he</code>.  Otherwise, if <code class="language-plaintext highlighter-rouge">f_pc</code> is clear, then no
reads can read into either PC or CC registers.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_pc</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wreg</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mh">3'h7</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o_rdbusy</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wreg</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">3'h7</span><span class="p">);</span></code></pre></figure>

<p>If any items are outstanding, then <code class="language-plaintext highlighter-rouge">o_wreg</code> must match the last register
address requested.  Hence, following a load into <code class="language-plaintext highlighter-rouge">R0</code>, both <code class="language-plaintext highlighter-rouge">o_wreg</code> and
<code class="language-plaintext highlighter-rouge">f_last_reg</code> should both point to the register address of <code class="language-plaintext highlighter-rouge">R0</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu_outstanding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wreg</span> <span class="o">==</span> <span class="n">f_last_reg</span><span class="p">);</span></code></pre></figure>

<p>As long as we are busy, the high bit of the return register must match
<code class="language-plaintext highlighter-rouge">f_gie</code>.  This finishes our constraints upon all of the bits of <code class="language-plaintext highlighter-rouge">o_wreg</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_busy</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_wreg</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">f_gie</span><span class="p">);</span></code></pre></figure>

<p>As one last property, let’s make sure <code class="language-plaintext highlighter-rouge">f_read_cycle</code> matches our logic.
If <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code> is true, then we should be in a read cycle–unless we
are flushing things out of our pipeline following a CPU reset.  Similarly,
if <code class="language-plaintext highlighter-rouge">M_AXI_RREADY</code> is not true and <code class="language-plaintext highlighter-rouge">M_AXI_BREADY</code> is, then we should be in a
write cycle and so we can assert <code class="language-plaintext highlighter-rouge">!f_read_cycle</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_RREADY</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_read_cycle</span> <span class="o">||</span> <span class="n">r_flushing</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">f_read_cycle</span><span class="p">);</span></code></pre></figure>

<p>Notice how easy that was?  All we had to do was to tie a couple of return
wires from the <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/bench/formal/fmem.v">interface property
set</a>
together to the internal state of our design, and we then have all the
properties we need.</p>

<h3 id="cover-properties">Cover properties</h3>

<p>As a final step in this proof, I’d like to see how well it works.  For that,
let’s just create some quick counters and count the number of returns
we receive–both for writes and then again for reads.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">cvr_writes</span><span class="p">,</span> <span class="n">cvr_reads</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">cvr_writes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">cvr_writes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span><span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">misaligned_response_pending</span>  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cvr_writes</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
		<span class="n">cvr_writes</span> <span class="o">&lt;=</span> <span class="n">cvr_writes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">cvr_reads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">cvr_reads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">misaligned_response_pending</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cvr_reads</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
		<span class="n">cvr_reads</span> <span class="o">&lt;=</span> <span class="n">cvr_reads</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Once we have this count, a simple <code class="language-plaintext highlighter-rouge">cover</code> check can produce some very useful
and instructive traces.  Indeed, these traces will show how fast
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">this core</a>
can operate at it’s fastest speed.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_writes</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_reads</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">);</span></code></pre></figure>

<p>The traces themselves are shown in Figs. 10 and 11 above.  They show that
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">this core</a>
can only ever achieve a 33% throughput at best.</p>

<p>No, 33% is not great.  In fact, when you put 33% in context of the rest
of any surrounding system, as we did in Fig. 13 above, it’s downright
dismal performance.  However, all designs need to start somewhere, and in
many ways this is a minimally working AXI master memory controller design.</p>

<h2 id="conclusions">Conclusions</h2>

<p>This is now our third article on building AXI masters.  The <a href="/blog/2020/03/23/wbm2axisp.html">first article
discussed AXI masters in
general</a> followed by a
demonstration <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">Wishbone to AXI
bridge</a>.
The <a href="/blog/2020/06/16/axiaddr-limits.html">second article discussed several of the problems associated with getting
AXI bursts working properly, and why they are so
challenging</a>.
This one returns to the simple AXI-lite master protocol, while also illustrating
a working CPU memory interface.</p>

<p>As I’ve alluded to earlier, this is only the first of a set of three AXI
memory controllers for the <a href="/about/zipcpu.html">ZipCPU</a>:
This was the single access controller.  I’ve also built a <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilpipe.v">pipelined
controller</a>
which should get much better performance.  These are both AXI-lite designs.
<a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axilops.v">This particular
controller</a>
also has an <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/core/axiops.v">AXI (full) sister
core</a>,
implementing the same basic design while also supporting exclusive access.
My intent is to make a similar sister design to support pipelined access
and AXI locking as well, but I haven’t gotten that far yet.  I have gotten
far enough, though, to have ported my <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/dcache.v">basic Wishbone data
cache</a> to AXI.
While usable, that work isn’t quite done yet, since it doesn’t (yet) support
either pipelined memory access or locking, but it’s at least a <a href="https://github.com/ZipCPU/zipcpu/blob/zipcore/rtl/axidcache.v">data
cache implementation using
AXI</a> that should
be a step in the right direction.  (Remember, I tend to design things in
layers these days …)</p>

<p>Lord willing, I’d like to spend some time discussing AXI exclusive access
operations next.  I’ve recently modified my AXI property sets so that they
can handle verifying AXI designs with exclusive access, and I’ve also tested
the approach on an updated version of my <a href="/blog/2019/05/29/demoaxi.html">AXI (full) demonstration
slave</a>.  Sharing those updates
will be valuable, especially since neither Xilinx’s MIG-based DDR3 memory 
controller, nor their <a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_bram_ctrl/v4_0/pg078-axi-bram-ctrl.pdf">AXI block RAM
controller</a>
appear to support exclusive access at all.  (Remember, the
<a href="/about/zipcpu.html">ZipCPU</a> will return a
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> on any attempt at an exclusive
access operation on a memory that doesn’t support it, so having a supporting
memory is a minimum requirement for using this capability.) This can then be a
prelude to a companion article to this one, discussing how to modify this
controller so that it handles exclusive access requests in the future.</p>

<p>Let me also leave you with one last haunting thought: What would happen if,
during a misaligned read operation across two words, a write took place at the
same time?  That’ll be something to think about.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Whom shall he teach knowledge?  And whom shall he make to understand doctrine?  Them that are weaned from the milk, and drawn from the breasts.  For precept must be upon precept, precept upon precept; line upon line, line upon line; hear a little and there a little (Is 28:9-10)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
