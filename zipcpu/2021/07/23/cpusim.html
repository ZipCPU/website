<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>CPU based simulation, first thoughts</title>
  <meta name="description" content="I’m currently working on a building a basic memory controller.  It’s a bigproject, and a fairly fun one.  The controller handles multiple hardware datachanne...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2021/07/23/cpusim.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">CPU based simulation, first thoughts</h1>
    <p class="post-meta"><time datetime="2021-07-23T00:00:00-04:00" itemprop="datePublished">Jul 23, 2021</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I’m currently working on a building a basic memory controller.  It’s a big
project, and a fairly fun one.  The controller handles multiple hardware data
channels, has a scatter-gather DMA, and will (eventually) have full ECC
support.  The device type involved is rather complex, and so the specification
requires complicated instruction sequences to access it.</p>

<p>At issue is, how shall such a design be tested?</p>

<p>Those who have been reading this blog know that I am a strong supporter of
formal verification.  I’ve been known to try to formally verify everything
I can get my hands on, and again I’ve had fun doing this.  The obvious problem
with this approach is that the design as a whole is far too complicated
to fit into a formal solver.  So, instead, I’ve only formally verified
the parts and pieces.  The design as a whole still requires some amount
of verification that cannot be done formally.</p>

<p>So, I had a crazy thought: Why not verify the design by using a CPU within the
test environment?</p>

<h2 id="background">Background</h2>

<p>To understand what I’m proposing, let me share a bit of the project’s
background.  The first point is that I didn’t create it.  The project was given
to me to both maintain and upgrade.</p>

<table align="center" style="float: right"><caption>Fig 1. Traditional test bench structure</caption><tr><td><img src="/img/cpusim/verilogtb.svg" alt="" width="320" /></td></tr></table>

<p>As the design was given to me, the test bench had a fairly
traditional structure.  It had a Verilog test script that drove an AXI <a href="https://en.wikipedia.org/wiki/Bus_functional_model">Bus
Functional Model (BFM)</a>
sometimes called a Verification IP.  There were also models for the external
peripheral(s) the module under test needed to interact with, as well as a
separate AXI slave <a href="https://en.wikipedia.org/wiki/Bus_functional_model">BFM</a>
for the design to interact with as it might with a memory.</p>

<ul>
  <li>
    <p>The original test script contained about 1.2k lines of a Verilog test
script that referenced another file containing 7.5k Verilog lines of
non-synthesizable, test-bench tasks.
These tasks are essentially Verilog subroutines.  Unlike traditional Verilog
design, these tasks are written as sequential logic:  wait until this happens,
set these wires, wait two clock ticks, etc.  Because these tasks
are sequential in nature, they act more like software than they do hardware.</p>
  </li>
  <li>
    <p>The original test script depended upon a client-provided AXI VIP
module–shown as the AXI
<a href="https://en.wikipedia.org/wiki/Bus_functional_model">BFM</a>
in Fig. 1 above.  This module contained a set of Verilog tasks which could
be called to issue AXI requests to anywhere on the bus.</p>

    <p>We’ve already discussed on the problems with this kind of VIP module on the
blog.  Basically, the module can be used to create a form of scripted
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
test.  (Read this address, write that address, etc.)  Most
modules of this type set RREADY and BREADY to 1, so they’ll never test for
back pressure.  Further, because of the sequential nature of their design,
they’ll never issue concurrent read and write requests, or even multiple
subsequent burst requests.  This VIP was no different.  A full check can’t
really be done via
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
at all–but that really leads to another discussion for another day.</p>
  </li>
</ul>

<p>So, my thought was, why should I build my updated test bench in Verilog, only
to rebuild it later in C?  Why not build it in C in the first place?  I mean,
if I have to deliver a working software test bench to the customer, to include
sample C software demonstrating how well the design works, then wouldn’t it
make sense to do the job once and then only deliver the C code?</p>

<h2 id="preparation">Preparation</h2>

<table align="center" style="float: left; padding: 25px"><caption>Fig 2. The alternative: Using software to drive the test bench</caption><tr><td><img src="/img/cpusim/softwaretb.svg" alt="" width="320" /></td></tr></table>

<p>My first thought was that the obvious reason why you wouldn’t use a CPU, and
thus why you wouldn’t write your test bench in C, would be that you didn’t
have a CPU available to you.  However, in this case I came to this project
with a <a href="/about/zipcpu.html">ZipCPU</a>, an
<a href="/blog/2019/07/17/crossbar.html">AXI crossbar</a>, a
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">demonstration AXI (full)
design</a>
which could be <a href="https://github.com/ZipCPU/axidmacheck/blob/4e7923db87edee141b9f8164b9ab5d84c25d7abf/rtl/main.v#L1414-L1486">used to implement a AXI based block-RAM type
device</a>, and <a href="/blog/2020/06/16/axiaddr-limits.html">an
AXI DMA</a>.  All of these
together would make for a very comprehensive test bench environment.  Even
better, I reasoned, I could then port the entire test bench (sans external
peripheral models) to an FPGA to prove the design at a later time.</p>

<p>The only problem was that the
<a href="/about/zipcpu.html">ZipCPU</a> didn’t (originally)
support <a href="/formal/2019/05/13/axifull.html">AXI</a>.</p>

<p>So, the first step was to get the
<a href="/about/zipcpu.html">ZipCPU</a> to support
<a href="/formal/2019/05/13/axifull.html">AXI</a>.  As mentioned in
the <a href="/blog/2021/06/28/master-examples.html">example AXI4 master
article</a>, I now have
several versions of instruction and data interfaces.  The debug interface has
also gotten a significant upgrade in the process.  Once done, however,
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> did a nice job of connecting
everything together.</p>

<p>Perhaps some of you can guess what happened next.  None of what followed
should really come as a surprise to anyone.  However, I still found the
entire exercise very instructive.</p>

<h2 id="observations">Observations</h2>

<p>Yes, I decided to try this approach.  Why not?  I had all the pieces I needed,
and it seemed like the right thing to do.</p>

<p>Here are some of the things I learned along the way.  We’ll call these some
of the <em>observations</em> that I made.</p>

<ul>
  <li>
    <p>First and foremost, you’ve never wanted to optimize a piece of code
more than when running it from within a
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
environment.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">printf()</code> is a very convenient way of outputting characters.  Actual
output can be done via the Verilog <code class="language-plaintext highlighter-rouge">$write()</code> command or a UART, but
<code class="language-plaintext highlighter-rouge">printf()</code> can handle a lot of formatting requirements.  (So, too, can
<code class="language-plaintext highlighter-rouge">$display()</code> …)</p>

    <p>However, what you may not expect is that you are paying for
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
time while simulating the standard library call to <code class="language-plaintext highlighter-rouge">printf()</code>, and
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
is not necessarily cheap.</p>
  </li>
  <li>
    <p>Did I mention that the design spends a lot of
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
time in the C library?</p>
  </li>
  <li>
    <p>At one point, I tried using the <code class="language-plaintext highlighter-rouge">rand()</code> function to generate random test
data, and I generated a new random data set for each test.</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span></code></pre></figure>

<p>At 3ms of simulated time, I quickly discovered that was a non-starter.</p>

<p>So, I rewrote the routine to use the
<a href="/about/zipcpu.html">ZipCPU</a>’s shift and carry facility.
Specifically, when the <a href="/about/zipcpu.html">ZipCPU</a>
executes a shift instruction, like the logical shift right (<code class="language-plaintext highlighter-rouge">LSR</code>) instruction
below, the last bit shifted is placed into the carry flag.  This means that
a second, conditional, <a href="https://en.wikipedia.org/wiki/Exclusive_or">exclusive OR (<code class="language-plaintext highlighter-rouge">XOR</code>)
instruction</a> can make a nicely
implemented <a href="/dsp/2017/10/27/lfsr.html">Galois linear feedback shift
register</a>: shift right, and
if the bit shifted out is a one then <a href="https://en.wikipedia.org/wiki/Exclusive_or">exclusive
OR</a> the result with the new
shift register value–called <code class="language-plaintext highlighter-rouge">fill</code> below.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define	STEP(F, T)	asm("LSR 1,%0\n\tXOR.C %1,%0" : "+r"(F) : "r"(T))
</span>	<span class="kt">unsigned</span>	<span class="n">fill</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">TAPS</span> <span class="o">=</span> <span class="mh">0x485b5</span><span class="p">;</span>
	<span class="c1">// char * buf;</span>

	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">STEP</span><span class="p">(</span><span class="n">fill</span><span class="p">,</span> <span class="n">TAPS</span><span class="p">);</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>Even this was too slow.</p>

<p>However, when I unrolled the loop so that it filled up two words at a time,
instead of eight separate bus writes, then things dropped down to 1.6ms.</p>

<p>Still too long.</p>

<p>Then I reasoned I could just re-use this data set for each of my tests–and
that seemed to speed things up enough to be bearable.</p>

<table align="center" style="float: right"><caption>Fig 3. Pond scum is known for moving faster than simulated serial ports</caption><tr><td><img src="/img/cpusim/pond-scum-sm.jpg" alt="" width="384" /></td></tr></table>

<ul>
  <li>
    <p>Simulated UARTs are slower than molasses in the winter time.  I think I’ve
even seen faster moving pond scum.  My original UART speed was 1MBaud.  In
the end I bumped that up to 10MBaud and the UART interface still felt slow.</p>
  </li>
  <li>
    <p>Increasing the serial port buffer size from 16-bytes to 256 bytes helped as
well.  This kept the CPU from spending its time polling for a space to be
available in the serial port’s buffer.</p>
  </li>
  <li>
    <p>Buffering UART requests means there’s a huge lag between the request to write
to the UART and the actual UART output.  The design can fail or even complete
during this time–before the UART output is completed.  As a result, the
last line from my
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
often read <code class="language-plaintext highlighter-rouge">haltSimulation complete</code>, instead of the two lines starting
with <code class="language-plaintext highlighter-rouge">halting</code> from the CPU and then <code class="language-plaintext highlighter-rouge">Simulation complete</code> from the simulator.</p>
  </li>
  <li>
    <p>When I first started with this design setup, the CPU was spending a lot of
timing fetching instructions from the bus.  Increasing the cache size to
something ridiculously large, such as 256kB for the instruction cache and
another 256kB for the data cache, helped.</p>
  </li>
  <li>
    <p>The <a href="/about/zipcpu.html">ZipCPU</a> is big
<a href="https://en.wikipedia.org/wiki/Endianness">endian</a>.  The
AXI4 bus (and everything on it) is little
<a href="https://en.wikipedia.org/wiki/Endianness">endian</a>.  Swapping
<a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> in
seems like a waste of precious time.
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a></p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span>
<span class="nf">byteswapln</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ln</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">while</span><span class="p">(</span><span class="n">ln</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">register</span>	<span class="kt">uint8_t</span>	<span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">;</span>

		<span class="n">a</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

		<span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
		<span class="n">dst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">dst</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">dst</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

		<span class="n">src</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dst</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">ln</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Rewriting this function in assembly helped, since GCC doesn’t (yet) do a good
job of exploiting the <a href="/about/zipcpu.html">ZipCPU</a>’s
pipelined memory features.</p>

<ul>
  <li>
    <p><a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
variables associated with the external C++ device model aren’t
automatically captured in the trace.  This made it a challenge, at times,
to debug why the model didn’t do what you wanted.  There was a <a href="/blog/2017/07/31/vcd.html">VCD trace
file</a> and two debug-by-printf
dumps: one from the simulated <a href="/about/zipcpu.html">ZipCPU</a>
and another from the host.  It took work to synchronize those three traces
to discover what was going on.</p>

    <p>On other designs I’ve created design inputs and filled them with the state
from the external model.  I could’ve done that here, and might’ve, if this
had turned out to be any harder than it was.</p>
  </li>
  <li>
    <p>The larger the CPU stack size becomes, the slower the CPU gets.</p>

    <p>This was not one I was expecting, although perhaps I should’ve expected
this–since I was the one who wrote the
<a href="/about/zipcpu.html">ZipCPU</a>’s GCC back end and I seem
to recall implementing this “feature”.</p>

    <p>The root of the problem stemmed from placing a large 8kB page buffer on
the stack.  This plus a couple other registers forced the stack size to be
larger than the <a href="/about/zipcpu.html">ZipCPU</a>’s
maximum load register offset of fourteen signed bits, or -8192, … 8191.
GCC then turned commands to move data from the stack to a register into the
instruction sequence:</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	LDI	#Offset, R0
	ADD	R12,R0
	LW	(R0),Rx</code></pre></figure>

<p>instead of the desired</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	LW	#Offset+R12,Rx</code></pre></figure>

<p>Moving the data buffer off the stack and into global memory helped–since
all accesses were then based upon shorter offsets from a buffer pointer
rather than large offsets of the frame pointer.</p>

<ul>
  <li>
    <p>The Bible can make a useful (and fun) data source.  If you are staring at
data coming across your screen, it’s more enjoyable to stare at a Bible
passage than raw hex or anything else for that matter.  Of course, this does
have the draw back that a Bible passage isn’t necessary a full and complete
test suite, since it tends not to test bit 7–but the separate random data
check discussed above and below helped to mitigate this issue.</p>
  </li>
  <li>
    <p>Generating a <a href="/blog/2017/07/31/vcd.html">VCD file</a> can
really slow down the
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
A <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilgpio.v">simple GPIO
peripheral</a>,
however, can be useful for intelligently controlling (based upon circumstances
within the design) whether or not trace recording is enabled in
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>.
With only a minor change to the C++ test script, turning on the
trace can then become as simple as the C statement:</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="n">_axilgpio</span><span class="o">-&gt;</span><span class="n">g_set</span> <span class="o">=</span> <span class="n">SET_TRACE</span><span class="p">;</span></code></pre></figure>

<p>Eventually, I got in the habit of something like:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">	<span class="k">if</span> <span class="p">(</span><span class="n">error_condition</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Something bad happened.</span>

		<span class="c1">// If the trace hasn't (yet) been turned on, turn it on now.</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">_axilgpio</span><span class="o">-&gt;</span><span class="n">g_set</span> <span class="o">&amp;</span> <span class="n">SET_TRACE</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">_axilgpio</span><span class="o">-&gt;</span><span class="n">g_set</span> <span class="o">=</span> <span class="n">SET_TRACE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="c1">// Otherwise this has been captured in a trace, so we</span>
			<span class="c1">// can exit the simulation now with a failure.</span>
			<span class="n">fail_simulation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">fail_simulation</code> variable above isn’t really anything special–it’s
just a C integer that’s then used to skip further testing.  Were this a
C++ test bench, it would’ve been implemented as a boolean.</p>

<ul>
  <li>
    <p>A <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">basic AXI DMA</a>
is vastly superior to
<a href="https://www.cplusplus.com/reference/cstring/memcpy/"><code class="language-plaintext highlighter-rouge">memcpy()</code></a>
when it comes to high speed data transfer.  Even better, the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">AXI DMA</a> helps
to test more of the designs AXI capabilities.</p>
  </li>
  <li>
    <p>Truly testing random data moving across an interface requires a bit of work
on both ends of the interface.  On one end, you’ll need a source of
pseudo-random data to push through the interface.  On the other end, you’ll
want to be able to compare the received results with the sent data.  In
whole, the test requirement looks something like Fig. 4 below.</p>

    <table align="center" style="float: none"><caption>Fig 4. Many tests require some form of memory comparison</caption><tr><td><img src="/img/cpusim/memcmp.svg" alt="" width="480" /></td></tr></table>

    <p>I’m not sure I have a good solution (yet) for this requirement.</p>

    <p>The requirement is easy enough to accomplish using
<a href="https://www.cplusplus.com/reference/cstring/memcmp/"><code class="language-plaintext highlighter-rouge">memcmp()</code></a>, but as I
noted above the <code class="language-plaintext highlighter-rouge">mem*()</code> functions can be notoriously slow and slow
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>s
are painful.  Something similar to an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">AXI
DMA</a> that
implements a <a href="https://www.cplusplus.com/reference/cstring/memcmp/"><code class="language-plaintext highlighter-rouge">memcmp()</code></a>
might be really useful here.  Perhaps a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">memory to stream (MM2S)
DMA</a>
could make this easier?</p>

    <table align="center" style="float: none"><caption>Fig 5. Here's what a hardware memory comparison might look like</caption><tr><td><img src="/img/cpusim/hwmemcmp.svg" alt="" width="560" /></td></tr></table>

    <p>For now, just keep your eyes peeled to the
<a href="https://github.com/ZipCPU/wb2axip">wb2axip</a> repo.  If I build such a hardware
<a href="https://www.cplusplus.com/reference/cstring/memcmp/"><code class="language-plaintext highlighter-rouge">memcmp()</code></a>, that’s
where I’d put it.  The basic design would likely follow Fig. 5 above, and
so it would be built around one (or two)
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">MM2S DMA</a>’s
followed by a stream comparison.</p>
  </li>
  <li>
    <p>A <a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
test bench script can quickly move from one bus request to the
next with no
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
time taken between the two requests.  The CPU, on
the other hand, needs to process instructions between bus requests.  This
will necessarily slow down any CPU based test when compared to its
Verilog counterpart.</p>
  </li>
</ul>

<p>I guess that’s the big bottom line here: although the CPU software based test
script leads to a more realistic test, it will always require more
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
cycles to accomplish.</p>

<h2 id="simple-changes">Simple changes:</h2>

<p>With some simple changes, many of these drawbacks became quite bearable.
Here are some more of the changes I made to get things working better.</p>

<ul>
  <li>
    <p>Boost the cache size.  I mentioned this above.  Basically, while you might
not be able to afford a 16kB cache in any real life FPGA, you can certainly
afford a 1MB cache in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
land.  Once the design ends up in actual hardware running at true hardware
speeds, then no one will notice that you went back to the smaller cache size.</p>
  </li>
  <li>
    <p>Rather than checking whether or not a byte can be output on every clock
CPU cycle, a quick fix to the
<a href="/about/zipcpu.html">ZipCPU</a>’s
newlib back end made it so that the device write command would first
check the serial port’s buffer availability, and then send that many
bytes to the serial port before going back to check on availability again.
I would’ve never noticed the impact of such a change had I not been running
the design in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
in the first place.</p>
  </li>
  <li>
    <p>Clock gating can speed up
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>s
… I think.  While clock gating is difficult to implement in an FPGA, it
is more common in ASIC designs.  Along the way, after a measurement or
two, I convinced myself that clock gating can speed up
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>s.</p>

    <table align="center" style="float: left; padding: 25px"><caption>Fig 6. Does clock gating speed up sim time?</caption><tr><td><img src="/img/cpusim/ckgate-comparison.svg" alt="" width="320" /></td></tr></table>

    <p>I was so excited about this technique that I started drafting an article
about how clock gating could be used to speed up
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
time.  To complete this article, and make my point about how awesome clock
gating was, I spent some time and made some measurements.  The
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
then ran five minutes slower with clock gating enabled.  Oops.</p>

    <p>What happened?  Well, I had upgraded
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
between the two tests.  Might this have affected things?</p>

    <p>Looking over
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>’s
documentation, I’ve since found some optimizations that might possibly speed
up designs when gated, so stay tuned.  I’m not convinced this is the end of
the story yet.</p>
  </li>
  <li>
    <p>A simple nonce at both the beginning and end of a test sequence can help make
it easier to verify, from a
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
<a href="/blog/2017/07/31/vcd.html">trace</a>,
that the first and last bytes were accurately communicated as desired.  In my
case, I replaced the first character of what would otherwise be a string of
<code class="language-plaintext highlighter-rouge">=</code> with a “0”, and the last character with a “Z”.  This left me with a test
set that started out reading:</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0==========================================================================+
|                                                                          |
|  Psalm 1                                                                 |
|                                                                          |
|  Blessed is the man that walketh not in the counsel of the ungodly, nor  |
|    standeth in the way of sinners, nor sitteth in the seat of the        |
|    scornful.                                                             |
|  But his delight is in the law of the LORD; and in his law doth he       |
|    meditate day and night.                                               |
|  And he shall be like a tree planted by the rivers of water, that        |
|    bringeth forth his fruit in his season; his leaf also shall not       |
|    wither; and whatsoever he doeth shall prosper.                        |
|  The ungodly are not so: but are like the chaff which the wind driveth   |
|    away.                                                                 |
|  Therefore the ungodly shall not stand in the judgment, nor sinners in   |
|    the congregation of the righteous.                                    |
|  For the LORD knoweth the way of the righteous: but the way of the       |
|   ungodly shall perish.                                                  |
|                                                                          |
============================================================================</code></pre></figure>

<p>Unfortunately, the block size was longer than the Psalm, so you don’t get to
see the “Z” in the output–even though it’s present in the <a href="/blog/2017/07/31/vcd.html">VCD
file</a>.</p>

<ul>
  <li>
    <p>When verifying whether bytes in a message have been gained or lost, it helps
to force every line to have the same length and end with the same character.
Missing or extra characters then stand out loudly.  Check out the
test sequence above, and ask what would happen if a space were skipped or
some other character inserted.  The lines at the edges of the message wouldn’t
line up.</p>
  </li>
  <li>
    <p>I was worried initially about how I might transition a design that requires
my <a href="/blog/2017/06/17/why-network-debugging.html">normal TCP/IP based serial
port</a>
to an all-Verilog simulation model that I might use with
<a href="http://iverilog.icarus.com">Icarus</a>,
<a href="https://www.cadence.com/en_US/home/tools/system-design-and-verification/simulation-and-testbench-verification/xcelium-simulator.html">XCellium</a>,
or some other commercial simulation tool.  An all-verilog
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
model was something my customer wanted, but not something I normally build
or use.  I eventually found out that I can incorporate Verilog’s <code class="language-plaintext highlighter-rouge">$write()</code>
command into my serial port controller to achieve a result that’s close
enough.</p>
  </li>
</ul>

<p>Realistically, the biggest changes came as a result of just staring at the
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
<a href="/blog/2017/07/31/vcd.html">traces</a> showing the
<a href="/about/zipcpu.html">ZipCPU</a> running software.  The more I
did so, the more obvious any slow software became, and therefore the more
I wanted to dig into the slow parts to speed them up.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In hind sight, this entire approach arguably violates a fundamental principle
of engineering: Tests should be accomplished by dividing the design into
components that are known to work and components that aren’t (necessarily)
known to work.  From there, you should only test one component at a time.</p>

<p>I say <em>arguably</em> because any test requires both trusted components and not
so trusted components.  The most obvious trusted component is the
simulator itself–in my case
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a> (so
far).  Likewise the most obvious untrusted component is the design or module
under test.  Other untrusted components tend to include the external device
module and the test script itself–whether written in C or Verilog.
This distinction is important, because it helps to reveal that the <em>module
under test</em> is never the only untrusted component in any design.  As a
result, we might argue to what extent the basic engineering principle applies
here.</p>

<p>This particular design approach treated certain pieces of the design, the
<a href="/about/zipcpu.html">ZipCPU</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">AXI DMA</a>, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demofull.v">RAM
model</a>, and
interconnect as <em>working</em> infrastructure pieces.  Indeed, in general, they did
“just work”, although the exercise began with a hiccup or two.  Remember, this
was only the <a href="/about/zipcpu.html">ZipCPU</a>’s second AXI
implementation (<a href="https://github.com/ZipCPU/axidmacheck/tree/zipcpu">here’s the
first</a>), and this was the
first design where the <a href="/about/zipcpu.html">ZipCPU</a>
ran from a 64-bit bus.  This design, therefore, also tested some new bus width
adjustment components
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilupsz.v">[1]</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilsub.v">[2]</a>.
Not only that, but the design also tested the
<a href="/about/zipcpu.html">ZipCPU</a>’s (new) clock gating
capability.  Much as one might expect, the first couple of tests weren’t
pretty.  For example, <a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> initially
got its <a href="https://github.com/ZipCPU/zipcpu/blob/0115687b43bcbdb5e88e4d1e458b69c992868c9b/rtl/core/iscachable.v#L54-L63">cachable address
markers</a>
off by 3-bits, and so even though the RAM was entirely cachable, very
few of the transactions were actually ending up in the <a href="https://github.com/ZipCPU/zipcpu/blob/0115687b43bcbdb5e88e4d1e458b69c992868c9b/rtl/core/axidcache.v#L323-L333">data
cache</a>.</p>

<p>The really big question of this whole exercise is, now that I’ve been through
it, whether or not I would do so again.  The answer to that question is: I’m
not sure.  Indeed, I’m now faced with a second, very similar project, and the
question before me today is whether or not I should write a Verilog test
script for it or just write the script in software as I did for this project.</p>

<p>We’ll see.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Confess your faults one to another, and pray one for another, that ye may be healed. The effectual fervent prayer of a righteous man availeth much. (James 5:16)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
