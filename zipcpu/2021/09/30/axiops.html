<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Upgrading the ZipCPU's memory unit from AXI4-lite to AXI4</title>
  <meta name="description" content="Some time ago, I presented a very simple AXI4-lite memorycontroller for theZipCPU.  At the time, I mentioned thatI also had a similar memory controller for A...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/zipcpu/2021/09/30/axiops.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Upgrading the ZipCPU's memory unit from AXI4-lite to AXI4</h1>
    <p class="post-meta"><time datetime="2021-09-30T00:00:00-04:00" itemprop="datePublished">Sep 30, 2021</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Some time ago, I presented a <a href="/zipcpu/2021/04/17/axilops.html">very simple AXI4-lite memory
controller</a> for the
<a href="/about/zipcpu.html">ZipCPU</a>.  At the time, I mentioned that
I also had a <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">similar memory controller for AXI4
(not-lite)</a>.
Today, let’s discuss the difference between these two controllers, to see how
AXI4 excels over AXI4-lite.  As you’ll see, a large focus of this discussion
will focus on the exclusive access capability specific to AXI4.</p>

<p>Perhaps you’ll remember the discussion of <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">today’s memory
controller</a>
from the article on <a href="/blog/2021/08/14/axiperf.html">measuring AXI4
performance</a>.  In that
article, we discussed and compared the performance of the various
<a href="/about/zipcpu.html">ZipCPU</a> memory controllers:</p>

<ol>
  <li>
    <p>The slowest memory controller in that test was the <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">basic, low-logic, memory
controller</a>
that we’ll be discussing today.</p>
  </li>
  <li>
    <p>I also tested a <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axipipe.v">pipelined memory controller</a>.
The claim to fame of this controller is that it will allow multiple requests
to be outstanding at a time.  The primary difference between
<a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axipipe.v">this pipelined controller</a>
and the <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">basic
controller</a> in today’s discussion is that the
<a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axipipe.v">pipelined controller</a>
contains a FIFO and some extra counters in order to keep track of the
outstanding transactions.  When running
<a href="https://en.wikipedia.org/wiki/Dhrystone">Dhrystone</a>, the
<a href="/about/zipcpu.html">ZipCPU</a> is about 9% faster when using
<a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axipipe.v">the pipelined controller</a>
rather than the <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">basic
controller</a>
we’ll be discussing today.</p>
  </li>
  <li>
    <p>I also presented an <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axidcache.v">AXI Data Cache based memory
controller</a>.  Despite being a very basic and simple
<a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axidcache.v">data cache implementation</a>,
the performance of a 4kB <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axidcache.v">data
cache</a>
still beat out <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">today’s basic controller</a> by 27%.
This should help illustrate one of the fundamental lessons of CPU logic
design: you can buy CPU speed with logic.</p>
  </li>
</ol>

<table align="center" style="float: right"><caption>Fig 1. Which board should I buy to study CPU design?</caption><tr><td><img src="/img/axiops/which-board.svg" alt="" width="480" /></td></tr></table>

<p>As I noted in <a href="https://github.com/ZipCPU/wb2axip/blob/master/doc/chexpo-2021.pdf">my recent briefing to ChipExpo
2021</a>, I
currently have no good AXI4 master for testing the
<a href="/blog/2019/04/27/axi-addr.html">AXI WRAP</a> capability of a
slave.  The natural master one might have for this would be a CPU cache
implementation, much like my <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axidcache.v">AXI data
cache</a>,
so you might see an upgrade in the near future so that it will support this
capability.</p>

<p>For now, however, I’d like to focus on the differences between the <a href="/zipcpu/2021/04/17/axilops.html">basic
AXI4-lite memory controller</a>
for the <a href="/about/zipcpu.html">ZipCPU</a> and its <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">AXI4 (not-lite)
counterpart</a>.
There are three big differences that we’ll discuss today, as well as two
features that I’d like to discuss because I didn’t end up using them.</p>

<ol>
  <li>
    <p>The big new feature from AXI4 over and above AXI4-lite is exclusive
access.  Exclusive access support is a required capability in order to
support
<a href="https://en.wikipedia.org/wiki/Linearizability">atomic actions</a> on a
busy <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>,
yet without bringing the other users of the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
to a halt.  This is something I haven’t really blogged about
before, so these changes should be interesting to discuss.</p>
  </li>
  <li>
    <p>One of the non-trivial differences in the upgrade from AXI4–lite to AXI4
was associated with setting the AxSIZE field.  This <em>should</em> have been
trivial.  Subtle requirements, both from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
and the CPU, guaranteed that this piece of the design was far from trivial,
and so I’d like to spend a moment discussing why the AxSIZE field was a
challenge.</p>
  </li>
  <li>
    <p>AXI offers two prominent features that I did not really use in my controller:
IDs and multibeat bursts via AxLEN.  The story of these two features, and
particularly why I didn’t use AxLEN to implement bursts, is important
for discussion.</p>
  </li>
  <li>
    <p>This still leaves us with a lot of unused features, so we’ll then quickly
drive those to default values in order to close out the differences between
the two designs.  That leaves only a small discussion at the end regarding
what default values should be chosen.</p>
  </li>
</ol>

<p>That’s our basic outline, so let’s go ahead and dive into the changes
required to add exclusive access to this design.</p>

<h2 id="exclusive-access">Exclusive Access</h2>

<p>The <a href="/about/zipcpu.html">ZipCPU</a> has a very simple exclusive access capability.  It’s one of the
few functionalities that require a multi-instruction sequence.</p>

<p>An <a href="https://en.wikipedia.org/wiki/Linearizability">atomic operation</a>
in the <a href="/about/zipcpu.html">ZipCPU</a> is a four instruction
sequence, starting with the <code class="language-plaintext highlighter-rouge">LOCK</code> instruction.  The other three instructions
are a load, an <a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
operation, and then a store instruction as shown in the following
pseudo-assembly:</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	LOCK
	LOAD	(Addr),Rdata	; Load something into Rdata
	ALU	Rx,Rdata	; Operate on Rdata
	STORE	Rdata,(Addr)	; Store the result in the original address</code></pre></figure>

<p>This format has been sufficient to implement a large number of
<a href="https://en.wikipedia.org/wiki/Linearizability">atomic operations</a>.
For example, an atomic increment can be written as,</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	LOCK
	LW	(R1),R2
	ADD	1,R2
	SW	R2,(R1)</code></pre></figure>

<p>Such an instruction sequence could easily form the basis of a
<a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a>
implementation.</p>

<p>A similar instruction sequence known as a
<a href="https://en.wikipedia.org/wiki/Test-and-set">test and set</a> can be written as,</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	LDI	1,R3
	LOCK
	LW	(R1),R2
	TEST	R2
	SW.Z	R3,(R1)</code></pre></figure>

<p>This operation reads a value from memory, checks to see if it is zero, and then
writes a one to the memory if it is.  This sequence is useful for seeing if
a resource is available, and then marking it as in use if it is.  The register
<code class="language-plaintext highlighter-rouge">R2</code> can then be checked to know if the resource was available.  Even better,
the result of this comparison has been conveniently left in the condition codes.</p>

<p>This is about as simple as it gets.</p>

<p>The actual implementation of this sequence is fairly simple as well–when
implemented in 
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.  Indeed,
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> exclusive
access is quite easy: just hold the CYC line high between the load and the
subsequent store, and nothing else will have access to that resource.</p>

<p>The <a href="/about/zipcpu.html">ZipCPU</a>
goes a bit further in its implementation: it guarantees that the
lock sequence will not be interrupted.  Therefore, even if the lock sequence
is executed from user mode (with interrupts enabled), the <code class="language-plaintext highlighter-rouge">LOCK</code> instruction
disables interrupts for the three instructions following.</p>

<p>This makes <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a>
memory access simple when using the
<a href="/about/zipcpu.html">ZipCPU</a>: the instruction sequence is
simplified, and the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> interaction
necessary to support it is also quite simple.</p>

<p>Mapping this simplicity into AXI4 was not nearly so easy.</p>

<p>AXI4 <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a>
access semantics are quite different.  AXI4, for example, doesn’t
allow you to lock the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
and keep other users from accessing memory (for example) during your operation.
Instead, AXI4 implements something called <em>exclusive access</em>.  Exclusive
access operations are described via a sequence of operations:</p>

<ol>
  <li>
    <p>First, the CPU issues an exclusive access read.  This is a read request
(a load instruction) from the CPU where <code class="language-plaintext highlighter-rouge">ARLOCK</code> is set.  When the slave
sees this request, it copies down the details of the request and returns
<code class="language-plaintext highlighter-rouge">RRESP=EXOKAY</code> when returning the request.</p>

    <p>If the slave doesn’t support exclusive access requests, then it simply
processes the read as normal and returns <code class="language-plaintext highlighter-rouge">RRESP=OKAY</code>.</p>
  </li>
  <li>
    <p>If the slave observes any subsequent writes to this address, it will
invalidate this lock.  Similarly, if the slave receives a subsequent
read request with <code class="language-plaintext highlighter-rouge">ARLOCK</code> set, the lock will move to a different address.</p>

    <p>On its face, this <a href="https://github.com/ZipCPU/wb2axip/blob/b3145001959c36a206a884243770be5c8c17e5da/rtl/demofull.v#L836-L965">forces the slave to track one exclusive access address
for every AxID value that it supports</a>.
Alternatively, the slave can monitor a single address and then keep track
of the AxID of the last exclusive access request together with the address
details of the request.</p>
  </li>
  <li>
    <p>Some time after the exclusive access read request, the CPU will issue the
subsequent write request.  This request <em>must</em> match the read request:
same address, same <code class="language-plaintext highlighter-rouge">AxLEN</code>, same <code class="language-plaintext highlighter-rouge">AxSIZE</code>, same <code class="language-plaintext highlighter-rouge">AxBURST</code>, etc.  The
slave will then compare these values to the values given by the last
exclusive access read request.</p>

    <ul>
      <li>
        <p>If the values match and nothing has been written to that address since the
read, then the request succeeds and the value is written to
memory.  This would be the case if nothing else had written to this
memory since the previous exclusive access read.  In this case, the
slave returns <code class="language-plaintext highlighter-rouge">BRESP=EXOKAY</code> to let the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> master know that the
operation has been successful.</p>
      </li>
      <li>
        <p>Alternatively, if the 1) values don’t match or 2) if something has written
to one of the addresses in the burst since the read, then the exclusive
access write request fails.  The slave then returns <code class="language-plaintext highlighter-rouge">BRESP=OKAY</code> <em>and
doesn’t update any memory</em>.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>The next step takes place in the CPU.  When the CPU sees the <code class="language-plaintext highlighter-rouge">BRESP=OKAY</code>,
rather than a <code class="language-plaintext highlighter-rouge">BRESP=EXOKAY</code> response, then it needs to repeat the
exclusive access request again and again until it succeeds.</p>
  </li>
</ol>

<p>Now, how should the <a href="/about/zipcpu.html">ZipCPU</a>
be modified to handle exclusive access?</p>

<p>A look at both ARM and Microblaze architectures didn’t help.  These
architectures both require an instruction sequence that’s closer tied to the
hardware than the <a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">ISA</a> allowed.
First, they require special exclusive access load and store instructions.
Following the exclusive access store instruction, the CPU must then check an
internal register flag to see if the operation was successful, and branch
if it was not.</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">	DMB ish			; Memory barrier
loop:
	LDREX	R2,[R3]		; Load w/ exclusive access
	ADD	R0,R2,R1	; An atomic add, R0 &lt;= R2 + R1
	STREX	R12,R0,[R3]	; Store the result, R0, with exclusive access
	CMP	R12,#0		; Check for the EXOKAY flag in R12
	BNE	loop		; Loop if the STREX didn't return EXOKAY
	DMB	ish		; Memory barrier</code></pre></figure>

<p>This requires both a longer instruction sequence, but also a more complex
instruction decoder and hence a larger bit field for the relevant opcode.</p>

<p>This was unacceptable for me: I wanted to keep the
<a href="/about/zipcpu.html">ZipCPU</a> simple.  For that reason, I
didn’t want to add any more instructions to the <a href="/zipcpu/2018/01/01/zipcpu-isa.html">ZipCPU’s instruction
set</a>, nor did I want to
support a different instruction sequence, additional special registers,
or special register fields.</p>

<p>This lead me to design a solution based upon the state diagram in Fig. 2 below.</p>

<table align="center" style="float: none"><caption>Fig 2. ZipCPU's exclusive access state machine</caption><tr><td><img src="/img/axiops/exaccess-fsm.svg" alt="" width="760" /></td></tr></table>

<p>Here’s how it works in detail:</p>

<ol>
  <li>
    <p>When issued, the <code class="language-plaintext highlighter-rouge">LOCK</code> instruction would send its instruction address to
the memory unit.</p>
  </li>
  <li>
    <p>The load instruction would be implemented as one might expect.  Indeed,
issuing the read is identical to <a href="/zipcpu/2021/04/17/axilops.html">the previous
controller</a>, save for a
couple details–such as setting <code class="language-plaintext highlighter-rouge">ARLOCK</code> and so forth.
<code class="language-plaintext highlighter-rouge">ARLOCK</code> would be set, etc.</p>
  </li>
  <li>
    <p>The first change comes if the load instruction does not return
<code class="language-plaintext highlighter-rouge">RRESP=EXOKAY</code>.  The AXI4 specification says that the master <em>may</em> treat
this as an <a href="https://en.wikipedia.org/wiki/Bus_error">error</a> condition.</p>
  </li>
</ol>

<table align="center" style="float: none"><caption>Fig 3. AXI4 Specification: Should RRESP != EXOKAY be treated as an error?</caption><tr><td><img src="/img/axiops/axi-rresp.png" alt="" width="760" /></td></tr></table>

<p>When I first read this, I understood that the slave must return <code class="language-plaintext highlighter-rouge">RRESP=OKAY</code>
   if it doesn’t support exclusive access operations, but otherwise the answer
   wasn’t constrained.  My first slave implementation, therefore, would return
   <code class="language-plaintext highlighter-rouge">RRESP=OKAY</code> if the slave supported exclusive access but a current write
   in progress would prevent this exclusive access operation from succeeding.
   Hence, I would only return <code class="language-plaintext highlighter-rouge">RRESP=EXOKAY</code> if the operation was going to
   succeed.</p>

<p>Upon further review, this initial AXI4 slave implementation was broken.
   Practically, the slave <em>must</em> return <code class="language-plaintext highlighter-rouge">EXOKAY</code> if an exclusive access
   operation might ever succeed for the given address.</p>

<p>The problem comes into play when you try to answer the question of what
   the CPU should do on an <code class="language-plaintext highlighter-rouge">RRESP=OKAY</code> response.  If the CPU doesn’t treat
   <code class="language-plaintext highlighter-rouge">RRESP=OKAY</code> as an <a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
   then <em>it will get stuck in an endless loop!</em>
   Hence, a request for exclusive access that returns <code class="language-plaintext highlighter-rouge">RRESP=OKAY</code> <em>must</em>
   generate a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
   <a href="https://en.wikipedia.org/wiki/Bus_error">error</a> return to the CPU.</p>

<ol start="4">
  <li>
    <p>On the other hand, if the CPU receives <code class="language-plaintext highlighter-rouge">RRESP=EXOKAY</code> then things proceed
as before: the value from memory is returned to the CPU, written into the
CPU’s register set, and then the CPU performs the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
operation on the memory value.</p>
  </li>
  <li>
    <p>The store instruction then starts out as expected as well: <code class="language-plaintext highlighter-rouge">AWLOCK</code> is
set, and the write request is issued.</p>
  </li>
  <li>
    <p>The next change takes place while the store operation is ongoing: during
this time, the CPU <em>must</em> stall to wait and see what the result of this
operation will be.  It cannot be allowed to continue with further
instructions since they might need to be rolled back if the write ever
failed.  While some CPU’s might be able to undo or “roll-back” any following
instructions, the <a href="/about/zipcpu.html">ZipCPU</a> has no such
ability–hence, it cannot continue until this operation finishes
successfully.</p>

    <p>For this reason, the memory controller must signal a stall to the CPU.</p>

    <p>In order to keep from rewriting any more of my memory interface than
necessary, I abused the read-in-progress signal, <code class="language-plaintext highlighter-rouge">o_rdbusy</code>, for this
purpose.  Hence, while an exclusive write operation is ongoing, the CPU
is told that a read is in progress.  This prevents the CPU from continuing,
lest it attempt to perform an operation on a register whose value is yet
to be returned from the read request.</p>

    <p>The second interface change is that, during this time, additional memory
operations are disallowed by the memory controller.  Only one outstanding
write operation is allowed during an exclusive access write of any type.
While this doesn’t really impact the
<a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">axiops</a>
controller we are discussing today, it does have a bit of an impact on <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axipipe.v">the
pipelined memory controller</a>
by prohibiting the pipeline from every becoming more than a single write
deep when using an exclusive access write.</p>
  </li>
  <li>
    <p>If the exclusive access store completes with <code class="language-plaintext highlighter-rouge">BRESP=EXOKAY</code>, the
stalls outlined above are quietly released and the CPU continues as before.</p>
  </li>
  <li>
    <p>On the other hand, if the exclusive store completes with <code class="language-plaintext highlighter-rouge">BRESP=OKAY</code>, then
the <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">memory controller</a>
returns a value to the CPU–much like it might return a value from a read
instruction.  The value returned is the value of the <code class="language-plaintext highlighter-rouge">LOCK</code> instruction’s
address, and this value is then written to the program counter.  Yes, the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">instruction set</a>
allows loads directly to the <a href="https://en.wikipedia.org/wiki/Program_counter">program
counter</a>.  This just forces
the exclusive access store operation to masquerade as such a read on failure.</p>
  </li>
</ol>

<p>At least, that was the plan I decided on to make this work.  I specifically
liked the fact that this plan didn’t require any changes to the <a href="/zipcpu/2018/01/01/zipcpu-isa.html">instruction
set</a>,
nor to the instruction decoder.  Indeed, the only change required to the
<a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/zipcore.v">CPU’s core</a>,
that of passing the <a href="https://en.wikipedia.org/wiki/Program_counter">program
counter</a> of the <code class="language-plaintext highlighter-rouge">LOCK</code>
instruction, was an easy/minor change to make.</p>

<p>Let’s therefore take a peek at how these details might be implemented in the
<a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">memory controller</a>.</p>

<p>The first step is to set the <code class="language-plaintext highlighter-rouge">AxLOCK</code> flag on any lock request.  We’ll start
by clearing this value if either the memory controller doesn’t support
exclusive accesses or if the value is reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">axlock</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_LOCK</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="n">OPT_LOWPOWER</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="n">axlock</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>The next step takes place only if <code class="language-plaintext highlighter-rouge">BREADY || RREADY</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span> <span class="o">||</span> <span class="n">M_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span> <span class="c1">// Something is outstanding</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">||</span> <span class="n">M_AXI_RVALID</span><span class="p">))</span>
			<span class="n">axlock</span> <span class="o">&lt;=</span> <span class="n">axlock</span> <span class="o">&amp;&amp;</span> <span class="n">i_lock</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_RVALID</span><span class="p">;</span></code></pre></figure>

<p>As a point of reference from <a href="/zipcpu/2021/04/17/axilops.html">our last
article</a>, the <code class="language-plaintext highlighter-rouge">BREADY</code>
and <code class="language-plaintext highlighter-rouge">RREADY</code> flags are being used as part of an implicit state machine to tell
us if an operation is ongoing.  <code class="language-plaintext highlighter-rouge">BREADY</code>, therefore, is only set if a write
operation is ongoing.  Likewise <code class="language-plaintext highlighter-rouge">RREADY</code> is only set if a read operation is
ongoing.  For this reason, the <code class="language-plaintext highlighter-rouge">BREADY || RREADY</code> check above is our way of
testing if an operation is ongoing.</p>

<p>If an operation is ongoing then we really don’t need to change anything.
However, if we’re trying to keep our power down, then it might make sense to
clear the lock flag at the end of the exclusive access write operation.</p>

<p>Otherwise, if there’s no operation ongoing, then we’ll want to set the
lock flag on any incoming memory request.  Here, again, we split the logic
into two possibilities: if we don’t care about arbitrarily toggling this
value, that is if <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> isn’t set and we are optimizing for low
area, then we just set <code class="language-plaintext highlighter-rouge">axlock</code> based upon the CPU’s lock request independent
of whether or not a new request is being made.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="c1">// New memory operation</span>
		<span class="c1">// Initiate a request</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_LOWPOWER</span><span class="p">)</span>
			<span class="n">axlock</span> <span class="o">&lt;=</span> <span class="n">i_lock</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>If <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> is set, then we are going to try to minimize the number of
times anything toggles, including <code class="language-plaintext highlighter-rouge">axlock</code>.
Therefore we’ll set <code class="language-plaintext highlighter-rouge">axlock</code> on any new memory request arriving
with the lock flag set, but otherwise clear the flag if an incoming lock
request will not result in an outgoing request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span>
				<span class="n">axlock</span> <span class="o">&lt;=</span> <span class="n">i_lock</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_cpu_reset</span> <span class="o">||</span> <span class="n">o_err</span> <span class="o">||</span> <span class="n">w_misaligned</span><span class="p">)</span>
				<span class="n">axlock</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="k">end</span>

	<span class="k">assign</span>	<span class="n">M_AXI_AWLOCK</span> <span class="o">=</span> <span class="n">axlock</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_ARLOCK</span> <span class="o">=</span> <span class="n">axlock</span><span class="p">;</span></code></pre></figure>

<p>This signal is then used to set the AXI <code class="language-plaintext highlighter-rouge">AWLOCK</code> and <code class="language-plaintext highlighter-rouge">ARLOCK</code> signals.</p>

<p>One of the AXI rules about exclusive access requests, however, is that all
exclusive access requests must be aligned.  It is a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> protocol violation to
issue an exclusive access request for an unaligned address.  Hence, we’ll need
to return a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
to the CPU on any request for exclusive access to an unaligned memory address.
This is controlled by the <code class="language-plaintext highlighter-rouge">w_misalignment_err</code> flag below.</p>

<p>Normally, this <code class="language-plaintext highlighter-rouge">w_misalignment_err</code> flag is set on any unaligned access if the
CPU is configured to generate a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> on any unaligned request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Return an error if a request requires two beats and we</span>
		<span class="c1">// don't support breaking the request into two, or ...</span>
		<span class="n">w_misalignment_err</span> <span class="o">=</span> <span class="n">OPT_ALIGNMENT_ERR</span> <span class="o">&amp;&amp;</span> <span class="n">w_misaligned</span><span class="p">;</span></code></pre></figure>

<p>To that logic, we add the exclusive access check for an unaligned access.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOCK</span> <span class="o">&amp;&amp;</span> <span class="n">i_lock</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// Return an error on any lock request for an unaligned</span>
			<span class="c1">// address--no matter how it is unaligned.</span>
			<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
			<span class="mb">2'b0?</span><span class="o">:</span> <span class="n">w_misalignment_err</span> <span class="o">=</span> <span class="p">(</span><span class="o">|</span><span class="n">i_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
			<span class="mb">2'b10</span><span class="o">:</span> <span class="n">w_misalignment_err</span> <span class="o">=</span> <span class="n">i_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="nl">default:</span>
				<span class="n">w_misalignment_err</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
			<span class="k">endcase</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>While the <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
operation is ongoing, the memory controller must tell the
CPU that it is busy with the request.  This is done via the “read-busy”
signal, <code class="language-plaintext highlighter-rouge">o_rdbusy</code>.  We’d nominally set this flag if <code class="language-plaintext highlighter-rouge">RREADY</code> were true,
indicating that a read operation was ongoing, with the exception being if the
CPU ever needed to flush pending responses from the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>–such
as if the CPU had received a reset independent of a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> reset, or following a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> of any type.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">o_rdbusy</span> <span class="o">=</span> <span class="n">M_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r_flushing</span><span class="p">;</span></code></pre></figure>

<p>This <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v#L319-L351"><code class="language-plaintext highlighter-rouge">r_flushing</code> signal</a>
is one of the biggest differences between the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> memory
controller and the
<a href="/zipcpu/2021/04/17/axilops.html">AXI controller</a>:
AXI doesn’t allow <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
aborts.  Hence, if a transaction is ongoing when the
CPU is reset, or likewise if a transaction is ongoing when an
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> condition is received, then
the CPU wants to abort any outstanding transactions.  Since AXI doesn’t have a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
abort capability, we’ll instead <em>flush</em> the returns.  That is, we count how
many requests are outstanding, and then wait for this value to return to zero
before returning back to operation again.</p>

<p>Keep in mind, this <code class="language-plaintext highlighter-rouge">o_rdbusy</code> signal is different from the busy signal,
<code class="language-plaintext highlighter-rouge">o_busy</code>.  If <code class="language-plaintext highlighter-rouge">o_busy</code> is true, the memory controller won’t accept any new
requests, and it won’t switch from <a href="/zipcpu/2018/01/01/zipcpu-isa.html">user to supervisor
mode</a>–choosing instead
to wait until all requests are complete.  If <code class="language-plaintext highlighter-rouge">o_rdbusy</code> is true, on the other
hand, then the CPU must also stall and wait on a read return.</p>

<p>That was before AXI exclusive access support.</p>

<p>Now we need to declare ourselves busy during exclusive access writes as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">o_rdbusy</span> <span class="o">=</span> <span class="p">(</span><span class="n">M_AXI_BREADY</span> <span class="o">&amp;&amp;</span> <span class="n">axlock</span><span class="p">)</span> <span class="o">||</span> <span class="n">M_AXI_RREADY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r_flushing</span><span class="p">)</span>
			<span class="n">o_rdbusy</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>That’s because we might need to write to the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a> register once
the exclusive access store instruction completes, assuming it didn’t receive
<code class="language-plaintext highlighter-rouge">BRESP=EXOKAY</code>, just like a normal read might.  This then forces the CPU to
stall waiting on the end of the exclusive access write, whereas it might
otherwise have continued onto its next instruction even though a write
operation might have been outstanding.</p>

<p>Once the exclusive access operation completes, we’ll need to either raise
<code class="language-plaintext highlighter-rouge">o_valid</code>, to indicate a read has completed and the result is to be written
to a CPU register (such as the <a href="https://en.wikipedia.org/wiki/Program_counter">program
counter</a>), or <code class="language-plaintext highlighter-rouge">o_err</code> to
cause the CPU to recognize a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> and trap, or neither if
the write completes successfully.</p>

<p>The semantics for <code class="language-plaintext highlighter-rouge">o_valid</code> are a touch different
<a href="/zipcpu/2021/04/17/axilops.html">from before</a>.
<a href="/zipcpu/2021/04/17/axilops.html">Before</a> we’d return
<code class="language-plaintext highlighter-rouge">o_valid</code> once any read operation completed to indicate that a read result
was ready to be copied into a CPU register.  Now, when using exclusive access,
we’ll also need to declare a successful read result if the write operation
failed.  Remember, if the write operation fails to receive <code class="language-plaintext highlighter-rouge">BRESP=EXOKAY</code> then
we need to write a new <a href="https://en.wikipedia.org/wiki/Program_counter">program
counter</a>
value to the CPU and cause it to jump to the beginning of the LOCK operation
to repeat it–hence we need to set <code class="language-plaintext highlighter-rouge">o_valid</code> in that case to indicate a valid
read return.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axlock</span><span class="p">)</span>
		<span class="n">o_valid</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_RRESP</span> <span class="o">==</span> <span class="n">EXOKAY</span><span class="p">)</span>
				<span class="o">||</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BRESP</span> <span class="o">==</span> <span class="n">OKAY</span><span class="p">);</span></code></pre></figure>

<p>Finally, during an exclusive access sequence we’ll need to generate an error
return on any <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> we receive.  Likewise, if an
exclusive access read return is anything other than  <code class="language-plaintext highlighter-rouge">EXOKAY</code> then we’ll
also return an <a href="https://en.wikipedia.org/wiki/Bus_error">error</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">axlock</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_err</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BRESP</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			 <span class="o">||</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_RRESP</span> <span class="o">!=</span> <span class="n">EXOKAY</span><span class="p">);</span></code></pre></figure>

<p>Such errors will force the CPU to have an exception.  If the
<a href="/about/zipcpu.html">ZipCPU</a> is in user mode, it will simply
set an bus error exception flag and switch to supervisor mode.  If the
<a href="/about/zipcpu.html">ZipCPU</a> is in supervisor mode, however,
it will either 1) halt on an exception for the debugger, or
2) reboot–depending on how it was configured at build time.</p>

<p>Note that if the write operation completes successfully with <code class="language-plaintext highlighter-rouge">BRESP=EXOKAY</code>,
then <code class="language-plaintext highlighter-rouge">o_rdbusy</code> will quietly be dropped without setting either <code class="language-plaintext highlighter-rouge">o_valid</code> or
<code class="language-plaintext highlighter-rouge">o_err</code>.</p>

<p>That leaves three final parts to the exclusive access implementation: the
return register, and two pieces of logic required for the return register’s
value.</p>

<p>Normally, the memory controller keeps track of the return register on any
read, so the CPU can be told where to write the read result back to.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span>
		<span class="n">o_wreg</span> <span class="o">&lt;=</span> <span class="n">i_oreg</span><span class="p">;</span></code></pre></figure>

<p>The need for this interface is driven by the <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axipipe.v">pipelined memory
controller</a>’s
implementation, where this value is kept in a FIFO.  In the case of <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">today’s
simplified controller</a>,
we simply keep track of which CPU register to write the return into in <code class="language-plaintext highlighter-rouge">o_wreg</code>.</p>

<p>When using exclusive access, we also want the CPU to execute a jump to the
original <code class="language-plaintext highlighter-rouge">LOCK</code> instruction on a failed write return.  Hence, on any exclusive
access write request, we set the return CPU register index to be the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>’s register
index.  In the case of the <a href="/about/zipcpu.html">ZipCPU</a>,
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">the bottom four bits of the program counter’s index is
15</a> leading to the logic
listed below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_wreg</span> <span class="o">&lt;=</span> <span class="n">i_oreg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOCK</span> <span class="o">&amp;&amp;</span> <span class="n">i_stb</span> <span class="o">&amp;&amp;</span> <span class="n">i_lock</span> <span class="o">&amp;&amp;</span> <span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">o_wreg</span><span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mh">4'hf</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>The last exclusive access change is to keep track of the address to restart
from on a write failure.  For this, we’ll first introduce a new register:
<code class="language-plaintext highlighter-rouge">r_pc</code>.  On the first load, as the exclusive access sequence begins, we’ll
record the address of the initial <code class="language-plaintext highlighter-rouge">LOCK</code> instruction given to the memory
controller by the CPU.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_LOCK</span><span class="p">)</span>
		<span class="n">r_pc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_stb</span> <span class="o">&amp;&amp;</span> <span class="n">i_lock</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_op</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">r_pc</span> <span class="o">&lt;=</span> <span class="n">i_restart_pc</span><span class="p">;</span></code></pre></figure>

<p>The next step is to determine the return value to be returned to the CPU.
Nominally, this return value would simply be <code class="language-plaintext highlighter-rouge">RDATA</code>.  The logic below,
however, is just a touch more complex.</p>

<p>First, we’ll zero the return value if <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> is set and there won’t
be any return.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span><span class="p">((</span><span class="o">!</span><span class="n">M_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_LOCK</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_BREADY</span><span class="p">))</span>
			<span class="o">||</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="n">r_flushing</span> <span class="o">||</span> <span class="n">i_cpu_reset</span><span class="p">))</span>
		<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>More interesting is what we do on a write return.  On any exclusive access
write return failure, where <code class="language-plaintext highlighter-rouge">BRESP == OKAY</code> rather then <code class="language-plaintext highlighter-rouge">EXOKAY</code>, <code class="language-plaintext highlighter-rouge">o_result</code>
is set to the <a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>
value captured above in <code class="language-plaintext highlighter-rouge">r_pc</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOCK</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_LOWPOWER</span>
					<span class="o">||</span> <span class="p">(</span><span class="n">axlock</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BRESP</span> <span class="o">==</span> <span class="n">OKAY</span><span class="p">)))</span>
		<span class="k">begin</span>
			<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">o_result</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">r_pc</span><span class="p">;</span>
		<span class="k">end</span></code></pre></figure>

<p>The rest of the read return logic is only activated on an actual read return.
It’s the same logic that we <a href="/zipcpu/2021/04/17/axilops.html">originally
presented</a>, so we’ll skip
the details here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span><span class="p">)</span>
		<span class="c1">// ...</span>
	<span class="k">end</span></code></pre></figure>

<p>The big lesson to be learned here, regarding how to implement an
exclusive access sequence, is that the sequence is really a state machine.
Fig. 4 below shows the basic four-state machine controlling an exclusive
access request.</p>

<table align="center" style="float: none"><caption>Fig 4.  Basic exclusive access state machine</caption><tr><td><img src="/img/axiops/axilock.svg" alt="" width="480" /></td></tr></table>

<p>Once you realize that it’s just a basic state machine, verification gets
easy.  Indeed, my own verification properties simply tie assertions (and
assumptions) to the various states of this machine, as shown below.</p>

<table align="center" style="float: none"><caption>Fig 5.  Exclusive access state machine based properties</caption><tr><td><img src="/img/axiops/awlock-assertions.svg" alt="" width="480" /></td></tr></table>

<p>That leads us to the next big change going from AXI-lite to AXI: the AxSIZE
field.</p>

<h2 id="updating-axsize">Updating AxSIZE</h2>

<p>On its surface, the AxSIZE field should be fairly simple.  If the CPU wants to
write a byte to or read a byte from memory, then the size should be <code class="language-plaintext highlighter-rouge">3'b000</code>
(one byte).  If the transaction calls for two bytes of memory, then the size
should be <code class="language-plaintext highlighter-rouge">3'b001</code> (16’bit word), and if the transaction calls for four bytes
of memory then the size should be <code class="language-plaintext highlighter-rouge">3'b010</code> (32’bit word).  This only makes
sense.</p>

<table align="center" style="float: none"><caption>Fig 6. Bytes in an aligned access</caption><tr><td><img src="/img/axiops/szaligned.png" alt="" width="446" /></td></tr></table>

<p>Sadly, the formal tool found several problems with this “only makes sense”
design.</p>

<p>The first problem was my own fault.  Once I got the design to work, I then
wanted to add “features”.  The feature that triggered this problem was the
unaligned feature, not shown in Fig. 6 above.  Handling an unaligned request
requires (potentially) turning a single request to write a 2-byte or 4-byte word
into multiple 32-bit transactions.</p>

<p>Fig. 7 below shows three examples of how an unaligned 32-bit access can be
spread across two separate but successive AXI4 beats.</p>

<table align="center" style="float: none"><caption>Fig 7. Unaligned 32-bit word accesses require two beats</caption><tr><td><img src="/img/axiops/szunalignword.png" alt="" width="383" /></td></tr></table>

<p>The second problem was my desire to make the design
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
width independent.  In the past, I’ve seen memory requests to/from a 64-bit
memory get wasted by only issuing 32-bit commands to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
at a time.  If I just made the memory controller in such a way that the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
width could be parameterized,
then I might get some more efficiency from my memory controller.</p>

<p>At this point, I might not have noticed any problems save that I had recently
built a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilsub.v">bus
downsizer</a>–a
bridge to transition a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
from one width to a smaller width.  <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilsub.v">This
bridge</a>
breaks an AXI4 request into (potentially) multiple requests.  Knowing where
each request begins and how many requests to issue, however, depends upon
the AxSIZE parameter.</p>

<p>Remembering how this
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilsub.v">downsizer</a>
worked forced me to look a bit deeper at how AxSIZE might be set.</p>

<p>As an example, let’s suppose we have a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
width of 64-bits that needs to be reduced to 32-bits.  In this case, if AxSIZE
indicates that the transaction is 64 bits wide <em>and</em> the AxADDR field
indicates that the first 32-bits of the transaction will be used, then the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilsub.v">downsizer</a>
will transform the transaction into two 32-bit transactions–each requiring
one clock per request and one clock per return.</p>

<p>Fig. 8 shows two examples of this.  In the first example, the bus word needs
to be broken into two 32-bit accesses.  In the second example, a single
32-bit access is sufficient.</p>

<table align="center" style="float: none"><caption>Fig 8. Transactions before and after downsizing</caption><tr><th>Original transaction on a 64-bit Bus</th><th>Same transaction, after downsizing to 32-bits</th></tr><tr><td colspan="2">Word size transaction, starting at AxAddr[1:0] == 3, requires two beats on a 32-bit bus</td></tr><tr><td align="center"><img src="/img/axiops/szword64.3.png" alt="" width="255" /></td><td align="center"><img src="/img/axiops/szword32.3.png" alt="" width="253" /></td></tr><tr><td colspan="2">Halfword transaction, starting at AxAddr[2:0] == 5, downsizes to a single beat on a 32-bit bus</td></tr><tr><td align="center"><img src="/img/axiops/szword64.5.png" alt="" width="255" /></td><td align="center"><img src="/img/axiops/szword32.5.png" alt="" width="253" /></td></tr></table>

<p>On the other hand, if AxSIZE either indicates that any transaction has only
32-bits or equivalently if the AxADDR indicates that only the upper 32-bits
will be impacted, then the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axi2axilsub.v">downsizer</a>
will only transform the transaction into a single 32-bit transaction.
In other words, there is efficiency to be had by keeping the transaction
size specified in AxSIZE as small as possible.</p>

<p>This problem is only compounded the larger the size difference is between the
two buses.  For example, if the first
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> is
64-bits but the smaller
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> is
only 8-bits, then the downsizer might have to break the request up into eight
smaller transactions–but, again, this all depends upon both AxSIZE and AxADDR.</p>

<p>So, how did this work out?</p>

<p>Well, I first built the logic below–much as I indicated above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// CPU_DATA_WIDTH for the ZipCPU is always 32-bits--independent</span>
	<span class="c1">// of the final bus size.  The final bus size must be at least</span>
	<span class="c1">// 32-bits, but may be arbitrarily larger.</span>
	<span class="k">localparam</span>	<span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">DSZ</span> <span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">CPU_DATA_WIDTH</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>

	<span class="k">initial</span>	<span class="n">axsize</span> <span class="o">=</span> <span class="n">DSZ</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="n">DSZ</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_BREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
		<span class="mb">2'b0?</span><span class="o">:</span> <span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b010</span><span class="p">;</span>	<span class="c1">// Word</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b001</span><span class="p">;</span>	<span class="c1">// Half-word</span>
		<span class="mb">2'b11</span><span class="o">:</span> <span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b000</span><span class="p">;</span>	<span class="c1">// Byte</span>
		<span class="k">endcase</span>
	<span class="k">end</span>

	<span class="k">assign</span>	<span class="n">M_AXI_AWSIZE</span> <span class="o">=</span> <span class="n">axsize</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_ARSIZE</span> <span class="o">=</span> <span class="n">axsize</span><span class="p">;</span></code></pre></figure>

<p>This worked great–up until I tried to enable misaligned transactions.  When
I did that, I came across the transaction shown below in Fig. 9.</p>

<!-- Show an illegal transaction: Halfword to address 1 -->
<table align="center" style="float: none"><caption>Fig 9. This transaction would be illegal if AxSIZE=3'b001 (16-bit)</caption><tr><td><img src="/img/axiops/szhalfill.png" alt="" width="253" /></td></tr></table>

<p>Was this transaction legal?</p>

<p>On the one hand, its a two-byte transaction bound to two bytes, therefore it
looks legal.  On the other hand, if this were a burst transaction, <a href="/blog/2019/04/27/axi-addr.html">the second
beat would necessarily start at address
two</a>–breaking the word in
two, so that two separate beats would be writing to the same word.</p>

<p>That didn’t make sense.</p>

<p>So, I did some digging.  I discovered a discrepancy between the AXI4 standard
I was using and the more recent AXI4 standards when it came to determining
the second address in a burst.  The second address of a burst is always the
next aligned address, given the alignment specified by AxSIZE.</p>

<p>That was enough for me.  I now marked this transaction as an illegal
transaction, adjusted my formal properties to handle it, and then went back
to adjusting the CPU again to handle it.  Thankfully, I could quickly reverify
all of my AXI designs against this updated standard and nothing failed–save
the <a href="/about/zipcpu.html">ZipCPU</a>’s new AXI memory controllers.</p>

<p>It was now time to come back and try to get the AxSIZE field right again–this
time with some more explicit formal properties.</p>

<p>My second approach, therefore, was to simply expand the transaction size if I
ever noticed an unaligned transaction.  In this approach, I thought I might
just merge the two halfwords together, and split any unaligned word requests
into two beats.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// ...</span>
		<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
		<span class="mb">2'b0?</span><span class="o">:</span> <span class="k">begin</span>
			<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b010</span><span class="p">;</span>	<span class="c1">// Word</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">i_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
				<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b010</span><span class="p">;</span> <span class="c1">// Split into two beats</span>
			<span class="k">end</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
			<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b001</span><span class="p">;</span>	<span class="c1">// Half-word</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b010</span><span class="p">;</span> <span class="c1">// Expand to 32-bit size</span>
			<span class="k">end</span>
		<span class="mb">2'b11</span><span class="o">:</span> <span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b000</span><span class="p">;</span>	<span class="c1">// Byte</span>
		<span class="k">endcase</span>
	<span class="c1">// ...</span></code></pre></figure>

<p>Here, I noticed three things.</p>

<ol>
  <li>
    <p>Byte requests can never be misaligned.  Their size can always be <code class="language-plaintext highlighter-rouge">3'b000</code>,
and they’ll never trigger a misaligned request requiring two beats.</p>
  </li>
  <li>
    <p>Expanding the transaction to two 32’bit words works great, but only on a
32-bit bus.  On a 64-bit bus, we might still be able to keep the two
transactions in a single beat.</p>

    <p>It’s worse than <em>might</em>, however, since my read/write logic depends upon
transactions taking two beats being split over <em>two bus-sized words</em>.</p>

    <p>This means that, if the transaction could at all fit into a single
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> word,
then it needed to be placed into a single
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> word.</p>
  </li>
  <li>
    <p>There’s another problem as well: the halfword transaction might also need
to be split into two beats.  Just expanding it to two bytes isn’t sufficient
if the two bytes won’t fit in the bus word.</p>
  </li>
</ol>

<p>My next approach was then to try merging requests into a single
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
word where possible.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
		<span class="mb">2'b0?</span><span class="o">:</span> <span class="k">begin</span>
			<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b010</span><span class="p">;</span>	<span class="c1">// Word</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">|</span><span class="n">i_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">w_misaligned</span><span class="p">)</span>
				<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b011</span><span class="p">;</span> <span class="c1">// 64-bit width</span>
			<span class="k">end</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
			<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b001</span><span class="p">;</span>	<span class="c1">// Half-word</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b010</span><span class="p">;</span> <span class="c1">// 32-bit width</span>
			<span class="k">end</span></code></pre></figure>

<p>In this approach, I use the flag <code class="language-plaintext highlighter-rouge">w_misaligned</code>.  This flag is intended to
capture whether or not the request needs to be split into two beats.  Hence,
if the request doesn’t need to be split, then I simply keep the original
width.</p>

<p>Unfortunately, this doesn’t work either.  What happens if a half-word
transaction needs to cross over two 32-bit fields on the 64-bit
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>?  Similarly, what would
happen if a word size transaction needed to cross two 64-bit fields on a 128-bit
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>?</p>

<!-- FIGURE!  Illegal transaction -->
<table align="center" style="float: none"><caption>Fig 10. This 16-bit transaction would be illegal if AxSIZE=2 (32-bit)</caption><tr><td><img src="/img/axiops/szhalfill.64.png" alt="" width="253" /></td></tr></table>

<p>Frankly, I never would’ve thought of this if I hadn’t adjusted my formal
properties earlier.  Unfortunately, this led to a very complex calculation of
AxSIZE based on the size of the transaction and how far off the transaction
would be, as shown in Fig. 11 below.</p>

<table align="center" style="float: none"><caption>Fig 11. Minimum AxSIZE values for a 64-bit bus</caption><tr><td><img src="/img/axiops/sztable.png" alt="" width="679" /></td></tr></table>

<p>At this point, I gave up and just tried to simplify things as much as possible.
It’s not that the logic required to implement the table was too complex, but
rather it was becoming too complex to be generic across all
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> sizes.
The one guaranteed solution to this problem was to simply bump the AxSIZE value
up from the minimum required size to that of a full
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> word if the request was
ever misaligned <em>and</em> was not going to be broken into two words.  If the
request was going to be broken into two words, it could still keep its original
size since each word would (of necessity) contain fewer bytes than the original
size would require.</p>

<p>This led me to the following logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">AXILSB</span> <span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">C_AXI_DATA_WIDTH</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>
	<span class="k">localparam</span>	<span class="n">DSZ</span> <span class="o">=</span> <span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="mi">32</span><span class="o">/</span><span class="mi">8</span><span class="p">);</span>

	<span class="c1">// M_AXI_AxSIZE</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">axsize</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">axsize</span> <span class="o">=</span> <span class="n">DSZ</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="n">DSZ</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_BREADY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_RREADY</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_LOWPOWER</span> <span class="o">||</span> <span class="n">i_stb</span><span class="p">))</span></code></pre></figure>

<p>Let me stop here, for a moment, because I just added a new requirement to
the logic we’ve been building: <code class="language-plaintext highlighter-rouge">!OPT_LOWPOWER || i_stb</code>.  As I mentioned
when discussing exclusive access above, the <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> parameter is
part of my ongoing effort to build logic that can work in both low power
environments and low logic environments.  In general, I force things to
zero on low power.  Here, I simply only allow the AxSIZE parameter to
change on a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> request
(i.e. <code class="language-plaintext highlighter-rouge">i_stb</code>), or I simplify the logic if I don’t care about low power and
allow it to change any time for the savings of a LUT or two.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">begin</span>
		<span class="k">casez</span><span class="p">(</span><span class="n">i_op</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">])</span>
		<span class="mb">2'b0?</span><span class="o">:</span> <span class="k">begin</span>
			<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b010</span><span class="p">;</span>	<span class="c1">// Word</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">|</span><span class="n">i_addr</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">w_misaligned</span><span class="p">)</span>
				<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="n">AXILSB</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">end</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
			<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b001</span><span class="p">;</span>	<span class="c1">// Half-word</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">w_misaligned</span><span class="p">)</span>
				<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="n">AXILSB</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">end</span>
		<span class="mb">2'b11</span><span class="o">:</span> <span class="n">axsize</span> <span class="o">&lt;=</span> <span class="mb">3'b000</span><span class="p">;</span>	<span class="c1">// Byte</span>
		<span class="k">endcase</span></code></pre></figure>

<p>There is, however, one exception to the AxSIZE rule and that exception is if
the CPU is running <a href="https://en.wikipedia.org/wiki/Endianness">big-endian</a>
software.  Remember, the AXI4
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a> is by nature
<a href="https://en.wikipedia.org/wiki/Endianness">little endian</a>,
and the <a href="/about/zipcpu.html">ZipCPU</a>
<a href="/zipcpu/2018/01/31/cpu-build.html">tool chain</a> is <a href="https://en.wikipedia.org/wiki/Endianness">big
endian</a>.  Adjusting the CPU to make
the <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://en.wikipedia.org/wiki/Endianness">little endian</a> is actually
quite easy to do–that’s not a problem at all.  Adjusting the
<a href="/zipcpu/2018/01/31/cpu-build.html">tool chain</a>
(GAS, GCC, C-Lib)?  That takes more work.  As a result, I’m running the
<a href="/about/zipcpu.html">ZipCPU</a> in a
<a href="https://en.wikipedia.org/wiki/Endianness">big endian</a> configuration on a
<a href="https://en.wikipedia.org/wiki/Endianness">little endian</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.
The result has been more than a hassle.</p>

<p>This also means that, when writing to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>, the address requested
doesn’t necessarily correspond with the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
address.  For example, writing a halfword
to address 0 (<a href="https://en.wikipedia.org/wiki/Endianness">big endian</a>) means
that it writes to address 2
(<a href="https://en.wikipedia.org/wiki/Endianness">little endian</a>).
Part of my solution has been to clip all address requests so that they are
aligned and just move the words/bytes into place as necessary.  That also
forces the size parameter to always reference the full size of the bus, as
shown below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">SWAP_WSTRB</span><span class="p">)</span> <span class="c1">// CPU is running big-endian</span>
			<span class="n">axsize</span> <span class="o">&lt;=</span> <span class="n">DSZ</span><span class="p">;</span>
	<span class="k">end</span>

	<span class="k">assign</span>	<span class="n">M_AXI_AWSIZE</span> <span class="o">=</span> <span class="n">axsize</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_ARSIZE</span>  <span class="o">=</span> <span class="n">M_AXI_AWSIZE</span><span class="p">;</span></code></pre></figure>

<p>No, this <a href="https://en.wikipedia.org/wiki/Endianness">big vs little endian</a>
“solution” does not follow the recommendations of
the AXI4 specification, but it 1) works, and 2) was easier to do than
adjusting every other slave my my design as the AXI specification
requires.</p>

<p>The logic above is now my current solution to setting AxSIZE.  It’s not
elegant, but it works and it keeps with the low logic spirit of the
<a href="/about/zipcpu.html">ZipCPU</a>.</p>

<h2 id="two-unused-features-axlen-and-axid">Two unused features: AxLEN and AxID</h2>

<p>The two AXI features
<a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">this design</a>
doesn’t use are the AxLEN and AxID fields.
Let me explain why, starting with the AxID field.</p>

<p>AxID is perhaps best known for its out of order feature.  If two packets
are requested, whether they be reads or writes, if their AxID’s are different
then their returns may come back out of order.  If their AxID’s are the
same, however, the requests must come back in the order they were issued.
This feature helps to create multiple virtual channels through the AXI
interconnect.  It can also be a real challenge when it comes to formally
verifying a design–but that’s another story.</p>

<table align="center" style="float: right"><caption>Fig 12. Most slaves can just mirror the given AxIDs onto their returns</caption><tr><td><img src="/img/axiops/id-reflection.svg" alt="" width="280" /></td></tr></table>

<p>Handling AxIDs is fairly easy within a slave: the slave just needs to return
the requests given to it with the AxIDs provided.  This is called mirroring,
and its fairly easy to do: incoming requests just go into a FIFO having the
depth of the slave’s pipeline.  Upon return, the request is simply returned
with the ARID provided with the request.  It’s that simple.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 13. What happens when a bus element misbehaves?</caption><tr><td><img src="/img/axiops/dropped-pkts.svg" alt="" width="320" /></td></tr></table>

<p>Where AxIDs become difficult to handle is within the interconnect.  The
interconnect must guarantee that any two packets with the same AxID are
always returned in order.  This creates some derived requirements within the
interconnect: The first is that the interconnect cannot switch arbitration
from a given master, ID, slave combination to another slave until all of the
returns have been received for the first master, ID, and slave combination.
This forces the interconnect to contain a counter for every master, ID pair
to count the number of requests made minus responses received.  Only when the
counter indicates there are no outstanding requests for a given master, ID
pair, is the interconnect allowed to reallocate that channel to a new slave.
A second derived requirement is that the interconnect must stall the
upstream master before its counter ever overruns.</p>

<table align="center" style="float: right"><caption>Fig 14. Transactions from multiple sources within the same master can easily be separated by ID</caption><tr><td><img src="/img/axiops/multi-master.svg" alt="" width="320" /></td></tr></table>

<p>These aren’t problems within the source–that is within the original AXI4
master.  In any given source, such as within a CPU, there’s a bit of a
different purpose for AxIDs.  Inside the source, each different master can be
assigned a different and unique ID.  For example, the instruction fetch can
be given one ID and the memory controller another, as illustrated in Fig. 14 on
the right.  In a scatter gather DMA, the <a href="https://github.com/ZipCPU/wb2axip/blob/ec864d4e445b0566695791e2550bd54591601cf0/rtl/axisgdma.v#L128">table reader could be given one
ID</a> and <a href="https://github.com/ZipCPU/wb2axip/blob/ec864d4e445b0566695791e2550bd54591601cf0/rtl/axisgdma.v#L126-L127">the underlying DMA another</a>.
In both cases, the master/source is simplified by only issuing requests to
and receiving responses from a single ID.  This is also what we’ll do here:
we’ll assign a fixed ID to the <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">memory controller</a>.
This will also simplify our logic.  By using a single ID,
1) we can verify the AXI interface against a single ID channel.  Further, we
can also 2) ignore the RID and BID returns knowing that we’ll never get a
return for an ID we haven’t requested.</p>

<p>That handles the AxID field: it’s just a constant.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="n">AXI_ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="k">assign</span>	<span class="n">M_AXI_AWID</span>    <span class="o">=</span> <span class="n">AXI_ID</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_ARID</span>    <span class="o">=</span> <span class="n">AXI_ID</span><span class="p">;</span></code></pre></figure>

<p>But what about AxLEN?</p>

<p>Just for background, the AxLEN field is used to indicate that the AXI4 <a href="/blog/2020/06/16/axiaddr-limits.html">bus
master wants to issue a burst request of (AxLEN+1)
beats</a>.  Both the
interconnect and the <a href="https://github.com/ZipCPU/wb2axip/blob/b3145001959c36a206a884243770be5c8c17e5da/rtl/demofull.v">ultimate
slave</a>
can then use this value to optimize the transaction–knowing that more beats
are coming from a given request.</p>

<p>This is another feature we won’t use.  This is also a feature that confuses a
lot of CPU users, leading to a common question: Why isn’t the CPU
(<a href="https://en.wikipedia.org/wiki/MicroBlaze">Microblaze</a>, ARM, etc.) issuing
burst requests of the FPGA?</p>

<p>For this, let me offer several observations.</p>

<ol>
  <li>The CPU never knows how many accesses will be made of the
  <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>.</li>
</ol>

<p>What of the case of a <code class="language-plaintext highlighter-rouge">memcpy()</code> library call, however, where the CPU knows
  that a lot of data needs to be moved?  Can’t a burst instruction be used
  there?</p>

<p>The answer here, again, is no.  Remember, a CPU will only ever execute
  one instruction at a time.  Even dual issue CPUs are designed to maintain
  the appearance of only ever issuing one instruction at a time.  To
  illustrate how this affects things, consider the following
  (super-simplified) memory move routine in
  <a href="/zipcpu/2018/01/01/zipcpu-isa.html">ZipCPU assembly</a>:</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">_simple_memcpy:	// R1=DST, R2=SRC, R3=LEN
	CMP	0,R3	// Return immediately on a zero length copy
	RTN.Z
_move_loop:
	LW	(R2),R4	// Read from the source
	SW	R4,(R1)	// Write the value to the destination
	ADD	4,R2	// Update the source pointer
	ADD	4,R1	// Update destination pointer
	SUB	1,R3	// Update the remaining length
	BNZ	_move_loop	// Repeat if more remains to copy
	RTN 		// All done, return</code></pre></figure>

<p>Now, looking through this, remember that the <em>hardware</em> only ever sees
one instruction of this sequence at any given time.  Nowhere in this
instruction sequence is there an instruction to indicate a <em>burst</em> transaction
of more than one beat.  Worse, never in the CPU pipeline will it see two
loads or two stores in a row.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 15. Might a multiple-move-register instruction use AxLEN?</caption><tr><td><img src="/img/axiops/movem.svg" alt="" width="320" /></td></tr></table>

<p>Keep in mind, this is a very <em>simplified</em> memory copy example.  A real memory
copy can be much more complex.  For example, in this simplified example we’ve
assumed that the two pointers are aligned on a word boundary (32bits for the
<a href="/about/zipcpu.html">ZipCPU</a>), and that the length is
specified in a number of words.  Similarly, there are some optimizations that
could be made to this function.  For example, if we could verify that the
number of words to be copied would be greater than one each time through the
loop, then we might manage to pipeline the memory copy to issue more than one
load (or store) at a time–but that’s still not a burst operation for the same
reason: nowhere in this set of instructions does the CPU <em>hardware</em> get told
how much memory the software wishes to copy.</p>

<p>In other words, the nature of a CPU simply leaves us out of luck here.</p>

<ol start="2">
  <li>
    <p>A data cache is only subtly different.  In the case of a data cache,
  and even then only when <em>reading</em> from memory, you can read more data than
  you need.  Indeed, you can read an entire cache line at a time.  This allows
  you to use burst reads nicely to your advantage.  The problem here, however,
  is that you can only issue burst read requests of <em>memory</em>.  If you make a
  mistake and issue a burst read of a <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped
  peripheral</a>, such as the
  serial port’s data FIFO, then you might invoke a <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">side
  effect</a> you
  aren’t intending–such as accidentally clearing the unread data from the
  serial port when just trying to read how much data is available in that FIFO.</p>
  </li>
  <li>
    <p>There is one potential place in <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">this design</a>
  where we might use an AXI burst, and that’s when reading (or writing) to an
  unaligned address.  As an example, suppose we wished to write 4 bytes to
  address 1.  Such a request would either need to cause a
  <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
  <a href="https://en.wikipedia.org/wiki/Bus_error">error</a>,
  due to the unaligned request, or else 2) it would need to be broken into two
  requests.  If the request was broken into two adjacent requests as illustrated
  in Fig. 7 above, then it might make sense to use AxLEN=1.</p>
  </li>
</ol>

<p>The problem with this choice is that AXI has a requirement that burst
  requests may not cross 4kB boundaries.  That means that, in order to turn an
  unaligned request into a two beat burst, the CPU would need extra logic to
  use singleton requests anytime the 4kB boundary were being crossed but burst
  requests at other times.</p>

<p>If it costs all that work, why not just issue a pair of singleton requests
  in the first place?  I mean, you need to build that logic into the memory
  controller anyway to handle the 4kB boundary crossing!</p>

<p>Now, let’s add to this discussion my own background with a stripped down
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>.
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>, as I use it,
has no capability for burst requests like AXI.  This has not slowed down either
my <a href="/blog/2019/07/17/crossbar.html">interconnect implementations</a>
or <a href="/zipcpu/2017/05/29/simple-wishbone.html">my slave implementations</a>.
If necessary, <a href="/blog/2019/03/27/qflexpress.html">a slave can just take a peek at the next request
address</a>
to derive any details of a burst as it arrives.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 15. Would a flash controller benefit from burst transactions?</caption><tr><td><img src="/img/axiops/flash-burst.svg" alt="" width="420" /></td></tr></table>

<p>As a result, <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">this non-cached memory
controller</a>
leaves <code class="language-plaintext highlighter-rouge">AxLEN==0</code>.</p>

<p>My <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axidcache.v">AXI4 data cache implementation</a>?
That’s the one example I have where <a href="https://github.com/ZipCPU/zipcpu/blob/bc9051269ecaadee271469968bb9bb550e8b3e25/rtl/core/axidcache.v#L553-L608"><code class="language-plaintext highlighter-rouge">ARLEN</code> may be set to something greater
than zero</a>.
In that case, however, 1) the <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axidcache.v">cache
implementation</a>
offers no support for unaligned requests, and 2) <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axidcache.v">the data
cache</a>
needs to <a href="https://github.com/ZipCPU/zipcpu/blob/bc9051269ecaadee271469968bb9bb550e8b3e25/rtl/core/axidcache.v#L323-L333">separate <em>memory</em> requests from <em>peripheral</em>
requests</a>.
<em>Memory</em> requests can be cached, and they get burst read support.  Yes, that’s
right, <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axidcache.v">the cache</a>
only provides burst <em>read</em> support, there’s no burst write support–since
the <a href="/about/zipcpu.html">ZipCPU</a>’s <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axidcache.v">AXI4 data
cache</a>
is a write-through cache.  Writes go directly to the
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
as outlined above.  <em>Peripheral</em> requests also fundamentally use the
same logic we’ve just outlined above as well.</p>

<h2 id="remaining-signals">Remaining signals</h2>

<p>These leaves only a small number of remaining signals: AxBURST, WLAST, AxQOS,
and AxCACHE.</p>

<p>I’ve set <code class="language-plaintext highlighter-rouge">M_AXI_AWBURST</code> to <code class="language-plaintext highlighter-rouge">2'b01</code>, also known as <code class="language-plaintext highlighter-rouge">INCR</code>(ement).
It could’ve just as easily been set to <code class="language-plaintext highlighter-rouge">2'b00</code> for a <code class="language-plaintext highlighter-rouge">FIXED</code> address burst
since we’re only issuing singleton requests.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">AXI_INCR</span> <span class="o">=</span> <span class="mb">2'b01</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">M_AXI_AWBURST</span> <span class="o">=</span> <span class="n">AXI_INCR</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_ARBURST</span> <span class="o">=</span> <span class="n">AXI_INCR</span><span class="p">;</span></code></pre></figure>

<p>Similarly, since we’re not using bursts, I can also set <code class="language-plaintext highlighter-rouge">WLAST</code> to one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">M_AXI_WLAST</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>What about AxQOS?  Frankly, this seems to me like a feature of an <a href="https://www.reddit.com/r/FPGA/comments/egkrce/is_axi_too_complicated/">over
designed, overly complex bus</a>
structure.  I have only a small number of designs that have even implemented
QOS.  It’s a challenge to implement, so I’ve really only used it in arbiters
to help arbitration.  Even at that, the four bit comparison in addition to
the arbitration can be a hassle to accomplish, so most of my designs ignore it.</p>

<p>In this case, I simply set it to a fixed constant, zero, but one that
can be adjusted when the design is built if necessary.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_QOS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">M_AXI_AWQOS</span>   <span class="o">=</span> <span class="n">OPT_QOS</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_ARQOS</span>   <span class="o">=</span> <span class="n">OPT_QOS</span><span class="p">;</span></code></pre></figure>

<p>I also do the same thing with <code class="language-plaintext highlighter-rouge">AxPROT</code>.  The difference here is that <code class="language-plaintext highlighter-rouge">AxPROT[0]</code>
must be zero to indicate that this is a data access.  As for the other bits,
secure/non-secure or privileged vs non-privileged, I have yet to find a good
description/reference for what those refer to.  For the time being, therefore,
I’m leaving these bits at zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS</span> <span class="o">=</span> <span class="mh">3'h0</span><span class="p">;</span>
	<span class="k">localparam</span> <span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_PROT</span><span class="o">=</span><span class="n">AXI_UNPRIVILEGED_NONSECURE_DATA_ACCESS</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">M_AXI_AWQOS</span>   <span class="o">=</span> <span class="n">OPT_PROT</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_ARQOS</span>   <span class="o">=</span> <span class="n">OPT_PROT</span><span class="p">;</span></code></pre></figure>

<p>That leaves <code class="language-plaintext highlighter-rouge">AxCACHE</code>.  Here again is a signal for which … I’m not sure what
the right answer is.  The <a href="/doc/axi-spec.pdf">AXI4
specification</a> just leaves me confused.
What I do know is that Xilinx recommends an <code class="language-plaintext highlighter-rouge">AxCACHE</code> value of <code class="language-plaintext highlighter-rouge">4'h3</code>
(normal, non-cacheable, bufferable).  On the other hand, I want to make sure
any lock requests make it all the way to the device.  Therefore, I set
<code class="language-plaintext highlighter-rouge">AxCACHE</code> to zero for lock requests–forcing any exclusive access request
to go through any intermediate caching all the way to the device.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">AXI_NON_CACHABLE_BUFFERABLE</span> <span class="o">=</span> <span class="mh">4'h3</span><span class="p">;</span>
	<span class="k">localparam</span> <span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">AXI_DEVICE_NON_BUFFERABLE</span>   <span class="o">=</span> <span class="mh">4'h0</span><span class="p">;</span>

	<span class="k">assign</span>	<span class="n">M_AXI_AWCACHE</span> <span class="o">=</span> <span class="n">M_AXI_AWLOCK</span> <span class="o">?</span> <span class="n">AXI_DEVICE_NON_BUFFERABLE</span>
				<span class="o">:</span> <span class="n">AXI_NON_CACHABLE_BUFFERABLE</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_ARCACHE</span> <span class="o">=</span> <span class="n">M_AXI_ARLOCK</span> <span class="o">?</span> <span class="n">AXI_DEVICE_NON_BUFFERABLE</span>
				<span class="o">:</span> <span class="n">AXI_NON_CACHABLE_BUFFERABLE</span><span class="p">;</span></code></pre></figure>

<p>You may notice that a lot of these signals just maintain constant values.
That’s a lot of what I’ve seen when working with AXI4: <a href="https://www.reddit.com/r/FPGA/comments/egkrce/is_axi_too_complicated/">there are a lot of
signals that just … don’t need to be
there</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>These are therefore the basic modifications necessary to convert an <a href="/zipcpu/2021/04/17/axilops.html">AXI4-lite
CPU memory controller</a>
into a <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">full AXI4 memory controller</a>.
Perhaps the most important new feature is the support for
<a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a>
accesses via AXI’s exclusive access capability.  Filling in the details of
the size, explaining why we’re not using <code class="language-plaintext highlighter-rouge">AxLEN &gt; 0</code>, and the rest of the
(mostly unused) ports filled out the rest of our discussion.</p>

<p>This is not to say that all AXI4 memory controllers need to look like
<a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">this one</a>.
Indeed, some of our choices only make sense in a minimum logic implementation,
such as <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">this
one</a>
is intended to be.  These include the choice to only issue one request at a
time, as well as the choice not to cache any results.  Lord willing and with
enough interest, we’ll can come back at a later time and discuss improving
upon <a href="https://github.com/ZipCPU/zipcpu/blob/73c6fae1aac6cf941fb44b6612f2a66038917b22/rtl/core/axiops.v">this memory controller</a>
in one of these two fashions.</p>

<p>The problem, however, is that without exclusive access support in the slave
it doesn’t matter whether or not the master (i.e. the CPU) supports it or not.
Xilinx’s Memory Interface Generator (MIG) DDR3 SDRAM controller doesn’t support
AXI exclusive access requests, nor does their block RAM controller.
That means, for now, that if you want exclusive access support you’ll need a
non-Xilinx memory controller.</p>

<p>To handle this need, I’ve converted my <a href="/blog/2019/05/29/demoaxi.html">demonstration AXI4
slave</a> to offer this support.
You can see <a href="https://github.com/ZipCPU/wb2axip/blob/b3145001959c36a206a884243770be5c8c17e5da/rtl/demofull.v#L836-L965">the changes required here</a>.
I’ve also got an SRAM controller with exclusive access support, based upon the
same <a href="/blog/2019/05/29/demoaxi.html">demo AXI slave</a>, that I
anticipate posting as well in the near future.</p>

<p>For now, the changes required to make exclusive access work in a slave will
have to remain the topic of another article.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And if a man also strive for masteries, yet is he not crowned, except he strive lawfully.  (2Tim 2:5)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
