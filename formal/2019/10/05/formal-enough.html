<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Is formal verfication enough, or is simulation required?</title>
  <meta name="description" content="">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2019/10/05/formal-enough.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Is formal verfication enough, or is simulation required?</h1>
    <p class="post-meta"><time datetime="2019-10-05T00:00:00-04:00" itemprop="datePublished">Oct 5, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><tr><td><img src="/img/enough/orconf.png" alt="ORCONF logo" width="161" /></td></tr></table>

<p>While at <a href="https://orconf.org">ORCONF</a> this past weekend, several folks asked
me to what extent I used
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>.
Since I found myself answering this question with some stories from my own
experiences that I had yet to blog about, I thought I’d write
them down and share them here.</p>

<p>Unlike many of my articles, this one will avoid deep dives into code.  We’ll
have plenty of opportunities to do that another time.</p>

<p>That said, I’d like to discuss four design examples: an <a href="https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v">instruction
cache</a> that wasn’t
formally verified, chasing down
a <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a> verification error,
a <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data cache</a> built
with formal from the beginning, and a recent speed upgrade I worked on for an
external <a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">Bus</a> interface.</p>

<h2 id="the-instruction-cache">The Instruction Cache</h2>

<p>The <a href="https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v">instruction
cache</a>
story is <a href="/zipcpu/2017/12/28/ugliest-bug.html">one I’ve told
before</a>.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 1. The ZipCPU Instruction Cache</caption><tr><td><img src="/img/enough/zipcpu-prefetch.svg" alt="" width="240" /></td></tr></table>

<p>The <a href="/about/zipcpu.html">ZipCPU</a>’s <a href="https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v">instruction
cache</a>
is actually one of several possible instruction fetch modules it can be
configured with.  We’ve already discussed the <a href="/zipcpu/2017/11/18/wb-prefetch.html">basic
prefetch</a>, and a more
<a href="/zipcpu/2018/03/21/dblfetch.html">pipelined prefetch</a>
implementation.  The 
<a href="https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v">cache</a> is a
drop-in replacement for either.  Then, within the
<a href="/about/zipcpu.html">ZipCPU</a>, the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>
and the load-store unit (also a plug-in with several options) are arbitrated
between to determine which gets access to the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>
at any given time, as shown in Fig. 2 on the left.</p>

<p>This is just basic CPU design and background.</p>

<p>Now, imagine if you had a program running on a CPU, and the program wasn’t
working.  Whenever you called the first function after a reset, it would fail
with a <a href="https://en.wikipedia.org/wiki/Bus_error">bus error</a> after writing
beyond the end of memory.</p>

<p><a href="/zipcpu/2019/02/04/debugging-that-cpu.html">How might you find this
bug</a>?</p>

<ul>
  <li>
    <p>Desk checking</p>

    <p>A desk check of the failing software clearly indicated that the software
shouldn’t cause a bus error.</p>
  </li>
  <li>
    <p>When I added an instruction to trigger an
<a href="/blog/2017/06/08/simple-scope.html">internal scope</a> and
so to get a <a href="/blog/2017/07/31/vcd.html">trace</a>, the failure
vanished.</p>

    <p>This made me wonder, did I have a
<a href="https://en.wikipedia.org/wiki/Heisenbug">Heisenbug</a>?</p>
  </li>
  <li>
    <p>If I then re-ran the broken program, it no longer failed at this same step
but instead later on.</p>

    <p><a href="/zipcpu/2017/07/14/cpu-debugging-needs.html">Restarting</a>
the <a href="/about/zipcpu.html">ZipCPU</a> a second time brought
the bug back.</p>
  </li>
  <li>
    <p>If I stepped through the code, there was no bug.</p>

    <p>I think this definitely meets the criteria for a
<a href="https://en.wikipedia.org/wiki/Heisenbug">Heisenbug</a>.</p>

    <p>It’s also a bug you can’t let go of to come back to on another day, since it
isn’t clear that you’d be able to reproduce it some other time.  I now had
to find it while it was hot.</p>
  </li>
  <li>
    <p><a href="/blog/2018/08/22/what-is-simulation.html">Simulation</a></p>

    <p>Okay, I gave up.  Maybe
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
would help?</p>

    <p>In this case, the design failed in
<a href="/blog/2018/08/22/what-is-simulation.html">Simulation</a>
as well as in hardware, and with the same symptoms even.  I was on the way
to a solution!</p>
  </li>
</ul>

<p>You can <a href="/zipcpu/2017/12/28/ugliest-bug.html">read more about the story here</a>.</p>

<p>The bottom line was that this bug took me way too long to find, and cost me way
more project time than I wanted to devote to it.</p>

<p>By using
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>, I have
kept this <a href="https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v">instruction cache design
unit</a> from failing
since.  Indeed, I’m now convinced that if I had used <a href="/blog/2017/10/19/formal-intro.html">formal
methods</a> from the get-go,
I would’ve never had this bug in the first place.</p>

<p>In a moment, we’ll come back and test that assumption–since I’ve since built
a <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data cache</a>
using <a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
from the very beginning and there’s a story to share there.  First, though, I
want to share the story of a design that got missed during my switch to
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>.</p>

<h2 id="flash-memory-verification-error">Flash Memory Verification Error</h2>

<table align="center" style="float: right"><caption>Fig 2. A Serial port to Wishbone converter</caption><tr><td><img src="/img/wb-uart-ovw.svg" alt="" width="240" /></td></tr></table>

<p>One of my recent projects involved building an FFT accelerator that
used the <a href="https://riscv.org">RISC-V</a>
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
In this project, like so many others, I needed to write the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>
software to <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
and then have an embedded
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
(i.e. the <a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> in this case)
run that program.  The first step in this process is to <a href="https://github.com/ZipCPU/zipversa/blob/3a99a61b0ed531338ec745c74758f3ca5729ee4c/sw/host/flashdrvr.cpp#L413-L438">read what’s currently
in the flash, and then to compare it to
what I want to be in the flash</a>.  Depending
on the result of that comparison, the flash sector needs to be either erased
(bits turn to ones) and then programmed (specific bits turned to zeros), or
just programmed.  Ideally, if the design already exists in the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a> then nothing more needs
to be done.</p>

<p>In testing, however, when I tried to load the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
a second time with a particular program, the comparison would fail and the
loader would say that the design needed to be loaded again, as shown
in Fig. 3 on the left.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 3. Comparing just-written flash memory failed</caption><tr><td><img src="/img/enough/flash-comparison.svg" alt="" width="240" /></td></tr></table>

<p>This was an indication that the first effort to program the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
had either failed for some reason, or there was a wild pointer error writing
strange things to the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.
Either way, it wasn’t how things were supposed to work.</p>

<p>My first thought was that my <a href="/blog/2019/03/27/qflexpress.html">updated flash
controller</a> had a bug in it,
or that maybe the current
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
I was working with had a unique feature that I wasn’t prepared for.
Much to my surprise, when I tried to reproduce the bug in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
it failed in the exact same place with the exact same symptoms–even though I
was using an <a href="https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp">emulated flash device</a>.</p>

<p>So I turned on the “debug by printf” feature of the <a href="https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp">emulated flash
device</a>,
and created a test: I would load the correct design into this <a href="https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp">emulated
flash</a>,
and then attempt to load my program into the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
a second time.  As before, the second load attempt detected a difference between
the original image and the new image, indicating that what was in the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
didn’t match–when it was supposed to.  However, the debugging statements
indicated that the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>
was never changed from its initial load.</p>

<p>Something else was wrong, and it wasn’t the <a href="/blog/2019/03/27/qflexpress.html">flash
controller</a>.</p>

<p>I restarted the
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>, this
time with <a href="/blog/2017/07/31/vcd.html">tracing</a> enabled.
Many minutes later (it might’ve even been an hour or two …) I had a 22GB
file I could work with.</p>

<p>I shouldn’t need to mention that 22GB is not a
<a href="/blog/2017/07/31/vcd.html">trace file</a> size I like to
work with.  It takes forever to generate/write, and slows down my CPU user
experience.  (I’ve often noticed my favorite music stuttering during this time.)
Further, anything over about 200MB will cause
<a href="http://gtkwave.sourceforge.net">GTKWave</a> to complain.  It also tends to lock
up my local WiFi network anytime I try to debugging on my laptop, when the
<a href="/blog/2017/07/31/vcd.html">trace</a>
is kept on my desktop.</p>

<p>I suppose I should point out that I tried using the
<a href="/blog/2017/06/21/looking-at-verilator.html">Verilator</a>
FST option to generate a compressed trace.  While the result was a shorter
<a href="/blog/2017/07/31/vcd.html">trace</a>, it took even
longer to generate.  That I even have this memory tells you that just running
the <a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
once wasn’t enough.  It rarely is.</p>

<p>The other problem is that it’s really hard to discover where the bug is in a
large <a href="/blog/2017/07/31/vcd.html">trace</a>.</p>

<p>Still, I managed to find the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone request</a>
that read from the address that was causing the fault.  (It was always the
same address, and within this section of the design the address only ever
incremented.)  Much to my surprise, the
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
read the correct value from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>.</p>

<p>Then why did my load software
<a href="https://github.com/ZipCPU/zipversa/blob/3a99a61b0ed531338ec745c74758f3ca5729ee4c/sw/host/flashdrvr.cpp#L429-L430">report</a>
that the <a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
didn’t match the software image, when in fact it actually did?</p>

<table align="center" style="float: right"><caption>Fig 4. The bus to PC processing chain</caption><tr><td><img src="/img/enough/return-path.svg" alt="" width="240" /></td></tr></table>

<p>I needed to trace this result through the design–from where I had found it
reading the correct value from the <a href="https://github.com/ZipCPU/zipversa/blob/master/sim/verilator/flashsim.cpp">emulated flash
device</a>
all the way to the PC host software that was receiving the wrong value, as shown
in Fig. 4 on the right.</p>

<p>Not all of the trace points were easy to work through.  The first trace point
was a
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbufifo.v">FIFO</a>.  I
watched the correct data word go into the
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbufifo.v">FIFO</a>.
I looked up the address it was written to, and then watched the correct word
come out of the
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbufifo.v">FIFO</a>
a significant time later.  No errors yet.</p>

<p>The word then went through another processing stage with no change, just
a delay.  No error there.</p>

<p>Then it went into the <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression algorithm</a>.</p>

<p>Ouch.  Did I really need to dig into the <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression algorithm</a>?
Unlike the prior steps, it would not be easy to “see” the correct word work
its way back.  Compression could fundamentally change the word into something
else.</p>

<p>Like any good engineer, I did what I could to avoid digging into the 
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression algorithm</a>:
I looked at the metadata.  I watched the <code class="language-plaintext highlighter-rouge">stb</code> (valid) and ready (<code class="language-plaintext highlighter-rouge">!stall</code>)
signals.  I quickly noticed data changing when the downstream interface was
still stalled.  Perhaps there was a
<a href="/blog/2017/08/14/strategies-for-pipelining.html">pipeline</a>
bug in the
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression algorithm</a>?</p>

<p>As it turned out, this data change was “normal”–it had just been too long
since I’d written and examined <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">the
code</a>,
and so I wasn’t remembering well what it was supposed to do.</p>

<p>Nevertheless, I stepped into and through all of the steps in the
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression algorithm</a>.  I had to.</p>

<p>Before continuing, let me tell you a bit about this compression scheme.</p>

<p>First, it’s part of my debugging bus protocol.  If you’ve read the <a href="//blog/2017/06/05/wb-bridge-overview.html">introductory
post</a> in my <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">series
on building a debugging
bus</a>, you’ll know that
I have two versions I use.  One is a simplified version that we built together
on the blog.  I call that one the <code class="language-plaintext highlighter-rouge">hexbus</code>, since it is built around
transmitting hexadecimal numbers.  The other is my workhorse debugging bus
implementation, outlined in Fig. 2 above.  This workhorse design includes <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">this
compression
module</a>
within in it.  The compressor
is designed to compress 36-bit codewords, where the first 4-bits contain
meta-information, such as whether the word contains an address update, write
acknowledgment, read-return, etc., and the last 32-bits may contain encoded
data.  After the compression, the 36-bit words are broken into one or more
6-bit words followed a synchronization/end-of-word character, and these are
then mapped into printable, human-readable characters.</p>

<p>The compression itself is based upon one of three schemes.  The first scheme
encodes the last data value into a new codeword that can be sent using a single
byte.  The second scheme encodes any one of the next eight values into what will
become a single byte again.  The third scheme encodes any of the next 512
values into what will become a two byte sequence.</p>

<p>Sadly, this requires a compression table of 521 elements in length.  Since
FPGAs don’t offer block RAM lengths of 521 elements, I use a 1024 element
table to record the last data words I’d sent.</p>

<table align="center" style="float: none"><caption>Fig 5. Serial port compression algorithm</caption><tr><td><img src="/img/enough/basic-compression.svg" alt="" width="560" /></td></tr></table>

<p>How does the compression work?</p>

<ol>
  <li>
    <p>Any time the host (PC) processor sets the address of a bus request, the
new address acknowledgment going back to the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
is used as a signal to reset the compression table to zero length.  This
synchronizes any external program to the compression algorithm, especially
since multiple independent programs may want to interact with the FPGA
design over time.  (Only one will ever interact with the FPGA at any given
time.)</p>

    <p>This is a key point.  Because I was reading from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>
over a long period of sequential addresses, the PC didn’t need to send new
address/synchronization requests.  This also allowed the table to fill up,
like it was supposed to, but perhaps more than it did for me normally.</p>
  </li>
  <li>
    <p>Then, once a 32-bit value is read from the internal
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>, it is
(eventually) sent to the <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression algorithm</a>
as a 36-bit data word.</p>

    <p>This was where I was at, while following the logic through the
<a href="/blog/2017/07/31/vcd.html">trace</a>.</p>
  </li>
  <li>
    <p>The compressor immediately places this 36-bit data word onto the output.</p>

    <p>This looked good–the 36-bit word I had been following was now on the output.</p>
  </li>
  <li>
    <p>However, since the serial port interface tends to be slow, it may take many,
many clocks for this output to be accepted.  During this time, the compressor
goes back through its past memory to see if any of the values it has sent
in the past 521 (uncompressed) samples matches this current one.</p>
  </li>
  <li>
    <p>On a match, the compression algorithm recodes the outgoing data word to
indicate a compressed codeword, and the search stops.</p>

    <p>This was the reason I had initially thought there was a fault in the
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression algorithm</a>–the
output was changing even though the output was stalled.  In this case, it
was the <em>expected</em> behavior.</p>

    <p>It’s amazing what you forget about your code between the time you write it
and the time years later you have to go back and look at it again to
understand what it’s doing when something goes wrong.</p>
  </li>
  <li>
    <p>If no matching code word is found by the time the outgoing word is ready to
be accepted, then the <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression
algorithm</a>
then writes this word to the table and knocks the last word out of the table.
All indices then advance.</p>
  </li>
  <li>
    <p>On a new word, the process starts over from step 2.</p>
  </li>
</ol>

<p>This is sort of the background of how this algorithm is supposed to work.</p>

<p>To find my bug, I walked through every step of this algorithm from within
the trace file.  I had to walk through each of the steps above, through the
algorithm, checking the work at every step.  I then got to the point where the
algorithm found a match from the table at 522 words ago.  (It was easy to
find–since that’s where the module output codeword changed.)  Since the number
of possible compressions is only 521 words ago, a distance further than that
should’ve been dismissed.</p>

<p>It wasn’t.</p>

<p>This was a serious bug.  It took a long time to find it.  The fix, once found
was easy, but finding it?</p>

<p>So, why hadn’t I found it earlier?</p>

<p>Let’s look a little bit deeper, and see the real story.</p>

<p>First, understand that this algorithm was built for <a href="/blog/2017/06/05/wb-bridge-overview.html">one of my very first
digital designs</a>–long
before I started posting all of my designs on
<a href="https://github.com/ZipCPU">GitHub</a>, and even before I was posting them on
<a href="https://opencores.org">OpenCores</a>.   For that early design, I verified this
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression algorithm</a>
as part of verifying a larger project in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
Once that larger project worked, I figured this algorithm worked as well.</p>

<p>After being used very successfully on that first project, this design was
lifted from that project to be used on a next one.  It was then lifted from that
one to be used on another, and another, and so on.  Today, I count its use in
twelve separate designs.  Indeed, over the years that I have used this module
it has become well-honed and well trusted.</p>

<p>Not once during this time did the design ever accumulate any automated tests,
to verify if any changes updating the design maintained the designs
functionality.</p>

<p>This was probably my key mistake.</p>

<p>Sometime later, after I had been using this compression design for some time,
I noticed the design was creating a synthesis warning.  For some reason, the
synthesizer was <a href="https://github.com/ZipCPU/openarty/blob/69b666b68eb49b22f7d32c9501e5ae2e5618f18f/rtl/wbucompress.v#L251">complaining about comparing the found code-word index against
<code class="language-plaintext highlighter-rouge">521</code></a>–the
maximum table offset I had an encoding for.  The warning said there were too
many bits in the comparison.  This didn’t make sense to me.  It should
be a 10-bit comparison, but … perhaps I wasn’t seeing the problem the
synthesis tool was seeing.  So I <a href="https://github.com/ZipCPU/zipversa/blob/977eca075829ec10716fb95086c7e3b65009d67a/rtl/wbubus/wbucompress.v#L251-L252">removed the comparison to make the warning
go away</a>.</p>

<p>Knowing I needed to test the design, I left it in my master debugging bus
repository and forgot about it.  My intent was to “verify it” when it was later
incorporated into another project.</p>

<p>So, here I was, with a broken design and cursing my broken design process.</p>

<p>After way too long staring at this code, I discovered the real bug: I was
<a href="https://github.com/ZipCPU/openarty/blob/69b666b68eb49b22f7d32c9501e5ae2e5618f18f/rtl/wbucompress.v#L251">originally comparing against</a>
<code class="language-plaintext highlighter-rouge">10'h521</code> rather than <code class="language-plaintext highlighter-rouge">10'd521</code>.  Look carefully.  Do you see the difference?
This bug could happen to anyone.  Had I properly created a unit verification
process for this core, I might have caught the bug long ago–or not.  I’m
<a href="/blog/2017/10/19/formal-intro.html">not sure I would’ve been rigorous enough to build a test that would’ve loaded
the FPGA with this
many values</a>
just to test index overflow.
That’s something only the formal solver would be annoying enough to try.</p>

<p>There’s a lesson I learned from jumping out of airplanes that applies well
here: Back in my days as a cadet in the US Air Force Academy, I had the
opportunity to jump out of perfectly good airplanes.  It was a lot of fun.
While we all enjoyed arguing over whether this was a smart or stupid thing to
do, no one argued about whether the reserve parachute was a smart or stupid
thing to have.  Instead, we were all taught that our reserve chute was our
last chance at life–our last chance to live.  We were to protect that reserve
chute with everything we had.</p>

<p>In many ways, the <a href="/blog/2017/06/02/design-process.html">debugging
bus</a> has somewhat of
the same purpose–although certainly not quite as dramatic.  This, plus the
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>
and the <a href="/blog/2018/08/22/what-is-simulation.html">simulator</a>,
are my last lines of defense against
<a href="/blog/2017/05/19/fpga-hell.html">FPGA Hell</a>.  If any of my
designs should’ve been <a href="/blog/2017/10/19/formal-intro.html">formally
verified</a>,
it would be these ones.</p>

<p>As an aside, I recently had the opportunity to formally verify the <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/axilscope.v">AXI
version</a> of my 
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">scope</a>.
Much to my surprise, I also found a subtle bug that had been hiding in the
<a href="/blog/2017/10/20/cdc.html">clock domain crossing</a>
logic of the reset signal in the <a href="https://github.com/ZipCPU/wbscope/blob/master/rtl/wbscope.v">Wishbone
version</a>
I’d been using as well.</p>

<p>My point?  Verify any debugging logic you use.  Getting out of
<a href="/blog/2017/05/19/fpga-hell.html">FPGA Hell</a>
depends upon it.</p>

<p>It’s designs like these, and hard-earned lessons like this one, that continue
to convince me that I need to use <a href="/blog/2017/10/19/formal-intro.html">formal
methods</a>.
Why?  Because I tend spend the longest amount of  time chasing bugs in prior
designs that were never properly verified in the first place.</p>

<h2 id="the-data-cache">The Data Cache</h2>

<table align="center" style="float: left"><caption>Fig 6. The ZipCPU Data Cache</caption><tr><td><img src="/img/enough/zipcpu-lsu.svg" alt="" width="240" /></td></tr></table>

<p>The third story centers around building a <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data
cache</a> for the
<a href="/about/zipcpu.html">ZipCPU</a>.</p>

<p>Indeed, it wasn’t long after building the
<a href="/about/zipcpu.html">ZipCPU</a>
that I decided I wanted to build a
<a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data cache</a>.
Even as far back as when I first presented the
<a href="/about/zipcpu.html">ZipCPU</a>
at <a href="https://orconf.org/2016/">ORCONF</a>, I
was using my spare time to scribble out how this
<a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data cache</a>
would work.  I then scribbled that out and started over and over again and
again.  (It didn’t help that my scribbles were being done in pen, or that
I kept finding so many bugs in the scribbles ….)  I just struggled to get
a grasp on the whole algorithm and, as I’m sure you know, details matter.</p>

<p>That was in 2016.</p>

<p>It wasn’t until later, in 2018, when I was preparing to <a href="/tutorial/formal.html">teach my first course
in formal methods</a>
that I actually managed to get the time and focus to build it from top to
bottom.  At that time, I was experimenting with the <code class="language-plaintext highlighter-rouge">cover()</code> statement, and
getting excited that I could just <code class="language-plaintext highlighter-rouge">cover()</code> the data returned from the
<a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">cache</a>
to get almost all the information I needed.</p>

<p>You can see an example of what this trace might have looked like in Fig. 7,
below.  This particular trace is drawn, however, from the <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">current
implementation</a>,
rather than the original one we are discussing.</p>

<table align="center" style="float: none"><caption>Fig 7. Data Cache Cover Trace</caption><tr><td><img src="/img/enough/dcache8.svg" alt="" width="720" /></td></tr></table>

<p>Notice that in order to <code class="language-plaintext highlighter-rouge">cover()</code> <code class="language-plaintext highlighter-rouge">o_valid</code>, the formal tool needed
to generate a trace that showed:</p>

<ol>
  <li>
    <p>The <a href="/about/zipcpu.html">CPU</a> requesting to read data
from the <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">cache</a></p>

    <p>You can see this in Fig. 7 where <code class="language-plaintext highlighter-rouge">i_request</code> goes high.  (Inside the
<a href="/about/zipcpu.html">ZipCPU</a>, the wire name used is
<code class="language-plaintext highlighter-rouge">i_pipe_stb</code>–but we’re trying to make things readable here.)</p>
  </li>
  <li>
    <p>That data had to be determined to be in a cachable address</p>

    <p>You might notice that it takes two clocks before <code class="language-plaintext highlighter-rouge">o_wb_cyc</code> goes high.
One clock is required to read from the table of
<a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a> tags, the second
to compare the current request against the result.</p>
  </li>
  <li>
    <p>The <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a>.
would’ve been empty at the time, since it was fresh from a restart.  Hence,
the requested address isn’t found in the
<a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a>.</p>
  </li>
  <li>
    <p>The <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">cache logic</a>
would then go out to the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>
and read a <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache line</a>.
into memory.  (As shown above in Fig. 7)</p>
  </li>
  <li>
    <p>Once the <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache line</a>
was in memory, the <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data
cache</a> would then
return the value to the <a href="/about/zipcpu.html">CPU</a>.</p>

    <p>This again requires several clocks, since it costs at least one clock to
write to the cache memory, another one to check that it’s in memory, and
another one to select between several possible cache results, etc.</p>
  </li>
</ol>

<p>I could examine all of this logic from one simple <code class="language-plaintext highlighter-rouge">cover()</code> generated
<a href="/blog/2017/07/31/vcd.html">trace</a>!</p>

<p>Even better, were either the
<a href="/about/zipcpu.html">CPU</a>’s or the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus protocol</a>
ever violated, the <code class="language-plaintext highlighter-rouge">cover()</code> request would fail and I’d get a trace showing
where the failure took place.</p>

<p>Not only that, the proof that I was using verified that the <a href="/zipcpu/2018/07/13/memories.html">“right” value
would always be returned</a>
by the <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">cache</a>.</p>

<p>I had similar <code class="language-plaintext highlighter-rouge">cover()</code> statements in the <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data cache
logic</a>
to verify:</p>

<ol>
  <li>
    <p>Words written to memory would go right through the
<a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">cache</a>
to the bus, since I had chosen a <a href="https://en.wikipedia.org/wiki/Cache_(computing)">“write-through” cache
implementation</a>.</p>
  </li>
  <li>
    <p>Words read or written from <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">non-cachable
memory</a> would also go
straight to the bus</p>
  </li>
</ol>

<p>With no properties violated, <a href="/zipcpu/2017/11/07/wb-formal.html">bus protocols
maintained</a>, and a series
of <code class="language-plaintext highlighter-rouge">cover()</code> statements in hand, I was really excited to go and run
<a href="https://en.wikipedia.org/wiki/Dhrystone">Dhrystone</a> to see how
my performance might have improved.</p>

<p>Any guesses as to what happened?</p>

<p>Much to my shock and surprise, the CPU with its brand <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">new data
cache</a>
installed froze when I ran it in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
Right out of the gate.  After staring at the screen in complete puzzlement,
I restarted the
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
with <a href="/blog/2017/06/21/looking-at-verilator.html">tracing enabled</a>, killed it, and then pulled the
<a href="/blog/2017/07/31/vcd.html">trace</a>
up into <a href="http://gtkwave.sourceforge.net">GTKWave</a>.</p>

<p>It didn’t take much work to find when the
<a href="/about/zipcpu.html">CPU</a> froze.</p>

<p>As it turns out, I had verified every part of the <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data
cache</a>’s operation
except one:  I never verified that the busy line would clear after
returning its result to the <a href="/about/zipcpu.html">CPU</a>.</p>

<p>Ever since, I no longer <code class="language-plaintext highlighter-rouge">cover()</code> a core just returning the “right-answer” any
more.  Instead, I will always create a
<a href="/blog/2017/07/31/vcd.html">trace</a>
showing the core returning to idle after the “right-answer” has been found.
Even better, my current <code class="language-plaintext highlighter-rouge">cover()</code> checks will look into a minimum of two
requests going through the core, so I can examine what sort of overall
throughput I might expect.</p>

<p>When trying to answer the question of whether or not formal is enough on its
own, this was a valuable lesson learned.  Since this time, however, I haven’t
found any further bugs in this core–in spite of updating it several times.
Indeed, looking back over the <a href="https://github.com/ZipCPU/zipcpu/blame/master/rtl/core/dcache.v">commit
log</a>, it looks
like all of the subsequent commits had to deal with tool issues–rather than
any more functional issues.</p>

<h2 id="the-new-picorv32-front-end">The New PicoRV32 Front End</h2>

<table align="center" style="float: left"><caption>Fig 8. A basic PicoRV32-based Accelerator</caption><tr><td><img src="/img/enough/zipversa.svg" alt="" width="480" /></td></tr></table>

<p>The last story focuses on the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> CPU.  In this case, a
customer had asked me to create a basic FPGA accelerator design, such as the
one shown in Fig. 8 on the right.  I chose to demonstrate this using an FFT
accelerator.  As built, the board was to receive data from GbE network, and
then the <a href="https://riscv.org">RISC-V</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
within the design would then push that data through the on-chip accelerator.</p>

<p>Of course, in the end, nothing works as desired.  The first problem I had was
the DDR3 SDRAM.  Since the goal of the project was to use entirely open source
tools, logic, and software, I needed an <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbddrsdram.v">open source DDR3
controller</a>
for an ECP5.  Since this wasn’t initially available, the team chose to skip the
DDR3 SDRAM.  (There’s now a <a href="https://github.com/enjoy-digital/litedram">litedram
controller</a> that <a href="https://github.com/enjoy-digital/litedram/blob/master/litedram/phy/ecp5ddrphy.py">works with the
ECP5</a>.)</p>

<p>Sadly, this had consequences.</p>

<p>The first consequence was that the <a href="https://sourceware.org/newlib/">newlib
C-library</a> didn’t fit into my 64kB of
block RAM.  That meant that the CPU’s instructions would need to be placed into
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash memory</a>.
As you may recall from our discussions about building a <a href="/blog/2019/03/27/qflexpress.html">flash
controller</a>,
a QSPI flash memory requires 8 serial port clocks (6 for address, and then
2 dummy clocks) just to start a transaction.  Another 8 clocks are needed
to read any 32-bit instruction word.</p>

<p>Making matters worse, the ECP5 chip the project ran on didn’t provide first
class access to the flash clock pin.  I needed to go through a logic block
to get access to it, and that block didn’t offer access to the DDR I/O
primitives <a href="/blog/2019/03/27/qflexpress.html">my controller</a>
needed for high speed access.  In other words, I’d need to suffer a minimum of
32 clocks per instruction access, since each SPI clock would cost two system
clocks.  When all was said and done, interfaces written, bus delays added up,
the cost ended up being closer to 38 clocks per instruction access.</p>

<p>The next piece of this problem surrounded the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>’s interfaces.  Unlike the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">instruction
pre-fetch interface</a> I
used for the <a href="/about/zipcpu.html">ZipCPU</a>, the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>’s bus interface involves
setting a valid line and an address line.  The environment is then expected to
go look up what ever is at that address, and then to return it to the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
Further, the only difference between reading and writing is that the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> sets the write select
bits when writing–so the wrapper needs to check these as well.  Finally, the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> also includes a flag to
indicate an instruction read request rather than a memory request.</p>

<p>While I had a <a href="/zipcpu/2018/07/13/memories.html">block RAM
controller</a> and a <a href="/blog/2019/03/27/qflexpress.html">flash
controller</a>
sitting on a shelf, I didn’t have a
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/picorv/wb_picorv32.v">bus control
wrapper</a>
that worked with <a href="/zipcpu/2017/11/07/wb-formal.html">AutoFPGA’s version of
Wishbone</a>.
Building this was one of the project deliverables.</p>

<p>You can see my <a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/picorv/wb_picorv32.v">first draft of this wrapper
here</a>. 
On any new bus request, the design sends the request to the
<a href="/zipcpu/2017/10/05/autofpga-intro.html">AutoFPGA</a> generated
bus interconnect, and then returns the result to the
<a href="https://github.com/cliffordwolf/picorv32">CPU</a>.</p>

<p>The problem with this design is that every instruction fetch is a separate
and independent bus transaction.  As a result, when the <a href="/blog/2019/03/27/qflexpress.html">flash
controller</a>
sees that there are no further fetches coming, it ends the burst read.
Subsequent reads will require sending the address and mode bits again.  That’s
12 clocks for the address bits, and 4 more clocks for the mode bits, for a
total of 16 extra clocks per instruction that wouldn’t be needed were
multiple requests made one after another.</p>

<p>Therefore, once I had completed the requirements of the contract, I took a
moment to see if I might build a better
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> interface.</p>

<p>The new design <a href="/zipcpu/2018/03/21/dblfetch.html">followed the techniques I discussed
here</a>, with just a
couple of differences.</p>

<ol>
  <li>
    <p>First, I required an extra clock to know if the requested address was
the result of a <a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch
instruction</a>.
In <a href="/zipcpu/2017/11/18/wb-prefetch.html">my own pre-fetch interface
design</a> the
<a href="/about/zipcpu.html">CPU</a> exports a wire indicating any
time the <a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>
has changed as a result of a
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">branch</a>.  Not so
with the <a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>.  I needed
to detect this in my bus wrapper.</p>
  </li>
  <li>
    <p>I also built a deeper lookup.  Instead of looking up only two instruction
words, and then looking up the next word anytime one of those two were
accepted, I chose to lookup up four words regardless of how fast the
<a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> consumed them.</p>

    <p>This was a draft design after all, to see if this might help, not something
final that was going to be part of this contract.</p>
  </li>
  <li>
    <p>Finally, the <a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>
muxes both instruction and data requests together across the same external
<a href="https://github.com/cliffordwolf/picorv32">CPU</a>
interface.  My updated <a href="https://en.wikipedia.org/wiki/Prefetching">prefetch</a>
routine needed to handle both types of requests.  Only the instruction
stream, where I could predict the next instruction address with some
certainty, would be partially
<a href="https://en.wikipedia.org/wiki/Cache_(computing)">cached</a>.</p>
  </li>
</ol>

<p><a href="/formal/2018/07/14/dev-cycle.html">As with any formal proof</a>,
I started with the <a href="/zipcpu/2017/11/07/wb-formal.html">bus
properties</a>.  I then
added further properties to include properties I felt necessary for
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
and also created properties to describe the CPU side of the interface.</p>

<p>When I was confident the design worked using
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>,
I switched to simulation and immediately my “working” programs (i.e. <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">Hello
World</a>) stopped
working.</p>

<p>What happened?</p>

<p>In this case, the software called for a data load during one of my set of four
instruction fetches.  Instead of waiting for the series of four instruction
fetches to finish and then initiating a request for the data, the core
returned the value from the ongoing instruction fetch to the data port.</p>

<p>Why?  Because I returned a data value on any bus acknowledgment … a simple
oversight.</p>

<p>Couldn’t formal methods have caught this?</p>

<p>Yes, they could’ve and they should’ve.  Why didn’t they?  Because I got sloppy.
I was trying to do something quick, and I had tried to short-circuit the
<a href="/zipcpu/2018/07/13/memories.html">memory property check</a>
on the data bus in order to build this design on the quick.</p>

<p>Lesson learned.</p>

<h2 id="the-project-with-no-bugs">The Project with no bugs</h2>

<p>The past four project stories have all involved finding ugly bugs in them.</p>

<p>I should mention before going on that I’ve also had the experience where a
formally verified
project has no logic bugs in it.</p>

<p>Tool issues?  Yes.  What works with the Yosys parser doesn’t necessarily work
with the Verific parser, and even that doesn’t necessarily work with Vivado or
Quartus.  What about language “standards”?  Yeah.  However, I should point out
that those who have tried my <a href="/formal/2018/12/28/axilite.html">formally
verified</a>
<a href="/blog/2019/05/29/demoaxi.html">AXI</a> or
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite slaves</a>
have often commented that they’ve worked the first time.</p>

<p>The key takeaway here is that it is possible to fully verify something using
formal methods alone.  I just need to learn how to reproduce this success in
all of my designs.</p>

<h2 id="lessons-learned">Lessons Learned</h2>

<p>Every year that I’ve gone to <a href="https://dvcon.org">DVCON</a>, there’s been a
contractor or two selling “formal <a href="https://en.wikipedia.org/wiki/Signoff_(electronic_design_automation)">sign-off</a>”
services.  I understand this to mean that by using their services, they will use
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
to verify your design to the point where it can be trusted enough for an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>
<a href="https://en.wikipedia.org/wiki/Tape-out">tape-out</a>.</p>

<p>That’s awesome.  I’ll be honest, I look up to anyone who can stand by such a
claim and ability.</p>

<p>However, as illustrated from the examples above, this has not been my
experience in general.  While it has always been my goal, and while I’ve
had a success or two doing this, I haven’t yet been able to fully eliminate
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
simulation from my personal design process.</p>

<p>That said, these four examples above do illustrate some important takeaways:</p>

<ol>
  <li>
    <p>There’s always a need for
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
in <a href="https://en.wikipedia.org/wiki/Integration_testing"><em>integration</em> testing</a>.</p>

    <p>To date, I’ve only ever formally verified design <em>components</em>, never
entire designs.  The larger the component has been, the more difficult the
formal proof becomes.  As a result, I’ve always had a need to use
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
to test an entire design.</p>
  </li>
  <li>
    <p>Most of my simulation testing I’ve done has tended to be rather ad-hoc.
My tests tend to be designed towards only ever demonstrate a single working
path through my design.  Indeed, simulations in general <em>never verify every
working path</em> within a design.  Only formal does that.</p>

    <p>The best evidence for this is the fact that I never sufficiently tested
whether element 521 could be properly returned by the compression algorithm,
but that element 522 would be properly rejected.</p>

    <p>I am looking forward to fixing some of my personal test-script issues by
using <a href="https://github.com/YosysHQ/mcy">Symbiotic EDA’s new
mutation engine</a>–but we’ll save the
discussion on how to use that engine for a later date.</p>
  </li>
  <li>
    <p>Don’t forget to <code class="language-plaintext highlighter-rouge">cover()</code> the design returning to idle.</p>

    <p><code class="language-plaintext highlighter-rouge">cover()</code> is great for proving that an operation can complete, or that you
haven’t assumed away the answer.  However, just verifying that a design will
return the correct answer upon request isn’t enough–you have to <code class="language-plaintext highlighter-rouge">cover()</code>
the return to the beginning or idle state.</p>

    <p>As I mentioned above, I also like checking 2-3 transactions via a <code class="language-plaintext highlighter-rouge">cover()</code>
statement, so that I can measure best-case throughput as well.</p>
  </li>
  <li>
    <p>Even though the two formally verified designs above still needed to be
<a href="/blog/2018/08/22/what-is-simulation.html">simulated</a>,
and even though new bugs were caught in that
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
check, I never found more than one bug in each.</p>

    <p>The <a href="https://github.com/ZipCPU/blob/master/rtl/core/dcache.v">data cache</a>
has now worked for me for over a year without further logic problems.  (There
were some <a href="https://github.com/ZipCPU/zipcpu/blame/master/rtl/core/dcache.v">tool
incompatibilities</a>
…) The <a href="https://github.com/ZipCPU/blob/master/rtl/core/pfcache.v">instruction
cache</a>
has likewise been formally verified, and it has worked for much longer
without problems.  Indeed, it’s undergone several revisions without
suffering from any more bugs caught during
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.</p>
  </li>
  <li>
    <p>Individual design components need their own verification infrastructure.</p>

    <p>This was one of the painful lessons I learned from the bus return
<a href="https://github.com/ZipCPU/zipversa/blob/master/rtl/wbubus/wbucompress.v">compression algorithm</a>.
In this case, I had tested it as part of a larger design and missed the
difference between <code class="language-plaintext highlighter-rouge">10'h521</code> and <code class="language-plaintext highlighter-rouge">10'd521</code>.  I then copied it from one
design to the next, to the next, to the next, and then needed to make a
change to it.  Having no method of testing the component, I instead queued
a minor disaster up for myself some time later.</p>

    <p>Now, sadly, I’ve learned that I need to go back through this entire
debugging bus implementation in order to add in proper verification
logic–logic that should’ve been created when the design was
initially created years ago.</p>
  </li>
  <li>
    <p>There’s not a single bug listed above that could not have been caught using
either <a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
<em>or</em> an appropriate
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.</p>

    <p>This goes both ways.  Any bug caught via
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
but not <a href="/blog/2017/10/19/formal-intro.html">formal</a>, can
be turned into a formal property to be subsequently checked.  Any bug caught
via <a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
but not
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
can be used to generate a better test script.</p>

    <p>Indeed, my guess is that <a href="/formal/2019/09/06/axi-story.html">now that I’ve found bugs that weren’t caught by
Xilinx’s AXI VIP</a>,
they’ll quickly adjust their product.  I certainly would if I were them.
I also expect that once these updates go through, that things that pass
their AXI VIP will look like they work again, the demonstration designs
will get fixed … and all will be look good again on the surface.  However,
the moment you make one change to those designs, everything will be up in the
air again.</p>
  </li>
  <li>
    <p>Just because something “works” in practice, doesn’t truly mean it “works”</p>

    <p>The reference to <code class="language-plaintext highlighter-rouge">10'h521</code> rather than <code class="language-plaintext highlighter-rouge">10'd521</code> existed in the compression
scheme since it was written.  It was there for many years, waiting until
just the right sequence triggered it.</p>

    <p>Although I hadn’t noticed this bug earlier, the design never truly worked
earlier either.</p>
  </li>
  <li>
    <p>The really ugly lessons learned come only after working with a design for
some period of time.</p>

    <p>This is a sad reality of IP core development.  Just because a given IP core
works in some designs, just because it passes the threshold for the
instructor to grant an <code class="language-plaintext highlighter-rouge">A</code>, or for the customer to accept the design work,
doesn’t mean it will work in all designs.  This is fundamentally the problem
with
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>–you
can’t test everything.</p>

    <p>The good news is that the longer you use a given core, then (hopefully) the
closer it gets to perfection.  That is, at least until you need to rewrite
it.</p>
  </li>
</ol>

<p>Let me share one final thought:  If you choose to cut corners in verification,
like I did to test the updated
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a> wrapper
for the <a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a>, then it doesn’t
matter whether when using
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
techniques or <a href="/blog/2017/10/19/formal-intro.html">formal
methods</a>.  Either way,
you are setting yourself up for getting burned later on.</p>

<p>The good news, though, is that by using the updated wrapper I could speed up
the <a href="https://github.com/cliffordwolf/picorv32">PicoRV32</a> by a factor of 2x.</p>

<p>We’ll leave that thought, though, to be the topic of another article.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And he began to speak unto them by parables. A certain man planted a vineyard, and set an hedge about it, and digged a place for the winefat, and built a tower, and let it out to husbandmen, and went into a far country. (Mark 12:1)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
