<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>AXI Verification, the story so far</title>
  <meta name="description" content="ORCONF 2019 is coming up, and I’m planning on presentingslides on the topic of formally verifying AXIinterfaces.  My intent wasjust to share some of the bugs...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2019/09/06/axi-story.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">AXI Verification, the story so far</h1>
    <p class="post-meta"><time datetime="2019-09-06T00:00:00-04:00" itemprop="datePublished">Sep 6, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><a href="https://orconf.org">ORCONF 2019</a> is coming up, and I’m planning on presenting
slides on the topic of <a href="/formal/2018/12/28/axilite.html">formally verifying AXI
interfaces</a>.  My intent was
just to share some of the bugs I’ve found and so to encourage folks to use
formal verification tools, such as the
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a> tool that I’ve been
using.  However, as I started to put the story together, I also started to
realize just how important this topic is.</p>

<p>Here’s the bottom line: AXI is very difficult to verify using traditional
simulation based methods.  How difficult is it?  So difficult that many of the
major vendors out there have gotten it wrong.</p>

<p>Let me back up, though, and walk you through some of the details.</p>

<h2 id="axi-whats-that">AXI, what’s that?</h2>

<p>It begins with the chip manufacturing industry.  There are a lot of companies
out there building their own special and secret sauce into digital electronics.
The reality, though, is that many of the tasks these chips are responsible
for performing are challenging to do in raw digital hardware.  It’s not that
they cannot be done, but rather that it’s a lot easier to do them in software.
That means that if you want to build a custom silicon widget, you are likely
to want to include a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
into your custom widget as well.</p>

<p>While building a basic
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
may be a college student’s class project, building and maintaining the
assembler, linker, compiler, debugger, and indeed the whole tool chain is a
task few design houses want to take on for themselves.  It’s just easier to
purchase someone else’s
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
rather than to handle all of this work yourself.</p>

<table align="center" style="float: right"><caption>Fig 1. A basic AXI bus structure</caption><tr><td><img src="/img/axi-story/axi-in-everything.svg" alt="" width="360" /></td></tr></table>

<p>One of the most popular
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
in the embedded sub-chip IP market is the
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>.  While
<a href="https://riscv.org">RISC-V</a> may well give
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
a run for their money, much of the industry has already standardized
around a set of <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a> bus
protocol standards drawn from the <a href="https://en.wikipedia.org/wiki/Advanced_Microcontroller_Bus_Architecture">AMBA bus protocol
set</a>.
Of these, the high bandwidth standard is clearly
<a href="/blog/2019/05/29/demoaxi.html">AXI</a>.  As a result, if you
want to connect your secret sauce to a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> hidden inside
your proprietary integrated circuit technology, you are likely going to be
using an <a href="/blog/2019/05/29/demoaxi.html">AXI bus</a> to connect
the pieces together.</p>

<p>Recognizing this reality, and the fact that
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGAs</a> are
often used to test the logic within integrated circuits before <a href="/blog/2017/10/13/fpga-v-asic.html">burning
them into actual hardware</a>,
the two major
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> vendors
have been offering <a href="/blog/2019/05/29/demoaxi.html">AXI</a>
based tooling for some time.  This includes not only the
<a href="/blog/2019/07/17/crossbar.html">AXI bus fabric</a> that connects
everything together, but also several basic design components like <a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM
controllers</a>, memory movers,
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>
engines, <a href="/blog/2018/11/29/llvga.html">video controllers</a>,
<a href="/blog/2019/03/27/qflexpress.html">flash controllers</a>, as well
as example designs so that their users can get more value from their hardware.
These basic <a href="/formal/2019/05/13/axifull.html">AXI</a>
designs are offered for free to anyone who uses their tools.  As a result, the
example designs in particular have become rather ubiquitous–so much so that
any error in one or the other tends to show up over and over again in the
code of anyone who used that example as a foundation for their own work.  Again,
this shouldn’t be surprising to anyone.</p>

<h2 id="formal-methods">Formal methods</h2>

<p>This was where I entered the picture.  In October, 2017, <a href="/blog/2017/10/19/formal-intro.html">I tried out formal
methods</a> for the
first time on what I thought was a fairly basic and simple design.  My plan
was just to write a review about some new “formal verification” fad and then
to go back to <a href="/blog/2017/06/02/design-process.html">digital design the way I had been doing
it</a>.  My plan changed
when the tool found bugs in my design.  So I then tried applying the tool to
another one of my “working” designs.  The same thing happened, the tool found
bugs in it.  Valid bugs.  <a href="/blog/2018/01/22/formal-progress.html">Over and over I applied the formal
tools</a>
to my designs and found more and more bugs.</p>

<p>To understand how significant these bugs were, consider these: an
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
<a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">controller</a>
that might fetch the wrong memory address, a
<a href="/about/zipcpu.html">CPU</a> <a href="https://en.wikipedia.org/wiki/Cache_(computing)">instruction
cache</a> that <a href="/zipcpu/2017/12/28/ugliest-bug.html">returned the
wrong instruction</a>,
or even an <a href="/dsp/2018/10/02/fft.html">FFT</a> that worked for one
set of sizes and bit widths but not for others.  The list goes on.</p>

<p>Eventually, I stopped verifying my designs after the fact and <a href="/formal/2018/07/14/dev-cycle.html">started going
straight to formal verification tools before ever picking up a
simulator</a>.  Design has
never been <a href="/formal/2019/08/03/proof-duration.html">so fast</a>
or so easy as a result.  Indeed, the <a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/dcache.v">data
cache</a> that I
had wanted to build for years suddenly came together inside of two weeks.</p>

<p>By the end of 2018, I’d also struggled many times to build my own AXI
interface components.  In <a href="/blog/2019/04/27/axi-addr.html">one particularly painful
example</a>, I was forced
to deliver a design to a customer that didn’t live up to the promises I had
made to him.  Even now, most of my work has been done using
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>–it’s much
<a href="/zipcpu/2017/05/29/simple-wishbone.html">simpler to use</a>.
Sadly, though, if you want to interact with the modern
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>+<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
SOC chips like either Xilinx’s Zynq or one of <a href="/blog/2018/02/09/first-cyclonev.html">Intel’s
SOC</a>s, you will
(eventually) <a href="/blog/2019/04/27/axi-addr.html">need to learn to speak
AXI</a>.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 2. Verification using a formal property file(s)</caption><tr><td><img src="/img/axi-story/fp-file.svg" alt="" width="320" /></td></tr></table>

<p>As I mentioned above, my first attempts at building AXI components dismal
failures.  My second set of attempts weren’t much better.  Finally, somewhere
around last Christmas time, I started picking up AXI and formal verification
together.  I first <a href="/formal/2018/12/28/axilite.html">built a set of formal properties for
AXI-lite</a>, and then again
later for <a href="/formal/2019/05/13/axifull.html">AXI</a>.  These
properties make it easy to verify <a href="/blog/2019/05/29/demoaxi.html">AXI
bus</a> components–much easier
than <a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
alone.  The neat thing about this approach is that the property files can then
be reused from one AXI design to another with only minimal configuration
and set up.  Hence, once I built one design, getting the next one right became
easier.</p>

<p>Not knowing whether or not I understood the bus standard well enough, my first
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a> and
<a href="/formal/2019/05/13/axifull.html">AXI</a> verification
projects were to verify any publicly available code I could get my hands on.  I
started with Xilinx’s example code, and then moved on to verifying several
projects on Github, and finally looked into Intel’s example AXI code.
I was expecting to find examples that met the <a href="/doc/axi-spec.pdf">AXI
standard</a> that I could then learn from.</p>

<table align="center" style="float: right"><caption>Fig 3. Most example designs have two parts</caption><tr><td><img src="/img/axi-story/ex-design.svg" alt="" width="320" /></td></tr></table>

<p>Let me pause at this point to describe what I mean by an “example” design,
or even a “demonstration” design.  These are vendor provided example logic
designs, such as the one illustrated in Fig. 3 on the right and typically
written in Verilog, VHDL, or both, that show the proper
interaction between a bus component and the bus.  Typically, they are written
in a fashion so that you can adjust a user logic section however
you might like, while another portion of the design provided by the vendor
handles all of the more difficult AXI bus interaction logic.</p>

<p>Much to my surprise, most of the cores I examined had bugs in them.
I’ve <a href="https://twitter.com/ZipCPU">tweeted</a> about many of these, and so now
I’m collecting these examples into some slides that I can present at
<a href="https://orconf.org">ORCONF</a> in just a couple of weeks.</p>

<h2 id="its-worse-than-a-software-bug">It’s worse than a software bug</h2>

<p>One of the jokes in the flying world is that pilots need to maintain “the
ratio”: one safe landing for every take off.  AXI bus interactions are
in many ways no different, there needs to be one response for every request.
Further, just as most airplanes don’t offer ejection seats or parachutes,
AXI doesn’t offer a “bus abort” capability.  As a result, if you fail to
keep the “ratio” then really “bad” things will happen.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 4. Every request must get a response</caption><tr><td><img src="/img/axi-story/request-response.svg" alt="" width="320" /></td></tr></table>

<p>What kind of “bad” things are we talking about?  In the case of a bus,
a bus master makes a request–whether or read or write–and the slave responds.
In the case of AXI, the fact that it has no abort capability means that a master
must wait for a response until it arrives.  The standard doesn’t allowed it to
time out and give up after waiting a second, minute, hour, or year.  Even
if the response gets dropped or otherwise becomes missing, the master must
still wait for a response.</p>

<p>Sadly, I discovered the problem with this in my first <a href="/blog/2018/02/09/first-cyclonev.html">Cyclone-V
SOC</a>
design.  At one point when I had a mistake within my own logic so that the
design didn’t respond to the bus like it was supposed to, the bus and the
<a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
driving the bus, locked up hard.  Only a reset, forcing a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
reboot, fixed the bug.</p>

<p>In my example, I was lucky.  Knowing that there was a bug in my design, I was
able to then turn around and <a href="/blog/2017/06/21/looking-at-verilator.html">simulate my
design</a> and
find the bug.  I haven’t always been this lucky, and things could’ve been much
worse.  Had I not been able to reproduce the bug in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
I might have ended up stuck in <a href="/blog/2017/05/19/fpga-hell.html">FPGA
Hell</a> myself, staring
at a flawed design with no idea how to fix it.</p>

<p>Others haven’t been so lucky.</p>

<p>Even among those who ask for help there are a lot of problems that can’t be
solved by a disinterested stranger looking over unfamiliar logic.  It’s only
gets worse when you have no clue where to start looking, as might happen
with a design that suddenly locks up the whole system.</p>

<p>You need to understand, this isn’t a
<a href="https://en.wikipedia.org/wiki/Kernel_panic">kernel panic</a>
type of bug.  We’re not talking about the
<a href="https://en.wikipedia.org/wiki/Blue_Screen_of_Death">blue sceen of death</a>
here either.  Nor are we talking
about bugs where your <a href="https://en.wikipedia.org/wiki/Segmentation_fault">application just
failed</a>.  No, we are
talking about something even more severe.  A fault in the
<a href="/formal/2019/05/13/axifull.html">AXI bus</a> structure
whereby a component fails to respond properly is catastrophic.  The result
will be a whole system crash so hard that only a power cycle can fix it.</p>

<p>Given that <a href="/blog/2017/07/08/getting-started-with-wbscope.html">I use the bus for
debugging</a>,
such a crash leaves me blind to the cause.</p>

<table align="center" style="float: right"><caption>Fig 5. Two types of catastrophic bugs</caption><tr><td><img src="/img/axi-story/catastrophic-two-types.svg" alt="There are two types of catastrophic bugs: those that return too few responses, and those that return too many" width="320" /></td></tr></table>

<p>So what kind of bugs did I find?  I found both types of catastrophic bugs.  Not
only did I find peripherals that didn’t produce as many responses as requests
they had received, but I also found bus masters that would drop requests before
the bus had accepted them.</p>

<p>In one <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> I examined
from a major vendor, two load or two store instructions, back to back, would
cause a transaction to be dropped if the interconnect wasn’t immediately ready
to receive to the request.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 6. An interconnect bug</caption><tr><td><img src="/img/axi-story/buggy-interconnect.svg" alt="Interconnect routes a slaves response to the wrong master" width="480" /></td></tr></table>

<p>Worse, I even found an
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
something that connects multiple masters to multiple peripherals such as the
one shown in Fig. 6, where a request from one master would get sent to the
correct slave, but then the response from the slave would be returned back
to a different master.</p>

<p>It wasn’t pretty.</p>

<p>Indeed, I found bugs in a very large percentage of the cores I examined.</p>

<p>It didn’t help that many demonstration cores, and how-to blog articles
I found had bugs in their example cores that were then copied into various
user designs.  Neither did it help that the example designs from <em>both</em> major
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
vendors had catastrophic bugs within them.</p>

<p>As you might imagine, I was rather perplexed by this.  In many ways, none of
this made any sense.  If these problems were really so bad, how was it that
no one had noticed them?</p>

<p>One possibility was that each vendor only checked their cores in their own
environment, and somehow the environment was masking the bugs.  As an example,
some of the bugs I found would be only triggered if the bus was ever used in
a particular configuration.  I also found that one vendor had crippled
the throughput of their interconnect–perhaps because no one really knew who or
what was responsible for the user bugs.
[<a href="/zipcpu/2019/02/09/cpu-blinky.html">1</a>] [<a href="/blog/2019/05/29/demoaxi.html">2</a>]</p>

<p>So I started browsing and participating in various forums.</p>

<h2 id="working-the-forums-for-answers">Working the forums for answers</h2>

<table align="center" style="float: right"><caption>Fig 7. Digilent's Popular Contributors</caption><tr><td><img src="/img/axi-story/leader-board.png" alt="" width="296" /></td></tr></table>

<p>Back in the beginning, when I first started to try to sell my services as an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design engineer, I worked <a href="/digilent/2017/05/18/most-common-digilent-support-requests.html">Digilent’s
forums</a>
fairly hard in the hopes that I might gain some free publicity and perhaps
even a contract.
Even to this date I’m one of their leading all time contributors, even though
I’ve stopped working the forum as hard and the forum moderator’s have since
caught up and one has passed me.
Since I had just left the military service, I was hoping this might be a way
to find some commercial work.  The technique worked well, since I found
two contracts, several long-term business relationships, and even some free
hardware as a result of it–such as a <a href="https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications">Nexys Video
board</a>
and even a <a href="/blog/2017/09/14/even-i-get-stuck.html">Digital
Discovery</a>.
This time, however, I worked up the chain on the major vendor’s forums, rather
than those of their outlets.  Specifically, I was looking for examples of the
bugs listed above, or if not then I was hoping to discover why they weren’t
being triggered.  I was also looking for example designs to check my formal
property files against.</p>

<p>While much of what I found was fairly benign, such as brand-new students
struggling to figure out their engineering design homework, there were
also many professional design engineers participating in these forums and
asking for help regarding the problems they had come across.</p>

<p>In one conversation, I came across a user asking for help whose AXI slave
design wasn’t working.  When I asked if he would try my own <a href="/blog/2019/01/12/demoaxilite.html">formally verified
design</a>,
he tried it and the bugs went away.  Sadly, we never found or identified the
bug(s) in his own (VHDL) code–perhaps because he never shared enough of his
design.  Incidentally, when I offered him <a href="/blog/2019/01/12/demoaxilite.html">my own design to
try</a>,
I never told him that this was the first time the core had been tried in either
hardware or simulation.  It “just worked” the first time.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 8. Updating software breaks the hardware design</caption><tr><td><img src="/img/axi-story/new-software.svg" alt="" width="240" /></td></tr></table>

<p>In another conversation, an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design engineer had built a design and delivered it to his product team in
a “working” condition for the software programmer to take over.  The design
contained a <a href="https://en.wikipedia.org/wiki/MicroBlaze">MicroBlaze</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> and whatever
application sauce they were putting into it, such as is shown in Fig. 8.  This
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design engineer then left the company.  Some time later, the software
engineer made some changes to his
<a href="https://en.wikipedia.org/wiki/MicroBlaze">MicroBlaze</a> software–not the
hardware design, but the software for the
<a href="https://en.wikipedia.org/wiki/MicroBlaze">MicroBlaze</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
within it.  The result was that the design locked up following two adjacent
store instructions and no one could understand why.  This pattern also matched
the bugs that I had found.</p>

<p>Someone else posted on a <a href="https://reddit.com/r/FPGA">Reddit forum</a> that their
design wasn’t working, curious if anyone had seen similar problems before.  I
asked if he had formally verified his design.  Instead of responding to
me, he turned around and posted on the vendor’s forum no longer asking but
now declaring that their
interconnect was broken.  Again, I asked if he had formally verified his
design or, if not, if he’d release his source code and I’d check it for him.  He
then proceeded to ignored me for a second time and instead posted a trace that
was supposed to show the bug.  When you looked closer at the trace, however,
you found a bug within his core and not the interconnect: one request was
creating two responses.  His design wasn’t keeping up the “ratio”.  Formal
methods would’ve caught that.</p>

<p>Another engineer posted, wondering what was wrong with the vendor tools.
When I asked if he could or would share his source, he refused.  Sadly, this
is a rather common though unfortunate answer.  Digital logic is designed and
sold, and protecting the market tends to keep corporations tight-lipped about
their secret algorithms–since it represents real money to them.  Instead,
this engineer offered a “sanitized” version of what he was doing.  With the
<a href="/formal/2019/04/16/axi-mistakes.html">experience I had gained from formal
methods</a>, I could
clearly see the bug in even his sanitized design–although I have to believe
it must’ve passed his test bench for him to even open up like that.</p>

<p>When I dug further into the forums, I found several examples of folks who had
written in, not knowing why their design was failing, but for whom no one had
responded.</p>

<p>I also looked into any example code I could find.  I noticed that most of the
examples I found followed the vendor’s examples.  This made it fairly easy
to verify, since once I had verified one example any others that looked like
it tended to have the same bugs.</p>

<table align="center" style="float: right"><caption>Fig 9. Vendor interconnect logic, with multiple internal implementations</caption><tr><td><img src="/img/axi-story/vendor-interconnect.svg" alt="" width="320" /></td></tr></table>

<p>At one point, I even looked into a major vendor’s interconnect structure.  I
was hoping I might be able to apply the formal tools to it, having <a href="/blog/2019/07/17/crossbar.html">verified
my own interconnect</a> and
also since I had found some severe bugs in an academic’s interconnect–as
mentioned above.  As I worked through this design to determine if it would
even be possible to set up the tools (it wasn’t–not all of the code was
available as shown in Fig. 9), I noticed an
optional “feature”: The default setting of their interconnect
would allocate a channel from the master to the slave and at the same time from
the slave to the master.  This channel would then remain allocated until all
transactions had completed–much like my own
<a href="/blog/2019/07/17/crossbar.html">crossbar design</a>.
An optional setting would activate a different implementation, one that would
route transaction requests in packets to the slaves,
and then route them back to the masters in a way that required bus arbitration
in both directions.  As a result of the second “return” arbitration, the slave
would experience “<a href="https://en.wikipedia.org/wiki/Back_pressure">back
pressure</a>”–a necessary trigger
condition for some (but not all) of the bugs I had found.  This second
implementation would’ve clearly triggered the bugs that I had found, whereas
the first might not have.  Given the code I examined, it is quite possible that
a failure to test all configurations of this vendor’s design might’ve
contributed to the problem manifesting in some designs and not others.</p>

<p>In another example from the same interconnect logic, I noticed that the
vendor crippled both read and write channels in their AXI-lite to AXI bridge.
This surprised me.  Bridging from <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilite2axi.v">AXI-lite to
AXI</a> is really
easy to do, requiring almost no logic.  Then I realized, their crippled design
probably kept some of these <a href="/formal/2018/12/28/axilite.html">AXI-lite
bugs</a>
from triggering.  This appeared to be either a consequence of an engineer
trying to fix an ill-defined logic bug, or perhaps it was legacy code
remaining from a protocol version (AXI3) that had since fallen out of favor.</p>

<p>I also discovered a more shocking reason why many of these bugs may have stayed
hidden, while examining some
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> reset questions.</p>

<table align="center" style="float: none"><caption>Fig 10. DMA's are used for automatic data copying</caption><tr><td><img src="/img/axi-story/dma-copy.svg" alt="" width="560" /></td></tr></table>

<p>For those who are not familiar with a
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>, it’s basically
a hardware component that copies data from one bus slave to another.  My own
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/peripherals/wbdmac.v">WB DMA</a>,
works by first copying the data to an internal memory, and only then writes
it back to the bus.  It will do this several times if necessary.  If it
ever encounters a bus error,
such as I sometimes generate from a slave failing to respond,
it issues a bus abort, ends the transaction, and reports an error.</p>

<p>This is not as easy to do with AXI.</p>

<p>In this case, several customers had posted to the forum over a couple of days
asking asking whether or not it was possible to interrupt an ongoing
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>
transaction.  Apparently, these customers were trying to copy data between a
user logic core and memory and the bus was locking up mid-transaction.  They
wanted to find out how to abort the transaction.  I replied to these
individuals that there is no such thing as a bus abort in AXI: every
transaction request must receive a response.  There’s no way to timeout
a transaction.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 11. Using an AXI Fault Isolator</caption><tr><td><img src="/img/axi-story/axi-fault-isolator.svg" alt="" width="320" /></td></tr></table>

<p>Well, not quite.  There is one way to timeout a transaction.  You can use a
“firewall” of some type, such as this <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">bus
fault isolator</a>,
to catch bugs in a faulty AXI slave.  If placed between the slave and the rest
of the bus logic, as shown in Fig. 11, it will catch faults and then isolate
the downstream slave from the rest of the system–keeping those faults from
propagating upstream and becoming catastrophic.  Of course, once the fault
is detected, you still don’t know if a subsequent response was for the
missing earlier response or not.  As a result, you can even configure 
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">the core</a>
to then reset the downstream slave as well.</p>

<p>Unfortunately, this approach is not a cure-all.  Placing the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">bus fault
isolator</a>
between the interconnect and user logic will slow the user logic transactions
down to one at a time.  As a result, just placing
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">this core</a>
between the interconnect and user logic may resolve the problem just by
itself–even if it never detects a fault.</p>

<p>Still, I shared this possibility on several of these forum threads.  If nothing
else, it would’ve helped isolate the cause of the problem.</p>

<table align="center" style="float: right"><caption>Fig 12. Unflattering posts were deleted</caption><tr><td><img src="/img/axi-story/deleted-post.svg" alt="" width="320" /></td></tr></table>

<p>What surprised me the most about this these
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>
reset inquiries was that the <em>vendor then deleted all but one of the three
threads</em> when it became apparent that it wasn’t going to be flattering to their
product line or to the bus structure they had chosen.  This left me wondering,
<em>how many other forum posts regarding these bugs have been deleted?</em></p>

<p>Yes, this problem runs deep.  It also appears to be hard to find.</p>

<h2 id="why-havent-these-bugs-been-caught">Why haven’t these bugs been caught?</h2>

<p>Digital design has been around for a while, so why haven’t these problems been
caught before?  Why do they remain so hard to find?</p>

<p>I think the answer to this question comes down to how digital designs are
tested and verified in the first place.  The standard test methodology
requires you to write a <a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx10/isehelp/ise_c_simulation_test_bench.htm">test bench</a>
that exercises your design.  Much as I discovered with <a href="/blog/2017/10/19/formal-intro.html">my first experience
with formal methods</a>,
such test benches tend to only examine a “normal” design path.  In my case,
my own FIFO test bench didn’t check all combinations of reading and writing to
either full or empty FIFOs.</p>

<p>My best guess is that the same thing is going on here.</p>

<p>I know one individual who wrote in to Xilinx’s forums proudly proclaimed
that his core had passed Xilinx’s (AXI VIP/simulation based) verification
and so any problem he was having must be Xilinx’s fault.  Sadly, their
verification step left him believing that his user core worked, even
though it still suffered from the <a href="/formal/2018/12/28/axilite.html">same AXI-lite
bugs</a> I had already found.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 13. Simulation scripts rarely test everything</caption><tr><td><img src="/img/axi-story/sim-script.svg" alt="" width="320" /></td></tr></table>

<p>The basic problem is that if
you only ever test your AXI user component against one transaction at a time,
you’ll miss most of these bugs: You’ll start your simulation with a bus
master initiating a transaction while the slave is already waiting for it.
The simulated slave will then respond to the waiting master and voila you’ll
convince yourself that your design works even when you haven’t checked all
conditions.  What then happens if the interconnect sends another request
before the first one has returned?  It wasn’t tested.  What happens if either
the interconnect or bus the master aren’t yet ready to receive the bus slave’s
response?  Not tested.  Might the slave
ever lock up, due to conditions that aren’t simulated, to where it stops
processing the bus request?  These aren’t things that are normally tested in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
but they do happen in real life.</p>

<p>Consider the <a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>
discussion above.  A good
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA</a>
will push as much data into and through a core as fast as the bus will allow,
yet the simulation approach we just discussed above will never test for this.</p>

<p>Consider the example of the vendor’s interconnect as well, shown in Fig. 9
above.  If the interconnect has to arbitrate response packets back to the
master that sent them, then it may not be ready to receive a particular
response if another slave has the return grant to that master.  This
didn’t get tested either.</p>

<p>What about the crippled channels?  If you had enabled them to be full speed,
by packing request after request, many of these example designs would break.
Again, this is something you won’t test if you just tested one transaction
at a time in a simulation.</p>

<p>Some weeks ago an engineer wrote to me and asked if I had a test bench for <a href="/blog/2019/01/12/demoaxilite.html">one
of my cores</a>.  You
know, he said, something where he might write:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="n">read_transaction</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="n">write_transaction</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span></code></pre></figure>

<p>I was floored.  Indeed, I didn’t even know where to start.  Any test bench
that only checked one transaction at a time, or waited for the read transaction
to finish before starting a write transaction would mask many if not all of
the bugs I had found.</p>

<p>On the other hand, this is <a href="/blog/2017/09/18/clocks-for-sw-engineers.html">how <em>software</em> engineers
think</a>,
since <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>s
can only ever do one thing at a time: test this, then test that.  It’s how
software works, but it’s not how hardware works.</p>

<p>This is why digital designers need
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
now more than ever–because they actually check the cases you weren’t
anticipating.</p>

<p>If you’ve never tried
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
before, then understand that they are very different from
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
Instead of trying one test after another in a long chain or sequence of logic,
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
check all logic paths at once.  Yes, “all”, in what typically is a breadth
first search.  This is both their greatest benefit, since they catch things
no one imagines, as well as their greatest curse, since the computation
required does not grow with <a href="https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time">polynomial
time</a>.</p>

<table align="center" style="float: right"><caption>Fig 14. Should vs should not</caption><tr><td><img src="/img/axi-story/should-not.svg" alt="" width="320" /></td></tr></table>

<p>Another thing that makes
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
different is that you don’t specify how the external environment <em>should</em>
interact with your core.  Instead, you specify how the external environment
<em>shouldn’t</em> interact with your core.  The subtle difference in logic means
that, unless you tell the tool not to, it will try all kinds of crazy logic
inputs that you might never expect.</p>

<p>One of the common misperceptions about formal verification techniques is that
they are only useful or cost-effective for “mission critical”
applications–things like aircraft, rockets, and satellites.  Were I to
buy into this misconception, I wouldn’t touch formal methods at all–since
my own little “sandbox” is hardly anything anyone cares about.</p>

<p>That view might have even described me before I tried it for the first time.
After using these tools, I’d never go back to the way I was doing
digital design before starting with formal methods.  For me, formal methods
are a big time saver.  One of the things I really dislike is trying to sort
through a 15GB+ simulation trace file looking for a bug.  It takes too long,
and wears thin on my patience.  Not so with formal methods.  Indeed, most of
the formal designs I do require less than 20 time steps to find a bug.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 15. Reasons why I still use formal methods</caption><tr><td><img src="/img/axi-story/why-formal.svg" alt="" width="320" /></td></tr></table>

<p>Posting to a forum?  Personally, I’d never write into a vendor forum asking
for help unless I was not only stuck in <a href="/blog/2017/05/19/fpga-hell.html">FPGA
Hell</a>, but I had tried
every option I knew of to get out and still ended up stuck.  I like the
ability to do my own work and to call it my own, and so I’m the type of person
who will wait until I had tried fixing my own design every way I knew how
before ever breaking down and asking for help.  Perhaps its a character flaw.
However it’s this particular bias of mine, and I don’t think it’s all that
uncommon, that makes me believe that those who had posted requesting help,
and especially the professionals among them, must have been stuck in
<a href="/blog/2017/05/19/fpga-hell.html">FPGA Hell</a>
for a while before they risked their pride and profit to ask on a public forum.
Now imagine if you could find a logic problem quickly, perhaps even in less
time than it took to synthesize your design or even write your post for help,
and do it all at your desk.</p>

<p>“Mission critical” or not, formal methods have saved me and my little
sandbox of the world <a href="/zipcpu/2017/12/28/ugliest-bug.html">a lot of
frustration</a>.</p>

<p>So <a href="/formal/2019/08/03/proof-duration.html">how long does it
take</a>?  Well, to
give you an example, I just built my own <a href="https://github.com/ZipCPU/wb2axip//blob/master/rtl/axis2mm.v">AXI stream to
memory</a>
converter.  After writing this core, I included the
formal bus properties into the core and started running the tools.  This
was before simulation–since I haven’t (yet) run the core through a simulation.
At first, <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
founds bugs in seconds.  Those first bugs tended to be focused on initial
values and reset processing.  Once fixed, the tool then took a bit longer
and found several bugs in my AXI-lite control logic.  Once I cleared
those two hurdles, I was then stuck again between about 10-15 time steps for
a while.  During this time, the tools only required two minutes of processing
to find a bug.  At this point the bugs found included things like reading
from an empty FIFO, initiating a bus burst requests before there was enough
data in the FIFO, changing a bus request while it was waiting to be accepted,
crossing memory pages within a single request and so forth.  Now that I’ve
worked with the core for a while, it only takes 56 seconds to know if any
changes I’ve made have broken the core.</p>

<p>Think about that for a moment.  It takes 56 seconds to know if any simple logic
change has placed a bug in the core or not.  Not only that, but by means of
<a href="/blog/2018/03/10/induction-exercise.html">k-induction</a>,
those 56 seconds evaluate not only the first 15-timesteps, but <em>every set of
15-timesteps from the beginning of time through all eternity</em>–or at least
until the hardware starts failing.</p>

<p>Good luck trying to get your simulation either to run that fast or to be
that complete.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Most of the bugs I’ve found have now been posted, either in a blog article
on this site, in Xilinx’s forums, or directly to the authors of any github
cores either by filing an issue or sending an e-mail.  Many of them have not
yet been fixed as of this writing.  For example, as of Vivado 2019.1, Xilinx’s
bugs remain including one dating back as far as 2016.1.  The good news is that
their engineers are now not only aware of these bugs, but they’ve also promised
to fix them.  This is not yet true of the bugs I found in Intel’s design.
Sorry, I’ve dropped the ball there.  Other than
<a href="https://twitter.com/ZipCPU">tweeting</a> about Intel’s bugs, I have
yet to formally post or write about my findings.</p>

<table align="center" style="float: right"><caption>Fig 16. It's not just for safety critical applications</caption><tr><td><img src="/img/axi-story/bubble.svg" alt="" width="320" /></td></tr></table>

<p>What I will say is that I remember, years ago and before I ever started
diving deeply into FPGA technology myself,
sitting down with a co-worker to integrate their data collection logic into
my mission requirements.  Our goal was to demonstrate that we had a useful
product to the boss.  Instead, I remember this coworker struggling and
struggling with the design, hitting the reset key over and over and over
again, frustrated and confused at why the design wasn’t starting up like
it was supposed to or like it “usually” did.  No, I’m not going to repeat
his language here, but let’s just say that over the course of time while
he was hitting that reset button it became more and more colorful.</p>

<p>Now consider that the training material I’ve found has been broken.  Indeed,
any one of the AXI bugs I’ve found in these public source vendor training
materials might’ve caused this same frustration.  These include not only the
bugs found in the training material for the vendor’s tools that I’ve already
blogged about, but also the training material for the other major vendors on the
market.</p>

<p>Now, as I’m slowly picking up my jaw off the floor, I’m starting to get the
full impact of what’s been going on.</p>

<p>These bugs can be found and fixed–using formal methods.</p>

<p>If you are interested in repeating any of my work, I’ve done all of my work
using <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>–either the
open source or the commercial version.  I’ve also posted copies of the
Xilinx designs I’ve tested.  If you’ve never formal methods, the open
source version is capable of processing any Verilog (2005) code you might have
with a limited number of SystemVerilog extensions.  Feel free to download it
and give it a try.  You can also find my <a href="/formal/2018/12/28/axilite.html">AXI-lite
properties</a> and <a href="https://github.com/ZipCPU/wb2axip">several
example designs on line</a> as well.</p>

<p>You can also start with my <a href="/tutorial">beginner’s design
tutorial</a>.  It’s free.  Enjoy it.  Even though
<a href="/blog/2019/08/20/lego-design.html">Xilinx deleted my response recommending this tutorial to new
engineers</a>, you are
welcome to it.  I also teach a course on how to do formal verification.
You can find <a href="/tutorial/formal.html">those slides here</a>,
and contact me if you are interested in taking the course either on-line or
in person on your site.  Feel free to check those out too.</p>

<p>Finally, I look forward to meeting many of my readers at
<a href="https://orconf.org">ORCONF 2019</a>!  Feel free to stop me and say hello.</p>

<!-- Counter argument: If Xilinx is having these issues, and it's not breaking their neck, it can't be such a big deal.  Other comment: IP Vendors need to adapt formal methods before their customers do, because as soon as their customers have the formal methods, they'll immediate know where to put the blame. -->

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Buy the truth, and sell it not; also wisdom, and instruction, and understanding. (Prov 23:23)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
