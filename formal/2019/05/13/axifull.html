<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Examining Xilinx's AXI demonstration core</title>
  <meta name="description" content="Fig 1: A Universal Software Radio Peripheral">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2019/05/13/axifull.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/#training">Formal training</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Examining Xilinx's AXI demonstration core</h1>
    <p class="post-meta"><time datetime="2019-05-13T00:00:00-04:00" itemprop="datePublished">May 13, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1: A Universal Software Radio Peripheral</caption><tr><td><img src="/img/usrp-b205-mini.png" alt="USRP B205-Mini" width="284" /></td></tr></table>

<p>Years ago, I remember sitting next to an engineer who was working with the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
device on a <a href="https://www.ettus.com">Universal Software Radio Peripheral
(USRP)</a>.  His job that day was to place his design
on that device and then to interact with it.</p>

<p>That alone shouldn’t be very remarkable.</p>

<p>The remarkable part was that I remember him struggling to get his design to
reliably interact with the host computer.  He’d run the script to start it and
it wouldn’t start, or to reconfigure it and it wouldn’t reconfigure.  I
remember his emotion, frustration, and even his expanded vocabulary as he
cycled power, and then later needed to cycle power again.</p>

<p>I left before he ever found the bug, if he ever found it at all.</p>

<p>More recently, I’ve been exploring the
<a href="/doc/axi-spec.pdf">AXI</a> protocol, trying to create
a <em>formal</em> verification IP core which can then be used to verify any
<a href="/doc/axi-spec.pdf">AXI</a> slave peripheral, or bus master.</p>

<p>When I applied my these new properties to <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s example/demonstration slave
core</a>,
I was left wondering how much of my teammates frustrations from just a couple
of years earlier were do to a “vendor” supplied yet broken IP core.</p>

<p>So let’s examine <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s example/demonstration slave
core</a> today.
Perhaps we might even shine some light on those frustrations from just a couple
years ago?  What do you think, will a formal property check will find any bugs
in <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s code</a>?
The same code that <a href="https://www.xilinx.com">Xilinx</a> recommends you start with
in all of their <a href="/doc/axi-spec.pdf">AXI</a> training materials?</p>

<p>Let’s find out.</p>

<h2 id="generating-the-test-core">Generating the Test Core</h2>

<p>The obvious way to go about generating formal verification IP (VIP), would be
to read the <a href="/doc/axi-spec.pdf">AXI specification</a> and
<a href="/formal/2018/12/28/axilite.html">write properties</a>.
Having done that, I’ll admit, there were many parts of <a href="/doc/axi-spec.pdf">the
specification</a> that left me quite
confused.  So I drafted my own verification IP, and then went looking for
something to test it upon.</p>

<p>Enter <a href="https://www.xilinx.com">Xilinx</a>’s
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a> software.
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
has the wonderful capability to generate skeleton IP cores which you can use
within your design(s).  These are designed to get you up and running quickly,
without needing to learn all of the details of the protocol along the way.</p>

<p>In a moment, I’ll show you how to use
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
to generate an <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">AXI4 slave
core</a>.
We’ll then spend the rest of this post illustrating and discussing the bugs
<a href="https://www.xilinx.com">Xilinx</a>
has left within that core.</p>

<p>For now, let me point out that this was the same approach I used when
developing my <a href="/formal/2018/12/28/axilite.html">formal properties for
AXI-lite</a>.  Why?  Well, much
to my surprise, despite <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">linking to Xilinx’s AXI-lite
core</a>
within that article, <a href="https://www.xilinx.com">Xilinx</a>’s field engineer asked
me for both a copy of the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">buggy AXI-lite
code</a>
that <a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
had generated, as well as to tell him how I had generated <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">this buggy
code</a>.</p>

<blockquote>
  <p>You mentioned in a few posts about an issue with Xilinx provided AXI4-lite
code.  I wanted to ask what that Xilinx code is that you are referring to.
If you have an example design that I could look at, that would be greatly
appreciated.</p>
</blockquote>

<p>So let’s leave nothing for granted this time.  We’ll start by walking through
the process I used to generate the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">example
code</a>
I’m going to be examining today.  It all starts with Vivado 2018.3.</p>

<table align="center" style="float: none"><caption>Fig 2: Vivado 2018.3 version</caption><tr><td><a href="/img/axifull-gen-version.png"><img src="/img/axifull-gen-version.png" alt="Vivado Version" width="360" /></a></td></tr></table>

<p>While using <a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
2018.3, I went to the menu, and selected “Create and Package IP”.</p>

<table align="center" style="float: none"><caption>Fig 3: Create and Package IP</caption><tr><td><a href="/img/axifull-gen1.png"><img src="/img/axifull-gen1.png" alt="Click on the Vivado menu option to create and package new IP" width="360" /></a></td></tr></table>

<p><a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
then brings up a dialog box, shown in Fig. 4, and I clicked through it.</p>

<table align="center" style="float: none"><caption>Fig 4: Click through the first dialog box</caption><tr><td><a href="/img/axifull-gen2.png"><img src="/img/axifull-gen2.png" alt="Click through the first dialog box" width="903" /></a></td></tr></table>

<p>The second dialog box asks me what what type of IP I wish to create, shown in
Fig. 5.  I selected “Create a new AXI4 Peripheral.”</p>

<table align="center" style="float: none"><caption>Fig 5: Select Create a new AXI4 Peripheral</caption><tr><td><a href="/img/axifull-gen3.png"><img src="/img/axifull-gen3.png" alt="Click through the first dialog box" width="900" /></a></td></tr></table>

<p>The following dialog box asks me for a name and location for where this IP
should be placed.  If you do this, take careful note of the location–I’ve
been surprised more than once that the location of the new IP isn’t within
the current project and directory I’m working with.  If you get stuck, just
go back and re-create your IP, but noting the directory along the way.  You
can stop mid-way through this second time if you need to–once you know where
the last IP got stored.</p>

<table align="center" style="float: none"><caption>Fig 6: Pick a name and file location for your new IP</caption><tr><td><a href="/img/axifull-gen4.png"><img src="/img/axifull-gen4.png" alt="Click through the first dialog box" width="862" /></a></td></tr></table>

<p>After this, you’ll finally come to an interesting dialog box, the one where you
actually set up the parameters for and configure your core.</p>

<table align="center" style="float: none"><caption>Fig 7: Configure the core to be an AXI "full" "slave" core</caption><tr><td><a href="/img/axifull-gen5.png"><img src="/img/axifull-gen5.png" alt="Click through the first dialog box" width="862" /></a></td></tr></table>

<p>For the code we’ll be discussing today, I created a <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v"><em>full</em> AXI <em>Slave</em>
peripheral</a>
with a 32-bit data bus and a memory size of 64-bytes (i.e. 6 address bits).</p>

<p>There’s then another dialog or two with information in them, and then
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
actually generates the core we’ve requested.  In my case, it generated a
directory of information, having subdirectories for <code class="highlighter-rouge">bd</code>, <code class="highlighter-rouge">drivers</code>,
<code class="highlighter-rouge">example_designs</code>, <code class="highlighter-rouge">hdl</code>, and <code class="highlighter-rouge">xgui</code>.  There’s even a <code class="highlighter-rouge">component.xml</code>
file with a bunch of properties in it that look GUI related.</p>

<p>Looking around the rest of the directories, I found a lot of
<a href="https://en.wikipedia.org/wiki/Tcl">TCL</a> files, some verification scripts,
and even a C program which I assume would be used for verifying that this
peripheral works.</p>

<p>Not finding any formal property files, I took these with a grain of salt.</p>

<p>I then discarded everything but the <code class="highlighter-rouge">hdl</code> directory.  Within the <code class="highlighter-rouge">hdl</code>
directory, I found two files, of which only one has any significant logic
within it.  I renamed this file, and then placed it within a <a href="https://github.com/ZipCPU/wb2axip">github
repository</a> where I could both work with
it and share my results with all of you.</p>

<p><a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">This was then the
core</a>
that I started working with, and that will form the basis for our discussion
below.  With the exception of the <code class="highlighter-rouge">ifdef FORMAL</code> section and the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v#L609-L629">initial statements</a>
just preceding it, I’ve kept it identical to what
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>
first created.</p>

<h2 id="verification-ip-status">Verification IP Status</h2>

<p>My current <a href="/doc/axi-spec.pdf">AXI4</a> verification IP (not
posted) looks nothing like my <a href="https://github.com/ZipCPU/wb2axip/blob/0a349a3c9a77666a8917e3532bf93ba46f0e47d6/bench/formal/faxi_slave.v">previous
attempt</a>,
or even <a href="https://github.com/ZipCPU/wb2axip/blame/0a349a3c9a77666a8917e3532bf93ba46f0e47d6/bench/formal/faxi_slave.v">those before it</a>.</p>

<p>The list below is a sampling of some of the checks found within it.  In
this list, I’m going to use <code class="highlighter-rouge">*</code> as a wildcard, so <code class="highlighter-rouge">*VALID</code> might refer to any
of the <code class="highlighter-rouge">AWVALID</code>, <code class="highlighter-rouge">WVALID</code>, <code class="highlighter-rouge">BVALID</code>, <code class="highlighter-rouge">ARVALID</code>, or <code class="highlighter-rouge">RVALID</code> signals.
I will also use the convention, found within the <a href="/doc/axi-spec.pdf">AXI
specification</a>, of using <code class="highlighter-rouge">x</code>, as in
<code class="highlighter-rouge">AxLEN</code>, to refer to either write or read channel.  Hence <code class="highlighter-rouge">AxLEN</code> could be
either <code class="highlighter-rouge">AWLEN</code> or the <code class="highlighter-rouge">ARLEN</code> signals.  That said, here’s a sampling of
some of the checks within this new formal property core:</p>

<ul>
  <li>
    <p>All <code class="highlighter-rouge">*VALID</code> signals must be low initially</p>

    <p><a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s slave
core</a>
didn’t meet this property, since it didn’t initialize any of the registers
within the core.  I quietly added initial statements and moved on.</p>
  </li>
  <li>
    <p>All <code class="highlighter-rouge">*VALID</code> signals must be low following a reset</p>
  </li>
  <li>
    <p>Any time <code class="highlighter-rouge">*VALID</code> and <code class="highlighter-rouge">!*READY</code>, all associated properties
must remain stable into the next clock cycle</p>
  </li>
  <li>
    <p>Read and write bursts must each be <code class="highlighter-rouge">AxLEN+1</code> beats long, and end with an
<code class="highlighter-rouge">xLAST</code> signal</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">BVALID</code> shall not go high unless first preceded by an
<code class="highlighter-rouge">AWVALID &amp; AWREADY</code> and then by a <code class="highlighter-rouge">WVALID &amp; WREADY &amp; WLAST</code></p>

    <p>Similarly, <code class="highlighter-rouge">BVALID</code> may not go high with a given <code class="highlighter-rouge">BID</code> unless preceded
by an <code class="highlighter-rouge">AWVALID &amp; AWREADY</code> and an <code class="highlighter-rouge">AWID</code> matching that <code class="highlighter-rouge">BID</code>, as well
as all of the data associated with that burst.</p>

    <p>Put simply for every <code class="highlighter-rouge">AWVALID &amp; AWREADY</code> with ID <code class="highlighter-rouge">AWID</code>, there should be one
and only one <code class="highlighter-rouge">BVALID &amp; BREADY</code> response with <code class="highlighter-rouge">BID</code> equal to that <code class="highlighter-rouge">AWID</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">RVALID</code> may not go high unless first preceded by an
<code class="highlighter-rouge">ARVALID &amp; ARREADY</code></p>

    <p>Similarly, <code class="highlighter-rouge">RVALID</code> may not go high with a given <code class="highlighter-rouge">RID</code> unless, much
like the <code class="highlighter-rouge">BVALID</code> and <code class="highlighter-rouge">BID</code> criteria above, there has also been an
<code class="highlighter-rouge">ARVALID &amp; ARREADY</code> with that same <code class="highlighter-rouge">ARID</code> on the clock prior.</p>

    <p>This is one of the more difficult specifications to meet, particularly when
using <a href="/blog/2018/03/10/induction-exercise.html">induction</a>.
The particularly challenging piece is that a <em>good</em> interconnect or other
master should be able to have multiple bursts outstanding at any given time.
Worse, without
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
there’s no way to prove that a core won’t break between receiving its
second <code class="highlighter-rouge">AxLEN=255</code> transaction request.
<a href="/blog/2018/03/10/induction-exercise.html">Induction</a>
is therefore practically <em>required</em> in order to prove that something works.</p>
  </li>
  <li>
    <p>Bursts may not cross 4kB boundaries</p>

    <p>Passing <a href="/blog/2018/03/10/induction-exercise.html">induction</a>
with this criteria, but also without being able to use any multipliers
(formal tools struggle with multiplies) can also be a challenge.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">WSTRB</code> cannot be high for all of the bits of an <em>unaligned</em> access.
Depending upon the unaligned portion of the address, some of the bottom
<code class="highlighter-rouge">WSTRB</code> must be zero.</p>
  </li>
  <li>
    <p>No more than <code class="highlighter-rouge">1&lt;&lt;AWSIZE</code> bits of <code class="highlighter-rouge">WSTRB</code> are ever allowed to be high</p>

    <p>While this property will not impact today’s verification requirements,
it has caught a variety of bugs in some of the
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">interconnect</a>s
I’ve verified.  In particular, I’ve caught mis-routed write packets
with this property.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">AxBURST</code> values may only be FIXED (2’b00), INCREMENT (2’b01) or
WRAP (2’b10).  The reserved mapping of 2’b11 is disallowed</p>
  </li>
  <li>
    <p>WRAP transactions:</p>

    <ul>
      <li>
        <p>WRAP transactions must begin with an aligned address</p>
      </li>
      <li>
        <p>Bursts of type WRAP must have lengths of 2,4,8, or 16</p>
      </li>
    </ul>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">AxSIZE</code> description of a transfer may not exceed the width of
the interface.  Since this design is for a 32-bit interface, <code class="highlighter-rouge">AxSIZE</code> may
never be more than <code class="highlighter-rouge">3'b010</code>.</p>

    <p>In today’s example, <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s demonstration AXI slave
core</a>
can’t handle an <code class="highlighter-rouge">AxSIZE</code> that doesn’t match the bus size,
<code class="highlighter-rouge">(1&lt;&lt;(AxSIZE+3)) == C_S_AXI_DATA_WIDTH</code>, even though the
<a href="/doc/axi-spec.pdf">AXI protocol</a> specifically supports it.</p>

    <p>If you want to support <code class="highlighter-rouge">AxSIZE</code>s other then the one matching
<code class="highlighter-rouge">C_S_AXI_DATA_WIDTH</code>, you’ll need a core that has what’s known as “narrow
burst” support, such as <a href="https://github.com/ZipCPU/wb2axip/blob/master/demofull.v">this one</a>.</p>

    <p>You might find you require this support if you ever find yourself needing to
support buses from multiple native sizes, with bridges between them.  As an
example, the <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>
implementations I’ve worked with have been natively either 64 or 128 bits
wide, even though the <a href="/about/zipcpu.html">ZipCPU</a> is
natively 32 bits wide.</p>
  </li>
  <li>
    <p>The slave shall not respond with a value of <code class="highlighter-rouge">BID</code> (or <code class="highlighter-rouge">RID</code>) that doesn’t
correspond to a value previously given to it.</p>

    <p>This is the second very challenging specification to meet when using
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>
  </li>
  <li>
    <p>The formal verification properties also support a configurable number of
maximum stall cycles.  If set, the slave may not leave it’s associated
<code class="highlighter-rouge">*READY</code> line low for more than this many cycles if the respective
<code class="highlighter-rouge">*VALID</code> line is high.  There are similar stall counters for both address
channels as well as the write channel.</p>

    <p>These counters need to be tempered by back pressure.  Hence, if
<code class="highlighter-rouge">BVALID &amp;&amp; !BREADY</code> for example, then the stall count on <code class="highlighter-rouge">AWREADY</code> is paused.</p>

    <p>These counters are all from the slave’s perspective, insisting that the
slave stall the bus no more than the given number of cycles.</p>
  </li>
  <li>
    <p>The core also supports two other types of counters.  One set determines the
maximum number of clock cycles the slave can take from request to response,
while the second set constrains the amount of time the master can stall the
return channel.</p>

    <p>In each case, the limit can be set to zero to disable this logic.</p>

    <p>These counters are important, since they can catch things like dropped
packets–which we’ll see in a moment.  They can also be a challenge, since
they often force the number of steps in the proof to be at least as many
steps as are in the counter.</p>

    <p>As an example of when you might wish to disable the timers, consider my own
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">AXI interconnect</a>.
In that case, if two masters each tried to request a maximum length burst
from the same slave, one of them would’ve needed to wait more than 256
cycles.  Keeping the proof within 5 clock cycles meant that I needed to
disable this check.</p>
  </li>
  <li>
    <p>The verification IP also offers
<a href="/blog/2019/04/27/axi-addr.html">address</a>
outputs, which can be used with either write or read data channels to
verify that the responses are associated with the given address.</p>
  </li>
</ul>

<p>To support
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Xilinx</a>’s
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">demonstration core</a>,
I also needed to create an <code class="highlighter-rouge">OPT_NARROW_BURST</code> option to my formal VIP.  If
this parameter is set, the VIP will insist that <code class="highlighter-rouge">AxSIZE</code> corresponds to
<code class="highlighter-rouge">C_S_AXI_DATA_WIDTH</code>, no more and no less.  While this isn’t part of the
<a href="/doc/axi-spec.pdf">AXI specification</a> per se, <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s
demonstration
core</a>
doesn’t have the logic within it to process bursts of any other <code class="highlighter-rouge">AxSIZE</code>.
Given that the <a href="/blog/2019/04/27/axi-addr.html">difference between narrow burst support and no narrow burst
support is only about 36
LUTs</a>, though, were this
my own core I would’ve probably sided with providing full bus support.</p>

<ul>
  <li><code class="highlighter-rouge">OPT_NARROW_BURST</code>: Narrow burst support (<code class="highlighter-rouge">C_S_AXI_DATA_WIDTH == (1&lt;&lt;(AxSIZE+3))</code>)</li>
</ul>

<p>The VIP core also has an option that can be set to indicate that the core
supports <em>exclusive mode</em>, <code class="highlighter-rouge">OPT_EXCLUSIVE</code>.  This mode is associated with
the various <code class="highlighter-rouge">AxLOCK</code> flags.  The idea, from an
<a href="/doc/axi-spec.pdf">AXI</a> point of view, is that a read
transaction might set <code class="highlighter-rouge">ARLOCK</code>.  The peripheral core may then return <code class="highlighter-rouge">EXOKAY</code>
indicating that it supports exclusive access.  Some time later, the bus
master may issue a write transaction to the same address.  At that time, the
core is to respond with <code class="highlighter-rouge">EXOKAY</code> if no one else has written to that address
between the read and write requests, or <code class="highlighter-rouge">OKAY</code> if the address has been written
to between the read lock and the write lock.  In the case of an <code class="highlighter-rouge">OKAY</code>
response, the slave is required not to write to the value, but rather to leave
it alone.</p>

<p>I haven’t yet fully implemented the properties to check these exclusive access
transactions.  On the other hand, I don’t yet have a core that uses them,
so this isn’t much of a problem yet, although the exclusive access features
don’t appear to be all that hard to build.  Certainly <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this demonstration
core</a>
doesn’t support exclusive access, so it’s a moot point for this discussion.</p>

<p>Instead, I’ve implemented the following properties for cores that don’t
support exclusive access:</p>

<ul>
  <li>
    <p>Unless <code class="highlighter-rouge">OPT_EXCLUSIVE</code> mode is set</p>

    <ul>
      <li>
        <p>Slaves may not return a response of <code class="highlighter-rouge">EXOKAY</code></p>
      </li>
      <li>
        <p>Masters may not raise <code class="highlighter-rouge">AxVALID &amp; AxLOCK</code></p>
      </li>
    </ul>
  </li>
</ul>

<p>Moving on, I made one rather controversial choice having to do with <code class="highlighter-rouge">WVALID</code>.
I chose to set up the core so that <code class="highlighter-rouge">WVALID</code> <em>may not</em> be asserted before
<code class="highlighter-rouge">AWVALID</code>.  The <a href="/doc/axi-spec.pdf">AXI4 protocol</a> doesn’t
require this, although <a href="https://www.xilinx.com">Xilinx</a>’s
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">peripheral</a>
enforces this internally.  This rule just made the VIP easier to write: it
kept me from needing to verifying skid buffers for write address and write
data channels.</p>

<ul>
  <li>
    <p>WVALID may not be asserted before AWVALID</p>

    <ul>
      <li>If writes are pending, to include when <code class="highlighter-rouge">WVALID &amp; WLAST</code>, AWREADY must be low</li>
      <li>If <code class="highlighter-rouge">AWVALID</code> and <code class="highlighter-rouge">WVALID</code> are asserted on the same clock cycle, then
<code class="highlighter-rouge">WREADY</code> may not go high before <code class="highlighter-rouge">AWREADY</code></li>
    </ul>
  </li>
</ul>

<p>Since this requirement goes beyond what
<a href="/doc/axi-spec.pdf">AXI</a> requires, and (worse) risks
false positives, I will likely need to go back and revisit this requirement
in the future.</p>

<p>Now, using all these properties, shall we spend a moment to take a look at
<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>’s
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">demonstration core</a>?</p>

<h2 id="read-and-write-traces">Read and Write Traces</h2>

<p>Let me start out presenting their core by presenting read and write traces
generated using the properties above.  My purpose is to show an example of how
the core is supposed to work.  Be aware, however, that this is backwards of
how I actually examined <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">the
core</a>,
but it makes for a good overview.  I personally started examining this core by
examining whether my assertions and assumptions held, but we’ll get to those
in a moment.</p>

<p>I often think of an <a href="/doc/axi-spec.pdf">AXI</a> read
transaction as the simpler of the two, so let’s start with a read transaction
and consider the <a href="/doc/axi-spec.pdf">AXI</a> transaction in
Fig. 8 below.</p>

<table align="center" style="float: none"><caption>Fig 8: A Read Transaction</caption><tr><td><a href="/img/axifull-rd.svg"><img src="/img/axifull-rd.svg" alt="A read transaction from Xilinx's demonstration AXI4 core" width="720" /></a></td></tr></table>

<p>Notice in this trace that <code class="highlighter-rouge">ARREADY</code> waits until after <code class="highlighter-rouge">ARVALID</code> goes high
to go high.  Then, once the address has been accepted, the core returns one
value every other clock.  As a result, any burst of <code class="highlighter-rouge">N</code> items will take a
minimum of <code class="highlighter-rouge">2+2N</code> clocks to complete.</p>

<p>I was actually expecting much better performance than this from a [Full AXI
slave core](his core](https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v).
Isn’t the whole point of using burst transactions the ability to perform
transactions at high speed without the connection overhead?  Indeed, the
<a href="/blog/2019/01/12/demoaxilite.html">AXI-lite slave core</a>
I built could perform better than <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this full AXI slave
core</a>,
and for much less logic as well!  Of course, this doesn’t mean that
<a href="https://www.xilinx.com">Xilinx</a>’s
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">interconnect</a> could’ve driven
my <a href="/blog/2019/01/12/demoaxilite.html">AXI-lite slave core</a>
any faster, it just means that the peripheral could’ve operated much faster.
For all I know at this time, <a href="https://www.xilinx.com">Xilinx</a>’s core might
have the same 2-clocks per beat requirement, or it might actually operate
at one beat per clock.  I haven’t gotten that far in my investigations.  I do
know that my own <a href="https://github.com/ZipCPU/wb2axip/blob/master/axixbar.v">AXI
interconnect</a> can
handle one beat per clock, although it does pay for this capability in
logic usage.</p>

<table align="center" style="float: right"><caption>Fig 9: A Write Transaction</caption><tr><td><a href="/img/axifull-wr.svg"><img src="/img/axifull-wr.svg" alt="A write transaction from Xilinx's demonstration AXI4 core" width="530" /></a></td></tr></table>

<p>Fig. 9 on the right shows a burst write transaction.</p>

<p>Here, you’ll notice that, as before, <code class="highlighter-rouge">AWREADY</code> idles low and doesn’t go
high until after <code class="highlighter-rouge">AWVALID</code> is raised.  While this is valid according to the
<a href="/doc/axi-spec.pdf">AXI specification</a>, the
<a href="/doc/axi-spec.pdf">specification</a> also recommends idling
with <code class="highlighter-rouge">AxREADY</code> high rather than low.  However, once <code class="highlighter-rouge">AWVALID &amp; AWREADY</code>
are both true, <code class="highlighter-rouge">WREADY</code> will go high on the next cycle.  From that time forward,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">the core</a>
is able to handle one write beat per clock.  Once the last write data value
has been received, <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">the
core</a>
raises <code class="highlighter-rouge">BVALID</code>.  In total, this requires <code class="highlighter-rouge">3+N</code> clocks per burst of <code class="highlighter-rouge">N</code>
beats.  This is actually somewhat decent performance, primarily driven by
<a href="/doc/axi-spec.pdf">AXI requirement</a> that all signals must be
registered.</p>

<p>At issue in our next section is the simple question of whether or not this
core will reliably follow the <a href="/doc/axi-spec.pdf">AXI
protocol</a>.  As we shall see, there are
some serious flaws in its performance.</p>

<h2 id="bugs-in-vivados-axi-demonstration-core">Bugs in Vivado’s AXI demonstration core</h2>

<p>By my count, <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this core</a>
has three significant bugs within it, and one ridiculous eye-brow raising
example of a plain old stupid piece of unnecessary and crippling logic.</p>

<h3 id="the-core-might-return-the-wrong-id">1. The core might return the wrong ID</h3>

<p>The first bug is associated with the ID logic.</p>

<p>In an effort to make packet routing simpler when using
<a href="/doc/axi-spec.pdf">AXI</a>, each request
and response can be given an identifier, <code class="highlighter-rouge">AxID</code>.  Then later, when the
slave responds, it is required to respond with the identifier found within
the request.  Further, the slave is required to preserve packet ordering within
a given ID.</p>

<ol>
  <li>
    <p>As an example of how this might be used, consider the <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM
protocol</a>.  It costs several
clocks to switch from accessing one row of memory to another.
Similarly, it takes several clocks to switch from reads to writes.  On the
other hand, if the <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>
controller could return responses out of order, it might be able to pack
more accesses from a given row together before switching rows.</p>

    <p><a href="/doc/axi-spec.pdf">AXI</a> IDs make it possible to return
values out of order.  The only rule is that, within a given ID, they must
be returned in order.</p>

    <p>At one time I used this property within my own <a href="https://github.com/ZipCPU/wb2axip/blob/95a432b92792738002a17d8772ba2abe5ac7b887/rtl/wbm2axisp.v">WB to AXI
bridge</a>.
I assigned each <a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>
transaction to an address within a buffer, and then used this
address as the transaction ID.  This allowed me to interleave read and write
transactions, to adjust transaction widths, and to receive transactions
out of order on return.  I’m now in the process of tearing this extra
code back out, for the simple reason that it made
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">the core</a>
way more complex than it needed to be.</p>
  </li>
  <li>
    <p>The other example of where ID’s might be used is within the
<a href="/doc/axi-spec.pdf">AXI</a>
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">interconnect</a>.  The
<a href="/doc/axi-spec.pdf">AXI protocol</a> is designed so that an
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">interconnect</a> might give
all of the bursts from a given master a particular ID.  Then, when the
slave returns the response, the
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">interconnect</a> can then use
the returned ID as part of a routing scheme so that the response from the
slave is returned to the proper master.</p>

    <p>That’s the theory at least.</p>

    <p>I should note that when I built <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">my own AXI crossbar
interconnect</a>,
I was disappointed to learn that this feature wasn’t very useful.  Allowing
two separate masters to access the same slave already required a clock lost
while arbitrating between the two of them.  If I granted access to a
particular master, and kept that grant active, I could optimize accesses
from that master while all other masters would be forced to wait.  Had I
supported IDs, I’d need to suffer that clock lost to arbitration on
every new request.</p>

    <p>The problem is even worse than that.  Not only would a clock be lost due
to arbitration on every address channel request, there would be another
clock lost due to arbitration on the return channel as well.</p>

    <p>If that’s not enough, the necessary <em>back pressure</em> might have broken <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">the
core</a>
we are studying today–as I’ll explain shortly.</p>

    <p>For all of these reasons, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axixbar.v">my own AXI
interconnect</a>
supports IDs, but doesn’t use them during routing.</p>
  </li>
</ol>

<p>ID’s are also one of the special features present in
<a href="/doc/axi-spec.pdf">AXI</a> that are not present in
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>.
They’re one of the things that make the full
<a href="/doc/axi-spec.pdf">AXI protocol</a> special.</p>

<table align="center" style="float: right"><caption>Fig 10: Transaction responses did not guarantee the proper transaction ID</caption><tr><td><a href="/img/axifull-rdid.svg"><img src="/img/axifull-rdid.svg" alt="An AXI transaction returning the wrong ID" width="360" /></a></td></tr></table>

<p>In the case of <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s demonstration
core</a>,
the formal tools returned a trace showing that transaction IDs were not
properly preserved from request to response, as shown in Fig. 10 on the right.</p>

<p>With a little bit of digging, I found the bug.  In this case,
the response ID wasn’t registered with <code class="highlighter-rouge">AxVALID &amp; AxREADY</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span> <span class="n">S_AXI_BID</span> <span class="o">=</span> <span class="n">S_AXI_AWID</span><span class="o">;</span>
	<span class="k">assign</span> <span class="n">S_AXI_RID</span> <span class="o">=</span> <span class="n">S_AXI_ARID</span><span class="o">;</span></code></pre></figure>

<p>This is wrong on a couple of levels.  First, once <code class="highlighter-rouge">AxVALID &amp; AxREADY</code> are
true, the <code class="highlighter-rouge">Ax*</code> lines can be anything–such as a request for a second
transaction.  Nothing requires the <code class="highlighter-rouge">AxID</code> values to remain constant.  Indeed,
this bug might cause the response from the core to be misrouted to a master
that hadn’t requested it, while causing the rest of the design to hang waiting
for a request that would never come!</p>

<p>This is also one of those bugs that you wouldn’t likely find using the
traditional test bench methodology, where you interact with a core as much
as your imagination allows.  For me, that was never more than one request
at a time, or even one ID at a time.  I know that I personally <a href="/blog/2017/10/19/formal-intro.html">struggled to
identify all of the possible failure modes in my own cores prior to using
formal methods</a>.</p>

<p>The fix, at least in this case, is really easy: register the return ID’s.
Here’s the logic necessary for the write channel, the read logic would be
similar.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span> <span class="p">[</span><span class="n">C_S_AXI_ID_WIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">s_axi_bid</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_AWREADY</span><span class="p">)</span>
		<span class="n">s_axi_bid</span> <span class="o">&lt;=</span> <span class="n">S_AXI_AWID</span><span class="o">;</span>

	<span class="k">assign</span>	<span class="n">S_AXI_BID</span> <span class="o">=</span> <span class="n">s_axi_bid</span><span class="o">;</span></code></pre></figure>

<h3 id="logic-depending-on-wlast-wasnt-guarded-by-wvalid">2. Logic depending on WLAST wasn’t guarded by WVALID</h3>

<p>Consecutive <a href="/doc/axi-spec.pdf">AXI</a> data bursts are
separated from one another by the <code class="highlighter-rouge">xLAST</code>
signal.  Hence, as you saw in Figs. 8 and 9 above, the last data item was
marked by <code class="highlighter-rouge">xLAST</code>.  Ideally, this would mean that the next burst might
start immediately on the next clock cycle, had the core been optimized
for throughput.</p>

<p>However, the <code class="highlighter-rouge">xLAST</code> signal is only relevant if the <code class="highlighter-rouge">xVALID</code> signal is also
true.  If <code class="highlighter-rouge">xVALID</code> is false for a given channel, then <em>all</em> of the <a href="/doc/axi-spec.pdf">AXI</a>
signals on that channel are don’t cares and irrelevant.</p>

<table align="center" style="float: right"><caption>Fig 11: What happens when you check for WLAST, without also checking for WVALID</caption><tr><td><a href="/img/axifull-wlast.svg"><img src="/img/axifull-wlast.svg" alt="Failing to check WLAST &amp; WVALID terminated this burst early" width="455" /></a></td></tr></table>

<p>While this may not be the <a href="/formal/2019/04/16/axi-mistakes.html">most common AXI
mistake</a> out there,
it certainly ranks up there: All <a href="/doc/axi-spec.pdf">AXI</a>
signals are undefined unless the associated <code class="highlighter-rouge">xVALID</code> line is high.</p>

<p><a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s core</a>
didn’t follow this rule, as shown in Fig. 11 on the right.</p>

<p>In particular, several signals depended upon the presence of <code class="highlighter-rouge">WLAST</code> while
<em>assuming</em> that <code class="highlighter-rouge">WVALID</code> would also be true at the same time.  In this case,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">the core</a>
went into an invalid state, dropping both <code class="highlighter-rouge">WREADY</code> and raising <code class="highlighter-rouge">AWREADY</code> for
the next burst, without ever returning a <code class="highlighter-rouge">BVALID</code> response.  As a result,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">the core</a>
never finished reading the write data for this transaction.</p>

<p>If you look through <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">the source code</a>,
you find some incomplete cascaded ifs.  Here’s one example:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span> <span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span> <span class="p">)</span>
	<span class="k">begin</span>
	  <span class="k">if</span> <span class="p">(</span> <span class="n">S_AXI_ARESETN</span> <span class="o">==</span> <span class="mb">1'b0</span> <span class="p">)</span>
	    <span class="k">begin</span>
	      <span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	    <span class="k">end</span>
	  <span class="k">else</span>
	    <span class="k">begin</span>
	      <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">axi_wready</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">axi_awv_awr_flag</span><span class="p">)</span>
	        <span class="k">begin</span>
	          <span class="c1">// slave can accept the write data
</span>	          <span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	        <span class="k">end</span>
	      <span class="c1">//else if (~axi_awv_awr_flag)
</span>	      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WLAST</span> <span class="o">&amp;&amp;</span> <span class="n">axi_wready</span><span class="p">)</span>
	        <span class="k">begin</span>
	          <span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	        <span class="k">end</span>
	    <span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>(The comments above are not mine, but rather are provided with the generated
code.)</p>

<p>Notice the first bug: the logic depends upon <code class="highlighter-rouge">WVALID &amp; WREADY</code> <em>and something
else</em>!  In a prior post, I declared this to be <a href="/formal/2019/04/16/axi-mistakes.html">the most common AXI bug I’ve
come across</a>.</p>

<p>The second bug is that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">the core</a>
checks for <code class="highlighter-rouge">S_AXI_WLAST &amp;&amp; axi_wready</code>, rather than also checking for
<code class="highlighter-rouge">S_AXI_WVALID</code> as well.  Had the logic block been written instead as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span> <span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span> <span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">axi_wready</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">axi_awv_awr_flag</span><span class="p">)</span>
		<span class="c1">// slave can accept the write data
</span>		<span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_WLAST</span> <span class="o">&amp;&amp;</span> <span class="n">axi_wready</span><span class="p">)</span>
		<span class="n">axi_wready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>it would’ve fixed the problem with this particular block.  That would
leave <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v#L247-L274">one remaining block</a>
still needing a similar fix.</p>

<p>As with the last error, the bus would come to a screeching halt if this
ever happened in practice, with the bus master waiting forever for the
response to its burst.  Worse, if a second address request were made at this
time, the original data would get written to the address associated with the
second burst and … it just goes downhill from there.</p>

<p>I can only guess that <a href="https://www.xilinx.com">Xilinx</a>’s
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">interconnect</a>,
the code of which I don’t have access to currently, doesn’t set <code class="highlighter-rouge">WLAST</code>
unless it also sets <code class="highlighter-rouge">WVALID</code>.  I shudder to think of what might happen
if it didn’t guarantee this, or similarly if a “working” design were taken
from where it was working with one
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">interconnect</a>
(<a href="https://www.xilinx.com">Xilinx</a>’s), and placed into another environment,
such as an <a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>
environment, which didn’t maintain this property.</p>

<h3 id="any-backpressure-on-bready-and-the-core-will-drop-responses">3. Any backpressure on BREADY and the core will drop responses</h3>

<p>The first rule of bus transactions is that every request gets a response.
The second rule is that stalled requests are not allowed to change until
they are accepted.  In the case of <a href="/doc/axi-spec.pdf">AXI</a>
that applies to stalled responses as well–a condition referred to as back
pressure.</p>

<p>What might cause back pressure?  There might be back pressure if the
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">interconnect</a> ever needs
to arbitrate between multiple competing return responses to a given master.
Another possible cause of back pressure might be an
<a href="https://en.wikipedia.org/wiki/Crossbar_switch">interconnect</a> that issued
two transaction requests to different slaves, and is still waiting for the
first slave to respond.  A third reason might be a
<a href="https://en.wikipedia.org/wiki/Direct_memory_access">DMA controller</a> that,
having issued a read request of one peripheral, had also issued a write
request to a second peripheral and is still waiting on second peripheral
to accept the write data.</p>

<p>Back pressure, however, can be a challenge to deal with.</p>

<p>One of the difficult problems with back pressure is that with enough
back pressure, the <code class="highlighter-rouge">AxREADY</code> signals need to drop for the associated
address channels as well.  <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s
core</a>
in this case attempts to deal with back pressure by only raising the <code class="highlighter-rouge">AxREADY</code>
lines once the last transaction completes.</p>

<table align="center" style="float: right"><caption>Fig 12: Xilinx's core can't handle back pressure</caption><tr><td><a href="/img/axifull-bvalid-fail.svg"><img src="/img/axifull-bvalid-fail.svg" alt="Xilinx's core drops a write response if BREADY isn't high in time for the second return" width="490" /></a></td></tr></table>

<p>Or rather, I think that was the designers intent.  That’s not what the code
actually does.  In the case of the write channel, <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">Xilinx’s example
core</a>
only waits until <code class="highlighter-rouge">WLAST</code> is high, then it will both set <code class="highlighter-rouge">BVALID</code> and
consider accepting a second burst.  The problem is what happens if
<code class="highlighter-rouge">BREADY</code> isn’t also high at the same time, as shown in Fig. 12 on the right.</p>

<p>In this example, <code class="highlighter-rouge">BREADY</code> is low long enough that the second burst’s
write response to overwrite the response from the first burst.  This could
easily halt a design depending upon this peripheral so hard it would take
a power cycle to fix.</p>

<p>Incidentally, <a href="https://www.xilinx.com">Xilinx</a>’s
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>
core had this same problem.  While <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this
core</a>
only suffers the problem on the write return channel,
<a href="https://www.xilinx.com">Xilinx</a>’s
<a href="/formal/2018/12/28/axilite.html">AXI-lite core</a>
suffered from this same problem on both read and write return channels.</p>

<p>Their field engineer asked me about my
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a> conclusion.  He
pointed to an
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>
trace that was very similar to the one shown in Fig. 12 above, and then pointed
out (correctly) that there was no protocol error shown in the figure.  A slave
might validly send write responses any time it wants, and so perhaps there’s a
write response still waiting.</p>

<p>Here’s the critical piece of missing information: the final state shown in
Fig. 12 is a <em>STEADY STATE</em>!  The core <em>never</em> returns the second response.</p>

<p>What happened?</p>

<p>Let’s take a look at the logic block that sets <code class="highlighter-rouge">AWREADY</code> to see.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span> <span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span> <span class="p">)</span>
	<span class="k">begin</span>
	  <span class="k">if</span> <span class="p">(</span> <span class="n">S_AXI_ARESETN</span> <span class="o">==</span> <span class="mb">1'b0</span> <span class="p">)</span>
	    <span class="k">begin</span>
	      <span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	      <span class="n">axi_awv_awr_flag</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	    <span class="k">end</span> 
	  <span class="k">else</span>
	    <span class="k">begin</span>
	      <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">axi_awready</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="n">axi_awv_awr_flag</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="n">axi_arv_arr_flag</span><span class="p">)</span>
	        <span class="k">begin</span>
	          <span class="c1">// slave is ready to accept an address and
</span>	          <span class="c1">// associated control signals
</span>	          <span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
	          <span class="n">axi_awv_awr_flag</span>  <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span> 
	          <span class="c1">// used for generation of bresp() and bvalid
</span>	        <span class="k">end</span>
	      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_WLAST</span> <span class="o">&amp;&amp;</span> <span class="n">axi_wready</span><span class="p">)</span>          
	      <span class="c1">// preparing to accept next address after current write burst tx completion
</span>	        <span class="k">begin</span>
	          <span class="n">axi_awv_awr_flag</span>  <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	        <span class="k">end</span></code></pre></figure>

<p>Did you see the bug?  There’s actually a couple of bugs here.  Let me give
the rest of the block here for reference, but the bug is in the <code class="highlighter-rouge">if</code>
statement(s) above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	      <span class="k">else</span>
	        <span class="k">begin</span>
	          <span class="n">axi_awready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
	        <span class="k">end</span>
	    <span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>The first bug is that this core checks for <code class="highlighter-rouge">~axi_awready &amp;&amp; S_AXI_AWVALID</code>
and <em>something else</em>.  This is a <a href="/formal/2019/04/16/axi-mistakes.html">common AXI
mistake</a>,
probably created by the engineer wanting to make certain the other flags
are also true.  The consequence of this bug, though, is that if the <em>something
else</em> wasn’t also true, then an address request just got dropped.</p>

<p>But that’s not the bug that caused the trace in Fig. 12 above.</p>

<p>The second bug is the check for <code class="highlighter-rouge">S_AXI_WLAST &amp;&amp; axi_wready</code>.  In this case,
we’ve already discussed the problem of referencing <code class="highlighter-rouge">WLAST</code> without also checking
<code class="highlighter-rouge">WVALID</code>.</p>

<p>That’s still not the bug that caused the trace in Fig. 12 above.</p>

<p>The bug in the trace above centers around the use of the <code class="highlighter-rouge">axi_awv_awr_flag</code>
to determine whether or not the core is currently processing a burst, or if
it can accept the next burst for processing.  In this case, once
<code class="highlighter-rouge">S_AXI_WLAST &amp;&amp; wready</code> were true the burst was marked complete and ready
for the next address.  If the designer had instead checked for
<code class="highlighter-rouge">BVALID &amp;&amp; BREADY</code>, it might have fixed this issue.  However, in the designer’s
zeal to lower the latency of this core, they allowed <code class="highlighter-rouge">axi_awv_awr_flag</code>
(the write address valid flag) to drop one clock cycle too early.</p>

<p>The rest follows from Fig. 12 above: the having dropped the write address valid
flag, the core now accepts the next write request.  It accepts and writes a
value to the core’s internal data structure, and then sets <code class="highlighter-rouge">BVALID</code>.  Only …
<code class="highlighter-rouge">BVALID</code> is <em>already</em> set.  Hence a return response is dropped.</p>

<p>Many pieces of hardware, ARM included, will wait for a missing burst return
forever.  As a result, this would mark the end of any fault-tolerant design–and
the bug was in <em>vendor</em> code!</p>

<p>Lesson learned: never trust vendor code.</p>

<p>When I built <a href="https://github.com/ZipCPU/wb2axip/blob/master/demofull.v">my own AXI
core</a>, I chose
instead to stall the <code class="highlighter-rouge">WLAST</code> cycle if <code class="highlighter-rouge">BVALID &amp;&amp; !BREADY</code> were true.  That
little bit of overlap also allowed <a href="https://github.com/ZipCPU/wb2axip/blob/master/demofull.v">my
design</a> to fully
process an <a href="/doc/axi-spec.pdf">AXI</a> write transaction at
one beat per clock across multiple bursts.  That’s better performance than
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this core</a>
achieves, while also passing a formal verification check which
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this core</a>
doesn’t.</p>

<h3 id="this-core-wont-handle-concurrent-reads-and-writes">4. This core won’t handle concurrent reads and writes</h3>

<p>Did you notice from the last piece of code that <code class="highlighter-rouge">AWREADY</code> depended upon not only
the <code class="highlighter-rouge">axi_awv_awr_flag</code> (the write address valid flag, indicating a write burst
is active), but also the <code class="highlighter-rouge">axi_arv_arr_flag</code> (the read address valid flag)?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">axi_awready</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="n">axi_awv_awr_flag</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="n">axi_arv_arr_flag</span><span class="p">)</span></code></pre></figure>

<p>This means that the core will not accept any read transactions while
a write transaction is ongoing.</p>

<table align="center" style="float: none"><caption>Fig 13: Write's wait on read completion</caption><tr><td><a href="/img/axifull-rdwr.svg"><img src="/img/axifull-rdwr.svg" alt="Xilinx's core won't start a read while there's an ongoing read" width="720" /></a></td></tr></table>

<p>This one I don’t get.  Indeed, this doesn’t make any sense to me.  One of the
key features of the <a href="/doc/axi-spec.pdf">AXI protocol</a>,
a key selling point if you will, is that it can handle both reads and
writes at the same time.</p>

<p>Not <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this core</a>.</p>

<p>When <a href="https://twitter.com/ZipCPU">I tweeted</a> about this bug,
<a href="https://twitter.com/Qermitos">Piotr</a>
suggested the reason for this was that the core was implementing a single
port RAM.  Indeed, if your only information was the trace above that would
make sense.  However, if you look through the logic of
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this core</a>
you’ll discover a couple of things.  First, the registers within the core are
implemented with either <a href="/zipcpu/2018/07/13/memories.html">block
RAMs</a>
or <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>.
Given the size of this core, at only 64-bytes, it would probably be implemented
in <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>.
Either way, both
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
and <a href="/zipcpu/2018/07/13/memories.html">block RAMs</a>
can handle both reads and writes on the same clock in
<a href="https://www.xilinx.com">Xilinx</a> devices.  Then, just to make this
more crazy, the core <em>will</em> allow both a read and write at the same time
<em>if</em> the two requests show up at the same time.  Similarly, if a read
request shows up during a write request the core will process it.</p>

<p>The only justification I can possibly think of for this “feature” is that
this was an unintentional oversight.</p>

<p>Removing the test for the <code class="highlighter-rouge">axi_arv_arr_flag</code> “fixes” this particular problem.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This is now the <a href="/formal/2018/12/28/axilite.html">second of Xilinx’s demonstration
designs</a> that I’ve
applied <a href="https://symbiyosys.readthedocs.io/en">SymbiYosys</a> to.  Let’s just
say that I’m not going to recommend either of these two
<a href="https://www.xilinx.com">Xilinx</a>
designs, and I’m certainly not going to recommend them to any beginners!
I can’t really think of a worse nightmare, as a beginner, than to be
struggling with non-functioning vendor code.  I’d be looking every place
<em>other</em> than the one with the bug!  Worse, I wouldn’t know how to verify
if any of my “fixes” worked–especially since
<a href="https://www.xilinx.com">Xilinx</a>’s
own verification procedures failed to find any of the bugs illustrated above.</p>

<p>If you would like a basic <a href="/doc/axi-spec.pdf">AXI4</a>
design that you can start from and work with, you might wish to consider
<a href="https://github.com/ZipCPU/wb2axip/blob/master/demofull.v">this design instead</a>.
Unlike my <a href="/blog/2019/01/12/demoaxilite.html">demonstration AXI-lite
design</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/demofull.v">this AXI full core</a>
requires connectivity to a second (external) core with the actual read/write
logic within.  I chose this approach to make it easier to integrate this
<a href="https://github.com/ZipCPU/wb2axip/blob/master/demofull.v">demonstration design</a>
into another of my designs that <a href="/blog/2019/04/27/axi-addr.html">desperately needs the AXI
performance</a>.</p>

<p>If all goes well, <a href="https://github.com/ZipCPU/wb2axip/blob/master/demofull.v">this demonstration
core</a>
may well be the next <a href="/doc/axi-spec.pdf">AXI</a>
core I blog about.</p>

<p>As for the formal properties that I used to find the bugs in
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxfull_2018_3.v">this core</a>,
those are currently available for purchase as part of the
<a href="https://www.symbioticeda.com/seda-suite/">SymbioticEDA Suite</a>.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Now all these things happened unto them for ensamples: and they are written for our admonition, upon whom the ends of the world are come. (1 Cor 10:11)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
