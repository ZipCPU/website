<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Formally Verifying a General Purpose Ultra-Micro Controller</title>
  <meta name="description" content="At long last, I have formally verified a DDR3 SDRAMcontroller.  Sadly,I haven’t yet had the time to verify its operation on real hardware.Worse, the I/O isn’...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2019/11/18/genuctrlr.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Formally Verifying a General Purpose Ultra-Micro Controller</h1>
    <p class="post-meta"><time datetime="2019-11-18T00:00:00-05:00" itemprop="datePublished">Nov 18, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>At long last, I have formally verified a <a href="https://opencores.org/project,wbddr3">DDR3 SDRAM
controller</a>.  Sadly,
I haven’t yet had the time to verify its operation on real hardware.
Worse, the I/O isn’t quite there yet so I don’t expect it will work … yet.</p>

<p>For those who don’t know the story, I built a
<a href="https://opencores.org/project,wbddr3">DDR3 SDRAM controller</a> years ago.
These were back in my stubborn days, before I was ever willing to use any
vendor modules.  I then built a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
controlled
<a href="https://opencores.org/project,wbddr3">DDR3 SDRAM controller</a>,
and attempted to instantiate it on my <a href="https://store.digilentinc.com/arty-a7-artix-7-fpga-development-board-for-makers-and-hobbyists">Arty
board</a>.</p>

<p>Let’s just cut the story short: it wasn’t a successful project.</p>

<p>There’s a world of difference between the logic used to drive the <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3
SDRAM</a> and the actual wires
and protocol required by the <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3
SDRAM</a>.  That world of difference
lies in the byte-strobe signals, but that’s a story for another day.</p>

<table align="center" style="float: right"><caption>Fig 1. A XuLA2-LX25 Board from Xess</caption><tr><td><img src="/img/XuLA2.png" alt="" width="250" /></td></tr></table>

<p>Prior to this <a href="https://opencores.org/project,wbddr3">DDR3 SDRAM
controller</a>, I had built an <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">SDRAM
controller</a>
for my XuLA2 LX25 board.  It wasn’t all that had to do, and so I thought I would
try my hand at a <a href="https://opencores.org/project/wbddr3">DDR3 SDRAM controller</a>.
Since this was a second generation <a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">Dynamic RAM
(DRAM)</a>
controller for me, I came into this
project knowing a thing or two regarding what had worked before and what
hadn’t.  (Or at least, so I thought.)  I also came into the project expecting
to run at a 200MHz system clock.  Then it was a 100MHz clock, then an 80MHz
clock, then … my motivation fell apart.  This was to be expected in so many
ways–especially since the project was never funded in the first place and it
cost me several months of work.</p>

<p>Recently, however, I’ve had the opportunity to dig up the design again.
Actually, I’ve had the opportunity to dig into both the
<a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/wbsdram.v">SDRAM design</a>
<em>and</em> the <a href="https://opencores.org/project/wbddr3">DDR3 SDRAM design</a>.  I modified
the SDRAM controller to handle <a href="http://www.issi.com/WW/pdf/42-45S16100H.pdf">ISSI’s SDRAM
chip</a>, as found on the <a href="https://www.tindie.com/products/Folknology/blackice-mx/">new
IceCore board from
myStorm</a> as well as
started working to port my controller to the <a href="https://www.micron.com/products/dram/ddr3-sdram/part-catalog/mt41k64m16tw-107">DDR3 SDRAM
chip</a>
found on Lattice’s <a href="https://www.latticesemi.com/en/Products/DevelopmentBoardsAndKits/ECP5VersaDevelopmentKit">ECP5 Versa Board</a>.  That is, until my project
funding ran out again.</p>

<p>One of the big things that has changed between my early work with
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">DRAM</a>
controllers and now is that <a href="/blog/2017/10/19/formal-intro.html">I’ve discovered formal
verification</a>.  Neither
of my original cores were formally verified initially.  Indeed, one of my
early formal verification stories is of trying to verify the <a href="https://github.com/ZipCPU/xulalx25soc/blob/master/rtl/wbsdram.v">(non-DDR) SDRAM
controller</a>
and discovering a corner case where the controller might’ve accessed
the wrong piece of memory.</p>

<p>That would’ve been <a href="/blog/2019/11/14/sdspi.html">hard to
debug</a>.</p>

<p>Today’s discussion, however, focuses on a piece of logic found within each
controller–something I’m going to call an ultra-micro controller.</p>

<h2 id="the-purpose-of-the-microcontroller">The Purpose of the MicroController</h2>

<p>There are actually two ultra-micro controller’s found within each of the updated
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">DRAM</a>
controller designs.  One of them is responsible for the <a href="https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L578-L607">reset logic
sequencing</a>, and the other
for the <a href="https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L622-L667">refresh logic</a>.
But I’m getting ahead of myself.  Let’s start with the
basic question, what is a “MicroController”?</p>

<p><a href="https://en.wikipedia.org/wiki/Microcontroller">Wikipedia currently defines a
MicroController</a> as</p>

<blockquote>
  <p>a small computer on a single integrated circuit on a single metal-oxide
semiconductor (MOS) integrated circuit chip. In modern terminology,
it is similar to, but less sophisticated than, a system on a chip (SoC);
an SoC may include a microcontroller as one of its components. A
microcontroller contains one or more CPUs (processor cores) along with
memory and programmable input/output peripherals. …
(Yes, Wikipedia’s definition even changed while I was writing this!)</p>
</blockquote>

<p>This is way more sophisticated than what I am talking about today.  That’s
why I’m going to use the term “ultra-micro controller”
today, I’m not talking about anything that would rank as I high as a full-blown
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
or even anything with external memory.  Instead, I’m referring to something
a little more sophisticated than a <a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite state
machine</a>, but not
nearly as sophisticated as a full
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.  The <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>
I’m talking about today does nothing but follow a simple fixed script, setting
a single register along the way.  This script is the unique feature that
separates it from a more traditional
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite state machine</a>.</p>

<p>I’m going to use this in two contexts initially, and probably many others later.
These are the reset sequence and the refresh sequence of my
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">DRAM</a>
controllers.
Here’s the basic idea, as applied to the reset sequence: when you read through
the data sheet for a memory chip, you’ll discover that there’s a very specific
sequence of events that needs to take place from power up to the first memory
access.  This sequence includes timing relative signals given to the core.
For example, many
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
chips require a PRECHARGE-ALL common (initializes all of the internal memory
banks to idle), followed by a REFRESH command and then finally a SETMODE
command to set the settings within the chip, telling the chip how the
controller will interact with it.  Only after all three of these commands have
been issued is the memory ready to use.</p>

<p>There’s one other key detail, and that is that those three startup commands,
PRECHARGE, REFRESH, and SETMODE, all have particular timing relationships
between them.  For example, there may need to be an adjustable number of idle
cycles between the PRECHARGE command and the following REFRESH command
and so forth.</p>

<p>That’s one of the two <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controllers</a>
I needed for these two
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">DRAM</a>
controllers.</p>

<p>The other one I’m using to handle the refresh logic.  If you aren’t familiar
with
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">DRAM</a>,
then you need to understand first that it’s built out of capacitors.  If the
capacitor is charged, that particular bit of memory is a one else its a zero.
Building memory out of capacitors makes it possible to build memories with
very low area and low power.  The problem with using capacitors to hold memory
is that the charge within any capacitor will decay over time.  It
leaks.  If each capacitor is not re-charged periodically, they will return
to zeros, losing any data you might have stored within them.  To keep this from
happening, the controller needs to follow an internal schedule of commands
within it–periodically pulling the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">DRAM</a>
off line, idling all the RAM banks, issuing a REFRESH command, and
then putting them back on line.</p>

<p>This is all well and good, but my problem was associated with the giant
process it took to calculate the memory commands.</p>

<p>To see how bad it got, here’s a look at what my initial draft looked like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">in_reset_sequence</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// The reset state machine
</span>	<span class="c1">//
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">reset_condition_one</span><span class="p">)</span>
		<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">SETMODE</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reset_condition_two</span><span class="p">)</span>
		<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">PRECHARGE_ALL</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reset_condition_three</span><span class="p">)</span>
		<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">REFRESH</span><span class="o">;</span>
	<span class="k">else</span>
		<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">NOOP</span><span class="o">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
	<span class="c1">// ...
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">need_refresh</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_condition</span><span class="p">)</span>
			<span class="c1">// Wait since the last precharge
</span>			<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">NOOP</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">second_condition</span><span class="p">)</span>
			<span class="c1">// Precharge all banks
</span>			<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">PRECHARGE</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">third_condition</span><span class="p">)</span>
			<span class="c1">// Wait for all banks to become idle
</span>			<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">NOOP</span><span class="o">;</span> <span class="c1">// Wait
</span>		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fourth_condition</span><span class="p">)</span>
			<span class="c1">// Issue the refresh command
</span>			<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">REFRESH</span><span class="o">;</span> <span class="c1">//
</span>		<span class="c1">// ...
</span>	<span class="k">else</span> <span class="k">begin</span>
		<span class="c1">// Another large state machine
</span>		<span class="c1">// To handle read and write commands
</span>	<span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>The problem with this giant always block was that the
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">state machine</a>
it generated was so complex it struggled to pass timing at any decent clock
speed.  Placing three separate
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">state machines</a>
into this same logic block, one for reset, one for refresh, and one for reading
and writing the RAM was … just too much for the hardware to handle in the
time allotted to it.</p>

<p>I needed to simplify my design.  I needed to pipeline some of this logic.
(Okay, <a href="/zipcpu.com/zipcpu/2019/03/28/return-decoding.html">switching to a
proper</a>
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">FSM state variable</a>
would’ve helped some as well.)</p>

<p>Eventually, I decided that I should separate this <em>maintenance logic</em>,
that’s the word I’m using for both reset and refresh logic, from the rest of
this giant logic block.  Along the way I noticed that all of the
maintenance logic was independent of any actual bus requests.  I could
run it a clock ahead of when it actually needed to be used.  In other words, I
could pre-calculate maintenance commands before they would be used and so
simplify things.  For example, I could have a reset logic block,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// The reset state machine
</span><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">reset_condition_one</span><span class="p">)</span>
	<span class="n">reset_cmd</span> <span class="o">=</span> <span class="n">SETMODE</span><span class="o">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reset_condition_two</span><span class="p">)</span>
	<span class="n">reset_cmd</span> <span class="o">=</span> <span class="n">PRECHARGE_ALL</span><span class="o">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reset_condition_three</span><span class="p">)</span>
	<span class="n">reset_cmd</span> <span class="o">=</span> <span class="n">REFRESH</span><span class="o">;</span>
<span class="k">else</span>
	<span class="n">reset_cmd</span> <span class="o">=</span> <span class="n">NOOP</span><span class="o">;</span></code></pre></figure>

<p>together with a separate and independent block to calculate the refresh
command sequence,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">first_refresh_condition</span><span class="p">)</span>
	<span class="c1">// Wait since the last precharge
</span>	<span class="n">refresh_cmd</span> <span class="o">=</span> <span class="n">NOOP</span><span class="o">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">second_refresh_condition</span><span class="p">)</span>
	<span class="c1">// Precharge all banks
</span>	<span class="n">refresh_cmd</span> <span class="o">=</span> <span class="n">PRECHARGE</span><span class="o">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">third_refresh_condition</span><span class="p">)</span>
	<span class="c1">// Wait for all banks to become idle
</span>	<span class="n">refresh_cmd</span> <span class="o">=</span> <span class="n">NOOP</span><span class="o">;</span> <span class="c1">// Wait
</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fourth_refresh_condition</span><span class="p">)</span>
	<span class="c1">// Issue the refresh command
</span>	<span class="n">refresh_cmd</span> <span class="o">=</span> <span class="n">REFRESH</span><span class="o">;</span> <span class="o">//</span></code></pre></figure>

<p>I could then <a href="https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L669-L689">combine these two logic sequences together</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">reset_logic</span><span class="p">)</span>
	<span class="n">maintenance_cmd</span> <span class="o">=</span> <span class="n">reset_cmd</span><span class="o">;</span>
<span class="k">else</span>
	<span class="n">maintenance_cmd</span> <span class="o">=</span> <span class="n">refresh_cmd</span></code></pre></figure>

<p>Why would I do all of this?  To simplify the giant always block, and to
<a href="http://zipcpu.com/blog/2017/09/18/clocks-for-sw-engineers.html">maintain a high clock
speed</a>.  Now,
instead of having multiple separate logic checks within one giant always block,
I can instead <a href="https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L366-L387">just check for the flag
<code class="highlighter-rouge">maintenance_mode</code></a>
which would indicate I wanted to issue either a command from the reset sequence
or the refresh sequence.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">maintenance_mode</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// Enter here during either reset or
</span>	<span class="c1">// refresh
</span>	<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">maintenance_cmd</span><span class="o">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
	<span class="c1">// ...
</span>	<span class="c1">// The large read/write state machine to read from memory
</span><span class="k">end</span></code></pre></figure>

<p>This greatly simplified the logic, but I now needed special
<a href="https://en.wikipedia.org/wiki/Finite-state_machine">state machines</a>
for both reset and refresh sequences.</p>

<p>To make this work, I just wanted a <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">simple
core</a>
that would do nothing but walk through the various reset or refresh
commands in the simplest logic possible.</p>

<table align="center" style="float: left"><caption>Fig 2. A Three-Stage Pipeline</caption><tr><td><img src="/img/genuctrl/pipeline.svg" alt="" width="360" /></td></tr></table>

<p>Hence the need for this ultra-micro controller.</p>

<p>The <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">microncontroller
itself</a>
worked off of a very basic 3-stage pipeline, as shown in Fig. 2.
First it would calculate an address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">r_addr</span> <span class="o">&lt;=</span> <span class="n">r_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>It would then read a command from that position in the command sequence.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">r_cmd</span> <span class="o">&lt;=</span> <span class="n">command_memory</span><span class="p">[</span><span class="n">r_addr</span><span class="p">]</span><span class="o">;</span>
<span class="k">endcase</span></code></pre></figure>

<p>Finally, it would act upon that command, setting internal registers.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">in_refresh</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">in_refresh</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">;</span>
	<span class="n">refresh_cmd</span> <span class="o">&lt;=</span> <span class="n">r_cmd</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span><span class="o">;</span>
	<span class="n">stall_bus</span>   <span class="o">&lt;=</span> <span class="n">r_cmd</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">;</span>
	<span class="c1">// ... and so on
</span><span class="k">endcase</span></code></pre></figure>

<p>Well, … not quite.  Often the startup or refresh sequence would require delays
between particular states.  Let’s dig into that more in a moment.</p>

<p>For now, notice two things.  First, this approach drastically simplified
my processing.  Second, getting this core to pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
requires a little bit of a trick–I’ll share that in a moment.</p>

<p>Indeed, if it weren’t for the neat trick required to pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
I wouldn’t be writing this article.  The <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">core
itself</a>
is embarrassingly simple.</p>

<h2 id="adding-a-counter">Adding a counter</h2>

<p>The biggest problem with the logic above is simply that the various commands
also have delays and durations associated with them.  For example, on
<a href="http://www.issi.com/WW/pdf/42-45S16100H.pdf">ISSI’s SDRAM chip</a>,
nine clocks need to separate any REFRESH command from any command following.
Our simple logic above would require 8-separate NOOP commands in our sequence
to capture that.</p>

<table align="center" style="float: right"><caption>Fig 3. Instruction Codes</caption><tr><td><img src="/img/genuctrl/genu-isa.svg" alt="" width="360" /></td></tr></table>

<p>Alternatively, we could add a second type of instruction–a “wait” instruction,
with an integrated number of wait clocks. This would then become an <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>
with two op-codes: the first for setting output registers, and
the second for starting a wait counter.  You can see these two codes shown in
Fig. 3 on the right.</p>

<p>This would change our logic above slightly.  For example, we’d only advance
the address pointer to the next instruction if the delay counter had already
finished counting down to zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">r_addr</span> <span class="o">&lt;=</span> <span class="n">r_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>Similarly, we’d only fetch the next instruction if the delay counter were zero
as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">case</span><span class="p">(</span><span class="n">r_cmd</span><span class="p">)</span>
<span class="mi">0</span><span class="o">:</span> <span class="n">r_cmd</span> <span class="o">&lt;=</span> <span class="n">command_zero</span><span class="o">;</span>
<span class="c1">// ....
</span><span class="k">endcase</span></code></pre></figure>

<p>We’d also only update the registers controlled by this sequence if the
delay counter were zero, <em>and</em> the next command didn’t request a delay.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">((</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">r_cmd</span><span class="p">[</span><span class="n">OPCODE</span><span class="p">]))</span>
<span class="k">begin</span>
	<span class="n">in_refresh</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">in_refresh</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">;</span>
	<span class="n">refresh_cmd</span> <span class="o">&lt;=</span> <span class="n">r_cmd</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span><span class="o">;</span>
	<span class="n">stall_bus</span>   <span class="o">&lt;=</span> <span class="n">r_cmd</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">;</span>
	<span class="c1">// ... and so on
</span><span class="k">endcase</span></code></pre></figure>

<p>With all of that out of the way, the only new feature remaining is the counter
itself.  In this case, on any new delay instruction we set the counter to the
value given in the instruction, otherwise if the counter is greater than zero
we count down.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">((</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">r_cmd</span><span class="p">[</span><span class="n">OPCODE</span><span class="p">]))</span>
	<span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">r_cmd</span><span class="p">[</span><span class="n">OPCODE</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">counter</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>The counter really is that basic.  Indeed, perhaps you’ve noticed that many of
my formal verification quizzes started out with verifying the properties of
a similar counter.</p>

<p>At least that’s the basic design.  We’ll come back to it in a moment and fill in
the details.</p>

<h2 id="the-problem-with-induction">The Problem with Induction</h2>

<p>If you’ve been reading my blog for a while, you may remember how I’ve described
the <a href="/blog/2018/03/10/induction-exercise.html">problem associated with induction
before</a>.
<a href="/blog/2018/03/10/induction-exercise.html">Induction</a>
is important enough that we can’t really skip it.  Without
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
you cannot formally verify anything beyond the reset sequence.  Without
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
you cannot prove that the properties in your design never fail.</p>

<p>Well, okay, that’s a debatable presumption.  I should point out that there
are others who don’t use
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
as regularly as I do.  For example, Clifford Wolf, the author of the
<a href="https://github.com/cliffordwolf/picorv32">picorv32 RISC-V CPU</a>,
<a href="https://github.com/YosysHQ/SymbiYosys">Yosys</a>,
<a href="https://github.com/YosysHQ/SymbiYosys">SymbiYosys</a>, and the <a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal set
of formal properties for RISC-V CPU
verification</a> tends not to use
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
as much.  Indeed, a strong argument can be made for not using
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>: it’s
complex, hard to learn, it requires its own way of thinking, and for certain
problems a bounded model check can be equivalent.</p>

<p>We can illustrate this with a basic
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
Suppose we had a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
with a 9-stage pipeline.  Chances are we could fully verify it in 20 clock
cycles.  I’ll admit, I’m guess with these numbers, but there is a mathematical
way to determine this distance and I think I can argue that the minimum bounded
check needs to be longer than a full operation.  That said, I often find myself
verifying cores with minimum cycle lengths that last longer than 256 cycles,
such as these AXI
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/aximm2s.v">MM2S</a> or
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axis2mm.v">S2MM</a> cores.
Simply put, 
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
is an important tool, but it does have its place.</p>

<p>When you use
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>, you
will find the traces shows the <em>appearance</em> of having started the design
somewhere between the initial state and eternity.  However, this view of
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
often frustrates engineers who use it, because they’ll point out that <code class="highlighter-rouge">X</code>
must happen before <code class="highlighter-rouge">Y</code> gets set, but somehow <code class="highlighter-rouge">Y</code> is getting set without
ever passing <code class="highlighter-rouge">X</code>.  “But I initialized that value!” is a common refrain
that I hear.</p>

<p>The problem is that this is not how
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
actually works.
<a href="/blog/2018/03/10/induction-exercise.html">Induction</a>
works by piecing together some number of logic steps for your core that don’t
break any assertions, and then tries to break your assertions on the last step.
It only offers the appearance that the state chosen is in the middle of time.
In reality, the “initial” values in the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
trace are arbitrary–they could be anything, with the only requirements
that they don’t break any assumptions, and again that they don’t break any
assertions until the last step.</p>

<p>As a result, because the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a> step
doesn’t start at the initial time step, constraining every register in the
design becomes important.  This includes the registers set by our <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>.</p>

<p>To bring this point home, I had a couple of memory rules that weren’t passing
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.
Things like, REFRESH commands that could only be issued once all the banks had
been placed in their idle modes, or that PRECHARGE commands could only take
place no earlier than some (configurable) number of clock cycles after ACTIVATE
commands, etc.</p>

<p>The particular problem is common among pipelined processes: Unless the various
pipeline stages are so constrained, the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
engine might start in a state where the stages have no relationship to each
other.  The <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>
might load a command to be decoded, and then the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
engine starts with a command in that register that’s not in the command set.
Or it might start outputting a value that nothing in the command set would
allow.  Or it might do both.</p>

<p><a href="/blog/2018/03/10/induction-exercise.html">Induction</a>
can seem kind of strange in that way.</p>

<p>The way we’ll solve this
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
problem is by walking a <em>microcode address</em> through the various pipeline stages
of processing.  We’ll use one value to describe the address pipeline stage,
<code class="highlighter-rouge">f_addr</code>, one for the command stage, <code class="highlighter-rouge">f_cmd</code>, and one to describe the currently
active outputs, <code class="highlighter-rouge">f_active</code>–the final pipeline stage.  These three are all
<em>addresses</em> into our instruction stream.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="n">LGNCMDS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_addr</span><span class="o">,</span> <span class="n">f_cmd</span><span class="o">,</span> <span class="n">f_active</span><span class="o">;</span></code></pre></figure>

<p>We’ll set all three of these pipeline-addresses to zero initially
and again upon any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="o">{</span> <span class="n">f_active</span><span class="o">,</span> <span class="n">f_cmd</span><span class="o">,</span> <span class="n">f_addr</span> <span class="o">}</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">f_active</span><span class="o">,</span> <span class="n">f_cmd</span><span class="o">,</span> <span class="n">f_addr</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span></code></pre></figure>

<p>In all other cases, we’ll increment the address whenever we step the <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>
forward by one step.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_step</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">f_addr</span> <span class="o">&lt;=</span> <span class="n">f_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
		<span class="o">{</span> <span class="n">f_active</span><span class="o">,</span> <span class="n">f_cmd</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_cmd</span><span class="o">,</span> <span class="n">f_addr</span> <span class="o">};</span>
	<span class="k">end</span></code></pre></figure>

<p>The next step is to convert these addresses to commands.  We can use a large
parameter to store these commands.  If we have <code class="highlighter-rouge">NCMDS</code> commands, each <code class="highlighter-rouge">WORDWID</code>
wide, this might look like,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="n">NCMDS</span><span class="o">*</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">COMMANDS</span> <span class="o">=</span> <span class="o">{</span>
			<span class="c1">// An arbitrary set of commands
</span>			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h0</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h3</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mh">6'h02</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'hb</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h3</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mh">6'h02</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'ha</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mh">6'h2f</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h0f</span> <span class="o">}</span>
			<span class="o">};</span></code></pre></figure>

<p>We can then use a simple Verilog <em>function</em> to turn this command address into
its associated command.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">function</span> <span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">getcommand</span><span class="o">;</span>
		<span class="kt">input</span>	<span class="p">[</span><span class="n">LGNCMDS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_addr</span><span class="o">;</span>

		<span class="n">getcommand</span> <span class="o">=</span> <span class="n">COMMANDS</span><span class="p">[</span><span class="n">i_addr</span> <span class="o">*</span> <span class="n">WORDWID</span> <span class="o">+:</span> <span class="n">WORDWID</span><span class="p">]</span><span class="o">;</span>
	<span class="k">endfunction</span></code></pre></figure>

<p>While I don’t normally use functions, in this case the function is the key
to this whole algorithm.  Why?  Because I can now reuse the function throughout
to map addresses to commands.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// f_active_cmd is the command that's currently *active* and defining
</span>	<span class="c1">// outputs
</span>	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_active_cmd</span> <span class="o">=</span> <span class="n">getcommand</span><span class="p">(</span><span class="n">f_active</span><span class="p">)</span><span class="o">;</span>

	<span class="c1">// f_cmd_cmd describes the command currently waiting to be interpreted
</span>	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_cmd_cmd</span> <span class="o">=</span> <span class="n">getcommand</span><span class="p">(</span><span class="n">f_cmd</span><span class="p">)</span><span class="o">;</span>

	<span class="c1">// f_prior_cmd is the command I was just executing before the current
</span>	<span class="c1">// one
</span>	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_prior_cmd</span> <span class="o">=</span> <span class="n">getcommand</span><span class="p">(</span><span class="n">f_active</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Because there is a single common mapping from address to command, used by both
the logic of the core and the logic of the formal properties, I can assert that
these copies of the various commands actually match what each stage of the
algorithm should be doing.</p>

<p>Only one other big step is required: we’ll need to constrain all of these
addresses with respect to each other.  You know, the <code class="highlighter-rouge">f_cmd</code> address must
follow <code class="highlighter-rouge">f_addr</code>, and <code class="highlighter-rouge">f_active</code> must follow <code class="highlighter-rouge">f_cmd</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">f_cmd</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">)</span><span class="o">;</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">f_active</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">f_cmd</span><span class="p">)</span><span class="o">;</span>
<span class="k">end</span></code></pre></figure>

<p>Of course, this is only an overview.  The actual logic, below, corrects
several details.  For example, <code class="highlighter-rouge">assert(f_cmd + 1 == f_addr);</code> will fail if
<code class="highlighter-rouge">f_cmd</code> is about to roll over to the next bit.  Similarly, my reset sequence
needs to be run only once starting from a reset command, whereas the refresh
sequence needs to repeat over and over forever.  The main core of the logic,
however, remains as simple as it always was.</p>

<p>Shall we take a peek at how this is done?</p>

<h2 id="microcontroller-logic">MicroController Logic</h2>

<p>Let’s look over the basic logic of <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">this really simple ultra-micro
controller</a>.</p>

<p>First, since I only want to build this once, I’ve chosen to make it highly
configurable.  The core accepts a parameterized number of command bits and
again a parameterized number of delay bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">genuctrl</span><span class="p">(</span><span class="n">i_clk</span><span class="o">,</span> <span class="n">i_reset</span><span class="o">,</span> <span class="n">o_cmd</span><span class="p">)</span><span class="o">;</span>
	<span class="k">parameter</span>	<span class="n">CMDWIDTH</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
	<span class="k">parameter</span>	<span class="n">LGDELAY</span>  <span class="o">=</span> <span class="mi">6</span><span class="o">;</span></code></pre></figure>

<p>Similarly, the core accepts a power of two length command set.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="n">LGNCMDS</span>  <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
	<span class="k">localparam</span>	<span class="n">NCMDS</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGNCMDS</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Every word in our command set needs to have at least <code class="highlighter-rouge">CMDWIDTH</code> bits,
<code class="highlighter-rouge">LGDELAY</code> bits, plus one more bit for the opcode if <code class="highlighter-rouge">LGDELAY</code> indicates
we’ll use a delay counter in our opcode.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">WORDWID</span>  <span class="o">=</span> <span class="p">((</span><span class="n">LGDELAY</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
			<span class="o">+</span> <span class="p">((</span><span class="n">CMDWIDTH</span> <span class="o">&lt;</span> <span class="n">LGDELAY</span><span class="p">)</span> <span class="o">?</span> <span class="n">LGDELAY</span> <span class="o">:</span> <span class="n">CMDWIDTH</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>We can now create a fairly arbitrary set of commands using this format.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="n">NCMDS</span><span class="o">*</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">COMMANDS</span> <span class="o">=</span> <span class="o">{</span>
			<span class="c1">//
</span>			<span class="c1">// Commands read from the bottom (LSBs are first)
</span>			<span class="c1">// up to the top (MSBs are last)
</span>			<span class="c1">//
</span>			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h0</span> <span class="o">},</span> <span class="c1">// Last command
</span>			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h3</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mh">6'h02</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'hb</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h3</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mh">6'h02</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'ha</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mh">6'h2f</span> <span class="o">},</span>
			<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h0f</span> <span class="o">}</span>	<span class="c1">// First command
</span>			<span class="o">};</span></code></pre></figure>

<p>We’ll also insist that the first command of this sequence, that’s the one
on the bottom, start with an output-register opcode.</p>

<p>Ideally, I’d like to formally verify this core against all possible command
sets.  However, using a parameter to set these commands really keeps me from
doing this.  Why then would I use a parameter to define the commands?</p>

<p>For a couple of reasons.  First, unlike memories, (and even ROM memories!)
parameters cannot change their values during
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.
Second, I am depending upon the properties of the resulting sequence to then
pass verification once this core is incorporated into <a href="https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L366-L387">another as a
submodule</a>.
My goal is to avoid turning this module into a black box that spits out
unconstrained values.  The parent module will depend upon these outputs and
their sequencing for a successful formal proof.</p>

<p>We’ll also pick, arbitrarily, that the first command will set an initial state.
All values throughout our processing chain will then get reset to this initial
state on any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">INITIAL_COMMAND</span> <span class="o">=</span> <span class="n">COMMANDS</span><span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Finally, we’ll support two options: <code class="highlighter-rouge">OPT_REPEAT</code> and <code class="highlighter-rouge">OPT_DELAY</code>.  <code class="highlighter-rouge">OPT_REPEAT</code>,
if set, will indicate that we want to keep repeating these commands over and
over–such as the refresh cycle.  If <code class="highlighter-rouge">OPT_REPEAT</code> is clear, we’ll go through
this sequence once and stop on the last step–as the reset sequence will want
to do.  <code class="highlighter-rouge">OPT_DELAY</code> on the other hand is a simple short hand for checking
whether or not we have one or more bits allocated to the delay counter.
If <code class="highlighter-rouge">OPT_DELAY</code> is clear, the counter will remain at zero and all commands will
proceed at the same pace.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_REPEAT</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">localparam</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">OPT_DELAY</span> <span class="o">=</span> <span class="p">(</span><span class="n">LGDELAY</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>With that aside, we can move into the <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">design
itself</a>.</p>

<p>Our first task will be to create a global step signal, <code class="highlighter-rouge">r_step</code>.  If this
signal is ever true, all of our various states will step forward.  Our goal
will be to set <code class="highlighter-rouge">r_step</code> so that it is only ever true if the counter is zero,
so that it can replace the <code class="highlighter-rouge">r_count == 0</code> logic check above and simplify
our logic.</p>

<p>So here’s how this works.  We’ll start with the wait count kept in <code class="highlighter-rouge">r_count</code>.
We’ll set this to zero initially so that the first command can always
contain the bits to output on any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_DELAY</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">DELAY_COUNTER</span>
		<span class="kt">reg</span>	<span class="p">[</span><span class="n">LGDELAY</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">r_count</span><span class="o">;</span>

		<span class="k">initial</span>	<span class="n">r_count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span></code></pre></figure>

<p>While the opcode might start with a delay, this turns out to be rather
problematic, since it leaves the output registers undefined both initially
and following any reset.  Disallowing this simplifies our initial and
reset logic therefore.</p>

<p>The reset should always bring this counter back to this same original state.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">r_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span></code></pre></figure>

<p>Every time the counter reaches (or stays at) zero, we’ll advance to the next
instruction.  If that instruction, kept in <code class="highlighter-rouge">r_cmd</code>, contains a delay
instruction then we’ll set the counter to that delay, otherwise we’ll keep it
at zero.  (Remember, <code class="highlighter-rouge">r_step</code> is equivalent to <code class="highlighter-rouge">r_count == 0</code>.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_step</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r_cmd</span><span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="c1">// This is a delay instruction
</span>				<span class="n">r_count</span> <span class="o">&lt;=</span> <span class="n">r_cmd</span><span class="p">[</span><span class="n">LGDELAY</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
			<span class="k">else</span>
				<span class="c1">// This is a command instruction
</span>				<span class="n">r_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span></code></pre></figure>

<p>Finally, if <code class="highlighter-rouge">r_count != 0</code>, we’ll decrement it until it does equal zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span>
			<span class="n">r_count</span> <span class="o">&lt;=</span> <span class="n">r_count</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>In order to stay off of the critical timing path, we’ll set <code class="highlighter-rouge">r_step</code> so that
it’s equivalent to <code class="highlighter-rouge">r_count == 0</code>.  That means that it’s logic will (roughly)
mirror that of <code class="highlighter-rouge">r_count</code> above, with only a few subtle differences.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">r_step</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">r_step</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_step</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r_cmd</span><span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="c1">// This is a delay instruction
</span>				<span class="n">r_step</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r_cmd</span><span class="p">[</span><span class="n">LGDELAY</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
			<span class="k">else</span>
				<span class="c1">// This is a command instruction
</span>				<span class="n">r_step</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">;</span>
		<span class="k">end</span> <span class="k">else</span> <span class="c1">// if (!r_step)
</span>			<span class="n">r_step</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>While the logic above is fairly straightforward, getting it right and convincing
yourself that it’s right can be valuable.  For this, we’ll set up a single
formal property to make certain that <code class="highlighter-rouge">r_step</code> is truly equivalent to
<code class="highlighter-rouge">r_count ==  0</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_step</span> <span class="o">==</span> <span class="p">(</span><span class="n">r_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>We can also check the counter against the currently active instruction.
If the instruction is not a delay OpCode, then the counter must be zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_active_cmd</span><span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Otherwise it must be less than the delay specified in the current command.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">r_count</span> <span class="o">&lt;=</span> <span class="n">f_active_cmd</span><span class="p">[</span><span class="n">LGDELAY</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="o">;</span>
<span class="cp">`endif</span></code></pre></figure>

<p>Finally, if the number of delay bits is zero, <code class="highlighter-rouge">LGDELAY==0</code> and so <code class="highlighter-rouge">!OPT_DELAY</code>,
then the <code class="highlighter-rouge">r_step</code> signal should always be high.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">r_step</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>That leaves three primary steps left to this algorithm.</p>

<p>The first is to calculate the next command address.  Because we have chosen
a super simple command set, there are no
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">jumps</a>,
no <a href="/blog/2017/08/14/strategies-for-pipelining.html">pipeline stalls</a>, nothing
but the next address.  That means we can keep this logic as simple as
initializing the address to zero and then perpetually incrementing it every
time we step forward.</p>

<p>That would work if we wanted to repeat this logic forever–such as with the
refresh sequence.  If we want to stop, though–such as at the end of the reset
sequence, then we’ll need recognize a last address and stop incrementing
<code class="highlighter-rouge">r_addr</code> once we get there.  In the logic below, this last address is captured
by <code class="highlighter-rouge">(&amp;r_addr)</code>–the address with every bit set.  If we are not repeating,
we’ll stop at this address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">r_addr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_step</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">OPT_REPEAT</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r_addr</span><span class="p">)))</span>
		<span class="n">r_addr</span> <span class="o">&lt;=</span> <span class="n">r_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>The second of the three remaining steps is to read the command from our
parameter set.  Other than the initialization and reset logic, this is
very straightforward.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_cmd</span> <span class="o">=</span> <span class="n">INITIAL_COMMAND</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">r_cmd</span> <span class="o">&lt;=</span> <span class="n">INITIAL_COMMAND</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_step</span><span class="p">)</span>
		<span class="n">r_cmd</span> <span class="o">&lt;=</span> <span class="n">getcommand</span><span class="p">(</span><span class="n">r_addr</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Finally, the last step is to act upon the command.  For this core, we’ll act
upon it by setting a number of bits in our output, <code class="highlighter-rouge">o_cmd</code>, based upon the
values captured by the command.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">r_step</span><span class="p">)</span>
	<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">r_cmd</span><span class="p">[</span><span class="n">CMDWIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Or, at least that’s the thought.</p>

<p>The problem is that we only want to set our output bits on a command opcode
and not on a wait opcode.  So we now need to check if either we aren’t
implementing the wait opcode, or if the next command isn’t a wait command,
before setting our output bits based upon the instruction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">r_step</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_DELAY</span> <span class="o">||</span> <span class="o">!</span><span class="n">r_cmd</span><span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
	<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">r_cmd</span><span class="p">[</span><span class="n">CMDWIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>But what should our initial and reset value be?  Ideally, we’d want to set
<code class="highlighter-rouge">o_cmd</code> initially to whatever was in the first instruction and then
update it on every step following.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">INITIAL_COMMAND</span><span class="p">[</span><span class="n">CMDWIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_cmd</span> <span class="o">&lt;=</span> <span class="n">INITIAL_COMMAND</span><span class="p">[</span><span class="n">CMDWIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_step</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_DELAY</span> <span class="o">||</span> <span class="o">!</span><span class="n">r_cmd</span><span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">o_cmd</span> <span class="o">=</span> <span class="n">r_cmd</span><span class="p">[</span><span class="n">CMDWIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>We’ve already discussed the <code class="highlighter-rouge">getcommand</code> function above, so we don’t
really need to discuss it more here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">function</span> <span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">getcommand</span><span class="o">;</span>
		<span class="kt">input</span>	<span class="p">[</span><span class="n">LGNCMDS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_addr</span><span class="o">;</span>

		<span class="n">getcommand</span> <span class="o">=</span> <span class="n">COMMANDS</span><span class="p">[</span><span class="n">i_addr</span> <span class="o">*</span> <span class="n">WORDWID</span> <span class="o">+:</span> <span class="n">WORDWID</span><span class="p">]</span><span class="o">;</span>
	<span class="k">endfunction</span></code></pre></figure>

<p>Voila!  That’s the logic to our <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>:
1) calculate an instruction address, 2) read the instruction, and then
3) do what it tells you to.</p>

<p>Hopefully this logic appears quite straightforward.  It’s supposed to be.
If not, feel free to <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">review the Verilog
design</a>
yourself to see how it works.
It’s supposed to be a very simple and reusable logic structure.</p>

<h2 id="formal-verification">Formal Verification</h2>

<p>That’s the basic logic associated with this simple <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>,
now let’s take a look at the formal properties necessary to force the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
engine into a consistent state.</p>

<p>There are two things to note before starting: First, this <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>
has only one input, <code class="highlighter-rouge">i_reset</code>.  That’s it.  That means we don’t need to make
any assumptions about how the various inputs might relate to each other.</p>

<table align="center" style="float: left"><caption>Fig 4. Formal Packets</caption><tr><td><img src="/img/genuctrl/fpipe.svg" alt="" width="480" /></td></tr></table>

<p>Second, our basic approach will be to shadow the <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>’s
pipeline with a set of registers used only for formal verification–a packet
of information if you will.  This is very similar to the way
<a href="https://github.com/cliffordwolf/riscv-formal">riscv-formal</a> works:
you form a packet of information describing each instruction as it goes through
the pipeline.  In this case, however, we’ll draw our assertions about that
packet as it works its way through the pipeline rather than just at the end
as <a href="https://github.com/cliffordwolf/riscv-formal">riscv-formal</a> does.</p>

<p>I’m also going to use the abbreviations <code class="highlighter-rouge">f_addr</code>, <code class="highlighter-rouge">f_cmd</code>, and <code class="highlighter-rouge">f_active</code> to
describe the three different pipeline stages, while <code class="highlighter-rouge">prior</code> will be used to
describe any stage prior to <code class="highlighter-rouge">active</code>.  Therefore, <code class="highlighter-rouge">f_active_cmd</code> will refer to
the command currently being carried out, whereas <code class="highlighter-rouge">f_cmd_cmd</code> will refer to the
command we are going to interpret next, and so forth.  This will allow us to
assert, in a moment, that the output command bits are equal to either the low
order bits of <code class="highlighter-rouge">f_active_cmd</code>, or the low order bits of the prior command,
<code class="highlighter-rouge">f_prior_cmd</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="c1">// reg	[LGNCMDS-1:0]	f_addr, f_cmd, f_active;
</span>	<span class="kt">reg</span>	<span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_active_cmd</span><span class="o">,</span> <span class="n">f_cmd_cmd</span><span class="o">,</span> <span class="n">f_prior_cmd</span><span class="o">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="n">LGNCMDS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">fn_cmd</span><span class="o">,</span> <span class="n">fn_active</span><span class="o">;</span>
	<span class="kt">reg</span>	<span class="n">f_past_valid</span><span class="o">;</span></code></pre></figure>

<p>Our first step will be to get a copy of the commands that should be
executing in each of the various stages of processing–as outlined in Fig. 4
above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_active_cmd</span> <span class="o">=</span> <span class="n">getcommand</span><span class="p">(</span><span class="n">f_active</span><span class="p">)</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_cmd_cmd</span> <span class="o">=</span> <span class="n">getcommand</span><span class="p">(</span><span class="n">f_cmd</span><span class="p">)</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_prior_cmd</span> <span class="o">=</span> <span class="n">getcommand</span><span class="p">(</span><span class="n">f_active</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_cmd</span> <span class="o">==</span> <span class="n">getcommand</span><span class="p">(</span><span class="n">f_cmd</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>As discussed above, we’ll shadow the next command address with <code class="highlighter-rouge">f_addr</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_addr</span> <span class="o">==</span> <span class="n">r_addr</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Then, on each step, we’ll move push one command in and through the pipeline.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="o">{</span> <span class="n">f_active</span><span class="o">,</span> <span class="n">f_cmd</span><span class="o">,</span> <span class="n">f_addr</span> <span class="o">}</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">f_active</span><span class="o">,</span> <span class="n">f_cmd</span><span class="o">,</span> <span class="n">f_addr</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_step</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_REPEAT</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f_addr</span><span class="p">))</span>
			<span class="n">f_addr</span> <span class="o">&lt;=</span> <span class="n">f_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
		<span class="o">{</span> <span class="n">f_active</span><span class="o">,</span> <span class="n">f_cmd</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_cmd</span><span class="o">,</span> <span class="n">f_addr</span> <span class="o">};</span>
	<span class="k">end</span></code></pre></figure>

<p>One of the hassles of dealing with addition wrapping in a finite number
of bits is that <code class="highlighter-rouge">value + 1</code> uses one more bit than <code class="highlighter-rouge">value</code> rather than
wrapping.  To make certain that adding one to a value causes the sum to
remain within the right number of bits, we need to force it back to the
bit-width of our address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">fn_cmd</span> <span class="o">=</span> <span class="n">f_cmd</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">fn_active</span> <span class="o">=</span> <span class="n">f_active</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span></code></pre></figure>

<p>Now that I have that, I can work through how the addresses should exist
in relationship to each other.  Let’s start with the case where the <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>
goes through its instructions in a one-shot (non-repeating) manner.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_REPEAT</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>We start out with everything at zero, so if <code class="highlighter-rouge">f_addr</code> is still at zero then
everything else must still be at zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">f_addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_cmd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Otherwise, if the <code class="highlighter-rouge">f_cmd</code> stage is still at address zero, then we are one step
further–having incremented <code class="highlighter-rouge">f_addr</code> but not yet propagated that incremented
value to <code class="highlighter-rouge">f_cmd</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f_cmd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_addr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Now let’s turn to look at the other end.  If <code class="highlighter-rouge">f_active</code> is all ones, then it’s
saturated at the last instruction as has everything before it.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">f_active</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f_cmd</span><span class="p">)</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f_addr</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>If <code class="highlighter-rouge">f_active</code> hasn’t yet saturated, but <code class="highlighter-rouge">f_cmd</code> has, then <code class="highlighter-rouge">f_active</code> will
saturate on the next clock.  Of course, <code class="highlighter-rouge">f_cmd</code> can’t get to the last value
unless <code class="highlighter-rouge">f_addr</code> has already done so, so <code class="highlighter-rouge">f_addr</code> must be on the last address
as well.  Finally, notice how we can check <code class="highlighter-rouge">f_active+1</code> against <code class="highlighter-rouge">f_cmd</code> without
worrying about overflow, since <code class="highlighter-rouge">f_cmd</code> is already the maximum positive number
and <code class="highlighter-rouge">f_active</code> one less.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">f_cmd</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f_addr</span><span class="p">)</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_active</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">f_cmd</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>If none of those special cases are true, then we must be somewhere in the
middle: <code class="highlighter-rouge">f_addr + 2 == f_cmd + 1 == f_active</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_cmd</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">)</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_active</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">f_cmd</span><span class="p">)</span><span class="o">;</span>
		<span class="k">end</span></code></pre></figure>

<p>The case where we repeat is a touch more interesting.  In this case, <code class="highlighter-rouge">f_active</code>
will remain equal to <code class="highlighter-rouge">f_cmd</code> for the first two initial clock cycles.  In the
first cycle, <code class="highlighter-rouge">f_addr == f_cmd == f_active == 0</code>.   In the second cycle,
<code class="highlighter-rouge">f_addr == 1</code>, while <code class="highlighter-rouge">f_cmd == f_active == 0</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_active</span> <span class="o">==</span> <span class="n">f_cmd</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_active</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">f_addr</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Once we get past those two first cycles, we then know that <code class="highlighter-rouge">f_addr == f_cmd+1</code>
and <code class="highlighter-rouge">f_cmd == f_active + 1</code> with the exception that we have to math that will
wrap around after the last instruction.  This was why we created <code class="highlighter-rouge">fn_cmd</code> and
<code class="highlighter-rouge">fn_active</code>, and then limited them to the bare width of any address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fn_cmd</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">)</span><span class="o">;</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fn_active</span> <span class="o">==</span> <span class="n">f_cmd</span><span class="p">)</span><span class="o">;</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>Now, what about our outputs?  Realistically, that’s what we want to guarantee,
that we have the right outputs.  Those are kept in <code class="highlighter-rouge">o_cmd</code>, and consist of the
bottom several bits of any command word.</p>

<p>Here’s where all of our address work pays off.  Because we’ve set
<code class="highlighter-rouge">f_active_cmd</code> to be equal to the instruction at <code class="highlighter-rouge">f_active</code>, we can assert that
<code class="highlighter-rouge">o_cmd</code> matches the bits in <code class="highlighter-rouge">f_active_cmd</code>.</p>

<p>Well, not quite.  What if the command in the last pipeline stage is a delay
command?  Okay, so as long as it’s not a delay command we can make this
assertion.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_DELAY</span> <span class="o">||</span> <span class="o">!</span><span class="n">f_active_cmd</span><span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_cmd</span> <span class="o">==</span> <span class="n">f_active_cmd</span><span class="p">[</span><span class="n">CMDWIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>But what if it is a delay command?  In that case, our outgoing command bits
must match those of the prior command.  As before, though, that’s only if
the prior command isn’t also a delay.  Since it’s not likely that we’ll ever
want to place two delays in a row, this should be good enough.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">f_active</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">f_prior_cmd</span><span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_cmd</span> <span class="o">==</span> <span class="n">f_prior_cmd</span><span class="p">[</span><span class="n">CMDWIDTH</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="o">;</span></code></pre></figure>

<p>There’s one other assertion we should make, and that is that the initial
command word is going to set <code class="highlighter-rouge">o_cmd</code> rather than be a delay instruction.
So let’s assert that this initial opcode is a set-bits op-code, that way
we’ll know that we always have a good set of output bits from the initial
state or the reset state forward.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">INITIAL_COMMAND</span><span class="p">[</span><span class="n">WORDWID</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">;</span>
<span class="cp">`endif</span>
<span class="k">endmodule</span></code></pre></figure>

<h2 id="the-reset-sequence">The Reset Sequence</h2>

<p>Before leaving this topic, let’s take a quick peek at how this <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/genuctrl.v">ultra-micro
controller</a>
gets used in an <a href="https://github.com/ZipCPU/zipstormmx/blob/master/rtl/wbsdram.v">SDRAM
controller</a>.
In particular, within <a href="https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v">this controller</a> for the iCE CORE
board,
you have <a href="https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L578-L607">this piece of logic</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="p">[</span><span class="mi">11</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">MODE_COMMAND</span> <span class="o">=</span>
			<span class="o">{</span> <span class="mb">5'b00000</span><span class="o">,</span>	<span class="c1">// Burst reads and writes
</span>			<span class="n">CAS_LATENCY</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span><span class="c1">// CAS latency (3 clocks)
</span>			<span class="mb">1'b0</span><span class="o">,</span>		<span class="c1">// Sequential (not interleaved)
</span>			<span class="mb">3'b001</span>		<span class="c1">// 32-bit burst length
</span>			<span class="o">};</span>
	<span class="n">genuctrl</span> <span class="p">#(</span>
		<span class="o">.</span><span class="n">CMDWIDTH</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">LGDELAY</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">LGNCMDS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">OPT_REPEAT</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">COMMANDS</span><span class="p">(</span><span class="o">{</span>
		<span class="c1">// Read these commands from the bottom up
</span>		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">CMD_NOOP</span><span class="o">,</span>      <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">CMD_NOOP</span><span class="o">,</span>      <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">CMD_NOOP</span><span class="o">,</span>      <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">CMD_NOOP</span><span class="o">,</span>      <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="c1">//
</span>		<span class="c1">// Need two cycles following SET_MODE before the first
</span>		<span class="c1">// command
</span>		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CMD_NOOP</span><span class="o">,</span>      <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CMD_SET_MODE</span><span class="o">,</span>  <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h6</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CMD_NOOP</span><span class="o">,</span>      <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CMD_REFRESH</span><span class="o">,</span>   <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h6</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CMD_NOOP</span><span class="o">,</span>      <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CMD_REFRESH</span><span class="o">,</span>   <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="mh">4'h0</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CMD_NOOP</span><span class="o">,</span>      <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CMD_PRECHARGE</span><span class="o">,</span> <span class="mb">1'b1</span> <span class="o">},</span>
		<span class="c1">// The command list starts here, with a no-op then precharge
</span>		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CMD_NOOP</span><span class="o">,</span>      <span class="n">MODE_COMMAND</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">}</span>
		<span class="o">}</span><span class="p">)</span>
	<span class="p">)</span> <span class="n">reset_controller</span><span class="p">(</span><span class="n">i_clk</span><span class="o">,</span> <span class="n">startup_hold</span><span class="o">,</span>
		<span class="o">{</span> <span class="n">reset_active</span><span class="o">,</span> <span class="n">reset_command</span><span class="o">,</span> <span class="n">reset_addr10</span> <span class="o">}</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>The most difficult thing about reading this is that the commands start from
low addresses and work their way up to higher addresses.  The second challenging
part is to realize that a command followed by a delay of zero issues the
same command twice, and that a command followed by a delay of one issues
it three times–so the actual number is the delay value plus two.  Now, reading
from the bottom up, we have:</p>

<ol>
  <li>The first command is a NOOP, <code class="highlighter-rouge">CMD_NOOP</code>.  It last’s for one cycle.</li>
  <li>The second command is a PRECHARGE command, <code class="highlighter-rouge">CMD_PRECHARGE</code>.  The final
bit, <code class="highlighter-rouge">1'b1</code>, controls the eleventh address bit indicating that this
command precharges all of the banks of the <a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>.</li>
  <li>We then return to a NOOP command.</li>
  <li>We maintain that NOOP command for a one cycle delay.</li>
  <li>Then we issue a REFRESH command, <code class="highlighter-rouge">CMD_REFRESH</code>.</li>
  <li>Set the outputs to a NOOP, and</li>
  <li>Wait <code class="highlighter-rouge">6+1</code> cycles.  (Total 8-cycles of NOOP)</li>
  <li>Issue a second REFRESH command, <code class="highlighter-rouge">CMD_REFRESH</code>.</li>
  <li>Another NOOP</li>
  <li>Wait for <code class="highlighter-rouge">6+1</code> cycles again</li>
  <li>Issue a SETMODE command, <code class="highlighter-rouge">CMD_SET_MODE</code></li>
  <li>Another NOOP</li>
  <li>Finally, that bit just more significant than the 4-bit <a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM
command</a>
gets released This is the flag indicating to the rest of the logic that
the reset sequence is complete.</li>
</ol>

<p>For more information on the meaning of these various commands, you should check
out the data sheet for the
<a href="http://www.issi.com/WW/pdf/42-45S16100H.pdf">ISSI SDRAM</a>.
In general, this sequence just follows directly from the one listed in the
data sheet.</p>

<p>Notice also that all I’ve done is to script the startup script described in the
<a href="http://www.issi.com/WW/pdf/42-45S16100H.pdf">SDRAM Spec</a> directly into the
design.  Framing the problem in terms of this ultra-micro controller made
it fairly easy to do.</p>

<p>That said, perhaps you noticed two confusing things.</p>

<ol>
  <li>
    <p>The instructions read backwards.  I may wish to change this in the future,
but for now that’s how the controller works.</p>
  </li>
  <li>
    <p>If you want to issue 7-cycles of NOOPs, you have to issue two commands.
The first command switches the outgoing <code class="highlighter-rouge">reset_command</code> to a <code class="highlighter-rouge">CMD_NOOP</code>,
and the second command waits.  As built, this is not one command
Worse, a wait cycle of ‘0’ will cause the controller to issue two NOOP’s,
not zero and not one: one for the command, and another for the delay
instruction.</p>
  </li>
</ol>

<h2 id="the-refresh-sequence">The Refresh Sequence</h2>

<p>The other sequence I used this ultra-micro controller for is the refresh
sequence.  In many ways, the refresh sequence is very similar to the reset
sequence.  The biggest difference is that the refresh sequence repeats.</p>

<p>Before diving into this sequence, let me just say that
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
refresh control can be much more complicated than what I’m presenting here.  A
“smart”
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
controller might issue more refreshes any time the chip is idle.  That way the
<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">SDRAM</a>
doesn’t necessarily need to be interrupted when busy–or at least not nearly
as often.</p>

<p>I’m not going to over think this today.  In this case, we’ll use our
<a href="https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L622-L667">ultra-micro controller to drive the refresh logic</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">genuctrl</span> <span class="p">#(</span>
		<span class="o">.</span><span class="n">CMDWIDTH</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">LGDELAY</span><span class="p">(</span><span class="n">LGREF</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">LGNCMDS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">OPT_REPEAT</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">,</span>
		<span class="o">.</span><span class="n">COMMANDS</span><span class="p">(</span><span class="o">{</span>
		<span class="c1">// Read these commands from the bottom up
</span>		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">},</span>
		<span class="c1">//
</span>		<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CK_REFRESH_NOOP_TO_ACTIVATE</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b11</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b11</span><span class="o">,</span> <span class="n">CMD_REFRESH</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CK_PRECHARGE_TO_REFRESH</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b11</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b11</span><span class="o">,</span> <span class="n">CMD_PRECHARGE</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CK_WAIT_FOR_IDLE</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b01</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">CK_REMAINING</span> <span class="o">},</span>
		<span class="o">{</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">REF_ZEROS</span><span class="o">,</span> <span class="mb">2'b00</span><span class="o">,</span> <span class="n">CMD_NOOP</span> <span class="o">}</span>
		<span class="c1">//
</span>		<span class="c1">// ...
</span>		<span class="c1">//
</span>		<span class="o">}</span><span class="p">)</span>
	<span class="p">)</span> <span class="n">refresh_controller</span><span class="p">(</span><span class="n">i_clk</span><span class="o">,</span> <span class="n">reset_active</span><span class="o">,</span>
		<span class="o">{</span> <span class="n">refresh_active</span><span class="o">,</span> <span class="n">refresh_stall</span><span class="o">,</span> <span class="n">refresh_cmd</span> <span class="o">}</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>This <a href="https://github.com/ZipCPU/zipstormmx/blob/e4cb3e6f3bc3ac5831925b28116cb19b4ed09e8d/rtl/wbsdram.v#L622-L667">implementation</a>
is a little different: the refresh command is placed at the low order bits.
The next two most significant bits are a refresh stall, and a refresh active
bit.  In this case, <code class="highlighter-rouge">refresh_stall</code> is an instruction to the bus controller
to stall any bus requests that might be coming into the controller.  That allows
us to flush any active requests through the processing pipeline until the
refresh commands become active and start to override the memory control.</p>

<p>Let’s just scan through this command set briefly, skipping commands in our
broad-brush through it:</p>

<ol>
  <li>We start in reset.  As long as the reset sequence is active, we hold the
controller in reset.</li>
  <li>Once we come out of reset, we’ll issue a NOOP.  Remember, this is also our
initial values that we set our results to during the reset cycle as well.
More importantly, we let the design run normally following the reset
without overriding any normal operation.
We’ll do this for <code class="highlighter-rouge">CK_REMAINING +2</code> clock cycles.  (The formula for this
duration is beyond the scope of this article, but easily verifiable from
within the core.)</li>
  <li>When it’s finally time to start our refresh cycle, we’ll force the Wishbone
interface to stall.  We then wait <code class="highlighter-rouge">CK_WAIT_FOR_IDLE+2</code> cycles for any
commands in process to flush through our interface and the bus to come to
a halt.</li>
  <li>Then we issue a PRECHARGE (all) command to close any active memory banks.
This takes <code class="highlighter-rouge">CK_PRECHARGE_TO_REFRESH+2</code> clock cycles to complete, so we issue
a <code class="highlighter-rouge">CMD_NOOP</code> during these cycles.</li>
  <li>We can finally issue the REFRESH command.  However, we can’t immediately
go back to using the interface.  Instead, we need to wait
<code class="highlighter-rouge">CK_REFRESH_NOOP_TO_ACTIVATE+2</code> cycles before the memory is (almost) ready
to accept a command.</li>
  <li>The next command clears any maintenance-induced bus stalls, and it also
clears our refresh cycle allowing the rest of the memory control to return
to bus control.</li>
  <li>Sadly, though, we need to go through all of the listed commands–even though
we stopped early.  Therefore, we issue idle NOOP’s until we reach the end
of our list before starting over.</li>
</ol>

<p>As with the reset sequence, most of this follows from the
<a href="http://www.issi.com/WW/pdf/42-45S16100H.pdf">ISSI SDRAM specification</a>.
It’s timing driven, and specifically driven to issue one reset at a time
every <code class="highlighter-rouge">N</code> cycles as determined from the
<a href="http://www.issi.com/WW/pdf/42-45S16100H.pdf">specification</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>While I’m not going to argue that this “ultra-micro controller” forms a general
purpose computer, it does have many of the attributes of a more general
purpose computer: It follows a pre-defined “program” or script of instructions.
Each instruction has an “OpCode”.  In this case, the “OpCode” was either to
output a series of bits or to wait for a given count.  Unlike more general
purpose computers, this “ultra-micro controller” has no ability to add,
subtract, test values, or branch.  Still, it was good enough for today’s
purposes to be reused in two different DRAM controllers in two different
ways.</p>

<p>Not only that, this simple example makes a great illustration of how you can
create a packet of information as instructions work their way through a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s pipeline,
and assert consistency with that pipeline along the way.  This is a very
useful pattern that you will likely see time and again when formally
verifying pipelines.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em> And she said to the king, It was a true report that I heard in mine own land of thy acts and of thy wisdom.  Howbeit I believed not the words, until I came, and mine eyes had seen it: and, behold, the half was not told me: thy wisdom and prosperity exceedeth the fame which I heard. (1King 10:6-7)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
