<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Using Sequence Properties to Verify a A Serial Port Transmitter</title>
  <meta name="description" content="For those who have been reading this blog,you’ll know that most of myformalwork has involved the immediate assertion subset of the SystemVerilogAssertion lan...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2019/02/21/txuart.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Using Sequence Properties to Verify a A Serial Port Transmitter</h1>
    <p class="post-meta"><time datetime="2019-02-21T00:00:00-05:00" itemprop="datePublished">Feb 21, 2019</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>For those who have been reading <a href="https://zipcpu.com/">this blog</a>,
you’ll know that most of my
<a href="/blog/2017/10/19/formal-intro.html">formal</a>
work has involved the immediate assertion subset of the SystemVerilog
Assertion language.  I’d like to take this opportunity to discuss some of my
frustrations using <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SVA
sequences</a>,
and illustrate how I was able to replicate much of the functionality I needed
from <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SVA
sequences</a>
with immediate assertions alone.</p>

<p>For this discussion, we’ll use the example of a <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">serial port
transmitter</a>
I built long ago.</p>

<h2 id="the-first-serial-port-transmitter">The First Serial Port Transmitter</h2>

<p>One of my early Verilog projects after starting <a href="/about/gisselquist-technology.html">Gisselquist Technology,
LLC</a> was to build a
<a href="https://github.com/ZipCPU/wbuart32">serial port</a>.</p>

<p>I’ve only learned later, at <a href="https://orconf.org/2017/">ORCONF2017</a> to be exact,
that building a <a href="https://github.com/ZipCPU/wbuart32">serial
port</a> is highly controversial.  At issue is, why should anyone rebuild the wheel?  There are so many
<a href="https://opencores.org/projects">serial ports available on line, examples to look
at</a>, etc., that some would argue that it
hardly makes sense to build one more.  The “market” is quite saturated.</p>

<p>I also discovered, long after implementing my own
<a href="https://github.com/ZipCPU/wbuart32">serial port</a> “the right way” that there’s
a well established interface between a computer and a serial port based upon
the <a href="https://en.wikipedia.org/wiki/16551_UART">16550 serial port</a>.  Of course,
mine was done “right” from the beginning just because it was mine–we need not
go over all of the flaws with that logic today, but there is something to be
said for having pride in your own workmanship.  On the other hand, I’m sure
we can all be critical of an interface that takes multiple steps to configure,
and that even requires paging in and out bytes of data.  We can also be
highly critical of a <a href="https://opencores.org/projects/uart16550">buggy
implementation</a> that can be caused
to send data that it was never commanded to sent.  (It’s amazing what a little
bit of <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a> can
find …)</p>

<p>Yes, I have enjoyed the reality that my own
<a href="https://github.com/ZipCPU/wbuart32">serial port</a> can
be completely configured by writing one 32-bit word to the configuration
register, as shown in Fig 1.</p>

<table align="center" style="float: none"><caption>Fig 1. One 32-bit word can completely configure a UART</caption><tr><td><a href="https://github.com/ZipCPU/wbuart32/blog/master/doc/spec.pdf"><img src="/img/wbuart-setup.png" alt="" width="780" /></a></td></tr></table>

<p>Hence, in <a href="/zipcpu/2017/05/29/simple-wishbone.html">one 32-bit write</a> you can configure:</p>

<ol>
  <li>The <a href="https://en.wikipedia.org/wiki/Baud">baud rate</a>, specified as an
integer divider of the clock.  This integer divider is shown in Fig. 1 as
<code class="highlighter-rouge">Baud CLKS</code></li>
  <li>Whether or not hardware flow control is to be used, shown in Fig. 1 as
<code class="highlighter-rouge">H</code>.</li>
  <li>Whether the serial port would transmit 5, 6, 7, or 8 bit characters.  These
are the <code class="highlighter-rouge">N</code> bits in Fig. 1.</li>
  <li>The <a href="https://en.wikipedia.org/wiki/Parity_bit">parity bit</a>, which can be
either no parity, even or odd parity, or even mark or space fixed parity
values–as specified by bits <code class="highlighter-rouge">P</code> (use parity), <code class="highlighter-rouge">F</code> (fixed parity) and
<code class="highlighter-rouge">T</code> (type of parity).</li>
  <li>If the stop bit is a single stop bit, or rather two stop bits.  This is
specified by bit <code class="highlighter-rouge">S</code> in the setup register.</li>
</ol>

<p>A separate write to the data register could send a <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#Break_condition">break
condition</a>
down the line.</p>

<p>But why did <a href="https://github.com/ZipCPU/wbuart32">my serial port</a> need all this
functionality?  Well, ahm, … it didn’t.  It only needed it because I wanted
to build a <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">full
featured</a>
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>.
Hence, I implemented <a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">every feature that a serial port could or should
have</a>.</p>

<p>Why not? Coding is fun, right?</p>

<p>Sure, but does it work?</p>

<p>Well, I tested the 8 bit character, with one stop bit and
no <a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a> at a
variety of <a href="https://en.wikipedia.org/wiki/Baud">baud rates</a>.  That worked
quite well.</p>

<p>… and this is the problem with a lot of both <a href="https://opencores.org">open</a>
and closed source digital design these days.</p>

<p>It’s one thing to design something that’s easy to do because it’s fun.  It’s
something else entirely to fully verify that all of this (cough unused)
functionality even works.  Indeed, the greater the functionality, the greater
the number of modes something has, the more complex the verification problem
becomes.  How did I know that the design would work if I later asked it to
operate in a mode I had never tested nor verified?  I didn’t.  Worse, when such
a time would come later, I’d likely be <a href="http://zipcpu.com/zipcpu/2019/02/04/debugging-that-cpu.html">trying to verify something
else</a>
and not expecting a bug in a “working”
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>
component.</p>

<p>This is neither <a href="https://en.wikipedia.org/wiki/Black-box_testing">black box</a>
nor <a href="https://en.wikipedia.org/wiki/White-box_testing">white box</a> verification.
It is ticking box verification.</p>

<p>But the story goes on.</p>

<h2 id="the-simplified-serial-port-transmitter">The Simplified Serial Port Transmitter</h2>

<p>The first problem I had with my one-size fits all serial port was that it
wouldn’t fit in a <a href="https://github.com/ZipCPU/s6soc">small
design</a>.  It just had <a href="/blog/2017/06/12/minimizing-luts.html">way too much
logic</a>.
So I simplified it.  Since I only ever used one <a href="https://en.wikipedia.org/wiki/Baud">baud
rate</a>, I created a parameter to fix the
number of clocks per <a href="https://en.wikipedia.org/wiki/Baud">baud</a> to a constant
value.  Since I only ever used 8-data bits, 1 stop bit, and no
<a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>–a protocol sometimes called
<a href="https://en.wikipedia.org/wiki/8-N-1"><code class="highlighter-rouge">8N1</code></a>,
I removed all of the other functionality from the core.</p>

<p>These simplifications lead to my
<a href="https://github.com/ZipCPU/wbuart32/blob/master/txuartlite.v">txuartlite</a> and
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rxuartlite.v">rxuartlite</a>
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>
cores.</p>

<p>At one time, I was scrounging for logic elements so hard that I even
parameterized the number of bits in the integer clock divider.  Perhaps
24-bits was too many.  Yes, design space has been tight.</p>

<p>These two cores became a mainstay of many of my designs–especially if I was
going to use a fixed <a href="https://en.wikipedia.org/wiki/Baud">baud rate</a> with an
<a href="https://en.wikipedia.org/wiki/8-N-1"><code class="highlighter-rouge">8N1</code></a>,
protocol.  How often was that?  Essentially all the time.</p>

<p>But I said this article was about
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>,
so let’s move on to <a href="/blog/2017/10/19/formal-intro.html">formally
verifying</a>
my <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v"><em>lite</em> transmitter
core</a> with
some <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SystemVerilog
sequences</a>.
Once you see how easy and awesome these 
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
can be, we’ll then transition to looking at the <a href="https://github.com/ZipCPU/wbuart32/blob/master/rxuartlite.v">fully functional transmitter
implementation</a>,
and discuss how
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
can be used to verify it.</p>

<h2 id="verifying-the-simplified-transmitter">Verifying the Simplified Transmitter</h2>

<p>If you want to know how to build a
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>
yourself, this probably isn’t the article for you.  Check out my
<a href="/tutorial">tutorial</a> instead.</p>

<p>If you want to know how to verify the receiver, then I’ll caution you that the
proof of my <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v">my lite
receiver</a>
isn’t trivial.  It’s an <a href="/formal/2018/05/31/clkswitch.html">asynchronous
proof</a> that involves
two separate <a href="/blog/2017/10/20/cdc.html">clock domains</a>–one
for the receiver and another subtly different clock for the
(assumed) transmitter.  The proof of <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v">this
receiver</a> was
one of the more challenging proofs I have done–so there’s little likelihood
I can fit it into this blog article.  You are more than welcome to check out
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/rxuartlite.v">the code and formal
properties</a>
yourself if you would like.</p>

<p>No, today we’re going to discuss the
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>
transmitter.  I’m also going to assume you know how to build a
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>
transmitter, and so I’m only
going to discuss a couple of details associated with the implementation.</p>

<p>First, the <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">serial port
transmitter</a>
is built around a state machine.  This state machine has ten separate states:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`define</span>	<span class="n">TXUL_BIT_ZERO</span>	<span class="mh">4'h0</span>
<span class="cp">`define</span>	TXUL_BIT_ONE	4<span class="err">'</span>h1<span class="cp">
`define</span>	TXUL_BIT_TWO	4<span class="err">'</span>h2<span class="cp">
`define</span>	TXUL_BIT_THREE	4<span class="err">'</span>h3<span class="cp">
`define</span>	TXUL_BIT_FOUR	4<span class="err">'</span>h4<span class="cp">
`define</span>	TXUL_BIT_FIVE	4<span class="err">'</span>h5<span class="cp">
`define</span>	TXUL_BIT_SIX	4<span class="err">'</span>h6<span class="cp">
`define</span>	TXUL_BIT_SEVEN	4<span class="err">'</span>h7<span class="cp">
`define</span>	TXUL_STOP	4<span class="err">'</span>h8<span class="cp">
`define</span>	TXUL_IDLE	4<span class="err">'</span>hf</code></pre></figure>

<p>I’ll probably adjust these in due time so that they are defined by <code class="highlighter-rouge">localparam</code>s
instead of macros, but these are the state names today.  Notice how there are
nine transmitting states and an idle state, and that they aren’t all sequential.</p>

<p>The second thing to note is that my design has a <a href="/blog/2017/06/02/generating-timing.html">basic clock
divider</a>, kept
in two parts.  First, there’s the countdown clock.  The logic below has been
simplified, but you should get the idea.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">baud_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="cp">`TXUL_IDLE</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">baud_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">i_wr</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">))</span>
				<span class="c1">// Start transmitting a new byte
</span>				<span class="n">baud_counter</span> <span class="o">&lt;=</span> <span class="n">CLOCKS_PER_BAUD</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">baud_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mh">4'h9</span><span class="p">))</span>
			<span class="c1">// Transmission is finished
</span>			<span class="n">baud_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">baud_counter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="c1">// Count down the number of clocks in a baud
</span>			<span class="c1">// interval
</span>			<span class="n">baud_counter</span> <span class="o">&lt;=</span> <span class="n">baud_counter</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">else</span>
			<span class="c1">// Start the next baud interval for the next
</span>			<span class="c1">// start, data, or stop bits
</span>			<span class="n">baud_counter</span> <span class="o">&lt;=</span> <span class="n">CLOCKS_PER_BAUD</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Second, there’s the <code class="highlighter-rouge">zero_baud_counter</code> value.  This is a registered
value designed to be equivalent of <code class="highlighter-rouge">baud_counter == 0</code>.  As a reminder,
if you ever find yourself drafting code to do something like this, you’d
want to place a reminder in your draft code to,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">zero_baud_counter</span> <span class="o">==</span> <span class="p">(</span><span class="n">baud_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>Finally <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">the
design</a>
has a basic state machine,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_busy</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">initial</span>	<span class="n">state</span>  <span class="o">=</span> <span class="cp">`TXUL_IDLE</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zero_baud_counter</span><span class="p">)</span>
			<span class="c1">// r_busy needs to be set coming into here
</span>			<span class="n">r_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;</span> <span class="cp">`TXUL_STOP</span><span class="p">)</span>	<span class="c1">// STATE_IDLE
</span>		<span class="k">begin</span>
			<span class="n">state</span> <span class="o">&lt;=</span> <span class="cp">`TXUL_IDLE</span><span class="o">;</span>
			<span class="n">r_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">i_wr</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">))</span>
			<span class="k">begin</span>	<span class="c1">// Immediately start us off with a start bit
</span>				<span class="n">r_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
				<span class="n">state</span> <span class="o">&lt;=</span> <span class="cp">`TXUL_BIT_ZERO</span><span class="o">;</span>
			<span class="k">end</span>
		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="c1">// One clock tick in each of these states ...
</span>			<span class="n">r_busy</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&lt;=</span><span class="cp">`TXUL_STOP</span><span class="p">)</span> <span class="c1">// start bit, 8-d bits, stop-b
</span>				<span class="n">state</span> <span class="o">&lt;=</span> <span class="n">state</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">else</span>
				<span class="n">state</span> <span class="o">&lt;=</span> <span class="cp">`TXUL_IDLE</span><span class="o">;</span>
		<span class="k">end</span>
	<span class="k">end</span>

	<span class="k">assign</span>	<span class="n">o_busy</span> <span class="o">=</span> <span class="p">(</span><span class="n">r_busy</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>shift register,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">lcl_data</span> <span class="o">=</span> <span class="mh">8'hff</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_wr</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">))</span>
			<span class="n">lcl_data</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">zero_baud_counter</span><span class="p">)</span>
			<span class="n">lcl_data</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="n">lcl_data</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">};</span></code></pre></figure>

<p>and output bit.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_uart_tx</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_wr</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">r_busy</span><span class="p">))</span>
			<span class="n">o_uart_tx</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span>	<span class="c1">// Set the start bit on writes
</span>		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">zero_baud_counter</span><span class="p">)</span>	<span class="c1">// Set the data bit.
</span>			<span class="n">o_uart_tx</span> <span class="o">&lt;=</span> <span class="n">lcl_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>None of this should look strange to you.  If it does, please check out my
<a href="/tutorial">tutorial</a> for a discussion of how to build a
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>
and why.</p>

<p>I’m just presenting this as a quick background, because I’d like to discuss the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
used to verify this core.</p>

<p>Why
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>?
Because I was looking for a use for them.  Because I wanted to be able to
teach them to others.  Because they are a part of the SystemVerilog standard.
Because … well, I wanted to figure out what they were worth.</p>

<table align="center" style="float: right"><caption>Fig 2. A Basic UART transmission</caption><tr><td><img src="/img/serialtx.png" alt="" width="480" /></td></tr></table>

<p>The basic “contract” associated with a
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>
is that upon any request to send a character, provided you aren’t already busy,
that you then send that character as shown in Fig 2 on the right.</p>

<p>This is fairly easy to express in
<a href="http://www.asic-world.com/systemverilog/assertions4.html">SVA</a>:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span>
		<span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="p">(</span><span class="n">i_wr</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_busy</span><span class="p">)</span>
		<span class="o">|=&gt;</span> <span class="p">((</span><span class="n">o_busy</span><span class="p">)</span> <span class="k">throughout</span> <span class="n">SEND</span><span class="p">(</span><span class="n">CLOCKS_PER_BAUD</span><span class="o">,</span><span class="n">fsv_data</span><span class="p">))</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="o">!</span><span class="n">o_busy</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_uart_tx</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">zero_baud_counter</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>If you aren’t familiar with this notation, this says that …</p>

<ol>
  <li>
    <p>Following any clock where the module is given a write request,
and where the module isn’t busy (<code class="highlighter-rouge">i_wr &amp;&amp; !o_busy</code>) …</p>
  </li>
  <li>
    <p>The port starts transmitting on the next clock.  That’s the <code class="highlighter-rouge">|=&gt;</code> piece.
If the left side of the <code class="highlighter-rouge">|=&gt;</code> is true (it doesn’t need to be) then whatever
follows <em>must</em> be the case.  Finally, throughout the whole
duration that the port is transmitting, <code class="highlighter-rouge">o_busy</code> must be true.</p>

    <p>This <em>transmitting</em> idea is captured by another
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
<code class="highlighter-rouge">SEND</code>.  We’ll get to that next in a moment.  For now, notice that we are
passing two parameters to it.  The first of these is the (fixed) number
of clocks per baud, and the second is the data we wish to send.</p>
  </li>
  <li>
    <p>Once the port has finished transmitting a character, the <code class="highlighter-rouge">o_busy</code> line
should be dropped, and the output wire should be high again.</p>
  </li>
</ol>

<p>What about the <code class="highlighter-rouge">fsv_data</code> value?  Well, it turns out that you can parameterize
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SVA
sequences</a>,
and so tailor them to their environment.  The values given
to them, though, are not necessarily constant.  If the design adjusts any
of the values, the properties within the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
adjust as well.</p>

<p>This was not what I wanted.  I wanted to keep track of the byte value that
was requested.  Once <code class="highlighter-rouge">i_wr &amp;&amp; !o_busy</code> is true, however, <code class="highlighter-rouge">i_data</code> can be
changed as early as the next clock cycle.  Therefore, on a write request,
I captured the data for reference within my design later.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_wr</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_busy</span><span class="p">))</span>
		<span class="n">fsv_data</span> <span class="o">&lt;=</span> <span class="n">i_data</span><span class="o">;</span></code></pre></figure>

<table align="center" style="float: left; padding: 15px"><caption>Fig 3. Serial port sequence assertion structure</caption><tr><td><img src="/img/txuart-seqstructure.svg" alt="" width="360" /></td></tr></table>

<p>Good!  This makes sense so far, so let’s peel the onion back one step further
and dig into the <code class="highlighter-rouge">SEND</code>
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.</p>

<p>Any
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>
transmission consists of a start bit, 8-data bits (in this case)
followed by a stop bit, as shown above in Fig. 2 above.  Each of these “bits”
fills a <a href="https://en.wikipedia.org/wiki/Baud">baud</a> interval entirely.
Therefore, if we could represent a single
<a href="https://en.wikipedia.org/wiki/Baud">baud</a> interval with a
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
of its own, such as one I shall call <code class="highlighter-rouge">BAUD_INTERVAL</code>, we can now represent
these ten intervals with a single parameterized
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
<code class="highlighter-rouge">BAUD_INTERVAL</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">sequence</span>	<span class="n">SEND</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DATA</span><span class="p">)</span><span class="o">;</span>
		<span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="mb">1'b0</span><span class="o">,</span> <span class="n">DATA</span><span class="o">,</span> <span class="mh">4'h0</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DATA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="o">,</span><span class="n">DATA</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span><span class="o">},</span> <span class="mh">4'h1</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DATA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">,</span> <span class="o">,</span><span class="n">DATA</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">2</span><span class="p">]</span><span class="o">},</span> <span class="mh">4'h2</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DATA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">,</span> <span class="o">,</span><span class="n">DATA</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">3</span><span class="p">]</span><span class="o">},</span> <span class="mh">4'h3</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DATA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">,</span> <span class="o">,</span><span class="n">DATA</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">4</span><span class="p">]</span><span class="o">},</span> <span class="mh">4'h4</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DATA</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">,</span> <span class="o">,</span><span class="n">DATA</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">5</span><span class="p">]</span><span class="o">},</span> <span class="mh">4'h5</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DATA</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">,</span> <span class="o">,</span><span class="n">DATA</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">6</span><span class="p">]</span><span class="o">},</span> <span class="mh">4'h6</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DATA</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">,</span> <span class="o">,</span><span class="n">DATA</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">7</span><span class="p">]</span><span class="o">},</span> <span class="mh">4'h7</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DATA</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">,</span> <span class="mh">8'hff</span><span class="o">,</span> <span class="mh">4'h8</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="mb">1'b1</span><span class="o">,</span> <span class="mh">8'hff</span><span class="o">,</span> <span class="mh">4'h9</span><span class="p">)</span><span class="o">;</span>
	<span class="k">endsequence</span></code></pre></figure>

<p>If you’ve never read something like this before, the big thing that you need to
know is that <code class="highlighter-rouge">##1</code> means “on the next clock”.  Hence this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
reads that after the first <code class="highlighter-rouge">BAUD_INTERVAL()</code>, another one will start
immediately on the next clock, followed by another, and so on.</p>

<p>The <code class="highlighter-rouge">BAUD_INTERVAL()</code>s themselves are parameterized, much like the <code class="highlighter-rouge">SEND()</code>
sequence.  First, they are parameterized by the number of clocks per baud,
<code class="highlighter-rouge">CKS</code>.  Then by the value that the output bit is supposed to have, <code class="highlighter-rouge">DAT</code>.  This
works its way from bit zero all the way to bit 7.  They are then parameterized
by the value that the shift register is to have, <code class="highlighter-rouge">SR</code>, and finally the value
that the state variable is to have, <code class="highlighter-rouge">ST</code>.</p>

<p>Putting all of these together, we can define a <code class="highlighter-rouge">BAUD_INTERVAL</code> sequence.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">sequence</span>	<span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DAT</span><span class="o">,</span> <span class="n">SR</span><span class="o">,</span> <span class="n">ST</span><span class="p">)</span><span class="o">;</span>
		<span class="p">((</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">DAT</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">ST</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">lcl_data</span> <span class="o">==</span> <span class="n">SR</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">zero_baud_counter</span><span class="p">))[</span><span class="o">*</span><span class="p">(</span><span class="n">CKS</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">DAT</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">ST</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">lcl_data</span> <span class="o">==</span> <span class="n">SR</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">zero_baud_counter</span><span class="p">)</span><span class="o">;</span>
	<span class="k">endsequence</span></code></pre></figure>

<p>This
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
comes in two parts.  The first part lasts <code class="highlighter-rouge">CKS-1</code> clock intervals.
That’s what the <code class="highlighter-rouge">[*(CKS-1)]</code> means at the end of the first expression.
The second part follows the <code class="highlighter-rouge">##1</code>, and so comes on the next clock after the
first one.  This one is identical, save that <code class="highlighter-rouge">zero_baud_counter</code> is now true
indicating the end of the <a href="https://en.wikipedia.org/wiki/Baud">baud</a> interval.  Put together, this one
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
will require <code class="highlighter-rouge">CKS</code> clocks to complete.</p>

<p>You might also notice a subtle bug in this
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
property, having to deal with the number of clocks in the stop bit.  I’ve
left it in there in order to keep the logic minimal, but the sharp eye might
catch it.</p>

<p>Don’t see it?  We’ll come back to it in the next section.</p>

<p>Now, remember the <a href="/blog/2018/03/10/induction-exercise.html">difficulties with using
induction</a>?
Because of those, I have constrained <em>all</em> of my state variables in this
one interval.  Well, all except the <code class="highlighter-rouge">baud_counter</code>.  As long as the
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
search depth lasts longer than one <a href="https://en.wikipedia.org/wiki/Baud">baud</a> interval, that shouldn’t be a problem.</p>

<p>At this point in my story, I was rather excited!  So far, this was easy.  I
could <a href="/blog/2017/10/19/formal-intro.html">formally verify</a> <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">my
transmitter</a>
using
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>,
each
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
used an appropriate abstraction, and so this was quite readable.  Yes, if you
look through
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">my code</a>,
you’ll find many more assertions within it–probably even more than it requires.</p>

<p>It was only when I returned on to my <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">original, full-featured serial port
design</a>
that I started having problems with these wonderful SystemVerilog
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>.</p>

<h2 id="verifying-the-full-featured-transmitter">Verifying the Full-Featured Transmitter</h2>

<p>My first approach to verifying the <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">full-featured
transmitter</a>
was to adjust how the <code class="highlighter-rouge">BAUD_INTERVAL</code>
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
was defined, and then to make
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
using my new and improved <code class="highlighter-rouge">BAUD_INTERVAL</code>
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
for each of the 5, 6, 7, and 8-bit bytes.  Things then got interesting as
I tried to implement each of the different types of
<a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>,
but we’ll ignore that for now.  I’m not sure I ever figured out how to do that
using
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
properties.  However, I had bigger problems before I got to the
<a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a> bits.
It’s not that my design passed or failed, nor was it that I had an example
of a broken trace.  The problem I was suffering from was much worse.</p>

<p>But let me slow down, and tell you how I ended up struggling with these
wonderful
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
properties.</p>

<p>It started out simply enough: the <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">full featured
transmitter</a>
allows you to adjust the
<a href="https://en.wikipedia.org/wiki/Baud">baud rate</a>.
That should be straightforward.  The problem was first that there was no way
to specify a <em>variable</em> number of repeats of a step in a
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>.
The number of repeats, specified by <code class="highlighter-rouge">[*(CKS-1)]</code> above, only worked because
<code class="highlighter-rouge">CKS</code> was a parameter and thus fixed at synthesis time.  The <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">full featured
serial port
transmitter</a>, 
on the other hand, needed to be able to support a variable number of
clock cycles in each <a href="https://en.wikipedia.org/wiki/Baud">baud</a> interval
or it wouldn’t be able to support changing <a href="https://en.wikipedia.org/wiki/Baud">baud
rates</a>.</p>

<p>Therefore, I adjusted the <a href="https://en.wikipedia.org/wiki/Baud">baud</a>
interval sequence to have an undetermined number of clock cycles, and figured
I’d use other properties to force this to work based upon the constraints
found in <code class="highlighter-rouge">zero_baud_counter</code>.  Once <code class="highlighter-rouge">zero_baud_counter</code> became true,
i.e. once the <a href="https://en.wikipedia.org/wiki/Baud">baud</a>
counter reached zero, the solver would exit the sequence.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">sequence</span>	<span class="n">BAUD_INTERVAL</span><span class="p">(</span><span class="n">CKS</span><span class="o">,</span> <span class="n">DAT</span><span class="o">,</span> <span class="n">SR</span><span class="o">,</span> <span class="n">ST</span><span class="p">)</span><span class="o">;</span>
		<span class="p">((</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">DAT</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">ST</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">lcl_data</span> <span class="o">==</span> <span class="n">SR</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">zero_baud_counter</span><span class="p">))[</span><span class="o">*</span><span class="mi">0</span><span class="o">:</span><span class="p">$]</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">DAT</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">ST</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">lcl_data</span> <span class="o">==</span> <span class="n">SR</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">zero_baud_counter</span><span class="p">)</span><span class="o">;</span>
	<span class="k">endsequence</span></code></pre></figure>

<table align="center" style="float: right"><caption>Fig 4. Four properties could capture each of the 5, 6, 7, or 8-bit transmit sequences</caption><tr><td><img src="/img/txuart-multiseq.svg" alt="" width="360" /></td></tr></table>

<p>I then created various <code class="highlighter-rouge">SEND5</code>, <code class="highlighter-rouge">SEND6</code>, <code class="highlighter-rouge">SEND7</code>, and <code class="highlighter-rouge">SEND8</code>
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>,
all composed of a variety of <code class="highlighter-rouge">BAUD_INTERVAL</code>s within them:
7 <a href="https://en.wikipedia.org/wiki/Baud">baud</a>
intervals in order to send 5-bit data, 8 for sending 6-bits data, etc.</p>

<p>At this point, I was feeling good about <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">this
design</a>.  Yes,
there were more
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
within it than in the <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">lite
design</a>.  Yes, the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
were more verbose.  Still, I was excited: I was finally getting the hang of <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SV
sequences</a>
and starting to really enjoy using them!</p>

<p>That’s when <a href="https://www.clifford.at/yosys">yosys</a> failed to elaborate
my design.</p>

<p>As it turns out, I had by now created so many states that
<a href="https://www.clifford.at/yosys">yosys</a>
was suffering from a complete combinatorial explosion of states my
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
could be in.  Once <a href="https://www.clifford.at/yosys">yosys</a>
hit 2^16 possible states, it gave up with an error message.</p>

<p>This took me by surprise.  There were only 20 states I counted in an 8-bit byte,
18 states in a 7-bit byte, and so forth.  How did
<a href="https://www.clifford.at/yosys">yosys</a> get to over 2^16 states?</p>

<p>I asked the <a href="https://symbioticeda.com">SymbioticEDA</a> team for some help,
and they created a special option which I could use to raise the limit.
Perhaps this might fit in 2^17 states?</p>

<p>Nope.</p>

<p>2^18 states?</p>

<p>Not even.</p>

<p>I went as high as somewhere between 2^22 and 2^24 states.  I don’t remember
the exact number anymore.  No matter what number it was,
<a href="https://www.clifford.at/yosys">yosys</a> plus my computer clearly couldn’t handle
it.  This left me unsure of how many states would’ve been required to
represent this updated design, since I was never able to expand them all.</p>

<p>The problem stems from the fact that SystemVerilog requires that
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>
be re-entrant.  That is, you can start a
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
at any time–even if you are already in the middle of one.  In other
words, even though my design would only ever start on <code class="highlighter-rouge">i_wr &amp;&amp; !o_busy</code>,
and even though <code class="highlighter-rouge">o_busy</code> would be true for the rest of the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>,
the underlying logic was still trying to account for all of the possibilities
where multiple
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
states might be active at a given time.</p>

<p>Ouch.  This meant that nothing was working.  How was I ever going to verify
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">this design</a>?</p>

<h2 id="poor-mans-sequences">Poor Man’s Sequences</h2>

<p>Eventually I figured out a solution to the
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
problem.  My solution is something I’m going to call a “Poor man’s sequences.”
These sequences are built out of immediate assertions, and they don’t use any of
the SystemVerilog concurrent assertions that the free version of
<a href="https://www.clifford.at/yosys">yosys</a>
doesn’t support.</p>

<p>Need to implement an <code class="highlighter-rouge">A|=&gt;B</code> sequence?  This sequence says that if <code class="highlighter-rouge">A</code> is
ever true, then <code class="highlighter-rouge">B</code> must be true on the next clock.  You may have noticed
that I have been writing,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>to describe this case.</p>

<p>Using concurrent assertions, you might’ve written</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assert</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">A</span> <span class="o">|=&gt;</span> <span class="n">B</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Using these “Poor man’s sequences”, you might also write,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="n">f_check</span><span class="o">;</span>
	<span class="k">initial</span>	<span class="n">f_check</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">f_check</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="o">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_check</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>See the idea?  Sure, it’s a bit longer and more verbose, but it captures the
idea of <code class="highlighter-rouge">A</code> must be followed by <code class="highlighter-rouge">B</code>.  Indeed, this was how
<a href="https://www.clifford.at/yosys">yosys</a>
was implementing my original logic anyway.</p>

<p>What about a longer sequence?  Suppose I wanted a sequence of ten states,
such as I might use when transmitting an 8-bit byte over the
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>.
How might that work?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">9</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_sendbyte</span><span class="o">;</span>
	<span class="k">initial</span>	<span class="n">f_sendbyte</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_wr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_busy</span><span class="p">)</span>
		<span class="n">f_sendbyte</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">zero_baud_counter</span><span class="p">)</span>
		<span class="n">f_sendbyte</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">1'b0</span> <span class="o">};</span></code></pre></figure>

<p>I can now make a set of assertions based upon what bit is a one within
<code class="highlighter-rouge">f_sendbyte</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_uart_tx</span><span class="p">)</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">fsv_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">fsv_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">fsv_data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">fsv_data</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">fsv_data</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">fsv_data</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">fsv_data</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_uart_tx</span> <span class="o">==</span> <span class="n">fsv_data</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span><span class="o">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">o_uart_tx</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>What else can I do with this?  I can assert that only one bit of
<code class="highlighter-rouge">f_sendbyte</code> will ever be true at any time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">onehot</span><span class="p">(</span><span class="n">f_sendbyte</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>Okay, <code class="highlighter-rouge">$onehot()</code> requires a
<a href="https://www.clifford.at/yosys">yosys</a>
license.  On the other hand, if I add to each of my assertions which
unique state the design must be in, and if I do it in such a way that no
two assertions could ever be true at the same time, I can then create
something equivalent.</p>

<p>Alternatively, I suppose I could’ve used a counter to describe each state
within this poor man’s sequence.
I’m not sure I have a good reason for not using a counter, other than
these bit-vector representations still maintained an appearance of supporting
the original SystemVerilog
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequences</a>–even
if they weren’t truly concurrent anymore.</p>

<p>What about the assertions that the design is busy while it is transmitting,
but that it lowers its busy flag once the sequence is complete?
To do this, I need to extend my <code class="highlighter-rouge">sendbyte</code> by one more state–the state in
which the <code class="highlighter-rouge">busy</code> flag is dropped.  This one is a bit unusual.  Unlike the
others which all last a full <a href="https://en.wikipedia.org/wiki/Baud">baud</a>
interval, this last state only lasts for one clock cycle at the most.
Hence, I can set and clear it as in:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">10</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_sendbyte</span><span class="o">;</span>
	<span class="k">initial</span>	<span class="n">f_sendbyte</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_wr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_busy</span><span class="p">)</span>
		<span class="n">f_sendbyte</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">zero_baud_counter</span><span class="p">)</span>
		<span class="n">f_sendbyte</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="mb">1'b0</span> <span class="o">};</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
		<span class="c1">// Only allow sendbyte[10] to be true for one
</span>		<span class="c1">// clock cycle--the cycle where o_busy is false
</span>		<span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="o">;</span></code></pre></figure>

<p>Now I can assert my property that <code class="highlighter-rouge">o_busy</code> should be true in the middle of
any character being sent, but false as soon as we are done.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">|</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">9</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_busy</span><span class="p">)</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f_sendbyte</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_busy</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>I’ll admit that, while this is mighty expressive, the code that results seems
to explode in size.  It’s a shame I wasn’t being paid for the number of lines
of code I was writing.</p>

<p>There’s also a really subtle bug here that took writing my
<a href="/tutorial">tutorial</a> to discover: if the last stop bit has the same number of
<a href="https://en.wikipedia.org/wiki/Baud">baud</a> clocks as every other
<a href="https://en.wikipedia.org/wiki/Baud">baud</a> interval, than the
<a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial port</a>
will use one too many clock ticks per byte, as shown in Fig. 5 below.</p>

<table align="center" style="float: right"><caption>Fig 5. If busy is true throughout all the baud intervals, a clock is lost at the transition between bytes</caption><tr><td><img src="/img/txuart-xtrabit.svg" alt="" width="780" /></td></tr></table>

<p>In order to make sure we can transmit at full speed, we’ll need to make certain
that the next byte can start <em>immediately</em> at the end of the last
<a href="https://en.wikipedia.org/wiki/Baud">baud</a>
interval.  This means that on the <em>last clock</em> of the final stop bit, <code class="highlighter-rouge">o_busy</code>
must be low indicating that the core is ready to accept a new character
on last clock of the last character.  Instead, I had built my design so that
<code class="highlighter-rouge">o_busy</code> would stay high throughout the entire duration of the stop bit.</p>

<p>The correct trace should’ve looked like Fig. 6 below.</p>

<table align="center" style="float: right"><caption>Fig 6. o_busy now goes low before the end of the stop bit, so the next byte can now start as soon as the last one finishes</caption><tr><td><img src="/img/txuart-xtrabit-gone.svg" alt="" width="780" /></td></tr></table>

<p>This is a subtle <a href="https://en.wikipedia.org/wiki/Asynchronous_serial_communication">serial
port</a>
bug that I wasn’t expecting in my own code.  Sure, I’d seen it in the code
of others, but in my own?</p>

<p>Oops.</p>

<p>But I digress.  Let’s get back to talking about these poor man’s
sequences again.</p>

<p>It shouldn’t be too hard to imagine that this bit-vector approach could easily
be extended to handle 5, 6, 7 and 8 bit bytes.  Indeed, if you look within <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">my
serial port code</a>,
you’ll find definitions for several sequences:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_five_seq</span><span class="o">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_six_seq</span><span class="o">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_seven_seq</span><span class="o">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_eight_seq</span><span class="o">;</span></code></pre></figure>

<p>I can also do one critical thing that the <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SV
sequence</a>,
approach could not do: I can assert that if any sequence is active, then no
other sequences are active.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_five_seq</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="mb">1'b0</span> <span class="o">==</span> <span class="o">|</span><span class="n">f_six_seq</span><span class="p">)</span><span class="o">;</span>
		<span class="k">assert</span><span class="p">(</span><span class="mb">1'b0</span> <span class="o">==</span> <span class="o">|</span><span class="n">f_seven_seq</span><span class="p">)</span><span class="o">;</span>
		<span class="k">assert</span><span class="p">(</span><span class="mb">1'b0</span> <span class="o">==</span> <span class="o">|</span><span class="n">f_eight_seq</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span></code></pre></figure>

<p>This plus the <code class="highlighter-rouge">$onehot()</code> solution above fixes the explosion of states problem 
<a href="https://www.clifford.at/yosys">yosys</a> was struggling with.</p>

<p>But what about the <a href="https://en.wikipedia.org/wiki/Parity_bit">parity bit</a> or
the optional second stop bit?</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 7. Each byte could end with an optional parity bit, and either one or two stop-bits</caption><tr><td><img src="/img/txuart-stopseq.svg" alt="" width="360" /></td></tr></table>

<p>Using <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SVA
sequence</a>,
I had been struggling to figure out how to handle the
optional <a href="https://en.wikipedia.org/wiki/Parity_bit">parity bit</a> or the optional
extra stop bit.  Ideally, I’d want to define a single
<a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">sequence</a>
that would follow any byte of data no matter how long, and that would
include all of my <a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>
and stop bit options.</p>

<p>This isn’t a problem with these poor man’s sequences, although all of the
options I needed to implement made it somewhat of a challenge.</p>

<p>To handle all of these stop sequences, I created yet another bit vector.  If
ever we were at the end of a <a href="https://en.wikipedia.org/wiki/Baud">baud</a>
interval (i.e. if ever <code class="highlighter-rouge">zero_baud_counter</code> were true), I could check the ends
of my various bit sequences to know if I should enter this new one.</p>

<p>So, for the stop sequence, I created a three bit vector.  The first bit would
be true during the <a href="https://en.wikipedia.org/wiki/Parity_bit">parity bit</a>–if
there was one.  The second bit would
be true during the first of two stop bits, and the third bit would be true
for the final stop bit.  This sequence of states then looked something like,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_stop_seq</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="o">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_break</span><span class="p">))</span>
		<span class="c1">// This would be equivalent to
</span>		<span class="c1">//	disable_iff (i_reset || i_break)
</span>		<span class="n">f_stop_seq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">zero_baud_counter</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// We'll rebuild every bit of this sequence each time through
</span>		<span class="n">f_stop_seq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">;</span>

		<span class="c1">// If we are coming from the parity bit ...
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">f_stop_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dblstop</span><span class="p">)</span>
				<span class="c1">// If there's two stop bits, go to bit '1'
</span>				<span class="n">f_stop_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">else</span>
				<span class="c1">// otherwise go to the last stop bit
</span>				<span class="n">f_stop_seq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">end</span>

		<span class="c1">// Any time we come from the first of two stop bits,
</span>		<span class="c1">// immediately go to the second.
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">f_stop_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">f_stop_seq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>

		<span class="c1">// Now let's check for whether we need to enter the
</span>		<span class="c1">// stop bit sequence.  Following the last bit of any
</span>		<span class="c1">// of our 5, 6, 7, or 8-bit sequences, we'll enter this
</span>		<span class="c1">// sequence of final bits.  This therefore merges these
</span>		<span class="c1">// sequences with a single stop sequence.
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">f_eight_seq</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">|</span> <span class="n">f_seven_seq</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">|</span> <span class="n">f_six_seq</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
			<span class="o">|</span> <span class="n">f_five_seq</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">use_parity</span><span class="p">)</span>
				<span class="c1">// If we are using parity,
</span>				<span class="c1">//   go to the parity state
</span>				<span class="n">f_stop_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dblstop</span><span class="p">)</span>
				<span class="c1">// If we are using two stop bits, go to
</span>				<span class="c1">// the first of the two
</span>				<span class="n">f_stop_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
			<span class="k">else</span>
				<span class="c1">// In all other cases, go to the one
</span>				<span class="c1">// (and only) stop bit period
</span>				<span class="n">f_stop_seq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="o">;</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>Asserting the properties of each of the various states is now a little bit
tedious, but it also works–something which it didn’t before.</p>

<p>As a result, I can now say that I have managed to fully verify both my
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">stripped down serial port transmitter
core</a>,
as well as the <a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuart.v">full featured serial port
transmitter</a>.
Yes, you heard me right, I verified that the core could handle any division
of the clock greater than two, 5, 6, 7 or
8 data bits, no parity, a fixed mark or space parity bit, odd or even
parity, and one or two stop bits–<em>and all combinations of those options</em>!
The core can also handle changing <a href="https://en.wikipedia.org/wiki/Baud">baud
rates</a>, something the
<a href="https://github.com/ZipCPU/wbuart32/blob/master/rtl/txuartlite.v">lite core</a>
could not.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I’ve now started using this approach on several of my newer designs.  For
example, did you notice that at the bottom of my <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">AXI-lite demonstration
code</a>
I used a sequence like this to create a cover trace?  Or, if you’ve been
watching my <a href="https://github.com/ZipCPU/qspiflash/blob/master/rtl/qflexpress.v">Quad-SPI flash
development</a>,
you’ll notice I’ve used these poor man’s sequences for reading from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
continued reading from the
<a href="https://en.wikipedia.org/wiki/Flash_memory">flash</a>,
or reading and writing arbitrary bytes to the QSPI interface.</p>

<p>Yes, I think I still like <a href="http://www.asic-world.com/systemverilog/assertions4.html#Sequences">SystemVerilog’s
sequence</a>
language better.  It’s <em>very</em> expressive.  However, there’s just some things
I haven’t figured out how to express within it that this (uglier) approach
using immediate assertions can handle.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Happy is the man that findeth wisdom, and the man that getteth understanding. (Prov 3:13)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
