<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Formally Verifying Asynchronous Components</title>
  <meta name="description" content="To date, our formal verification efforts have primarily centered aroundsynchronous designs usingyosys,that is those designs where all logic transitions on th...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2018/05/31/clkswitch.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Formally Verifying Asynchronous Components</h1>
    <p class="post-meta"><time datetime="2018-05-31T00:00:00-04:00" itemprop="datePublished">May 31, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>To date, our formal verification efforts have primarily centered around
<em>synchronous</em> designs using
<a href="http://www.clifford.at/yosys">yosys</a>,
that is those designs where all logic transitions on the same clock edge,
rather than looking at
<em><a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a></em>
designs.
The one exception so far has been the description of how to get an
<a href="/formal/2018/04/12/areset.html">asynchronous reset</a>
to pass induction.  I’d like to move beyond this simple example towards
verifying a full <a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf">asynchronous FIFO
design</a>,
but that’s going to require a bit more background in how to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a> an
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
design in general.  Today, therefore, let’s examine how to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a> an
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
component that
<a href="/blog/2017/10/20/cdc.html">crosses between clock domains</a>.</p>

<p>If you aren’t familiar with
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>,
you might wish to go back and review our
<a href="/blog/2017/10/19/formal-intro.html">introductory article</a>
on the topic.  You might also find the
<a href="/blog/2018/03/10/induction-exercise.html">induction exercise</a>
to be valuable as well.</p>

<table align="center" style="float: right"><caption>Fig 1. A Clock Switch Component</caption><tr><td><img src="/img/ckswitch-blkdiag.svg" alt="" width="360" /></td></tr></table>

<p>Today, let’s demonstrate how these same
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
concepts apply an
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
design with two clocks within it.  In this
case, we’ll examine a clock switch.  Such a switch takes two clock inputs
and one line to select between them.  In our case, the two separate clocks
makes a perfect example of how
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
can be applied to an
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
design.</p>

<h1 id="two-clocks">Two Clocks</h1>

<p>The first and most important step is to somehow describe both clocks via
formal properties to the
<a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT solver</a>.
This step is really independent
of anything you might wish to verify, and it applies to any
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
design.  Once you learn the simple trick involved, you’ll then notice that
other <a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
verification proofs follow the exact same approach.</p>

<table align="center" style="float: left"><caption>Fig 2. The Master rule of Formal Verification</caption><tr><td><img src="/img/fv-master-rule.svg" alt="" width="240" /></td></tr></table>
<p>Specifically, we need to provide some assumptions to describe the two clocks
which will be the inputs to our clock switch design.  Why assumptions?
Because these clocks will be inputs, and the basic rule is that you should
always make assumptions about your inputs, and assertions about your local
state and any outputs.</p>

<p>Perhaps you may remember our earlier discussion of how to create a <a href="/blog/2017/06/02/generating-timing.html">fractional
clock divider</a>?
In <a href="/blog/2017/06/02/generating-timing.html">that article</a>,
we used the top bit of a counter as a divided clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">counter</span> <span class="o">+</span> <span class="nb">increment</span><span class="p">;</span>

	<span class="k">assign</span> <span class="n">divided_clock</span> <span class="o">=</span> <span class="n">counter</span><span class="p">[</span><span class="n">MSB</span><span class="p">];</span></code></pre></figure>

<p>Clocks like this one that are generated from logic are often called
<em>logic</em> <em>clocks</em>.  Logic clocks are distinguished from regular clocks in that
are generated from logic within the design, rather than external hardware or
internal
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s,
and are then distributed across the design and used
like a clock.  In general, you don’t want to transition on the positive or
negative edge of any logic clock.  Doing so will make it
harder to achieve timing closure, and it will add additional
<a href="/blog/2017/10/20/cdc.html">clock domain crossing</a>
requirements to your design.
Further, if this divided clock isn’t placed on the clock network, then
it might be seen to rise (or fall) at inconsistent times across the design.</p>

<p>All of these are “bad” hardware consequences.</p>

<p>None of these problems, however, will keep us from using the transitions of
this divided clock as a <em><a href="/blog/2017/10/19/formal-intro.html">formal
constraint</a></em>
on our clock input, so that’s exactly what we are about to do.</p>

<p>We’ll start out by creating counters, <code class="language-plaintext highlighter-rouge">f_*_count</code>, and increments,
<code class="language-plaintext highlighter-rouge">f_*_step</code>, for each input clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">wire</span>	<span class="p">[</span><span class="n">F_CKSTEP</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_a_step</span><span class="p">,</span>  <span class="n">f_b_step</span><span class="p">;</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="n">F_CKSTEP</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_a_count</span><span class="p">,</span> <span class="n">f_b_count</span><span class="p">;</span></code></pre></figure>

<p>In order to handle properties associated with any particular speed, we’ll allow
these increments to be completely arbitrary.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">f_a_step</span> <span class="o">=</span> <span class="p">$</span><span class="n">anyconst</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">f_b_step</span> <span class="o">=</span> <span class="p">$</span><span class="n">anyconst</span><span class="p">;</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">$anyconst</code> description is specific to
<a href="http://www.clifford.at/yosys">yosys</a>.
It means that these values will have a constant value given to
them–any value.  It’s roughly the same as having an extra unconstrained
input to the design and then forcing it to be <code class="language-plaintext highlighter-rouge">$stable</code>.  Alternatively,
you can think of it as a register with no initial statement that doesn’t
produce a
<a href="http://www.clifford.at/yosys">yosys</a>
warning on synthesis.</p>

<p>However, these arbitrary constant values aren’t quite what we want yet.
For example, any increment having a zero value would indicate a clock
that doesn’t tick. 
This is bad, so we’ll force the increments to be greater than zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">f_a_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">f_b_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>In a similar fashion, we can also constrain the clocks so that the fastest
one, whichever that one might be, takes four simulation time steps per cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">((</span><span class="n">f_a_step</span><span class="p">[</span><span class="n">F_CKSTEP</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">F_CKSTEP</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mb">2'b01</span><span class="p">)</span>
			<span class="o">||</span><span class="p">(</span><span class="n">f_b_step</span><span class="p">[</span><span class="n">F_CKSTEP</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">F_CKSTEP</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mb">2'b01</span><span class="p">));</span></code></pre></figure>

<p>This will help make certain that there is always a positive edge to the clock
at least once per cycle.</p>

<p>Now that we have an increment, we just add this increment to our counters on
every formal step–one counter per incoming clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">f_a_count</span> <span class="o">&lt;=</span> <span class="n">f_a_count</span> <span class="o">+</span> <span class="n">f_a_step</span><span class="p">;</span>
		<span class="n">f_b_count</span> <span class="o">&lt;=</span> <span class="n">f_b_count</span> <span class="o">+</span> <span class="n">f_b_step</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Let me draw your attention to the <code class="language-plaintext highlighter-rouge">$global_clock</code> statement within the always
header.  In
<a href="https://en.wikipedia.org/wiki/SystemVerilog">SystemVerilog</a>,
this value needs to be declared earlier in the file
as a positive or negative edge trigger based upon some pre-existing clock.
<a href="http://www.clifford.at/yosys">Yosys</a>,
however, extends this behavior by making <code class="language-plaintext highlighter-rouge">$global_clock</code> the
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
time step.  Every time step is now examined by the formal engine,
not just those times described by an edge of a clock but intermediate times
as well.  It’s for this reason that we can use <code class="language-plaintext highlighter-rouge">$global_clock</code> in this
circumstance.  Indeed, <code class="language-plaintext highlighter-rouge">$global_clock</code> is one of the keys to this whole
operation.</p>

<p>Our last formal property will be to assume that our incoming clock signals
are identical to the most significant bits of our counters.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_clk_a</span> <span class="o">=</span> <span class="n">f_a_count</span><span class="p">[</span><span class="n">F_CKSTEP</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_clk_b</span> <span class="o">=</span> <span class="n">f_b_count</span><span class="p">[</span><span class="n">F_CKSTEP</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span></code></pre></figure>

<p>Simple enough?  We’ve just assumed the presence of two dissimilar clocks
coming into our design.  We’ve also allowed them to have arbitrary phases
and frequencies with respect to each other.</p>

<p>There is one more required piece of
<a href="http://www.clifford.at/yosys">yosys</a>,
magic, you’ll need to add <code class="language-plaintext highlighter-rouge">clk2fflogic</code> to your
<a href="http://www.clifford.at/yosys">yosys</a>
script file.  Alternatively, if you are using
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>,
you can instead add <code class="language-plaintext highlighter-rouge">multiclock on</code> to the options section.  You can
see an example of this
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a> <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.sby">script
here</a>.</p>

<p>No more setup work is required–we’ve just formally assumed the existence of
two separate and dissimilar clock inputs.  In the next section, we’ll examine a
<a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock switch
design</a>
and discuss how we might
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
that it is glitch free.</p>

<h1 id="a-clock-switch">A Clock Switch</h1>

<p>At this point in our article, I usually present a working design that would
use the principle under discussion and
<a href="/blog/2017/10/19/formal-intro.html">formal verify</a> it.
Sadly, I only have a couple of
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
designs to share.  I just haven’t had the need to build
that many.  That said, neither my formal proof of
<a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf">Cliff Cumming’s asynchronous
FIFO</a>
design, nor the <a href="https://github.com/ZipCPU/wbuart32/blob/dev/rtl/rxuartlite.v">proof of my
UART receiver</a>
would be appropriate for a beginning blog post on
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
despite the fact that both proofs use the techniques discussed here.</p>

<p>So let’s try something simpler.  Let’s instead examine a <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>.</p>

<p>A <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>
is a design component that takes two clock inputs and a switch
input, and produces one of the two clocks as its output dependent upon how
the switch is set.
It’s not something an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
designer normally needs to build, since most
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
vendor libraries provide similar components which will be known
to work on their parts.  As an example, Xilinx offers a 
<a href="https://www.xilinx.com/support/documentation/user_guides/ug472_7Series_Clocking.pdf"><code class="language-plaintext highlighter-rouge">BUFGMUX</code> design element</a>
with similar capabilities.  However, for today’s purpose, 
a <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>
design makes a perfect example of an
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
design which can be
<a href="/blog/2017/10/19/formal-intro.html">formally verified</a>.</p>

<p><a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">Clock
switches</a>
are very important parts of a failsafe designs.  A failsafe
design can start with one clock and then switch to the second clock once it
stabilizes.  In a similar fashion, if the second clock becomes unstable or
otherwise unusable, then the
<a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>
should return the design to the original clock.  A third use for a <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>
would be in a
power sensitive design.  In such a power sensitive design, the clock
might be switched between a fast and a slow clock in order to control how
much power the design is using at any given time.</p>

<p>So, how would you build a
<a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>?</p>

<p>A straight forward <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>
design might look like,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_sel</span><span class="p">)</span>
		<span class="n">o_clk</span> <span class="o">=</span> <span class="n">i_clk_a</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_clk</span> <span class="o">=</span> <span class="n">i_clk_b</span><span class="p">;</span></code></pre></figure>

<p>Sadly, this doesn’t work.  The problem is that the switch input <code class="language-plaintext highlighter-rouge">i_sel</code>
is <a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
to at least one of the two clock domains if not both.
The output clock period might therefore be something other than the
period of either clock if <code class="language-plaintext highlighter-rouge">i_sel</code> changes mid clock.  Worse, the period
could easily be shorter then the minimum pulse width of this design.</p>

<table align="center" style="float: right"><caption>Fig 3. A Clock switching circuit</caption><tr><td><img src="/img/clock-switch.svg" alt="" width="560" /></td></tr></table>

<p>A little googling turns up
<a href="https://www.eetimes.com/document.asp?doc_id=1202359">a fascinating article</a>
on <a href="https://www.eetimes.com">EE Times</a> discussing, “<a href="https://www.eetimes.com/document.asp?doc_id=1202359">Techniques to make clock
switching glitch free</a>.”
In <a href="https://www.eetimes.com/document.asp?doc_id=1202359">the article</a>,
Mahmud provides just the logic we need.</p>

<p>According to
<a href="https://www.eetimes.com/document.asp?doc_id=1202359">the article</a>,
the key piece we are missing is a pair of
<a href="/blog/2017/10/20/cdc.html">synchronizers</a>.
Since the clock select input isn’t guaranteed to be synchronous to
either clock, it must be <a href="/blog/2017/10/20/cdc.html">synchronized into each
clock’s domain</a>.  Once the
clock select line has been split and synchronized into each respective
clock domain, the output clock can then be synthesized by <code class="language-plaintext highlighter-rouge">and</code>ing each
leg of the clock domain with its respective enable, and <code class="language-plaintext highlighter-rouge">or</code>ing the
result together.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">o_clk</span> <span class="o">=</span> <span class="p">((</span><span class="n">a_sel</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">))</span>
		<span class="o">||</span><span class="p">((</span><span class="n">b_sel</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_clk_b</span><span class="p">));</span></code></pre></figure>

<p>This sounds simple enough.  Indeed, the article and the picture are so clear
that writing out the design is quite straightforward.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">clkswitch</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">,</span> <span class="n">i_clk_b</span><span class="p">,</span> <span class="n">i_areset_n</span><span class="p">,</span> <span class="n">i_sel</span><span class="p">,</span> <span class="n">o_clk</span><span class="p">);</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="n">i_clk_a</span><span class="p">,</span> <span class="n">i_clk_b</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="n">i_areset_n</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="n">i_sel</span><span class="p">;</span>
	<span class="kt">output</span>	<span class="kt">wire</span>	<span class="n">o_clk</span><span class="p">;</span>

	<span class="kt">reg</span>		<span class="n">aff</span><span class="p">,</span> <span class="n">bff</span><span class="p">,</span> <span class="n">a_sel</span><span class="p">,</span> <span class="n">b_sel</span><span class="p">;</span>

	<span class="c1">// First half of the synchronizer for A</span>
	<span class="c1">//</span>
	<span class="c1">// Set aff on the positive edge of clock A</span>
	<span class="k">initial</span> <span class="n">aff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk_a</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_areset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_areset_n</span><span class="p">)</span>
		<span class="n">aff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">aff</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_sel</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">b_sel</span><span class="p">);</span>

	<span class="c1">// Second half of the synchronizer for A</span>
	<span class="c1">//</span>
	<span class="c1">// Set a_sel based upon the negative edge of clock A</span>
	<span class="c1">//</span>
	<span class="k">initial</span> <span class="n">a_sel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">negedge</span> <span class="n">i_clk_a</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_areset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_areset_n</span><span class="p">)</span>
		<span class="n">a_sel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">a_sel</span> <span class="o">&lt;=</span> <span class="n">aff</span><span class="p">;</span></code></pre></figure>

<p>Notice that this synchronizer uses both edges of the clock to synchronize
on.  This would be a bad idea in an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
since you have no control over how far apart the design elements are.
However, this isn’t quite the same problem on an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>,
as this design could be delivered as an internally
routed black box.</p>

<p>The logic for B’s side is identical, save that it is based
upon the negation of our select signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">bff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk_b</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_areset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_areset_n</span><span class="p">)</span>
		<span class="n">bff</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bff</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">i_sel</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">a_sel</span><span class="p">);</span>

	<span class="k">initial</span> <span class="n">b_sel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">negedge</span> <span class="n">i_clk_b</span><span class="p">,</span> <span class="kt">negedge</span> <span class="n">i_areset_n</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_areset_n</span><span class="p">)</span>
		<span class="n">b_sel</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">b_sel</span> <span class="o">&lt;=</span> <span class="n">bff</span><span class="p">;</span></code></pre></figure>

<p>As the final step, the output clock is determined by clock <code class="language-plaintext highlighter-rouge">A</code> if
<code class="language-plaintext highlighter-rouge">a_sel</code> is ever true, and by clock <code class="language-plaintext highlighter-rouge">B</code> if <code class="language-plaintext highlighter-rouge">b_sel</code> is true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_clk</span> <span class="o">=</span> <span class="p">((</span><span class="n">a_sel</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">))</span>
			<span class="o">||</span><span class="p">((</span><span class="n">b_sel</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_clk_b</span><span class="p">));</span>
<span class="k">endmodule</span></code></pre></figure>

<p>This design would be bad practice within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
Besides transitioning on both positive and negative edges of a
clock, we are also sourcing a clock from combinational logic.
Both of these are big no-no’s in any
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
design.  If you want a <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>
within your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
design logic, use the vendor supplied black box that implements
something approximating (or better than) the above logic.</p>

<p>Shall we see if we can
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
whether this circuit truly works?</p>

<h1 id="formally-verifying-the-clock-switch">Formally Verifying the clock switch</h1>

<p>Our first
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
step is to determine what the “contract” is that
this design needs to meet.  Specifically, we want to make certain that</p>

<ol>
  <li>
    <p>The outgoing clock should only transition when one of the incoming clocks
transitions.</p>
  </li>
  <li>
    <p>The output clock’s high or low pulse width is no less than the width of the
fastest clock</p>
  </li>
  <li>
    <p>We can switch from one clock to another</p>
  </li>
</ol>

<p>Let’s work through these one by one.  The first criteria is easy: if neither
input clock rises, then we’ll assert that the output doesn’t rise either.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_areset_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_clk_b</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">o_clk</span><span class="p">));</span></code></pre></figure>

<p>Notice how I needed to add an exception for the
<a href="/formal/2018/04/12/areset.html">asynchronous reset</a>.  Hence
this property will only hold as long as the reset line remains inactive (high).</p>

<p>Likewise, if neither input falls, then the output shouldn’t fall either.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_areset_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">fell</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">fell</span><span class="p">(</span><span class="n">i_clk_b</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">fell</span><span class="p">(</span><span class="n">o_clk</span><span class="p">));</span></code></pre></figure>

<p>If you don’t recognize the <code class="language-plaintext highlighter-rouge">f_past_valid</code> signal, we’ve discussed it many
times on this blog.  It is necessitated by the fact that on the initial time
step, <code class="language-plaintext highlighter-rouge">$rose()</code>, <code class="language-plaintext highlighter-rouge">$fell()</code>, and <code class="language-plaintext highlighter-rouge">$past()</code> are not well defined.  Instead,
we set the <code class="language-plaintext highlighter-rouge">f_past_valid</code> just after that initial time step, and then start
checking on every step thereafter.</p>

<p>The second criteria is a little harder to describe.  Indeed, our design choice
to use a fractional clock makes this more difficult.  Because we are
looking at the most significant bit of a counter, it’s not immediately
apparent how long each clock should be high.  Without a divide operator
to tell us how long we’d expect each clock leg to be high or low
we’re sort of stuck.</p>

<p>We could switch from the <a href="/blog/2017/06/02/generating-timing.html">fractional
clock division</a>
description above to an integer divide:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_a_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">f_a_count</span> <span class="o">&lt;=</span> <span class="n">f_a_count</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">f_a_count</span> <span class="o">&lt;=</span> <span class="n">f_a_idiv</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_a_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_clk_a</span> <span class="o">==</span> <span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">);</span></code></pre></figure>

<p>This would offer some different properties to the clock, so I would
encourage anyone interested to try this approach.</p>

<p>For this post, however, we’ll continue with the
<a href="/blog/2017/06/02/generating-timing.html">fractional divider</a>
and see if we can’t find a simpler approach.</p>

<p>If you examine the logic for the output clock, <code class="language-plaintext highlighter-rouge">o_clk</code>, you’ll see that
the output clock is determined by either <code class="language-plaintext highlighter-rouge">a_sel</code> or <code class="language-plaintext highlighter-rouge">b_sel</code>.  If <code class="language-plaintext highlighter-rouge">a_sel</code>
is true, clock <code class="language-plaintext highlighter-rouge">A</code> is
produced.  Likewise if <code class="language-plaintext highlighter-rouge">b_sel</code> is true, then clock B is produced.  If neither
is true, there should be no clock pulse out.  However, both should never be
true at the same time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">a_sel</span> <span class="o">||</span> <span class="o">!</span><span class="n">b_sel</span><span class="p">);</span></code></pre></figure>

<p>We might also choose to assert that <code class="language-plaintext highlighter-rouge">a_sel</code> or <code class="language-plaintext highlighter-rouge">b_sel</code> would only change
on a clock edge.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_areset_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">fell</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">a_sel</span><span class="p">));</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_areset_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">fell</span><span class="p">(</span><span class="n">i_clk_b</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">b_sel</span><span class="p">));</span></code></pre></figure>

<p>However, if you examine the design above you’ll see that this
is indeed the case by examination—with the exception of the
<a href="/formal/2018/04/12/areset.html">asynchronous reset</a>
input.  This one piece of our logic might produce a clock glitch, but
we’ll assume that if you are using an
<a href="/formal/2018/04/12/areset.html">asynchronous reset</a>
then you know what you are doing and you can handle such a glitch.</p>

<p>For our final criteria, let’s count clock ticks in each clock domain.
We’ll start with the <code class="language-plaintext highlighter-rouge">A</code> clock domain.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">a_ticks</span><span class="p">,</span> <span class="n">last_a_ticks</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">a_ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_areset_n</span><span class="p">)</span>
			<span class="n">a_ticks</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">($</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_clk_a</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">a_sel</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span> <span class="o">&amp;</span><span class="n">a_ticks</span><span class="p">))</span>
			<span class="n">a_ticks</span> <span class="o">&lt;=</span> <span class="n">a_ticks</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b_sel</span><span class="p">)</span>
			<span class="n">a_ticks</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>We’ll do the same in a moment with the <code class="language-plaintext highlighter-rouge">B</code> clock domain.  For now, let’s
keep track of the number of clock ticks we’ve had in the <code class="language-plaintext highlighter-rouge">A</code> domain, and
remember this value even after we leave the <code class="language-plaintext highlighter-rouge">A</code> domain.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">last_a_ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_areset_n</span><span class="p">)</span>
		<span class="n">last_a_ticks</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">a_sel</span><span class="p">)))</span>
		<span class="n">last_a_ticks</span> <span class="o">&lt;=</span> <span class="n">a_ticks</span><span class="p">;</span></code></pre></figure>

<p>We’ll then repeat this logic for the <code class="language-plaintext highlighter-rouge">B</code> clock domain–both counting how
many ticks have taken place since changing, and keeping track of that count
once we switch back to <code class="language-plaintext highlighter-rouge">A</code>s clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">b_ticks</span><span class="p">,</span> <span class="n">last_b_ticks</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">b_ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_areset_n</span><span class="p">)</span>
			<span class="n">b_ticks</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">($</span><span class="nb">rose</span><span class="p">(</span><span class="n">i_clk_b</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">b_sel</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span> <span class="o">&amp;</span><span class="n">b_ticks</span><span class="p">))</span>
			<span class="n">b_ticks</span> <span class="o">&lt;=</span> <span class="n">b_ticks</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a_sel</span><span class="p">)</span>
			<span class="n">b_ticks</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">last_b_ticks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_areset_n</span><span class="p">)</span>
		<span class="n">last_b_ticks</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">b_sel</span><span class="p">)))</span>
		<span class="n">last_b_ticks</span> <span class="o">&lt;=</span> <span class="n">b_ticks</span><span class="p">;</span></code></pre></figure>

<p>To make our traces look nice, we’ll assume that there must be at least
three clock ticks between switches.  Since this minimum duration properties
isn’t really a fundamental part of our proof, we’ll place it within an
parameterized option to the core.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_COVER</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">// Only one clock should ever be active at any time</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">((</span><span class="n">a_ticks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">b_ticks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">a_sel</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">a_ticks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">assume</span><span class="p">(</span><span class="n">i_sel</span><span class="p">);</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">b_sel</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">b_ticks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_sel</span><span class="p">);</span></code></pre></figure>

<p>Using these two measures of the number of times either <code class="language-plaintext highlighter-rouge">A</code> or <code class="language-plaintext highlighter-rouge">B</code> has
ticked between clock swaps, we can now ask the formal tools to <code class="language-plaintext highlighter-rouge">cover()</code>
a clock transition from A to B where A is at least twice as fast as <code class="language-plaintext highlighter-rouge">B</code>,
and again from <code class="language-plaintext highlighter-rouge">B</code> to <code class="language-plaintext highlighter-rouge">A</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_a_ticks</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_ticks</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">b_sel</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_a_step</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">f_b_step</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)));</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_b_ticks</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_ticks</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">a_sel</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_a_step</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">f_b_step</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)));</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Now, if everything works, then when we run
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
with a <code class="language-plaintext highlighter-rouge">mode</code> of <code class="language-plaintext highlighter-rouge">cover</code>, and using the <code class="language-plaintext highlighter-rouge">cover</code> task defined by the 
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
<a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.sby">script</a>,
we’ll get two traces of clock transitions.</p>

<p>So we’ve now described two of the three properties above, and hand waved through
the third.  Will this work?</p>

<p>Not quite.</p>

<p>Should you test this core with only those properties above, you’ll discover
as I did that they aren’t sufficient to ensure that this <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>
even worked.  You can see the output from
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a> below.</p>

<table align="center" style="float: none"><caption>Fig 4. SymbiYosys results from the first formal verification attempt</caption><tr><td><img src="/img/ckswitch-first-fail.png" alt="Textual terminal output from SymbiYosys" width="854" /></td></tr></table>

<p>From this, we determine that our assertion from <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v#L184">line
184</a>
failed.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">assert</span><span class="p">((</span><span class="o">!</span><span class="n">a_sel</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">b_sel</span><span class="p">));</span></code></pre></figure>

<h2 id="what-happened">What happened?</h2>

<p>If you look near the bottom of the
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
output, you’ll see a line identifying a counterexample trace.  We can use this
trace to find out why our proof didn’t work.  This trace is shown in Fig 5
below.</p>

<table align="center" style="float: none"><caption>Fig 5. Trace file describing how the assertions might fail</caption><tr><td><img src="/img/ckswitch-first-trace.png" alt="Failing trace, showing a_sel and b_sel both true at the same time" width="827" /></td></tr></table>

<p>If you look closely at the penultimate time step, between 70ns and 80ns,
you’ll notice that both
<code class="language-plaintext highlighter-rouge">a_sel</code> and <code class="language-plaintext highlighter-rouge">b_sel</code> are true at the same time.  <em>This should never happen!</em>
This violates all of the properties we are hoping to get from this clock
divider.</p>

<p>Looking closer, you can see that <code class="language-plaintext highlighter-rouge">i_sel</code> (shown in red) didn’t simply change
from selecting clock A to clock B.  Instead, it started out requesting clock
<code class="language-plaintext highlighter-rouge">B</code>, suddenly switched to selecting clock <code class="language-plaintext highlighter-rouge">A</code>, and then immediately
switched back before the synchronizers could settle.  Such a signal on
then <code class="language-plaintext highlighter-rouge">i_sel</code> select line would defeat the purpose of our <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>,
so it’s not really all that reasonable.</p>

<p>On the other hand, if we assume that <code class="language-plaintext highlighter-rouge">i_sel</code> won’t change until the clock
transition is complete, then we get a lot farther:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_sel</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">a_sel</span><span class="p">))</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_sel</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_sel</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">b_sel</span><span class="p">))</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_sel</span><span class="p">);</span></code></pre></figure>

<p>As another way we might express this, we might insist that anytime there is
a change propagating through the synchronizers then <code class="language-plaintext highlighter-rouge">i_sel</code> will be
held constant.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">($</span><span class="n">global_clock</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">a_sel</span> <span class="o">!=</span> <span class="n">aff</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">b_sel</span> <span class="o">!=</span> <span class="n">bff</span><span class="p">))</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_sel</span><span class="p">));</span></code></pre></figure>

<p>Getting this design to <a href="/blog/2018/03/10/induction-exercise.html">pass
induction</a>
requires some additional properties.  For example, we can’t allow the
design to be transitioning in both rails at the same time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">aff</span> <span class="o">!=</span> <span class="n">a_sel</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">bff</span> <span class="o">==</span> <span class="n">b_sel</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bff</span> <span class="o">!=</span> <span class="n">b_sel</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">aff</span> <span class="o">==</span> <span class="n">a_sel</span><span class="p">);</span></code></pre></figure>

<p>With these changes the design passes, proving our first criteria–that the
outgoing clock only
ever changes on an input clock edge.  We also have a meager assurance that the
outgoing clock will not be faster than either incoming clock.  Perhaps
we should examine the third criteria, and see how this switch works when
swapping?</p>

<p>As you may recall, our third criteria was whether or not we could
switch from one clock to the other or back again.
To see whether or not we met this criteria, we’ll need to run
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
in its cover mode.  Our
<a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.sby">script</a>
has a <code class="language-plaintext highlighter-rouge">cover</code> task defined within it that does just that.  The result is two
generated clock traces that illustrate how clock transitions might happen.</p>

<p>The first trace shows that a design can switch from a faster clock to a slower
clock.</p>

<table align="center" style="float: none"><caption>Fig 6. Cover result, switching from a faster clock to a slower clock</caption><tr><td><img src="/img/ckswitch-trace0.png" alt="" width="578" /></td></tr></table>

<p>The second trace, on the other hand, shows the clock switching from a slower
clock to a faster clock.</p>

<table align="center" style="float: none"><caption>Fig 7. Cover result, switching from a slower clock to a faster clock</caption><tr><td><img src="/img/ckswitch-trace1.png" alt="" width="603" /></td></tr></table>

<p>But what about the idea of a failsafe clock?  Didn’t we say that one reason
for using a <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>
is to be able to have a failsafe clock, where if one
dies then the other one picks back up?</p>

<p>This particular design doesn’t support a failsafe clock.
If <code class="language-plaintext highlighter-rouge">A</code> is the failsafe clock, and <code class="language-plaintext highlighter-rouge">B</code> stops transitioning, then you
can’t switch from <code class="language-plaintext highlighter-rouge">B</code> back to <code class="language-plaintext highlighter-rouge">A</code> using <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">this
design</a>
since <code class="language-plaintext highlighter-rouge">b_sel</code> depends upon both a positive and a negative transition from
clock <code class="language-plaintext highlighter-rouge">B</code>.</p>

<p>Even though this clock switch design doesn’t offer a failsafe capability,
you should now understand the tools necessary to prove that your own design,
perhaps even one with a failsafe capability, would work—but only in an
<a href="/blog/2017/10/13/fpga-v-asic.html">ASIC</a>
design of course!  (Remember, the clock switch is not appropriate for an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
design for the reasons given above.)</p>

<h2 id="next-steps">Next Steps</h2>

<p>Let’s think about what we just did.  We just verified that a design with
three <a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
inputs “works”.  This involved formally describing two dissimilar clocks
with arbitrary phases and frequencies.  These techniques apply well beyond
this simple <a href="https://github.com/ZipCPU/website/blob/master/examples/clkswitch.v">clock
switch</a>
design.  These techniques can be used in <em>any</em>
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
design component to verify that your logic is working as desired–in spite of
whatever clock phases or frequencies might be given to it.</p>

<p>While working with
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
inputs isn’t common, there are times and places for doing so.  I’ve already
mentioned some examples above: an
<a href="/formal/2018/04/12/areset.html">asynchronous reset</a>,
a <a href="https://github.com/ZipCPU/wbuart32/blob/dev/rtl/rxuartlite.v">serial port
receiver</a>,
or perhaps a circuit that must read memory at one clock rate and feed a video
stream at another rate.  In all of these cases, knowing how to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
your component in spite of any
<a href="/blog/2017/10/20/cdc.html">multiple clock domains</a>
will be a valuable tool.</p>

<p>The next step in this short series on
<a href="https://en.wikipedia.org/wiki/Asynchronous_circuit">asynchronous</a>
logic will be to take <a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf">Cliff Cummings’ asynchronous FIFO
design</a>,
and apply the same basic
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
steps we just applied above.</p>

<p>As an added bonus in this process, you should be able to then turn around and
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
any modifications you need to make to
<a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf">his design</a>
to meet your particular design requirements.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And he said unto them, It is not for you to know the times or the seasons, which the Father hath put in His own power. (Acts 1:7)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
