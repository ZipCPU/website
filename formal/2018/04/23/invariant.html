<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Aggregating verified modules together</title>
  <meta name="description" content="  Warning: The formal verification approach presented within this article, thatof swapping assertions and assumptions, can lead to false positives.See this a...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2018/04/23/invariant.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Aggregating verified modules together</h1>
    <p class="post-meta"><time datetime="2018-04-23T00:00:00-04:00" itemprop="datePublished">Apr 23, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <blockquote>
  <p>Warning: The formal verification approach presented within this article, that
of swapping assertions and assumptions, can lead to false positives.
See <a href="/formal/2018/12/18/skynet.html">this article</a>
for more details.</p>
</blockquote>

<table align="center" style="float: right"><caption>Fig 1. The ZipCPU</caption><tr><td><img src="/img/zipcpu.svg" alt="Block diagram of the ZipCPU, showing five pipeline stages" width="360" /></td></tr></table>
<p>If you’ve been following my work with the
<a href="/about/zipcpu.html">ZipCPU</a>,
you’ll know that I have formally verified <a href="/blog/2018/01/22/formal-progress.html">all of the leaf
modules</a>,
and that I am now working on verifying
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">the CPU</a>
<a href="/blog/2018/04/02/formal-cpu-bugs.html">as a whole</a>.
By “leaf module”, I mean a design component that references no other design
components.
You might also remember that <a href="/blog/2017/10/19/formal-intro.html">I am rather new to formal
verification</a>,
having only picked it up within this last year.  Verifying the
<a href="/about/zipcpu.html">ZipCPU</a>
may be the most complex design I’ve tried to verify yet.</p>

<p>Prior to my attempts at formally verifying the
<a href="/about/zipcpu.html">ZipCPU</a>,
the most difficult proof I had worked on was for a proprietary block
floating point module.  That module assigned a single exponent for all
of the values within a block of <code class="language-plaintext highlighter-rouge">2^N</code> numbers, and then output the input
numbers sequentially together with their assigned floating point value.  Like
the
<a href="/about/zipcpu.html">ZipCPU</a>,
it also involved proving a module with a leaf module underneath it.
The alignment was very difficult to get right in that implementation
and so I dependended heavily upon the <a href="/blog/2017/10/19/formal-intro.html">formally verified
properties</a>
of those two modules in order to have the assurance that the component
even worked.</p>

<p>Along the way, I’ve learned that there are some tricks to aggregating
<a href="/blog/2017/10/19/formal-intro.html">formally verified</a>
submodules together in order to prove the whole.  I’ve now learned two
particular techniques, abstraction and invariants, to help
control the complexity of a formal proof.
Today’s discussion will focus on invariants.  If the
<a href="https://www.blueletterbible.org/kjv/jas/4/15">Lord is willing</a>,
we’ll come back and discuss how to use abstraction, and present several
examples of it.</p>

<p>I would love to declare, before starting out, that I am an expert on these
techniques.  I’m not.  Perhaps if I had found some article
or set of articles describing them I might be able to declare some amount
of expertise.  Sadly, while I found
a small number of articles describing invariants, I struggled to relate the
concepts presented within those articles to the
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
problems
I was dealing with.  The one source I found to guide me along this road
was a presentation from <a href="https://www.onespin.com">OneSpin Solutions</a> at
<a href="https://dvcon.org">DVCon</a> 2018 in San Jose.</p>

<p>So with credit to <a href="https://www.onespin.com">OneSpin Solutions</a>, here’s
what I have learned about
invariants and how they apply to
<a href="/blog/2017/10/19/formal-intro.html">Formal Verification</a>.
More than that, I’ll
try to keep this presentation simple enough to be understandable, and
focused on how these topics apply to the
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
of complex RTL modules.</p>

<h2 id="formal-property-review">Formal Property Review</h2>

<p>If you are coming in to the discussion late, then there are two concepts
you must understand in order to follow the discussion below.  These are
the <code class="language-plaintext highlighter-rouge">assume()</code> and <code class="language-plaintext highlighter-rouge">assert()</code> System Verilog operators.  I like to explain
these with a set of diagrams describing the state of a design at any
given point in time.</p>

<table align="center" style="float: right"><caption>Fig 2. Formal regions of relevance</caption><tr><td><img src="/img/formal-bmc.svg" alt="" width="360" /></td></tr></table>
<p>One such example state diagram is shown in Fig 2.  Consider every point in
this image as representing one state of all the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
in your design.  Any change to one of the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
in your design will move your system’s state to a new point on the diagram.</p>

<p>Several parts of this diagram are worth noting.</p>

<p>First, note that your design starts from an initial state, as defined by the
<code class="language-plaintext highlighter-rouge">initial</code> statements within your design.  From this point, the inputs to your
design together with the logic within your design will cause the design
to move from one state to another.</p>

<p>Second, note that there are three different types of states you can be in.
The first set of states are the set of “valid” states.  These are all of the
states that may be reached from your initial state without violating any
<code class="language-plaintext highlighter-rouge">assert</code>ions within your design.  These are shown in green.</p>

<p>The second set of states are those shown in red.  These are the “illegal” or
“invalid” states.  These are defined by all those states that violate an
<code class="language-plaintext highlighter-rouge">assert()</code> statements within your design.
Your goal, using formal methods, will be to prove that you cannot cross from
a point in the set of valid states to one of the invalid states.</p>

<p>There is a third set of states.  This set is shown by the largest region
containing all of the others.  This is the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of all possible sets of
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
(register) combinations of values within your design.  Initially, this set is
defined by every
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
combination in your design.  Hence if you have <code class="language-plaintext highlighter-rouge">N</code>
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
in your design, then without any further assumptions there are initially
<code class="language-plaintext highlighter-rouge">2^N</code> states in this set.  Not all of these states will be <em>reachable</em> from
your initial state.</p>

<table align="center" style="float: left"><caption>Fig 3. The Effect of an Assumption</caption><tr><td><img src="/img/formal-bmc-assume.svg" alt="" width="360" /></td></tr></table>
<p>Within your design, you have two sorts of statements you can make about the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
within your design.  The first is the <code class="language-plaintext highlighter-rouge">assume()</code> statement.  This reduces the
size of the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of values your
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
may be set to.</p>

<p>To use the <a href="/zipcpu/2018/04/17/ziptimer.html">example of a
counter</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_start</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">TIMEOUT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r_value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">r_value</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>we might assume that the <code class="language-plaintext highlighter-rouge">i_reset</code> signal is always zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">);</span></code></pre></figure>

<p>This will restrict the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of possibilities to only those where <code class="language-plaintext highlighter-rouge">i_reset</code> is
always zero.</p>

<p>The goal of
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
is to examine <em>every possible</em> state your design can enter into in order
to prove that your design will never reach an <em>invalid</em> state.
As I’m sure you can imagine, this task can be a challenge.  In general, this
challenge is <code class="language-plaintext highlighter-rouge">NP-hard</code>–the computational complexity is roughly exponential
in the size of the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
within your design.  Hence, the smaller you can make the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of possibilities the easier it will be to verify a design.</p>

<table align="center" style="float: right"><caption>Fig 4. The Effect of an Assertion</caption><tr><td><img src="/img/formal-bmc-assert.svg" alt="" width="360" /></td></tr></table>
<p>The second basic formal statement is the <code class="language-plaintext highlighter-rouge">assert()</code> statement.  Unlike the
<code class="language-plaintext highlighter-rouge">assume()</code> statement which limits the size of the search space, the <code class="language-plaintext highlighter-rouge">assert()</code>
statement declares particular states within that
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
are somehow “illegal” as shown in Fig 4.  When you use
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>,
your goal will be to guarantee your design remains in a legal state.</p>

<p>If we return to the
<a href="/zipcpu/2018/04/17/ziptimer.html">timer example</a>
above, we might assert that value of the counter is never one greater than
<code class="language-plaintext highlighter-rouge">TIMEOUT</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">!=</span> <span class="n">TIMEOUT</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>When applying
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
to this example, the engine will quickly point out that
the initial state may lie within the red or illegal states–since we did nothing
to restrict <code class="language-plaintext highlighter-rouge">r_value</code>s contents initially.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span> <span class="n">r_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>These two operators, <code class="language-plaintext highlighter-rouge">assume</code> and <code class="language-plaintext highlighter-rouge">assert</code>, alone should be enough to get you
started with
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>,
and there’s a lot you can do with them.  However, if you want to <em>prove</em> that
your design will work for all time rather than just the first <code class="language-plaintext highlighter-rouge">S</code> time steps,
then you will need to apply the
<a href="/blog/2017/10/19/formal-intro.html">formal method</a>
called
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<p><a href="/blog/2018/03/10/induction-exercise.html">Induction</a>
starts by assuming your design is somewhere among the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of all possible states, and that the initial state the engine has chosen
is not illegal.  Its first
step is to create <code class="language-plaintext highlighter-rouge">S</code> time steps where your design stays out of the
illegal set of states.  Then, on the <code class="language-plaintext highlighter-rouge">S+1</code> time step, it tries to see if it
is possible to enter into the set of illegal states.</p>

<p>The difficult part of this
<a href="/blog/2018/03/10/induction-exercise.html">inductive step</a>
is that the formal engine cannot tell the difference between reachable states
and unreachable states.  This can be <a href="/blog/2018/03/10/induction-exercise.html">particularly
problematic</a>
for the new user of
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
to understand.
A common refrain is, “how did the formal engine put my design into this
state?  There’s no way it can get there!”</p>

<table align="center" style="float: left"><caption>Fig 5. The Lesson of Induction</caption><tr><td><img src="/img/formal-induction-soln.svg" alt="" width="360" /></td></tr></table>
<p>Addressing this problem was the subject of a
<a href="/blog/2018/03/10/induction-exercise.html">prior article</a>.
In that article, I explained that you must use either an <code class="language-plaintext highlighter-rouge">assume</code> or an <code class="language-plaintext highlighter-rouge">assert</code>
to keep the formal engine from reaching any unreachable states, or you will
never be able to fully <em>prove</em> your design meets the properties you have
asserted for all time.</p>

<p>Following our example of a timer, the formal engine might pick a value for
<code class="language-plaintext highlighter-rouge">r_value</code> that was <code class="language-plaintext highlighter-rouge">TIMEOUT+S+2</code>.  It would then follow <code class="language-plaintext highlighter-rouge">r_value</code> for
<code class="language-plaintext highlighter-rouge">S</code> steps until <code class="language-plaintext highlighter-rouge">r_value</code> was <code class="language-plaintext highlighter-rouge">TIMEOUT+2</code>.  On the next step, our property
that <code class="language-plaintext highlighter-rouge">(r_value != TIMEOUT+1)</code> would be violated.</p>

<p>To fix this, one would need to assert instead that <code class="language-plaintext highlighter-rouge">r_value &lt;= TIMEOUT</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">r_value</span> <span class="o">&lt;=</span> <span class="n">TIMEOUT</span><span class="p">);</span></code></pre></figure>

<p>This makes the size of the “red” area large enough to include the whole
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>, as shown
in Fig 5.  To follow the consequence of this in our example above,
<code class="language-plaintext highlighter-rouge">r_value</code> would never be allowed to be <code class="language-plaintext highlighter-rouge">TIMEOUT+S+2</code>.  It would only be allowed
to have a valid value.</p>

<p>To know which of the two, <code class="language-plaintext highlighter-rouge">assert</code> or <code class="language-plaintext highlighter-rouge">assume</code>, is appropriate at any given
time, I’ve always used what I call the <em>master rule of Formal Verification</em>
shown in Fig 6: <em>assume inputs</em>, then <em>assert</em> properties of both
<em>internal states and outputs</em>.</p>
<table align="center" style="float: right"><caption>Fig 6. Master rule of Formal Verification</caption><tr><td><img src="/img/fv-master-rule.svg" alt="" width="280" /></td></tr></table>

<p>This rule has served me well for all of my
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
efforts to date.  Now that I’ve discovered I need to aggregate modules together,
I’ve had to learn some of the fine nuances of this rule.  These nuances
are the subject of the rest of this article.</p>

<h2 id="the-concept-of-an-invariant">The Concept of an Invariant</h2>

<p>What the master rule of
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
doesn’t capture is how you deal
with things that have already been proven.  For example, let’s suppose <code class="language-plaintext highlighter-rouge">A</code>
is a set of assumptions, and <code class="language-plaintext highlighter-rouge">B</code> is a set of assertions.  Once you’ve proven
that <code class="language-plaintext highlighter-rouge">A</code> implies <code class="language-plaintext highlighter-rouge">B</code>, which I shall write as <code class="language-plaintext highlighter-rouge">A-&gt;B</code>, then you shouldn’t need
to prove it again.</p>

<table align="center" style="float: left"><caption>Fig 7. (Some caption)</caption><tr><td><img src="/img/formal-invariants.svg" alt="" width="360" /></td></tr></table>
<p>This is the concept of an Invariant.  Once you know that <code class="language-plaintext highlighter-rouge">A-&gt;B</code>, then <code class="language-plaintext highlighter-rouge">A-&gt;B</code>
becomes an invariant of your design.  Instead of reproving it, you may now treat
it as an assumption.  This becomes especially useful when trying to deal
with complex proofs. If you can reduce the complexity, you can then verify
larger and larger designs.</p>

<p>There are two situations where I have found to apply this.  The first is
that of a parent module with a child (or leaf) module underneath it.  The
second place is when the proof of a design can be broken into separate sections.
I’ve encountered both while trying to verify the
<a href="/about/zipcpu.html">ZipCPU</a>.  We’ll
examine each in turn.</p>

<table align="center" style="float: right"><caption>Fig 8. ZipCPU's module hierarchy</caption><tr><td><img src="/img/files-zipcpu-proved.svg" alt="" width="240" /></td></tr></table>
<p>To explain the first situation, consider the module hierarchy (file structure)
of the <a href="/about/zipcpu.html">ZipCPU</a>
shown in Fig 8.  The
<a href="/about/zipcpu.html">ZipCPU</a> consists of a
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">master CPU</a>
file, an <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/idecode.v">instruction
decoder</a>, an
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/cpuops.v">ALU</a> with a
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/mpyop.v">multiply component</a>
within it, a <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/ex/wbdblpriarb.v">twin bus
arbiter</a>,
and one of two <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/memops.v">memory
controllers</a>.
I use the red bar in Fig 8 to indicate the
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
within the design.  Normally these properties are found at the end of the
source file.  You’d therefore normally expect this red bar to be at the bottom
of each file within the diagram.  However, since the concept of invariants
turns these properties on end, I show the red bar in this figure at the top
of the file–for illustration purposes.</p>

<p>The other three components of the
<a href="/about/zipcpu.html">ZipCPU</a> were abstracted.
These were the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a>, and
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/mpyop.v">multiply</a>.
These are shown in Fig 8 as empty files with dotted lines around them,
indicating that due to the abstraction they have very little logic remaining
within them.  You can find their abstract representations in
my <a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal">bench/formal</a>
directory.  These also made the proof easier, but for now we’ll leave the
mechanics of this for a topic for a future article.</p>

<table align="center" style="float: left"><caption>Fig 9. Invariants applied to a parent/leaf module hierarchy</caption><tr><td><img src="/img/invariance-external.svg" alt="" width="480" /></td></tr></table>
<p>To understand how I applied the principle of invariants to this design,
consider Fig 9.  This shows a parent module and a leaf or child module–both
with assertions and assumptions within them.</p>

<p>In my first step, I verified that the leaf module works.  This is shown in the
left side of Fig 9.  During this step, I ignored the parent module, and only
proved that if the child’s assumptions held then the child would never enter
into an illegal state.</p>

<p>Once the assumptions and module logic had been used to prove the assertions
within the module, I then switched my focus to the parent.  This is shown
on the right of Fig 9.  In this case, I no longer needed to prove the properties
of the child.  Instead, I needed to prove the properties of the parent.  To do
this, I asserted that the assumptions of the child held, and then assumed that
the assertions therefore held as well.</p>

<p>Hmm, that statement was about as confusing as some of the mathematical articles
I’ve read on this topic.  Let me try explaining that again.</p>

<p>Suppose we let <code class="language-plaintext highlighter-rouge">LA</code> refer to the set of assumptions within the leaf module, and
<code class="language-plaintext highlighter-rouge">LB</code> refer to the set of assertions within the leaf module.  By
<a href="/blog/2017/10/19/formal-intro.html">formally verifying</a>
that module, I’ve now proved that <code class="language-plaintext highlighter-rouge">LA -&gt; LB</code>.
Unwrapping this a touch, this is equivalent to the
statement that either <code class="language-plaintext highlighter-rouge">LA</code> is false, or <code class="language-plaintext highlighter-rouge">LB</code> must be true: <code class="language-plaintext highlighter-rouge">(!LA)||(LB)</code>.
Said another way, either one of the assumptions of this module must be false,
or all the assertions must be true.</p>

<p>Now I want to move on to the parent module.  In this case, I have the additional
assumptions <code class="language-plaintext highlighter-rouge">PA</code> and assertions <code class="language-plaintext highlighter-rouge">PB</code> from the parent and I would like to prove
that <code class="language-plaintext highlighter-rouge">PA-&gt;PB</code>.
However, I also need to deal with the leaf module.  For the leaf module, I
know that <code class="language-plaintext highlighter-rouge">LA-&gt;LB</code>.  What I don’t know is whether or not <code class="language-plaintext highlighter-rouge">LA</code> holds since
it consists of values provided by the parent module.  Unless and until I know
that <code class="language-plaintext highlighter-rouge">LA</code> holds, I really know nothing about <code class="language-plaintext highlighter-rouge">LB</code>.  Further, since the wires
composing <code class="language-plaintext highlighter-rouge">LA</code> come from the parent, what I really need to do is to <em>assert</em>
these properties hold in order to guarantee the proper functioning of the leaf.
Hence, I will now assert <code class="language-plaintext highlighter-rouge">LA</code> and assume <code class="language-plaintext highlighter-rouge">LB</code>.  This is backwards from how I
treated these components before.  As a result, I will assume <code class="language-plaintext highlighter-rouge">PA&amp;LB</code> and assert
<code class="language-plaintext highlighter-rouge">PB&amp;LA</code>.</p>

<p>The fascinating part of this is that the master rule of
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
still applies.  We’re still <em>assuming</em> the inputs to the parent module and
<em>asserting</em> the properties of the internal state and any outputs.  How can this
be?  It works because the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
composing the internal state of the parent module are the input
connections to the child.  Hence the assumptions of the child’s inputs
are now outputs from the parent and so they may be asserted.  Likewise the
child’s outputs are now the parent’s inputs, and so it makes sense to make
assumptions about them.</p>

<p>It this is still confusing, relax, I’ll show some code snippets
to illustrate how I applied this concept in the next section.</p>

<blockquote>
  <p>Warning: This process just discussed is flawed, and can leave you believing
your design works when it does not.  See <a href="/formal/2018/12/18/skynet.html">this
article</a> for more details.</p>
</blockquote>

<p>The second way that invariants can be used within a design is within a given
design component (module).  In my case, it was within the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">ZipCPU core</a>.
In this case, we’ll separate the assertions into groups of increasingly
complex logic, called stages in Fig 10 below.</p>

<table align="center" style="float: none"><caption>Fig 10. Invariants applied within a file</caption><tr><td><img src="/img/invariance-internal.svg" alt="" width="720" /></td></tr></table>

<p>Let’s call these sets of assertions <code class="language-plaintext highlighter-rouge">B0</code>, <code class="language-plaintext highlighter-rouge">B1</code>, and <code class="language-plaintext highlighter-rouge">B2</code>.  For the first
formal proof, we’ll prove that the assumptions together with the design
logic prove the <code class="language-plaintext highlighter-rouge">B0</code> property, <code class="language-plaintext highlighter-rouge">A-&gt;B0</code>.  Within the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">ZipCPU core</a>,
I call these <code class="language-plaintext highlighter-rouge">PHASE_ONE_ASSERT</code>ions.  Once we know that <code class="language-plaintext highlighter-rouge">A-&gt;B0</code>,
we turn our attention to proving <code class="language-plaintext highlighter-rouge">B1</code>.  In that case, we now know that
<code class="language-plaintext highlighter-rouge">A</code> is true by assumption, but we also know that <code class="language-plaintext highlighter-rouge">B0</code> is true by the implication
we just proved.  So for this second stage proof, we assume <code class="language-plaintext highlighter-rouge">A</code> <em>and</em> <code class="language-plaintext highlighter-rouge">B0</code> and
attempt to prove <code class="language-plaintext highlighter-rouge">B1</code>.  We can then repeat this again, assuming
<code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B0</code>, and now <code class="language-plaintext highlighter-rouge">B1</code> and proving <code class="language-plaintext highlighter-rouge">B2</code>.</p>

<p>If you’ve examined the (current)
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">formal proof</a>
of the
<a href="/about/zipcpu.html">ZipCPU</a> (it’s still a work in
progress), you may have noticed that I am using both of these methods.
First, I am verifying that the component pieces to the
<a href="/about/zipcpu.html">ZipCPU</a>
work as desired.  Then, I am aggregating those into the proof of the
<a href="/about/zipcpu.html">ZipCPU</a> as a whole.  Second, within the
<a href="/about/zipcpu.html">ZipCPU</a>, I’ve created two parts to the
proof: <code class="language-plaintext highlighter-rouge">B0</code> and <code class="language-plaintext highlighter-rouge">B1</code>.  I’m expecting to create a third and possibly fourth
component later.  Currently, I can prove both <code class="language-plaintext highlighter-rouge">B0</code> and <code class="language-plaintext highlighter-rouge">B1</code> using
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>.</p>

<p>According to <a href="https://www.onespin.com">OneSpin Solutions</a>, this method can
increase the depth of the proof or rather the number of state transitions that
can be examined in a reasonable amount of time by perhaps a thousand fold.
These are their numbers, though.  In my own experience, I can only say that
formally verifying the second stage of the
<a href="/about/zipcpu.html">ZipCPU</a> used to take longer than all
night.  (I’m not really sure how long–I never let it finish.)  It now takes
just over an hour.</p>

<blockquote>
  <p>At one time, I used this approach to formally verify the
<a href="/about/zipcpu.html">ZipCPU</a>.  I’ve since adjusted
my approach, and the newer proof works better than it had when using this
approach.</p>

  <p>For the sake of <a href="https://www.onespin.com">OneSpin Solutions</a>, who had
recommended this method to me, I’m hoping they are quietly aware of the
flaws within it.</p>
</blockquote>

<h2 id="how-this-concept-appears-in-verilog">How this concept appears in Verilog</h2>

<p>The previous sections have discussed a lot about
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
in the abstract.  They’ve
been so far from coded reality that I would imagine I’ve now left several
readers wondering what I’m talking about.  So let’s bring these abstract
concepts to reality, and discuss how they might look within a piece
of Verilog code.</p>

<p>We’ll start with a fairly plain Verilog module.  Almost all of my modules have
the following rough format.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// Copyright statement</span>
<span class="cp">`default_nettype</span>	<span class="n">none</span>
<span class="c1">//</span>
<span class="k">module</span> <span class="n">thismodule</span><span class="p">(</span> <span class="p">...);</span>
	<span class="c1">// Core logic</span>
<span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="c1">// Formal properties</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_some_input</span><span class="p">);</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_some_output</span><span class="p">);</span>
<span class="cp">`endif</span>
<span class="k">endmodule</span></code></pre></figure>

<p>They start with a copyright statement, and then declare the <code class="language-plaintext highlighter-rouge">default_nettype</code>
to be none instead of wire.  (This catches a <em>lot</em> of bugs.)  The module
definition then follows with the core logic within it.  Following the module
logic, there’s an <code class="language-plaintext highlighter-rouge">ifdef FORMAL</code> delimited section ending just before the
<code class="language-plaintext highlighter-rouge">endmodule</code> on the last line of the file.  Inside that section I
place any assumptions or assertions regarding the logic above.  Indeed,
if you browse through any of the code I’ve formally verified, you’ll find
this to be the common form.</p>

<p>If it is possible that this might be a leaf or child module to some other
module within a formal proof, then I’ll make some adjustments to the formal
section.  First, I’ll use a synthesis define to indicate <code class="language-plaintext highlighter-rouge">THISMODULE</code> is
the module being verified.  Inside the module’s yosys script, I’ll also
modify the <code class="language-plaintext highlighter-rouge">read_verilog</code> command to include a <code class="language-plaintext highlighter-rouge">-D THISMODULE</code>.  So, for
example, within the <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v">pipelined memory controller
module</a>,
there’s a check for whether or not <code class="language-plaintext highlighter-rouge">PIPEMEM</code> is defined.  Likewise, you
can see the definition within its <a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/pipemem.ys">its yosys
script</a>.
Second, I’ll define macros which I can then use to reference either the
<code class="language-plaintext highlighter-rouge">assume</code> and <code class="language-plaintext highlighter-rouge">assert</code> statements.  If <code class="language-plaintext highlighter-rouge">THISMODULE</code> is defined, these
will refer to <code class="language-plaintext highlighter-rouge">assume</code> and <code class="language-plaintext highlighter-rouge">assert</code> as expected.  If not, they’ll be
swapped.  Then I rewrite the formal properties to use these macros.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
<span class="cp">`ifdef</span>	<span class="n">THISMODULE</span>
<span class="cp">`define</span>	ASSUME	assume<span class="cp">
`define</span>	ASSERT	assert<span class="cp">
`else</span>
<span class="cp">`define</span>	ASSUME	assert<span class="cp">
`define</span>	ASSERT	assume<span class="cp">
`endif</span>
	<span class="c1">// Formal properties</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="cp">`ASSUME</span><span class="p">(</span><span class="n">i_some_input</span><span class="p">);</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="cp">`ASSERT</span><span class="p">(</span><span class="n">o_some_output</span><span class="p">);</span>
<span class="cp">`endif</span></code></pre></figure>

<p>This is how I handle creating the logic pictured in Fig 9 above within any
of the non-abstracted child modules.</p>

<p>Perhaps the best example of how this might be useful is in the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v">pipelined memory
controller</a>.
The “contract” the
<a href="/about/zipcpu.html">ZipCPU</a>
has with the user is that it will not
<a href="https://meltdownattack.com">speculatively execute memory operations</a>–since the
<a href="/about/zipcpu.html">ZipCPU</a>
places both memory and peripherals on the same bus.  Bus operations may be
<a href="/zipcpu/2017/11/07/wb-formal.html">pipelined</a>,
meaning that multiple reads may be ongoing at any given time.  Now consider,
what would happen if one of those reads set the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>?
There would be no way to undo any of the other reads that might be in
progress by this point.</p>

<p>For example, consider the following string of loads.  In the
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">ZipCPU ISA</a>,
an <code class="language-plaintext highlighter-rouge">LW</code> instruction loads a word of data from the bus into the register given
as the second argument.  (<a href="/about/zipcpu.html">ZipCPU</a>
instructions read left to right.)  The second to the last of these loads reads
a value into the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>.</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">LW (R0),R1	; Load word from the address in R0 into the R1 register
LW 4(R0),R2	; R2 &lt;- Mem[R0+4]
LW 8(R0),R3
LW 12(R0),R4
LW 16(R0),R5
LW 20(R0),PC	; PC &lt;= Mem[R0+20]
LW 24(R0),R6	; Must not issue until the last load has completed</code></pre></figure>

<p>Any time the <a href="https://en.wikipedia.org/wiki/Program_counter">program counter
(PC)</a>
is set, the
CPU
jumps to a new instruction.  Hence, this memory read into the
<a href="https://en.wikipedia.org/wiki/Program_counter">PC</a>
is really a jump instruction.</p>

<p>Should the CPU initiate the read into <code class="language-plaintext highlighter-rouge">R6</code>?  No.  Not until the read into the
<a href="https://en.wikipedia.org/wiki/Program_counter">PC</a> completes.</p>

<p>To check for this, the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v">memory
controller</a>
assumes that any read into the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>
must be the last read in a sequence.  To
<a href="/blog/2017/10/19/formal-intro.html">formally prove</a>
this in an
<a href="/blog/2018/03/10/induction-exercise.html">inductive manner</a>,
I need to check via assertions that the nothing in the
pipeline of ongoing reads contains a read into the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>.
Once proven, the controller then asserts that if any output is to the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>
then it must be the last return value in the sequence.  When this
component is aggregated, the “check every FIFO element” code is quietly
removed, being replaced only be the final assertion on the output.  This
final assertion, however, has been replaced by this process with an assumption
that no longer needs to be checked–simplifying the proof of the
<a href="/about/zipcpu.html">ZipCPU</a>
as a whole.</p>

<p>The second method of applying invariants is the application within a given
file, as shown in Fig 10 above.  In this case, you want to prove several
sets of assertions.  Within the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">core</a>,
I call these <code class="language-plaintext highlighter-rouge">PHASE_ONE</code>, <code class="language-plaintext highlighter-rouge">PHASE_TWO</code>, and so on.
Associated with each phase is an assertion macro, <code class="language-plaintext highlighter-rouge">PHASE_ONE_ASSERT</code>,
<code class="language-plaintext highlighter-rouge">PHASE_TWO_ASSERT</code>, etc.  To then verify the component, you’d run it through
the formal engine twice: first as is, to test all of the phase one assertions,
and then again with <code class="language-plaintext highlighter-rouge">PHASE_TWO</code> defined in order to test the phase two
assertions.  The second set of assertions are excluded from being evaluated
during the first set by a synthesis <code class="language-plaintext highlighter-rouge">ifdef</code> directive.</p>

<p>You can see the
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/zipcpu.sby">script for this here</a>.</p>

<p>The relevant code, shown below, was lifted from the beginning of the
<a href="/about/zipcpu.html">ZipCPU</a>’s <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">formal properties
section</a>.
It starts out with a commented list of all of the formal phases supported by
the <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">module</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
<span class="c1">//</span>
<span class="c1">// PHASE_X definitions control our assertion logic below.  They are to be</span>
<span class="c1">// defined by the synthesizer</span>
<span class="c1">//</span>
<span class="c1">// `define PHASE_TWO</span>
<span class="c1">// `define PHASE_THREE</span>
<span class="c1">// `define PHASE_FOUR</span>
<span class="c1">//</span></code></pre></figure>

<p>These aren’t strictly necessary, but they remind me which defines I am
supporting.</p>

<p>Then each of the phases is given its own assertion macro.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`define</span>	<span class="n">PHASE_ONE_ASSERT</span>	<span class="k">assert</span>
<span class="cp">`define</span>	PHASE_TWO_ASSERT	assert<span class="cp">
`define</span>	PHASE_THR_ASSERT	assert<span class="cp">
</span><span class="c1">//</span></code></pre></figure>

<p>If <code class="language-plaintext highlighter-rouge">PHASE_TWO</code> is defined, the <code class="language-plaintext highlighter-rouge">PHASE_ONE_ASSERT</code> macro is then redefined as
an assumption.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">PHASE_TWO</span>
<span class="cp">`undef</span>	<span class="n">PHASE_ONE_ASSERT</span>
<span class="cp">`define</span>	PHASE_ONE_ASSERT	assume</code></pre></figure>

<p>Likewise, if <code class="language-plaintext highlighter-rouge">PHASE_THREE</code> is also defined then the <code class="language-plaintext highlighter-rouge">PHASE_TWO_ASSERT</code>
is redefined to be an assumption.  This process then repeats for all of the
phases supported by the design.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">PHASE_THREE</span>
<span class="cp">`undef</span>	<span class="n">PHASE_TWO_ASSERT</span>
<span class="cp">`define</span>	PHASE_TWO_ASSERT	assume<span class="cp">
</span>
<span class="cp">`ifdef</span>	<span class="n">PHASE_FOUR</span>
<span class="cp">`undef</span>	<span class="n">PHASE_THR_ASSERT</span>
<span class="cp">`define</span>	PHASE_THR_ASSERT	assume<span class="cp">
`endif</span> <span class="c1">// PHASE_FOUR</span>
<span class="cp">`endif</span> <span class="c1">// PHASE_THREE</span>
<span class="cp">`endif</span> <span class="c1">// PHASE_TWO</span></code></pre></figure>

<p>At this point, the <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">formal
properties</a>
can proceed in sections.  The first section makes any input assumptions
necessary.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// An example assumption</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">i_some_input</span><span class="p">);</span></code></pre></figure>

<p>Then the first set of assertions follows these assumptions.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// An example assertion</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="cp">`PHASE_ONE_ASSERT</span><span class="p">(</span><span class="n">o_some_output</span><span class="p">);</span></code></pre></figure>

<p>This set of assertions is created
using the <code class="language-plaintext highlighter-rouge">PHASE_ONE_ASSERT</code> macro.  That will allow us to replace these
assertions with assumptions in the next pass–once they’ve been proven
true in a first pass.</p>

<p>Later, we can split into a second section of assertions–but only after
we’ve used the formal tools to verify the first set of assertions, and only
if <code class="language-plaintext highlighter-rouge">PHASE_TWO</code> is defined.  In this latter section, assertions are created
using the <code class="language-plaintext highlighter-rouge">PHASE_TWO_ASSERT</code> macro.  Further, in order to get into this
section the <code class="language-plaintext highlighter-rouge">PHASE_ONE_ASSERT</code> macro used the previous section will have
been redefined to be an <code class="language-plaintext highlighter-rouge">assume</code> statement instead of the original <code class="language-plaintext highlighter-rouge">assert</code>
statement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">PHASE_TWO</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="cp">`PHASE_TWO_ASSERT</span><span class="p">(</span><span class="n">o_some_other_output</span><span class="p">);</span>
<span class="cp">`endif</span> <span class="c1">// PHASE_TWO</span>
<span class="cp">`endif</span> <span class="c1">// FORMAL</span></code></pre></figure>

<p>In the case of the
<a href="/about/zipcpu.html">ZipCPU</a>,
the second phase of
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
includes several free variables (<a href="http://www.clifford.at/yosys/">yosys</a>’s
<code class="language-plaintext highlighter-rouge">$anyconst</code>) used to track an arbitrary instruction from an arbitrary address
working its way through the <a href="/about/zipcpu.html">ZipCPU</a>’s
logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">f_const_insn</span>    <span class="o">=</span> <span class="p">$</span><span class="n">anyconst</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">f_const_addr</span>    <span class="o">=</span> <span class="p">$</span><span class="n">anyconst</span><span class="p">;</span></code></pre></figure>

<p>Using this method, I can reconstruct the operands for any operation
before that operation is issued, and verify that they have the right values.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="c1">// details</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="c1">// more details ...</span>
		<span class="k">begin</span>
			<span class="c1">// Check that the first operand matches</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fc_rA</span><span class="p">)</span>
				<span class="cp">`PHASE_TWO_ASSERT</span><span class="p">(</span><span class="n">f_Av</span> <span class="o">==</span> <span class="n">op_Av</span><span class="p">);</span>
			<span class="c1">// Now check the second operand</span>
			<span class="cp">`PHASE_TWO_ASSERT</span><span class="p">(</span><span class="n">f_Bv</span> <span class="o">==</span> <span class="n">op_Bv</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>If you’ll recall from the article describing the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">instruction set</a>,
almost all
<a href="/about/zipcpu.html">ZipCPU</a>
instructions have the basic form: <code class="language-plaintext highlighter-rouge">OP.C Ra,Rb+I</code>, where <code class="language-plaintext highlighter-rouge">Ra</code> and <code class="language-plaintext highlighter-rouge">Rb</code> are
arbitrary registers, and <code class="language-plaintext highlighter-rouge">I</code> is some immediate constant.</p>

<table align="center" style="float: none"><caption>Fig 11. ZipCPU's ALU stage in context</caption><tr><td><img src="/img/cpu-bypass.svg" alt="" width="640" /></td></tr></table>

<p>Prior to entering the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
stage, the
<a href="/about/zipcpu.html">ZipCPU</a>
adds the <code class="language-plaintext highlighter-rouge">Rb</code> register value and <code class="language-plaintext highlighter-rouge">I</code> together.  Then, while waiting for the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
stage to become available, any write to either <code class="language-plaintext highlighter-rouge">Ra</code> or <code class="language-plaintext highlighter-rouge">Rb</code> adjusts these
values.</p>

<p>What makes this difficult is that, in order to keep clock speed high, there’s
no opportunity to re-add the immediate constant <code class="language-plaintext highlighter-rouge">I</code> to <code class="language-plaintext highlighter-rouge">Rb</code>–that would take an
extra clock tick.  Dealing with this requires some careful pipeline stall
logic, and getting this logic right has been
tricky.  By allowing the formal engine to pick an arbitrary pipeline state
and then examine an arbitrary instruction going into the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>,
I can guarantee that the <code class="language-plaintext highlighter-rouge">Ra</code> and <code class="language-plaintext highlighter-rouge">Rb+I</code> operands are valid no matter
which instruction precedes them.</p>

<p>Searching through all of the possibilities of these free variables
can be expensive.  Indeed, this was the phase that was taking many hours
of processing as I was working on verifying
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">this core</a>
module within the
<a href="/about/zipcpu.html">ZipCPU</a>.  Now, using this method of
invariants, the entire formal verification of the (still not quite complete
properties of the)
<a href="/about/zipcpu.html">ZipCPU</a>
takes less than two hours.</p>

<blockquote>
  <p>In hindsight, this made my CPU proof more complicated than it needed to be,
while leaving the proof susceptible to false positives.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>Invariants are only one method of handling formal complexity when aggregating
multiple modules together.  As I mentioned in the opening, I am by no means
an expert in
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>,
and so this is only my first application of
the principle of invariants to any project–in this case the
<a href="/about/zipcpu.html">ZipCPU</a>.
However, even in the case of the
<a href="/about/zipcpu.html">ZipCPU</a>,
the value of using invariants has saved many, many
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
CPU cycles.</p>

<p>We’ll have to return to this topic later in order to handle the concept of
abstraction in
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>.
Abstraction may be an even more powerful concept than invariants.
As you may remember from above, I’ve been using abstracted components to
represent the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_prefetch.v">prefetch</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v">multiply</a>,
and
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_div.v">divide</a>
components.  As another illustration, consider this: when
<a href="/blog/2017/10/19/formal-intro.html">formally verifying</a>
any container of the
<a href="/about/zipcpu.html">ZipCPU</a>,
whether the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>,
or some yet to be determined container, I’m anticipating being able to
replace the entire complicated
<a href="/about/zipcpu.html">ZipCPU</a>
core with an abstracted version of it, and then to be able to prove
the formal properties of the wrapper in question.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And that ye study to be quiet, and to do your own business, and to work with your own hands, as we commanded you (1Thes 4:11)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
