<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Aggregating verified modules together</title>
  <meta name="description" content="Fig 1. The ZipCPUIf you’ve been following my work with theZipCPU,you’ll know that I have formally verified all of the leafmodules,and that I am now working o...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zipcpu.com/formal/2018/04/23/invariant.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="http://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Aggregating verified modules together</h1>
    <p class="post-meta"><time datetime="2018-04-23T00:00:00-04:00" itemprop="datePublished">Apr 23, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. The ZipCPU</caption><tr><td><img src="/img/zipcpu.svg" alt="Block diagram of the ZipCPU, showing five pipeline stages" width="360" /></td></tr></table>
<p>If you’ve been following my work with the
<a href="/about/zipcpu.html">ZipCPU</a>,
you’ll know that I have formally verified <a href="/blog/2018/01/22/formal-progress.html">all of the leaf
modules</a>,
and that I am now working on verifying
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">the CPU</a>
<a href="/blog/2018/04/02/formal-cpu-bugs.html">as a whole</a>.
By “leaf module”, I mean a design component that references no other design
components.
You might also remember that <a href="/blog/2017/10/19/formal-intro.html">I am rather new to formal
verification</a>,
having only picked it up within this last year.  Verifying the
<a href="/about/zipcpu.html">ZipCPU</a>
may be the most complex design I’ve tried to verify yet.</p>

<p>Prior to my attempts at formally verifying the
<a href="/about/zipcpu.html">ZipCPU</a>,
the most difficult proof I had worked on was for a proprietary block
floating point module.  That module assigned a single exponent for all
of the values within a block of <code class="highlighter-rouge">2^N</code> numbers, and then output the input
numbers sequentially together with their assigned floating point value.  Like
the
<a href="/about/zipcpu.html">ZipCPU</a>,
it also involved proving a module with a leaf module underneath it.
The alignment was very difficult to get right in that implementation
and so I dependended heavily upon the <a href="/blog/2017/10/19/formal-intro.html">formally verified
properties</a>
of those two modules in order to have the assurance that the component
even worked.</p>

<p>Along the way, I’ve learned that there are some tricks to aggregating
<a href="/blog/2017/10/19/formal-intro.html">formally verified</a>
submodules together in order to prove the whole.  I’ve now learned two
particular techniques, abstraction and invariants, to help
control the complexity of a formal proof.
Today’s discussion will focus on invariants.  If the
<a href="https://www.blueletterbible.org/kjv/jas/4/15">Lord is willing</a>,
we’ll come back and discuss how to use abstraction, and present several
examples of it.</p>

<p>I would love to declare, before starting out, that I am an expert on these
techniques.  I’m not.  Perhaps if I had found some article
or set of articles describing them I might be able to declare some amount
of expertise.  Sadly, while I found
a small number of articles describing invariants, I struggled to relate the
concepts presented within those articles to the
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
problems
I was dealing with.  The one source I found to guide me along this road
was a presentation from <a href="https://www.onespin.com">OneSpin Solutions</a> at
<a href="https://dvcon.org">DVCon</a> 2018 in San Jose.</p>

<p>So with credit to <a href="https://www.onespin.com">OneSpin Solutions</a>, here’s
what I have learned about
invariants and how they apply to
<a href="/blog/2017/10/19/formal-intro.html">Formal Verification</a>.
More than that, I’ll
try to keep this presentation simple enough to be understandable, and
focused on how these topics apply to the
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
of complex RTL modules.</p>

<h2 id="formal-property-review">Formal Property Review</h2>

<p>If you are coming in to the discussion late, then there are two concepts
you must understand in order to follow the discussion below.  These are
the <code class="highlighter-rouge">assume()</code> and <code class="highlighter-rouge">assert()</code> System Verilog operators.  I like to explain
these with a set of diagrams describing the state of a design at any
given point in time.</p>

<table align="center" style="float: right"><caption>Fig 2. Formal regions of relevance</caption><tr><td><img src="/img/formal-bmc.svg" alt="" width="360" /></td></tr></table>
<p>One such example state diagram is shown in Fig 2.  Consider every point in
this image as representing one state of all the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
in your design.  Any change to one of the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
in your design will move your system’s state to a new point on the diagram.</p>

<p>Several parts of this diagram are worth noting.</p>

<p>First, note that your design starts from an initial state, as defined by the
<code class="highlighter-rouge">initial</code> statements within your design.  From this point, the inputs to your
design together with the logic within your design will cause the design
to move from one state to another.</p>

<p>Second, note that there are three different types of states you can be in.
The first set of states are the set of “valid” states.  These are all of the
states that may be reached from your initial state without violating any
<code class="highlighter-rouge">assert</code>ions within your design.  These are shown in green.</p>

<p>The second set of states are those shown in red.  These are the “illegal” or
“invalid” states.  These are defined by all those states that violate an
<code class="highlighter-rouge">assert()</code> statements within your design.
Your goal, using formal methods, will be to prove that you cannot cross from
a point in the set of valid states to one of the invalid states.</p>

<p>There is a third set of states.  This set is shown by the largest region
containing all of the others.  This is the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of all possible sets of
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
(register) combinations of values within your design.  Initially, this set is
defined by every
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flop</a>
combination in your design.  Hence if you have <code class="highlighter-rouge">N</code>
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
in your design, then without any further assumptions there are initially
<code class="highlighter-rouge">2^N</code> states in this set.  Not all of these states will be <em>reachable</em> from
your initial state.</p>

<table align="center" style="float: left"><caption>Fig 3. The Effect of an Assumption</caption><tr><td><img src="/img/formal-bmc-assume.svg" alt="" width="360" /></td></tr></table>
<p>Within your design, you have two sorts of statements you can make about the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
within your design.  The first is the <code class="highlighter-rouge">assume()</code> statement.  This reduces the
size of the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of values your
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
may be set to.</p>

<p>To use the <a href="/zipcpu/2018/04/17/ziptimer.html">example of a
counter</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	if (i_reset)
		r_value &lt;= 0;
	else if (i_start)
		r_value &lt;= TIMEOUT;
	else if (r_value != 0)
		r_value &lt;= r_value - 1'b1;</code></pre></figure>

<p>we might assume that the <code class="highlighter-rouge">i_reset</code> signal is always zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(*)
	assume(!i_reset);</code></pre></figure>

<p>This will restrict the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of possibilities to only those where <code class="highlighter-rouge">i_reset</code> is
always zero.</p>

<p>The goal of
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
is to examine <em>every possible</em> state your design can enter into in order
to prove that your design will never reach an <em>invalid</em> state.
As I’m sure you can imagine, this task can be a challenge.  In general, this
challenge is <code class="highlighter-rouge">NP-hard</code>–the computational complexity is roughly exponential
in the size of the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
within your design.  Hence, the smaller you can make the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of possibilities the easier it will be to verify a design.</p>

<table align="center" style="float: right"><caption>Fig 4. The Effect of an Assertion</caption><tr><td><img src="/img/formal-bmc-assert.svg" alt="" width="360" /></td></tr></table>
<p>The second basic formal statement is the <code class="highlighter-rouge">assert()</code> statement.  Unlike the
<code class="highlighter-rouge">assume()</code> statement which limits the size of the search space, the <code class="highlighter-rouge">assert()</code>
statement declares particular states within that
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
are somehow “illegal” as shown in Fig 4.  When you use
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>,
your goal will be to guarantee your design remains in a legal state.</p>

<p>If we return to the
<a href="/zipcpu/2018/04/17/ziptimer.html">timer example</a>
above, we might assert that value of the counter is never one greater than
<code class="highlighter-rouge">TIMEOUT</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(*)
	assert(r_value != TIMEOUT+1);</code></pre></figure>

<p>When applying
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
to this example, the engine will quickly point out that
the initial state may lie within the red or illegal states–since we did nothing
to restrict <code class="highlighter-rouge">r_value</code>s contents initially.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">initial r_value = 0;</code></pre></figure>

<p>These two operators, <code class="highlighter-rouge">assume</code> and <code class="highlighter-rouge">assert</code>, alone should be enough to get you
started with
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>,
and there’s a lot you can do with them.  However, if you want to <em>prove</em> that
your design will work for all time rather than just the first <code class="highlighter-rouge">S</code> time steps,
then you will need to apply the
<a href="/blog/2017/10/19/formal-intro.html">formal method</a>
called
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<p><a href="/blog/2018/03/10/induction-exercise.html">Induction</a>
starts by assuming your design is somewhere among the
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>
of all possible states, and that the initial state the engine has chosen
is not illegal.  Its first
step is to create <code class="highlighter-rouge">S</code> time steps where your design stays out of the
illegal set of states.  Then, on the <code class="highlighter-rouge">S+1</code> time step, it tries to see if it
is possible to enter into the set of illegal states.</p>

<p>The difficult part of this
<a href="/blog/2018/03/10/induction-exercise.html">inductive step</a>
is that the formal engine cannot tell the difference between reachable states
and unreachable states.  This can be <a href="/blog/2018/03/10/induction-exercise.html">particularly
problematic</a>
for the new user of
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
to understand.
A common refrain is, “how did the formal engine put my design into this
state?  There’s no way it can get there!”</p>

<table align="center" style="float: left"><caption>Fig 5. The Lesson of Induction</caption><tr><td><img src="/img/formal-induction-soln.svg" alt="" width="360" /></td></tr></table>
<p>Addressing this problem was the subject of a
<a href="/blog/2018/03/10/induction-exercise.html">prior article</a>.
In that article, I explained that you must use either an <code class="highlighter-rouge">assume</code> or an <code class="highlighter-rouge">assert</code>
to keep the formal engine from reaching any unreachable states, or you will
never be able to fully <em>prove</em> your design meets the properties you have
asserted for all time.</p>

<p>Following our example of a timer, the formal engine might pick a value for
<code class="highlighter-rouge">r_value</code> that was <code class="highlighter-rouge">TIMEOUT+S+2</code>.  It would then follow <code class="highlighter-rouge">r_value</code> for
<code class="highlighter-rouge">S</code> steps until <code class="highlighter-rouge">r_value</code> was <code class="highlighter-rouge">TIMEOUT+2</code>.  On the next step, our property
that <code class="highlighter-rouge">(r_value != TIMEOUT+1)</code> would be violated.</p>

<p>To fix this, one would need to assert instead that <code class="highlighter-rouge">r_value &lt;= TIMEOUT</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(*)
	assert(r_value &lt;= TIMEOUT);</code></pre></figure>

<p>This makes the size of the “red” area large enough to include the whole
<a href="https://en.wikipedia.org/wiki/Universe_(mathematics)">universe</a>, as shown
in Fig 5.  To follow the consequence of this in our example above,
<code class="highlighter-rouge">r_value</code> would never be allowed to be <code class="highlighter-rouge">TIMEOUT+S+2</code>.  It would only be allowed
to have a valid value.</p>

<p>To know which of the two, <code class="highlighter-rouge">assert</code> or <code class="highlighter-rouge">assume</code>, is appropriate at any given
time, I’ve always used what I call the <em>master rule of Formal Verification</em>
shown in Fig 6: <em>assume inputs</em>, then <em>assert</em> properties of both
<em>internal states and outputs</em>.</p>
<table align="center" style="float: right"><caption>Fig 6. Master rule of Formal Verification</caption><tr><td><img src="/img/fv-master-rule.svg" alt="" width="280" /></td></tr></table>

<p>This rule has served me well for all of my
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
efforts to date.  Now that I’ve discovered I need to aggregate modules together,
I’ve had to learn some of the fine nuances of this rule.  These nuances
are the subject of the rest of this article.</p>

<h2 id="the-concept-of-an-invariant">The Concept of an Invariant</h2>

<p>What the master rule of
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
doesn’t capture is how you deal
with things that have already been proven.  For example, let’s suppose <code class="highlighter-rouge">A</code>
is a set of assumptions, and <code class="highlighter-rouge">B</code> is a set of assertions.  Once you’ve proven
that <code class="highlighter-rouge">A</code> implies <code class="highlighter-rouge">B</code>, which I shall write as <code class="highlighter-rouge">A-&gt;B</code>, then you shouldn’t need
to prove it again.</p>

<table align="center" style="float: left"><caption>Fig 7. (Some caption)</caption><tr><td><img src="/img/formal-invariants.svg" alt="" width="360" /></td></tr></table>
<p>This is the concept of an Invariant.  Once you know that <code class="highlighter-rouge">A-&gt;B</code>, then <code class="highlighter-rouge">A-&gt;B</code>
becomes an invariant of your design.  Instead of reproving it, you may now treat
it as an assumption.  This becomes especially useful when trying to deal
with complex proofs. If you can reduce the complexity, you can then verify
larger and larger designs.</p>

<p>There are two situations where I have found to apply this.  The first is
that of a parent module with a child (or leaf) module underneath it.  The
second place is when the proof of a design can be broken into separate sections.
I’ve encountered both while trying to verify the
<a href="/about/zipcpu.html">ZipCPU</a>.  We’ll
examine each in turn.</p>

<table align="center" style="float: right"><caption>Fig 8. ZipCPU's module hierarchy</caption><tr><td><img src="/img/files-zipcpu-proved.svg" alt="" width="240" /></td></tr></table>
<p>To explain the first situation, consider the module hierarchy (file structure)
of the <a href="/about/zipcpu.html">ZipCPU</a>
shown in Fig 8.  The
<a href="/about/zipcpu.html">ZipCPU</a> consists of a
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">master CPU</a>
file, an <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/idecode.v">instruction
decoder</a>, an
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/cpuops.v">ALU</a> with a
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/mpyop.v">multiply component</a>
within it, a <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/ex/wbdblpriarb.v">twin bus
arbiter</a>,
and one of two <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/memops.v">memory
controllers</a>.
I use the red bar in Fig 8 to indicate the
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>
within the design.  Normally these properties are found at the end of the
source file.  You’d therefore normally expect this red bar to be at the bottom
of each file within the diagram.  However, since the concept of invariants
turns these properties on end, I show the red bar in this figure at the top
of the file–for illustration purposes.</p>

<p>The other three components of the
<a href="/about/zipcpu.html">ZipCPU</a> were abstracted.
These were the
<a href="/zipcpu/2017/11/18/wb-prefetch.html">prefetch</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/div.v">divide</a>, and
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/mpyop.v">multiply</a>.
These are shown in Fig 8 as empty files with dotted lines around them,
indicating that due to the abstraction they have very little logic remaining
within them.  You can find their abstract representations in
my <a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal">bench/formal</a>
directory.  These also made the proof easier, but for now we’ll leave the
mechanics of this for a topic for a future article.</p>

<table align="center" style="float: left"><caption>Fig 9. Invariants applied to a parent/leaf module hierarchy</caption><tr><td><img src="/img/invariance-external.svg" alt="" width="480" /></td></tr></table>
<p>To understand how I applied the principle of invariants to this design,
consider Fig 9.  This shows a parent module and a leaf or child module–both
with assertions and assumptions within them.</p>

<p>In my first step, I verified that the leaf module works.  This is shown in the
left side of Fig 9.  During this step, I ignored the parent module, and only
proved that if the child’s assumptions held then the child would never enter
into an illegal state.</p>

<p>Once the assumptions and module logic had been used to prove the assertions
within the module, I then switched my focus to the parent.  This is shown
on the right of Fig 9.  In this case, I no longer needed to prove the properties
of the child.  Instead, I needed to prove the properties of the parent.  To do
this, I asserted that the assumptions of the child held, and then assumed that
the assertions therefore held as well.</p>

<p>Hmm, that statement was about as confusing as some of the mathematical articles
I’ve read on this topic.  Let me try explaining that again.</p>

<p>Suppose we let <code class="highlighter-rouge">LA</code> refer to the set of assumptions within the leaf module, and
<code class="highlighter-rouge">LB</code> refer to the set of assertions within the leaf module.  By
<a href="/blog/2017/10/19/formal-intro.html">formally verifying</a>
that module, I’ve now proved that <code class="highlighter-rouge">LA -&gt; LB</code>.
Unwrapping this a touch, this is equivalent to the
statement that either <code class="highlighter-rouge">LA</code> is false, or <code class="highlighter-rouge">LB</code> must be true: <code class="highlighter-rouge">(!LA)||(LB)</code>.
Said another way, either one of the assumptions of this module must be false,
or all the assertions must be true.</p>

<p>Now I want to move on to the parent module.  In this case, I have the additional
assumptions <code class="highlighter-rouge">PA</code> and assertions <code class="highlighter-rouge">PB</code> from the parent and I would like to prove
that <code class="highlighter-rouge">PA-&gt;PB</code>.
However, I also need to deal with the leaf module.  For the leaf module, I
know that <code class="highlighter-rouge">LA-&gt;LB</code>.  What I don’t know is whether or not <code class="highlighter-rouge">LA</code> holds since
it consists of values provided by the parent module.  Unless and until I know
that <code class="highlighter-rouge">LA</code> holds, I really know nothing about <code class="highlighter-rouge">LB</code>.  Further, since the wires
composing <code class="highlighter-rouge">LA</code> come from the parent, what I really need to do is to <em>assert</em>
these properties hold in order to guarantee the proper functioning of the leaf.
Hence, I will now assert <code class="highlighter-rouge">LA</code> and assume <code class="highlighter-rouge">LB</code>.  This is backwards from how I
treated these components before.  As a result, I will assume <code class="highlighter-rouge">PA&amp;LB</code> and assert
<code class="highlighter-rouge">PB&amp;LA</code>.</p>

<p>The fascinating part of this is that the master rule of
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
still applies.  We’re still <em>assuming</em> the inputs to the parent module and
<em>asserting</em> the properties of the internal state and any outputs.  How can this
be?  It works because the
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
composing the internal state of the parent module are the input
connections to the child.  Hence the assumptions of the child’s inputs
are now outputs from the parent and so they may be asserted.  Likewise the
child’s outputs are now the parent’s inputs, and so it makes sense to make
assumptions about them.</p>

<p>It this is still confusing, relax, I’ll show some code snippets
to illustrate how I applied this concept in the next section.</p>

<p>The second way that invariants can be used within a design is within a given
design component (module).  In my case, it was within the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">ZipCPU core</a>.
In this case, we’ll separate the assertions into groups of increasingly
complex logic, called stages in Fig 10 below.</p>

<table align="center" style="float: none"><caption>Fig 10. Invariants applied within a file</caption><tr><td><img src="/img/invariance-internal.svg" alt="" width="720" /></td></tr></table>

<p>Let’s call these sets of assertions <code class="highlighter-rouge">B0</code>, <code class="highlighter-rouge">B1</code>, and <code class="highlighter-rouge">B2</code>.  For the first
formal proof, we’ll prove that the assumptions together with the design
logic prove the <code class="highlighter-rouge">B0</code> property, <code class="highlighter-rouge">A-&gt;B0</code>.  Within the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">ZipCPU core</a>,
I call these <code class="highlighter-rouge">PHASE_ONE_ASSERT</code>ions.  Once we know that <code class="highlighter-rouge">A-&gt;B0</code>,
we turn our attention to proving <code class="highlighter-rouge">B1</code>.  In that case, we now know that
<code class="highlighter-rouge">A</code> is true by assumption, but we also know that <code class="highlighter-rouge">B0</code> is true by the implication
we just proved.  So for this second stage proof, we assume <code class="highlighter-rouge">A</code> <em>and</em> <code class="highlighter-rouge">B0</code> and
attempt to prove <code class="highlighter-rouge">B1</code>.  We can then repeat this again, assuming
<code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">B0</code>, and now <code class="highlighter-rouge">B1</code> and proving <code class="highlighter-rouge">B2</code>.</p>

<p>If you’ve examined the (current)
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">formal proof</a>
of the
<a href="/about/zipcpu.html">ZipCPU</a> (it’s still a work in
progress), you may have noticed that I am using both of these methods.
First, I am verifying that the component pieces to the
<a href="/about/zipcpu.html">ZipCPU</a>
work as desired.  Then, I am aggregating those into the proof of the
<a href="/about/zipcpu.html">ZipCPU</a> as a whole.  Second, within the
<a href="/about/zipcpu.html">ZipCPU</a>, I’ve created two parts to the
proof: <code class="highlighter-rouge">B0</code> and <code class="highlighter-rouge">B1</code>.  I’m expecting to create a third and possibly fourth
component later.  Currently, I can prove both <code class="highlighter-rouge">B0</code> and <code class="highlighter-rouge">B1</code> using
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>.</p>

<p>According to <a href="https://www.onespin.com">OneSpin Solutions</a>, this method can
increase the depth of the proof or rather the number of state transitions that
can be examined in a reasonable amount of time by perhaps a thousand fold.
These are their numbers, though.  In my own experience, I can only say that
formally verifying the second stage of the
<a href="/about/zipcpu.html">ZipCPU</a> used to take longer than all
night.  (I’m not really sure how long–I never let it finish.)  It now takes
just over an hour.</p>

<h2 id="how-this-concept-appears-in-verilog">How this concept appears in Verilog</h2>

<p>The previous sections have discussed a lot about
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
in the abstract.  They’ve
been so far from coded reality that I would imagine I’ve now left several
readers wondering what I’m talking about.  So let’s bring these abstract
concepts to reality, and discuss how they might look within a piece
of Verilog code.</p>

<p>We’ll start with a fairly plain Verilog module.  Almost all of my modules have
the following rough format.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">// Copyright statement
`default_nettype	none
//
module thismodule( ...);
	// Core logic
`ifdef	FORMAL
	// Formal properties

	always @(*)
		assume(i_some_input);
	always @(*)
		assert(o_some_output);
`endif
endmodule</code></pre></figure>

<p>They start with a copyright statement, and then declare the <code class="highlighter-rouge">default_nettype</code>
to be none instead of wire.  (This catches a <em>lot</em> of bugs.)  The module
definition then follows with the core logic within it.  Following the module
logic, there’s an <code class="highlighter-rouge">ifdef FORMAL</code> delimited section ending just before the
<code class="highlighter-rouge">endmodule</code> on the last line of the file.  Inside that section I
place any assumptions or assertions regarding the logic above.  Indeed,
if you browse through any of the code I’ve formally verified, you’ll find
this to be the common form.</p>

<p>If it is possible that this might be a leaf or child module to some other
module within a formal proof, then I’ll make some adjustments to the formal
section.  First, I’ll use a synthesis define to indicate <code class="highlighter-rouge">THISMODULE</code> is
the module being verified.  Inside the module’s yosys script, I’ll also
modify the <code class="highlighter-rouge">read_verilog</code> command to include a <code class="highlighter-rouge">-D THISMODULE</code>.  So, for
example, within the <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v">pipelined memory controller
module</a>,
there’s a check for whether or not <code class="highlighter-rouge">PIPEMEM</code> is defined.  Likewise, you
can see the definition within its <a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/pipemem.ys">its yosys
script</a>.
Second, I’ll define macros which I can then use to reference either the
<code class="highlighter-rouge">assume</code> and <code class="highlighter-rouge">assert</code> statements.  If <code class="highlighter-rouge">THISMODULE</code> is defined, these
will refer to <code class="highlighter-rouge">assume</code> and <code class="highlighter-rouge">assert</code> as expected.  If not, they’ll be
swapped.  Then I rewrite the formal properties to use these macros.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`ifdef	FORMAL
`ifdef	THISMODULE
`define	ASSUME	assume
`define	ASSERT	assert
`else
`define	ASSUME	assert
`define	ASSERT	assume
`endif
	// Formal properties
	always @(*)
		`ASSUME(i_some_input);
	always @(*)
		`ASSERT(o_some_output);
`endif</code></pre></figure>

<p>This is how I handle creating the logic pictured in Fig 9 above within any
of the non-abstracted child modules.</p>

<p>Perhaps the best example of how this might be useful is in the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v">pipelined memory
controller</a>.
The “contract” the
<a href="/about/zipcpu.html">ZipCPU</a>
has with the user is that it will not
<a href="https://meltdownattack.com">speculatively execute memory operations</a>–since the
<a href="/about/zipcpu.html">ZipCPU</a>
places both memory and peripherals on the same bus.  Bus operations may be
<a href="/zipcpu/2017/11/07/wb-formal.html">pipelined</a>,
meaning that multiple reads may be ongoing at any given time.  Now consider,
what would happen if one of those reads set the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>?
There would be no way to undo any of the other reads that might be in
progress by this point.</p>

<p>For example, consider the following string of loads.  In the
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">ZipCPU ISA</a>,
an <code class="highlighter-rouge">LW</code> instruction loads a word of data from the bus into the register given
as the second argument.  (<a href="/about/zipcpu.html">ZipCPU</a>
instructions read left to right.)  The second to the last of these loads reads
a value into the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>.</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">LW (R0),R1	; Load word from the address in R0 into the R1 register
LW 4(R0),R2	; R2 &lt;- Mem[R0+4]
LW 8(R0),R3
LW 12(R0),R4
LW 16(R0),R5
LW 20(R0),PC	; PC &lt;= Mem[R0+20]
LW 24(R0),R6	; Must not issue until the last load has completed</code></pre></figure>

<p>Any time the <a href="https://en.wikipedia.org/wiki/Program_counter">program counter
(PC)</a>
is set, the
CPU
jumps to a new instruction.  Hence, this memory read into the
<a href="https://en.wikipedia.org/wiki/Program_counter">PC</a>
is really a jump instruction.</p>

<p>Should the CPU initiate the read into <code class="highlighter-rouge">R6</code>?  No.  Not until the read into the
<a href="https://en.wikipedia.org/wiki/Program_counter">PC</a> completes.</p>

<p>To check for this, the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/pipemem.v">memory
controller</a>
assumes that any read into the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>
must be the last read in a sequence.  To
<a href="/blog/2017/10/19/formal-intro.html">formally prove</a>
this in an
<a href="/blog/2018/03/10/induction-exercise.html">inductive manner</a>,
I need to check via assertions that the nothing in the
pipeline of ongoing reads contains a read into the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>.
Once proven, the controller then asserts that if any output is to the
<a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>
then it must be the last return value in the sequence.  When this
component is aggregated, the “check every FIFO element” code is quietly
removed, being replaced only be the final assertion on the output.  This
final assertion, however, has been replaced by this process with an assumption
that no longer needs to be checked–simplifying the proof of the
<a href="/about/zipcpu.html">ZipCPU</a>
as a whole.</p>

<p>The second method of applying invariants is the application within a given
file, as shown in Fig 10 above.  In this case, you want to prove several
sets of assertions.  Within the
<a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">core</a>,
I call these <code class="highlighter-rouge">PHASE_ONE</code>, <code class="highlighter-rouge">PHASE_TWO</code>, and so on.
Associated with each phase is an assertion macro, <code class="highlighter-rouge">PHASE_ONE_ASSERT</code>,
<code class="highlighter-rouge">PHASE_TWO_ASSERT</code>, etc.  To then verify the component, you’d run it through
the formal engine twice: first as is, to test all of the phase one assertions,
and then again with <code class="highlighter-rouge">PHASE_TWO</code> defined in order to test the phase two
assertions.  The second set of assertions are excluded from being evaluated
during the first set by a synthesis <code class="highlighter-rouge">ifdef</code> directive.</p>

<p>You can see the
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/zipcpu.sby">script for this here</a>.</p>

<p>The relevant code, shown below, was lifted from the beginning of the
<a href="/about/zipcpu.html">ZipCPU</a>’s <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">formal properties
section</a>.
It starts out with a commented list of all of the formal phases supported by
the <a href="/about/zipcpu.html">ZipCPU</a>
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">module</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`ifdef	FORMAL
//
// PHASE_X definitions control our assertion logic below.  They are to be
// defined by the synthesizer
//
// `define PHASE_TWO
// `define PHASE_THREE
// `define PHASE_FOUR
//</code></pre></figure>

<p>These aren’t strictly necessary, but they remind me which defines I am
supporting.</p>

<p>Then each of the phases is given its own assertion macro.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`define	PHASE_ONE_ASSERT	assert
`define	PHASE_TWO_ASSERT	assert
`define	PHASE_THR_ASSERT	assert
//</code></pre></figure>

<p>If <code class="highlighter-rouge">PHASE_TWO</code> is defined, the <code class="highlighter-rouge">PHASE_ONE_ASSERT</code> macro is then redefined as
an assumption.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`ifdef	PHASE_TWO
`undef	PHASE_ONE_ASSERT
`define	PHASE_ONE_ASSERT	assume</code></pre></figure>

<p>Likewise, if <code class="highlighter-rouge">PHASE_THREE</code> is also defined then the <code class="highlighter-rouge">PHASE_TWO_ASSERT</code>
is redefined to be an assumption.  This process then repeats for all of the
phases supported by the design.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`ifdef	PHASE_THREE
`undef	PHASE_TWO_ASSERT
`define	PHASE_TWO_ASSERT	assume

`ifdef	PHASE_FOUR
`undef	PHASE_THR_ASSERT
`define	PHASE_THR_ASSERT	assume
`endif // PHASE_FOUR
`endif // PHASE_THREE
`endif // PHASE_TWO</code></pre></figure>

<p>At this point, the <a href="https://github.com/ZipCPU/zipcpu/blob/dev/rtl/core/zipcpu.v">formal
properties</a>
can proceed in sections.  The first section makes any input assumptions
necessary.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	// An example assumption
	always @(*)
		assume(i_some_input);</code></pre></figure>

<p>Then the first set of assertions follows these assumptions.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	// An example assertion
	always @(*)
		`PHASE_ONE_ASSERT(o_some_output);</code></pre></figure>

<p>This set of assertions is created
using the <code class="highlighter-rouge">PHASE_ONE_ASSERT</code> macro.  That will allow us to replace these
assertions with assumptions in the next pass–once they’ve been proven
true in a first pass.</p>

<p>Later, we can split into a second section of assertions–but only after
we’ve used the formal tools to verify the first set of assertions, and only
if <code class="highlighter-rouge">PHASE_TWO</code> is defined.  In this latter section, assertions are created
using the <code class="highlighter-rouge">PHASE_TWO_ASSERT</code> macro.  Further, in order to get into this
section the <code class="highlighter-rouge">PHASE_ONE_ASSERT</code> macro used the previous section will have
been redefined to be an <code class="highlighter-rouge">assume</code> statement instead of the original <code class="highlighter-rouge">assert</code>
statement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">`ifdef	PHASE_TWO
	always @(*)
		`PHASE_TWO_ASSERT(o_some_other_output);
`endif // PHASE_TWO
`endif // FORMAL</code></pre></figure>

<p>In the case of the
<a href="/about/zipcpu.html">ZipCPU</a>,
the second phase of
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
includes several free variables (<a href="http://www.clifford.at/yosys/">yosys</a>’s
<code class="highlighter-rouge">$anyconst</code>) used to track an arbitrary instruction from an arbitrary address
working its way through the <a href="/about/zipcpu.html">ZipCPU</a>’s
logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assign	f_const_insn    = $anyconst;
	assign	f_const_addr    = $anyconst;</code></pre></figure>

<p>Using this method, I can reconstruct the operands for any operation
before that operation is issued, and verify that they have the right values.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if // details
	begin
		if // more details ...
		begin
			// Check that the first operand matches
			if (fc_rA)
				`PHASE_TWO_ASSERT(f_Av == op_Av);
			// Now check the second operand
			`PHASE_TWO_ASSERT(f_Bv == op_Bv);
		end
	end</code></pre></figure>

<p>If you’ll recall from the article describing the
<a href="/about/zipcpu.html">ZipCPU</a>’s
<a href="/zipcpu/2018/01/01/zipcpu-isa.html">instruction set</a>,
almost all
<a href="/about/zipcpu.html">ZipCPU</a>
instructions have the basic form: <code class="highlighter-rouge">OP.C Ra,Rb+I</code>, where <code class="highlighter-rouge">Ra</code> and <code class="highlighter-rouge">Rb</code> are
arbitrary registers, and <code class="highlighter-rouge">I</code> is some immediate constant.</p>

<table align="center" style="float: none"><caption>Fig 11. ZipCPU's ALU stage in context</caption><tr><td><img src="/img/cpu-bypass.svg" alt="" width="640" /></td></tr></table>

<p>Prior to entering the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
stage, the
<a href="/about/zipcpu.html">ZipCPU</a>
adds the <code class="highlighter-rouge">Rb</code> register value and <code class="highlighter-rouge">I</code> together.  Then, while waiting for the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>
stage to become available, any write to either <code class="highlighter-rouge">Ra</code> or <code class="highlighter-rouge">Rb</code> adjusts these
values.</p>

<p>What makes this difficult is that, in order to keep clock speed high, there’s
no opportunity to re-add the immediate constant <code class="highlighter-rouge">I</code> to <code class="highlighter-rouge">Rb</code>–that would take an
extra clock tick.  Dealing with this requires some careful pipeline stall
logic, and getting this logic right has been
tricky.  By allowing the formal engine to pick an arbitrary pipeline state
and then examine an arbitrary instruction going into the
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a>,
I can guarantee that the <code class="highlighter-rouge">Ra</code> and <code class="highlighter-rouge">Rb+I</code> operands are valid no matter
which instruction precedes them.</p>

<p>Searching through all of the possibilities of these free variables
can be expensive.  Indeed, this was the phase that was taking many hours
of processing as I was working on verifying
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">this core</a>
module within the
<a href="/about/zipcpu.html">ZipCPU</a>.  Now, using this method of
invariants, the entire formal verification of the (still not quite complete
properties of the)
<a href="/about/zipcpu.html">ZipCPU</a>
takes less than two hours.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Invariants are only one method of handling formal complexity when aggregating
multiple modules together.  As I mentioned in the opening, I am by no means
an expert in
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>,
and so this is only my first application of
the principle of invariants to any project–in this case the
<a href="/about/zipcpu.html">ZipCPU</a>.
However, even in the case of the
<a href="/about/zipcpu.html">ZipCPU</a>,
the value of using invariants has saved many, many
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
CPU cycles.</p>

<p>We’ll have to return to this topic later in order to handle the concept of
abstraction in
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>.
Abstraction may be an even more powerful concept than invariants.
As you may remember from above, I’ve been using abstracted components to
represent the
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_prefetch.v">prefetch</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_mpy.v">multiply</a>,
and
<a href="https://github.com/ZipCPU/zipcpu/blob/dev/bench/formal/abs_div.v">divide</a>
components.  As another illustration, consider this: when
<a href="/blog/2017/10/19/formal-intro.html">formally verifying</a>
any container of the
<a href="/about/zipcpu.html">ZipCPU</a>,
whether the
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipsystem.v">ZipSystem</a>,
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/zipbones.v">ZipBones</a>,
or some yet to be determined container, I’m anticipating being able to
replace the entire complicated
<a href="/about/zipcpu.html">ZipCPU</a>
core with an abstracted version of it, and then to be able to prove
the formal properties of the wrapper in question.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And that ye study to be quiet, and to do your own business, and to work with your own hands, as we commanded you (1Thes 4:11)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
