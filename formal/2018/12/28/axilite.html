<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Using a formal property file to verify an AXI-lite peripheral</title>
  <meta name="description" content="Fig 1. A MicroZed Board">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2018/12/28/axilite.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Using a formal property file to verify an AXI-lite peripheral</h1>
    <p class="post-meta"><time datetime="2018-12-28T00:00:00-05:00" itemprop="datePublished">Dec 28, 2018</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. A <a href="http://zedboard.org/product/microzed">MicroZed Board</a></caption><tr><td><a href="http://zedboard.org/product/microzed"><img src="/img/microzed.png" alt="" width="319" /></a></td></tr></table>

<p>The <a href="/doc/axi-spec.pdf">AXI bus</a> has become prominent as a
defacto standard for working with either
<a href="https://www.xilinx.com">Xilinx</a> or
<a href="https://www.intel.com/content/www/us/en/fpga/devices.html">Intel</a> supplied <a href="https://en.wikipedia.org/wiki/Semiconductor_intellectual_property_core">IP
cores</a>.
This common standard is intended to make it easy to interface a design to one
of a variety of System on a Chip cores,
such as Xilinx’s MicroBlaze or <a href="https://www.altera.com/literature/hb/nios2/n2cpu_nii5v1.pdf">Intel’s
NiosII</a>.
The bus is also used by <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a>,
and so it is a natural fit for both
<a href="https://www.xilinx.com/products/silicon-devices/soc/zynq-7000.html">Zynq</a>
and <a href="https://www.intel.com/content/www/us/en/products/programmable/soc.html">Soc+FPGA</a>
products.</p>

<p>While this is all well and good,
<a href="/doc/axi-spec.pdf">AXI</a> is a beast to work with.
Achieving both correct performance, as well as high speed performance, can
be a challenge.  Today, we’ll limit ourselves to the
<a href="/doc/axi-spec.pdf">AXI-lite bus</a>: a version of
<a href="/doc/axi-spec.pdf">AXI</a> that
supports neither bursts, nor locking, nor transaction ID’s, nor varying
quality of service guarantees.
While I’d like to imagine that these simplifications have made it easy enough
for a beginner to be able to work with it, I would have to imagine that
most beginners who have tried to work with the
<a href="/doc/axi-spec.pdf">AXI-lite protocol</a>
used by either the
<a href="https://www.xilinx.com/products/silicon-devices/soc/zynq-7000.html">Zynq</a>
or <a href="https://www.intel.com/content/www/us/en/products/programmable/soc.html">Soc+FPGA</a>
chips haven’t found it to be the simple protocol they were hoping for.</p>

<p>It has certainly been anything but simple for me.</p>

<p>Today, let’s take a look at how you can use a set of formal properties to
work with an <a href="/doc/axi-spec.pdf">AXI-lite</a> slave–both to
verify that it works as well as to query how well it works.  Along the way,
I’ll demonstrate how easy it us to use this set of formal properties
to find the problems in an <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">AXI-lite slave
implementation</a>.</p>

<h2 id="the-axi-lite-bus">The AXI-lite Bus</h2>

<p>Some time ago, I wrote <a href="/zipcpu/2017/05/29/simple-wishbone.html">an article describing how to build a simple
wishbone peripheral</a>.<a href="/zipcpu/2017/05/29/simple-wishbone.html">A simple wishbone
peripheral</a>
only needed to respond to a request,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">((</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_we</span><span class="p">))</span>
	<span class="n">some_data</span><span class="p">[</span><span class="n">i_wb_addr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_wb_data</span><span class="p">;</span></code></pre></figure>

<p>an acknowledgment,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_wb_stb</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_wb_stall</span><span class="p">);</span></code></pre></figure>

<p>some returned data,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="n">o_wb_data</span> <span class="o">&lt;=</span> <span class="n">some_data</span><span class="p">[</span><span class="n">i_wb_addr</span><span class="p">];</span></code></pre></figure>

<p>and a (never) stall signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Voila!  That’s all the signaling required for a <a href="/zipcpu/2017/05/29/simple-wishbone.html">basic Wishbone
peripheral</a>.</p>

<p>If only <a href="/doc/axi-spec.pdf">AXI</a> were as easy.</p>

<table align="center" style="float: right"><caption>Fig 2. The AXI bus is composed of five separate channels</caption><tr><td><img src="/img/bus-axi-channels.svg" alt="" width="360" /></td></tr></table>

<p>Instead of one read-write request channel, and one acknowledgment-response
channel, <a href="/doc/axi-spec.pdf">AXI</a> has five such channels.  For writing values to the bus, there’s
the write address channel, the write data channel, and the write response
channel.  For reading values from the bus, there’s a read address-request
channel and a read response channel.</p>

<p>For today, let’s just discuss the AXI-lite version of this interface.  Unlike
the <a href="/doc/axi-spec.pdf">full AXI specification</a>,
<a href="/doc/axi-spec.pdf">AXI-lite</a> removes a lot of capability from this
interaction.  Perhaps the biggest differences are that, with
<a href="/doc/axi-spec.pdf">AXI-lite</a>, any
read and write request can only reference one piece of data at a time,
and that there is no need to provide unique identifiers for each transaction.
There are other more minor differences as well.
<a href="/doc/axi-spec.pdf">AXI-lite</a>
has no requirement to
implement locking, quality of service, or any cache protocols.
Once these differences are accounted for,
<a href="/doc/axi-spec.pdf">AXI-lite</a>
becomes almost as <a href="/zipcpu/2017/11/07/wb-formal.html">easy to verify as a Wishbone (WB)
transaction</a>.</p>

<p>Don’t get me wrong, building an
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">AXI-lite peripheral</a> is still a challenge,
but verifying an
<a href="/doc/axi-spec.pdf">AXI-lite</a>
peripheral?  Not so much.</p>

<p>The key to these transactions are the various <code class="language-plaintext highlighter-rouge">*READY</code> and <code class="language-plaintext highlighter-rouge">*VALID</code> signals.
<code class="language-plaintext highlighter-rouge">*VALID</code> is used to signal a <em>valid</em> request or acknowledgment.  The two
signals together form a
<a href="/blog/2017/08/14/strategies-for-pipelining.html">handshake</a>.
One side of the channel will set a
<em>valid</em> signal when it has information to send, whether request or
acknowledgment, while the other side controls a <em>ready</em> signal.  You
may recognize this from our prior discussion of the <a href="/blog/2017/08/14/strategies-for-pipelining.html">simple handshake method
of pipeline control</a>.
The <a href="/doc/axi-spec.pdf">AXI specification</a>
also contains a very specific requirement: asserting the
<em>valid</em> signal can never be dependent upon the <em>ready</em> signal for the same
channel.</p>

<p>Perhaps you may remember with the
<a href="/doc/wbspec_b4.pdf">WB specification</a>
that it takes a hand shake to make a bus request.  Both <code class="language-plaintext highlighter-rouge">STB</code>
(from the master) and <code class="language-plaintext highlighter-rouge">!STALL</code> (from the slave) must be true in order for a
request to be accepted.  The same is basically true of 
<a href="/doc/axi-spec.pdf">AXI</a> only the names have changed:
<code class="language-plaintext highlighter-rouge">*VALID</code> and <code class="language-plaintext highlighter-rouge">*READY</code> must be true for a bus request to be accepted by the
slave.  This <code class="language-plaintext highlighter-rouge">*VALID</code> signal is similar to the
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>
<code class="language-plaintext highlighter-rouge">STB</code> signal, while <code class="language-plaintext highlighter-rouge">*READY</code> is similar to the <code class="language-plaintext highlighter-rouge">!STALL</code> signal.</p>

<p>However, unlike
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>,
<a href="/doc/axi-spec.pdf">AXI</a>
has separate channels for reading and writing, and each of these channels
has its own <code class="language-plaintext highlighter-rouge">VALID</code> and <code class="language-plaintext highlighter-rouge">READY</code> signal set.
<a href="/doc/axi-spec.pdf">AXI</a> also requires a <code class="language-plaintext highlighter-rouge">VALID</code> and <code class="language-plaintext highlighter-rouge">READY</code>
<a href="/blog/2017/08/14/strategies-for-pipelining.html">handshake</a>
on acknowledgments, both for read and separately for write acknowledgments.</p>

<h4 id="axi-lite-read">AXI-lite Read</h4>

<p>Perhaps it might make sense to walk through an example or two.  Fig. 2
therefore shows several example
<a href="/doc/axi-spec.pdf">AXI-lite</a>
read transactions from the perspective of
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the slave</a>.
In this example, I’ve chosen to use <a href="https://www.xilinx.com">Xilinx</a>’s
convention where the
<a href="/doc/axi-spec.pdf">AXI</a>
signals are in all capitals, although this loses the <code class="language-plaintext highlighter-rouge">i_*</code> and <code class="language-plaintext highlighter-rouge">o_*</code> prefix
that I enjoy using to indicate which signals are inputs and which are outputs.
(We’ll switch back later, when we get to the
formal property set.)</p>

<table align="center" style="float: none"><caption>Fig 2. Several AXI-lite read transactions</caption><tr><td><img src="/img/xilinx-axil/axil-xilinx-read.svg" alt="" width="780" /></td></tr></table>

<p>Each request starts with the
<a href="/doc/axi-spec.pdf">AXI-lite</a>
master raising the <code class="language-plaintext highlighter-rouge">S_AXI_ARVALID</code> signal,
signaling that it wants to initiate a read transaction.  Together with the
<code class="language-plaintext highlighter-rouge">S_AXI_ARVALID</code> signal, the master will also place the address of the desired
read on the bus.</p>

<p><a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">The slave</a>
will respond to this request by raising the <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> signal,
although
<a href="/doc/axi-spec.pdf">the specification</a>
sets forth several comments about this.  For example, the slave can
set <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> before or in response to the
<code class="language-plaintext highlighter-rouge">S_AXI_ARVALID</code> signal.  Further, all the
<a href="/doc/axi-spec.pdf">AXI</a>
outputs are not allowed to be dependent combinatorially on the inputs,
but must instead be registered.
Beyond that, the slave can stall the bus as required by the implementation.</p>

<p>A read transaction request takes place when both
<code class="language-plaintext highlighter-rouge">S_AXI_ARVALID</code> and <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> are true on the same clock.</p>

<p>Looking back at Fig 2, you can see four such read transaction requests being
made.</p>

<p>As with the transaction requests, the acknowledgments also only take place when
<code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> and <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code>, the signals from the acknowledgment channel,
are both true.  Because responses must be registered, the earliest the slave
can acknowledge a signal is on the clock following the request.</p>

<p>Let’s now turn our attention to the acknowledgments shown in Fig 2.  In
this example,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the slave</a>
acknowledge the request on the clock after the request is made.  Since
the master holds <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> high, the acknowledgment only needs to be high
for one transaction.  Further, in addition to <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the slave</a>
will also set <code class="language-plaintext highlighter-rouge">S_AXI_RDATA</code>, the result of the read, and <code class="language-plaintext highlighter-rouge">S_AXI_RRESP</code>, an
indicator of any potential error conditions.  As with the <code class="language-plaintext highlighter-rouge">S_AXI_ARADDR</code>
signal above, these two signals are part of the acknowledgment transaction
as well.</p>

<p>The more interesting transaction may be the high speed transaction shown
at the end of the trace in Fig 2.  Judging from this transaction, if the
master wishes to transmit at its fastest speed, <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">this particular
core</a>
will only ever support a rate of one request every other clock.</p>

<p>Working from
<a href="/doc/axi-spec.pdf">the spec</a>,
just a couple of <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal verification
properties</a>
will help keep us from running into problems.  From what we’ve learned
examining the figures above, the following basic properties would seem prudent.</p>

<ol>
  <li>
    <p>Once <code class="language-plaintext highlighter-rouge">S_AXI_ARVALID</code> is raised, it must remain high until
<code class="language-plaintext highlighter-rouge">S_AXI_ARVALID &amp;&amp; S_AXI_ARREADY</code></p>
  </li>
  <li>
    <p>While <code class="language-plaintext highlighter-rouge">S_AXI_ARVALID</code> is true but the slave hasn’t yet raised
<code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code>, <code class="language-plaintext highlighter-rouge">S_AXI_ARADDR</code> must remain constant.</p>
  </li>
  <li>
    <p>Similarly, once the <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> reply acknowledgment request is raised,
it must also remain high until <code class="language-plaintext highlighter-rouge">S_AXI_RVALID &amp;&amp; S_AXI_RREADY</code> are both true.</p>
  </li>
  <li>
    <p>As with the read address channel, while <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> is true and the
master has yet to raise <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code>, both
<code class="language-plaintext highlighter-rouge">S_AXI_RDATA</code> and <code class="language-plaintext highlighter-rouge">S_AXI_RRESP</code> must remain constant.</p>
  </li>
  <li>
    <p>For every request with <code class="language-plaintext highlighter-rouge">S_AXI_ARVALID &amp;&amp; S_AXI_ARREADY</code>, there must follow
one clock period sometime later where <code class="language-plaintext highlighter-rouge">S_AXI_RVALID &amp;&amp; S_AXI_RREADY</code>.</p>

    <p>Unlike <a href="/zipcpu/2017/11/07/wb-formal.html">our development of the WB
properties</a>, there is
no bus abort capability in the <a href="/doc/axi-spec.pdf">AXI bus
protocol</a>.  As a result, following
a <a href="https://en.wikipedia.org/wiki/Bus_error">bus error</a>,
you’ll still need to deal with any remaining acknowledgments.</p>
  </li>
  <li>
    <p>Just to keep things moving, we’ll also want to insist that after some
implementation defined minimum number of clock ticks waiting the slave
must raise <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code>.</p>
  </li>
  <li>
    <p>The same applies to the reverse link: the master should not be allowed to
hold <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> low indefinitely while <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> is high.</p>
  </li>
</ol>

<p>We’ll add a couple more
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">properties</a>
beyond these below, but for now these should suffice to capture most of what
<a href="/doc/axi-spec.pdf">AXI-lite</a>
requires.</p>

<p>That’s how reads work, so let’s now go on and examine the write path.</p>

<h4 id="axi-lite-write-example">AXI-lite Write Example</h4>

<p>While the <a href="/doc/axi-spec.pdf">AXI</a> read channel above may appear to be straightforward, the write
channel is anything but.  The write address channel is designed to allow a
single “burst” request to indicate a desire to write to multiple addresses,
closely followed by a burst of data on the write data channel.
<a href="/doc/axi-spec.pdf">AXI-lite</a>,
unlike the
<a href="/doc/axi-spec.pdf">full AXI protocol</a>,
has no burst write support.  Every
address request must be accompanied by a single piece of associated write data.
To make matters worse, the two channels are only loosely synchronized, forcing
the slave to synchronize to them internally.</p>

<p>Were <code class="language-plaintext highlighter-rouge">S_AXI_AWVALID</code> tied to <code class="language-plaintext highlighter-rouge">S_AXI_WVALID</code>, and <code class="language-plaintext highlighter-rouge">S_AXI_AWREADY</code> tied to
<code class="language-plaintext highlighter-rouge">S_AXI_WREADY</code>, the slave’s write channel logic would collapse into the basic
read problem discussed above.  Alas, this is not so.  The
<a href="/doc/axi-spec.pdf">AXI-lite</a>
slave is thus forced to try to synchronize these two channels in order to
make sense of the transaction.</p>

<p>Fig. 3 shows a basic set of write transactions illustrating this problem.</p>

<table align="center" style="float: none"><caption>Fig 3. Some example write transactions</caption><tr><td><img src="/img/xilinx-axil/axil-xilinx-write.svg" alt="" width="780" /></td></tr></table>

<p>The first three transactions within Fig. 3 shows the bounds set on the
synchronization of the channels.  Note that I found these bounds within
Xilinx’s documentation.  They are not present in
<a href="/doc/axi-spec.pdf">the specification itself</a>,
as far as I can tell.  Since they simplify the problem
significantly, I’ve chosen to <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">implement them as part of this property
set</a>.</p>

<p>Let’s look at and discuss each of the transactions shown in Fig. 3 above.</p>

<ol>
  <li>
    <p>The first transaction is as simple as one might like.  Both write address
and write data requests show up at the same time.  On the following clock
the respective <code class="language-plaintext highlighter-rouge">*WREADY</code> signals are set, and then the acknowledgment
takes place on the third clock where <code class="language-plaintext highlighter-rouge">*BVALID</code> is set.</p>

    <p>Let’s note two things about this picture.  First, the <code class="language-plaintext highlighter-rouge">*WREADY</code> signals
are kept low until the request is made.  This is not required of the bus
and in general slows the bus down.  Second, the <code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code> signal is
held high.  The <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">particular core we are demonstrating</a>
will fail if this is not the case.  We’ll come back to that in a moment.</p>
  </li>
  <li>
    <p>The second transaction illustrates one of the bounds on the write channels:
Xilinx’s rules allow the write address valid signal to show up no more than
two clocks before the write data.  In this example, the slave holds the two
<code class="language-plaintext highlighter-rouge">*WREADY</code> lines low until the clock after both are valid.</p>
  </li>
  <li>
    <p>The third transaction illustrates the other bound: the write data channel
may arrive up to one clock before the write address channel.  As with the
previous example, this slave holds the various <code class="language-plaintext highlighter-rouge">*WREADY</code> lines low until
both are present.  The acknowledgment then takes place on the next clock.</p>
  </li>
  <li>
    <p>The final three transactions are part of a speed test measuring how fast
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">this core</a>
can handle subsequent transactions.  In the case of
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">this slave</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the slave</a>
waits until both <code class="language-plaintext highlighter-rouge">S_AXI_AWVALID</code> and <code class="language-plaintext highlighter-rouge">S_AXI_WVALID</code> signals are high
before raising the ready signal.  This wait period limits the
speed of
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">this slave core</a>
to one transaction every two clocks.</p>

    <p>If the Lord wills, I’d like to also present <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">another AXI-slave
core</a> with
much better throughput performance, but that will need to remain for another
day.</p>
  </li>
</ol>

<p><a href="/doc/axi-spec.pdf">This protocol</a> suggests a <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">couple formal
properties</a>.</p>

<ol>
  <li>
    <p>Each of the <code class="language-plaintext highlighter-rouge">*VALID</code> signals should remain high until their respective
<code class="language-plaintext highlighter-rouge">*READY</code> signal is also high.  This applies to both the write address
channel, the write data channel, as well as the acknowledgment channel.</p>
  </li>
  <li>
    <p>The data associated with each channel should be constant from when the
<code class="language-plaintext highlighter-rouge">*VALID</code> signal is set until both <code class="language-plaintext highlighter-rouge">*VALID</code> and <code class="language-plaintext highlighter-rouge">*READY</code> are set together.</p>
  </li>
  <li>
    <p>We also discussed the two Xilinx imposed limits above as well.</p>

    <p>– The write data channel may become active no more than one clock before
   the write address channel, and</p>

    <p>– The write address channel may become active no more than two clocks before
   the write data channel.</p>
  </li>
  <li>
    <p>Finally, there should be no more than one acknowledgment per write
request.  Well, it’s a bit more complex than that.  Both write address
and write data channels will need to be checked, so that there is never
any write acknowledgment until a request has previously been received
on both of those two channels.</p>
  </li>
</ol>

<h2 id="using-a-formal-property-set">Using a Formal Property Set</h2>

<p>Further on in this article, we’ll dive into the weeds of <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">how to express the
formal properties necessary to specify an AXI-lite bus
interaction</a>.  For now,
I’d like to discuss what you can do with such a
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal property set</a>.</p>

<p>I currently have Vivado 2016.3 installed on my computer.  Is it out of date?
Yes.  However, it works for me.  Xilinx has had problems breaking things when
they make updates, so I hesitate to update Vivado lest I break something that
is already working.</p>

<p>That said, <a href="https://www.xilinx.com/video/hardware/creating-an-axi-peripheral-in-vivado.html">this
video</a>
from Xilinx describes how to create an
<a href="/doc/axi-spec.pdf">AXI-lite</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">peripheral core</a>.
I followed similar instructions, and received a
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">default demonstration AXI-lite peripheral</a>.</p>

<p>I then added a
<a href="/blog/2017/10/19/formal-intro.html">formal property section</a>
to the bottom of this core.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//</span>
<span class="c1">// Formal Verification section begins here.</span>
<span class="c1">//</span>
<span class="c1">// The following code was not part of the original Xilinx demo.</span>
<span class="c1">//</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="cp">`ifdef</span>	<span class="n">FORMAL</span></code></pre></figure>

<p>The important part of this property section is the reference to our
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal AXI-lite property
file</a>.
Since the properties require some counters in order to make certain that
exactly one response is given to every transaction, let’s set a width for
those counters and declare them here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">F_LGDEPTH</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="kt">wire</span>	<span class="p">[(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_axi_awr_outstanding</span><span class="p">,</span>
					<span class="n">f_axi_wr_outstanding</span><span class="p">,</span>
					<span class="n">f_axi_rd_outstanding</span><span class="p">;</span></code></pre></figure>

<p>For <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">this particular design</a>,
a four bit counter is really overkill, but it will work for us.</p>

<p>Then, we connect the various signals associated with the
<a href="/doc/axi-spec.pdf">AXI-lite protocol</a>
to
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">our core</a>.
The parameters have fairly well defined meanings.  The data width
is the number of data bits in the bus.  The address width is the number of
bits required to describe a single octet in the data stream.  This is different
from
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>,
which has only the number of bits necessary to describe a word address.
We’ll ignore the extra bits for now, since they are fairly irrelevant here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">//</span>
	<span class="c1">// Connect our slave to the AXI-lite property set</span>
	<span class="c1">//</span>
	<span class="n">faxil_slave</span> <span class="p">#(</span>  <span class="p">.</span><span class="n">C_AXI_DATA_WIDTH</span><span class="p">(</span><span class="n">C_S_AXI_DATA_WIDTH</span><span class="p">),</span>
			<span class="p">.</span><span class="n">C_AXI_ADDR_WIDTH</span><span class="p">(</span><span class="n">C_S_AXI_ADDR_WIDTH</span><span class="p">),</span>
			<span class="p">.</span><span class="n">F_LGDEPTH</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="p">))</span> <span class="n">properties</span><span class="p">(</span>
		<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_reset_n</span><span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_awaddr</span><span class="p">(</span><span class="n">S_AXI_AWADDR</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awcache</span><span class="p">(</span><span class="mh">4'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awprot</span><span class="p">(</span><span class="n">S_AXI_AWPROT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awvalid</span><span class="p">(</span><span class="n">S_AXI_AWVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_awready</span><span class="p">(</span><span class="n">S_AXI_AWREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_wdata</span><span class="p">(</span><span class="n">S_AXI_WDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wstrb</span><span class="p">(</span><span class="n">S_AXI_WSTRB</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wvalid</span><span class="p">(</span><span class="n">S_AXI_WVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_wready</span><span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_bresp</span><span class="p">(</span><span class="n">S_AXI_BRESP</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bvalid</span><span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_bready</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_araddr</span><span class="p">(</span><span class="n">S_AXI_ARADDR</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arprot</span><span class="p">(</span><span class="n">S_AXI_ARPROT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arcache</span><span class="p">(</span><span class="mh">4'h0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arvalid</span><span class="p">(</span><span class="n">S_AXI_ARVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_arready</span><span class="p">(</span><span class="n">S_AXI_ARREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_rdata</span><span class="p">(</span><span class="n">S_AXI_RDATA</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rresp</span><span class="p">(</span><span class="n">S_AXI_RRESP</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rvalid</span><span class="p">(</span><span class="n">S_AXI_RVALID</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_rready</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">f_axi_rd_outstanding</span><span class="p">(</span><span class="n">f_axi_rd_outstanding</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_axi_wr_outstanding</span><span class="p">(</span><span class="n">f_axi_wr_outstanding</span><span class="p">),</span>
		<span class="p">.</span><span class="n">f_axi_awr_outstanding</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span><span class="p">));</span></code></pre></figure>

<p>If we wanted to stop here and only run a bounded model check, we could do
that.  However, with just a couple of more
<a href="/blog/2017/10/19/formal-intro.html">properties</a>
we can make certain <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">this
design</a>
will pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
as well–or not, as we’ll see in a moment.</p>

<p>For example, a short examination of the internals of <a href="https://github.com/ZipCPU/wb2axip/blob/c9821fe23abf19a077afe56a9ad61942ab599c/bench/formal/xlnxdemo.v">this
core</a>
will reveal that it can only ever respond to a single transaction
request at a time.  See for example the logic for
<a href="https://github.com/ZipCPU/wb2axip/blob/c9821fe23abf19a077afe56a9ad61942ab599c/bench/formal/xlnxdemo.v#L159-L180"><code class="language-plaintext highlighter-rouge">axi_awready</code></a>,
and <a href="https://github.com/ZipCPU/wb2axip/blob/c9821fe23abf19a077afe56a9ad61942ab599c/bench/formal/xlnxdemo.v#L207-L229"><code class="language-plaintext highlighter-rouge">axi_wready</code></a> for writes,
and similarly the logic for <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v#L583-L604"><code class="language-plaintext highlighter-rouge">axi_arready</code></a> for reads.
Further, once that transaction request has been made, but before the
acknowledgment has been accepted, the appropriate acknowledgment valid flag
will be high, whether <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v#L549-L574"><code class="language-plaintext highlighter-rouge">bvalid</code></a> or
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v#L614-L635"><code class="language-plaintext highlighter-rouge">rvalid</code></a>.
Not only that, but when
the acknowledgment valid flag is high is the only time we’ll have one pending
transaction.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_rd_outstanding</span> <span class="o">==</span> <span class="p">((</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_wr_outstanding</span> <span class="o">==</span> <span class="p">((</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>Likewise,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">this core</a>
does not allow the number of outstanding requests on the write address channel
to differ at all from those on the write data channel.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span> <span class="o">==</span> <span class="n">f_axi_wr_outstanding</span><span class="p">);</span></code></pre></figure>

<p>Then, we create a very simple <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.sby">SymbiYosys
script</a>:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[tasks]
cvr
prf

[options]
cvr: mode cover
cvr: depth 60
prf: mode prove
prf: depth 40

[engines]
smtbmc

[script]
read -formal xlnxdemo.v
read -formal faxil_slave.v
prep -top xlnxdemo

[files]
xlnxdemo.v
faxil_slave.v</code></pre></figure>

<p><a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.sby">This script</a>
describes
<a href="/zipcpu/2018/12/20/sby-makefile.html">two tasks</a>.  One task,
named <code class="language-plaintext highlighter-rouge">cvr</code>, will check the cover properties in this core.  Since we haven’t
introduced any yet, we’ll come back to this task in a moment.  The second
task, <code class="language-plaintext highlighter-rouge">prf</code>, will attempt to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">this core</a>
meets <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">all of the
properties</a>
required of any
<a href="/doc/axi-spec.pdf">AXI-lite protocol</a>
core–basically all of the properties mentioned above.</p>

<p>Now, when we run
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
to check the safety properties (i.e. the assertions),</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">% sby -f xlnxdemo.sby prf</code></pre></figure>

<p>The proof fails almost immediately.</p>

<p>This first problem comes from the fact that none of the various signal
registers are given appropriate initial values.  While I personally consider
this to be a bug, many individuals will consider this irrelevant in a
<a href="https://en.wikipedia.org/wiki/Semiconductor_intellectual_property_core">core</a>
that depends upon a reset like this one does.  Therefore, let’s just quietly
fix <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the
core</a>
with some initial statements and go on.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// The following lines are only questionable a bug</span>
	<span class="k">initial</span>	<span class="n">axi_arready</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">axi_awready</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">axi_wready</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">axi_bvalid</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">axi_rvalid</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>And again the design fails.  This time it fails with the trace shown in Fig.
4 to the right.</p>

<table align="center" style="float: right"><caption>Fig. 4.  Xilinx's demonstration code drops a write acknowledgment</caption><tr><td><img src="/img/xilinx-axil/axil-xilinx-write-fail.svg" alt="" width="360" /></td></tr></table>

<p>In this image, you can see two write transactions.  I’ve colored them with
two different colors, to help separate the two and make this example easier
to follow.  The image differs, however,
from our previous write example in Fig 3 above simply because the
<code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code> signal is not held high.  As a result, the <code class="language-plaintext highlighter-rouge">S_AXI_BVALID</code>
transaction is not immediately acknowledged until <code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code> has been
valid for a whole clock.  By that time, however, the logic within <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the
core</a>
has lost the reality that there is a second transaction that needs to be
acknowledged as well.  Hence, once <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the
core</a>
drops the <code class="language-plaintext highlighter-rouge">S_AXI_BVALID</code> line, a transaction has been lost.</p>

<p>If we want to move on and look for other problems, we could bandage over this
bug with an assumption.  While you’d never want to do this in production
code, sometimes it is helpful to move on in order to find some other problem.
In this case, a simple assumption causes this error to go away.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">);</span></code></pre></figure>

<p>However, when we run the tools again the design still fails.  Looking at the
trace reveals that it is failing for the same basic bug again, only now the
problem is found within the read channel, as shown in Fig 5.</p>

<table align="center" style="float: right"><caption>Fig. 5.  Xilinx's demonstration code drops a read acknowledgment</caption><tr><td><img src="/img/xilinx-axil/axil-xilinx-read-fail.svg" alt="" width="360" /></td></tr></table>

<p>If we assume that <code class="language-plaintext highlighter-rouge">S_AXI_RREADY</code> is always high, just like we did with
<code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code>, this failure also vanishes and now <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the
core</a>
can be
<a href="/blog/2017/10/19/formal-intro.html">verified for all time</a>
using
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<p>With a little looking, and a quick trace capability, it
doesn’t take long to chase down the bug.  You can see the problem below
as it exists for the <code class="language-plaintext highlighter-rouge">S_AXI_ARREADY</code> signal.  Basically, the core allowed
this signal to go high before it knew that the <code class="language-plaintext highlighter-rouge">S_AXI_RVALID</code> signal would
be acknowledged.</p>

<p>If you page through the code, you’ll find the always block, shown below,
that sets the <code class="language-plaintext highlighter-rouge">axi_arready</code> signal.  It starts with a basic, almost
boilerplate, reset function to clear <code class="language-plaintext highlighter-rouge">axi_arready</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span> <span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span> <span class="p">)</span>
	<span class="k">begin</span>
	  <span class="k">if</span> <span class="p">(</span> <span class="n">S_AXI_ARESETN</span> <span class="o">==</span> <span class="mb">1'b0</span> <span class="p">)</span>
	    <span class="k">begin</span>
	      <span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	      <span class="n">axi_araddr</span>  <span class="o">&lt;=</span> <span class="mb">7'b0</span><span class="p">;</span>
	    <span class="k">end</span>
	  <span class="k">else</span>
	    <span class="k">begin</span></code></pre></figure>

<p>Early on in the operation, though, we find the bug.  In particular,
<code class="language-plaintext highlighter-rouge">axi_arready</code> is set irrespective of whether the result channel is stalled
and there’s no place to hold the result.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	      <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">axi_arready</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARVALID</span><span class="p">)</span>
	        <span class="k">begin</span>
	          <span class="c1">// indicates that the slave has acceped the valid read address</span>
	          <span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	          <span class="c1">// Read address latching</span>
	          <span class="n">axi_araddr</span>  <span class="o">&lt;=</span> <span class="n">S_AXI_ARADDR</span><span class="p">;</span>
	        <span class="k">end</span>
	      <span class="k">else</span>
	        <span class="k">begin</span>
	          <span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	        <span class="k">end</span>
	    <span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>Just a touch of extra logic will fix this for us.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">axi_arready</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">))</span>
	        <span class="k">begin</span>
	          <span class="c1">// indicates that the slave has acceped the valid read address</span>
	          <span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	          <span class="c1">// Read address latching</span>
	          <span class="n">axi_araddr</span>  <span class="o">&lt;=</span> <span class="n">S_AXI_ARADDR</span><span class="p">;</span>
	        <span class="k">end</span>
	      <span class="k">else</span>
	        <span class="k">begin</span>
	          <span class="n">axi_arready</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	        <span class="k">end</span>
	    <span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>A similar fix to the write channel and the design should pass nicely.</p>

<h3 id="cover">Cover</h3>

<p>The check above encourages us that this design will not violate any of our
safety properties, but will it work?  Or, rather, how well can it be made
to work?  To answer that question, let’s create a <code class="language-plaintext highlighter-rouge">cover()</code> property.</p>

<p>Cover properties are known as <em>liveness</em> properties, versus the assertion
properties which are known as <em>safety</em> properties.  When a <em>safety</em> property
fails, a trace is created showing how the property may be made to fail.
However, when a <em>safety</em> property succeeds you know the <code class="language-plaintext highlighter-rouge">assert()</code> will always
be valid and so no trace is created.  Cover properties are the opposite.  A
cover property succeeds if there is at least one way to make the statement
true.  In that case, a trace is generated.  More generally, one trace is
generated for <em>every</em> <code class="language-plaintext highlighter-rouge">cover()</code> statement within a design, or the <code class="language-plaintext highlighter-rouge">cover()</code>
check will fail.</p>

<p>Within the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal property
set</a>,
there are two cover properties just to make certain the design is able to
function.  These properties verify that both a read and write operation are
able to succeed using the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">core</a>.</p>

<p>What I want to do now is to check performance, and we can use a cover
property for that purpose.</p>

<p>Let’s see if we can retire four write instructions in four clocks.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span> <span class="p">((</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span><span class="mi">3</span><span class="p">)));</span></code></pre></figure>

<p>Let’s also test whether we can retire four read requests in four clocks
as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span> <span class="p">((</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span><span class="mi">3</span><span class="p">)));</span></code></pre></figure>

<p>These two tests would be easier to express with concurrent assertions,
such as:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Writes</span>
	<span class="k">cover</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">)</span> <span class="p">[</span><span class="o">*</span><span class="mi">4</span><span class="p">]);</span>

	<span class="c1">// Reads</span>
	<span class="k">cover</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="p">(</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">)</span> <span class="p">[</span><span class="o">*</span><span class="mi">4</span><span class="p">]);</span></code></pre></figure>

<p>Wow, those are nice to work with!</p>

<p>I personally like the four clock test, because sometimes there is a single
stage within the design somewhere that can queue up an answer and so succeed
on a two clock test.  A four clock test on a design this simple will only
succeed if the core can truly retire one instruction on every clock.</p>

<p>Not surprisingly, this test fails.  <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">This particular
core</a>
is <em>unable</em> to handle a one transaction per clock throughput.</p>

<p>If high speed were your goal, then, you would say the core is <em>crippled</em>.
(Yes, I have an <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">alternative
core</a>
if you want something that uses
<a href="/doc/axi-spec.pdf">AXI-lite</a>
and yet has better performance.)</p>

<p>We could adjust the two tests and make them check for one instruction retiring
on every other clock.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// First a write check</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span> <span class="p">((</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_BVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_BREADY</span><span class="p">),</span><span class="mi">6</span><span class="p">)));</span>

	<span class="c1">// Now a read check</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span> <span class="p">((</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span><span class="mi">4</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">((</span><span class="n">S_AXI_RVALID</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">S_AXI_RREADY</span><span class="p">),</span><span class="mi">6</span><span class="p">)));</span></code></pre></figure>

<p>This test now succeeds.</p>

<p>If you choose to examine <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">the formal properties within the
core</a>,
you’ll notice there is also a very large set of code at the bottom to
set up two rather complicated cover traces.  We’ve already reviewed the
results of those complex cover statements in Figs. 2 and 3 above.</p>

<h3 id="exhaustive-coverage-exponential-complexity">Exhaustive Coverage, Exponential Complexity</h3>

<p>The first lesson of
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
is that it is <em>exhaustive</em>.  Every possible input, output, and register
combination are checked to determine whether a property holds or not.  As
you might imagine, this creates an exponential
explosion in complexity that can be hard to manage.  This can often discourage
a learner from trying
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>
in the first place.</p>

<p>To put that whole argument into perspective, know this: I have a series of
not one or two but twelve separate
<a href="/doc/axi-spec.pdf">AXI-lite</a>
proofs in my <a href="https://github.com/ZipCPU/wb2axip">Wishbone to AXI
bridge(s) repository</a>.  It takes me less
than two minutes to
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
<em>all</em> of these
<a href="https://en.wikipedia.org/wiki/Semiconductor_intellectual_property_core">cores</a>.</p>

<p>Finally, consider what we’ve done: for the price of a small insertion of
code into our design, referencing a
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">pre-written property set</a>,
and for the cost of only a handful of other core-specific properties,
we’ve managed to find, fix, and then
<a href="/blog/2017/10/19/formal-intro.html">formally verify</a>
an
<a href="/doc/axi-spec.pdf">AXI-lite</a>
core.  After you’ve done this once or twice, you’ll find that the whole
verification process takes only minutes to set up, and less than that
to get your first trace.
This makes it very easy for me, when I want to reply to someone’s request for
help on either
<a href="https://forums.xilinx.com">Xilinx</a>’s or
<a href="https://forum.digilentinc.com">Digilent’s forum</a>s, to quickly review their
code and provide a comment on it.</p>

<p>Fixing the code?  Well, that can take more time.</p>

<p>So just what does <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">this property
set</a>
look like?</p>

<h2 id="axi-lite-properties">AXI-lite Properties</h2>

<p>We’ve already discussed most of the properties above, all that remains
now is to lay out the details and write the immediate assertions to accomplish
these tasks.  The basic properties were:</p>

<ol>
  <li>
    <p>Requests must wait to be accepted</p>
  </li>
  <li>
    <p>Acknowledgments can only follow requests</p>
  </li>
  <li>
    <p>All responses must return in a known number of cycles</p>
  </li>
  <li>
    <p>Waiting requests should not be held waiting more than some maximum delay</p>
  </li>
</ol>

<p>The first step in writing
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">this property set</a>
will be to create several configuration parameters that can be used to
configure <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">the properties</a>
to match the needs of our design.  Shown below is the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">AXI-lite slave property set</a>,
and the various configuration parameters within it.</p>

<p>The first configuration parameter is the width of the bus.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">faxil_slave</span> <span class="p">#(</span>
	<span class="c1">// The width of the data bus</span>
	<span class="k">parameter</span> <span class="n">C_AXI_DATA_WIDTH</span>	<span class="o">=</span> <span class="mi">32</span><span class="p">,</span><span class="c1">// Fixed, width of the AXI R&amp;W data</span></code></pre></figure>

<p>While most of my work is done with a 32-bit bus, the property set should
be generic enough to allow bus widths of other sizes, such as 8, 16, 64, or
128 bits.  Why might you want 128 bits?  Because
<a href="https://github.com/ZipCPU/videozip">many designs</a>
including
<a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR SDRAM</a>’s
can transfer 128-bits or more per clock.</p>

<p>Following the number of data bits, <code class="language-plaintext highlighter-rouge">C_AXI_ADDR_WIDTH</code> controls the number
of bits used to describe an address within the peripheral.  This needs to be
a sufficient number of bits necessary to access every octet within the address
space of the slave, even though we are going to ignore the sub-word address
bits for now.  (There’s only one requirement of them, associated with the
<code class="language-plaintext highlighter-rouge">S_AXI_WSTRB</code> signal, and I haven’t coded that up yet.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>  <span class="n">C_AXI_ADDR_WIDTH</span>	<span class="o">=</span> <span class="mi">28</span><span class="p">,</span><span class="c1">// AXI Address width (log wordsize)</span></code></pre></figure>

<p>Further, since I find <code class="language-plaintext highlighter-rouge">C_AXI_DATA_WIDTH</code> and <code class="language-plaintext highlighter-rouge">C_AXI_ADDR_WIDTH</code> rather
cumbersome to type, I’m going to create two short-cut names: DW for the
data bus width, and AW for the address width.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="n">DW</span>			<span class="o">=</span> <span class="n">C_AXI_DATA_WIDTH</span><span class="p">,</span>
	<span class="k">localparam</span> <span class="n">AW</span>			<span class="o">=</span> <span class="n">C_AXI_ADDR_WIDTH</span><span class="p">,</span></code></pre></figure>

<p>Some implementations add
<a href="/doc/axi-spec.pdf">AXI</a>
cache flags to the address request.
These flags indicate whether the transaction is to be bufferable,
non-bufferable, cachable, non-cachable, or more.  I’m not personally using
these flags.  However, to handle both cores with and without these bits,
we’ll use the parameter <code class="language-plaintext highlighter-rouge">F_OPT_HAS_CACHE</code>.  If <code class="language-plaintext highlighter-rouge">F_OPT_HAS_CACHE</code> is set,
the slave will assume particular values for <code class="language-plaintext highlighter-rouge">i_axi_awcache</code>
and <code class="language-plaintext highlighter-rouge">i_axi_arcache</code>, indicating
that the write is to be done to the cache or through the cache.  This is
probably more important for an
<a href="/doc/axi-spec.pdf">AXI</a>
master than the slave, but since the two are mirrors of each other, we’ll
keep it in here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_OPT_HAS_CACHE</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">,</span></code></pre></figure>

<p>Sometimes I need to verify a write-only
<a href="/doc/axi-spec.pdf">AXI interface</a>, such as in <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilwr2wbsp.v">this AXI-lite
write-channel to wishbone
bridge</a>.  In
that case, I’ll want to assume the read channel is idle and remove the read
channel cover check.  <code class="language-plaintext highlighter-rouge">F_OPT_NO_READS</code> can be set to make this happen.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_OPT_NO_READS</span>  <span class="o">=</span> <span class="mb">1'b0</span><span class="p">,</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">F_OPT_NO_WRITES</code> is the analog to <code class="language-plaintext highlighter-rouge">F_OPT_NO_READS</code>.  If
<code class="language-plaintext highlighter-rouge">F_OPT_NO_WRITES</code> is set, then the proof will assume the write channel
is idle, and remove the write channel cover check.  This is used by my
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilrd2wbsp.v">AXI-lite read-channel to wishbone
bridge core</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_OPT_NO_WRITES</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">,</span></code></pre></figure>

<p><a href="/doc/axi-spec.pdf">AXI</a>
defines three separate possible responses: an OK response,
a slave produced an error response, or an interconnect produced
an error response.  If a particular slave cannot produce any
form of
<a href="https://en.wikipedia.org/wiki/Bus_error">bus error</a>,
it makes sense to disallow it.  Clearing
<code class="language-plaintext highlighter-rouge">F_OPT_BRESP</code> to zero will disallow any form of
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> on the write channel.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_OPT_BRESP</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">,</span>
	<span class="c1">//</span>
	<span class="c1">//  The same is true for F_OPT_RRESP for the read channel</span>
	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_OPT_RRESP</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">,</span></code></pre></figure>

<p><a href="https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf">Xilinx’s AXI reference
guide</a>
requires a rather lengthy reset of 16 clock periods.  If the slave
(or master) being verified isn’t creating that reset, then it makes sense
to just assume the reset is present.  The <code class="language-plaintext highlighter-rouge">F_OPT_ASSUME_RESET</code> configures
the core to do just that.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_OPT_ASSUME_RESET</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">,</span></code></pre></figure>

<p>In order to insure that there is only one acknowledgment for every
request received, we’ll need to count requests and acknowledgments
and compare our signals to these counters.  <code class="language-plaintext highlighter-rouge">F_LGDEPTH</code> specifies
the number of bits to be used for those counters.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>				<span class="n">F_LGDEPTH</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">,</span></code></pre></figure>

<p>We’re going to insist that no transaction remains stalled for more
than some maximum number of clock cycles, <code class="language-plaintext highlighter-rouge">F_AXI_MAXWAIT</code>.  This also
keeps the design and traces moving during our proof.  While the constraint
placed upon the design as a result is somewhat artificial, you can adjust
it to match what you would expect within your design environment.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="p">[(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_AXI_MAXWAIT</span>  <span class="o">=</span> <span class="mi">12</span><span class="p">,</span></code></pre></figure>

<p>Our last parameter, <code class="language-plaintext highlighter-rouge">F_AXI_MAXDELAY</code>, is used to make certain that,
following a request, the result will be returned to the
<a href="/doc/axi-spec.pdf">AXI bus</a>
master within a given number of clock cycles.  The number of cycles to wait
is very implementation dependent, so it needs to be a configuration parameter.
We set it here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="p">[(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_AXI_MAXDELAY</span> <span class="o">=</span> <span class="mi">12</span>
	<span class="p">)</span> <span class="p">(</span></code></pre></figure>

<p>In many ways, <code class="language-plaintext highlighter-rouge">F_AXI_MAXDELAY=12</code> is overkill for the demonstration designs
in the <a href="https://github.com/ZipCPU/wb2axip">wishbone to AXI bridge repository</a>
we are taking our examples from.
However, <a href="/blog/2018/08/16/spiflash.html">other designs</a>
have needed delays of <code class="language-plaintext highlighter-rouge">65</code> clocks or more, so this is an appropriate
configuration parameter.</p>

<p>Let me add one other note on these two clock durations: the shorter
<code class="language-plaintext highlighter-rouge">F_AXI_MAXWAIT</code> and <code class="language-plaintext highlighter-rouge">F_AXI_MAXDELAY</code> are, the faster your proof will complete.</p>

<p>Let’s now move on from the parameters within the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal property
file</a>
to the inputs and outputs of the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">module</a>
itself.  Since this <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal property
set</a>
is my own code rather than Xilinx’s,
I’m also going to switch notations to one I am familiar with.  Inputs
to any core in my notation start with <code class="language-plaintext highlighter-rouge">i_</code>, outputs begin with an <code class="language-plaintext highlighter-rouge">o_</code>.
Further, only constant values such as parameter or macros will use all
capitals.  Finally, since the core we will be writing is a <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">formal property
set</a>,
all of the interface wires will be inputs.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_clk</span><span class="p">,</span>	<span class="c1">// System clock</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_reset_n</span><span class="p">,</span>

<span class="c1">// AXI write address channel signals</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_awready</span><span class="p">,</span><span class="c1">//Slave is ready to accept</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_axi_awaddr</span><span class="p">,</span>	<span class="c1">// Write address</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_axi_awcache</span><span class="p">,</span>	<span class="c1">// Write Cache type</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_axi_awprot</span><span class="p">,</span>	<span class="c1">// Write Protection type</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_awvalid</span><span class="p">,</span>	<span class="c1">// Write address valid</span>

<span class="c1">// AXI write data channel signals</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_wready</span><span class="p">,</span>  <span class="c1">// Write data ready</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">DW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_axi_wdata</span><span class="p">,</span>	<span class="c1">// Write data</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_axi_wstrb</span><span class="p">,</span>	<span class="c1">// Write strobes</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_wvalid</span><span class="p">,</span>	<span class="c1">// Write valid</span>

<span class="c1">// AXI write response channel signals</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_axi_bresp</span><span class="p">,</span>	<span class="c1">// Write response</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_bvalid</span><span class="p">,</span>  <span class="c1">// Write reponse valid</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_bready</span><span class="p">,</span>  <span class="c1">// Response ready</span>

<span class="c1">// AXI read address channel signals</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_arready</span><span class="p">,</span>	<span class="c1">// Read address ready</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_axi_araddr</span><span class="p">,</span>	<span class="c1">// Read address</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_axi_arcache</span><span class="p">,</span>	<span class="c1">// Read Cache type</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_axi_arprot</span><span class="p">,</span>	<span class="c1">// Read Protection type</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_arvalid</span><span class="p">,</span>	<span class="c1">// Read address valid</span>

<span class="c1">// AXI read data channel signals</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_axi_rresp</span><span class="p">,</span>   <span class="c1">// Read response</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_rvalid</span><span class="p">,</span>  <span class="c1">// Read reponse valid</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">DW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_axi_rdata</span><span class="p">,</span>   <span class="c1">// Read data</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_axi_rready</span><span class="p">,</span>  <span class="c1">// Read Response ready</span></code></pre></figure>

<p>Well, almost.  We’re also going to create
three outputs, as shown below, so that assertions may be
connected to our various counters to constrain them to the implementation
using them.  Such constraints are <a href="/blog/2018/03/10/induction-exercise.html">necessary in order to pass induction, as
we’ve discussed before</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">//</span>
	<span class="kt">output</span>	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_axi_rd_outstanding</span><span class="p">,</span>
	<span class="kt">output</span>	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_axi_wr_outstanding</span><span class="p">,</span>
	<span class="kt">output</span>	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_axi_awr_outstanding</span>
<span class="p">);</span></code></pre></figure>

<p>Since checking for transactions can be somewhat tedious below, I’ll declare
some simple transaction abbreviations here.  These are basically abbreviations
for when both <code class="language-plaintext highlighter-rouge">*VALID</code> and <code class="language-plaintext highlighter-rouge">*READY</code> are true indicating that either a
transaction or or an acknowledgment
<a href="/blog/2017/08/14/strategies-for-pipelining.html">handshake</a>
completes.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// wire	w_fifo_full;</span>
	<span class="kt">wire</span>	<span class="n">axi_rd_ack</span><span class="p">,</span> <span class="n">axi_wr_ack</span><span class="p">,</span> <span class="n">axi_ard_req</span><span class="p">,</span> <span class="n">axi_awr_req</span><span class="p">,</span> <span class="n">axi_wr_req</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="k">assign</span>	<span class="n">axi_ard_req</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_axi_arvalid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_axi_arready</span><span class="p">);</span>
	<span class="k">assign</span>	<span class="n">axi_awr_req</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_axi_awvalid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_axi_awready</span><span class="p">);</span>
	<span class="k">assign</span>	<span class="n">axi_wr_req</span>  <span class="o">=</span> <span class="p">(</span><span class="n">i_axi_wvalid</span> <span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_axi_wready</span><span class="p">);</span>
	<span class="c1">//</span>
	<span class="k">assign</span>	<span class="n">axi_rd_ack</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_axi_rvalid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_axi_rready</span><span class="p">);</span>
	<span class="k">assign</span>	<span class="n">axi_wr_ack</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_axi_bvalid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_axi_bready</span><span class="p">);</span></code></pre></figure>

<p>I’m also trying something new with this property set.  Since bus slave
properties are very similar to those for the master, save only that the
assumptions and assertions are swapped, I’m going to create two macros:
<code class="language-plaintext highlighter-rouge">SLAVE_ASSUME</code> and <code class="language-plaintext highlighter-rouge">SLAVE_ASSERT</code>.  These are defined from the perspective of
the slave to be <code class="language-plaintext highlighter-rouge">assume</code> and <code class="language-plaintext highlighter-rouge">assert</code> respectively.  Within the master,
these definitions will naturally swap.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`define</span>	<span class="n">SLAVE_ASSUME</span>	<span class="k">assume</span>
<span class="cp">`define</span>	SLAVE_ASSERT	assert</code></pre></figure>

<p>Using a macro like this makes it easier to run
<a href="http://meldmerge.org">meld</a>
on both
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">slave</a>
and
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_master.v">master</a>
property files when making updates.  This way the actual logic differences
stand out more.  Interested in seeing how well this works?  Just install
<a href="http://meldmerge.org">meld</a>, download the
<a href="https://github.com/ZipCPU/wb2axip">wb2axip</a> repository, then <code class="language-plaintext highlighter-rouge">cd</code> into
the <a href="https://github.com/ZipCPU/wb2axip/tree/bench/formal">bench/formal</a>
directory and run</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">% meld faxil_slave.v faxil_master.v</code></pre></figure>

<p>to see how easy it is to spot differences between the two cores.</p>

<h4 id="reset-properties">Reset Properties</h4>

<p>I’ve struggled a bit with the <a href="https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf">reset properties for
AXI</a>.
Specifically, what
<a href="https://en.wikipedia.org/wiki/Semiconductor_intellectual_property_core">core</a>
is it that actually creates the reset that needs to be verified here?
That core should have the
<a href="/blog/2017/10/19/formal-intro.html">assertions</a>
applied to it.  However, the reset is often defined by some other module
within the design.  Hence, we’ll either
assert or assume the reset is initially set based instead on the
<code class="language-plaintext highlighter-rouge">F_OPT_ASSUME_RESET</code> parameter from above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_OPT_ASSUME_RESET</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">ASSUME_INIITAL_RESET</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span>
			<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">ASSERT_INIITAL_RESET</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p><a href="https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf">Xilinx requires that the AXI reset be asserted for a minimum of 16 clock
cycles</a>.
Our first step is to count the number of cycles the reset signal is active.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_reset_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_axi_reset_n</span><span class="p">)</span>
		<span class="c1">// If ever the reset is released, "reset" the reset-length</span>
		<span class="c1">// counter back to zero.</span>
		<span class="c1">//</span>
		<span class="n">f_reset_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f_reset_length</span><span class="p">))</span>
		<span class="c1">// Otherwise, just quietly increment the counter until we get</span>
		<span class="c1">// to 15</span>
		<span class="n">f_reset_length</span> <span class="o">&lt;=</span> <span class="n">f_reset_length</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>We can then make (assumptions) or assertions about the reset signal to make
certain it is held long enough.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_OPT_ASSUME_RESET</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">ASSUME_RESET</span>
		<span class="c1">// ...</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">ASSERT_RESET</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_reset_n</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f_reset_length</span><span class="p">)))</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">);</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_reset_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_reset_length</span> <span class="o">&lt;</span> <span class="mh">4'hf</span><span class="p">))</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">);</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Finally, now that we know our design meets its reset requirements, we can
create some properties regarding what must happen as a result of a reset.
Specifically, we’ll require that following any reset, the various <code class="language-plaintext highlighter-rouge">*VALID</code>
flags should be set to zero.</p>

<p>We’re also going to apply this to the very first clock cycle of the design, by
also checking for <code class="language-plaintext highlighter-rouge">!f_past_valid</code> and by applying these properties through
<code class="language-plaintext highlighter-rouge">initial</code> statements.  As you may recall, this was the issue
the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">Xilinx core</a>
had above with its (missing) initial statements.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Nothing should be returned or requested on the first clock</span>
	<span class="k">initial</span>	<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_arvalid</span><span class="p">);</span>
	<span class="k">initial</span>	<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_awvalid</span><span class="p">);</span>
	<span class="k">initial</span>	<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_wvalid</span><span class="p">);</span>
	<span class="c1">//</span>
	<span class="k">initial</span>	<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_bvalid</span><span class="p">);</span>
	<span class="k">initial</span>	<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_rvalid</span><span class="p">);</span>

	<span class="c1">// Same thing, but following any reset as well</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_reset_n</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_arvalid</span><span class="p">);</span>
		<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_awvalid</span><span class="p">);</span>
		<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_wvalid</span><span class="p">);</span>
		<span class="c1">//</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_bvalid</span><span class="p">);</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_rvalid</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Moving on to the response signals, <code class="language-plaintext highlighter-rouge">S_AXI_BRESP</code> for the write channel and
<code class="language-plaintext highlighter-rouge">S_AXI_RRESP</code> for the read channel, we’ll note that the <code class="language-plaintext highlighter-rouge">2'b01</code> pattern is
the only pattern disallowed by the <a href="/doc/axi-spec.pdf">AXI
specification</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_axi_bvalid</span><span class="p">)</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">i_axi_bresp</span> <span class="o">!=</span> <span class="mb">2'b01</span><span class="p">);</span> <span class="c1">// Exclusive access not allowed</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_axi_rvalid</span><span class="p">)</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">i_axi_rresp</span> <span class="o">!=</span> <span class="mb">2'b01</span><span class="p">);</span> <span class="c1">// Exclusive access not allowed</span></code></pre></figure>

<h4 id="stability-properties">Stability Properties</h4>

<p>The rule we discussed above was that the signals that are coupled with
any transaction should be held constant as long as the transaction remains
outstanding (i.e. valid but not ready).  This is a basic
<a href="/blog/2017/08/14/strategies-for-pipelining.html">handshake</a>
that we also required when building our
<a href="/zipcpu/2017/11/07/wb-formal.html">WB</a>
properties.  Let’s capture that
<a href="/blog/2017/08/14/strategies-for-pipelining.html">handshake</a>
property here in this context.</p>

<p>Simply put using concurrent assertions, we could express this as:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="cp">`SLAVE_ASSUME</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="kt">disable</span> <span class="k">iff</span> <span class="p">(</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">)</span>
		<span class="p">(</span><span class="n">i_axi_awvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_awready</span><span class="p">)</span>
		<span class="o">|=&gt;</span> <span class="n">i_axi_awvalid</span> <span class="o">&amp;&amp;</span> <span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_axi_awaddr</span><span class="p">)));</span>

	<span class="cp">`SLAVE_ASSUME</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="kt">disable</span> <span class="k">iff</span> <span class="p">(</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">)</span>
		<span class="p">(</span><span class="n">i_axi_wvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_wready</span><span class="p">)</span>
		<span class="o">|=&gt;</span> <span class="n">i_axi_wvalid</span> <span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_axi_wdata</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_axi_wstrb</span><span class="p">)</span> <span class="p">);</span>

	<span class="cp">`SLAVE_ASSERT</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="kt">disable</span> <span class="k">iff</span> <span class="p">(</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">)</span>
		<span class="p">(</span><span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_bready</span><span class="p">)</span>
		<span class="o">|=&gt;</span> <span class="n">i_axi_bvalid</span> <span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_axi_bresp</span><span class="p">));</span>

	<span class="c1">// ...</span></code></pre></figure>

<p>Alternately, in order to use the immediate assertions supported by the free
version of <a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>, we’ll
need to put a little more work into this.
First, we want to avoid the first clock period and any clock period following
a reset.  This is to make sure our properties deal with valid data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_reset_n</span><span class="p">)))</span>
	<span class="k">begin</span></code></pre></figure>

<p>Now, for each channel, we’ll write out the properties in question.  Basically
if the <code class="language-plaintext highlighter-rouge">*VALID</code> was true on the previous cycle but the <code class="language-plaintext highlighter-rouge">*READY</code> was false,
then the <code class="language-plaintext highlighter-rouge">*VALID</code> should remain true and the associated data should be stable.</p>

<p>For the write address channel, the first of five, this property looks like
the following.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Write address channel</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_awvalid</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_awready</span><span class="p">)))</span>
		<span class="k">begin</span>
			<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="n">i_axi_awvalid</span><span class="p">);</span>
			<span class="cp">`SLAVE_ASSUME</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">i_axi_awaddr</span><span class="p">));</span>
		<span class="k">end</span>

		<span class="c1">// Apply to all other incoming channels</span>
	<span class="k">end</span></code></pre></figure>

<p>The other channel properties are nearly identical, so we’ll skip them for
brevity here.  The important part to remember is that we will <em>assume</em>
properties of the input, and <em>assert</em> properties of our local state and any
outputs.  Hence, in this case we’ll assume the properties of the write address
channel, the write data channel, and the read address channel, but <em>assert</em>
properties of the two acknowledgment channels.</p>

<h4 id="maximum-delay">Maximum Delay</h4>

<p>We said above that no channel should remain stalled for more than a finite
number of clock cycles.  Such a stall would be defined as <code class="language-plaintext highlighter-rouge">*VALID &amp;&amp; !*READY</code>.
Let’s check that property for each channel here, but only if we were given
an <code class="language-plaintext highlighter-rouge">F_AXI_MAXWAIT</code> value greater than zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_AXI_MAXWAIT</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">CHECK_STALL_COUNT</span>
		<span class="c1">//</span>
		<span class="c1">//</span>
		<span class="kt">reg</span>	<span class="p">[(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_axi_awstall</span><span class="p">,</span>
						<span class="n">f_axi_wstall</span><span class="p">,</span>
						<span class="n">f_axi_arstall</span><span class="p">,</span>
						<span class="n">f_axi_bstall</span><span class="p">,</span>
						<span class="n">f_axi_rstall</span><span class="p">;</span></code></pre></figure>

<p>To create a check constraining how many clock cycles a design may be allowed
to stall a channel, we’re going to have to first count the number of stalls.</p>

<p>I’ll show the write address channel stall count here, and skip the others
for brevity again.</p>

<p>I should also mention, it took me several rounds to get this count just right.
So, here’s the basic logic:</p>

<ol>
  <li>Anytime we either reset the core, or anytime there’s no pending write
request, or the write address request is accepted, the write address
bus isn’t stalled and we set the counter back to zero.  This much was
straightforward, and matches my first draft.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">f_axi_awstall</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_awvalid</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_axi_awready</span><span class="p">))</span>
			<span class="n">f_axi_awstall</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<ol start="2">
  <li>Likewise any time we are waiting for the other write channel, in this case
the write data channel, to request a transaction we also set the counter to
zero.  This allows the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">Xilinx AXI-lite demo
code</a> to stall
the bus as long as it wants while waiting for the other channel to
synchronize.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">f_axi_awr_outstanding</span> <span class="o">&gt;=</span> <span class="n">f_axi_wr_outstanding</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_axi_awvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_wvalid</span><span class="p">))</span>
			<span class="c1">// If we are waiting for the write channel to be valid</span>
			<span class="c1">// then don't count stalls</span>
			<span class="n">f_axi_awstall</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<ol start="3">
  <li>Here’s the part that caught me by surprise though: we only want to accumulate
stalls on this request channel if the back end isn’t stalled.  Hence if
there’s no waiting acknowledgment, or likewise if the acknowledgment that
is waiting has just been accepted, then and only then do we count a stall
against the write address channel for not being ready.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">i_axi_bvalid</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_axi_bready</span><span class="p">))</span>
			<span class="n">f_axi_awstall</span> <span class="o">&lt;=</span> <span class="n">f_axi_awstall</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<ol start="4">
  <li>Finally, <em>assert</em> that the number of stalls is within our limit.</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">f_axi_awstall</span> <span class="o">&lt;</span> <span class="n">F_AXI_MAXWAIT</span><span class="p">);</span>

		<span class="c1">// The other channel stall counts are very similar</span></code></pre></figure>

<p>Why would we <em>assert</em> this?  Because the stall signal, <code class="language-plaintext highlighter-rouge">S_AXI_AWREADY</code>, is
an output of the slave core, and we always place assertions on outputs and
assumptions on inputs.</p>

<p>Hence, if you look down through the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">property
file</a>
a bit further, you’ll see an assumption made for the read acknowledgment
channel.  Why is this an assumption?  Because it is dependent upon the
<code class="language-plaintext highlighter-rouge">S_AXI_BREADY</code> <em>input</em> to the core.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="n">f_axi_rstall</span> <span class="o">&lt;</span> <span class="n">F_AXI_MAXWAIT</span><span class="p">);</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Of course, all of these assumptions will swap with their assertion counterparts
when we go to the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_master.v">AXI-lite master property
set</a>.</p>

<h4 id="xilinx-constraints">Xilinx Constraints</h4>

<p>Remember the two Xilinx constraints?  The additional rules to make things work?
Here they are written out.</p>

<ol>
  <li>
    <p>The address line will never be more than two clocks ahead of
 the write data channel, and</p>
  </li>
  <li>
    <p>The write data channel will never be more than one clock
ahead of the address channel.</p>
  </li>
</ol>

<p>I found these rules in a DDR3 IP core module usage guide, though I can’t seem
to find that guide right now.  However, since they’ve helped make
the various proofs complete, I’ve chosen to include these rules here.</p>

<p>Let’s express these as
<a href="/blog/2017/10/19/formal-intro.html">formal properties</a>.
First, if there was a write address request two clocks ago, and no
intervening write data request, then we want to assume a write data request now.</p>

<p>Ok, not quite, that’s missing a key detail: it is possible that the write
address request of two clocks ago <em>followed</em> a write data request.  That means
we’ll also have to check that the number of write data and write
address requests were equal two clocks ago, or there had been more write
address requests.</p>

<p>This is another one of those properties where a concurrent assertion would
make the most sense,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="cp">`SLAVE_ASSUME</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="kt">disable</span> <span class="k">iff</span> <span class="p">(</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">)</span>
		<span class="p">(</span><span class="n">i_axi_awvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_wvalid</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span><span class="o">&gt;=</span><span class="n">f_axi_wr_outstanding</span><span class="p">)</span>
		<span class="p">##</span><span class="mi">1</span> <span class="p">(</span><span class="o">!</span><span class="n">i_axi_wvalid</span><span class="p">)</span>
		<span class="o">|=&gt;</span> <span class="n">i_axi_wvalid</span><span class="p">);</span></code></pre></figure>

<p>We could also express this same property as an immediate assertion.  It’s
uglier and harder to read, but it still works well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_axi_reset_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_reset_n</span><span class="p">))</span>
		<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_awvalid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">i_axi_wvalid</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span><span class="o">&gt;=</span><span class="n">f_axi_wr_outstanding</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_wvalid</span><span class="p">)))</span>
		<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="n">i_axi_wvalid</span><span class="p">);</span></code></pre></figure>

<p>The second rule is simpler since it only covers two clock periods instead of
three.  It’s the same basic thing, just with the channels reversed and one less
clock period.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_axi_reset_n</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_awvalid</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_axi_wvalid</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span> <span class="o">&lt;</span> <span class="n">f_axi_wr_outstanding</span><span class="p">))</span>
		<span class="cp">`SLAVE_ASSUME</span><span class="p">(</span><span class="n">i_axi_awvalid</span><span class="p">);</span></code></pre></figure>

<p>Together these two properties will keep the two channels roughly synchronized
with one another.  Making the actual synchronization work within the peripheral
code will still remain a challenge.</p>

<h4 id="compare-the-number-of-acknowledgments-to-requests">Compare the number of acknowledgments to requests</h4>

<p>The next rule we want to check is that for every acknowledgment,
there must have been one and only one request.</p>

<p>No matter how we do this, we’ll need to start by counting the number of
outstanding requests.  This count goes as follows: following any reset,
the number of outstanding requests must be zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_axi_awr_outstanding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">)</span>
		<span class="n">f_axi_awr_outstanding</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Likewise anytime we have accepted a request, or had an acknowledgment
on the return channel accepted, but not both, the count will adjust.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span> <span class="p">(</span><span class="n">axi_awr_req</span><span class="p">),</span> <span class="p">(</span><span class="n">axi_wr_ack</span><span class="p">)</span> <span class="o">}</span><span class="p">)</span>
		<span class="mb">2'b10</span><span class="o">:</span> <span class="n">f_axi_awr_outstanding</span> <span class="o">&lt;=</span> <span class="n">f_axi_awr_outstanding</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="mb">2'b01</span><span class="o">:</span> <span class="n">f_axi_awr_outstanding</span> <span class="o">&lt;=</span> <span class="n">f_axi_awr_outstanding</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>Please notice that I didn’t use a pair of <code class="language-plaintext highlighter-rouge">if</code> statements here, such as
if there’s been a write address channel request then increment the counter,
else if there’s been a write response then decrement the counter.  I’ve tried
that approach several times in the past, but I always seem to get burned
by it.  Why?  Because of the cases the <code class="language-plaintext highlighter-rouge">if</code> statements don’t cover, usually
the case where there’s both a request and an acknowledgment on the same clock
cycle.</p>

<p>Two other counters, <code class="language-plaintext highlighter-rouge">f_axi_wr_outstanding</code> based upon the write data channel
and <code class="language-plaintext highlighter-rouge">f_axi_rd_outstanding</code> based upon the read channel, are defined similarly.</p>

<p>We can now start creating some properties using these count values.  First,
we want to make certain our counters never overflow.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">f_axi_wr_outstanding</span>  <span class="o">&lt;</span> <span class="o">{</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">);</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span> <span class="o">&lt;</span> <span class="o">{</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">);</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">f_axi_rd_outstanding</span>  <span class="o">&lt;</span> <span class="o">{</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">);</span></code></pre></figure>

<p>Second, in order to guarantee that the counters never overflow, we’ll
need to insist that the channel stops making a request one clock earlier.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_axi_awr_outstanding</span> <span class="o">==</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">,</span> <span class="mb">1'b0</span><span class="o">}</span> <span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_awvalid</span><span class="p">);</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_axi_wr_outstanding</span> <span class="o">==</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">,</span> <span class="mb">1'b0</span><span class="o">}</span> <span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_wvalid</span><span class="p">);</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_axi_rd_outstanding</span> <span class="o">==</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">,</span> <span class="mb">1'b0</span><span class="o">}</span> <span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">i_axi_arvalid</span><span class="p">);</span></code></pre></figure>

<p>You might notice that these are all a series of assertions–for both
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_master.v">master</a>
and
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">slave</a>.
They are not <code class="language-plaintext highlighter-rouge">SLAVE_ASSERT()</code>ions, but rather regular assertions.
This somewhat violates our
rule, that we only make assertions of local state and outputs.  However,
if an assumption is required to keep this number lower, that assumption
should really exist within the implementation defined code.  Hence we’ll just
use regular assertions here.</p>

<p>Finally, to make certain that acknowledgments do follow requests, we can make
a couple of assertions.  The three counters above make these assertions
really easy.</p>

<p>First, on any write acknowledgment, there must be at least one outstanding
write address request that needs to be acknowledged.  Likewise, there also
needs to be one write data request that needs to be acknowledged.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_axi_bvalid</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">f_axi_awr_outstanding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">f_axi_wr_outstanding</span>  <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Notice here that I’m applying the test every time <code class="language-plaintext highlighter-rouge">i_axi_bvalid</code> is true,
not every time <code class="language-plaintext highlighter-rouge">axi_wr_ack</code>, <code class="language-plaintext highlighter-rouge">axi_awr_ack</code>, nor every time
<code class="language-plaintext highlighter-rouge">S_AXI_BVALID &amp;&amp; S_AXI_BREADY</code>.  In other words, before even attempting
an acknowledgment, the respective counter should be greater than one.</p>

<p>A second thing to notice is that I’m not excepting the case where a request
is being made on the same cycle.  Such an acknowledgment, dependent only on
a combinatorial expression of the inputs, is specifically disallowed by the
<a href="https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf">AXI specification</a>.</p>

<p>The assertion for the read channel is nearly identical to those for the write
channel above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_axi_rvalid</span><span class="p">)</span>
		<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">f_axi_rd_outstanding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>This guarantees we’ll never respond to the bus unless a prior request has
been made.</p>

<p>We haven’t yet guaranteed that every request will get a response.  For that, we
need to count the number of clock cycles following a request to when a response
should taken place.</p>

<h4 id="maximum-response-delay-check">Maximum Response Delay Check</h4>

<p>The maximum response delay check is just that: checking that every request
gets a response within a maximum number of clock periods.  This number of clock
periods is captured by the configuration parameter <code class="language-plaintext highlighter-rouge">F_AXI_MAXDELAY</code>.  Setting
this parameter to zero will disable this check.</p>

<p>As with the other tests, we’ll start by counting how long a request remains
unacknowledged or outstanding.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_AXI_MAXDELAY</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">CHECK_MAX_DELAY</span>

		<span class="kt">reg</span>	<span class="p">[(</span><span class="n">F_LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_axi_wr_ack_delay</span><span class="p">,</span>
						<span class="n">f_axi_rd_ack_delay</span><span class="p">;</span></code></pre></figure>

<p>This count is very similar to the stall count above.  We’ll examine the
read portion below, although the write count portion is similar.  For a read,
we’ll only count up if the reset is inactive, no acknowledgment is pending,
and there exists an outstanding read that has not been acknowledged.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">f_axi_rd_ack_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">i_axi_reset_n</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_axi_rvalid</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">f_axi_rd_outstanding</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span>
			<span class="n">f_axi_rd_ack_delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">f_axi_rd_ack_delay</span> <span class="o">&lt;=</span> <span class="n">f_axi_rd_ack_delay</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>

		<span class="c1">// ...</span></code></pre></figure>

<p>We can then assert that the counter must remain less than the maximum
acknowledgment delay.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="cp">`SLAVE_ASSERT</span><span class="p">(</span><span class="n">f_axi_rd_ack_delay</span> <span class="o">&lt;</span> <span class="n">F_AXI_MAXDELAY</span><span class="p">);</span>

		<span class="c1">// ...</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>That’s the last of the safety properties necessary to determine that a core
abides by the rules of
<a href="/doc/axi-spec.pdf">AXI-lite</a>.</p>

<p>When I originally started working with <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>, I would
stop once I’d finished writing my assertions and assumptions.
I’ve since been burned multiply times by believing that a core worked when I’d
somehow missed something internally, or perhaps assumed one property too many.
For that reason, let’s add in some <code class="language-plaintext highlighter-rouge">cover()</code> properties.</p>

<h4 id="cover-properties">Cover Properties</h4>

<p>As a final property category, it’s important to have some assurance that a
given
<a href="/doc/axi-spec.pdf">AXI-lite</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">slave core</a>
can handle a write request,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">F_OPT_NO_WRITES</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">((</span><span class="n">i_axi_bvalid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_axi_bready</span><span class="p">));</span></code></pre></figure>

<p>and a read request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">F_OPT_NO_READS</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">((</span><span class="n">i_axi_rvalid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_axi_rready</span><span class="p">));</span>
<span class="k">endmodule</span></code></pre></figure>

<p>Now, upon any
<a href="https://symbiyosys.readthedocs.io/en/latest">SymbiYosys</a>
run in cover mode, the formal solver will find
some path from reset, through either read or write request, through whatever
operation the slave needs to do within its implementation, all the way to the
acknowledgment being accepted.  In many cases, this will also showcase the
logic within the slave, giving you a trace you can use when debugging so
that you can make sure you are implementing your logic properly.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I’d like to say that it only took me one weekend to build <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">these properties</a>.
That’s roughly true.  Interface property lists such as <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">this
one</a>
really aren’t that hard or difficult to build for a given application.  Even
better, the basic properties tend to remain the same from one application to
the next.  For example, we’re still using the same basic
<a href="/blog/2017/08/14/strategies-for-pipelining.html">handshake</a>
properties here that we used for the
<a href="/zipcpu/2017/11/07/wb-formal.html">WB bus</a>, only now we are
using different names for the signals.</p>

<p>However, it has taken some work on my part to build some example <a href="https://github.com/ZipCPU/wb2axip/tree/master/rtl">bus
bridges</a> and a <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">demonstration
AXI-lite slave core</a>
to give <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">this property
list</a>
some good exercise.  Further, I’ve been using
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">these properties</a>
to check the
functionality of other AXI-slaves that I’ve found on-line, so I have some
decent confidence that
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">these properties</a>
work.</p>

<p>As we’ve seen above, <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">these
properties</a>
can be used to diagnose and then fix any <a href="/doc/axi-spec.pdf">AXI-lite
core</a>, such as the <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">one produced
by Vivado that we discussed above</a>.</p>

<p>Even better, I’ve been able to use <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/faxil_slave.v">these
properties</a>
to create <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">a core</a>
that outperforms <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">Xilinx’s AXI-lite demonstration
core</a>.  <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">This
new example core</a>
can handle one read or write transaction request and thus acknowledgment
on every clock, and it can keep this speed up indefinitely.  Now, if only
the interconnect would maintain that speed, you’d have a peripheral that runs
a full twice as fast.</p>

<p>Just to give you a hint for what this core might do, here’s an example
write trace from this
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/demoaxi.v">new core</a>.</p>

<table align="center" style="float: none"><caption>Fig. 6.  Write demonstration through an improved AXI-lite core</caption><tr><td><img src="/img/xilinx-axil/axil-demo-write.svg" alt="" width="780" /></td></tr></table>

<table align="center" style="float: right"><caption>Fig. 7.  Read demonstration through the improved AXI-lite core</caption><tr><td><img src="/img/xilinx-axil/axil-demo-read.svg" alt="" width="480" /></td></tr></table>

<p>Here’s an example read trace in Fig. 7 on the right.</p>

<p>Want to know how to build an
<a href="/doc/axi-spec.pdf">AXI-lite</a>
<a href="https://en.wikipedia.org/wiki/Semiconductor_intellectual_property_core">core</a>
with this kind of throughput?  Check out the <a href="/blog/2017/08/14/strategies-for-pipelining.html">buffered handshake approach to
pipeline signaling</a>
and then stay tuned.  That will likely be my next post on the topic of
<a href="/doc/axi-spec.pdf">AXI-lite</a>.</p>

<p>But what about the
<a href="/doc/axi-spec.pdf">full AXI protocol</a>?  While I have a
full <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbm2axisp.v">Wishbone to full AXI bridge</a>,
I have yet to build a property file that would describe the 
<a href="/doc/axi-spec.pdf">full AXI protocol</a> properly.  Worse,
I’ve put a lot of time into trying to build such a file.
Too much time, in fact, so I really can’t afford to put much more time into it.</p>

<p>I’m sure I’ll get it soon enough, but given the amount of work it has taken
me so far, it’s not very likely to be an open source core in the near
future.</p>

<p><em>These bugs were <a href="https://forums.xilinx.com/t5/Simulation-and-Verification/Formally-verifying-the-functionality-of-an-AXI-lite-peripheral/m-p/924562">reported to Xilinx on 28 Dec, 2018</a>.  As of Jan, 2020, they have not yet been fixed.</em></p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And it came to pass, when the king had heard the words of the book of the law, that he rent his clothes. (2Kings 22:11)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
