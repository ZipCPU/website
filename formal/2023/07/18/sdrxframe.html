<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>SDIO RX: Bugs found w/ Formal methods</title>
  <meta name="description" content="This post is the second post regarding my new SDIO/eMMCcontroller.  The SDIO protocol is commonlyused on SD cards, and the eMMC protocol for eMMC chips.  The...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2023/07/18/sdrxframe.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">SDIO RX: Bugs found w/ Formal methods</h1>
    <p class="post-meta"><time datetime="2023-07-18T00:00:00-04:00" itemprop="datePublished">Jul 18, 2023</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>This post is the second post regarding my new <a href="https://github.com/ZipCPU/sdspi">SDIO/eMMC
controller</a>.  The SDIO protocol is commonly
used on SD cards, and the eMMC protocol for eMMC chips.  The two protocols
are so similar that, when using
<a href="https://github.com/ZipCPU/sdspi">this controller</a>, they will differ in
software only.  Today’s bottom line is that, although <a href="https://github.com/ZipCPU/sdspi">the
controller</a> is still quite new and only
barely silicon proven, this week I had the chance to formally verify the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receive portion</a>
of the controller and so I thought I might write about what took place.
My goal will be to answer the question of whether this extra step of doing
formal verification was worth it or not.</p>

<p><a href="https://github.com/ZipCPU/sdspi">This SDIO controller</a> is being written as
part of the <a href="https://github.com/ZipCPU/eth10g">Klusterlab project</a>.  I’ve been
calling <a href="https://github.com/ZipCPU/eth10g">this same project the ETH10G
project</a>, because at its core it is a <a href="https://github.com/ZipCPU/eth10g/blob/master/rtl/net/routecore.v">10Gb
Ethernet switch</a>.
The project team, however, has named it KlusterLab because of all of the
various hardware and IO interfaces that have been integrated into it.
This has given me plenty of opportunities for testing hardware components, and
for writing blog articles about them.  As a result, I’ve now written about the
development of this project a couple times.  First, I wrote about <a href="/blog/2023/04/08/vpktfifo.html">virtual
packet FIFOs</a>,
then about <a href="/blog/2023/06/28/sdiopkt.html">using Verilog tasks to script the SDIO
transmitter</a>, and now today
I want to discuss formally verifying the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">SDIO
receiver</a>
that will soon be tested on this board.  I’ll even go so far as to discuss
the remaining bugs that were found during hardware verification.</p>

<table align="center" style="float: right"><caption>Fig 1. SDIO progress</caption><tr><td><img src="/img/sdrxframe/progress.svg" width="320" /></td></tr></table>

<p>You might argue this <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">SDIO
receiver</a>
had already been verified.  Indeed, you might argue that the <a href="https://github.com/ZipCPU/sdspi">entire
controller</a> had been verified.  Let’s walk
through the various development steps.  At this point in its development, the
entire <a href="https://github.com/ZipCPU/sdspi">SDIO controller</a> has been written.  It
passes a <a href="/blog/2017/06/21/looking-at-verilator">Verilator</a>
lint check.  I’ve also generated simulation test scripts to verify the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v">divided clock
generator</a> and the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdtxframe.v">transmitter</a> in
isolation.  A final <a href="https://github.com/ZipCPU/sdspi/blob/master/bench/verilog/tb_sdio.v">simulation
environment</a>
drives the entire controller through its paces: starting up the
SDIO controller in a simulated environment all the way from sending the
CMD0 (GO IDLE) all the way through reading and writing a page of data
(CMD24 and CMD17).  It passes these simulation steps nicely.  I’ve integrated
the controller into the <a href="https://github.com/ZipCPU/eth10g">larger design</a>, and
it passes both Vivado synthesis and timing.  Indeed, it’s been implemented in
hardware.  Most recently, it failed in hardware testing for PCB reasons, not
logic reasons–but that still counts as a <em>failure</em> in hardware, so I’ve got
more work to do before I can call this silicon proven.  At the end of this
article, I’ll share the results of my next round silicon testing–once I
finished verifying the receiver.</p>

<p>The question before us today is whether or not I’ve skipped any necessary
tests.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 2. The rule of gold</caption><tr><td><img src="/img/vlog-wait/rule-of-gold.svg" width="320" /></td></tr></table>

<p>One might argue at this point that this is all the
<a href="https://github.com/ZipCPU/sdspi">controller</a> needs to do in practice, and so
I should stop here.  In the past, I might’ve done so.  However, the
<a href="https://github.com/ZipCPU/sdspi">controller</a> can do a lot more than I’ve
tested so far.  It’s designed to operate with either 1 data bit, 4 data bits
(SDIO/eMMC), or 8 data bits (eMMC only), in either SDR and DDR modes, and
both with (eMMC only) and without (SDIO/eMMC) a data strobe.  The <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v">clock
divider</a> is designed
to allow the IOs to be driven at less than one
edge per clock cycle, two edges per clock cycle, or even four edges per
clock cycle.  That’s a lot of features, and due to the way the current board
is designed, I won’t be able to test all of them.  (Specifically, the PCB
design connected the clock line to the CCLK pin, and it doesn’t allow a
card voltage change from 3.3V to 1.8V, so I can’t use either
<a href="/blog/2020/08/22/oddr.html">ODDR</a>
or OSERDES controllers to drive it any faster than than half the clock rate.)</p>

<p>Here’s my problem with stopping here: I want to place this <a href="https://github.com/ZipCPU/sdspi">SDIO/eMMC
controller</a>
in my “library” of working components, and I’ve had too many experiences in the
past of pulling something out of my library only to end up debugging it when
I place it onto hardware.  In practice, it’s worse than that–because by the
time I pull it out of my library, I typically won’t remember that I only tested
<em>some</em> of the modes the IP supports, or whether or not it’s been updated since
I last used it on hardware.  I just remember that it has “worked” in the past,
so I consider it a piece of “working” IP from my library.  What that means is
that, when things don’t work in hardware, I won’t be suspecting this piece of
IP.  Hence, I’ll find myself looking all over some large SOC design for a bug,
instrumenting everything and its brother, before I finally realize that a
“working” IP component from my library had been left with a bug in it.</p>

<p>This is unsatisfactory.</p>

<p>Debugging a large design is a painful process.  It takes a lot of time–often
time that’s been allocated for other purposes–you know, like the new
capabilities the design is supposed to have–capabilities the sponsor is paying
for.  It delays product delivery with unscheduled debugging.  Frankly, I don’t
like spending my time on unplanned projects like that.  As a result, I want a
solid assurance that every IP component in my “library” <em>works</em> before I add
it to a larger design.  It’s not enough that it worked in silicon the last
time it was used.  I want to know if any updates made since that time still
work.  I want to know to all the features work, to include features that
haven’t yet been tested in silicon.</p>

<p>This requires a more rigorous approach to IP verification than just
demonstrating the IP once in silicon.</p>

<p>For me, that more vigorous approach involves formally verifying each leaf
component, and then simulating the library component as a whole.  When it
comes to <a href="https://github.com/ZipCPU/sdspi">this SDIO/eMMC controller</a>,
I have formal proofs of <em>most</em> of the major components.  I have a proof of the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v">clock generator</a>,
the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v">Wishbone
controller</a>, the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v">command wire handler</a>
and the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdtxframe.v">transmitter</a>.
What I didn’t have, which we’ll be discussing today, is a formal proof of the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receiver</a>.</p>

<p>Yes, I now have a formal proof of the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">SDIO/eMMC
receiver</a>.</p>

<p>So, before we get started, let me ask: how many bugs do you think I found
going through this process?</p>

<h2 id="fitting-the-receiver-into-the-design">Fitting the Receiver into the Design</h2>

<p>Let me take a moment, though, to introduce you to <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">this
subcomponent</a> and
discuss how it is supposed to work, prior to discussing the problems it had.</p>

<table align="center" style="float: right"><caption>Fig 3. The SDIO/eMMC receive component</caption><tr><td><img src="/img/sdrxframe/pinlist.svg" width="400" /></td></tr></table>

<p>The <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">SDIO/eMMC receive
framer</a>, as I
call it, is responsible for receiving a block of data, checking the
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>(s), and writing
that block of data to an external <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics">ping-pong
buffer</a>.
A separate <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v">Wishbone
component</a>
acts as its controller in two ways.  First, it tells
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">the receiver</a>
what IO mode is in operation.  The <code class="language-plaintext highlighter-rouge">i_cfg_width</code> setting tells us if we are
using 1, 4 (SDIO/eMMC), or 8 (eMMC only) IO pins.  The <code class="language-plaintext highlighter-rouge">i_cfg_ddr</code> setting
controls whether or not we’ll need to check separate
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s
for each clock edge.  Similarly, if we are using the data strobe pin, as
indicated by <code class="language-plaintext highlighter-rouge">i_cfg_ds</code>, then we’ll be accepting data via the asynchronous
data port from the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a>,
rather than the simpler synchronous port.</p>

<p>When the user issues a CMD17 to read a block, the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v">Wishbone
controller</a> will
raise the <code class="language-plaintext highlighter-rouge">i_rx_en</code> line to indicate a block of data is on the way.  It
will also set <code class="language-plaintext highlighter-rouge">i_length</code> to the length of the block to be expected.  The
<code class="language-plaintext highlighter-rouge">i_crc_en</code> pin also allows us to receive things that may, or may not–counter
to protocol–have <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s
attached.  Since the protocol requires
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s,
I may remove this (unused) configuration bit in the future.</p>

<p>The <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">front end</a>
provides two sets of inputs for us, of which we will pick and
choose only one.  The first set is the <em>synchronous</em> path.  This is the path
used in all SDIO modes and most of the eMMC modes–the path that doesn’t
depend upon the data strobe return from the eMMC device.  The second path is
the <em>asynchronous</em> path from the front end.</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 4. The PHY supports three operating modes</caption><tr><td><img src="/img/sdrxframe/phymodes.svg" width="320" /></td></tr></table>

<p>Both of these paths come to us from a <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">front end
component</a> that
I’m going to call the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a>.  The
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a> can be
built in one of three ways, as shown in Fig. 4.  First, it can be built in
“standard” mode, where the IO buffers are driven directly from logic.  It can
also be built where the IO buffers are all driven via
<a href="/blog/2020/08/22/oddr.html">ODDR</a> components, and the
returns come back via IDDR sampling.  Finally, there’s a front end mode which
will drive the IOs via 8:1 OSERDES elements, and read the results back via
a 1:8 ISERDES.  Which IO mode is used controls the maximum clock speed.
Likewise, only the SERDES IO mode supports the data strobe.</p>

<p>All data messages in the SDIO/eMMC protocol start with a zero start bit.  This
is used as a synchronization point.  In our case one of the key features of
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">the front end</a>
is that it strips off the start bit.  It also samples our data for us–either
by sampling the outgoing clock edges to discover a sample point, or by
sampling data when the return data strobe is present (eMMC only).</p>

<p>A second key feature is specific to the synchronous path.  In this case, the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a>
measures the outgoing clock signal (before it gets to the pins), and sets a
sample time some programmable delayed time afterwards.  In this way, for high
speed IO, we allow ourselves to sample the incoming data at a programmable
fraction of a clock cycle later than the outgoing clock itself, to allow
for any clock propagation time from our controller, through the PCB to the
SDIO/eMMC chip, and then coming back from the SDIO/eMMC chip through the PCB to
our FPGA.</p>

<p>All this is to say that by the time we get any data, all the hard work of
discovering when to sample the various IO bits has been taken care of for us.</p>

<p>On the synchronous interface, the <code class="language-plaintext highlighter-rouge">i_rx_strb</code> signal will indicate whether we
have new data available.  It will either indicate no sampling clock edges
(<code class="language-plaintext highlighter-rouge">i_rx_strb==0</code>), one edge (<code class="language-plaintext highlighter-rouge">i_rx_strb==2'b10</code>), or two edges
(<code class="language-plaintext highlighter-rouge">i_rx_strb==2'b11</code>) of data.  If <code class="language-plaintext highlighter-rouge">i_rx_strb[1]</code> is true, then either 1, 4, or
8 bits of data will be available on the <code class="language-plaintext highlighter-rouge">i_rx_data[15:8]</code> ports.  If
<code class="language-plaintext highlighter-rouge">i_rx_strb[0]</code> is also true, then 1, 4, or 8 bits of data will also be present
in the <code class="language-plaintext highlighter-rouge">i_rx_data[7:0]</code> inputs.</p>

<p>The asynchronous interface is even simpler to use.  If <code class="language-plaintext highlighter-rouge">S_ASYNC_VALID</code> is ever
true, then we’ll have 32-bits of incoming data available to us.  There will
never be less.  This is due in part due to how the front end IOs are set up,
and also in part due to the nature of how the data strobe line is used.
Specifically, it is never used in one or four bit modes–always 8 bit.
Likewise, the data strobe is only ever used in
<a href="/blog/2020/08/22/oddr.html">DDR</a> mode, when data is
transmitted on both clock edges.</p>

<p>That describes what comes into this <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receive
component</a>.</p>

<p>There are two interfaces on the output.  The first is the control interface.
For every request that is made, that is for every time <code class="language-plaintext highlighter-rouge">i_rx_en</code> is enabled,
the controller will process a received packet.  Once the packet is complete,
this receiver will raise the <code class="language-plaintext highlighter-rouge">o_done</code> flag.  At that time, it will also
raise the <code class="language-plaintext highlighter-rouge">o_err</code> flag if there were any errors associated with the packet.
Such errors could either be 1) a
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
mismatch, or 2) a watchdog timeout error.</p>

<p>Let me pause here for a moment to point out, whenever you use a return
data strobe for sampling data coming back to a chip, you <em>always</em> need to
add a watchdog timer.  This is to keep your controller from hanging in
the event you make a mistake and either 1) don’t properly wire up the
data strobe, or 2) make a mistake in your protocol handling so that the
downstream chip doesn’t return the number of data strobes you are expecting.
In our case, the watchdog timer will also generate a timeout if the start
bit isn’t received within its timeout window–something that will come back
to haunt us when we get to hardware testing.</p>

<p>The last interface, coming out of this controller, is the memory interface.
This is designed to feed one of two <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics">ping-pong
buffers</a>.
My vision is that these <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics">ping-pong
buffers</a>
will be as wide as the bus, so they can be used in high speed DMA operations on
wider buses if necessary–although to date I’ve only tried them at 32-bits
each.  (Yes, the <a href="https://github.com/ZipCPU/eth10g">ETH10G
project</a> uses a 512-bus, but I’m initially
only going to connect this to the 32-bit control bus portion of that design.)</p>

<p>The memory interface has valid, strobe, and data lines.  If the valid line
is high, then the strobe lines will tell you which bytes within the data lines
to write.</p>

<p>If all goes well, once <code class="language-plaintext highlighter-rouge">i_rx_en</code> is set, memory will flow from the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a>,
get collected into bytes and/or words, and then sent out the memory interface.
Once complete, the <code class="language-plaintext highlighter-rouge">o_done</code> signal will be raised and the controller will
then drop the <code class="language-plaintext highlighter-rouge">i_rx_en</code> line, and only raise it following another command from
the user–or perhaps the to-be written DMA.</p>

<p>At least, that’s how this portion of the design is <em>supposed</em> to work.</p>

<h2 id="outlining-the-formal-proof">Outlining the Formal Proof</h2>

<p>One of the reasons why <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">this
component</a>
took so long to verify was because I had a sort of writer’s block when I first
looked at it.  I didn’t really know where to start.  <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">The
design</a>,
I said to myself, was so simple–what could possibly be done to verify it?</p>

<p>Yeah.</p>

<p>As a result, <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">this
component</a>
sat on the shelf for a week or two while I worked on other things.</p>

<table align="center" style="float: right"><caption>Fig 5. When do I get to the real stuff?</caption><tr><td><img src="/img/sdrxframe/realstuff.svg" width="320" /></td></tr></table>

<p>The <a href="/formal/2020/06/12/four-keys.html">minimum requirement</a>
of any formal proof is something I call “The Contract.” The contract describes
how the IP is supposed to operate if everything is working.  In this case, the
contract is fairly easy to express in words: given an arbitrary byte, arriving
at an arbitrary position in the received data stream, formally <em>prove</em> that
this arbitrary byte gets processed properly and sent to the output.</p>

<p>As with most things in life, however, you need some sort of structure to hang
all of this verification logic off of.  You can think of it like a skeleton.
Just like a skeleton holds all your joints, ligaments, and muscles in place, a
good formal verification structure can be used to hold all of the formal
verification logic in place.</p>

<p>I chose two pieces for my skeleton.  The first was a bit counter.  Starting
from the beginning of the operation, I would count the number of bits
arriving on our interface.  If we were in one bit mode, that would be the
number of ones arriving on <code class="language-plaintext highlighter-rouge">i_rx_strb</code>.  For the four or eight bit interface,
it would be four or eight times that much.  It simply counts how many bits of
valid data we’ve received.  The second key component was a memory counter.
This memory counter would count the number of bytes written to the <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics">ping-pong
buffer</a>
control outputs.</p>

<p>I then needed some assertions to tie these two together.</p>

<p>Those two counters alone were enough to find the first several bugs.</p>

<p>They were also enough to allow me to build and express the contract.</p>

<p>A third component of the skeleton that I added at a later time was a 1-bit
state machine.  This one bit state machine would become high upon a request
for operation–one cycle after <code class="language-plaintext highlighter-rouge">i_rx_en</code> goes high, and then it would go low
once we completed our task.  I needed this to prove that the design wouldn’t
hang–especially since I was seeing it hang at the time.</p>

<p>At this point, we can come back to our original question, and ask: how
many bugs did I find?</p>

<h2 id="bugs-discovered-via-formal-verification">Bugs discovered via formal verification</h2>

<p>Let’s count the bugs I found.  Since I’m using <a href="https://git-scm.com/">git</a>,
it’s not all that hard.  I’m just doing a <code class="language-plaintext highlighter-rouge">git diff</code>, or rather
<a href="https://meldmerge.org/?utm_source=Logiciels.Pro"><code class="language-plaintext highlighter-rouge">meld</code></a>
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v"><code class="language-plaintext highlighter-rouge">sdrxframe</code></a> to
be more specific, and counting all of the differences between the commit before
verifying the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receiver</a> and
the changes after now that the verification now passes.  Let’s walk through
the differences, shall we?</p>

<ol>
  <li>
    <p>The first difference doesn’t really count.  I discovered, via simulation
testing, that I had stripped off the start bit in two locations: first in the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a>,
and second in the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receive
framer</a>.
The result was both lost data and a failing
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>, since the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receive framer</a>
would remove one or more clock cycles of data from the beginning of any
packet, while looking for that start bit.  This change just hadn’t made
it into my baseline commit.</p>
  </li>
  <li>
    <p>The next big change is sort of borderline as to whether it should count
or not.  Since I had let the design sit for a couple weeks before coming
back to it to verify it, I came at it with fresh eyes and noticed a big
bug while simply desk checking: I never implemented the
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s for the
negative clock edge.</p>

    <p>When using the SDIO/eMMC protocol, each data wire used in transmission
gets its own <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
at the end of the data block.  These
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s are each
16-bits in length, and they protect the entire data block.  That’s in single
data rate (SDR) mode.  When operating in dual data rate (DDR) mode and
sending data on each edge of the clock, there’s one
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a> for each data
wire on the positive edge of the clock, and a separate
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a> for each data
wire protecting the data sent on the negative edge of the clock.  Both
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s
are 16-bits, and they are interleaved–so the positive edge
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
will alternate transmission with the negative edge
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
at the end of the packet.</p>

    <p>When building the receive controller, however, I had only implemented the
positive edge
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s.</p>

    <p>Oops.</p>

    <p>I’m not sure I’d call that a formal verification bug, though, since the
tools didn’t really find it.  I found it via a desk check.  That is, I found
it via a desk check that I was only doing because I was adding formal
properties to the design in order to verify it.</p>
  </li>
  <li>
    <p>The next bug was associated with the logic for <code class="language-plaintext highlighter-rouge">o_done</code>.  This bug
didn’t really show up as an assertion failure, rather it showed up as I
was trying to formally describe how the logic was supposed to operate.</p>

    <p>The first problem here was that I had <em>two</em> <code class="language-plaintext highlighter-rouge">done</code> signals.  One was used
internally, and the other was my external signal.  Further, I couldn’t
really make out (from my own design even!) what the real difference was
between these two signals.  How were they supposed to relate?  Were they
supposed to be identical?</p>

    <p>Let me back up and explain this a bit more.  I want to formally verify
the entire operation of the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receive
framer</a>.
That means I want to verify,
formally, that it can properly receive 512 bytes of data in all modes,
to include the mode where it only receives one bit at a time for a minimum
total of 4096 clock cycles.  This is a minimum, however, because when I
operate the design at 100kHz (the slowest potential clock speed), there
will be
1,000 clock cycles between every bit.  Hence, a full operation will
take more than 4M clock cycles.  Most formal proofs will die on anything
over about 20 clock cycles, with the longest proof I have running at about
350 clock cycles.  There would be no way I’d verify 4M clock cycles of
operation, therefore, without using
<a href="/blog/2018/03/10/induction-exercise.html">Induction</a>.</p>

    <p><a href="/blog/2018/03/10/induction-exercise.html">Induction</a>,
however, requires assertions to both verify and then guarantee
all of the relationships between registers.  That means I need assertions
to describe the differences between these two done registers.</p>

    <p>Yeah, the second <code class="language-plaintext highlighter-rouge">done</code> register was quickly dropped when I couldn’t decide
what it’s real purpose was.</p>

    <p>Even that wasn’t enough, since there were several registers that needed
to act on the clock prior to <code class="language-plaintext highlighter-rouge">o_done</code>.  Therefore, I ended up creating
a signal I called <code class="language-plaintext highlighter-rouge">w_done</code> to indicate that <code class="language-plaintext highlighter-rouge">o_done</code> was about to be
set, and everything remaining should clean itself up.</p>
  </li>
  <li>
    <p>The next bug was that
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a> errors (not
tested by my simulation), wouldn’t show up coincident with the done signal.
Yes, my <code class="language-plaintext highlighter-rouge">done</code> logic was really messed up.  At first I was declaring the
design <code class="language-plaintext highlighter-rouge">done</code> once all the data (not
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s)
had been received.  Then I tried setting <code class="language-plaintext highlighter-rouge">done</code> once all the
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s
had been received, but not allowing for the last bit(s) to impact the
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s,
nor for a test of whether or not the last
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
successfully received its data.</p>

    <p>In many ways this didn’t surprise me: I rarely test fault conditions in
simulation.  I should.  Indeed, I need to make it a habit of doing so, but
my simulation setup for this design was still somewhat new, so I hadn’t yet
verified failed <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
handling.</p>
  </li>
  <li>
    <p>At full speed, data would get written to the wrong memory address.</p>

    <p>Remember how I said that the skeleton of the proof would help?  Well, it
turns out my address counting was messed up.  I would calculate the
next memory address on the cycle I wrote to memory.  That wasn’t a problem.
However, I’d then use that memory address to shift the next memory strobe
and data into position, and so my logic required a dead cycle between
memory writes in order to be successful.  That would be fine when operating
on four data bits (SDIO/eMMC) in SDR mode, when not using the OSERDES (i.e.
when using the CCLK pin).  In other words, it would work fine
the way both my simulation and my hardware were setup.  However, this
approach would fail quickly when/if I ever transitioned to one of the high
speed modes this IP was supposed to support.</p>
  </li>
</ol>

<table align="center" style="float: left; padding: 25px"><tr><td><img src="/img/sdrxframe/pride-shame.svg" width="240" alt="When pride cometh, then cometh shame: but with the lowly is wisdom. (Prov 11:2)" /></td></tr></table>

<p>Remember how I commented earlier on my frustrations when taking a design
   out of my library to add to a larger SOC-based design?  This would’ve lead
   directly to one of those problems.  Had I not verified this IP, I would’ve
   run it on hardware and been really proud of it.  I’d put it, in my pride,
   into my library and declare it to be “working”, only to come back later,
   configure it for a (supposed to be supported) high frequency mode, only
   to discover that mode didn’t work.</p>

<p>This is why I like formal methods.</p>

<ol start="6">
  <li>
    <p>I also came across a bug whereby the receiver might ingest one too many
clock cycles.  What happens, for example, if you want to receive a five
byte packet, the data width is set to 8-bits, and <code class="language-plaintext highlighter-rouge">i_rx_strb==2'b11</code> on
every clock cycle?  The answer is that, on the last clock cycle, the
data associated with the second clock edge would need to be discarded.</p>

    <p>In this case, I needed to generate a new signal, one I called <code class="language-plaintext highlighter-rouge">last_strb</code>,
to keep the IP from ingesting more than one clock edge with the last data
set.</p>
  </li>
  <li>
    <p>The next bug was associated with disabling
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
checking.  When I built <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">this
receiver</a>,
I built it with a mode for receiving something that doesn’t have a
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>.  This was to
support reading particular registers that weren’t
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a> protected.
In hindsight, however, I’m not really sure I need this mode–since 1) all
of those registers transfer their data over the CMD wire, and 2) even those
unprotected registers still have
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s–they
just can’t be trusted.  Regardless of whether it is needed or not, however,
the formal tool decided to test it and found it broken.</p>

    <p>Of course, my simulation didn’t check this mode.  There was no reason to.
All data transactions require
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>s.  However,
design lock ups are bad, and that was what the formal tool found.  If ever
the <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
checking was disabled, the design might accept its packet (but not the
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>)
and then hang waiting on the remaining
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
that would never come.</p>
  </li>
  <li>
    <p>The last bug was more serious.  It involved those cases where I might
receive data on two separate clock edges within a single clock cycle.
This might be the case when using either the
<a href="/blog/2020/08/22/oddr.html">ODDR</a> component in DDR
mode, or the SERDES component in a multiple IO clock per system clock mode.
The bug would only be triggered if I receive data on one clock edge at
first (<code class="language-plaintext highlighter-rouge">i_rx_strb==2'b10</code>), and then ever after received data on both
clock edges (<code class="language-plaintext highlighter-rouge">i_rx_strb==2'b11</code>).  Not only that, it’s only triggered
in 8-bit mode.</p>

    <p>Here’s how the bug works.  When the first 8-bits of data arrive,
those bits get written to bits [31:24] of the memory bus–assuming it’s
32-bits, which it is for these runs.  On all subsequent clock cycles,
16-bits arrive and get forwarded to the memory.  Hence you’d write to
bits [23:8] of memory on the second write, and then you’d want to write to
bits [7:0] of the current memory word and (oops) bits [31:23] of the
subsequent word.  This is called an <em>unaligned data access</em>, and herein
lies the bug.  I didn’t account for writing unaligned data to memory.</p>

    <p>Fixing this bug wasn’t hard, but it did require logic to handle the
unaligned memory write request.</p>
  </li>
</ol>

<p>One of the tricks I often use when formally verifying components is to assume
difficult things won’t happen.  It helps the proof along, and can often help
me get through the simpler logic.  Of course, difficult things <em>do</em> happen in
real life, and so these assumptions can easily render a proof invalid.  For
this reason, I make sure to place all such assumptions in a specially marked
block at the end of the file–a block I like to call “Careless assumptions,”
because of the likelihood that they will void a proof.  Over time, as I get
the opportunity, I’ll slowly work off these “careless assumptions” until none
remain.</p>

<p>In this case, my “Careless assumptions” section held two assumptions for a while
that I needed to come back to.  The first was that <code class="language-plaintext highlighter-rouge">i_rx_strb</code> would only ever
be either <code class="language-plaintext highlighter-rouge">2'b11</code> or <code class="language-plaintext highlighter-rouge">2'b10</code>.  This allowed me to get the proof to pass first,
and then come back later to handle the unaligned memory requests.  My second
assumption is that the watchdog timeout would never fire.  In both cases, I
had to come back later and work through removing these assumptions before the
proof could really be declared complete.</p>

<p>Today, I can now say with confidence that this design and proof no longer
contains any “careless” assumptions.</p>

<h2 id="hardware-bringup">Hardware bringup</h2>

<p>Yes, but … <em>does it work?</em>  Alternatively, I might ask, did all that formal
verification work actually make a dent when it came to how long it took to
bringup <a href="https://github.com/ZipCPU/sdspi">the controller</a> in silicon to talk
to its first device?</p>

<p>To answer that question, let’s go over the bugs found during hardware bringup.</p>

<p>First, as background, the design did need a hardware change before starting.
The FPGA was driving the SD Card at 1.8Volts via a TI TXB0108 voltage
translator to 3.3V, and the voltage translator couldn’t handle the open
drain signaling required during startup.</p>

<p>Second, I was quite pleased to see the card respond to the very first
command I gave it, the <code class="language-plaintext highlighter-rouge">SEND_IF_COND</code> command.  Not only did it respond, but
it also returned a valid response.  This helped to add momentum to the
subsequent testing, knowing that at least the interaction via the
command wire worked.</p>

<p>Now let’s go over the bugs I found.</p>

<ol>
  <li>
    <p>The next command in the bringup of an SD card, following the <code class="language-plaintext highlighter-rouge">SEND_IF_COND</code>
command, is to ask the card to send its Operating Conditions Register (OCR).
This is part of a voltage negotiation that takes place between <a href="https://github.com/ZipCPU/sdspi">the
controller</a> and the card.  It’s supposed
to be a <em>handshake</em>.  <strong>The bug:</strong> in my first software drafts, I never
told the card what voltages I could provide.  Hence, from the card’s
perspective, we had never come to an agreement on the required voltage
and so the card never booted up.</p>

    <p>Reading through the specification helped here.</p>

    <p><strong>Conclusion:</strong> This was a <em>software</em> bug.</p>
  </li>
  <li>
    <p>The next problem was that I couldn’t get the card to respond
to the next command, <code class="language-plaintext highlighter-rouge">ALL_SEND_CID</code>.  This is where every card sharing the
bus sends its identification via an open-drain setup, and whoever sends a
‘0’ wins the bus for that bit and following.  It’s a part of the protocol
designed to allow multiple cards to share a bus–although I’ve never actually
seen this used in practice.  In this case, I just couldn’t get the card to
respond at <em>all</em> to this request.  The card had responded fine to the
previous command, just not this one.</p>

    <p>The problem here turned out to have nothing to do with the <code class="language-plaintext highlighter-rouge">ALL_SEND_CID</code>
command at all–it was how I handled the response to the reading the
OCR.  Bit [31] of the OCR is listed in the specification as “Card power up
status bit (busy)”.  So, I figured that once the bit was clear, the card
was no longer busy.  <strong>The bug:</strong> Re-reading the specification revealed I
had the sense wrong–the bit needed to become a one before moving on.
Because I wasn’t waiting, the card hadn’t finished powering up when I
gave it its next command, hence it wasn’t responding.</p>

    <p>I found this bug via simulation, once I tried increasing the power up time
in simulation to the point where it would have an impact.  Then, when <a href="https://github.com/ZipCPU/sdspi/blob/master/bench/verilog/tb_sdio.v">the
simulation</a>
didn’t match my software, I knew I was on to something.</p>

    <p><strong>Conclusion:</strong> This was a second <em>software</em> bug.</p>
  </li>
</ol>

<table align="center" style="float: left; padding: 25px"><caption>Fig 6. Voodoo computing</caption><tr><td><img src="/img/sdrxframe/voodoo.svg" width="320" /></td></tr></table>

<ol start="3">
  <li>
    <p>During this time I should point out I did a lot of return code debugging.
Specifically, <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v">my command wire
processor</a> got a
lot of scrubbing to make sure I was getting the right return code for
any error I encountered.  I’m not sure I really found anything here, but I
did change a bunch of stuff in the process.</p>

    <p><strong>Conclusion:</strong> I’m not sure there was a bug here at all.  I think the
bottom line issue here was that I had forgotten, between when I wrote this
module and when I came back to it, exactly how the interface was supposed
to work.  So I ended up rewriting how errors should be reported, even though
they may have not been reported incorrectly in the first place.</p>

    <p>Sadly, I also discovered that I had left a “Careless assumption” in my
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v">command wire processor</a>,
an assumption that kept the formal proof of this processor from ever
examining a timeout situation.  So, I had to pause here to remove this
last assumption–especially since I was getting timeout errors, and I
had no confidence that these errors were correct.</p>
  </li>
  <li>
    <p>I then managed to get far enough to read several registers from the SD
card.  Two in particular, the Card Identification (CID) register and the
Card Specific Register (CSR) deserve some extra mention.  These are each
128’bit registers (including
the <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>).
.  They follow what would normally be an echo of the
8’b command, and end with a 7-bit
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a> followed by a
stop bit for a total of 136 bits.  In testing, I could read these registers
just fine.  The bug the problem was that the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v">command
wire processor</a>
was indicating a <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
error every time it read from these registers.</p>

    <p><strong>The bug:</strong> Digging further, I discovered I had calculated the
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
over the 8’bit prefix to the 120’bit data register, not just the 120’bit
data bits.  In this case, both <a href="https://github.com/ZipCPU/sdspi/blob/master/bench/verilog/mdl_sdio.v">my SDIO
model</a>
and <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v">my controller</a>
were in error.  This is a classic example of building the wrong thing
right.</p>

    <p>I’m not sure I would’ve found this apart from hardware testing.</p>

    <p><strong>Conclusion:</strong> This one was a hardware bug.  The hardware did everything
I had designed it to do and it did it all properly, I had just designed
it to do the wrong thing.</p>
  </li>
  <li>
    <p>I also came across a second problem with these 128-bit registers, and that
was that I could read them once, and once only.  Ever after that first
success, the register would always read zero.</p>

    <p>To understand this bug, we have to look a bit deeper into the design.</p>

    <p>The <a href="https://github.com/ZipCPU/sdspi">SDIO controller</a> is designed to
handle data transfer via two internal FIFOs–the <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics">ping-pong
buffer</a>s.
Normally, those buffers are only used for data transfer: Either software
writes a sector into them that is then forwarded to the SD Card, or the
<a href="https://github.com/ZipCPU/sdspi">controller</a> reads a sector from the SD
Card and places the results into the buffer for software to come back and
read once the operation is complete.  The exception to this rule is that
these 128-bit registers are also written to the <a href="https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics">ping-pong
buffer</a>s,
not by the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receive
framer</a>, but by
the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v">command wire
handler</a>.</p>

    <p>The problem in this case had to do with the pointers to the FIFO.
<strong>The bug:</strong> I wasn’t
resetting the read pointer when I issued a command to read these registers.
As a result, the first time I read the registers properly from addresses
0, 1, 2, and 3.  When I issued the command again, the pointers weren’t reset
and so I was attempting to read the 128-bit register value from addresses
4, 5, 6, and 7–after it had been stored in addresses 0, 1, 2, and 3.</p>

    <p><strong>Conclusion:</strong> While you might argue this was bad user interface design,
it required a hardware fix.  Therefore this falls into the category of a
hardware bug.</p>
  </li>
  <li>
    <p>Once the card identifies itself, it is then picks its relative address and
the protocol clock can speed up from 400kHz to 25MHz.  Later, if I want
to restart things, I might wish to slow the clock back down to 400kHz.
<strong>Design bug:</strong> Along the way, I discovered that my register design
provided me no way of knowing what the current clock speed was.  Hence,
I might change the clock speed, but never know how long to wait until that
new speed was active.</p>

    <p>I solved this by adjusting the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v">Wishbone
controller</a> and
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v">clock divider</a> so
that <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v">the controller</a>
would return, upon a read request, the <em>current</em>
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v">clock divider</a>
setting, not necessarily the most recently commanded one.  Once the two
matched, I could then know the clock rate had properly changed and so I
could move on.</p>

    <p>This still creates a sudden clock change.  Were the card to try to lock a
PLL to this clock, it wouldn’t have time to lock it before I was sending
the next command.  On the other hand, the specification does say that the
clock can be stopped or paused at any time if need be, a criteria that would
probably preclude such an implementation.</p>

    <p><strong>Conclusion:</strong> This was a flaw in my user interface design.</p>
  </li>
  <li>
    <p>SD Cards have two command sets.  There are regular commands, called CMDs
and followed by a decimal number, such as CMD0 (GO IDLE) or CMD17
(READ SECTOR).  There are also application specific commands, or ACMDs.
To send an ACMD, you first send a CMD55, and then the following command is
interpreted as an ACMD.  I now needed to issue an ACMD6 to set the bus width
to four bits.  However, much as I tried, I couldn’t get the card to respond
to my CMD55 at all.  <strong>The bug:</strong> It was only after much frustration that I
looked up the CMD55’s argument, only to discover I was supposed to
address the card in the CMD55 via the card’s relative address–and I was just
setting the address field to zero.  This was appropriate earlier in the
setup, before the card had assigned itself a non-zero relative address, but
not once the address had been assigned.  No wonder it wasn’t responding–I
wasn’t addressing it.</p>

    <p><strong>Conclusion:</strong> This makes for a third software bug.</p>
  </li>
  <li>
    <p>At this point, I was finally at the point in the sequence where I could
issue a command to read a sector from the SD Card and … I got stuck here
again.  I kept issuing read commands, only to have them end in
a failure with a
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
failing error code.  In the end, this turned out to be a couple of bugs.</p>

    <p><strong>The bug:</strong> The first problem was that I couldn’t tell the difference
between a read failure and a command response failure.  Both might return
the same <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a>
failure code, both shared the same three bits.</p>

    <p><strong>Conclusion:</strong> I really need to adjust the user interface here, so I can
tell the difference between failures on the command wire, and read failures
on the data lines–whether they be timeout errors or actual
<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a> errors.</p>

    <p>Now for the other problems …</p>
  </li>
  <li>
    <p>I also made the mistake at one point of not enabling the FIFOs.  Sure
enough, by design, the read wasn’t enabled because the FIFOs hadn’t been
enabled.</p>

    <p><strong>Conclusion:</strong>  This was a software bug, caused by my thrashing around
trying to determine if I had a read error or a command wire error, and
so I had turned off the FIFOs to get the command to end early enough that
I might trigger the internal logic analyzer on something useful, and then
I later forgot that I had them turned off.</p>
  </li>
  <li>
    <p>At this point, I still wasn’t able to read a sector from the device,
and it took a bit longer to figure out why.  Not only that, I had to dig
into the trace from my internal logic analyzer to discover the next bug.
Remember how I said when discussing the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receiver
design</a>, that
the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a>
would remove the start bit?  Well, in order to do that, the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a>
needs to be told when to expect a packet so it can reset its start-bit
search algorithm.  Nothing in my internal interfaces allowed for this
communication–I just hadn’t foreseen the need.</p>

    <p><strong>Conclusion:</strong> This was definitely a hardware bug.</p>
  </li>
  <li>
    <p>Then I got lucky.  <strong>The bug:</strong> I just managed to (by chance) adjust the
scope enough that I could see there was a packet (i.e. the sector) coming
back across the interface, but the design just wasn’t seeing it.  This was
key, because it told me I wasn’t somehow messing up the command.  I had
the command sequence right, and the card was returning data, I just wasn’t
seeing it.</p>

    <p>Was it a problem in the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receiver</a>?</p>

    <p>No.  The formally verified
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receiver</a>
worked nicely as designed.</p>

    <p>The problem was in my watchdog timer.  The timer was set, by a parameter in
the <a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v">receiver</a>,
to wait a maximum of 8M clock cycles for the first data bit.  That timer was
overridden at the top level, so that it would only wait 64 clock cycles for
the first data bit.  Needless to say, the card didn’t respond that fast.</p>

    <p><strong>Conclusion:</strong> Yeah, this was another hardware bug.  This time, it was in
the design’s configuration.</p>
  </li>
</ol>

<p>At this point, I’d like to write that all my formally verified modules worked
as intended.  Was this really the case?  Let’s work through the issues
identified above.  Issue three wasn’t clearly a bug.  Issues one, two,
seven, and nine were all software issues,
and issues six and eight were user interface design issues.</p>

<p>That leaves four hardware issues that were revealed during bringup.  The
first was the 128-bit register CRC issue.  This flaw passed both formal
and simulation based verification–the design did what I told it to, I had
just told it to do the wrong thing.  The second issue, that of the FIFO
pointers, should’ve been caught when I verified the user interface, or at least
when I ran the whole design in simulation.  The last two issues, that of when
to start looking for the start bit and how long the watchdog timeout should
be, were both issues rooted in the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a>.
They were missed simply because 1) I didn’t formally verify the
<a href="https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v">PHY</a>,
and 2) my simulation never checked more than one packet, and 3) never
waited a significantly long period of time before returning a packet.
(Given how expensive simulation can be, I dislike waiting if I don’t have to.
Unfortunately, this led to missing two bugs in simulation that had to be caught 
later in hardware.)</p>

<p>One item I haven’t yet mentioned is how long this hardware bringup session
took.  Once everything was formally verified, I managed to run through all the
hardware bringup over the course of two days.  The work often took place when
another project was running simulations, and it had to be paused for nearly
a whole day in the middle due to internet connectivity issues.  So, let’s
say hardware bringup–from synthesis to reading a sector took no more than
a day of work in total.  This is in contrast to my first attempts to bring
up <a href="https://github.com/ZipCPU/sdsdpi/blob/master/sw/sdiodrv.c">this controller</a>,
taken before either simulation or formal were accomplished,
where I just embarrassed myself when not only did the controller not work but
I had no idea why not.  At least this time I had more confidence in what
was going on.</p>

<p>I should also caveat this list by pointing out that I haven’t (yet) verified
either <a href="https://github.com/ZipCPU/sdsdpi/blob/master/sw/sdiodrv.c">my software
driver</a>, or the
hardware’s ability to write a sector.  So far, I’ve only tested a piece of
well instrumented <a href="https://github.com/ZipCPU/eth10g/blob/dev/sw/zipcpu/board/sdiochk.c">test
software</a>–nothing
that can really be used beyond initial hardware verification.  My work,
therefore, isn’t complete yet.</p>

<h2 id="conclusions">Conclusions</h2>

<p>I like to ask myself, after going through all this pain, was it really worth
it?  Was it worth all the pain of going through a formal verification process?
Were the bugs I found ones that justified the extra work?</p>

<p>In this case, let’s think of the alternative.  The alternative is that I
would run this design on silicon, convince myself over the next week or two
that it worked, and then put this design away, in my library, containing
bugs associated with features never tested in silicon.  I’d be proud of my
work, and pat myself on the back.  Then, sometime later–perhaps a year or
more, I’d come back to this design, remember how proud I was of it, pull it off
the shelf, and place it into a new design using an IO mode that had never been
properly tested, only to
discover things not working.  I’d then re-run the simulation, get a “success”
result, and convince myself that some other part of the design must be in error.
Then, after a painful week of debugging–perhaps even two–I’d be forced back
to this portion of the design only to kick myself for allowing such bugs to be
left in my “library”.</p>

<p>This is definitely one of those cases where an ounce of prevention is worth
a pound of cure.  It’s certainly easier to debug a design shortly after
writing it than it is to come back to it years later wondering what’s wrong
with it.</p>


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Prepare thy work without, and make it fit for thyself in the field; and afterwards build thine house. (Prov 24:27)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
