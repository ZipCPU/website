<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>I have a brand new piece of IP.  How shall I verify it?</title>
  <meta name="description" content="Fig 1. Is Digital Design Bifurcated?">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2020/07/21/formal-plan.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">I have a brand new piece of IP.  How shall I verify it?</h1>
    <p class="post-meta"><time datetime="2020-07-21T00:00:00-04:00" itemprop="datePublished">Jul 21, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. Is Digital Design Bifurcated?</caption><tr><td><img src="/img/bifurcated-design.svg" alt="" width="320" /></td></tr></table>

<p>The digital design industry appears to me to be bifurcated.  There are design
engineers and then there are verification engineers.  Designs are built, and
then thrown over a wall (a.k.a. “delivered”) to the verification team to be
“verified”.  The verification team then finds a bug and throws (sends) the
design back to the design team to be fixed and so forth.</p>

<p>The verification team tends to use one of several methodologies then to verify
the design.  Many of these methodologies involve using the <a href="http://www.asic-world.com/systemverilog/assertions4.html">System Verilog
Assertion language</a>
to describe how the design is supposed to work, and then
trying to find what it takes to break the design.  Often, this approach
makes extensive use of automatically generated <code class="language-plaintext highlighter-rouge">cover()</code> statements to
make certain every piece of logic within a design has been reached.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 2. Using formal property sets to test black box designs</caption><tr><td><img src="/img/blackbox-propset.svg" alt="" width="320" /></td></tr></table>

<p>To understand the issues associated with this divide, let’s look at it from
the verification team’s perspective.  Imagine someone just handed you
a large and complex design, and then asked you to verify it.  This isn’t just
an academic exercise, since I’ve had the opportunity to examine such
<a href="https://riscv.org">RISC-V</a> designs as the <a href="https://github.com/openhwgroup/cv32e40p">Pulp-Platform’s Ri5cy
CPU</a>, or <a href="https://github.com/westerndigitalcorporation/swerv_eh1">Western Digital’s SWERV
processor</a>.
Most recently, I had the opportunity to apply my
formal AXI properties
to the <a href="https://github.com/pulp-platform/axi/blob/master/src/axi_lite_xbar.sv">Pulp-Platform’s AXI-Lite
crossbar</a>.</p>

<p>In each of these examples, I had the opportunity to play (some of) the role
of the Verification Engineer.  I was given a large and complex design that I
had never seen before, and then was asked to find a bug within it.</p>

<p>Where would you start?</p>

<p>Read the fine manual.</p>

<p>Sure, but what would your next step be?</p>

<p>In my case, I started by treating each processor as a <a href="https://en.wikipedia.org/wiki/Black-box_testing">black
box</a>, to which I attached any
<a href="/formal/2018/12/28/axilite.html">interface property sets</a>
I had to it.  I then ran a bounded model check until
I ran out of patience.  In the case of the <a href="https://github.com/westerndigitalcorporation/swerv_eh1">Western Digital’s SWERV
processor</a>, I added
an AXI property set to their I/Os and only made it about 20 time steps into
the design.  In the case of the <a href="https://github.com/pulp-platform/axi/blob/master/src/axi_lite_xbar.sv">Pulp-Platform’s AXI-Lite
crossbar</a>,
I added my <a href="/formal/2018/12/28/axilite.html">AXI-lite property
sets</a> and then
only made it about 14 steps into the design.  With
<a href="https://github.com/openhwgroup/cv32e40p">Ri5cy</a>, I attached the
<a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal</a>
property set to the CPU.  Once done, I was able to discover that the
<a href="https://github.com/openhwgroup/cv32e40p">Ri5cy</a>
CPU had six bugs in the first 12 time steps.  After those 12 time steps,
the process came to an absolute brick wall, and I couldn’t go any further.</p>

<table align="center" style="float: right"><caption>Fig 3. A bounded model check can only identify failures, not the absence of failures</caption><tr><td><img src="/img/four-keys/induction-results.png" alt="" width="417" /></td></tr></table>

<p>Might there be a bug on timestep 40?  Absolutely!  When you only use a
bounded proof, it’s hard to know if the first 20 timesteps are
sufficient for verifying a core or not.</p>

<p>This is very different from the way I go about verifying my own designs.  When
I verify one of my own designs, I use
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
to verify the design for all time.  This is often called an “unbounded” proof.
I will examine the design for some number of time steps from the beginning of
time, and then again using
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
for some number of timesteps at some arbitrary point later in time.  The
resulting proof is then valid for all time–not just the first 10-20 time
steps.</p>

<p>The amount of formal-processing work isn’t really all that different.  For
example, in the <a href="/about/zipcpu.html">ZipCPU</a>,
I can <a href="/blog/2018/04/02/formal-cpu-bugs.html">verify the entire CPU using an unbounded
proof</a>.   The
proof only <a href="https://github.com/ZipCPU/zipcpu/blob/master/bench/formal/zipcpu.sby">requires between 8 and 18
steps</a>,
depending upon how the CPU is configured.</p>

<p>Why can’t I do this with one of these other
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s?</p>

<p>I suppose I could–theoretically.  The problem is that I would then need to
get to know how these
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
work in a deeper depth than the designers ever knew and understood when
they built their various cores in the first place.  Let’s take a moment to
dig into this, and see why this is so.   We’ll look at an AXI-lite proof,
an AXI slave, and then some example CPU proofs along the way.</p>

<h2 id="the-axi-lite-crossbar">The AXI-Lite Crossbar</h2>

<p>At the core of the issue is the question of whether or not
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
is a form of <a href="https://en.wikipedia.org/wiki/White-box_testing">white</a>
or <a href="https://en.wikipedia.org/wiki/Black-box_testing">black box</a> testing.  To
answer this question, let’s consider a <a href="https://github.com/ZipCPU/wb2axip/blob/master/doc/busprops.pdf">generic set of bus
properties</a>
for discussion, and then examine how those would get applied to a crossbar.</p>

<ol>
  <li>Everything gets cleared following a reset</li>
  <li>Whenever the bus is stalled, the request doesn’t change</li>
  <li>There should be no acknowledgments without a prior request</li>
  <li>All requests should (eventually) get a response</li>
</ol>

<p>Two of these properties are particularly problematic.  These are the third and
fourth ones.  They are problematic simply because they require state within the
property checker–state that can get out of alignment with the rest of the
design under test if you aren’t careful.</p>

<p>Let’s look at how we might implement the property that there should be no
acknowledgments without a prior request.  The first thing we’d need is a
counter to keep track of all of the outstanding transactions–transactions
that still need returns.  Let’s call this counter <code class="language-plaintext highlighter-rouge">f_outstanding</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="n">f_outstanding</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span> <span class="n">bus_request</span><span class="p">,</span> <span class="n">bus_response</span> <span class="o">}</span><span class="p">)</span>
<span class="mb">2'b10</span><span class="o">:</span> <span class="n">f_outstanding</span> <span class="o">&lt;=</span> <span class="n">f_outstanding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="mb">2'b01</span><span class="o">:</span> <span class="n">f_outstanding</span> <span class="o">&lt;=</span> <span class="n">f_outstanding</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">endcase</span></code></pre></figure>

<p>Now that we know how many requests are outstanding, we can assert that there
shouldn’t be any bus acknowledgments without a prior request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bus_response</span><span class="p">)</span>
	<span class="k">assert</span><span class="p">(</span><span class="n">f_outstanding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>Now, let me ask you, what would it take to verify this property?  With a
bounded proof, it’s not that hard: you just follow the design from time-step
one through the end of your patience, and you know the design will be
internally consistent.</p>

<p>But was that enough time steps?  You might never know.</p>

<p>How about that unbounded proof then?  This would be the proof that verifies
your assertions <em>for all time</em>.  For this you need
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<p>Yes, there are some solvers that can handle unbounded proofs with no more
work.  Such solvers include
<a href="https://github.com/berkeley-abc/abc">ABC’s IC3 solver</a>, called <a href="https://symbiyosys.readthedocs.io/en/latest/reference.html">“abc pdr” in
SymbiYosys</a>, or the
<a href="https://bitbucket.org/arieg/extavy/src/master">Avy</a> or
<a href="https://bitbucket.org/sterin/super_prove_build">Super-Prove</a>
<a href="https://fmv.jku.at/aiger">Aiger</a> solvers.  The problem with these solvers is
that they work great on simple problems, but tend to struggle on the more
complex problems.  Even worse than that, when they struggle it’s hard to tell
why.</p>

<p>To go after the large and complex proofs, you will need an <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT
solver</a> such as
<a href="https://yices.csl.sri.com">Yices</a> or
<a href="https://boolector.github.io">Boolector</a>.  (BTOR looks like a promising
upgrade over SMT, but I have only limited experience with it to date.)  These
solvers need a little
guidance in order to handle an unbounded proof.  This guidance comes in the
form of assertions, contained within the design, that the design will be
consistent.  In this case, we’ll need to make certain that the design is
consistent with the <code class="language-plaintext highlighter-rouge">f_outstanding</code> counter from our property checker.</p>

<p>For example, when verifying <a href="/formal/2018/12/28/axilite.html">Xilinx’s AXI-lite
cores</a>, I was able to add,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">faxil_awr_outstanding</span> <span class="o">==</span> <span class="n">faxil_wr_outstanding</span><span class="p">);</span></code></pre></figure>

<p>This works because <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">Xilinx’s
core</a>
never accepted any write address transactions into the core without also
accepting the write data transaction at the same time.</p>

<p>Similarly, once a write request is accepted, <a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/xlnxdemo.v">Xilinx’s demo
core</a>
immediately acknowledged it.  That allowed me to write,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">==</span> <span class="p">(</span><span class="n">o_axi_bvalid</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span></code></pre></figure>

<p>I can now write similar properties for the read side of the core, and the
various outstanding transaction counters are now fully matched to the state
within the core.</p>

<p>My own <a href="/blog/2019/01/12/demoaxilite.html">AXI-lite slave demonstration
design</a> doesn’t work like
that at all.  In order to achieve 100% throughput, the design uses an
internal <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.
When using a <a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>,
there may be an outstanding transaction within the
<a href="/blog/2019/05/22/skidbuffer.html">buffer</a>
that needs to be counted.  In that case, the assertion looks more like,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">faxil_wr_outstanding</span> <span class="o">==</span> <span class="p">(</span><span class="n">o_axi_bvalid</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
				<span class="o">+</span> <span class="p">(</span><span class="o">!</span><span class="n">o_axi_wready</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span></code></pre></figure>

<p>since the core will drop <code class="language-plaintext highlighter-rouge">WREADY</code> any time something is in the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>.
A similar assertion can then be used to constrain the number of outstanding
write address requests.</p>

<p>These assertions are easy to write.  Indeed they are fairly trivial–to me the
designer.</p>

<p>What happens, though, when you get to a <a href="/blog/2019/07/17/crossbar.html">crossbar
interconnect</a>?  In that
case, the assertions get more challenging to write.</p>

<p>Let’s take a look, for example, at the <a href="https://github.com/ZipCPU/wb2axip/blob/f87f8001ef30f238fdafc0bc8f1c54919a0a2745/rtl/axilxbar.v#L1807-L1858">assertion that relates the outstanding
counter in the master’s properties to those of the slaves properties</a>.
This needs to be done for every one of the various masters
who might have made
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>
requests of the core.  In this design, there are <code class="language-plaintext highlighter-rouge">NM</code> of them, corresponding
to each of the <code class="language-plaintext highlighter-rouge">NM</code> masters connecting to the crossbar that might each wish
to talk to one of the <code class="language-plaintext highlighter-rouge">NS</code> slaves.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">for</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">N</span><span class="o">&lt;</span><span class="n">NM</span><span class="p">;</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">CORRELATE_OUTSTANDING</span></code></pre></figure>

<p>For each master, we have to ask the question of whether or not they’ve been
granted access to a particular slave.  This information is captured by
<code class="language-plaintext highlighter-rouge">swgrant[N]</code> which, within <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilxbar.v">my
design</a>,
indicates that master <code class="language-plaintext highlighter-rouge">N</code> has been granted access to a slave, and also by
<code class="language-plaintext highlighter-rouge">swindex[N]</code>, which gets populated with the index of the slave that master <code class="language-plaintext highlighter-rouge">N</code>
has been granted access to.  If <code class="language-plaintext highlighter-rouge">swindex[N] == NS</code>, then the master has
been granted access to a non-existent slave whose sole <a href="https://github.com/ZipCPU/wb2axip/blob/f87f8001ef30f238fdafc0bc8f1c54919a0a2745/rtl/axilxbar.v#L1167-L1168">purpose is to return bus
errors</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">swgrant</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">swindex</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">NS</span><span class="p">)))</span>
		<span class="k">begin</span></code></pre></figure>

<p>Now, for every master who’s been granted access to a slave, we can then
correlate the number of outstanding transactions from the masters perspective,
<code class="language-plaintext highlighter-rouge">fm_awr_outstanding[N]</code>, with the number of outstanding transactions from the
slaves perspective, <code class="language-plaintext highlighter-rouge">fs_awr_outstanding[swindex[N]]</code>.  This correlation needs
to take into account the
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
on the input, the extra clock stage (optionally) used to
determine which slave a request needs to be assigned to, as well as any
responses that have yet to be accepted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">assert</span><span class="p">((</span><span class="n">fm_awr_outstanding</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
				<span class="o">-</span> <span class="p">(</span><span class="n">S_AXI_AWREADY</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span>
				<span class="o">-</span><span class="p">((</span><span class="n">OPT_BUFFER_DECODER</span> <span class="o">&amp;&amp;</span> <span class="n">dcd_awvalid</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
				<span class="o">-</span> <span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>  <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">))</span></code></pre></figure>

<p>It needs to equal the slave’s counter of outstanding write address transactions,
<code class="language-plaintext highlighter-rouge">fs_awr_outstanding[swindex[N]]</code>, adjusted for any requests waiting to be
accepted in the slave, or being returned from the slave and waiting
to be accepted by the master.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">				<span class="o">==</span> <span class="p">(</span><span class="n">fs_awr_outstanding</span><span class="p">[</span><span class="n">swindex</span><span class="p">[</span><span class="n">N</span><span class="p">]]</span>
					<span class="o">+</span> <span class="p">(</span><span class="n">m_axi_awvalid</span><span class="p">[</span><span class="n">swindex</span><span class="p">[</span><span class="n">N</span><span class="p">]]</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
					<span class="o">+</span> <span class="p">(</span><span class="n">m_axi_bready</span><span class="p">[</span><span class="n">swindex</span><span class="p">[</span><span class="n">N</span><span class="p">]]</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)));</span></code></pre></figure>

<p>The process then needs to be repeated for the write data channel–although
it’s still roughly the same equation as the write address channel we just
looked at.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">assert</span><span class="p">((</span><span class="n">fm_wr_outstanding</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>
				<span class="o">-</span> <span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span>
				<span class="o">-</span> <span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">))</span>
				<span class="o">==</span> <span class="p">(</span><span class="n">fs_wr_outstanding</span><span class="p">[</span><span class="n">swindex</span><span class="p">[</span><span class="n">N</span><span class="p">]]</span>
					<span class="o">+</span> <span class="p">(</span><span class="n">m_axi_wvalid</span><span class="p">[</span><span class="n">swindex</span><span class="p">[</span><span class="n">N</span><span class="p">]]</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
					<span class="o">+</span> <span class="p">(</span><span class="n">m_axi_bready</span><span class="p">[</span><span class="n">swindex</span><span class="p">[</span><span class="n">N</span><span class="p">]]</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)));</span></code></pre></figure>

<p>But what about all of the other channels that haven’t (yet) been granted
access to any slaves, or for whom the grant is to our non-existent,
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
producing slave?
In that case, we now need to repeat the assertion–but this time it won’t
depend upon the slave’s counter of outstanding transactions at all–just
the master’s counter.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">swgrant</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="n">swindex</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">==</span><span class="n">NS</span><span class="p">)))</span>
		<span class="k">begin</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swgrant</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">fm_awr_outstanding</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">==</span>
					<span class="p">(</span><span class="n">S_AXI_AWREADY</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span>
					<span class="o">+</span><span class="p">((</span><span class="n">OPT_BUFFER_DECODER</span> <span class="o">&amp;&amp;</span> <span class="n">dcd_awvalid</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
					<span class="o">+</span><span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>  <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">fm_awr_outstanding</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">&gt;=</span>
					<span class="p">(</span><span class="n">S_AXI_AWREADY</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span>
					<span class="o">+</span><span class="p">((</span><span class="n">OPT_BUFFER_DECODER</span> <span class="o">&amp;&amp;</span> <span class="n">dcd_awvalid</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
					<span class="o">+</span><span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>  <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span>

			<span class="k">assert</span><span class="p">(</span><span class="n">fm_wr_outstanding</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>  <span class="o">==</span>
					<span class="p">(</span><span class="n">S_AXI_WREADY</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>  <span class="o">?</span> <span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span>
					<span class="o">+</span><span class="p">(</span><span class="n">S_AXI_BVALID</span><span class="p">[</span><span class="n">N</span><span class="p">]</span>  <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">));</span>
		<span class="k">end</span>

	<span class="c1">//</span>
	<span class="c1">// We'll skip the similar assertions for the read channel(s)</span>
	<span class="c1">// ...</span>
	<span class="c1">//</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Now, let me ask you, how complex is this assertion to write and express?</p>

<p>All we’ve done is create an assertion to correlate the state within the design
with the number of outstanding transactions the
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>
expects.  That allows us to make the assertion that there shall be no
responses without a prior request–the same thing we started with.  As with
the two example AXI-lite slaves, we’re still correlating the state of the
internal crossbar with that of the various counters found within the
<a href="/formal/2018/12/28/axilite.html">AXI-Lite property checkers</a>.
However, unlike the very simple AXI-lite slaves, this assertion is now much
more complex than the original one we started out with.</p>

<p>What would happen if we didn’t have these complex and design-dependent
assertions?  In the case of the
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>,
the solver would find 4 time-steps ending such that the master had
no outstanding transactions, but where there was also a bus response being
returned from one of the slaves.  The solver would then conclude the design
was in error.</p>

<p>Why only 4 time-steps?  Simply because that’s <a href="https://github.com/ZipCPU/wb2axip/blob/f87f8001ef30f238fdafc0bc8f1c54919a0a2745/bench/formal/axilxbar.sby#L18">how I have the proof set
up</a>–since
I am able to verify the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilxbar.v">AXI-lite
crossbar</a> in
only four time steps, I do so.</p>

<p>Would it help to add more time steps?  Not really.  The solver would always be
able to find more time-steps with outstanding transactions, only to return a
contradiction on the last step.  Proving this to students is one of the
exercises in the <a href="/tutorial/formal.html">formal verification
course</a> that I teach.</p>

<h3 id="your-turn-verify-an-axi-slave">Your turn: Verify an AXI slave</h3>

<p>So, now, let me ask you: if this was not your design, would you ever add such
a complex assertion to the design?  If you were a “verification engineer”,
who had been handed this design for the purpose of verifying it, would you
add this assertion?  Would you even know where to look to find all the
registers that needed to be included to do so?</p>

<p>If you didn’t add the assertion to the design, you wouldn’t be able to
accomplish an <a href="/blog/2018/03/10/induction-exercise.html">unbounded
proof</a>.  You’d
be stuck verifying the design for a bounded proof only and never knowing
if you’d missed anything.</p>

<p>So, who should add these properties then?  Are properties like these the
responsibility of the design team or the verification team?</p>

<p>For those who have never used
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>,
this complexity is cited as a reason not to use it.</p>

<p>For the verification engineer looking over a design with no internal
properties, he’d be tempted to just look at a bounded check of the design.  If
the bounded check finds something, the verification engineer can claim he’s
earned his pay for that day.</p>

<p>But what if it doesn’t find anything?  In frustration, he might decide to just
run simulations looking for property violations.  Perhaps he might use a lot
of cover checks to convince himself that the simulations were sufficient, much
like <a href="/blog/2020/01/01/2019-in-review.html">Xilinx did when verifying their AXI ethernet-lite
design</a>, and so miss
the fact (as Xilinx did) that writes to the core might be applied to the wrong
address if they arrived on the same clock cycle as a read request.</p>

<p>To the designer, on the other hand, this property isn’t nearly as complex.
Why not?  <em>Because it’s his design</em>.  The designer knows every stage in his
design, where transactions might get stalled, where they might hide, and
where to check when getting this count right.  As the designer of the
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilxbar.v">AXI-lite</a>
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>,
above, I know there’s a
<a href="/blog/2019/05/22/skidbuffer.html">skid buffer</a>
on entry.  I know the parameter that enables or disables it.  I know that
the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/addrdecode.html">address
decoder</a>
might, or might not, require a clock–and which parameter option controls that.</p>

<p>These are things an engineer might not be aware of who examines the design from
a <a href="https://en.wikipedia.org/wiki/Black-box_testing">black box</a>
perspective alone.</p>

<p>But lets be serious, what’s the likelihood of hitting a bug in a
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>
more than 14 steps into the design?  In this case, it’s actually higher than
you might expect.  Every
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>
needs counters within it to know how many transactions are outstanding, so
that it can tell when a channel may be reassigned to another master-slave
pair.  It is the responsibility of the
<a href="/blog/2019/07/17/crossbar.html">crossbar</a>
to make certain these counters don’t overflow.  You aren’t likely to overflow
one of these counters inside 14 timesteps.</p>

<h2 id="cpu-verification">CPU Verification</h2>

<p>The same basic concepts apply when verifying a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
although they will look different.  A
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
contains instructions that get passed through various stages of processing
as they direct reads from the register file, writes to the register file,
and reads from or writes to memory.  To verify a
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
therefore, you want to follow an instruction through the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
and make sure that it does the “right thing” at every stage.</p>

<p>The <a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal project</a>
does this based upon a packet of information that is
produced by a piece of logic scaffolding added to the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.
Within the <a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal</a>
parlance, this is called the <a href="https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md">“RISC-V Formal Interface” or
RVFI</a>.
Once the packet is fully formed, the attached property set can make assertions
about what the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> did.</p>

<p>For example, if the instruction was an ADD instruction, then it should’ve
read from the two given registers, summed their values together,
and then written the result back to the destination register before retiring.
<a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal</a> captures these
separate pieces together in its <a href="https://github.com/SymbioticEDA/riscv-formal/blob/master/insns/insn_add.v">insn_add</a> logic.</p>

<ol>
  <li><a href="https://github.com/SymbioticEDA/riscv-formal/blob/c36e1e1cdac572cc1fcd7b240c04eef9cf56873c/insns/insn_add.v#L46">Is this an ADD instruction</a>?</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span> <span class="n">spec_valid</span> <span class="o">=</span> <span class="n">rvfi_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">insn_padding</span> <span class="o">&amp;&amp;</span> <span class="n">insn_funct7</span> <span class="o">==</span> <span class="mi">7</span><span class="err">'</span><span class="n">b</span> <span class="mi">0000000</span> <span class="o">&amp;&amp;</span> <span class="n">insn_funct3</span> <span class="o">==</span> <span class="mi">3</span><span class="err">'</span><span class="n">b</span> <span class="mi">000</span> <span class="o">&amp;&amp;</span> <span class="n">insn_opcode</span> <span class="o">==</span> <span class="mi">7</span><span class="err">'</span><span class="n">b</span> <span class="mi">0110011</span><span class="p">;</span></code></pre></figure>

<ol start="2">
  <li><a href="https://github.com/SymbioticEDA/riscv-formal/blob/c36e1e1cdac572cc1fcd7b240c04eef9cf56873c/insns/insn_add.v#L47-48">What are the two source registers</a>?</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="kt">wire</span> <span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">insn_rs2</span>    <span class="o">=</span> <span class="n">rvfi_insn</span><span class="p">[</span><span class="mi">24</span><span class="o">:</span><span class="mi">20</span><span class="p">];</span>
  <span class="kt">wire</span> <span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">insn_rs1</span>    <span class="o">=</span> <span class="n">rvfi_insn</span><span class="p">[</span><span class="mi">19</span><span class="o">:</span><span class="mi">15</span><span class="p">];</span>
  <span class="c1">// ...</span>
  <span class="k">assign</span> <span class="n">spec_rs1_addr</span> <span class="o">=</span> <span class="n">insn_rs1</span><span class="p">;</span>
  <span class="k">assign</span> <span class="n">spec_rs2_addr</span> <span class="o">=</span> <span class="n">insn_rs2</span><span class="p">;</span></code></pre></figure>

<ol start="3">
  <li>
    <p>What were their values?</p>

    <p>In the <a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal</a>
setup, the values of the instructions are provided by the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
core, and only checked by a <a href="https://github.com/SymbioticEDA/riscv-formal/blob/master/checks/rvfi_reg_check.sv">separate register value
checker</a>.</p>
  </li>
</ol>

<ol start="4">
  <li><a href="https://github.com/SymbioticEDA/riscv-formal/blob/c36e1e1cdac572cc1fcd7b240c04eef9cf56873c/insns/insn_add.v#L45">What result should be written back</a>?</li>
</ol>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">  <span class="kt">wire</span> <span class="p">[</span><span class="n">RISCV_FORMAL_XLEN</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">rvfi_rs1_rdata</span> <span class="o">+</span> <span class="n">rvfi_rs2_rdata</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="k">assign</span> <span class="n">spec_rd_wdata</span> <span class="o">=</span> <span class="n">spec_rd_addr</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Once these portions of the instruction have been decoded, the <a href="https://github.com/SymbioticEDA/riscv-formal/blob/c36e1e1cdac572cc1fcd7b240c04eef9cf56873c/checks/rvfi_insn_check.sv">check for this
instruction</a> can then be written
simply as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@*</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reset</span> <span class="o">&amp;&amp;</span> <span class="n">spec_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">spec_trap</span><span class="p">)</span>
	<span class="k">begin</span>

		<span class="c1">// If the source register is used, it must match</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spec_rs1_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">spec_rs1_addr</span> <span class="o">==</span> <span class="n">rs1_addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">spec_rs2_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">spec_rs2_addr</span> <span class="o">==</span> <span class="n">rs2_addr</span><span class="p">);</span>

		<span class="c1">// The destination register must match</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">spec_rd_addr</span> <span class="o">==</span> <span class="n">rd_addr</span><span class="p">);</span>

		<span class="c1">// The instruction result must match the result of an</span>
		<span class="c1">// addition, as expected</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">spec_rd_wdata</span> <span class="o">==</span> <span class="n">rd_wdata</span><span class="p">);</span>

		<span class="c1">// The next instruction must have an address 4 bytes later</span>
		<span class="c1">// (for an add instruction)</span>
		<span class="k">assert</span><span class="p">(</span><span class="cp">`rvformal_addr_eq</span><span class="p">(</span><span class="n">spec_pc_wdata</span><span class="p">,</span> <span class="n">pc_wdata</span><span class="p">));</span>

		<span class="c1">//</span>
		<span class="c1">// Other properties, not relevant to an ADD</span>
		<span class="c1">//</span>
	<span class="k">end</span></code></pre></figure>

<p>This is, of course, a paraphrase.  The <a href="https://github.com/SymbioticEDA/riscv-formal/blob/c36e1e1cdac572cc1fcd7b240c04eef9cf56873c/checks/rvfi_insn_check.sv">actual instruction
check</a>
also needs to check for potential memory operations (not used in an add
instruction), and so on.</p>

<p>Further, the <a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal</a>
approach to verifying a <a href="https://riscv.org">RISC-V</a> processor has a unique
twist to it–it treats instructions as separate individual checks, and allows
the processor to do whatever it wants for <code class="language-plaintext highlighter-rouge">N-1</code> clock cycles, only to insist
that the <code class="language-plaintext highlighter-rouge">N</code>th clock cycle contains an addition (if checking additions), and
so on.  I understand these choices to be made for performance reasons
<em>appropriate for bounded checks only</em>.</p>

<p>Let’s see how this plays out when examining a couple of
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s:
<a href="https://github.com/openhwgroup/cv32e40p">Ri5cy</a>
and the <a href="/about/zipcpu.html">ZipCPU</a>–which doesn’t use
<a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal</a>, but rather
uses an unbounded approach.</p>

<h3 id="the-ri5cy-processor">The Ri5cy Processor</h3>

<p>Some years ago, I was asked to apply the
<a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal</a>
properties to the <a href="https://github.com/openhwgroup/cv32e40p">Ri5cy</a> processor.
<a href="https://github.com/openhwgroup/cv32e40p">Ri5cy</a> is a
<a href="https://riscv.org">RISC-V</a>
processor built as part of the <a href="https://pulp-platform.org">PULP Platform</a>.
The <a href="https://pulp-platform.org">PULP Platform</a> was built as part of a joint
project between <a href="https://iis.ee.ethz.ch/research/research-groups/Digital%20Circuits%20and%20Systems.html">ETH Zurich</a> and the <a href="https://dei.unibo.it/en/research">Univerty of
Bologna</a>.  You can also read more about the
<a href="https://iis-projects.ee.ethz.ch/index.php/PULP">PULP Platform</a> here.</p>

<p>My task was simple: all I needed to do was to find the various signals within
the core that corresponded to the various components of the <a href="https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md">riscv-formal
interface</a>.
Once these various signals were made available to the external environment,
the <a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal</a>
properties could then be applied to find the bugs in the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.</p>

<p>Did I find bugs?  Yes.  My report described six bugs that I found using
the <a href="https://www.symbioticeda.com/seda-suite">Symbiotic EDA Suite</a>.  Were
these bugs major?  Not this time.  Most of the major bugs had been worked out
by the time I got to the core.  As a result, most of what I found revolved
around properly decoding HINT instructions.</p>

<p>Or so I thought.</p>

<p>Some time later, <a href="https://www.axiomise.com/risc-v-formal-verification">Ashish Dhabari of
Axiomise</a> had the
opportunities to look at
<a href="https://github.com/openhwgroup/cv32e40p">Ri5cy</a>’s two sibling processors:
<a href="https://github.com/tom01h/zero-riscy">Zero-Ri5cy</a> and Micro-Ri5cy.  He found
several issues with these two processors, to include several with the core’s
debugging interface as well as a situation that would cause the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
to deadlock.</p>

<p>Why didn’t I find these bugs?  The obvious answer is that I wasn’t tasked
with verifying the debugging interface, and so I disabled it early on
when it created problems.  Moreover, I only looked through the first
12 timesteps, and that’s not a long period of time to find
<a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a> issues.</p>

<p>I also know that I really struggled to identify the various signals within
the <a href="https://github.com/openhwgroup/cv32e40p">Ri5cy</a>
<a href="https://github.com/openhwgroup/cv32e40p/blob/master/rtl/riscv_core.sv">core</a>
that could be used to properly populate the
<a href="https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md">RVFI</a>
packet.  Indeed, it felt like I needed to reverse engineer the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> to do so.
One of the surprises that I had to deal with was the fact that
<a href="https://github.com/openhwgroup/cv32e40p">Ri5cy</a> might retire a memory
instruction on the same cycle as it retires a subsequent
<a href="/zipcpu/2017/08/11/simple-alu.html">ALU</a> operation.
This took me a long time to figure out.  Indeed, I found myself <a href="/formal/2018/07/14/dev-cycle.html">using the
formal tools to debug my own properties long before I was debugging any
instruction properties</a>.</p>

<p>I think I might have found more bugs, however, if I was able to convert my proof
into an <a href="/blog/2018/03/10/induction-exercise.html">unbounded proof using
induction</a>.  That
said, long after I had “verified” the
<a href="/about/zipcpu.html">ZipCPU</a>, I still found a <a href="/zipcpu/2019/02/04/debugging-that-cpu.html">deadlock
bug</a> within it,
so there’s still something to be said for looking for such bugs particularly.</p>

<h3 id="the-zipcpu-processor">The ZipCPU Processor</h3>

<p>So what would it take to convert the
<a href="https://github.com/SymbioticEDA/riscv-formal">riscv-formal</a> approach
to one that would work for an unbounded check?  Simple–the
<a href="https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md">RVFI</a>
packet would need to be followed through all the processing steps of the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.  At each stage,
the
<a href="https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md">RVFI</a>
packet would need to be checked against the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>’s
internal state.  Such properties would not be required in any bounded check,
but in my own experience they are <em>required</em> for any
<a href="/blog/2018/03/10/induction-exercise.html">unbounded</a> proofs.</p>

<p>This is basically how the <a href="/about/zipcpu.html">ZipCPU</a>’s
verification flow works.  It’s the same basic principle: create a packet
of information describing the instruction being processed, and then follow
that packet of information as it works its way through the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>.</p>

<p>The two big differences?  First, the
<a href="/about/zipcpu.html">ZipCPU</a> is not a
<a href="https://riscv.org">RISC-V</a>
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>,
and second the <a href="/about/zipcpu.html">ZipCPU</a>’s
proof is an unbounded proof.  To make the unbounded proof work, the
<a href="/about/zipcpu.html">ZipCPU</a>’s formal instruction packet
is double checked against
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">the CPU</a>
for consistency purposes at <a href="/zipcpu/2017/08/23/cpu-pipeline.html">every stage of the
pipeline</a>.</p>

<p>Let’s look at the <a href="/formal/2018/07/21/zipcpu-icoboard.html">read-operands
stage</a> of the
<a href="/about/zipcpu.html">ZipCPU</a>’s
pipeline as an arbitrary example.  This stage is defined first and foremost
by the instruction within it.  When the <a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline steps
forward</a>, the
instruction from the decode stage steps forward into the <a href="/formal/2018/07/21/zipcpu-icoboard.html">read-operands
stage</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">f_op_insn_word</span> <span class="o">&lt;=</span> <span class="n">f_dcd_insn_word</span><span class="p">;</span>
		<span class="n">f_op_phase</span> <span class="o">&lt;=</span> <span class="n">dcd_phase</span><span class="p">;</span>
		<span class="c1">// ...</span>
	<span class="k">end</span></code></pre></figure>

<p>A special, <a href="https://github.com/ZipCPU/zipcpu/blob/5b0269905726eacd634c025af706cc3e4702ed66/bench/formal/f_idecode.v">formal verification-only, instruction
decoder</a>
is then used to <a href="https://github.com/ZipCPU/zipcpu/blob/5b0269905726eacd634c025af706cc3e4702ed66/rtl/core/zipcpu.v#L3404-L3419">decode the various components of this
instruction</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">f_idecode</span> <span class="p">#(.</span><span class="n">ADDRESS_WIDTH</span><span class="p">(</span><span class="n">AW</span><span class="p">),</span>
		<span class="p">.</span><span class="n">OPT_MPY</span><span class="p">((</span><span class="n">IMPLEMENT_MPY</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">?</span> <span class="mb">1'b1</span><span class="o">:</span><span class="mb">1'b0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">OPT_EARLY_BRANCHING</span><span class="p">(</span><span class="n">EARLY_BRANCHING</span><span class="p">),</span>
		<span class="p">.</span><span class="n">OPT_DIVIDE</span><span class="p">(</span><span class="n">IMPLEMENT_DIVIDE</span><span class="p">),</span>
		<span class="p">.</span><span class="n">OPT_FPU</span><span class="p">(</span><span class="n">IMPLEMENT_FPU</span><span class="p">),</span>
		<span class="p">.</span><span class="n">OPT_LOCK</span><span class="p">(</span><span class="n">OPT_LOCK</span><span class="p">),</span>
		<span class="p">.</span><span class="n">OPT_OPIPE</span><span class="p">(</span><span class="n">OPT_PIPELINED_BUS_ACCESS</span><span class="p">),</span>
		<span class="p">.</span><span class="n">OPT_SIM</span><span class="p">(</span><span class="mb">1'b0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">OPT_CIS</span><span class="p">(</span><span class="n">OPT_CIS</span><span class="p">))</span>
		<span class="n">f_insn_decode_op</span><span class="p">(</span><span class="n">f_op_insn_word</span><span class="p">,</span> <span class="n">f_op_phase</span><span class="p">,</span> <span class="n">op_gie</span><span class="p">,</span>
			<span class="n">fc_op_illegal</span><span class="p">,</span> <span class="n">fc_op_Rid</span><span class="p">,</span> <span class="n">fc_op_Aid</span><span class="p">,</span> <span class="n">fc_op_Bid</span><span class="p">,</span>
			<span class="n">fc_op_I</span><span class="p">,</span> <span class="n">fc_op_cond</span><span class="p">,</span> <span class="n">fc_op_wF</span><span class="p">,</span> <span class="n">fc_op_op</span><span class="p">,</span> <span class="n">fc_op_ALU</span><span class="p">,</span>
			<span class="n">fc_op_M</span><span class="p">,</span> <span class="n">fc_op_DV</span><span class="p">,</span> <span class="n">fc_op_FP</span><span class="p">,</span> <span class="n">fc_op_break</span><span class="p">,</span> <span class="n">fc_op_lock</span><span class="p">,</span>
			<span class="n">fc_op_wR</span><span class="p">,</span> <span class="n">fc_op_rA</span><span class="p">,</span> <span class="n">fc_op_rB</span><span class="p">,</span> <span class="n">fc_op_prepipe</span><span class="p">,</span>
			<span class="n">fc_op_sim</span><span class="p">,</span> <span class="n">fc_op_sim_immv</span>
			<span class="p">);</span></code></pre></figure>

<p><a href="https://github.com/ZipCPU/zipcpu/blob/5b0269905726eacd634c025af706cc3e4702ed66/bench/formal/f_idecode.v">This decoder</a>
is <em>special</em> because all of its results are combinatorial.  That’s important:
there’s no state within it to check.  Instead, the combinatorial outputs are
checked against the <a href="/about/zipcpu.html">ZipCPU</a>’s state.</p>

<p>The results of this “formal-only” decoder can then be <a href="https://github.com/ZipCPU/zipcpu/blob/5b0269905726eacd634c025af706cc3e4702ed66/rtl/core/zipcpu.v#L3447-L3543">compared with the
internal values</a>
found within the <a href="/zipcpu/2017/08/23/cpu-pipeline.html">CPU’s
pipeline</a>.  Here,
for example, is a small portion of <a href="https://github.com/ZipCPU/zipcpu/blob/5b0269905726eacd634c025af706cc3e4702ed66/rtl/core/zipcpu.v#L3447-L3543">that check</a>:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">op_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">((</span><span class="n">f_op_branch</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="o">!</span><span class="n">fc_op_illegal</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">clear_pipeline</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op_illegal</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">f_op_branch</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// If it's an ALU instruction, make sure it's</span>
			<span class="c1">// flagged as such</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_ALU</span> <span class="o">==</span> <span class="n">op_valid_alu</span><span class="p">);</span>
			<span class="c1">// ... same for a memory instruction</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_M</span>   <span class="o">==</span> <span class="n">op_valid_mem</span><span class="p">);</span>
			<span class="c1">// ... and a divide instruction</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_DV</span>  <span class="o">==</span> <span class="n">op_valid_div</span><span class="p">);</span>
			<span class="c1">// ... and a (yet to be implemented) floating point</span>
			<span class="c1">//   instruction</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_FP</span>  <span class="o">==</span> <span class="n">op_valid_fpu</span><span class="p">);</span>
			<span class="c1">// Make sure the register ID of operand A matches</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_rA</span> <span class="o">==</span> <span class="n">op_rA</span><span class="p">);</span>
			<span class="c1">// Make sure the register ID of operand B matches</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_rB</span> <span class="o">==</span> <span class="n">op_rB</span><span class="p">);</span>
			<span class="c1">// Make sure whether or not this instruction writes</span>
			<span class="c1">//   to the flags register matches whether or not its</span>
			<span class="c1">//   supposed to</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_wF</span> <span class="o">==</span> <span class="n">op_wF</span><span class="p">);</span>
			<span class="c1">// Make sure the resulting ID register matches</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_Rid</span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">op_R</span><span class="p">);</span>
			<span class="c1">// Make certain that the "is-this-a-lock instruction"</span>
			<span class="c1">//   flag matches</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_lock</span> <span class="o">==</span> <span class="n">op_lock</span><span class="p">);</span>
			<span class="c1">// Make certain that the "is-this-a-break instruction"</span>
			<span class="c1">//   flag matches</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">fc_op_break</span> <span class="o">==</span> <span class="n">op_break</span><span class="p">);</span>
			<span class="c1">// ...</span>
		<span class="c1">//</span>
		<span class="c1">// ...</span>
	<span class="c1">// ...</span></code></pre></figure>

<p>This forces consistency between the instruction word,
<code class="language-plaintext highlighter-rouge">f_op_insn_word</code>, that’s working it’s way through the
<a href="/zipcpu/2017/08/23/cpu-pipeline.html">pipeline</a>,
and the various signals within
<a href="https://github.com/ZipCPU/zipcpu/blob/master/rtl/core/zipcpu.v">the CPU</a>
which should have been determined properly from the instruction word.</p>

<h3 id="your-turn-verify-a-cpu">Your turn: Verify a CPU</h3>

<p>Now, imagine you were handed a large
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
and told that it needed to be verified.  How would you go about it?</p>

<p>Would you create a large simulation script, designed to exercise every
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
instruction, to then verify that the
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
worked?  This was my initial approach to verifying the
<a href="/about/zipcpu.html">ZipCPU</a>.
You can read about <a href="/blog/2018/04/02/formal-cpu-bugs.html">all the bugs this script missed
here</a>.
You can read about the <a href="/zipcpu/2017/12/28/ugliest-bug.html">problems I had with my instruction cache
here</a>.
Indeed, in just my <a href="/blog/2017/10/19/formal-intro.html">first experience with formal
methods</a>,
I learned that such a scripted simulation approach was prone to failure.</p>

<p>The industry understanding of <a href="/blog/2017/10/19/formal-intro.html">formal
verification</a>
is that a specialized verification engineer should examine a given core,
one that he didn’t write, and then write formal properties for it.</p>

<p>Pardon me for saying it, but … <em>this doesn’t make any sense</em>!</p>

<p>You want a verification engineer, someone who isn’t familiar with the core
he is supposed to verify, who doesn’t understand the internals of how the
core operates, to verify that the core has no bugs in it?  Do you want him to
reverse engineer the core to get there?</p>

<p>Wouldn’t it make more sense for the designer to <a href="/formal/2018/07/14/dev-cycle.html">build his own formal
properties</a>?</p>

<p>Sure, a verification engineer could do this work.  However, he would be
swimming upstream to do this.  Would it work?  That might depend upon your
verification engineer–since he’d need to be more capable than the design
engineer to do this.  The original core designer, on the other hand, would
<a href="/formal/2018/07/14/dev-cycle.html">get much farther with the same
tools</a> for the
simple reason that the designer already knows his own design.</p>

<h2 id="conclusions">Conclusions</h2>

<p>My point is simply this: The greatest benefit from using formal methods comes
<a href="/formal/2018/07/14/dev-cycle.html">during design</a>, not
during some later verification stage run by a separate engineering team.</p>

<p>During design, one simple formal statement can drive a lot of testing.  During
design, formal properties will give you more bang for your engineering time
than a simulation script will.  It will check more of your designs
functionality, and find more bugs.  You can read about <a href="/formal/2018/07/14/dev-cycle.html">what that might
look like here</a>.</p>

<p>The ideal place for
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
isn’t really before running the formal tools,
it’s <em>after</em> running those same tools.</p>

<p>Even better, if the designer has already run the formal tools on his design,
he can then pass the design to a verification engineer with the formal
properties still attached.  This will give the verification engineer a leg up
when attempting to verify that the core truly will live up to its design or not.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>The lord of that servant shall come in a day when he looketh not for him, and in an hour that he is not aware of, (Matt 24:50)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
