<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a Protocol Firewall</title>
  <meta name="description" content="Ever since finding bugs in Xilinx’s AXI implementations, I’ve been wary ofseeing these bugs again.[1][2]I’ve certainly found copies of these same bugs in man...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/formal/2020/05/16/firewall.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building a Protocol Firewall</h1>
    <p class="post-meta"><time datetime="2020-05-16T00:00:00-04:00" itemprop="datePublished">May 16, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Ever since finding bugs in Xilinx’s AXI implementations, I’ve been wary of
seeing these bugs again.
<a href="/formal/2018/12/28/axilite.html">[1]</a>
<a href="/formal/2019/05/13/axifull.html">[2]</a>
I’ve certainly found copies of these same bugs in many user cores.  I’ve also
found <a href="/formal/2019/04/16/axi-mistakes.html">quite a few other bugs in user
cores</a>.  Indeed, it
seems like AXI is just a hard bus to get things right with.</p>

<p>How then should a user build a working bus slave?</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 1. Verificcation as a service</caption><tr><td><img src="/img/firewall/as-a-service.svg" alt="" width="360" /></td></tr></table>

<p>Well, the obvious answer is <a href="/blog/2019/01/12/demoaxilite.html">by using formal
methods</a>.  If you are
interested in that road, you are welcome to try out my formal properties
for <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>,
<a href="/formal/2018/12/28/axilite.html">AXI-lite</a>, or even
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/fav_slave.v">Avalon-MM</a>.
You can also purchase my AXI formal property set from
<a href="https://www.symbioticeda.com">Symbiotic EDA</a>.  If you’d rather, you can also
purchase my time to look at your design, and run the <a href="https://www.symbioticeda.com/formal-verification">formal
tools</a> on it for you.</p>

<p>Even when using <a href="/blog/2017/10/19/formal-intro.html">formal
methods</a>, however, things
can still be a challenge.  An AXI4 transaction can have up to 256 beats to it.
At best that requires a clock for a reset, another clock for the address
request, and 256 clocks to transfer data.  If you want to check what happens
with <a href="https://en.wikipedia.org/wiki/Back_pressure">back pressure</a>,
you might want to check twice that many cycles.  Sadly, even at my best, I
haven’t managed to exhaustively search through that many time steps using
<a href="/blog/2017/10/19/formal-intro.html">formal methods</a>.
AXI just happens to be particularly complicated.</p>

<table align="center" style="float: right"><caption>Fig 2. AXI proof depths</caption><tr><td><img src="/img/firewall/depth-tbl.png" alt="" width="436" /></td></tr></table>

<p>This forces any complete AXI proof to use <a href="/blog/2018/03/10/induction-exercise.html">induction</a>.
Using <a href="/blog/2018/03/10/induction-exercise.html">induction</a>
I can complete a proof for all time with many fewer clock ticks, as shown in
Fig. 2 on the right.  The problem with
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
though is that you need to add a lot of extra
assertions into the design to make certain it can pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.
This can be a real challenge, especially as the core becomes more and more
complex.</p>

<p>Sometimes, you don’t get a choice.  For example, the DMAs and
<a href="/blog/2019/07/17/crossbar.html">crossbars</a> 
I wrote were so complex that I had to limit the depth as short as I could.
Were their proofs any longer, I’d lose interest in the results before they
came back.</p>

<p>Just how long is too long for me?  Well, remember, when you first start with a
proof the solver finds bugs very quickly.  It might find the first bug in two
seconds.  Then after a bit of work you’ll start to spend a lot of time at 30
seconds or so.  Only as you start getting close to a working solution does
the proof starts to take longer and longer, and so I find I then need to start
trimming the
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
depth more and more.  In the end, the memory to memory
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axidma.v">DMA</a>
requires an hour to complete the proof for aligned transfer and nearly
four hours to verify the core in it’s configuration where it can handle
unaligned transfers.</p>

<p><a href="/formal/2019/08/03/proof-duration.html">Most proofs are simpler than
that</a>, but AXI happens
to be rather complex.</p>

<p>Now let me ask, is this
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
check worth it?</p>

<table align="center" style="float: left; padding: 20px"><caption>Fig 3. Is induction worth the time?</caption><tr><td><img src="/img/firewall/is-induction-required.svg" alt="" width="360" /></td></tr></table>

<p>Given that I still keep finding bugs in cores when I use
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
I would argue that it is, although you do end up with diminishing returns.
Most of the “bugs” you will find when using
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
tend to be bugs related to missing assertions.  These are just frustrating,
leaving you wonder if your time is well spent.  However, I’ve found counter
overflow errors, <a href="/blog/2017/10/19/formal-intro.html">FIFO
overflow</a>
errors, and more when using
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.
These are important errors to find.</p>

<p>However, what if you can’t formally verify the core you are working with?
What if you are working with a piece of vendor IP that you have no insight
into?  Who knows, maybe it’s encrypted.  Given <a href="/blog/2020/01/01/2019-in-review.html">what we’ve discovered from
Xilinx’s IP</a> already,
you will need another
approach.  Similarly, if you ever want to partially reconfigure an FPGA and
have some ability to protect the upstream bus from the (not-yet-properly
configured) downstream logic, you could place a bus fault isolator into the
mix.  Finally, what happens if you want to talk off chip and you want to place
a bus component off chip.  How should you be able to handle what happens if the
off-chip slave is either off-line or being reconfigured?  How shall the rest of
the design be kept from locking up?</p>

<p>Enter the bus fault isolator, sometimes known as a bus firewall.</p>

<h2 id="bus-fault-isolators">Bus Fault Isolators</h2>

<table align="center" style="float: right"><caption>Fig 4. A Bus Fault Isolator</caption><tr><td><img src="/img/firewall/busports.svg" alt="" width="360" /></td></tr></table>

<p>As shown in Fig. 4 on the right, a bus fault isolator is a bus adaptor having
a trusted slave interface on one side, and an untrusted master bus interface
on the other.  It’s used to protect a bus from a faulty slave.</p>

<p>Here’s the basic idea:</p>

<table align="center" style="float: left; padding: 25px"><caption>Fig 5. If everything works, the bus fault isolator is a passthrough component</caption><tr><td><img src="/img/firewall/nofault.svg" alt="" width="360" /></td></tr></table>

<ol>
  <li>
    <p>If the slave follows protocol, there should ideally be no difference between
using the bus fault isolator and not using it, as shown in Fig. 5 on the
left.  Bus requests are passed through the bus fault isolator unchanged,
and responses are returned upstream without modification.  Indeed, in this
case, the firewall is just a passthrough device.</p>

    <p>Practically, there will be a minimum of some timing differences.  My <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">AXI bus
fault isolator</a> 
also restricts the number of outstanding downstream bursts to a single one
alone, and this restriction can have some other complications–possibly
even preventing any potential downstream bug from appearing.</p>
  </li>
</ol>

<table align="center" style="float: right"><caption>Fig 6. On a fault, the trusted bus is isolated from the broken core</caption><tr><td><img src="/img/firewall/onfault.svg" alt="" width="360" /></td></tr></table>

<ol start="2">
  <li>
    <p>If, on the other hand, the slave ever tries to break protocol, then the
bus fault isolator …</p>

    <p>a. Disconnects the slave from the bus as shown in Fig. 6 on the right</p>

    <p>b. Raises a flag on an external output which can be used to stop a <a href="/blog/2017/06/08/simple-scope.html">logic
   analyzers capture</a>
   allowing you to debug the problem</p>

    <p>c. Returns a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
   <a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
   for the failing transactions, for all outstanding transactions, and then
   for any future transactions</p>

    <p>d. Optionally, the bus fault isolator can be configured to reset the broken
   slave</p>
  </li>
</ol>

<p>You can get a feel for what this might look like from Fig. 7 below.  Follow
the numbers, since the logic flow appears to jump from one line on the trace
to another.  I’ve tried to add some lines and arrows to help make it clearer.</p>

<table align="center" style="float: center"><caption>Fig 7. Detecting a fault in an AXI-lite slave</caption><tr><td><img src="/img/firewall/axilsafety-diagram.png" alt="" width="711" /></td></tr></table>

<p>Fig. 7 shows an example of what might happen were a fault to be detected on
an AXI-lite slave link.  In this example, the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsafety.v">AXI-lite fault
isolator</a> has
been configured to reset the AXI-lite interface on a failure.  Very early on
in this trace, the downstream bus tries to return an unrequested response.  A
fault is detected.  The downstream AXI-lite core then gets reset again.  During
this reset, any AXI-lite request from upstream returns a bus
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>, as shown in step 3.  Once
reset, the core is then reintegrated back into the design until its next fault.</p>

<p>What kind of errors should a bus fault isolator like this be able to detect?
Well, ideally they should be able to detect any error caught by the formal
protocol checking properties.  This includes the classic errors:</p>

<ol>
  <li>
    <p>Acknowledgments without requests, such as <a href="https://github.com/ZipCPU/wb2axip/blob/master/doc/orconf2019.pdf">Intel’s AXI3 demonstrator
produced</a>.
(Intel’s core did require a request, it just might respond before the
request was complete and all write data was received.)</p>

    <p>The error shown above in Fig. 7 represents an error of this type.
This class of errors is a touch unusual, since a slave such as the bus
fault isolator appears to the rest of the bus can only return a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>
response in response to a bus request.  Don’t be too surprised, therefore,
if a fault is detected without a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> response.</p>
  </li>
  <li>
    <p>Missing acknowledgments, such as both Xilinx’s demonstrators and Intel’s
demonstrator’s struggled with or even as <a href="/blog/2020/01/01/2019-in-review.html">Xilinx’s ethernet
core</a> struggled
from.</p>

    <p>To catch a missing acknowledgment, the bus fault isolator needs an optional
timeout parameter.  If set to a non-zero value, it will insist that all bus
responses take place within that period of time.  Responses that take
longer will result in a detected bus fault and return a
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a> back upstream.</p>
  </li>
  <li>
    <p>Other errors, such as the <a href="/formal/2019/05/13/axifull.html">wrong ID being returned for a given
request</a>, or
RLAST getting set before the end of the burst also need to trigger a fault.
In the case of AXI-lite, the fault isolator will catch faults such as an
EXOKAY response being returned on any request.</p>
  </li>
</ol>

<p>That’s an amazing set of requirements.  There’s only one problem: they’re
impossible to meet.</p>

<p>I came across a couple problems when implementing my bus fault isolators.
In particular, it takes a clock period to detect an error.
Further, AXI’s requirement that signals cannot depend combinatorially on any
inputs means that the fault isolator must take a clock tick or two for its
translation.  Finally, <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">my AXI bus fault
isolator</a>
can only handle a single burst outstanding at any given time.</p>

<p>Still, even with its limitations, a bus fault isolator can be quite valuable.
Consider, for example, <a href="https://forums.xilinx.com/t5/PCIe-and-CPM/XDMA-Simulation-works-for-many-transfers-then-descriptor-count-0/m-p/1106225">this user who is struggling to figure out why Xilinx’s
AXI XDMA core locks up on him</a>.
The trace, showing the last valid burst before this lockup is shown in
Fig. 8 below.</p>

<table align="center" style="float: none"><caption>Fig 8. The last valid returned transaction before the XDMA locks up</caption><tr><td><a href="/img/firewall/xdma_bug.png"><img src="/img/firewall/xdma_bug.png" alt="" width="780" /></a></td></tr></table>

<p>Traces like that make me wonder, was there a protocol error in that trace?
It’s hard to tell at this resolution, and even if you were to zoom in to a
usable resolution, you’d have a lot of counting to do in order to know.
A bus fault isolator would reveal such a bug, allowing you to
separate which of the two pieces of IP is potentially at fault.</p>

<p>In this case, the limitations of the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">AXI bus fault
isolator</a>
wouldn’t bother you: the core in question appears to only ever request
one burst at a time, so it would ideally be useful for finding this kind of bug.</p>

<h2 id="verifying-a-bus-fault-isolator">Verifying a Bus Fault Isolator</h2>

<p>One of the things that makes a bus fault isolator unique is the form of its
proof.  First, the proof requires a bus property set.  This should come as no
surprise.  We’ve described building a bus property set for
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>, and again
for <a href="/formal/2018/12/28/axilite.html">AXI-lite</a>.
You’ll need a bus property set like one of those to do this.  Further, the
proof is tightly tied to the property set and dependent upon it.  For example,
the timeout counter logic must almost exactly mirror that of the property
set.  Once set up, then two proofs are required.</p>

<ol>
  <li>Assuming the slave behaves and follows the requirements of the bus
protocol as outlined in the bus properties, you need to prove that no fault
will be detected and all upstream protocols will be followed properly.</li>
</ol>

<table align="center" style="float: none"><caption>Fig 9. Good slaves produce no errors</caption><tr><td><img src="/img/firewall/nofault-assumption.svg" alt="" width="380" /></td></tr></table>

<ol start="2">
  <li>Now, assuming nothing about the slave, prove that all upstream protocols will
still be followed.</li>
</ol>

<table align="center" style="float: none"><caption>Fig 10. Either way, the upstream interface must always follow protocol</caption><tr><td><img src="/img/firewall/failsafe-assumption.svg" alt="" width="560" /></td></tr></table>

<p>It’s really that simple.</p>

<p>In my own designs, I have these two proofs separated by the SBY configuration.
Here, for example, is the task declaration section of the <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsafety.v">AXI-lite fault
isolator</a>’s
<a href="https://github.com/ZipCPU/wb2axip/blob/master/bench/formal/axilsafety.sby">SBY configuration file</a>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[tasks]
prf
cvr    fault     opt_reset
fault        prf
prfr         prf opt_reset
faultr fault prf opt_reset
longr  fault prf opt_reset opt_long_reset
prlong       prf opt_reset opt_long_reset</code></pre></figure>

<p>There’s a different <em>task</em> for each proof, shown on the left, together with a
series of tags defining common portions of each proof.  Those proofs without
the <code class="language-plaintext highlighter-rouge">fault</code> tag will define a design parameter, <code class="language-plaintext highlighter-rouge">F_OPT_FAULTLESS</code>, to be one.
This is done within the Yosys script section, as shown along with other
parameter declarations below–such as whether or not the core should reset
itself on any error, or how many cycles that reset pulse should require.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[script]
read -formal axilsafety.v
read -formal skidbuffer.v
read -formal faxil_slave.v
read -formal faxil_master.v
--pycode-begin--
cmd = "hierarchy -top axilsafety"
cmd += " -chparam F_OPT_FAULTLESS %d" % (0 if "fault"     in tags else 1)
cmd += " -chparam OPT_SELF_RESET  %d" % (1 if "opt_reset" in tags else 0)
cmd += " -chparam OPT_MIN_RESET   %d" % (16 if "opt_long_reset" in tags else 0)
cmd += " -chparam OPT_TIMEOUT 10"
output(cmd)
--pycode-end--
prep -top axilsafety</code></pre></figure>

<p>A generate block within the design then includes the bus properties of the
downstream slave in addition to those of the upstream master if ever
<code class="language-plaintext highlighter-rouge">F_OPT_FAULTLESS</code> is set.  The second proof, those with the <code class="language-plaintext highlighter-rouge">fault</code> tag set
above, sets this parameter to zero, and so the proof then assumes nothing about
the downstream slave.  If both proofs pass, then we know that the upstream
interface will follow the bus protocol independent of what the downstream core
does.</p>

<p>In general, this logic has the following form–independent of which bus
fault isolator is getting verified,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">AXI</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsafety.v">AXI-lite</a>, or
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbsafety.v">WB</a>:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">bussafety</span> <span class="p">#(</span><span class="cm">/* parameters */</span>
	<span class="p">)</span> <span class="p">(</span><span class="cm">/* portlist */</span><span class="p">,</span>
	<span class="kt">output</span> <span class="kt">reg</span> <span class="n">fault_detected</span><span class="p">);</span>

	<span class="cm">/* Core logic */</span>

<span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="c1">//</span>
	<span class="c1">// Invoke the bus bus property set to include</span>
	<span class="c1">// the bus properties of the upstream interface</span>
	<span class="c1">//</span>
	<span class="n">fbus_slave</span> <span class="p">#(</span><span class="cm">/* bus parameters */</span><span class="p">)</span>
	<span class="n">fslave</span><span class="p">(</span><span class="cm">/* upstream bus ports */</span><span class="p">);</span>

	<span class="c1">//</span>
	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_OPT_FAULTLESS</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">//</span>
		<span class="c1">// Assume the downstream slave "behaves" by instantiating</span>
		<span class="c1">// the downstream property set</span>
		<span class="c1">//</span>
		<span class="n">fbus_master</span> <span class="p">#(</span><span class="cm">/* bus parameters */</span><span class="p">)</span>
		<span class="n">fmaster</span><span class="p">(</span><span class="cm">/* downstream bus ports */</span><span class="p">);</span>

		<span class="c1">//</span>
		<span class="c1">// Assert that no fault will ever be detected</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">fault_detected</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="c1">//</span>
		<span class="c1">// No assumptions about the slave here</span>
		<span class="c1">//</span>
	<span class="k">end</span> <span class="k">endgenerate</span>
<span class="cp">`endif</span>
<span class="k">endmodule</span></code></pre></figure>

<p>The rest of the proof is just asserting that the state of the upstream
bus properties match those of the internal state of the core, and (possibly)
that the downstream properties match as well.</p>

<p>My bus fault isolators also have one other option that we’ve mentioned above,
and that is the option to restore a downstream slave core to the bus following
a fault.  It’s configured above as part of the <code class="language-plaintext highlighter-rouge">OPT_SELF_RESET</code> parameter.
Basically, on any fault, a downstream reset is generated.  Why?  Well, it has
to be.  Otherwise, how will you know that the next response from the
downstream core isn’t a response to the last response, you know–the one that
you gave up waiting on when you declared a fault?  You need a way to
resynchronize the downstream core with the upstream interface, and a reset is
the easy/only way to do that.</p>

<p>This also means that you have to use the firewall downstream of any (trusted)
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>,
or you would need to not only reset the entire
<a href="/blog/2019/07/17/crossbar.html">interconnect</a>
but also all of the masters connected to it.  This leads to a required
<a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
topography similar to the one shown in Fig. 11 below.</p>

<table align="center" style="float: none"><caption>Fig 10. Bus firewall must be downstream of the interconnect</caption><tr><td><img src="/img/firewall/interconnected.svg" alt="" width="560" /></td></tr></table>

<p>Want to see how this works?  Feel free to examine either <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">my AXI bus fault
isolator</a>,
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsafety.v">my AXI-lite bus fault
isolator</a>,
or more recently <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/wbsafety.v">my new Wishbone bus fault
isolator design</a>.
Indeed, let’s take a look at that <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsafety.v">AXI-lite bus fault
isolator</a> in the
next section.</p>

<h2 id="axi-lite-bus-fault-isolator">AXI-Lite bus fault isolator</h2>

<p>I’ve named my bus fault isolators using the name of the bus followed by the
word <em>safety</em>.  In this case, because we are using the AXI-lite bus, I’ve named
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsafety.v">this core axilsafety</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span> <span class="n">axilsafety</span> <span class="p">#(</span></code></pre></figure>

<p>Most of the parameters to this core are what you would expect.  There’s the
address and data widths for example.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="n">C_AXI_ADDR_WIDTH</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span>
	<span class="k">parameter</span>	<span class="n">C_AXI_DATA_WIDTH</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span></code></pre></figure>

<p>Then there’s the timeout.  We need this timeout.  This will help us find any
bugs.  For example, if the downstream core fails to accept a request before
this counter times out, or fails to return a response before it times out, in
both cases we’d declare a bug.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="n">OPT_TIMEOUT</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span></code></pre></figure>

<p>Of course, you’ll probably want to set this timeout to be much longer in
practice.  I just needed it to be short for the proof to pass–and even then
12 steps was too long for a quick proof.</p>

<p>The second important parameter is the <code class="language-plaintext highlighter-rouge">MAX_DEPTH</code>.  This is the maximum number
of outstanding transactions the downstream core can ever be allowed to have
outstanding at any time.  We’ll need this number to size our counters
properly.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="n">MAX_DEPTH</span> <span class="o">=</span> <span class="p">(</span><span class="n">OPT_TIMEOUT</span><span class="p">),</span></code></pre></figure>

<p>The next parameter of interest is the <code class="language-plaintext highlighter-rouge">OPT_SELF_RESET</code>.  If this parameter
is set, the core will issue a reset to the downstream interface on any
fault–in an attempt to allow you to recover what’s left of the broken design
in the presence of a fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_SELF_RESET</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">,</span></code></pre></figure>

<p>Further, Xilinx wants their bus resets to be a minimum of 16 clock cycles.
While I personally find this rather excessive, a long reset is a requirement
of working with their cores, so let’s create this as an option below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> 	<span class="n">OPT_MIN_RESET</span> <span class="o">=</span> <span class="mi">16</span></code></pre></figure>

<p>Finally, we have the formal <code class="language-plaintext highlighter-rouge">F_OPT_FAULTLESS</code> parameter controlling whether or
not we assume the downstream core is faultless or assume nothing of it at all.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="p">,</span> <span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">F_OPT_FAULTLESS</span> <span class="o">=</span> <span class="mb">1'b1</span>
<span class="cp">`endif</span>
	<span class="p">)</span> <span class="p">(</span></code></pre></figure>

<p>I’m going to skip most of the rest of the declarations.  They’re mostly
busy work, with two exceptions.  These are the write fault and read fault
indicators.  These will be set if ever the core detects a downstream fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="kt">output</span>	<span class="kt">reg</span>	<span class="n">o_write_fault</span><span class="p">,</span>
		<span class="kt">output</span>	<span class="kt">reg</span>	<span class="n">o_read_fault</span><span class="p">,</span></code></pre></figure>

<p>The idea is that you should be able to trigger an <a href="/blog/2017/06/08/simple-scope.html">internal logic
analyzer</a> based upon
one (or both) of these signals, so you can then catch, see, and debug whatever
it is that is going on.</p>

<p>From there, we’ll skip past our register declarations to the
write address <a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>.
<a href="/blog/2019/01/12/demoaxilite.html">As you may remember</a>,
handling high throughput (i.e. 100% throughput) within an AXI channel requires
a <a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>.  We’ve used
them in each of our AXI slave designs, and this one is no different.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">DW</span><span class="p">(</span><span class="n">AW</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
<span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
		<span class="p">,</span> <span class="p">.</span><span class="n">OPT_PASSTHROUGH</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">)</span>
<span class="cp">`endif</span>
	<span class="p">)</span> <span class="n">awskd</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">,</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">,</span>
		<span class="n">S_AXI_AWVALID</span><span class="p">,</span> <span class="n">S_AXI_AWREADY</span><span class="p">,</span> <span class="o">{</span> <span class="n">S_AXI_AWPROT</span><span class="p">,</span> <span class="n">S_AXI_AWADDR</span> <span class="o">}</span><span class="p">,</span>
		<span class="n">awskd_valid</span><span class="p">,</span> <span class="n">awskd_ready</span><span class="p">,</span> <span class="o">{</span> <span class="n">awskd_prot</span><span class="p">,</span> <span class="n">awskd_addr</span><span class="o">}</span><span class="p">);</span></code></pre></figure>

<p>The unique feature of this
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>
is that I’ve set the passthrough option for any formal proof.</p>

<p>Why?</p>

<p>This keeps me from needing to re-verify the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a> when
verifying
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axilsafety.v">this core</a>.</p>

<p>It’s actually a touch worse than that.  Not only would I need to reverify the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>, I’d also
need to adjust all of my accounting below based upon what’s in it.  Bypassing
it for our formal proof just simplifies the proof.  I do this commonly for my
AXI proofs–it just simplifies things.</p>

<p>You may remember from our <a href="/blog/2020/03/08/easyaxil.html">Easy
AXI-Lite</a>
<a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/easyaxil.v">example core</a>
discussion how we generated an <code class="language-plaintext highlighter-rouge">axil_write_ready</code> signal?  We’ll do something
similar here, although here we can treat each channel independently.</p>

<p>In this case, we can accept any request from up stream under two conditions.
First, if the slave has faulted or its being reset, then we can only accept
the request if the two channels are aligned and the downstream channel isn’t
stalled, or otherwise if we have more write data requests than write address
requests–at which point it doesn’t matter if the downstream is stalled or not.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">)</span>
		<span class="n">awskd_ready</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_aw_greater</span><span class="p">)</span>
			<span class="o">||</span><span class="p">((</span><span class="n">aw_zero</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">));</span></code></pre></figure>

<p>Otherwise, if everything is going well, then whether or not we accept a
write address request depends upon whether or not the downstream write address
channel is busy or not.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span>
		<span class="n">awskd_ready</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_AWVALID</span> <span class="o">||</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span><span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">aw_full</span><span class="p">);</span></code></pre></figure>

<p>The downstream write address valid signal is simply set by the upstream
write address signal.  It gets cleared on any reset, and nothing moves if
the downstream channel is ever stalled.  Otherwise we set it based upon the
write address
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>’s control
signals.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">M_AXI_AWVALID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_AWVALID</span> <span class="o">||</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span>
		<span class="n">M_AXI_AWVALID</span> <span class="o">&lt;=</span> <span class="n">awskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">awskd_ready</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_write_fault</span><span class="p">;</span></code></pre></figure>

<p>In general, we want to set the downstream <code class="language-plaintext highlighter-rouge">AWADDR</code> and <code class="language-plaintext highlighter-rouge">AWPROT</code> any time the
downstream channel isn’t stalled.  I make an exception if I’m trying to achieve
low power.  In that case, I’ll set the downstream values to zero when not
used.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="n">M_AXI_AWADDR</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">M_AXI_AWPROT</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_AWVALID</span> <span class="o">||</span> <span class="n">M_AXI_AWREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">M_AXI_AWADDR</span> <span class="o">&lt;=</span> <span class="n">awskd_addr</span><span class="p">;</span>
		<span class="n">M_AXI_AWPROT</span> <span class="o">&lt;=</span> <span class="n">awskd_prot</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>That’s all that’s required for the write address channel–we just forwarded
the upstream data downstream, with a slight adjustment for if a fault had been
detected.</p>

<p>Now let’s move on to the write data channel.  As with the write address channel,
we start with a
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>–also
configured as a passthrough.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">DW</span><span class="p">(</span><span class="n">DW</span><span class="o">+</span><span class="n">DW</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>
<span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
		<span class="p">,</span> <span class="p">.</span><span class="n">OPT_PASSTHROUGH</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">)</span>
<span class="cp">`endif</span>
	<span class="p">)</span> <span class="n">wskd</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">,</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">,</span>
		<span class="n">S_AXI_WVALID</span><span class="p">,</span> <span class="n">S_AXI_WREADY</span><span class="p">,</span> <span class="o">{</span> <span class="n">S_AXI_WDATA</span><span class="p">,</span> <span class="n">S_AXI_WSTRB</span> <span class="o">}</span><span class="p">,</span>
		<span class="n">wskd_valid</span><span class="p">,</span> <span class="n">wskd_ready</span><span class="p">,</span> <span class="o">{</span> <span class="n">wskd_data</span><span class="p">,</span> <span class="n">wskd_strb</span><span class="o">}</span><span class="p">);</span></code></pre></figure>

<p>When should we accept a value from this
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>?  As with
the write address channel, there are two conditions to check.  First, if
either a fault has been detected or the downstream core is in reset, then we’ll
accept a request if either there are more write address requests than write
data requests accepted, or alternatively if we are in sync then only if the
upstream return channel isn’t stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">)</span>
		<span class="n">wskd_ready</span> <span class="o">=</span> <span class="p">(</span><span class="n">aw_w_greater</span><span class="p">)</span>
			<span class="o">||</span> <span class="p">((</span><span class="n">w_zero</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">));</span></code></pre></figure>

<p>If, on the other hand, no fault has been detected, then we can just forward
any address requests downstream whenever the downstream channel is ready
for another data value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">else</span>
		<span class="n">wskd_ready</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WVALID</span> <span class="o">||</span> <span class="n">M_AXI_WREADY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">w_full</span><span class="p">);</span></code></pre></figure>

<p>Let me take a moment to discuss the <code class="language-plaintext highlighter-rouge">w_full</code> flag here, and similarly the
<code class="language-plaintext highlighter-rouge">aw_full</code> flag above.  These flags are required to keep our internal counters
from ever overflowing.  It’s one of those lessons you learn from running an
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
proof that you might miss otherwise.  In order to keep our counters from
overflowing, we need to avoid accepting additional values if ever our counters
might overflow by doing so.</p>

<p>The write address logic and indeed even the write data logic follow the same
form as the similar signals for the write address channel above.  The big
difference is that on any fault, the <code class="language-plaintext highlighter-rouge">WSTRB</code> signal is set to zero–to avoid
(potentially) doing any further damage to a downstream core peripheral in the
case something went wrong.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">M_AXI_WVALID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">M_AXI_WVALID</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WVALID</span> <span class="o">||</span> <span class="n">M_AXI_WREADY</span><span class="p">)</span>
		<span class="n">M_AXI_WVALID</span> <span class="o">&lt;=</span> <span class="n">wskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">wskd_ready</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_write_fault</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="n">M_AXI_WDATA</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">M_AXI_WSTRB</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WVALID</span> <span class="o">||</span> <span class="n">M_AXI_WREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">M_AXI_WDATA</span> <span class="o">&lt;=</span> <span class="n">wskd_data</span><span class="p">;</span>
		<span class="n">M_AXI_WSTRB</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">o_write_fault</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">wskd_strb</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<table align="center" style="float: left; padding: 20px"><caption>Fig 11. Write channels</caption><tr><td><img src="/img/firewall/writechan.svg" alt="" width="320" /></td></tr></table>

<p>Having processed the write address and write data channels, we now turn our
attention to the return data path from the downstream core–the <code class="language-plaintext highlighter-rouge">B*</code> channel.
As before, high throughput requires a
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>.  Normally,
I don’t use a
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a> on the <code class="language-plaintext highlighter-rouge">B*</code>
channel simply because there’s no need to.  Here, however, the <code class="language-plaintext highlighter-rouge">B*</code> channel
is an <em>input</em> to our core when coming from the slave, and hence the need for
the <a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>.  Also,
as before, we bypass it for our formal proof.</p>

<p>There’s another reason for bypassing
the <a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a> here:
internal to the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a> are assumptions
about the incoming logic that might not be valid if the downstream bus doesn’t
follow protocol.  We need to make certain we don’t make those assumptions,
so just setting the passthrough flag on the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a> is no longer
good enough–we actually need to skip it entirely.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="k">assign</span>	<span class="n">bskd_valid</span> <span class="o">=</span> <span class="n">M_AXI_BVALID</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_BREADY</span><span class="o">=</span> <span class="n">bskd_ready</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">bskd_resp</span>  <span class="o">=</span> <span class="n">M_AXI_BRESP</span><span class="p">;</span>
<span class="cp">`else</span>
	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">DW</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="p">)</span> <span class="n">bskd</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">,</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">,</span>
		<span class="n">M_AXI_BVALID</span><span class="p">,</span> <span class="n">M_AXI_BREADY</span><span class="p">,</span> <span class="n">M_AXI_BRESP</span><span class="p">,</span>
		<span class="n">bskd_valid</span><span class="p">,</span> <span class="n">bskd_ready</span><span class="p">,</span>  <span class="n">bskd_resp</span><span class="p">);</span>
<span class="cp">`endif</span></code></pre></figure>

<p>On any write fault, we’ll accept whatever it is the downstream core sends us.
Perhaps that’ll help it flush itself out … before we reset it.  In all other
cases, we read from the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a> only if the
upstream <code class="language-plaintext highlighter-rouge">B*</code> channel isn’t stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_write_fault</span><span class="p">)</span>
		<span class="n">bskd_ready</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bskd_ready</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">);</span></code></pre></figure>

<p>How shall we set the outgoing <code class="language-plaintext highlighter-rouge">B*</code> now that we’ve accepted a response from the
slave?  The form of this follows the generic pattern for (most) AXI
logic.  Reset on reset, and only update everything else if the channel isn’t
stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">S_AXI_BVALID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">S_AXI_BVALID</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>If we can return a value, then on any write fault or downstream reset
we’ll want to set <code class="language-plaintext highlighter-rouge">BVALID</code>.  Notice the checks below for <code class="language-plaintext highlighter-rouge">!aw_zero</code> and
<code class="language-plaintext highlighter-rouge">!w_zero</code>.  These are flags indicating the number of write address or write
data requests we’ve received.  If <code class="language-plaintext highlighter-rouge">aw_zero</code> is true, then we don’t have
an outstanding write data request.  Hence we only return a result if we
have valid write address data <em>and</em> write data.  The other thing to note is that
we’re only returning data at a 50% throughput.  This is to make certain that
our counters stay valid–else we might return too many <code class="language-plaintext highlighter-rouge">BVALID</code>s due to an
off-by-one error.  (Yes, the formal tools helped catch that for me–I wasn’t
seeing it until I was “helped” by the tools.)</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">o_write_fault</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">S_AXI_BVALID</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">aw_zero</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">w_zero</span><span class="p">));</span>
		<span class="k">else</span></code></pre></figure>

<p>Under normal circumstances, we’d return a value any time the slave wants to
return a value.  Only in this case we don’t trust the slave.  Therefore, we
need to explicitly check here for ourselves that the slave has been given both
a write address and a piece of write data before it issued the <code class="language-plaintext highlighter-rouge">bskd_valid</code>
signal–lest we return a response for a request that hasn’t yet been accepted
by the slave.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="n">S_AXI_BVALID</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">downstream_aw_zero</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">downstream_w_zero</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">bskd_valid</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Now we come to one of our first checks for a fault.  The rule is that while
the return channel is stalled, the slave isn’t allowed to change things.
Therefore, let’s keep track of whether or not the slaves <code class="language-plaintext highlighter-rouge">B*</code> channel is
stalled, and if it is whether or not the <code class="language-plaintext highlighter-rouge">BRESP</code> data on that channel changed.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">last_bvalid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">)</span>
		<span class="n">last_bvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">last_bvalid</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_BREADY</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span><span class="p">)</span>
		<span class="n">last_bdata</span> <span class="o">&lt;=</span> <span class="n">M_AXI_BRESP</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">)</span>
		<span class="n">last_bchanged</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">last_bchanged</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">last_bvalid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_BVALID</span>
					<span class="o">||</span> <span class="n">last_bdata</span> <span class="o">!=</span> <span class="n">M_AXI_BRESP</span><span class="p">));</span></code></pre></figure>

<p>We’ll use this later as an indication of having detected a slave error.</p>

<p>Finally, we’ll forward the write acknowledgment from the slave upstream.  In
generall, we’ll just forward upstream whatever the slave returned to us in
the <code class="language-plaintext highlighter-rouge">bskd_resp</code> value.  Well, not quite.  First, on any write fault we’ll
return a slave error.  It doesn’t matter what the slave
returns–if <code class="language-plaintext highlighter-rouge">o_write_fault</code> is ever set, we’ve disconnected ourselves from the
slave.  Everything will return a slave error.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">S_AXI_BRESP</span> <span class="o">=</span> <span class="n">OKAY</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_BVALID</span> <span class="o">||</span> <span class="n">S_AXI_BREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_write_fault</span><span class="p">)</span>
			<span class="n">S_AXI_BRESP</span> <span class="o">&lt;=</span> <span class="n">SLVERR</span><span class="p">;</span></code></pre></figure>

<p>Second, if the slave ever returns an <code class="language-plaintext highlighter-rouge">EXOKAY</code> response then we’ve got a problem.
This is an illegal response from an AXI-lite slave, so we need to convert it
to a legal slave error, <code class="language-plaintext highlighter-rouge">SLVERR</code>, response.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bskd_resp</span> <span class="o">==</span> <span class="n">EXOKAY</span><span class="p">)</span>
			<span class="n">S_AXI_BRESP</span> <span class="o">&lt;=</span> <span class="n">SLVERR</span><span class="p">;</span></code></pre></figure>

<p>Everything else goes through without adjustment.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span>
			<span class="n">S_AXI_BRESP</span> <span class="o">&lt;=</span> <span class="n">bskd_resp</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>That’s it for the write channel.</p>

<p>Now we can turn our attention to the read channel.</p>

<p>As with the write channels, we’ll start with a
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>.  This will
help us maintain 100% throughput through the firewall to the slave.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">DW</span><span class="p">(</span><span class="n">AW</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
<span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
		<span class="p">,</span> <span class="p">.</span><span class="n">OPT_PASSTHROUGH</span><span class="p">(</span><span class="mb">1'b1</span><span class="p">)</span>
<span class="cp">`endif</span>
	<span class="p">)</span> <span class="n">arskd</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">,</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">,</span>
		<span class="n">S_AXI_ARVALID</span><span class="p">,</span> <span class="n">S_AXI_ARREADY</span><span class="p">,</span> <span class="o">{</span> <span class="n">S_AXI_ARPROT</span><span class="p">,</span> <span class="n">S_AXI_ARADDR</span> <span class="o">}</span><span class="p">,</span>
		<span class="n">arskd_valid</span><span class="p">,</span> <span class="n">arskd_ready</span><span class="p">,</span>  <span class="o">{</span> <span class="n">arskd_prot</span><span class="p">,</span> <span class="n">arskd_addr</span> <span class="o">}</span><span class="p">);</span></code></pre></figure>

<p>The ready signal, for reading from the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>, comes in
two parts: on fault and regular–just like we did for the write address ready.
On a fault, we are ready if every we have nothing waiting to be returned and
the return <code class="language-plaintext highlighter-rouge">R*</code> channel isn’t stalled.  Otherwise, if the downstream read
address channel isn’t stalled then we can forward the read address request
downstream.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_read_fault</span><span class="p">)</span>
		<span class="n">arskd_ready</span> <span class="o">=</span><span class="p">((</span><span class="n">r_zero</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">arskd_ready</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARVALID</span> <span class="o">||</span> <span class="n">M_AXI_ARREADY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">r_full</span><span class="p">);</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">ARVALID</code> logic is very similar to the above <code class="language-plaintext highlighter-rouge">AWVALID</code> logic.  On a reset,
either an upstream or a downstream reset, we clear the <code class="language-plaintext highlighter-rouge">AWVALID</code>.  Otherwise,
if the downstream core is ready for a new value then we forward it–but only
if there’s no outstanding read fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">M_AXI_ARVALID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARVALID</span> <span class="o">||</span> <span class="n">M_AXI_ARREADY</span><span class="p">)</span>
		<span class="n">M_AXI_ARVALID</span> <span class="o">&lt;=</span> <span class="n">arskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">arskd_ready</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_read_fault</span><span class="p">;</span></code></pre></figure>

<p>The read address and read protection values can just be copies of what’s in the
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>, forwarded
if ever the downstream read address channel isn’t stalled.  I make an exception
here for the <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code>, as I did above.  If <code class="language-plaintext highlighter-rouge">OPT_LOWPOWER</code> is set then
I’ll clear the address and protection on either a downstream reset or a
downstream fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_LOWPOWER</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_read_fault</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="n">M_AXI_ARADDR</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">M_AXI_ARPROT</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARVALID</span> <span class="o">||</span> <span class="n">M_AXI_ARREADY</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">M_AXI_ARADDR</span> <span class="o">&lt;=</span> <span class="n">arskd_addr</span><span class="p">;</span>
		<span class="n">M_AXI_ARPROT</span> <span class="o">&lt;=</span> <span class="n">arskd_prot</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<table align="center" style="float: right"><caption>Fig 12. Read channels</caption><tr><td><img src="/img/firewall/readchan.svg" alt="" width="320" /></td></tr></table>

<p>Okay, now that we’ve done the read address channel, we can move onto the
read data return channel–what I sometimes call the <code class="language-plaintext highlighter-rouge">R*</code> channel.  As with the
write channels, we’ll place a
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>
on the incoming read data return channel from the slave.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="k">assign</span>	<span class="n">rskd_valid</span> <span class="o">=</span> <span class="n">M_AXI_RVALID</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">M_AXI_RREADY</span> <span class="o">=</span> <span class="n">rskd_ready</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="o">{</span> <span class="n">rskd_resp</span><span class="p">,</span> <span class="n">rskd_data</span> <span class="o">}</span> <span class="o">=</span> <span class="o">{</span> <span class="n">M_AXI_RRESP</span><span class="p">,</span> <span class="n">M_AXI_RDATA</span> <span class="o">}</span><span class="p">;</span>
<span class="cp">`else</span>
	<span class="n">skidbuffer</span> <span class="p">#(.</span><span class="n">DW</span><span class="p">(</span><span class="n">DW</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
	<span class="p">)</span> <span class="n">rskd</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">,</span> <span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">,</span>
		<span class="n">M_AXI_RVALID</span><span class="p">,</span> <span class="n">M_AXI_RREADY</span><span class="p">,</span> <span class="o">{</span> <span class="n">M_AXI_RRESP</span><span class="p">,</span> <span class="n">M_AXI_RDATA</span> <span class="o">}</span><span class="p">,</span>
		<span class="n">rskd_valid</span><span class="p">,</span> <span class="n">rskd_ready</span><span class="p">,</span>  <span class="o">{</span> <span class="n">rskd_resp</span><span class="p">,</span> <span class="n">rskd_data</span> <span class="o">}</span><span class="p">);</span>
<span class="cp">`endif</span></code></pre></figure>

<p>When shall we read a value from this
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>?
On any read fault–just to flush the downstream core as much as possible.
Similarly, we’ll read any time the upstream return channel isn’t stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_read_fault</span><span class="p">)</span>
		<span class="n">rskd_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rskd_ready</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">);</span></code></pre></figure>

<p>We then need to return the read data upstream.</p>

<p>As with the <code class="language-plaintext highlighter-rouge">B*</code> channel, this return path has a specific format in order
to make certain we remain protocol compliant.  1) we reset to zero, and 2)
we only adjust <code class="language-plaintext highlighter-rouge">RVALID</code> when the upstream channel isn’t stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">S_AXI_RVALID</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">S_AXI_RVALID</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>If the upstream channel isn’t stalled, then whether or not we set <code class="language-plaintext highlighter-rouge">RVALID</code>
again splits into two cases.  The first case would be when a read fault
has been detected or if the downstream core is in reset.  (Note, that the
downstream core might be in reset even if there was never any read fault.  The
write channel might have faulted for example.)  If the downstream core is
in a fault or reset condition, then we immediately return any requests, and
return outstanding values but only on every other clock cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">o_read_fault</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">S_AXI_RVALID</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r_zero</span><span class="p">)</span>
					<span class="o">||</span> <span class="p">(</span><span class="n">arskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">arskd_ready</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">S_AXI_RVALID</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">downstream_r_zero</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">rskd_valid</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Why not on every return?  I suppose I could’ve written this core to continue
with 100% throughput even in the presence of a fault.  I would’ve needed to
check whether the count of outstanding values was not just equal to zero, but
also whether or not it was equal to one and a return was being issued.  I’ve
tried to be cleaner and to avoid this double check.  Further, I judge that no
one really cares about speed that much once the core has already faulted.  All
that’s left at that time is failure analysis and limited recovery.</p>

<p>Also, if there’s no fault above, then I set <code class="language-plaintext highlighter-rouge">RVALID</code> on two conditions.
First, the slave must be attempting to return a response, and second only
if the slave has accepted a request.  Note that whether or not the slave
has accepted a request, as captured by the <code class="language-plaintext highlighter-rouge">downstream*</code> counters and flags,
is different from whether or not the bus fault isolator has accepted a
request.  It might be that there’s a request pending for the slave to accept
and the slave returns a value too soon.  We’ll want to detect that here.</p>

<p>That brings us to the contents of the read data return channels.  These
again follow the form of any AXI data channel.  We can only adjust things
if the channel isn’t stalled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_RVALID</span> <span class="o">||</span> <span class="n">S_AXI_RREADY</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>Then, on a fault, we’ll just return zero data–otherwise we’ll return whatever
the slave has requested.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">o_read_fault</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">S_AXI_RDATA</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">S_AXI_RDATA</span> <span class="o">&lt;=</span> <span class="n">rskd_data</span><span class="p">;</span></code></pre></figure>

<p>The read response signal, whether an okay or some kind of error, takes a touch
more work–as did the write response code above.  On any fault, we return
a <a href="https://en.wikipedia.org/wiki/Bus_(computing)">bus</a>
<a href="https://en.wikipedia.org/wiki/Bus_error">error</a>, known to the AXI protocol
as a slave error or <code class="language-plaintext highlighter-rouge">SLVERR</code>.  On the other hand, if there is an outstanding
transaction downstream waiting for a response, then we copy it upstream.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">S_AXI_RRESP</span> <span class="o">&lt;=</span> <span class="n">OKAY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">o_read_fault</span> <span class="o">||</span> <span class="n">rskd_resp</span> <span class="o">==</span> <span class="n">EXOKAY</span><span class="p">)</span>
			<span class="n">S_AXI_RRESP</span> <span class="o">&lt;=</span> <span class="n">SLVERR</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">downstream_r_zero</span><span class="p">)</span>
			<span class="n">S_AXI_RRESP</span> <span class="o">&lt;=</span> <span class="n">rskd_resp</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Our next task is to determine if the slave ever changed an incoming value
while we had the return channel stalled.  This will feed into a read fault
on the next clock if true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">last_rvalid</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_read_fault</span><span class="p">)</span>
		<span class="n">last_rvalid</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">last_rvalid</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_RREADY</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span><span class="p">)</span>
		<span class="n">last_rdata</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">M_AXI_RRESP</span><span class="p">,</span> <span class="n">M_AXI_RDATA</span> <span class="o">}</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_read_fault</span><span class="p">)</span>
		<span class="n">last_rchanged</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">last_rchanged</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">last_rvalid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_RVALID</span>
			<span class="o">||</span> <span class="n">last_rdata</span> <span class="o">!=</span> <span class="o">{</span> <span class="n">M_AXI_RRESP</span><span class="p">,</span> <span class="n">M_AXI_RDATA</span> <span class="o">}</span><span class="p">));</span></code></pre></figure>

<h3 id="counting-outstanding-transactions">Counting Outstanding Transactions</h3>

<p>Did you notice how the logic above depended upon a series of counters to keep
track of how many requests were outstanding?  Let’s flesh those out here.</p>

<p>First, we’d like to keep track of how many requests are outstanding on the
write address channel.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">aw_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">aw_zero</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">aw_full</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">aw_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">aw_zero</span>  <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">aw_full</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span><span class="p">(</span><span class="n">awskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">awskd_ready</span><span class="p">),</span><span class="n">S_AXI_BVALID</span><span class="o">&amp;&amp;</span><span class="n">S_AXI_BREADY</span><span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">aw_count</span> <span class="o">&lt;=</span> <span class="n">aw_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">aw_zero</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">aw_full</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">aw_count</span> <span class="o">==</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">,</span> <span class="mb">1'b0</span> <span class="o">}</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">aw_count</span> <span class="o">&lt;=</span> <span class="n">aw_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">aw_zero</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">aw_count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">aw_full</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>In this case, <code class="language-plaintext highlighter-rouge">aw_zero</code> is a registered copy of <code class="language-plaintext highlighter-rouge">aw_count == 0</code>, and <code class="language-plaintext highlighter-rouge">aw_full</code>
is a registered copy of <code class="language-plaintext highlighter-rouge">&amp;aw_count</code>.  That just helps us reason about these
values above without needing to burden the logic above with doing the
comparison at the time it is used.</p>

<p>You might also wish to note the <code class="language-plaintext highlighter-rouge">case()</code> statement.  A common beginner mistake
is to forget that the two channels, write address request and write response,
are parallel and independent.  They might both accept requests at the same
time, and the <code class="language-plaintext highlighter-rouge">case()</code> statement helps to encode that value properly.</p>

<p>The write data counters have almost the same logic as the write address counters
above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">w_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">w_zero</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">w_full</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">w_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">w_zero</span>  <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">w_full</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span><span class="p">(</span><span class="n">wskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">wskd_ready</span><span class="p">),</span> <span class="n">S_AXI_BVALID</span><span class="o">&amp;&amp;</span> <span class="n">S_AXI_BREADY</span><span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">w_count</span> <span class="o">&lt;=</span> <span class="n">w_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">w_zero</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">w_full</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">w_count</span> <span class="o">==</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">,</span> <span class="mb">1'b0</span> <span class="o">}</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">w_count</span> <span class="o">&lt;=</span> <span class="n">w_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">w_zero</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">w_count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">w_full</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>This core also requires knowing whether or not we’ve received more write
address requests than write data requests and vice versa.  In particular, on a
fault if we’ve ever received more of one request than the other then we need
to balance the two channels out.  Here, we capture that reality.
<code class="language-plaintext highlighter-rouge">aw_w_greater</code> will be true if we’ve ever accepted more write address requests
than write data requests, and vice versa for <code class="language-plaintext highlighter-rouge">w_aw_greater</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">aw_w_greater</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">w_aw_greater</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">aw_w_greater</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">w_aw_greater</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span><span class="p">(</span><span class="n">awskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">awskd_ready</span><span class="p">),</span>
			<span class="p">(</span><span class="n">wskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">wskd_ready</span><span class="p">)</span><span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">aw_w_greater</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">aw_count</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span>  <span class="n">w_count</span><span class="p">);</span>
		<span class="n">w_aw_greater</span> <span class="o">&lt;=</span> <span class="p">(</span> <span class="n">w_count</span>     <span class="o">&gt;</span> <span class="n">aw_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">aw_w_greater</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">aw_count</span>     <span class="o">&gt;</span>  <span class="n">w_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">w_aw_greater</span> <span class="o">&lt;=</span> <span class="p">(</span> <span class="n">w_count</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">aw_count</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>Our read counter is similar to the two write counters above, but otherwise
unremarkable.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r_zero</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r_full</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">r_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r_zero</span>  <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">r_full</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span><span class="p">(</span><span class="n">arskd_valid</span><span class="o">&amp;&amp;</span><span class="n">arskd_ready</span><span class="p">),</span> <span class="n">S_AXI_RVALID</span><span class="o">&amp;&amp;</span><span class="n">S_AXI_RREADY</span><span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">r_count</span> <span class="o">&lt;=</span> <span class="n">r_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">r_zero</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r_full</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r_count</span> <span class="o">==</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">LGDEPTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span><span class="p">,</span> <span class="mb">1'b0</span> <span class="o">}</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">r_count</span> <span class="o">&lt;=</span> <span class="n">r_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">r_zero</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r_count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">r_full</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>When I first wrote this core, my intention was to only use a single set of
counters for outstanding transactions–i.e. the three counters above.  Then
as I got into working with the cores, I realized I needed another set as well.
I needed a set of counters to determine when something was outstanding on the
<em>downstream</em> side separate and independent from the upstream side.  The two
sets of counters could (and would) get out of sync.</p>

<p>Hence, I needed to count outstanding downstream write address transactions,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">downstream_aw_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">downstream_aw_zero</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">downstream_aw_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">downstream_aw_zero</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span><span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_AWREADY</span><span class="p">),</span> <span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BREADY</span><span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">downstream_aw_count</span> <span class="o">&lt;=</span> <span class="n">downstream_aw_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">downstream_aw_zero</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">downstream_aw_count</span> <span class="o">&lt;=</span> <span class="n">downstream_aw_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">downstream_aw_zero</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">downstream_aw_count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>outstanding downstream write data transactions,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">downstream_w_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">downstream_w_zero</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">downstream_w_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">downstream_w_zero</span>  <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span><span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_WREADY</span><span class="p">),</span> <span class="n">M_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_BREADY</span><span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">downstream_w_count</span> <span class="o">&lt;=</span> <span class="n">downstream_w_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">downstream_w_zero</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">downstream_w_count</span> <span class="o">&lt;=</span> <span class="n">downstream_w_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">downstream_w_zero</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">downstream_w_count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>and finally outstanding downstream read transactions.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">downstream_r_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">downstream_r_zero</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_read_fault</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">downstream_r_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">downstream_r_zero</span>  <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">case</span><span class="p">(</span><span class="o">{</span><span class="n">M_AXI_ARVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_ARREADY</span><span class="p">,</span> <span class="n">M_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_RREADY</span><span class="o">}</span><span class="p">)</span>
	<span class="mb">2'b10</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">downstream_r_count</span> <span class="o">&lt;=</span> <span class="n">downstream_r_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">downstream_r_zero</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="mb">2'b01</span><span class="o">:</span> <span class="k">begin</span>
		<span class="n">downstream_r_count</span> <span class="o">&lt;=</span> <span class="n">downstream_r_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">downstream_r_zero</span>  <span class="o">&lt;=</span> <span class="p">(</span><span class="n">downstream_r_count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">end</span>
	<span class="nl">default:</span> <span class="k">begin</span> <span class="k">end</span>
	<span class="k">endcase</span></code></pre></figure>

<p>As I mentioned above, these counters are important for making certain
that no returns are accepted save those which have already been requested.</p>

<h3 id="timeout-checking">Timeout checking</h3>

<p>A very important part of our protocol is counting how long it takes the
downstream channel to respond.  This includes both counting stalls, as in how
long it takes the downstream channel to accept a transaction, as well as
counting how long it takes the downstream channel to reply.</p>

<p>In all cases, a surprising discovery is that these counters <em>must</em> mirror
their counterparts in the 
<a href="/formal/2018/12/28/axilite.html">bus property set</a>.  It
seems as though everytime I tried to get smart and do something different
or better, the proof would fail–so I’ve had to mirror those counters instead.</p>

<p>Let’s start by looking at the write address channel, and here we’ll count
stalls.  We’ll also use the <code class="language-plaintext highlighter-rouge">aw_stall_limit</code> register to capture having reached
the stall limit.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">aw_stall_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">aw_stall_limit</span>   <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>Obviously, if we are in a reset (or fault) condition, we don’t want to count
stalls, so we’ll hold our stall count to zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">aw_stall_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">aw_stall_limit</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>In a similar fashion, if the downstream core is every ready to accept a
write address transaction, or if no write address transaction is pending
and stalled, then we want to clear our counters as well.  Also, in case
this core can only accept a limited number of transactions, then we need to
clear our stall count if ever <code class="language-plaintext highlighter-rouge">BVALID</code> is true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_AWVALID</span> <span class="o">||</span> <span class="n">M_AXI_AWREADY</span> <span class="o">||</span> <span class="n">M_AXI_BVALID</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">aw_stall_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">aw_stall_limit</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>That’s not enough.  We also need to allow that the write address channel might
be stalled if it’s accepted a write address but not yet the associated write
data.  In that case, as before, we’ll clear our stall counter.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aw_w_greater</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_WVALID</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">aw_stall_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">aw_stall_limit</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>In all other cases, we increment our stall counter.  If the new stall counter
will be equal to or greater than our timeout, then we’ve hit our
limit–something we’ll note here and register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="n">aw_stall_counter</span> <span class="o">&lt;=</span> <span class="n">aw_stall_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">aw_stall_limit</span>   <span class="o">&lt;=</span> <span class="p">(</span><span class="n">aw_stall_counter</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">OPT_TIMEOUT</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>We now need to repeat those measures for the write data channel.  In this
case, they’re almost identical to the write address channel above, so we
won’t go through each piece here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">w_stall_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">w_stall_limit</span>   <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">w_stall_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">w_stall_limit</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_WVALID</span> <span class="o">||</span> <span class="n">M_AXI_WREADY</span> <span class="o">||</span> <span class="n">M_AXI_BVALID</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">w_stall_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">w_stall_limit</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">w_aw_greater</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">M_AXI_AWVALID</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">w_stall_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">w_stall_limit</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="n">w_stall_counter</span> <span class="o">&lt;=</span> <span class="n">w_stall_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">w_stall_limit</span>   <span class="o">&lt;=</span> <span class="p">(</span><span class="n">w_stall_counter</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">OPT_TIMEOUT</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Stalls timeouts are only one type of timeout we need to keep track of.  We also
need to know if the slave has accepted a request but isn’t producing a result.
Here, therefore, we look at all the write requests, both data and address,
that have been accepted.  If one is outstanding and <code class="language-plaintext highlighter-rouge">BVALID</code> remains low,
then we increment a timeout counter here as well.  Once it times out, we’ll
raise the write acknowledgement timeout limit hit, or <code class="language-plaintext highlighter-rouge">w_ack_limit</code>,
register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">w_ack_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">w_ack_limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">w_ack_timer</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">w_ack_limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_BVALID</span> <span class="o">||</span> <span class="n">downstream_aw_zero</span> <span class="o">||</span> <span class="n">downstream_w_zero</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">w_ack_timer</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">w_ack_limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span>
	<span class="k">begin</span>
		<span class="n">w_ack_timer</span> <span class="o">&lt;=</span> <span class="n">w_ack_timer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">w_ack_limit</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">w_ack_timer</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">OPT_TIMEOUT</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>The read stall counter mirrors the two write stall counters above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">r_stall_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r_stall_limit</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_read_fault</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">r_stall_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r_stall_limit</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARVALID</span> <span class="o">||</span> <span class="n">M_AXI_ARREADY</span> <span class="o">||</span> <span class="n">M_AXI_RVALID</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">r_stall_counter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r_stall_limit</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="n">r_stall_counter</span> <span class="o">&lt;=</span> <span class="n">r_stall_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">r_stall_limit</span>   <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r_stall_counter</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">OPT_TIMEOUT</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>The read acknowledgment delay counter mirrors the write acknowledgment
delay counter from above as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">r_ack_timer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">r_ack_limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_read_fault</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">r_ack_timer</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r_ack_limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_RVALID</span> <span class="o">||</span> <span class="n">downstream_r_zero</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">r_ack_timer</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">r_ack_limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="n">r_ack_timer</span> <span class="o">&lt;=</span> <span class="n">r_ack_timer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">r_ack_limit</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">r_ack_timer</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">OPT_TIMEOUT</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Now that we have our counters, it’s time to see if we can detect faults.</p>

<h3 id="fault-detection">Fault detection</h3>

<p>The first fault to look for is the write fault.</p>

<p>On a reset, we’ll clear the fault indication.  Similarly, if the downstream
core is reset, and the self reset option is set, then we clear the write fault
indication.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_write_fault</span> <span class="o">=</span><span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">o_write_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_SELF_RESET</span> <span class="o">&amp;&amp;</span> <span class="n">o_write_fault</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">//</span>
		<span class="c1">// Clear any fault on reset</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">o_write_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>That’s how the fault indicator gets cleared.  How shall it be set?</p>

<p>First, if ever the downstream core returns a value for which it hasn’t seen
both a write address and a write data request.  In that case, we set the write
fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">((</span><span class="n">downstream_aw_zero</span> <span class="o">||</span> <span class="n">downstream_w_zero</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">bskd_valid</span><span class="p">))</span>
			<span class="n">o_write_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Second, we’ll have a write fault if any write response is <code class="language-plaintext highlighter-rouge">EXOKAY</code>.  This
is an invalid return on an AXI-lite channel.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">bskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">bskd_resp</span> <span class="o">==</span> <span class="n">EXOKAY</span><span class="p">)</span>
			<span class="n">o_write_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Further, if we ever hit any of our timeouts, then we have a write fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">aw_stall_limit</span> <span class="o">||</span> <span class="n">w_stall_limit</span> <span class="o">||</span> <span class="n">w_ack_limit</span><span class="p">)</span>
			<span class="n">o_write_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>The last possibility is if the <code class="language-plaintext highlighter-rouge">B*</code> return channel values ever changed when
they were supposed to be stalled.  That’s also a write fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">last_bchanged</span><span class="p">)</span>
			<span class="n">o_write_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>That’s all we need to check on the write channel.  If <code class="language-plaintext highlighter-rouge">o_write_fault</code> remains
low, then we know we have a good write channel.</p>

<p>Really, there aren’t that many things to check … for AXI-lite.  (AXI is
harder to check.)</p>

<p>Let’s turn our attention to the read fault detection.  Clearing the read fault
is the same as clearing the write fault above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_read_fault</span> <span class="o">=</span><span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
		<span class="n">o_read_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_SELF_RESET</span> <span class="o">&amp;&amp;</span> <span class="n">o_read_fault</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="c1">//</span>
		<span class="c1">// Clear any fault on reset</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">o_read_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>What might set the read fault?  How about a
response without a prior request.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">downstream_r_zero</span> <span class="o">&amp;&amp;</span> <span class="n">rskd_valid</span><span class="p">)</span>
			<span class="n">o_read_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Returning <code class="language-plaintext highlighter-rouge">EXOKAY</code> is also a fault for an AXI-lite slave.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">rskd_valid</span> <span class="o">&amp;&amp;</span> <span class="n">rskd_resp</span> <span class="o">==</span> <span class="n">EXOKAY</span><span class="p">)</span>
			<span class="n">o_read_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Hitting a timeout is a fault as well, just like the write channel above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">r_stall_limit</span> <span class="o">||</span> <span class="n">r_ack_limit</span><span class="p">)</span>
			<span class="n">o_read_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Finally, if the return values change when they’re supposed to be stalled,
that’s our last write fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">last_rchanged</span><span class="p">)</span>
			<span class="n">o_read_fault</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>That should detect any potential fault condition.</p>

<h3 id="self-reset">Self Reset</h3>

<p>The self reset feature is one of the unique features of my bus fault isolators,
over and above many of the commercial tools.  I find that being able to start
over, without reloading the entire design onto a board again, I can often learn
more about what particular and specific conditions cause a fault.  Indeed, it’s
an important part of debugging for me, so I like having it within my own cores.</p>

<p>If, therefore, we want to reset on error–then let’s take a look at how that’s
done.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_SELF_RESET</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">SELF_RESET_GENERATION</span></code></pre></figure>

<p>I actually have two reset options in this design.  One option uses a counter
to make certain that the reset lasts a particular duration before getting
released.  Let’s examine that one first.  If we insist on a minimum reset
duration of <code class="language-plaintext highlighter-rouge">OPT_MIN_RESET</code>, then we need to count how long we are in reset
to know when we can release from reset.  That’s the purpose of the
<code class="language-plaintext highlighter-rouge">reset_counter</code> and <code class="language-plaintext highlighter-rouge">min_reset</code> flag.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_MIN_RESET</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">begin</span> <span class="o">:</span> <span class="n">MIN_RESET</span>

			<span class="k">initial</span> <span class="n">reset_counter</span> <span class="o">=</span> <span class="n">OPT_MIN_RESET</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">initial</span>	<span class="n">min_reset</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
			<span class="k">begin</span></code></pre></figure>

<p>If we ever come out of reset, then we’ll reset the counter to the minimum
reset duration, and likewise declare that the minimum reset duration hasn’t
(yet) been achieved.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">				<span class="n">reset_counter</span> <span class="o">&lt;=</span> <span class="n">OPT_MIN_RESET</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">min_reset</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Otherwise, if the downstream reset signal is active, then we’ll count down
to zero.  Once we hit zero, we’ve had already had a minimum reset delay, so
we can set <code class="language-plaintext highlighter-rouge">min_reset</code> for the next step of logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
			<span class="k">begin</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">reset_counter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">reset_counter</span> <span class="o">&lt;=</span> <span class="n">reset_counter</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">min_reset</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">reset_counter</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">end</span></code></pre></figure>

<p>Finally, before leaving this section, I stuffed a couple of formal properties
in here.  These are important for passing
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
but they’re also only specific to this generate block.  First, the reset
counter must always be less than the <code class="language-plaintext highlighter-rouge">OPT_MIN_RESET</code> value, and second
that <code class="language-plaintext highlighter-rouge">min_reset</code> shall only be set when <code class="language-plaintext highlighter-rouge">reset_counter</code> has achieved its
zero count.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">reset_counter</span> <span class="o">&lt;</span> <span class="n">OPT_MIN_RESET</span><span class="p">);</span>
			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
				<span class="k">assert</span><span class="p">(</span><span class="n">min_reset</span> <span class="o">==</span> <span class="p">(</span><span class="n">reset_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
<span class="cp">`endif</span>
		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>Of course, if the user hasn’t requested a minimum reset duration, then we’ve
already achieved it whenever we are counting down.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
				<span class="n">min_reset</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>

		<span class="k">end</span></code></pre></figure>

<p>Now that we know when our reset has been active long enough, we know what
we need to in order to create a downstream reset signal.</p>

<p>First, we go into reset if ever the upstream reset becomes active.   Likewise,
we’ll enter the reset condition if ever there’s a read or a write fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">M_AXI_ARESETN</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
			<span class="n">M_AXI_ARESETN</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o_write_fault</span> <span class="o">||</span> <span class="n">o_read_fault</span><span class="p">)</span>
			<span class="n">M_AXI_ARESETN</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Coming out of reset seamlessly is a bit more difficult than entering reset.
In this case, we have to wait for the bus to be idle.  Hence, we now wait
for a time when there are no write address requests, no write data requests,
and no read requests either outstanding or pending in our
<a href="/blog/2019/05/22/skidbuffer.html">skidbuffer</a>s.
At that time, and if the minimum reset duration has been achieved, then we
can release from the downstream reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aw_zero</span> <span class="o">&amp;&amp;</span> <span class="n">w_zero</span> <span class="o">&amp;&amp;</span> <span class="n">r_zero</span> <span class="o">&amp;&amp;</span> <span class="n">min_reset</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">awskd_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wskd_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">arskd_valid</span><span class="p">)</span>
			<span class="n">M_AXI_ARESETN</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">SAME_RESET</span></code></pre></figure>

<p>Of course, if we aren’t set up to reset the downstream core on any error,
then we can just use the upstream reset value to reset our downstream logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">//</span>
		<span class="c1">// The downstream reset equals the upstream reset</span>
		<span class="c1">//</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="n">M_AXI_ARESETN</span> <span class="o">=</span> <span class="n">S_AXI_ARESETN</span><span class="p">;</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>I’ll admit, there’s been more than once when I thought the logic for this
core as listed above had become too complex.  I’d then go back and <a href="/blog/2017/06/12/minimizing-luts.html">count
inputs to each logic
result</a>.
I think I’ve kept them reasonable.  The only things that might be a challenge
would be the counters.  However, FPGA’s often have hardware optimized for
additions and comparisons, so those shouldn’t be a problem–especially since
their widths have been tailored for the precise widths they need.</p>

<h2 id="formal-verification">Formal Verification</h2>

<p>Let’s take a quick look see what it takes to verify this core, remembering
the outline I shared above.</p>

<p>First, we’d need to instantiate our bus property set for the upstream interface.
These are a set of properties we need to meet no matter how we are configured.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="n">faxil_slave</span> <span class="p">#(</span>
		<span class="c1">//</span>
		<span class="c1">// ...</span>
		<span class="c1">//</span>
	<span class="p">)</span> <span class="n">axils</span> <span class="p">(</span>
		<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span>
		<span class="p">.</span><span class="n">i_axi_reset_n</span><span class="p">(</span><span class="n">S_AXI_ARESETN</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="p">.</span><span class="n">i_axi_awvalid</span><span class="p">(</span><span class="n">S_AXI_AWVALID</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="c1">// ... Skipping the rest for brevity</span>
		<span class="c1">//</span>
	<span class="p">);</span></code></pre></figure>

<p>Let’s quickly check our counters.  Remember how we had <code class="language-plaintext highlighter-rouge">aw_*</code>, <code class="language-plaintext highlighter-rouge">w_*</code>, and <code class="language-plaintext highlighter-rouge">r_*</code>
counters, with flags for full and zero?  Let’s make sure those flags are
properly set.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">aw_zero</span> <span class="o">==</span> <span class="p">(</span><span class="n">aw_count</span>  <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">w_zero</span>  <span class="o">==</span> <span class="p">(</span><span class="n">w_count</span>   <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_zero</span>  <span class="o">==</span> <span class="p">(</span><span class="n">r_count</span>   <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>

		<span class="k">assert</span><span class="p">(</span><span class="n">aw_full</span> <span class="o">==</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">aw_count</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">w_full</span>  <span class="o">==</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">w_count</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_full</span>  <span class="o">==</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">r_count</span><span class="p">));</span></code></pre></figure>

<p>As long as there’s been no write fault, our downstream counters should match
their flags as well.  Not only that, but there should be a particular
relationship between the downstream counters and the upstream ones.  This
equality check is a key to passing
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_write_fault</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">downstream_aw_zero</span>  <span class="o">==</span> <span class="p">(</span><span class="n">downstream_aw_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">downstream_w_zero</span>   <span class="o">==</span> <span class="p">(</span><span class="n">downstream_w_count</span>  <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">downstream_aw_count</span> <span class="o">+</span> <span class="p">(</span><span class="n">M_AXI_AWVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
					<span class="o">+</span> <span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">aw_count</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">downstream_w_count</span> <span class="o">+</span> <span class="p">(</span><span class="n">M_AXI_WVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
					<span class="o">+</span> <span class="p">(</span><span class="n">S_AXI_BVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span>  <span class="n">w_count</span><span class="p">);</span>
		<span class="k">end</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_read_fault</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">downstream_r_zero</span>   <span class="o">==</span> <span class="p">(</span><span class="n">downstream_r_count</span>  <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">downstream_r_count</span> <span class="o">+</span> <span class="p">(</span><span class="n">M_AXI_ARVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span>
					<span class="o">+</span> <span class="p">(</span><span class="n">S_AXI_RVALID</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span>  <span class="n">r_count</span><span class="p">);</span>
		<span class="k">end</span></code></pre></figure>

<p>We also need to check that our various counters match the similar counters
within the <a href="/formal/2018/12/28/axilite.html">bus property
set</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">assert</span><span class="p">(</span><span class="n">aw_count</span> <span class="o">==</span> <span class="n">faxils_awr_outstanding</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">w_count</span>  <span class="o">==</span> <span class="n">faxils_wr_outstanding</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">r_count</span>  <span class="o">==</span> <span class="n">faxils_rd_outstanding</span><span class="p">);</span></code></pre></figure>

<p>Finally, we want to make certain that our inequality flags are properly set
as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">assert</span><span class="p">(</span><span class="n">aw_w_greater</span> <span class="o">==</span> <span class="p">(</span><span class="n">aw_count</span> <span class="o">&gt;</span> <span class="n">w_count</span><span class="p">));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">w_aw_greater</span> <span class="o">==</span> <span class="p">(</span><span class="n">w_count</span> <span class="o">&gt;</span> <span class="n">aw_count</span><span class="p">));</span>
	<span class="k">end</span></code></pre></figure>

<p>That should verify all of our logic above.
Indeed, the first half of the proof is now done.  If we now pass,
independent of any properties of the downstream bus, then we’ve proved that
we’ll keep the upstream bus isolated from any problems downstream.</p>

<h3 id="the-second-half-of-the-proof">The Second Half of the Proof</h3>

<p>The other half of the proof is to show that, if the downstream bus behaves,
then no fault will be detected.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">F_OPT_FAULTLESS</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">ASSUME_FAULTLESS</span></code></pre></figure>

<p>Once we come inside the generate block, the first thing we do is incorporate
a set of <a href="/formal/2018/12/28/axilite.html">bus properties</a>
for the downstream link.  These will limit our proof to only those cases
where the downstream link is valid.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">faxil_master</span> <span class="p">#(</span>
			<span class="c1">//</span>
			<span class="c1">// Skipped for brevity</span>
			<span class="c1">//</span>
		<span class="p">)</span> <span class="n">axilm</span> <span class="p">(</span>
			<span class="p">.</span><span class="n">i_clk</span><span class="p">(</span><span class="n">S_AXI_ACLK</span><span class="p">),</span>
			<span class="p">.</span><span class="n">i_axi_reset_n</span><span class="p">(</span><span class="n">M_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_ARESETN</span><span class="p">),</span>
			<span class="c1">//</span>
			<span class="p">.</span><span class="n">i_axi_awvalid</span><span class="p">(</span><span class="n">M_AXI_AWVALID</span><span class="p">),</span>
			<span class="c1">//</span>
			<span class="c1">// Skipped for brevity</span>
			<span class="c1">//</span>
		<span class="p">);</span></code></pre></figure>

<p>Now, with those assumptions from the
<a href="/formal/2018/12/28/axilite.html">bus property set</a>,
our clear and core proof is to prove that no faults will ever be generated.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_write_fault</span><span class="p">);</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_read_fault</span><span class="p">);</span></code></pre></figure>

<p>All that’s left is to make certain we can meet these assertions.</p>

<p>In particular, we need to then assert that we’ll both never time out.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">aw_stall_limit</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">w_stall_limit</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">w_ack_limit</span><span class="p">);</span>

			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">r_stall_limit</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">r_ack_limit</span><span class="p">);</span></code></pre></figure>

<p>We also need to assert that the downstream counters match the identical
ones contained within the
<a href="/formal/2018/12/28/axilite.html">bus property set</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="n">M_AXI_ARESETN</span><span class="p">)</span>
			<span class="k">begin</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">downstream_aw_count</span> <span class="o">==</span> <span class="n">faxilm_awr_outstanding</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">downstream_w_count</span>  <span class="o">==</span> <span class="n">faxilm_wr_outstanding</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">downstream_r_count</span>  <span class="o">==</span> <span class="n">faxilm_rd_outstanding</span><span class="p">);</span>
			<span class="k">end</span>
		<span class="k">end</span></code></pre></figure>

<h3 id="cover-checks">Cover checks</h3>

<p>One of the tricks of building any IP core is making certain that it still does
what it should.  So far, all we’ve done is prove that it doesn’t do what it
shouldn’t, but does it still do what it should?  Specifically, can we pass
data through this core?</p>

<p>So let’s try to <code class="language-plaintext highlighter-rouge">cover()</code> this core doing something interesting.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">WILD_DOWNSTREAM</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">OPT_SELF_RESET</span><span class="p">)</span>
		<span class="k">begin</span></code></pre></figure>

<p>For example, can we reset the downstream bus as desired?  Let’s find out.</p>

<p>First, let’s record if we ever detect a fault–whether a read or write fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">initial</span>	<span class="n">write_faulted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
				<span class="n">write_faulted</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o_write_fault</span><span class="p">)</span>
				<span class="n">write_faulted</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>


			<span class="k">initial</span>	<span class="n">faulted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span><span class="p">)</span>
				<span class="n">read_faulted</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o_read_fault</span><span class="p">)</span>
				<span class="n">read_faulted</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
				<span class="n">faulted</span> <span class="o">=</span> <span class="p">(</span><span class="n">write_faulted</span> <span class="o">||</span> <span class="n">read_faulted</span><span class="p">);</span></code></pre></figure>

<p>Now, let’s check if either fault can send us to a reset condition.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
				<span class="k">cover</span><span class="p">(</span><span class="n">write_faulted</span> <span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">M_AXI_ARESETN</span><span class="p">));</span>

			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
				<span class="k">cover</span><span class="p">(</span><span class="n">read_faulted</span> <span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">rose</span><span class="p">(</span><span class="n">M_AXI_ARESETN</span><span class="p">));</span></code></pre></figure>

<p>Might we ever be in a fault and return a value?  Let’ check for that too.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
				<span class="k">cover</span><span class="p">(</span><span class="n">faulted</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_BVALID</span><span class="p">);</span>

			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
				<span class="k">cover</span><span class="p">(</span><span class="n">faulted</span> <span class="o">&amp;&amp;</span> <span class="n">M_AXI_ARESETN</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RVALID</span><span class="p">);</span></code></pre></figure>

<p>In order to generate the trace shown above in Fig. 7, I needed to see the core
come out of a fault and then complete some number of reads or writes.  Let’s
check for the ability to accomplish more than five writes and more than five
reads following a reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">initial</span>	<span class="n">cvr_writes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_write_fault</span><span class="p">)</span>
				<span class="n">cvr_writes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">write_faulted</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_BVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_BREADY</span>
				<span class="o">&amp;&amp;</span> <span class="n">S_AXI_BRESP</span> <span class="o">==</span> <span class="n">OKAY</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cvr_writes</span><span class="p">)))</span>
				<span class="n">cvr_writes</span> <span class="o">&lt;=</span> <span class="n">cvr_writes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
				<span class="k">cover</span><span class="p">(</span><span class="n">cvr_writes</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">);</span>

			<span class="k">initial</span>	<span class="n">cvr_reads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">S_AXI_ACLK</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_AXI_ARESETN</span> <span class="o">||</span> <span class="o">!</span><span class="n">M_AXI_ARESETN</span> <span class="o">||</span> <span class="n">o_read_fault</span><span class="p">)</span>
				<span class="n">cvr_reads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">read_faulted</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RVALID</span> <span class="o">&amp;&amp;</span> <span class="n">S_AXI_RREADY</span>
				<span class="o">&amp;&amp;</span> <span class="n">S_AXI_RRESP</span> <span class="o">==</span> <span class="n">OKAY</span>
				<span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cvr_reads</span><span class="p">)))</span>
				<span class="n">cvr_reads</span> <span class="o">&lt;=</span> <span class="n">cvr_reads</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
				<span class="k">cover</span><span class="p">(</span><span class="n">cvr_reads</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="k">end</span></code></pre></figure>

<p>Can you think of anything we missed that should be in this cover check?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">endgenerate</span>

<span class="cp">`endif</span>
<span class="k">endmodule</span></code></pre></figure>

<p>That ends this walk through.</p>

<p>Do beware that, should you wish to do this yourself, the devil lies in the
details, and those details are captured by the
<a href="/formal/2018/12/28/axilite.html">bus property set</a>.  Hence,
you should always start with a working and trusted
<a href="/formal/2018/12/28/axilite.html">bus property set</a>.  After
that, the task is fairly easy.</p>

<h2 id="conclusions">Conclusions</h2>

<p>While bus fault isolators have their purposes, they don’t necessarily fit every
application.  In particular, the dual reality that they will increase your logic
usage as well as the latency of your bus tends to make them less than
desirable.  Still, they have certainly earned themselves a place in the
debugging stack.  Use a bus fault isolator when …</p>

<ol>
  <li>
    <p>You have two failing components, and can’t seem to tell which one is truly
at fault</p>
  </li>
  <li>
    <p>Your design locks up, and you can’t figure out why.  In that case, a
bus fault isolator might help you keep a design from locking up, to
the point where you can now do the analysis necessary to find the bug.</p>
  </li>
  <li>
    <p>You need a signal to trigger an <a href="/blog/2017/06/08/simple-scope.html">internal logic
analyzer</a> in order
to find the evidence of the bus fault at issue.</p>
  </li>
  <li>
    <p>You have external hardware that might need to be reset separate from your
design–perhaps due to any partial reconfiguration, perhaps due to a
communications link, who knows?</p>
  </li>
</ol>

<p>Either way you look at it, the bus fault isolator is useful and it has its
place.</p>

<p>Is that why I built these three bus fault isolators?  No.  I built them
because I kept seeing individuals writing into forums wondering why their
AXI based designs weren’t working.  Or, at least that was the first reason.
The second reason was that once I figured out how to build the first one,
the rest of them were kind of fun.</p>

<p>Gasp, did I just admit to enjoying this work?</p>

<p>Lord willing, I’d love to come back to my <a href="https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisafety.v">AXI bus fault
isolator</a>,
and adjust it so it can handle more than one packet at a time.  That, however,
will be a project for not just another day, but perhaps another couple of weeks.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And I sought for a man among them, that should make up the hedge, and stand in the gap before me for the land, that I should not destroy it: but I found none.  (Ez 22:30)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
