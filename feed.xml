<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</description>
    <link>https://zipcpu.com/</link>
    <atom:link href="https://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 29 May 2023 16:51:48 -0400</pubDate>
    <lastBuildDate>Mon, 29 May 2023 16:51:48 -0400</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    <image>
      <url>https://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>Introducing the ZipCPU v3.0</title>
        <description>&lt;p&gt;It’s time to announce a new version of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;:
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; v3.0!&lt;/p&gt;

&lt;p&gt;For reference, here’s how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
development has taken place over the years:&lt;/p&gt;

&lt;h2 id=&quot;zipcpu-v01&quot;&gt;ZipCPU v0.1&lt;/h2&gt;

&lt;p&gt;Way back in the beginning, the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; had four bit opcodes and only
16x16-bit multiplies.  It truly had a very limited instruction set.  That said,
the instruction set design was too limited to be very functional.&lt;/p&gt;

&lt;p&gt;This original instruction set didn’t even last a half a year.&lt;/p&gt;

&lt;h2 id=&quot;zipcpu-v10&quot;&gt;ZipCPU v1.0&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
v1.0, had 32-bit bytes and no octet level access.  If you wanted to read or
write an octet (8bit value) in memory, you needed to read a 32b word, modify
the 8b value within it, and write the 32b word back.&lt;/p&gt;

&lt;p&gt;As a result, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, v1.0, did not
have C library support.&lt;/p&gt;

&lt;h2 id=&quot;zipcpu-v20&quot;&gt;ZipCPU v2.0&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; v2.0 provided 8-bit byte support,
better compiler support, and full C-library support.  The instruction set
also included changes to the supported condition codes as well.&lt;/p&gt;

&lt;h2 id=&quot;now-announcing-zipcpu-v30&quot;&gt;Now: Announcing ZipCPU v3.0&lt;/h2&gt;

&lt;p&gt;The good news is that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
instruction set, as shown in Fig. 1, has not changed as part of this release.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU instruction set and encoding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/nextgen.png&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Although there have been (essentially) no changes to the instruction set
with this release, it feels like everything else associated with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has changed:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;This upgrade started with a core refactor, so that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
could support more than just the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;.  As a
result, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can now support
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;Wishbone&lt;/a&gt;,
&lt;a href=&quot;/zipcpu/2021/04/17/axilops.html&quot;&gt;AXI-Lite&lt;/a&gt;, and &lt;a href=&quot;/zipcpu/2021/09/30/axiops.html&quot;&gt;(full)
AXI&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The new memory interfaces are now bus width independent, allowing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to work on buses larger than 32-bits.  Indeed, it’s since been used on
64-bit and 512-bit buses quite successfully.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The core refactor led to better formal proofs, since the memory components
can now be verified independently.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The DMA has also been rewritten for bus width independence.  This rewrite
provides even more capabilities along the way.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The debug port has been rewritten.  This change is the one really
necessitating a new major release, as it won’t even appear to be backwards
compatible with prior releases.  Instead of two registers, the
rewritten &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
debug port is now accessed via 33 registers: a control
register and one debug register address per each of the 32 internal registers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The companion core configuration file has been replaced by parameter settings
at the CPU wrapper level.  Parameter names have been formalized across
wrappers, so common names configure common capabilities.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; now has &lt;a href=&quot;/zipcpu/2022/07/04/zipsim.html&quot;&gt;its own
simulation infrastructure for CPU level
testing&lt;/a&gt;.
This new infrastructure makes it possible to 1) test multiple configurations
of the CPU, 2) test the CPU in multi-processor environments, 3) verify that
the clock can be stopped and restarted, 4) verify the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; in both
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
and AXI configurations, 5) verify the lock instructions, and 6) verify the
CPU’s new debugging port.  This new simulation infrastructure also includes
the ability to measure test coverage.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In perhaps the only downgrade of capabilities, the NOOP/SIM instructions
NEXIT and SEXIT have lost their ability to exit a simulation with a given
exit code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has the ability to stop its clock if necessary.  Using this outside of the
simulator will likely require hardware level support, so for the time being
this may be a simulation only capability.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Put together, these are enough changes to warrant a new major release.&lt;/p&gt;

&lt;p&gt;Let’s take a moment to discuss these changes.&lt;/p&gt;

&lt;h2 id=&quot;expanding-the-bus&quot;&gt;Expanding the Bus&lt;/h2&gt;

&lt;p&gt;Perhaps the one reason driving this upgrade more than any other was the bus,
both in width and in type.  I needed to test a variety of AXI peripherals I
was building and wanted (needed, really) a CPU that could speak both AXI and
AXI-Lite.  Some of these peripherals required bus sizes wider than 32-bits.
Worse, the prior version of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
core included the memory ports within the CPU core itself forcing the CPU
to be &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; only.&lt;/p&gt;

&lt;p&gt;This proved to be a verification nightmare.  It meant that, in order to verify
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s core functionality, I
needed to verify the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
against every possible memory interface it might have.&lt;/p&gt;

&lt;p&gt;To make matters worse, which memory model the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
used was determined not by parameter, but by macro.  This made the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
harder to configure or adjust in any design.&lt;/p&gt;

&lt;p&gt;The fix was to refactor the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  In
the process, the interfaces to the prefetch, and the interface to the memory
unit, were both standardized as shown in Fig. 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. The ZipCPU's refactored architecture&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tweets/zipcpu/cpu-verification.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; core
was then verified against a pair of formal interface specifications,
as were the instruction fetch and memory units.  This made it possible to
formally verify those units separate from
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; core.&lt;/p&gt;

&lt;p&gt;The refactor wasn’t quite seamless.  &lt;a href=&quot;/zipcpu/2021/09/30/axiops.html&quot;&gt;AXI exclusive
access&lt;/a&gt; required a different
interface to the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; than
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
exclusive access (i.e. bus locking) required.  In
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;, all you need
to do is hold the cycle line high between any two accesses to do any sort of
“read-modify-write” routine.  In AXI, on the other hand, any
“read-modify-write” routine won’t know until the write return whether the
sequence was successful or not.  Then, if the sequence was not successful, the
“read-modify-write” routine needs to be repeated.  To add this new capability,
the core now provides the AXI module the instruction pointer at the beginning
of any “read-modify-write” sequence.  If the “read-modify-write” sequence then
fails, the memory module returns as if it were returning from a “load into the
program counter” access causing a jump to the beginning of the sequence.&lt;/p&gt;

&lt;p&gt;The good news is that, once I had the AXI interface I needed, &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;I could then
test and demonstrate ASIC IP using this
approach&lt;/a&gt;.  As a result, I’ve
used this upgraded &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to test both
a &lt;a href=&quot;https://www.arasan.com/product/xspi-master-ip/&quot;&gt;NOR flash controller&lt;/a&gt;
and a &lt;a href=&quot;https://www.arasan.com/product/xspi-psram-master/&quot;&gt;hyperRAM controller&lt;/a&gt;
using my &lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty board&lt;/a&gt;,
as well as an &lt;a href=&quot;https://www.arasan.com/products/nand-flash/&quot;&gt;ONFI flash
controller&lt;/a&gt; (via simulation only).
This has provided me with the valuable ability of &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;debugging system software
entirely in simulation&lt;/a&gt;–and
thus being able to answer why the device did (or did not) respond as expected.&lt;/p&gt;

&lt;h2 id=&quot;upgrading-the-dma&quot;&gt;Upgrading the DMA&lt;/h2&gt;

&lt;p&gt;Some time ago, someone contacted me to ask if I’d be willing to work with them
to build an “ideal-DMA”.  They had noticed that it seemed like every IP
component they integrated into their SOC required a DMA, and so it felt like
they had DMA’s running all through their SOC.  Wouldn’t it make more sense,
they asked, if we could just build one “better”/”ideal” DMA and not to keep
building all these special purpose DMAs throughout their SOC?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/one-dma.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;No, the deal didn’t go through.  I didn’t have the hours to spare at the time,
and we had some disagreements over the legal terms of working together.
However, this did leave me asking the question, what would constitute an ideal
DMA?&lt;/p&gt;

&lt;p&gt;Then I needed to use &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/peripherals/wbdmac.v&quot;&gt;my
DMA&lt;/a&gt;
with one of these wider bus sizes.  Specifically, I was working on a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/&quot;&gt;project
requiring a 512b bus
width&lt;/a&gt;, and &lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;I use the DMA as part of
the process of loading CPU memory images from flash to RAM in the first
place&lt;/a&gt;.
At this point, my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/peripherals/wbdmac.v&quot;&gt;one-32b-size-fits-all DMA&lt;/a&gt;
just couldn’t connect to the bus.
It &lt;em&gt;needed&lt;/em&gt; to be upgraded.  I no longer had a choice.&lt;/p&gt;

&lt;p&gt;So, let’s think of all the lessons I’ve learned over the last couple of years
using the last DMA.  What would a better DMA look like?  Specifically, a DMA
is designed to move data around without CPU intervention.  What kinds of data
moves are required?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The most obvious requirement is for a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt; type of data move, that
moves memory from one location to somewhere else.  Such a capability needs
to move memory as fast as possible (it &lt;em&gt;is&lt;/em&gt; a DMA, right?), and so it really
needs to use the whole bus width.&lt;/p&gt;

    &lt;p&gt;It also needs octet level alignment in order to be relevant–unaligned
requests need to be expected, and handled appropriately.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What about peripherals?  Consider audio peripherals, for example.&lt;/p&gt;

    &lt;p&gt;A microphone peripheral might capture 16b audio samples, generate an
interrupt after each sample is captured, and then need its sample to be read
and copied to memory.&lt;/p&gt;

    &lt;p&gt;A D/A peripheral might be similar: generating an interrupt whenever it
consumes a sample and needs another.  The DMA should then need to read the
new sample from memory and write it to this peripheral.&lt;/p&gt;

    &lt;p&gt;In both cases, the data source address for the microphone peripheral,
or the data destination address of the speaker, won’t change but the
address in memory will.&lt;/p&gt;

    &lt;p&gt;To make matters worse, the audio peripheral might require 8b or 16b values
which would be packed in memory.  Hence the DMA needs to be able to read
or write less than a full bus word at a time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Years ago, I wrote a controller for an &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboledrgb.v&quot;&gt;RGB based OLED
peripheral&lt;/a&gt;.
I demonstrated the capability of this controller by alternately placing the
Gisselquist Technology logo and my own mug onto the display.  In this case,
the peripheral understood 32b command and data words, but the data had to
be transferred one word at a time.  An interrupt would then tell the CPU
when it was time to transfer the next 32b word.  To use a DMA, the DMA
would need to wait for the interrupt, transfer the next word from memory
to a constant destination address, then wait for the next interrupt again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How about block peripherals?  For example, I have an
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI peripheral&lt;/a&gt;
which allows me access to an SD card via its (optional) SPI interface.  The
peripheral has two 32b data ports for transfers.  Each port leads to a 512B
FIFO, and the controller is expected to ping-pong between the two ports
for speed.&lt;/p&gt;

    &lt;p&gt;Reading from the SD card will fill one of these FIFOs and then trigger
an interrupt.  At that point, a DMA needs to read (many times) from the
same 32b address, form wide bus words together, and then write the results
to memory.&lt;/p&gt;

    &lt;p&gt;Writing to the same FIFO is similar, only the interrupt works in a different
fashion.  The CPU would first call the DMA to transfer a block (typically
512 bytes) of memory to the data port FIFO.  This block would need to be
read at whatever the bus size is, and then packaged into 32bit writes to fill
the FIFO.  Once the transfer is done, the CPU should be interrupted, and
the CPU can then instruct the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI peripheral&lt;/a&gt;
to write the information to the external SD card.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 3. Requirements of an upgraded DMA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/betterdma.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From these requirements alone, what does a good DMA need to do?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(Optinally) Wait on an interrupt before starting any transfer.  Which
interrupt will need to be user selectable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Transfer a given per-interrupt amount, perhaps less than the whole transfer.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Be able to read either 8b, 16b, 32b, or the full bus width at a time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Be able to write either 8b, 16b, 32b, or the full bus width at a time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Accessing peripheral memory may require that the DMA not increment the
source or destination address, whereas accesses to memory will require both
that the source/destination address increment and that accesses may (or may
not) be aligned.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/zipdma/zipdma.v&quot;&gt;new ZipDMA&lt;/a&gt;
now offers all these abilities.  It’s an awesome DMA capability.&lt;/p&gt;

&lt;p&gt;You can see the basic structure of this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/zipdma/zipdma.v&quot;&gt;new
DMA&lt;/a&gt; in Fig. 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. The new ZipCPU DMA's structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/zipdma-blocks.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Requests are made to the DMA, then sent to an FSM.  The FSM then breaks those
DMA requests into chunks.  Remember, unlike AXI,
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; can only operate
in one direction at a time.  Therefore, all operations need to take place in
chunks where data is first read, then written.  In terms of the chunk processing
itself, there’s a memory to stream processor to read data from the bus.  This
will read 8b, 16b, 32b, or the full bus width of data per clock cycle.  Data
are then packed by a gearbox prior to going into a FIFO.  Coming out of the
FIFO, the same data words are now unpacked into the user’s desired transfer
width: 8b, 16b, 32b, or the full width of the bus.  As the final per-chunk step,
this data is placed onto the bus and written.&lt;/p&gt;

&lt;p&gt;The biggest problem with this new capability?  There’s only one ZipDMA.  If
it’s so good that every process needs it, there will be contention for it.
The second biggest problem?  This DMA capability is (currently) a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;em&gt;only&lt;/em&gt; capability.  I don’t (yet) have an AXI version of it.  Further work on
this DMA will
concentrate on making sure all of the various capabilities within it are
properly verified–as I don’t yet have a good set of DMA focused test cases
for that purpose.&lt;/p&gt;

&lt;h2 id=&quot;a-better-debugging-interface&quot;&gt;A Better Debugging Interface&lt;/h2&gt;

&lt;p&gt;The original &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; had only two
registers for its in-hardware debugging interface.  One register could be used
to &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;reset, start, stop, and step the
CPU&lt;/a&gt;.  This same
register could be used to select which internal
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; register the
second register would access.  Reads and writes to this second register would
then either read or update the actual (selected) register within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  While this worked, it didn’t
work well.&lt;/p&gt;

&lt;p&gt;To illustrate the problem, consider Fig. 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Before the update: two round-trips per request&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/slowdbg.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Reading any register from this interface required &lt;em&gt;two&lt;/em&gt; accesses, and therefore
&lt;em&gt;two&lt;/em&gt; round trips through the &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
bus&lt;/a&gt; to the FPGA.&lt;/p&gt;

&lt;p&gt;This interface struggled when I tried to debug
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; programs over my serial port
“&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;”.
The debugger wanted the ability to read all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
registers.  The two register interface then required that I first write the
to the first register, that write then needed to complete, then I would read
the data register, and that read would need to complete, all before I could
move on to reading the second CPU register.  That required two round trip
transactions just to read one register, or sixty four round trip transactions
to read all of the CPU’s registers.  (There are 16 supervisor register and
16 user registers.)&lt;/p&gt;

&lt;p&gt;This could take a long time over a serial port.&lt;/p&gt;

&lt;p&gt;My &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;
has another type of read command: one where you can read multiple sequential
addresses in a row.  This operation only requires sending
the request (read thirty two 32b registers) and then waiting for the results.
There’s no requirement for a round-trip handshake in the meantime.  Instead,
any handshaking is complete once the entire operation is complete.  The
CPU just needed a minor upgrade to provide enough addresses on the bus to do
this.&lt;/p&gt;

&lt;p&gt;You can see how this operation is different in Fig. 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 6. After the update, one request yields all results&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/fastdbg.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Even better, I formalized how the CPU was to respond to accesses.  Debug
register reads shouldn’t need to stop the CPU–that way you can monitor
registers while the CPU is running, at the risk of reading an incoherent set
of registers.  This might be useful to know that the CPU is running, or where
it might be in its processing.  Bus writes, on the other hand, do need to stop
the CPU.&lt;/p&gt;

&lt;h2 id=&quot;upgrading-the-simulation-environment&quot;&gt;Upgrading the Simulation Environment&lt;/h2&gt;

&lt;p&gt;The original &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
purpose was to be absolutely as light on resources as
possible.  However, depending on the project, the “lightest resource” CPU might
have too little power.  I therefore quickly learned that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
would need the ability to expand or adjust its area to fit the available area,
while optimizing the CPU’s speed in that area.  Example configurations might
include whether or not the CPU used caches, or just very simple data accessing
routines, whether the hardware supported multiplies via hardware-specific
DSP elements, whether &lt;a href=&quot;/zipcpu/2021/07/03/slowmpy.html&quot;&gt;an all–RTL
multiply&lt;/a&gt; was required, or
whether the CPU should be built with no capability for multiplies at all.  All
this led to an early on requirement that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; needed to be highly configurable.&lt;/p&gt;

&lt;p&gt;My original approach to all this configurability was to create a separate
configuration file containing a set of macros in it.  The CPU’s configuration
would then depend on if or how those macros were configured.  I also had a
separate project, one I called &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;,
which would be used to test the CPU.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic project&lt;/a&gt;
was a piece of CPU testing software that could then
be used to test whether each of the CPU’s instructions worked.  All of this put
together worked great for testing a single configuration–the one described by
the macro file.  However I kept running into problems where I’d port the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to some piece of hardware or other and it wouldn’t work.  Perhaps I had made
some change some time earlier, and only tested other configurations to prove
that change.  Whatever the cause, I was often left debugging the CPU in
hardware–the one place you don’t want to debug the CPU.&lt;/p&gt;

&lt;p&gt;As it turns out, &lt;a href=&quot;/zipcpu/2022/07/04/zipsim.html&quot;&gt;it takes some engineering thought to build a test
setup that can check all configurations of a highly configurable
CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Version 3.0 of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
comes with such an infrastructure.  &lt;a href=&quot;/zipcpu/2022/07/04/zipsim.html&quot;&gt;I’ve written about
it before&lt;/a&gt;.
It centers around a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/sim_run.pl&quot;&gt;Perl script&lt;/a&gt;
and a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/rtl/sim_testcases.txt&quot;&gt;file describing a series of tests&lt;/a&gt;.
Each test specifies a canned configuration, a piece of CPU software,
and one of two environments: a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/rtl/wb_tb.v&quot;&gt;Wishbone
environment&lt;/a&gt;
and an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/rtl/axi_tb.v&quot;&gt;AXI environment&lt;/a&gt;.
Each test can also include any parameter overrides, so the default environments
can be overridden for the test.  I override these defaults, for example, to
adjust the bus width for non-32bit bus testing.  All told, there are 105 tests
that take just over an hour to run under
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;, or just over five days when
using &lt;a href=&quot;https://steveicarus.github.io/iverilog/&quot;&gt;Icarus Verilog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Simulation testing, however, is perhaps the one place where the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
instruction set is now less capable than before.&lt;/p&gt;

&lt;p&gt;As background, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; had two
special instructions, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instructions, that took specialized
arguments when run in simulation.  In hardware, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instructions turned
into standard no-operation instructions, whereas the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instructions turned
into illegal instructions.  That functionality alone left 22-bits of instruction
space which I could use for additional functionality,
from which I had carved out sub-instructions to write characters or even
register values to the simulation log.  One special instruction would dump the
entire register set.  Another special instruction, encoded as either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEXIT&lt;/code&gt;
(NOOP based) or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEXIT&lt;/code&gt; (SIM based) was supposed to cause the simulation to
end with a given exit code.  It’s this x&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXIT&lt;/code&gt; code’s functionality that’s
been lost.&lt;/p&gt;

&lt;p&gt;The reason had to do with the implementation of these instructions.  They were
originally implemented by the
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;
C++ wrapper, and that wrapper required the ability to take a sneak-peek into the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s internals to know when to
execute these instructions.  This lead to two problems.  First, the instructions
would never work in a more traditional simulator that didn’t have or need such
a wrapper–such as &lt;a href=&quot;https://steveicarus.github.io/iverilog/&quot;&gt;Icarus
Verilog&lt;/a&gt; or a commercial simulator.
The second problem was that the interface used by the wrapper kept changing.
Since the features it depended upon weren’t standard Verilog
but rather depended upon &lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;’s
internals, the interface broke every time
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;
changed its internal data structure.&lt;/p&gt;

&lt;p&gt;In the end, I resolved these problems by rewriting how the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIM&lt;/code&gt;
instructions were handled, and the new rewrite was done entirely in Verilog.
Using Verilog only, I could guarantee that all Verilog compliant simulators
would correctly implement these instructions.  However, I could not properly
implement the exit code requirement of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEXIT&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEXIT&lt;/code&gt; instructions.
Hence, while the CPU has gained the capability of executing NOOP and SIM
instructions under a general purpose Verilog simulator, it has lost the
capability to exit the simulation with a specific exit code.&lt;/p&gt;

&lt;p&gt;In many ways, this is a small price to pay for better interoperability
between simulators, and the ability to simulate/test the CPU under a large
number of configurations.&lt;/p&gt;

&lt;h2 id=&quot;clock-gating&quot;&gt;Clock Gating&lt;/h2&gt;

&lt;p&gt;One of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
goals has always been low-logic.  A truly low logic CPU &lt;em&gt;should&lt;/em&gt; also be able
to be a low-power CPU.  In ASIC designs, low power often means
&lt;a href=&quot;/blog/2021/10/26/clkgate.html&quot;&gt;clock gating&lt;/a&gt;,
and the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has had a plan for
&lt;a href=&quot;/blog/2021/10/26/clkgate.html&quot;&gt;clock gating&lt;/a&gt;
since the beginning.&lt;/p&gt;

&lt;p&gt;Here’s how it works: the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
supports two special modes, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HALT&lt;/code&gt; mode and a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SLEEP&lt;/code&gt; mode.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SLEEP&lt;/code&gt; will
cause the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to stop executing
instructions until the next interrupt.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HALT&lt;/code&gt; causes the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to stop executing instructions
at all, and thus to come to a complete halt until either the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debug port&lt;/a&gt; or an
external reset restarts the CPU.  These modes were originally envisioned to
allow the clock to be stopped by the CPU.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;/blog/2021/10/26/clkgate.html&quot;&gt;clock gating capability&lt;/a&gt;
is now a reality–in simulation at least.&lt;/p&gt;

&lt;p&gt;I’ve also now used
&lt;a href=&quot;/blog/2021/10/26/clkgate.html&quot;&gt;clock gating&lt;/a&gt;
several times, although never in actual
hardware.  The biggest lesson I’ve learned?  The
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debug port&lt;/a&gt;
&lt;em&gt;must&lt;/em&gt; automatically restart the clock to handle requests.  There’s been more
than once when I’ve tried to load a program into the CPU externally from the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging port&lt;/a&gt;,
only to find out later that the reason the CPU was non responsive was
because its clock was stopped.  The next biggest lesson?  Stopping the clock
&lt;em&gt;might&lt;/em&gt; lower simulation time, but this isn’t a given.&lt;/p&gt;

&lt;p&gt;The end result of this work is that the CPU now has a program to test its
ability to stop the clock.&lt;/p&gt;

&lt;h2 id=&quot;profiling&quot;&gt;Profiling&lt;/h2&gt;

&lt;p&gt;There was one more minor update to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, this one having to do with
profiling.&lt;/p&gt;

&lt;p&gt;Yes, I’ve profiled software–mostly benchmarks–running on the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, although only in simulation.
My current approach involves recording, for every instruction in a given
program, both the number of times that instruction was executed and the
number of clock cycles used to execute that instruction.  The resulting data
has done wonders for speeding up the CPU.&lt;/p&gt;

&lt;p&gt;While I’ve been using this data for quite some time, my previous method of
collecting it involved examining
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;’s internal data structures to
access it.  While that has worked in the past, it forces me to update the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; every time
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt; changes
their internal data structures.  (This was the same problem I had with the
simulation only instructions.)  The solution is to create a proper external
port, coming out of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
containing this data.  It’s then there if you want to use it, or it can be
ignored if you do not.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s simulation monitor
program had the same problem, where it was also accessing values internal
to the design.  Such values tend to move or get renamed with
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;
updates.  As with the profiler interface, this is easily solved by generating
proper Verilog ports to the CPU containing references to these values for
the monitor.&lt;/p&gt;

&lt;p&gt;In both cases, I expect my updated solution to handling these values will
need less maintenance as I use (and maintain) the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; over time.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As with any project, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
remains a work in progress.  It will likely remain so for the foreseeable
future.  This is a good thing.  It means the CPU remains supported.&lt;/p&gt;

&lt;p&gt;In the meantime, I’ve now used the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; on a variety of commercial
projects.  I’ve written about some of them.  For example, it’s been used in
a couple of SONAR applications, and I’m now importing it into a
&lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb Ethernet switch&lt;/a&gt;
application.  I’ve also used it to test, via both simulation and hardware,
pre-ASIC IP cores.  (I.e. IP cores designed for ASICs, but tested in FPGAs
first.)&lt;/p&gt;

&lt;p&gt;At present, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has two
drawbacks that I’d still like to address in the future.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;It still doesn’t have a memory management unit (MMU) to give it access to
virtual memory.  Worse, the MMU I designed years ago for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is now abandonware.  It needs to be rebuilt.  Since all of the internal
interfaces have changed between the core and the memory components, the
MMU’s required interfaces have changed as well.  Worse, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s core infrastructure may
also need to be adjusted so that it can handle page faults.  For example,
what happens in a compressed instruction if the second half of the
instruction suffers from a page fault?  At present, compressed instructions
do not need to be, and therefore cannot be restarted mid-instruction.&lt;/p&gt;

    &lt;p&gt;This upgrade will be required before I can truly run Linux on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The good news is that I don’t have any applications that require such an MMU
at present.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Although the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports AXI,
it doesn’t really do so by the book.  AXI is, by the book,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little endian&lt;/a&gt;
whereas the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; remains a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt;
machine.  Yes, it now has options to run in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little endian&lt;/a&gt;
fashion, but the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little endian&lt;/a&gt;
options within the tool chain haven’t been
tested, and so I have no confidence that they will work.  What this means
is that bytes within words are mis-ordered when using AXI.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
will still write byte zero to bits [31:24], and byte one to bits [23:16]
and so forth.&lt;/p&gt;

    &lt;p&gt;This has lead me to no end of troubles when testing AXI IP that is properly
ordered.  Not only that, but I now have an optimized software routine for
byte-reordering–a patch, written instead of a proper upgrade.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’ve imagined a third upgrade over the years as well: adding a floating point
capability to the CPU.  Moreover, I’ve reserved several instruction op-codes to
support 32-bit single precision floating point operations.  In hindsight,
however, I’m not sure to what extent I would use these instructions even if I
did implement them.  I don’t normally use &lt;em&gt;single&lt;/em&gt; precision floating point.
I default to using &lt;em&gt;double&lt;/em&gt; precision floating point.  Not only that, but the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
will never be a hard core floating point processing machine.  It just
doesn’t fit that role.  It will always be better as a fixed point system.
Hence, floating point is no longer one of my goals for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This v3.0 release also marks the first time the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has synthesized (with caches) on a Kintex-7 device with &lt;em&gt;200MHz clock&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Yes, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has been well used (by me), and remains well loved.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Every man's work shall be made manifest: for the day shall declare it, because it shall be revealed by fire; and the fire shall try every man's work of what sort it is.  (1Cor 3:13)&lt;/em&gt;</description>
        <pubDate>Mon, 29 May 2023 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2023/05/29/zipcpu-3p0.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2023/05/29/zipcpu-3p0.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>What is a Virtual Packet FIFO?</title>
        <description>&lt;p&gt;I first came across virtual packet FIFOs in a &lt;a href=&quot;/blog/2022/04/29/proto-bringup.html&quot;&gt;SONAR
project&lt;/a&gt; by necessity.
The &lt;a href=&quot;/blog/2022/04/29/proto-bringup.html&quot;&gt;SONAR device&lt;/a&gt;’s
only means of communicating with the outside world was
via Gb Ethernet.  There was no
&lt;a href=&quot;/formal/2019/02/21/txuart.html&quot;&gt;UART&lt;/a&gt; and no JTAG.
Everything went over Ethernet.  Collected data went over Ethernet.
Device control was over Ethernet.  &lt;a href=&quot;/blog/2022/08/24/protocol-design.html&quot;&gt;Debugging had to be done over
Ethernet&lt;/a&gt;.  FPGA
reconfiguration and all software updates had to go over Ethernet.  Last of
all, the CPU needed to talk to the outside world over Ethernet.  This was
where I first came up with the idea of a virtual packet FIFO.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. A Virtual Packets FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/pktvfifo.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The idea came from necessity, given how &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/enet/enetpackets.v&quot;&gt;my previous network
controller&lt;/a&gt;
operated.  In &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/enet/enetpackets.v&quot;&gt;that
controller&lt;/a&gt;,
packets would be received into a small block RAM connected the controller.
That block RAM could hold only one packet at a time.  Once a packet was
received, therefore, the network controller would be deaf until the CPU
processed the packet and then notified the controller it could use its
memory for another packet.  Likewise, when the CPU wished to transmit a
packet, it would write a single packet to the controller’s memory, notify
it that a packet was present, and then wait for the controller to finish
transmitting it before writing the next packet to memory.&lt;/p&gt;

&lt;p&gt;This works great–on a low bandwidth interface.  But what happens if two
packets arrive in short succession?  Or, similarly, what happens if
packets arrive that are larger than the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/enet/enetpackets.v&quot;&gt;controller’s internal
buffer&lt;/a&gt;?
What about “Jumbo packets”?&lt;/p&gt;

&lt;p&gt;All of these problems necessitated a new solution, and the solution I chose was
a virtual packet FIFO.  This solution has two big upgrades to the previous
one.  The first is a size upgrade.  A virtual packet FIFO can be &lt;em&gt;much&lt;/em&gt; larger
than its block RAM counterpart.  The second upgrade is the number of packets
that can be held.  Frankly, it doesn’t make much sense if you can hold
lots of data, if you can’t also fill that with either lots of packets or
a small number of jumbo packets.&lt;/p&gt;

&lt;p&gt;Since this is a neat idea, let’s take a moment and discuss it.&lt;/p&gt;

&lt;h2 id=&quot;packet-streams&quot;&gt;Packet streams&lt;/h2&gt;

&lt;p&gt;Some time ago, I discussed &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;the problems with the AXI stream
protocol&lt;/a&gt;.
At the time, I based my discussion on three specific applications:
&lt;a href=&quot;/video/2022/03/14/axis-video.html&quot;&gt;video&lt;/a&gt;,
&lt;a href=&quot;/blog/2019/11/14/sdspi.html&quot;&gt;data capture&lt;/a&gt;, and network
packet handling.  In each of these applications, data would arrive at the
incoming interface independent of whether or not there was space available
to handle it.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;Backpressure&lt;/a&gt;, a
key feature of the AXI stream protocol, could not be supported properly
without risking data corruption.&lt;/p&gt;

&lt;p&gt;At that time, &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;I suggested a new AXI stream field:
ABORT&lt;/a&gt;.
If the &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt; signal
was ever asserted from an upstream source, the rest of any data packet
would need to be dropped, and data handling would need to start over with
the first beat of the next packet.  This new
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;
signal has worked nicely in network packet handling constructs.  Indeed, it
has worked &lt;em&gt;very&lt;/em&gt; well.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Yes, it’s a bit harder to work with and harder to verify than straight AXI
streams.  This is to be expected.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;However, it was joy to watch the network design “just work” with this
protocol.  In particular, I watched network data get captured, formed
into packets, and then dropped as the design started up–because either
the network interface hadn’t finished its negotiation into 1Gb mode
(it could never keep up at less than 1Gb/s), or because the data hadn’t
been told where to go yet.  (Yes, it still needed a destination addresses
for the SONAR data, both IP and Ethernet, before it could send it out.)&lt;/p&gt;

    &lt;p&gt;Once configuration completed, the protocol started blasting captured
packets without a hitch.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I loved it!&lt;/p&gt;

&lt;p&gt;Others, however, have argued that my proposed
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;
field was unnecessary.  Why create a new protocol, they argued, vs. just using
straight AXI stream?  The answer to this is twofold:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Jumbo_frame&quot;&gt;Jumbo Frames&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;In order to use straight AXI stream, you have to first convert the incoming
network packet to AXI stream in the first place.  The follows simply because
that incoming network interface doesn’t know anything about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;.
To do this conversion, incoming packets need to first go into a buffer.
If there’s not sufficient space in the buffer, the packet is simply dropped.
If there’s sufficient space, the packet is “committed” and can then be read
out of the buffer via standard AXI stream.&lt;/p&gt;

    &lt;p&gt;The size of this buffer forces a limit on the maximum packet size that can
be handled.  Packets larger than the buffer size will need to be dropped.&lt;/p&gt;

    &lt;p&gt;While I was designing the original SONAR Ethernet controller, my customer
asked about &lt;a href=&quot;https://en.wikipedia.org/wiki/Jumbo_frame&quot;&gt;jumbo
frames&lt;/a&gt;–packets much larger than
the (otherwise) maximum
Ethernet packet size of 1500 Bytes.  How much larger?  They didn’t say.
All of a sudden, I could no longer size my buffer prior to hardware
layout (place and route).&lt;/p&gt;

    &lt;p&gt;The Virtual Packet FIFO we’ll discuss today can solve this problem of
converting an (otherwise) unsized packet to AXI stream proper.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Vendor Infrastructure&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;If I used Xilinx (or any other vendor’s) AXI stream infrastructure, I might
be tied to that protocol.  The choice of whether or not to use AXI stream
is really a business decision: either rebuild the AXI stream infrastructure
from scratch to support a modified protocol, or stick to the AXI stream
protocol as is.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: right&quot;&gt;&lt;caption&gt;Fig 2. Advantages to using your own IP&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/personal-ip.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If I rebuild the infrastructure from scratch, I incur additional costs
   above and beyond what I might have incurred had I used someone else’s
   (free) infrastructure.  I can release any IP I build under my chosen user
   license.  I can also formally verify anything I build.  I will also gain
   the ability (and responsibility, and cost associated with) debugging and
   maintaining it.  The good news, though, is that I can guarantee the quality
   of any IP I control.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: left&quot;&gt;&lt;caption&gt;Fig 3. Advantages to using vendor IP&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/vendor-ip.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If I use a vendor’s infrastructure then I might save some money–while
   risking my project’s success on the vendor’s responsiveness to bugs found in
   their infrastructure.  Given that I’m aware of bugs that’ve lived in Xilinx
   IP for nearly 10 years, and given that I’m a small one-man nobody shop, I
   don’t have a strong confidence that they’ll fix anything that’s broken.&lt;/p&gt;

&lt;p&gt;Yes, I suppose this is a business decision.&lt;/p&gt;

&lt;p&gt;Frankly, I don’t use vendor infrastructure unless I have to.  It’s just the
   nature of how I’ve structured my own business at &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
   Technology&lt;/a&gt;.
   I’ve now built &lt;a href=&quot;/about/zipcpu.html&quot;&gt;my own CPU&lt;/a&gt;, my own
   GNU compiler and assembler back ends, &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;my own bus
   interconnects&lt;/a&gt;,
   &lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;my own DSP filters&lt;/a&gt;,
   &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDICs&lt;/a&gt;,
   &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFTs&lt;/a&gt;, etc.  So it should come
   as no surprise that I’d have no problems building &lt;a href=&quot;https://github.com/ZipCPU/eth10g/tree/master/rtl/net&quot;&gt;an AXI stream
   infrastructure&lt;/a&gt; based
   around a new “&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;”
   field.&lt;/p&gt;

&lt;p&gt;Yes, there are risks with this approach.  One common risk is that I might
   need to interface with a vendor protocol, so I often have &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;conversion
   routines&lt;/a&gt; available to move back and
   forth between one protocol and another when necessary.  For example, it’s
   not enough to use
   &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; if you need
   to interact with Xilinx’s MIG–so I use a &lt;a href=&quot;/blog/2020/03/23/wbm2axisp.html&quot;&gt;bridge from one protocol to the
   other&lt;/a&gt;.  I &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;also
   have&lt;/a&gt; sufficient infrastructure to
   use AXI without bridges if necessary.&lt;/p&gt;

&lt;p&gt;Still, AXI stream is a really simple protocol, and &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;this modified AXI
   network stream
   protocol&lt;/a&gt;,
   while more complex, isn’t really that much more difficult to deal with.&lt;/p&gt;

&lt;p&gt;Since writing &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;that
article&lt;/a&gt;, I’ve had great
success with this new
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt; field.
Indeed, I’ve had so much success, that I’m now rebuilding all of my network
data handling components to use it.&lt;/p&gt;

&lt;p&gt;However, there is one (more) problem this &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;new
protocol&lt;/a&gt; needs
to address: stream widths.&lt;/p&gt;

&lt;p&gt;When working with 1Gb Ethernet, I could operate at 8b/clock at 125MHz, and
stream widths weren’t really a problem–every beat contained exactly one byte.
Well, not quite.  Stream widths became a bit of a problem when crossing clock
domains, since I would need to guarantee sufficient handling width.  To
handle the CDC case, I first converted to a wider (32b) AXI stream, and
then prepended a 32b packet length to the packet.  This kept me from
supporting &lt;a href=&quot;https://en.wikipedia.org/wiki/Jumbo_frame&quot;&gt;jumbo frames&lt;/a&gt;,
so when rebuilding for a 10Gb interface, I needed a new solution.&lt;/p&gt;

&lt;p&gt;Standard AXI stream solves this problem with their TSTRB and TKEEP fields.
Each field has one bit per byte per beat within it, and allows the stream
processor to handle less than a full beat of information.  For example, when
dealing with a 32-bit interface, a 16-bit value might contain two NULL bytes,
where a NULL byte is defined as one where TKEEP and TSTRB are both low.&lt;/p&gt;

&lt;p&gt;This seemed insufficient for me for a variety of reasons.  In general, to use
an AXI stream of this type, you’d first want to pack it and remove all
NULL bytes.  This would force any unused bytes into the last beat, while also
requiring that the last beat had at least one valid byte.  The last beat would
also need to be packed, so that all used bytes would be on the low end–when
using little endian semantics, or the high end otherwise.  Further, I never
saw a reason for keeping “position” bytes (TKEEP &amp;amp;&amp;amp; !TSTRB) around.  The
result was that TKEEP and TSTRB contained too many bits for my purpose.&lt;/p&gt;

&lt;p&gt;So I created a new field: BYTES.  At first, the BYTES field had &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$clog2(DW/8+1)&lt;/code&gt;
bits to it, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW&lt;/code&gt; is the number of bits in the DATA field–sometimes
called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C_AXIS_DATA_WIDTH&lt;/code&gt;.  This BYTES field would then be equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt;
for every beat prior to the last one, and between one and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt; inclusive for
the last beat.  (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 &amp;lt; BYTES &amp;lt;= DW/8&lt;/code&gt;)  Then, on second thought, I realized the
top bit of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYTES&lt;/code&gt; was irrelevant: Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYTES&lt;/code&gt; was never zero, and never
more than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt;, I could map the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt; value to zero and drop a bit.  So,
now, BYTES has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$clog2(DW/8)&lt;/code&gt; bits and a value of zero (representing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt;
bytes) for all but the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LAST&lt;/code&gt; beat where it might represent fewer bytes per
beat.&lt;/p&gt;

&lt;p&gt;So, in summary, to support packet data I made the following changes to the
AXI stream protocol:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;&lt;/strong&gt;: A new
field, indicating that the upstream processor needed to drop the packet
for any reason.  Possible reasons I’ve come across include: 1) CRC errors,
2) protocol errors, 3) hardware errors, or even 4) insufficient memory
for handling &lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;,
from downstream.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TKEEP/TSTRB&lt;/strong&gt;: I dropped both of these fields.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BYTES&lt;/strong&gt;: A new field to replace the TSTRB/TKEEP fields, while still
indicating how many bytes are active in a given beat.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;And, of course, all beats are fully packed.  Hence, all but the LAST
beat will have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt; valid bytes in it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’ve named &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;this (new) protocol the AXI-networking, or AXIN,
protocol&lt;/a&gt;, for lack
of a better name.  As a result, if you look through &lt;a href=&quot;https://github.com/ZipCPU/eth10g/tree/master/rtl/net&quot;&gt;the designs I’ve built
to use this protocol&lt;/a&gt;,
you’ll find “AXIN” in a lot of the names.&lt;/p&gt;

&lt;p&gt;I also have a lot of infrastructure for this new protocol, and that
infrastructure is growing on a daily basis.  For example, I have AXIN
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netskid.v&quot;&gt;skidbuffers&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;asynchronous&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt;s,
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinbroadcast.v&quot;&gt;broadcasters&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinarbiter.v&quot;&gt;arbiters&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;width
converter&lt;/a&gt;,
and more.  (A CRC checker is still being verified, but will likely be posted
soon.)&lt;/p&gt;

&lt;p&gt;This brings us to the topic of virtual FIFOs.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-virtual-fifo&quot;&gt;What is a virtual FIFO?&lt;/h2&gt;

&lt;p&gt;A virtual FIFO is simply a FIFO that uses external instead of internal memory.
That external memory is typically accessed via a bus, shared among many
potential users, and commonly exists off-chip.  A classic example would be a
DDR3 SDRAM memory accessed via an AXI (or
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;) bus.  You can
see the difference between a traditional and a virtual FIFO in Fig. 4.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: right&quot;&gt;&lt;caption&gt;Fig 4. Difference between a FIFO and a Virtual FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/fifo-comparison.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Some time ago, I built a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v&quot;&gt;Virtual FIFO for the AXI
protocol&lt;/a&gt;.  The
flow went as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first step was to &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L486-L490&quot;&gt;buffer a burst of data&lt;/a&gt;
into a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt;.  To work
smoothly, the &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt; needed
space for at least two AXI bursts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once a full burst’s worth of data was available in the &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L486-L490&quot;&gt;local
FIFO&lt;/a&gt;,
that data would be &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L486-L490&quot;&gt;burst to the AXI
bus&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;When using &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;,
I’d do the same thing, save that the burst would only
end after the incoming FIFO was completely drained.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L409-L427&quot;&gt;Once BVALID was then received&lt;/a&gt;,
we would know that a full AXI burst’s
worth of memory was now available in the external RAM to be &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L681-L735&quot;&gt;read
back&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;In the case of
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;,
I’d count data words, not burst sizes, but it’s the same principle.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There was again another (local, block RAM) &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt; on the read
memory side.  Like the first FIFO, &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L788-L796&quot;&gt;this
one&lt;/a&gt;
also required enough room to contain at least two AXI bursts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once a burst’s worth of data has been placed into the external RAM, &lt;em&gt;and&lt;/em&gt;
there is sufficient (uncommitted) data in the second FIFO to hold it,
a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L681-L735&quot;&gt;burst read request would be issued&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Again, when using
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;,
I’d make requests until the entire FIFO’s size was committed–not just the
initial burst size.  Hence, as reads might be made from the FIFO while
requesting data from the bus, additional reads would be made.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data read back from memory would then get sent straight into &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L788-L796&quot;&gt;this second
buffer&lt;/a&gt;
once it returned from the bus.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final, outgoing AXI stream, would then be fed &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L786&quot;&gt;straight from this
second buffer&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only when the incoming FIFO is full would
&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;,
attempt to slow down the upstream source.&lt;/p&gt;

    &lt;p&gt;The incoming FIFO would be “full” if it wasn’t getting emptied.  This
would happen if either 1) &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L535-L536&quot;&gt;the memory was full&lt;/a&gt;,
or 2) the &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L540-L541&quot;&gt;FIFO couldn’t write to memory fast
enough&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Success, when using this technique, required that the stream bandwidth be
less than 50% of the memory bandwidth.  This will often require that any stream
necessitating a high throughput might first need to be resized to a wider
width–just to reduce the throughput to something the memory can handle.
Remember, when sizing memory bandwidth, there are lots of things that can
use up your bandwidth:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 5. Calculating memory bandwidth&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/mem-bw.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need bandwidth for the data to come in and get written to memory&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need that much again to read the data back out&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need to allocate time for bus latency.&lt;/p&gt;

    &lt;p&gt;This can be worse for any bus that needs to stop in order to switch
directions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A memory can only read or write on any given clock cycle, and also needs
a couple cycles to switch from reading to writing and back again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t forget, you’ll also need to allocate some number of memory clock
cycles for refresh.  How many cycles will be required here depends upon
your memory, your bus structure, and whether or not your memory allows
pulling refresh cycles or whether such pulled cycles are supported in your
controller.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Xilinx’s MIG controller also uses a couple of clock cycles per refresh
to keep it’s IO PLL locked on the memories DQS strobe signal(s).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll also need memory bandwidth for everything else that might use the
memory.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In short, &lt;em&gt;it depends&lt;/em&gt;.  The best way to size memory bandwidth requirements is
to calculate how many beats per second you will need, and then make sure
your memory can support perhaps four times that amount.&lt;/p&gt;

&lt;p&gt;A key problem with the standard virtual FIFO, described above, is that there’s
no (good) way to store non-data information such as packet boundaries in
memory.  Either you increase the memory storage requirement to hold a LAST bit
(often by 2x!), or it just gets dropped.  Indeed, my &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v&quot;&gt;basic AXI virtual
FIFO&lt;/a&gt;
implementation simply drops this data.  As a result, it works well on a
proper &lt;em&gt;stream&lt;/em&gt; interface, but not very well on a &lt;em&gt;packet&lt;/em&gt; interface.&lt;/p&gt;

&lt;p&gt;I have a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/memscope.v&quot;&gt;separate virtual FIFO that I’ve built for my
&lt;em&gt;scope&lt;/em&gt;&lt;/a&gt;,
sometimes called an internal logic analyzer.  (This one’s been formally
verified, but never used in any practical context.  It was fun to build, and
a good learning exercise, it just hasn’t fit into any important usage
scenarios … yet.)  In this case, if the
&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;scope&lt;/a&gt;
ever gets overrun and can’t keep up, all the data will be dropped
and it will start collecting all over again with new data.&lt;/p&gt;

&lt;p&gt;Again, the problem with the stream protocol is
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;&lt;/em&gt;,
and what to do if you overrun the FIFO, and where/when in your stream processing
will that information be known.  When dealing with packets, the rule
is data needs to be dropped at packet boundaries.  That information needs
to be communicated to the place where the decision can be made.&lt;/p&gt;

&lt;p&gt;So how do we mix the &lt;em&gt;packet&lt;/em&gt; concept with the concept of a &lt;em&gt;virtual FIFO&lt;/em&gt;?
The answer is a virtual packet FIFO.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-virtual-packet-fifo&quot;&gt;What is a virtual packet FIFO?&lt;/h2&gt;

&lt;p&gt;A virtual packet FIFO is simply a virtual FIFO that maintains packet
boundaries.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Virtual FIFO definitions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/vpktdefns.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That means two things.&lt;/p&gt;

&lt;p&gt;First, it means we have to preserve packet boundaries.  That &lt;em&gt;LAST&lt;/em&gt; signal
is important when working with packets.  Moreover, packet boundaries need
&lt;em&gt;octet&lt;/em&gt; level precision.&lt;/p&gt;

&lt;p&gt;Second, it means that packets are written to the FIFO before being
&lt;em&gt;committed&lt;/em&gt; to the FIFO.  Only after a full packet has been written to
the FIFO can it ever get committed.&lt;/p&gt;

&lt;p&gt;To handle both of these requirements, I rearranged how I stored packets
in memory.  Instead of storing packet data alone, or packet data plus a LAST
bit, or packet data plus some number of ancillary bits (TSTRB, TKEEP, TUSER,
and TLAST), I store the length of the packet &lt;em&gt;before&lt;/em&gt; the packet.&lt;/p&gt;

&lt;p&gt;Fig. 6 shows this pictorally.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: right&quot;&gt;&lt;caption&gt;Fig 6. Virtual packets in memory&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/vpktmem.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Specifically:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;All packet length fields precede the packet they describe.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All packet lengths are 32’bits.  Yes, this is an arbitrary length.
However, 1) this seems to be the smallest bus size I’ve ever needed to work
with.  2) I rarely have more than 4GB of memory, so this seems sufficient.
3) It allows for jumbo packet sizes up to whatever memory size I have on hand.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also force a minimum 32-bit alignment on all accesses.  So, for a 128-bit
wide bus, this word will be aligned on a 32-bit boundary.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Before a packet is committed, its packet length shall be NULL.  (i.e. 32’h0)
You can think of this like the NULL pointer at the end of a linked list.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The packet data is written to memory using the full width of the bus.&lt;/p&gt;

    &lt;p&gt;In the context of the &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb Ethernet switch&lt;/a&gt;
I’m working on, maintaining memory throughput is important.  As a result, I
need to use the full memory width (512 bits) as often as possible.  Anything
less would reduce my memory bandwidth.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If ever a packet gets dropped, the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;packet
writer&lt;/a&gt;
just goes back to the beginning of the packet data area and starts over
following the NULL packet length word when the next packet starts.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Packets can be dropped for any upstream reason.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Packets are also dropped if the virtual packet FIFO runs out of room.&lt;/p&gt;

        &lt;p&gt;This is a necessary criteria to prevent a deadlock created if the upstream
source never needs to abort, and yet there’s no room in memory to hold
the last of the packet in memory.&lt;/p&gt;

        &lt;p&gt;In order to support packet length pointers, a packet may not be completed
unless there’s room for both the packet length before and the packet
length of the packet to follow.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As I mentioned, I’m now working on building a Virtual Packet FIFO.  It hasn’t
yet been verified, or I’d present the entire FIFO here.  For now, let me point
out the three major components and discuss how they work together:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;There’s the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;Controller&lt;/a&gt;,&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;, and&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You may expect these components to change as they eventually get verified,
and then tested and proven in hardware.  (As of today, only the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;
has passed a formal check, and even that check didn’t properly include the
&lt;a href=&quot;/formal/2020/06/12/four-keys.html&quot;&gt;contract&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Let’s discuss each of these components briefly.&lt;/p&gt;

&lt;h3 id=&quot;the-virtual-packet-fifo-controller&quot;&gt;The Virtual Packet FIFO Controller&lt;/h3&gt;

&lt;p&gt;The controller is responsible for setting the base address and memory size
allocated to the virtual FIFO.  These two values are then propagated down to
both &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;.
It’s also responsible for resetting the FIFO, and (depending on the
configuration) releasing it from reset.&lt;/p&gt;

&lt;p&gt;Even though this is only my second virtual packet FIFO, I’ve already had several
diverse needs for this controller.  In one design, the controller was given a
fixed memory allocation.  This is appropriate if the controller is required to
start up and operate without any CPU intervention.  In another design, the CPU
could allocate memory for the FIFO and then enable or disable the FIFO.  When
I can’t decide which of the two I want, sometimes I will generate a combination
of the two, so that the FIFO may start with a default allocation that the CPU
can come back to and adjust later if necessary.&lt;/p&gt;

&lt;p&gt;What happens if the CPU gives it a bad allocation?  One of the challenges of
controller design is determining how the virtual packet FIFO should handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt;.
In general, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; indicates
that the FIFO has a bad memory allocation.  This might be the case if the
CPU has allocated memory to the FIFO that isn’t present in the system.  In
this case, it makes the most sense for the FIFO to shut down with some type of
error condition, and to then wait for the CPU to correct its memory allocation.
On the other hand, if the CPU will get its instructions for “fixing” any faults
from the network, then the network must be able to heal itself without any
CPU intervention.&lt;/p&gt;

&lt;p&gt;A similar problem might be generated by the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
if it ever comes across an invalid packet length word.  Such a packet length
migth be equal to zero, greater than the total size of the allocated memory,
or perhaps just big enough to pass the write pointer.&lt;/p&gt;

&lt;p&gt;In both of these cases, either a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; or an invalid
packet length, there should be an appropriate way to fix the situation.
In a hands-off implementation, the FIFO will need to just reset
itself–hopefully in that case memory allocation issues will be handled before
implementation.  In another case, the FIFO will wait for the CPU to issue a
new address before releasing itself from reset.  The same could be done with
the read packet length, or alternatively the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;packet
reader&lt;/a&gt;
might just skip to where the write pointer is at–skipping any packets in the
way.&lt;/p&gt;

&lt;p&gt;Which method of resolving faults is appropriate depends upon the particular
design requirements.&lt;/p&gt;

&lt;h3 id=&quot;the-write-state-machine&quot;&gt;The Write State Machine&lt;/h3&gt;

&lt;p&gt;Once the base address and memory size are known, and once the FIFO has been
released from reset, incoming packets may be written to memory.&lt;/p&gt;

&lt;p&gt;This takes place in several discrete steps.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, prior to any packet, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L397-L423&quot;&gt;the packet’s length word must be written as
zero&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then, as packet data enters the FIFO, its data &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L424-L464&quot;&gt;gets written directly to
memory&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Unfortunately, the 32-bit packet length word guarantees that further writes
to memory can not be guaranteed to have any particular alignment.  Incoming
data must then be &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L450-L457&quot;&gt;realigned as it is written to memory&lt;/a&gt;.
This also means that there may need to be &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L483-L488&quot;&gt;N+1 memory writes for
every N memory words&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;A second problem here is associated with the data pointer.  Specifically,
pointers wrap.  Hence, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L226-L237&quot;&gt;any calculation of the next memory
address&lt;/a&gt;
must include &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L232-L234&quot;&gt;a check against the last memory address, and a wrap back
to the first address if it passes the end of
memory&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Finally, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L461-L462&quot;&gt;this is the only place where committed memory space is
checked&lt;/a&gt;.
If a packet uses all of the available memory space, not just the remaining
memory space, then it must be aborted locally.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On any packet &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;s,
the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L435-L440&quot;&gt;write pointer is set to follow the prior NULL
length&lt;/a&gt;.  On a local
packet &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;, such
as might take place if the packet overflowed memory, then we need to
resync to the beginning of the next packet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once a packet is complete, the next word becomes the length field of the
next packet.  &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L495-L523&quot;&gt;It is set to
NULL&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;After this next word has been set to NULL, the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;FIFO
writer&lt;/a&gt;
can then &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L524-L557&quot;&gt;go back and write the length of the current (just written) packet
into memory&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This is what actually commits the packet to memory.  We can know the
packet has been committed once all bus requests have been completed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once the bus becomes idle, we tell the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L579&quot;&gt;our new start-of-packet pointer&lt;/a&gt;
and go back to step #2 above to handle the next packet.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All of this is handled via a (monster) state machine that can master the bus.&lt;/p&gt;

&lt;h3 id=&quot;the-read-state-machine&quot;&gt;The Read State Machine&lt;/h3&gt;

&lt;p&gt;Once a packet is committed, a second state machine can then read the packet
back from the bus.  (This one still needs a lot of verification work …)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
reads the length word from memory.&lt;/p&gt;

    &lt;p&gt;Knowing when to read this length word is a bit of a problem.  Were this a
piece of CPU software, we might poll this memory word.  If the memory word
was ever non-zero, we’d know a packet was present.  However, this design is
intended for a hardware implementation.  Hardware can poll memory on every
clock cycle, so much so that the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;
wouldn’t have any cycles left to write the packet to memory.  To prevent
this, we’d need to specify a polling interval, which would then increase our
latency.  Supporting minimum latency requires a different solution.&lt;/p&gt;

    &lt;p&gt;My solution to this problem has been to use an out-of-band communication
scheme through the controller.  In this scheme, the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;
tells the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
a pointer to the length word of the last packet committed.  If this address
doesn’t match the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;’s
last memory address, then a packet is present that may be read.
In another version of this FIFO, one with the CPU in the middle, the CPU
provides the reader with the same pointer.  Again, this tells the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
when it’s safe to go and read the packet length counter for the next packet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once returned, the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
then verifies the packet length word.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;It’s not allowed to be zero.&lt;/li&gt;
      &lt;li&gt;The packet length may not pass the write pointer.  This would indicate
a memory overrun condition.&lt;/li&gt;
      &lt;li&gt;The packet length must be less than the size of memory.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;On any failure, we can either reset the entire FIFO, or (alternatively) just
drop all packets between our current location and the write pointer.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the length pointer is good, we start reading from memory.&lt;/p&gt;

    &lt;p&gt;There are two challenges with this task.  The first challenge is that
the memory will (in general) be misaligned.  The second challenge is that
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; has no
concept of &lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;,
and our outgoing stream interface may require it.&lt;/p&gt;

    &lt;p&gt;To handle misalignment, we need to keep track of the previously read
memory word.  That, plus the current memory word, both shifted
appropriately, we’ll yield an outgoing stream word.  The trick is that
we may need to read an additional word to get all of the outgoing
stream data associated with this packet.&lt;/p&gt;

    &lt;p&gt;The way to handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt; when using
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; is to
guarantee that we don’t issue a read request in the first place unless
there’s space available in the following outgoing FIFO for a packet word.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One of the nice things about the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;,
is that we don’t need to generate any
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;s.  That’s
a pleasant simplification.  Indeed, at this point in our return processing, we
could finally handle (infinite)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt; if need be.&lt;/p&gt;

&lt;h3 id=&quot;a-new-interconnect&quot;&gt;A New Interconnect&lt;/h3&gt;

&lt;p&gt;One piece I wasn’t expecting in this new architecture was an updated/better
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As perspective, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;this virtual packet
FIFO&lt;/a&gt;, is
designed to support a &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb, 4-way Ethernet
switch&lt;/a&gt;.  That means I want to be able to
support 10Gb arriving (and departing) on each of the 4 interfaces at the same
time.  When using our planned hardware, the memory will run on a 200MHz clock,
reading (or writing) 512-bits (64-bytes) of data per clock cycle.  However, a
10Gb Ethernet switch will generate one 512-bit word every 51.s ns, or (roughly)
once every 11 clocks at 200MHz.  Hence, when the interface is running full
speed, we’ll be getting requests from rotating controllers.  The first
controller might want a beat, but then not need anything for another 10 beats
while the second controller wants a beat, etc.&lt;/p&gt;

&lt;p&gt;Typically, I run
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; in a fashion
where I burst data to the bus (i.e. to memory) and then wait for the response
before shutting the interface down.  When using Xilinx’s MIG, this can take
up 20 clock cycles of latency.  If I did that here, I’d never have enough
memory bandwidth to keep up.&lt;/p&gt;

&lt;p&gt;My solution to this problem is to use a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/wbmarbiter.v&quot;&gt;special type of
interconnect&lt;/a&gt;–one
I first developed for an AXI project.  When using &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/wbmarbiter.v&quot;&gt;this
interconnect&lt;/a&gt;, N
masters may request bus accesses of a single slave.  In this case, as each bus
master makes its request, the master’s ID is placed in a FIFO.  Since
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; requests are
always returned in the order they are received, I can then use this FIFO to
route responses back to the appropriate master.  This will allow me to
interleave requests from multiple masters together on their way to memory.&lt;/p&gt;

&lt;p&gt;That’s the good news–more bandwidth.  The bad news is that this N:1 arbiter
will break &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; in
two ways.  First, since there’s no guaranteed concept of the end of a
transaction, there’s no way to know when to lock the bus.  Second, as I
implement &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; terminates any ongoing
transaction.  This means that if N masters are active and only one of those
masters receives a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;–in
response to some erroneous transaction, then all
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; masters will
receive a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; in return to
their ongoing operations.  For now, this will work: 1) these virtual packet
FIFOs will not be locking the bus, and 2) any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt; should be rare or
even non-existent.  Still, it’s a risk, and I’ll need to make sure it’s
well documented throughout the project.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;This is now the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;second virtual packet FIFO I’ve
created&lt;/a&gt;.
If any design becomes so useful that you need to build it more than once,
then it’s going to become useful again.&lt;/p&gt;

&lt;p&gt;In this case, this &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;virtual packet
FIFO&lt;/a&gt; will
play an important part of the &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb Ethernet
switch&lt;/a&gt;) I’m working on.  As packets arrive
from the PHY, their CRC’s will be validated, their &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;stream width
expanded&lt;/a&gt;,
they’ll then &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;cross clock
domains&lt;/a&gt;,
their source MACs will recorded in the router, and they will enter &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;this virtual
packet FIFO&lt;/a&gt;.
Once these packets come out of
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;the FIFO&lt;/a&gt;,
the’ll go into a separate &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt;, have
their destination MACs checked, get routed to an outgoing interface, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;cross
clock domains&lt;/a&gt;
(again), have &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;their widths
adjusted&lt;/a&gt;
back to the interface width, and finally get blasted out the network.  Feel
free to check out
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/doc/eth10g-blocks.png&quot;&gt;this picture&lt;/a&gt; to see
an overview of this entire operation, as well as the status of the various
components required of this project.&lt;/p&gt;

&lt;p&gt;For now, however, the project is still draft.  The hardware, while drafted,
isn’t yet built and I’m still working on the RTL components within it.
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15/&quot;&gt;Lord willing&lt;/a&gt;,
I’ll have the RTL done by the time the hardware is available.&lt;/p&gt;

&lt;p&gt;Still, the overall concept of a Virtual Packet FIFO was one I felt would
be worth sharing.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;There is that scattereth, and yet increaseth; and there is that withholdeth more than is meet, but it tendeth to poverty.  (Prov 11:24)&lt;/em&gt;</description>
        <pubDate>Sat, 08 Apr 2023 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2023/04/08/vpktfifo.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2023/04/08/vpktfifo.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>What is a SwiC?</title>
        <description>&lt;p&gt;Central to the motivation behind the development of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is the concept of a System within a Chip (SwiC).  As I’m now preparing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; for a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/79a3f19a8ab8b7786319c71019700e86f5918075&quot;&gt;version
3.0&lt;/a&gt;
release, it’s worth revisiting this concept to see what it means and then to
compare that with how the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has been used in practice.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A SwiC consists of a small CPU within a chip&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/swic-concept.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I have defined a SwiC to be a small soft-core CPU within a chip, but
specifically where the CPU is neither the purpose of the chip nor the main
application within it.  Key to this definition is the requirement that the
purpose of the chip is not the CPU nor the application the CPU is supporting,
but rather that the CPU is more incidental to the application.&lt;/p&gt;

&lt;p&gt;Today, I’d like to examine this concept of a SwiC in light of the many years of
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
application and development, to see how well it (or any other CPU for that
matter) lives up to this concept.&lt;/p&gt;

&lt;h2 id=&quot;the-initial-motivation-for-the-zipcpu-gps&quot;&gt;The initial motivation for the ZipCPU: GPS&lt;/h2&gt;

&lt;p&gt;The initial application that motivated the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
was that of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
correlator.  A &lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
correlator consists of a data feed coming from an Analog to Digital Converter
(A/D), possibly entering via a DMA to memory, and correlation outputs–perhaps
even going as far as soft-bit outputs.  The hardware in this case is is
centered on the correlator.  The correlator just reads and then correlates the
data in memory with the spreading code of a GPS satellite.  It requires several
logic &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFTs&lt;/a&gt; and a lot of internal
memory, together with whatever glueware is required to connect them
all together.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 2. Controlling a GPS correlator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/gps-correlator.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;An example of one such correlator is shown in Fig. 2 on the left.&lt;/p&gt;

&lt;p&gt;So where does the CPU fit in?&lt;/p&gt;

&lt;p&gt;My original plan for the CPU was to have it control which satellite’s ranging
code would be loaded into the correlator, together with estimating which
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt; offsets to search.&lt;/p&gt;

&lt;p&gt;Determining which satellites to correlate against and which
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt; offsets to check
requires a CPU.  The CPU takes an estimate of where the system thinks the user
is on the ground, together with a coarse estimate of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ephemeris&quot;&gt;ephemerides&lt;/a&gt; for each
of the satellites in the constellation.  It then uses this information to
determine first which satellites are in view, and then second what
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt;
shifts can be expected from each of them.  The better the CPU can do this
task, the fewer correlations that need to be checked and so the sooner the
correlators will lock on to the various satellite signals.  Once lock has been
achieved, the CPU will continue to look for new satellites that might be in
view, and estimate what their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt; offsets would be
given the receiver’s known location.&lt;/p&gt;

&lt;p&gt;Sure, this task could be offloaded to an external CPU.  But what about the
task of loading the coefficients and setting things up given the satellite
number and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt; estimate?&lt;/p&gt;

&lt;p&gt;Handling nuisance tasks like this isn’t a major portion of the design logic,
but it is a necessary part.  Further, since the CPU exists, it can also be
used to coordinate reporting and the control of the DMAs to move data around.
It could even be used to take the correlation estimates and turn them into
positions, but in my world that was always handled externally by a full
featured processor.&lt;/p&gt;

&lt;p&gt;This is where I came up with the idea of a SwiC: it’s a small, disadvantaged
computer, occupying a minor portion of a chip which is devoted to another task
entirely.&lt;/p&gt;

&lt;p&gt;As an added benefit to starting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
project, the hardware required for a minimal CPU is also going to be minimal
and even cheap.  In contrast, the hardware required for the correlators
wouldn’t be cheap at all–especially since the algorithm I wanted to implement
was block RAM limited.  Indeed, it may have required a
&lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;–something I couldn’t
afford at the time, which kept the project from getting off the ground.
The CPU hardware on the other hand?  That would definitely form the cheaper
part of the project.  Indeed, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
even demonstrated its ability to run a small Operating System on a $60 Spartan
6 LX4 (smallest Spartan 6).  This made it easier to justify the business end of
getting started–but I’m getting ahead of myself.&lt;/p&gt;

&lt;h2 id=&quot;properties-of-a-swic&quot;&gt;Properties of a SwiC&lt;/h2&gt;

&lt;p&gt;A SwiC, therefore, must be a small CPU.  It must be small enough that it can
be added to a design as an after thought.  Ideally, it shouldn’t significantly
impact the logic or area requirements of the design, simply because it uses so
few resources.&lt;/p&gt;

&lt;p&gt;That’s the most basic requirement: it must be small.&lt;/p&gt;

&lt;p&gt;Must it be fast?  Not necessarily, although faster is usually better.&lt;/p&gt;

&lt;p&gt;Must it be low power?  Maybe, maybe not.  Again, that depends on your
requirements.&lt;/p&gt;

&lt;p&gt;Like all CPUs, however, a SwiC must be a bus master and it must be able
to communicate with the environment around it.  It must also be responsive
to &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupts&lt;/a&gt; that
may be generated by the application handler.  For example, an interrupt might
tell the CPU that one round of correlation processing had completed.&lt;/p&gt;

&lt;p&gt;These are then the minimum requirements: 1) a small 2) bus master, that is 3)
responsive to &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupts&lt;/a&gt;.
Further requirements may insist that it be 3) fast and/or 4) low power, but
these are more ancillary than core requirements.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Mandatory interfaces&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/barecpu.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;After that, however, the requirements of a CPU in general start to dominate
the problem space.  To see how this is so, let’s start at the top.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Instruction memory&lt;/p&gt;

    &lt;p&gt;A CPU, by definition, processes instructions in a serial manner.  Therefore
a SwiC, like any CPU, must have access to memory containing instructions.
These instructions are generally constant, so one may often assume the
instruction stream is kept in a ROM.&lt;/p&gt;

    &lt;p&gt;Sadly, there are enough exceptions to this rule to keep it from being
absolutely true.  For example, programs must be loaded, updated, and
modified over time.  It may also be advantageous to move the instruction
memory from an offline storage such as an SD Card into an accessible
memory.  A ROM therefore is a good approximation, but only an approximation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data memory&lt;/p&gt;

    &lt;p&gt;A CPU also needs the ability to store and process data in some kind of RAM.
This means the CPU must have access to a read and writable memory
somewhere, and not just the ROM containing the instructions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Application peripherals&lt;/p&gt;

    &lt;p&gt;Finally, the CPU needs to interact with the part of the design it was
intended to control.  These are application specific peripherals that
may exist in some designs and not in others.  Optionally, these
peripherals may generate
&lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupts&lt;/a&gt;
that the CPU is required to process.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This might leave you imagining a small bare bones CPU, such as the one shown
in Fig. 3 above.&lt;/p&gt;

&lt;p&gt;At least, that’s what you might imagine before you try implementing such a CPU.&lt;/p&gt;

&lt;p&gt;Reality starts to look more like Fig. 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 4. Mapping the SwiC to hardware&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/naiive-flash.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s start with how we might go about implementing the instruction memory.
Marrying these requirements to commodity FPGA hardware lends to placing
the instruction memory into
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt;.
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;Flash memory&lt;/a&gt;
tends to be slow, but generally abundant for these purposes.  The problem with
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt; is that
you need a way to program it before activating the CPU.  My general solution
to this problem has been to add a second bus master to any system, something
I call a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;.
This bus master can then access the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt; to program
it.  As a bonus, the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging bus master can also reach into and control
and/or debug the CPU
itself&lt;/a&gt;.
That’s actually important, since the CPU needs to be kept from accessing the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt;
while it is being programmed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;Flash memory&lt;/a&gt;,
however, won’t pass for data memory.  While it is easy to read from, it is
hard to write to.  So we’ll still need some data memory.  Worse, unlike
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt; where the
common 16MB size is typically more than enough, a CPU’s data memory usage can
quickly expand beyond the capability of any nearby memory.  For example, while
the standard C library can greatly simplify working with a CPU, that same
standard C library may require a minimum of 16kB of memory, and often something
closer to 64kB of memory.  Over the course of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
lifetime, this data memory has been provided by
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/0d7b428abe5c9a02d86a0272e290baafae00f13f/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/sramdev.v&quot;&gt;SRAM&lt;/a&gt;, an
&lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/599d5fa02975c693849bb138995b15800d8a36e8/rtl/arrowzip/wbsdram.v&quot;&gt;external SDRAM&lt;/a&gt;,
or even an external DDR3 SDRAM–all depending on the development board hosting
the design.  That leaves us with a minimal system having two bus masters, the
debugging bus and the CPU, and a minimum of three items on the bus: the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;,
data memory, and any application peripherals.&lt;/p&gt;

&lt;p&gt;Adding the application peripherals only makes this worse: we now need a &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;bus
interconnect&lt;/a&gt; that can handle
two bus masters and three or more peripherals.  Many applications also require
access to memory as well, via some form of automated memory transfer or more.
All of these accesses need to be arbitrated.  Hence, a CPU must now have a
general purpose
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;bus interconnect&lt;/a&gt;–something
not necessarily obvious from our minimum requirements above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Minimum SwiC system&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/minsystem.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When implementing the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, there has
been a small set of peripherals that also keep coming up over and over again.
Fig. 5 on the right shows an example setup including many of these common
peripherals.  The first of these is a console port, by which a user can
communicate with the CPU.  The second is a set of &lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;single bit input or output
wires, what I call a GPIO
peripheral&lt;/a&gt;.
The next two important peripherals are one or more
&lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timers&lt;/a&gt; and an
&lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That means that our simple CPU from Fig. 3 above has now become a much more
complicated design component, even more than Fig. 4 suggested, as shown in
Fig. 5.&lt;/p&gt;

&lt;p&gt;This also means that any minimum CPU can quickly become much more than the
bare minimum CPU we started our outline from.&lt;/p&gt;

&lt;h2 id=&quot;examples-of-the-vision&quot;&gt;Examples of the Vision&lt;/h2&gt;

&lt;p&gt;Now that you know the initial application that motivated the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
let’s take a moment and look at some other applications.  I’ll start this list
off with a set of applications I’ve come across where a SwiC, such as the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, might do nicely.  Then, in the
next section, we’ll discuss the reality of how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has actually been used.
Let’s start with the exceptionally simple.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;PLL controller&lt;/p&gt;

    &lt;p&gt;Some time ago, a user asked on Xilinx’s forums what the easiest way would
to control a PLL with an AXI4 interface.  A kind helper replied that the
easiest way to control a PLL on chip would be with an AXI4 input driven
by a MicroBlaze computer.&lt;/p&gt;

    &lt;p&gt;Herein lies the problem of the SwiC:  A simple SwiC having 20-100
instructions might’ve solved the problem nicely.  However, if the SwiC needs
access to RAM, &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;,
and an &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;,
then … it might have been easier just to drive the PLL with a &lt;a href=&quot;/blog/2021/12/30/dbgaxil.html&quot;&gt;simple
state machine&lt;/a&gt;
instead of a full blown CPU.  Still, a small SwiC might’ve solved this
problem nicely–even if it was a bit of overkill for the problem.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this level, the SwiC competes with a state machine, and a good state machine
will easily use less area.  However, a good SwiC will only need to be written,
simulated, and verified once in order to know it might properly drive a PLL.
Still, the advantage here goes to the state machine.  Once you need to drive
many dissimilar peripherals, or alternatively once the interaction becomes
sufficiently complex, then a single SwiC might start to make sense again.&lt;/p&gt;

&lt;p&gt;What other uses might one find for a SwiC?&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Power Controller&lt;/p&gt;

    &lt;p&gt;Digilent sells a &lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;small color OLEDrgb PMod&lt;/a&gt;,
suitable for drawing any small image on it.
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;This OLEDrgb&lt;/a&gt;,
however, has some very specific timing requirements associated with when the
various power rails of the OLEDrgb chip within it need to be turned on.
Once the power rails had been turned on properly, the
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;OLEDrgb&lt;/a&gt;
then needed to be configured via a long string of SPI commands.&lt;/p&gt;

    &lt;p&gt;In a system with a hardware
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;OLEDrgb&lt;/a&gt;
controller, a small CPU could easily manage this power sequence, followed
by the required initialization sequence before getting out of the way
of the rest of the hardware.&lt;/p&gt;

    &lt;p&gt;Yes, a state machine might have worked as well.  However, if you have a
state machine to control your PLL, and another one to control your
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;OLEDrgb&lt;/a&gt;s
power and startup SPI, then the cost of the separate areas for these
separate state machines, and the cost of there respective memory areas, will
soon start adding up.  At some point, the SwiC becomes a cheaper
solution–especially if it can be kept small, and kept from dominating the
rest of the design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;Flash memory&lt;/a&gt; startup
handler&lt;/p&gt;

    &lt;p&gt;Many of my &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash controller
designs&lt;/a&gt; begin the
interaction with the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt; using &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/b75249d6db61db041008a2a8eafcd62aa0f1d0b5/rtl/qflexpress.v#L388-L751&quot;&gt;a small
startup script&lt;/a&gt;.
This script is necessary to first reset the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
into a known mode, and then second to issue sufficient commands to the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
to place it into its highest speed mode–typically &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;QSPI with a high speed
clock&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This gets more difficult in an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt; device where the
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt; needs to be
manufactured before the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
device is selected.  The more modern protocols allow for the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
to be queried regarding which modes it supports, followed by issuing
appropriate commands to place the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt; into a chosen high
speed mode.  This is a complicated enough exchange that it makes the
most sense to handle this in software.  A small SwiC, therefore, might be
useful for this purpose.&lt;/p&gt;

    &lt;p&gt;Here, though, I would note that this should only be required for non–System
on a Chip (SOC) ASIC chips.  If you had a processor available to you on the
chip already, then a simpler solution would have been to start the processor
using &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt; in
its default state (slow SPI), and then to read the necessary instructions
from the &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
to move it into a higher speed state for operation normal operation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;Flash memory&lt;/a&gt; programmer&lt;/p&gt;

    &lt;p&gt;Yes, I once thought to use the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
as a &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt;
programmer on an FPGA.  The problem here lies in how a
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt; is operated.
Basically, a &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt;
is divided into sectors and pages.  Writing to a
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
device means either erasing a sector (64k Bytes), whereby all
the bits in the sector are set to one, or programming a page (256 Bytes),
whereby one or more bits within that page are cleared.  This means that
programming the &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
requires &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/b75249d6db61db041008a2a8eafcd62aa0f1d0b5/sw/host/flashdrvr.cpp#L416-L444&quot;&gt;first 1) reading a whole sector, 2) copying it somewhere, and then
3) determining if the sector needs to be erased as a whole, before 4) one
or more pages within it needs to be programmed&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;While I normally &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;handle this over a serial
port&lt;/a&gt;, the
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;serial port&lt;/a&gt;
can be quite slow for this purpose.  Why, for example, should a whole
sector’s worth of data be read and then written when one might just as easily
write the sector to the CPU’s memory and then have the CPU determine locally
if the sector needs to be fully erased, or only partially programmed?  What
if, even better, the data were compressed when going over the &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;serial
port&lt;/a&gt;,
and a CPU on the other end uncompressed it?&lt;/p&gt;

    &lt;p&gt;In my case, although I built the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
software necessary to do this, I never quite got annoyed enough to build
the host software that would interact with it in order to finish following
through with the experiment.  Instead, it’s still waiting for me to come
back to it and report on how well it works.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2021/11/15/ultimate-i2c.html&quot;&gt;(Multi) I2C Sensor handler&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;In one project involving a robotic SONAR device, something was needed to
periodically poll and report on multiple voltage level, temperature, and
accelerometer sensor readings and to create a telemetry stream from them.
A first cut of this project suggested the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; could handle this task
quite nicely.  Indeed, communicating with the originally intended sensor
set based upon a Dallas Semiconductor 1–wire protocol would’ve required
something as complex as a CPU to handle this coordination and communication.&lt;/p&gt;

    &lt;p&gt;In the end, I chose not to use the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  The sensor readings needed
strict time stamps, and a minimum of logic was required to guarantee things
would be shut down if the voltage or temperature measurements were ever out
of normal limits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hi-Res &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; test bench&lt;/p&gt;

    &lt;p&gt;One of my earlier projects was to build a &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;high resolution
FFT&lt;/a&gt;.  The algorithm primarily
involved a special pre-processor that would take place before a
&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;traditional FFT&lt;/a&gt;.  The results
on paper and in off-line testing, however, were
&lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;spectacular&lt;/a&gt;.
One individual wrote me, after testing the &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;hi-res FFT
algorithm&lt;/a&gt; on a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency-shift_keying&quot;&gt;frequency shift
keyed signal&lt;/a&gt;, at his
amazement that the &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;hi-res FFT&lt;/a&gt;
could then distinguish between which “bit” was being sent.&lt;/p&gt;

    &lt;p&gt;This project earns its place on this list, however, not because of the FFT,
nor because of the pre-processor’s implementation, but rather because of the
challenge associated with testing it.  My initial tests involved sending
a tone into the &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;
at a &lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;programmable frequency&lt;/a&gt;,
and then evaluating the sidelobes to see how well the tone was isolated.
The problem?  The amount of data getting sent back and forth rendered
sweeping the tone across all frequencies and examining the data from
it an exercise in patience.&lt;/p&gt;

    &lt;p&gt;This project took place before the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Had I placed a small
CPU on board, this task might have become much easier: The CPU might have
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;controlled the tone’s
frequency&lt;/a&gt;, and then estimated
the maximum sidelobe–all taking place within the FPGA–reducing the data
requirement over the
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;serial port&lt;/a&gt;
to something much more reasonable, and speeding up the testing significantly.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is just a short list of the sorts of ideas that have motivated my
interest in SwiCs in general.  At least, this describes the vision.  What
about the reality?&lt;/p&gt;

&lt;h2 id=&quot;zipcpu-the-reality&quot;&gt;ZipCPU: The Reality&lt;/h2&gt;

&lt;p&gt;Now that I’ve worked with the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
over the course of several projects, it’s worth asking: how well has this
vision panned out to reality?  To answer that, I’d like to look through
several projects that have included a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, to see how well the vision
fits or doesn’t.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Doorbell controller&lt;/p&gt;

    &lt;p&gt;One of &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;my earlier projects was a doorbell
controller&lt;/a&gt;.  This probably fits more into
the category of SOC than SwiC, but the story is worth telling anyway.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 6. Our beloved security officer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/security.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The background behind this project was a 2AM visitor that … well, I have
   no idea who it was, or why they knocked on our door at 2AM.  (By the time
   I got to the door with my security officer, they were no longer there.)  But
   this got me thinking: it would’ve been nice to turn on the outdoor lights
   when this person rang the doorbell, and to make sure the lights were
   otherwise turned off automatically at night.&lt;/p&gt;

&lt;p&gt;My thought was to use a small FPGA to control the doorbell and outdoor light
   together.  The outdoor light would be turned on initially at dusk, but
   eventually turned off–unless the doorbell rang.  If anyone rang the
   doorbell, the outdoor light would turn on for a period of time.
   That meant that the FPGA would need to know time of day–requiring user
   interaction to set, hence there was a small keypad and a 2–line LED display.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;this project&lt;/a&gt;, the
   &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
   controlled the light, the keypad, the 2–line display, and the audio
   doorbell.&lt;/p&gt;

&lt;p&gt;Wouldn’t a small microcontroller have been more appropriate?  Perhaps a
   &lt;a href=&quot;https://www.raspberrypi.org/&quot;&gt;Raspberry Pi&lt;/a&gt; or even an
   &lt;a href=&quot;https://www.arduino.cc/&quot;&gt;Arduino&lt;/a&gt;?  Absolutely.&lt;/p&gt;

&lt;p&gt;However, my true purpose was to see how small a system containing the
   &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; could be, and whether or not
   the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; could handle
   &lt;a href=&quot;/zipcpu/2019/11/23/multithreaded-blinky.html&quot;&gt;multi-tasking&lt;/a&gt;.
   The answer was, &lt;a href=&quot;/zipcpu/2021/03/18/zipos.html&quot;&gt;yes it could handle multi-tasking&lt;/a&gt;
   while &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;still fitting on Xilinx’s smallest
   Spartan 6&lt;/a&gt;: the LX4.&lt;/p&gt;

&lt;p&gt;(This project was internally funded …)&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2019/11/14/sdspi.html&quot;&gt;Test recorder&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;In another project, the customer wanted to generate a special communications
signal on an I/O pin.  Part of the project involved deciding what signaling
standard to use, so several were tried to include two different types of
on-off keying and two types of pulse position modulation.&lt;/p&gt;

    &lt;p&gt;In this case, the application used only a small amount of logic within the
FPGA to generate these signals.&lt;/p&gt;

    &lt;p&gt;A more substantial problem was how to record the results from a test like
this.  In this case, the ideal recorder was the FPGA: it had access to
the incoming signals, a large DDR3 SDRAM attached, as well as an SD Card
to make recordings with.  While an SD card can become an ideal medium
for recording data, the challenge is how to deal with the file system
present on the card.&lt;/p&gt;

    &lt;p&gt;Enter the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI Controller&lt;/a&gt;,
and the &lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS&lt;/a&gt; library.&lt;/p&gt;

    &lt;p&gt;The next challenge was how to deliver the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s program to the customer,
who didn’t have the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus
infrastructure&lt;/a&gt;
available to him on his host computer in order to load the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;The particular board&lt;/a&gt;
we had chosen for this project, however, permitted loading the FPGA from an
SD Card.  Therefore, we chose to load the board from this SD card, and I
placed a boot loader for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
into 64kB of ROM.  (The program required 168 bytes more than the 32kB,
forcing a 64kB ROM built out of block RAM.)  The boot loader would then
walk through a small script to start up the SD Card, and then read a file
from it into memory, before jumping to the first address of memory.&lt;/p&gt;

    &lt;p&gt;Once loaded, the user could interact with the design via a CPU provided
menu, allowing the user to configure the test, capture data, and save any
data captured to a file on the SD card.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.extremesonar.com/projects&quot;&gt;Broadband High-Frequency Active
SONAR&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;A more recent project involved the development of a controller for a SONAR
transmitter.  As with the last project, the amount of logic involved in the
transmitter turned out to be a small portion of the project.  Still, small
or not, it did need to be configured.  A small
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; program attached to
the serial port provided the customer with a way to control the transmitter,
to both turn it on and off, as well as to control the waveform produced by
the transmitter: frequency, pulse duration, pulse repetition rate, chirp,
pseudorandom noise pattern, etc.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Video&lt;/p&gt;

    &lt;p&gt;When first learning about HDMI video, I struggled to get the timing right
to lock onto the HDMI clock using the IDELAYE2 function on my FPGA.  (In
hindsight, I didn’t understand how the IDELAYE2 element worked, and could’ve
greatly simplified this problem …)  While
I couldn’t lock automatically, I could tell if things were locked.  My
solution was to use the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to
&lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/6e4215b3b6ea96595a4083603636a88a5599604d/sw/board/hdmistest.c&quot;&gt;measure whether or not the received HDMI signal quality was good enough,
and then to adjust the subsample delay timing until it
was&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Also, in &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;the same project&lt;/a&gt;, I had to
deal with the challenge of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Display_Identification_Data&quot;&gt;EDID&lt;/a&gt;
display data.  The &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;project&lt;/a&gt;
involved a pass through HDMI signal.  Therefore, the downstream
&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Display_Identification_Data&quot;&gt;EDID&lt;/a&gt;
information needed to be read and forwarded upstream.  There was an
opportunity for software to adjust things in the middle.  In the end,
however, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/6e4215b3b6ea96595a4083603636a88a5599604d/sw/board/hdmistart.c#L157-L158&quot;&gt;just copied the
EDID information from the downstream monitor to the upstream RPi
source&lt;/a&gt; and everything worked.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;One potential customer has asked me about the feasability of
&lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/dev/rtl/axisvoverlay.v&quot;&gt;overlaying&lt;/a&gt;
graphical information, such as text and/or menus, onto a video stream.  The
FPGA would sample data from a camera, apply some special processing
algorithms to clean up the image, and then forward the results down stream.
It just needed an ability for user control and feedback somewhere. Here,
again, the majority of the processing will take place within the FPGA
logic.  Indeed, it might be possible to do all of the processing in the
FPGA logic without a CPU at all.  The problem was … the technology was
still in development.  While in development, it makes sense to be able to
reconfigure things.  Therefore, the CPU is present to be able to read
&lt;a href=&quot;/dsp/2019/12/21/histogram.html&quot;&gt;histogram&lt;/a&gt; data,
operate on it, adjust scaling constants, and in general
to rearrange the configuration as necessary.&lt;/p&gt;

    &lt;p&gt;In this last case, the CPU may evolve into a more necessary function as well.
Because the project is designed to be a “bump” in the video stream, i.e.
HDMI and power in, maybe a couple buttons, and then HDMI out, any user
feedback regarding the algorithm or its performance will need to be placed
onto the video output stream itself.  This can easily be done with a text
overlay, however a CPU will be required to determine what text to overlay
and where.  Perhaps I’ll even port the &lt;a href=&quot;https://invisible-island.net/ncurses/announce.html&quot;&gt;nCurses
library&lt;/a&gt; to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and integrate that.  We’ll see, however, as this project develops–assuming
it gets funded in the first place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt; testing&lt;/p&gt;

    &lt;p&gt;There’s another place where a small soft-core CPU can have a big impact,
and that’s in &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;simulation
testing&lt;/a&gt;.  When building
and &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;testing an ASIC
peripheral&lt;/a&gt; recently, it
helped to be able to simulate the peripheral’s interactions with a nearby
soft-core CPU.  This, of course, requires having a Verilog CPU nearby
which can stimulate the peripheral.&lt;/p&gt;

    &lt;p&gt;Being an open source CPU, or perhaps more because the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was &lt;a href=&quot;/blog/2020/01/13/reuse.html&quot;&gt;internally
sourced&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; fit this role quite 
nicely.&lt;/p&gt;

    &lt;p&gt;The proposal ended up being a challenge on two fronts, however.  The
first was speed.  A Verilog test script will always beat a Verilog CPU
in processing speed.  The second was in maintainability.  At some point, I
needed to hand the software to someone else to maintain, and they weren’t
necessarily comfortable with the risk of needing to maintain the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s tool base.  Doh!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you can see from the above examples, the amount of CPU interaction with
the design has ranged from something that might be replaced by a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/9a83c98a0b2d27d5715813364391cd8860a906ff/hexbus/rtl/hbexecaxi.v&quot;&gt;small
AXI4-lite state machine&lt;/a&gt;,
to something rivaling an SOC in its own right.&lt;/p&gt;

&lt;h2 id=&quot;logic-usage&quot;&gt;Logic Usage&lt;/h2&gt;

&lt;p&gt;How about logic usage?  Let’s take a quick look at logic usage.  Does the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; truly qualify as small enough
to be used in a SwiC?  This question isn’t so easy to answer, since CPU design
always involves a trade off between performance and area.  Specifically, you
can buy more, better, faster performance with more on-chip area.  That means
to compare logic usage, we’ll need to define a feature set to measure logic
usage from.  So let’s define and then compare a couple of configurations:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. Supporting multiple configurations is a hassle&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/config-testing.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ASM&lt;/strong&gt;: If you strip the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; of
every single optional feature, you get to this ASM mode.  I call it the
“ASM” mode because it doesn’t include instructions that the toolchain would
require–such as multiplies, divides, or shifts of more than one bit.  Worse,
because this mode doesn’t include the &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user
mode&lt;/a&gt;, there’s no way
to trap on an unimplemented instruction–the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would either just halt
or restart–depending on its configuration.  This means that any
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; program using this mode will
likely need to be written in assembly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TRAP&lt;/strong&gt;: This is a compromise from the ASM support above.  In this mode,
shift instructions are now implemented, and there’s now a
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user mode&lt;/a&gt; that can
be used to trap unimplemented multiply or divide instructions.  Further,
the LOCK instruction is now implemented, allowing atomic access from
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user mode&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;For those buses that don’t support the LOCK instruction, such as the AXI-lite
bus, the LOCK instruction instead implements a interrupt block–preventing
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; from responding to an
interrupt for three instructions.  Sadly, this includes all of the
Wishbone wrappers prior to the pipelined controller, since the LOCK
instruction would otherwise cause a dead lock: the data bus would hold
the Wishbone cycle line high during the lock operation, and so otherwise
it would lock out the instruction bus interface from fetching the next
instruction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Minimum&lt;/strong&gt;: This configuration includes support for &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;all
CPU instructions&lt;/a&gt;.
In particular, it also supports the compressed instruction set not
supported by the TRAP configuration above.  This isn’t quite a full featured
configuration, however, since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; isn’t (yet) pipelined.
(That’s the next configuration.)
Instructions, therefore, take a minimum of four cycles to complete.&lt;/p&gt;

    &lt;p&gt;The savings between this mode and the pipelined mode (next) is primarily
captured by the difference between the memory controllers, shared registers,
and some simplified pipeline signaling.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pipelined&lt;/strong&gt;: The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was
originally designed to be a pipelined CPU.  This configuration turns
pipelining on, while also including a powerful memory controller that’s
not (yet) quite as capable as a cache.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cached&lt;/strong&gt;: This configuration adds a 4kB instruction and a 4kB data cache
to the CPU’s configuration.&lt;/p&gt;

    &lt;p&gt;In general, cache sizes are configurable–but this configuration arbitrarily
uses 4kB caches.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Low Power&lt;/strong&gt;: This final configuration adds both &lt;a href=&quot;/blog/2021/10/26/clk-gate.html&quot;&gt;clock
gating&lt;/a&gt; (unusable on
most FPGAs, but we’ll ignore that for now), as well as zeroing unused
registers for the purpose of lowering the CPU’s power requirements.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Just for review, you can see these configurations compared in Fig. 8 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Comparing the basic configuration options&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/config-comparison.png&quot; alt=&quot;&quot; width=&quot;778&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That covers the configurations of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/core/zipcore.v&quot;&gt;core of the CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This isn’t sufficient, however, to measure the CPU’s logic usage, since the
CPU needs to be married to a wrapper containing the bus interface and memory
controllers.  Since the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/zipcore&quot;&gt;new ZipCPU
distribution&lt;/a&gt;
supports Wishbone &lt;em&gt;and&lt;/em&gt; AXI-lite and AXI4, there are three basic wrappers:
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxil.v&quot;&gt;Zip-AXIL&lt;/a&gt;,
and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxi.v&quot;&gt;ZipAXI&lt;/a&gt;
wrappers.  A &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;fourth
wrapper&lt;/a&gt;,
one I call the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
connects the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to an immediate set of local peripherals: one or two
&lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt controller&lt;/a&gt;s,
three &lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timers&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/zipjiffies.v&quot;&gt;jiffies peripheral&lt;/a&gt;,
some &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/zipcounter.v&quot;&gt;performance counters&lt;/a&gt;,
and a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/wbdmac.v&quot;&gt;Wishbone DMA&lt;/a&gt;.
Each of these wrappers has a different logic requirement when attached to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/core/zipcore.v&quot;&gt;core&lt;/a&gt;.  So examine them one at a time.&lt;/p&gt;

&lt;p&gt;For accounting purposes, I’ll measure CPU usage in terms of both 4-LUTs on
an iCE40, and Xilinx 6-LUTs.  I will use &lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;Yosys&lt;/a&gt;
for the measurements, and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/usage.pl&quot;&gt;this
script&lt;/a&gt;
to make them automatically.&lt;/p&gt;

&lt;p&gt;Let’s start with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
area usage, as shown in Fig. 9 on the left.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 9. ZipBones logic usage&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-zipbones.png&quot; alt=&quot;&quot; width=&quot;332&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you can see from this table, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
configuration fits nicely in the smallest of areas.  Indeed, I was quite
pleased with myself that the CPU can be made to fit in as few as 576 6-LUTs.
No, it’s not very usable in that configuration, but that’s about as good as
I can get for low-area bragging rights.&lt;/p&gt;

&lt;p&gt;The next wrapper we’re examining is the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;.
As mentioned above, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
is not a bare CPU, but rather includes includes several local peripherals:
three &lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timers&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/wbdmac.v&quot;&gt;a Wishbone DMA&lt;/a&gt;,
&lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt controller&lt;/a&gt;s,
and more.  As one might expect, there’s a logic cost to these new features,
and this cost can be seen in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;’s
logic usage chart shown in Fig. 10 on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. ZipSystem logic usage&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-zipsystem.png&quot; alt=&quot;&quot; width=&quot;332&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In general, the cost of these extra peripherals runs about 1150 6-LUTs or so.&lt;/p&gt;

&lt;p&gt;The chart for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxil.v&quot;&gt;AXI-Lite wrapper&lt;/a&gt;’s
logic usage is just a little different.  Specifically, I have yet to build any
AXI-_lite_ cache implementations.  (I have an AXI cache implemention …)
Therefore, the usage chart for AXI-lite shown in Fig. 11 doesn’t have any
cache options to it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 11. ZipAXI4-Lite logic usage&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-zipaxil.png&quot; alt=&quot;&quot; width=&quot;346&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For reference, all of these AXI-Lite configurations, prior to the pipelined
one, make use of the &lt;a href=&quot;/zipcpu/2021/04/17/axilops.html&quot;&gt;AXI-lite memory controller we discussed some time
ago&lt;/a&gt;.  As you might guess,
there’s no bus support for the LOCK instruction in this configuration since
AXI-Lite has no support for exclusive access.&lt;/p&gt;

&lt;p&gt;That brings us to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxi.v&quot;&gt;final wrapper&lt;/a&gt;,
showing the AXI4 (full) interface logic usage in Fig. 12 on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 12. ZipAXI4 logic usage&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-zipaxi.png&quot; alt=&quot;&quot; width=&quot;332&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This includes the &lt;a href=&quot;/zipcpu/2021/09/30/axiops.html&quot;&gt;bare minimum AXI4 memory controller we
discussed&lt;/a&gt;
for the minimum modes as well.  Since making this measurement, however, I’ve
added an exclusive access option to my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/core/axidcache.v&quot;&gt;AXI data cache
implementation&lt;/a&gt;.
So, the numbers may not quite match the current performance.&lt;/p&gt;

&lt;p&gt;Having this kind of information, though, is really cool.  That means that I
can now compare logic usage requirements between the various bus
implementations, as shown in Fig. 13 on the left.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 13. Bus logic usage comparison&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-bus.png&quot; alt=&quot;&quot; width=&quot;520&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One of my contentions has always been that &lt;a href=&quot;https://www.reddit.com/r/FPGA/comments/egkrce/is_axi_too_complicated/&quot;&gt;AXI4 is unnecessarily
complicated&lt;/a&gt;.
Here, you can see that, in spite of the extra complications of working with
the AXI4 bus, the CPU 6–LUT logic usage difference is only 100-200 LUTs
between the Wishbone and AXI4 implementations.  On an FPGA with 200k LUTs,
this difference isn’t a big deal.  On an FPGA with 1,500 LUTs?  A 200 LUT
difference could mean the difference between fitting and not.&lt;/p&gt;

&lt;p&gt;While informative, this bus comparison really isn’t complete.  To be complete,
the comparison should also the cost of the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt; and all of
the peripherals–each of which would magnify the differences shown here.&lt;/p&gt;

&lt;p&gt;When comparing logic usage options, one of the things not shown in these
charts is the cost of a Finite State Machine bus controller such as one might
use instead of a CPU for relatively simple tasks.  For reference, therefore, a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/9a83c98a0b2d27d5715813364391cd8860a906ff/hexbus/rtl/hbexecaxi.v&quot;&gt;simple AXI-lite FSM–based bus
controller&lt;/a&gt;,
reading from a (not-included) memory script, can be made as simple as 88~LUTs.&lt;/p&gt;

&lt;h2 id=&quot;comparison-to-socs&quot;&gt;Comparison to SOCs&lt;/h2&gt;

&lt;p&gt;So, how does a &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
compare against a full blown SOC?  Something like a Zynq, for example?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hardware support&lt;/strong&gt;.  The Zynq is bigger (i.e. more capable), and supports
more hardware out of the box.  It has hard macros for such things
as DDR3 memory, SD Cards, ethernet, displays, and more.  Further, because
the ARM CPU within the Zynq is implemented out of raw gates, rather than
FPGA fabric, it runs at a much higher clock speed.&lt;/p&gt;

    &lt;p&gt;A SwiC isn’t going to compete well here.&lt;/p&gt;

    &lt;p&gt;On the other hand, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
memory controller tends to &lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;compare favorably to the ARM when measuring
the raw bus access speed of the CPU accessing FPGA
logic&lt;/a&gt;.  I can’t
explain this, but I have seen it multiple times over.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Logic Portability&lt;/strong&gt;.  One problem with the Zynq, or any other SOC for that
matter, is that its peripherals are unique to it.  Some may have a device
independent interface, similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt; for the ability to interact
with a console, but getting to that interface takes a lot of work and
capability away from a raw CPU.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
on the other hand, is a soft core CPU.  It can therefore (theoretically)
run on any hardware, and its peripherals can be ported from one piece of
hardware to another for a similar user experience across multiple vendors’
FPGAs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bare-Bones Programming&lt;/strong&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; runs quite well without
any operating system.  As &lt;a href=&quot;/zipcpu/2019/11/23/multithreaded-blinky.html&quot;&gt;we’ve discussed
earlier&lt;/a&gt;,
it’s pretty easy to run multiple threads on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–even without an operating
system.&lt;/p&gt;

    &lt;p&gt;How does this compare the the ARM within a Zynq?  Frankly, I haven’t written
any bare bones software for the ARM to really know.  I know plenty of others
have, so I know it’s quite doable.  I’d personally be tempted to give
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; the advantage here,
simply because of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
approach to interrupt handling, but my own subjective view of this matter
is hardly definitive and quite likely biased.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Simulation&lt;/strong&gt;. What the Zynq cannot do, however, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can:
&lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;simulation&lt;/a&gt;.  Since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is an all Verilog CPU based
upon publicly available Verilog, it can easily be &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;verilated into
C++&lt;/a&gt;,
integrated into the host O/S of the simulator, and therefore offer more
realistic cycle by cycle simulation of a system under test.  If
&lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;simulation&lt;/a&gt;
is what you want, therefore, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; (or any other soft-core for
that matter) easily wins here.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ASIC&lt;/strong&gt;.  If I ever need to build a CPU into an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; will be my go to solution.
It’s proven,
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;verified&lt;/a&gt;,
fits into a small (and controllable) area, and costs less than an ARM.&lt;/p&gt;

    &lt;p&gt;(I might be a touch biased in this opinion.  Use your own discretion.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Having now reviewed the concept of a SwiC, and seen how such a device might
be used, what conclusions might we draw?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;For a single need, an FSM may make more sense&lt;/p&gt;

    &lt;p&gt;Even at it’s lowest logic usage of 576 Xilinx 6–LUTs (plus the &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;, data
memory, and &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
which we didn’t count), the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
cannot compete with an 88 6-LUT &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/9a83c98a0b2d27d5715813364391cd8860a906ff/hexbus/rtl/hbexecaxi.v&quot;&gt;FSM based bus
controller&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Sorry, that’s just not going to happen.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For multiple needs, an
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
and console become indispensable.  The measure of the CPU’s impact on the
rest of the system really needs to include these components.&lt;/p&gt;

    &lt;p&gt;Simply put, the more things the CPU needs to control, the more things
it needs to be connected to.&lt;/p&gt;

    &lt;p&gt;Why the console?  Simple: it’s really easy to use, and even easier to debug
with.  Debug by printf() is just so much easier than debug by debugger, or
even debug via &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace&lt;/a&gt;,
that I’d use it in a heartbeat any time I can.&lt;/p&gt;

    &lt;p&gt;Unfortunately, the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt; and DDR3
SDRAM controller by themselves can easily be so costly as to void the whole
SwiC vision.  Why use a SwiC at all, then?  Why not a regular soft core?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even in the presence of big SOC+FPGA devices, small soft-core CPUs can still
have a big impact.&lt;/p&gt;

    &lt;p&gt;While the impact might be reserved to &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;simulation and
testing&lt;/a&gt;, or vendor
independence only, impacts are still impacts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In most of my actual, real-life use cases, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; hasn’t really fulfilled
my original vision of a SwiC.  Instead, it seems to grow and expand to
fill whatever space is left on my device.&lt;/p&gt;

    &lt;p&gt;On the other hand, perhaps that was the vision–especially since I have
yet to come across a project where the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; won’t fit.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The one thing I haven’t tried, though, is connecting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s fetch directly to a small
attached block RAM implemented as an instruction ROM.  Doing so would probably
both speed up the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and lower its
memory usage.  Let me add this one to my to-do list as well.  It won’t be the
first item on my list, though–that’s still finalizing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; for it’s version 3.0 release.&lt;/p&gt;

&lt;p&gt;Expect to hear more of this in the future.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. A short ZipCPU to do list&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/zipcpu-todo.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Of course, the sad part of this to-do list, like any good to-do list, is that
it just keeps on growing.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Were there is no vision, the people perish: but he that keepeth the law, happy is he.  (Prov 29:18)&lt;/em&gt;</description>
        <pubDate>Mon, 13 Mar 2023 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2023/03/13/swic.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2023/03/13/swic.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Debugging the Hard Stuff</title>
        <description>&lt;p&gt;There are a couple of really hard problems in digital design.  These include
debugging &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;s,
cryptographic algorithms, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;Error Correction Coding
(ECC)&lt;/a&gt;.
Debugging a good compression algorithm is also a solid runner up, but it’s
not quite as difficult as the others.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/dbgchallenge.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What makes these problems hard is the debugging challenge: put simply,
given a failing design, pinpoint the line (or lines) of failing logic.
This debugging challenge is hard because these particular problems don’t
break down easily into visually reducible sub-problems.  That is, it can
be a real challenge when working with problems like these is to first
identify the problem in the trace, and then to be able to walk backwards
from there to the bug.&lt;/p&gt;

&lt;p&gt;Take, for example, an &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;.
Some time ago, a user came to me telling me my
&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;
was broken.  Nonsense I said, it works fine for me.  So he sent me a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD
trace&lt;/a&gt;, and sure enough, the
I&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; of an
&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; wasn’t producing the
input again.
It wasn’t even close.  The challenge here was that this user had introduced
random data into the system.  Because it was &lt;em&gt;random&lt;/em&gt;, it was hard to tell at
every stage what the &lt;em&gt;right&lt;/em&gt; answer should’ve been and therefore where in
the algorithm did the design break.&lt;/p&gt;

&lt;p&gt;How then do you debug these complex algorithms?&lt;/p&gt;

&lt;h2 id=&quot;to-debug-build-new-tools-when-necessary&quot;&gt;To debug: Build new tools when necessary&lt;/h2&gt;

&lt;p&gt;Remember, the goal is to find the one (or more) lines of HDL that are broken.&lt;/p&gt;

&lt;p&gt;Recently, I was asked to do some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
work.  It started out simple: here’s a working
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
design, now generate a piece of software that will replicate it.
Okay, there’s more to the backstory.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
was part of a non-volatile memory controller, and the customer wanted to
pre-load the device at the factory with data and valid
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
parity bits.  Not a problem, right?  Most, but not all,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
is just straight linear algebra over &lt;a href=&quot;https://en.wikipedia.org/wiki/GF%282%29&quot;&gt;Galois Field 2
(GF2)&lt;/a&gt;, so this should be basic, no?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: left&quot;&gt;&lt;caption&gt;Fig 1. ECC wraps the CRC, which then wraps the user data&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/eccpkt.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The problems got worse from there.  Gee, Dr. Dan, since you’re an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; expert (Wait, what?
I am?), why not maintain some logic for me?  Here’s your first task: a
customer wants 32-bit error correction.  Our standard 16-bit error correction
isn’t good enough for this customer.  Then, once that task was done, the next
task was for a customer who wanted even more error correction than just
32-bits per packet.  Then there was the customer who wanted not just
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;, but an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; protected
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
so that he could tell if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; ever failed.&lt;/p&gt;

&lt;p&gt;This is all well and good, but how do you debug this stuff?  Remember, the
debugging challenge is to find the line (or lines) of HDL (VHDL or Verilog)
containing the bug.  Also remember, I didn’t write the original logic–I’m
just the one getting paid to maintain it.&lt;/p&gt;

&lt;p&gt;Here’s the method I came up with:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start with a golden reference.&lt;/p&gt;

    &lt;p&gt;This may seem like the hardest part at first.  I mean, if you are building
an algorithm for the first time, how will you know that your golden
reference works properly in the first place?&lt;/p&gt;

    &lt;p&gt;It helps to start with the references from others.  &lt;a href=&quot;https://www.amazon.com/Numerical-Recipes-Scientific-Computing-Second/dp/0521431085/&quot;&gt;Numerical Recipes in
C &lt;/a&gt;
publishes the C source of an
&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; algorithm that I’ve since
used often.  There’s even a &lt;a href=&quot;https://www.amazon.com/Numerical-Recipes-Art-Scientific-Computing/dp/8175960965&quot;&gt;Numerical Recipes in
C++&lt;/a&gt;,
which I would expect is the same recipes but with an updated coding
standard.  Then there’s the “Advanced Encryption Standard” (AES), which
includes an appendix showing what the outputs should look like at each
stage of the encryption standard given a known key and a known input.
There’s also at least one &lt;a href=&quot;https://opencores.org/projects/tiny_aes&quot;&gt;AES algorithm on
OpenCores&lt;/a&gt; that you might use.
In general, references are available for your work with digital design,
you might just need to spend some time looking for them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add debug &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$display&lt;/code&gt; statements to the design, and make them both human
readable and computer friendly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use those debug statements to feed the golden reference.&lt;/p&gt;

    &lt;p&gt;This is the key feature I’ll be discussing in a moment.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now look for the first difference between the reference and any broken 
trace.&lt;/p&gt;

    &lt;p&gt;Remember, the golden reference &lt;em&gt;works&lt;/em&gt;.  Therefore, any discrepancy or
other difference between the golden reference and your design will be
something you want to dig into.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s walk through how this works, by discussing the last
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
problem I worked on: adding a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
to a memory controller, prior to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
parity generator and then checking it at the back end.&lt;/p&gt;

&lt;p&gt;What made this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
task challenging was that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
parity bits were packed together–even across byte boundaries.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; bits, therefore,
needed to be packed together with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
parity bits.  Not only that, both needed to be gathered together and assembled
separate from the data itself.  Together, this created data blocks looking
somewhat like Fig. 2 below when transmitted.  (Note that the Fig 2. is not
drawn to scale by any means.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Data backs consisted of data blocks, followed by CRC then parity&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/packet.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The original algorithm I was given handled this via a combined shift
register and memory implementation that had grown to over 2k lines
of Verilog.  It read like a series of cascaded case statements: if this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
option, this data block size, the data block number, then adjust these bits,
etc.)  Indeed, by the time I started working with this logic, it had
gotten so repetitive that I was using a C++ program to write and update these
thousands of lines of Verilog for me.  Now, this may have been fine originally,
for the simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
codes this controller was originally built to handle, but the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
bit-vector had now grown to over 7k bits, each individually accessed, and none
able to be optimized into memory properly.  It got so bad that this part of
the algorithm was starting to dominate the total area cost–and I was going to
add &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s
to this mess?  No, that wasn’t going to happen–not without a rewrite.&lt;/p&gt;

&lt;p&gt;So, I rewrote the algorithm with a proper gearbox coupled with a proper FIFO.
Moreover, in the hopes that I might be able to reuse the implementation, I
built the gearboxes using standard interfaces: AXI stream, VALID, READY, LAST,
etc, and I even parameterized the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
size so the customer could change it at a later time if they wished to.  All
told, the new implementation took just over 1k Verilog lines of code, and at
least half of that was either comments or formal properties.  That meant
there was a rough 4x reduction in the number of lines of code.  Does this
mean the design is simpler?  In this case, definitely!  It was both simpler
to understand, easier to see what was going on within it, and therefore
simpler to maintain.  The giant tables had been replaced.  The new design
also used less area, so we’re good all around.&lt;/p&gt;

&lt;p&gt;But, how to debug this?&lt;/p&gt;

&lt;p&gt;To give you an idea, then general test setup I was given looked something like
Fig. 3 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Test bench setup&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/dbgpath.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;A test bench script would drive the entire test.  This script would generate
commands to write pseudorandom data to the memory device.  Then, once all the
data had been written, the script would command an error generator to
insert errors into the read path, and then generate commands to read from
the memory device.  The results would be compared against the data written to
the device.  If (and &lt;em&gt;only&lt;/em&gt; if) the number of errors inserted was beyond the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;’s
correction ability, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
failure flag was to be set.  In all other cases, the data returned from the
device was required to match the data sent to it.&lt;/p&gt;

&lt;p&gt;Now consider all the steps involved in this process, and ask yourself where
and how would you debug all of this?&lt;/p&gt;

&lt;p&gt;The (obvious) answer should be: starting with unit tests.  Each individual
unit should be tested and verified separately, and known to work before
being integrated into the larger whole.  For unit tests, I turn to formal
methods.  One of the things I like about formal methods is that, any time you
get a property (i.e. an assertion) failure, that failure will lead you directly
to the failed assertion, which is usually nearby the logic it defends, and so
formal methods will typically find bugs in about 5-10 steps.  In my case here,
the gearboxes required 40 steps.  Why so many?  Because of a technical problem.
Formal methods don’t handle division very well, and a full induction description
would require that the formal methods implement a divide.  As a result, I
didn’t get induction working.  Still, 40 time steps was enough to give me
strong confidence the gearboxes worked.&lt;/p&gt;

&lt;p&gt;My next step was to use a bench test with
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;.
You can see this basic setup in Fig. 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Verilog unit testing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/vgolden.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this case, the &lt;em&gt;unit&lt;/em&gt; under test was the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
block separated from the
rest of the design.  In particular, this unit testing approach allowed me
to separate my test from the AXI bus interface, the device interface, and the
device model.  Data came into the test design via the AXI stream protocol,
and then the same protocol was used to take data back out once encoded or
decoded.  Still, as you can see from the figure, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
block under test wasn’t quite the &lt;em&gt;working&lt;/em&gt; design given to me, but
rather my modified version of it, now containing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
generation and checking.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Test vector choice&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/tbdesign.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One key to this type of testing was the test vectors chosen.  For example,
when building an &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;,
you’ll want to use both impulses and sine waves.  Since this is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;, i.e. linear math
over &lt;a href=&quot;https://en.wikipedia.org/wiki/GF%282%29&quot;&gt;GF2&lt;/a&gt;, I started with vectors of
all zeros, and then vectors with a single bit set, and only then a small number
of countable bits set.  From there I moved on to all bits set and then random
settings.&lt;/p&gt;

&lt;p&gt;What if the design fails with random data?  In that case, you just reduce the
random data vector back to the relevant basis vectors, and try again.&lt;/p&gt;

&lt;p&gt;Thankfully, it wasn’t too difficult to get this
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
based test bench working.
In general, the trace led me straight to any bugs–well, that and the fact that
I knew that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
algorithm worked initially, so the only thing that could’ve
broken would be associated with one of my changes.  That meant that this
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
test bench could then become my “golden reference” model.&lt;/p&gt;

&lt;p&gt;Once things worked in this “golden” model, I could then integrate this updated
design back into the memory controller it was originally a part of. 
Not only that, but remember this was a maintenance task.  In other words,
I needed to modify logic someone else had written years ago, logic that
I wasn’t familiar with–a recipe for problems, no?&lt;/p&gt;

&lt;p&gt;This brings us back to the integrated test bench design shown in Fig. 3.
The good news is that we come into this integrated test design with something
known to work.&lt;/p&gt;

&lt;p&gt;Now, let me point out a problem with the type of integrated testing shown in
Fig. 3: the test bench script won’t notice any data failures until late in
the process.  This is just the nature of the perspective of a black box.
Data will first need to be written to a staging area, then pushed through
the device path, transferred to the external memory device model, then
transferred back, then copied out of the controller–and only then would any
errors be noted and flagged–all in good &lt;a href=&quot;https://en.wikipedia.org/wiki/Black-box_testing&quot;&gt;black box testing
fashion&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This wonderful &lt;a href=&quot;https://en.wikipedia.org/wiki/Black-box_testing&quot;&gt;black box
testing&lt;/a&gt;
fashion might be great for proving that a
design does what it is supposed to, but it is horrible for telling you what
fails when it fails.  Why?  Because the failure isn’t noticed until microseconds
of simulation time later, and only after thousands of data transfers.  That’s
a lot of trace you have to back through manually to find any bugs.  There’s
another word for that: pain.&lt;/p&gt;

&lt;p&gt;This is where the debugging statements came into the design.  To show you what
I mean, the following lines have been clipped from the design.  First,
as every word went into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;, and now the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;+&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
algorithm, I dumped it to the simulation log.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;localparam&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;OPT_ECC_DEBUG&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1'b1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_ECC_DEBUG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GEN_ECC_DEBUG&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_enabled&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_data_valid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_data_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-TX: %08x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_data_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can call this test point #1.&lt;/p&gt;

&lt;p&gt;Once an entire block of data had gone through the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
encoder, it would then generate parity bits.  I dumped these to the same
log as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_enabled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_parity_valid&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_parity_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-TX: RES&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PARITY_BITS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %04x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_parity_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(This test point doesn’t get a number, because my diagram in Fig. 3
doesn’t really show this part of the path very well.)&lt;/p&gt;

&lt;p&gt;I repeated the same process on receive.  As data came into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; decoder,
it was also dumped to the log.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx_data_valid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_enabled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_data_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-RX: %08x -- LAST at %t&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
							&lt;span class=&quot;n&quot;&gt;rx_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-RX: %08x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can call this test point #2.&lt;/p&gt;

&lt;p&gt;Before moving on, I should point out a key feature of this test point that
I don’t want to pass up, and that is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$time&lt;/code&gt;.  One of the challenges of
working with both simulation logs and trace files together is synchronizing the
two.  That’s where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$time&lt;/code&gt; comes in handy, and I’ve gotten to using it in
this manner often.  Because this test point outputs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$time&lt;/code&gt;, I can now use
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$time&lt;/code&gt; in this log to find the associated step in the trace and to
then see the context associated with this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$display()&lt;/code&gt; function call.&lt;/p&gt;

&lt;p&gt;Finally, when the decoder made it’s error correction decisions, those were
also dumped to the log.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_enabled&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_data_valid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_data_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-MASK: %08x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_data_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can call this test point #3.&lt;/p&gt;

&lt;p&gt;For reference, you can see all of these test points in Fig. 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Test points&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/testpoints.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first step to analyzing this log file was to search for all lines
starting with “ECC-“.  In the future, if I do this again, I’ll probably write
to a specific
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
log file, but for now these messages were dumped together
with the rest of the simulation log.  The good news is that the rest of the
simulation log provides the context for what’s going on.  The bad news is that
dumping 16kB of data for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
engine doesn’t make a pseudo human-readable log any more legible.  Because
of the mess this makes of the simulation log, I’ve gated all of this logic
with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OPT_ECC_DEBUG&lt;/code&gt; parameter and only turn the parameter on when I
need to.&lt;/p&gt;

&lt;p&gt;Even before building any better capabilities, this helped: it allowed me to
see the data going into the gearboxes, and then coming out again.  I could
then make sure that things were lined up properly.&lt;/p&gt;

&lt;p&gt;It wasn’t enough.&lt;/p&gt;

&lt;p&gt;One particular problem was that the TX and RX data were so far separated in
time.  That made it difficult to tell whether any problem lied between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; components, such
as in the transmitter to the device, the memory model, the test-bench error
generator, or the receive logic on the other end.  However, it wasn’t all
that hard to generate a simple C++ program to process this pseudo human-readable
data, to place the TX data next to the RX data and then notice if anything had
changed.  This one piece of software alone helped me catch nearly all of my
bugs.  (Remember, I started with a &lt;em&gt;working&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
design–that means most bugs should be confined to my changes alone.
Unfortunately, I changed a lot of stuff.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Feeding the golden reference model&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/binfile.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That software alone, however, wasn’t sufficient.  It was close, but not quite
there, and this is where today’s particular problem comes into play: because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
is a challenge to debug, I needed to know more of what was going on &lt;em&gt;inside&lt;/em&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
algorithm.  This is where the third debugging step comes
into play: feeding the golden reference model.  That is, I adjusted my
log reading program so that it could generate a binary file that could then
be ingested into my golden reference model, as shown in Fig. 7 above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: left&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/feedref.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At one point, it was only by comparing the trace coming out of the golden
reference model with the one from my larger integrated test environment that
I found the bug.  One of the bugs I found was even in
the &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
translation of my Verilog, and so I thank the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
team, and in this case Mr. Snyder in particular, for fixing it quickly.&lt;/p&gt;

&lt;h2 id=&quot;customers&quot;&gt;Customers&lt;/h2&gt;

&lt;p&gt;I wish I could say this was the end of the story: the design worked, and should
now be shipped.  Sadly, it wasn’t.  Three further problems then turned the
simple update listed above into a nightmare for both my team and our customer.&lt;/p&gt;

&lt;p&gt;First, as a simple background, let me set the stage: I offered to make this
maintenance upgrade for a simple two weeks of work.  The updates were simple
enough, they should’ve only taken two weeks.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/requirements.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;It was only once those two weeks were over that the challenges began.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Once I was ready to turn in the work, the customer started demanding
other changes.  (Changes that they had no intention of paying for …)
Worse, they were asking for fundamental changes which would force me
back to the drawing board for this design.&lt;/p&gt;

    &lt;p&gt;The laughable part of these demands?  In the same breath they asked for
a fundamental redesign, they also asked for the current design to be
shipped in order to support their RTL freeze date in less than two more
weeks.  Then they were upset when we didn’t deliver according to their
schedule, when they were the ones who changed the requirements mid-task.
Seriously.  You just can’t make this stuff up.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;One problem I wasn’t expecting was that the memory device model implemented
address regions not present in the actual memory device.  Adding a four byte
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; required all
of the addresses within to be updated to make room for these extra four
bytes.  How many places did these addresses need to be updated in?  Let’s
just say that I really dislike &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic
numbers&lt;/a&gt;, since
their usage in this project by the prior developer made this part of the
update all the more painful.&lt;/p&gt;

    &lt;p&gt;You can read some more of &lt;a href=&quot;/blog/2022/09/21/vlog-wait.html&quot;&gt;my thoughts on test bench design
here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last problem was a repository merge nightmare.  Sadly, I had made my
changes to a design that wasn’t the “latest” design–the customer had
submitted changes to the design that I was unaware of.  I didn’t discover
this until after I had turned my changes in.  Then I discovered I was
about two versions behind the official latest version.  Bugs discovered
here were …  anything but what I was expecting.&lt;/p&gt;

    &lt;p&gt;For example, one of the test scripts depended upon a 1000 clock cycle
reset.  This script would wait 100 cycles, then set a “fixed” value that
needed to be referenced when the design came out of reset.  The test bench
script then then waited for the signal that this (optional) startup process
had taken place.  Not knowing this, I had come along and tried to speed
up the simulation by switching to a 3-cycle reset and … all kinds of
regression hell broke lose when the two “working” designs needed to be
merged.  Was there any documentation discussing why a 1000 clock cycle
reset was necessary, or why a key reset input wouldn’t get set until 100
clock cycles into the simulation?  Well, one might hope.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The end result was that I spent another 2-3 months, beyond the 2-week update
task, working on the test bench, rebuilding the model, fixing &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic
numbers&lt;/a&gt;,
fixing &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)&quot;&gt;the many places the same task was
accomplished&lt;/a&gt; in error, and more.&lt;/p&gt;

&lt;p&gt;My simple two week task?  Sure, it took two weeks to do.  It then took another
two months arguing with the customer over what the requirements needed to be.
Another month was then spent chasing down bugs associated with merging
the repository, and then another two were spent dealing with further
consequences of the original merge as they continued to ripple through the
&lt;a href=&quot;/blog/2022/09/21/vlog-wait.html&quot;&gt;test model and test script
library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And the customer?  The customer wanted to know why the design couldn’t be
delivered the same afternoon that I submitted my changes to the official
repository.  Worse, they are now convinced that the problems associated with
these updates are due to the unreliability of the IP they purchased, rather
than rippling consequences of the changes they made working their way
through the design.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;When faced with a really &lt;em&gt;hard&lt;/em&gt; HDL problem, consider using a golden
reference model and comparing your design against that reference.  Any
differences between the two should lead you directly to any bugs.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tweets/bible/diligence.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As for difficult customers?  Be honest.  Smile, and do your best.  There will
be other customers.&lt;/p&gt;

&lt;p&gt;Oh, and the end of this tale?  I’m now working to port those same changes to
another controller, which means I get to reuse both my golden reference model,
as well as the software I used to reformat the data into something that could
be ingested into it.  Once I post this article, I’ll go back to looking for
the differences between the two.  The good Lord only knows what I’ll find
at this point.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Be careful for nothing; but in every thing by prayer and supplication with thanksgiving let your requests be made known unto God.&lt;/em&gt;</description>
        <pubDate>Mon, 13 Feb 2023 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/blog/2023/02/13/eccdbg.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2023/02/13/eccdbg.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Your soft-core CPU won't boot.  Where should you start debugging?</title>
        <description>&lt;p&gt;When I first decided to start &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;, one of my
first internal projects was to see if I could get the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt; kernel to boot from a read-only
file system–to promote longevity on a flash device, using a kernel that I
could swap out remotely at a later time via a call to
&lt;a href=&quot;https://wiki.archlinux.org/title/kexec&quot;&gt;kexec()&lt;/a&gt;.  I intended to
do this using a &lt;a href=&quot;https://beagleboard.org/black&quot;&gt;Beagle Board Black&lt;/a&gt;, and then
to sell the capability to a customer as something they could do with their
own internally developed boards.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/blank-screen.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;So, I made a bunch of kernel configuration changes, and then tried to boot
my newly configured kernel.&lt;/p&gt;

&lt;p&gt;Nothing happened.&lt;/p&gt;

&lt;p&gt;I just stared at a blank screen.&lt;/p&gt;

&lt;p&gt;At the time, I had no idea where to start.&lt;/p&gt;

&lt;p&gt;Since that time, I’ve gone on to build &lt;a href=&quot;/about/zipcpu.html&quot;&gt;my own
CPU&lt;/a&gt;.  In other words, I’ve now had
to deal with this problem many times over, where I “start” my CPU and
nothing happens.  No, I haven’t gone back to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
kernel, but I’ve
still had the same basic problem.&lt;/p&gt;

&lt;p&gt;There is one key difference, however: with a soft-core CPU, 1) I know my
hardware (I never knew the ARM that well), and 2) I can run a
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
of that hardware and &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;get a
trace&lt;/a&gt;
leading me straight to the problem.  (Yes, this is a
painful approach, but it is a reliable one.)&lt;/p&gt;

&lt;p&gt;So, let me offer you some of the lessons I’ve learned while trying to debug
the startup of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
Specifically, how shall the CPU be debugged between when it is released from
reset and the first (successful) call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt;?&lt;/p&gt;

&lt;h2 id=&quot;how-to-debug-a-boot-failure&quot;&gt;How to debug a boot failure&lt;/h2&gt;

&lt;p&gt;So, let’s look into how one might debug a “boot failure”.  In this case, by
“boot failure”, I mean that you’ve “loaded” both your soft-core CPU either
into &lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
or onto an FPGA, and your program onto your memory device
and then something goes wrong between &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;releasing the CPU from
reset&lt;/a&gt;
and the first console output.  The question here and now is, how do you
debug that?  I mean, a CPU represents a lot of logic to dig through, and
there’s a lot of software between reset and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;.  How do you go about
narrowing down the problem to find the bug?&lt;/p&gt;

&lt;p&gt;Here’s some of the approaches I’ve found valuable.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start at the &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction
fetch&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;My first step is almost always to look at a
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
trace of the &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction
fetch&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;For this, you’ll first need a hex dump of the program you are trying to run.
I usually get this from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;objdump -S -D &amp;lt;program&amp;gt;&lt;/code&gt;.  Indeed, I use this
command so often, I have a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/board/Makefile#L80-L81&quot;&gt;common “make”
target&lt;/a&gt;
that I will use to produce this dump file.&lt;/p&gt;

    &lt;p&gt;Now, looking at the dump file, open a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;simulation
trace&lt;/a&gt; and look at the
address and value of the first several instructions coming from the
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction fetch&lt;/a&gt;
and going to the CPU’s core.  These address/value pairs
should match a dump of your executable file.&lt;/p&gt;

    &lt;p&gt;If they don’t match, that should tell you where to look next:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Reset problems&lt;/p&gt;

        &lt;p&gt;Are you getting any instructions from the
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction fetch&lt;/a&gt;
at all?  If not, you might have a bug in your &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;reset
control&lt;/a&gt;.
Does the CPU come out of reset at all?  If it does, does it come out
of reset reading from the right address?&lt;/p&gt;

        &lt;p&gt;It can be a challenge to get a CPU, configured to boot from a
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash memory&lt;/a&gt;
address, to start from a different address describing some other memory
that might be easier to work with–such as block RAM.  I often do this to
initially verify the CPU, before verifying the
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash memory&lt;/a&gt;, but
getting a program to load and start properly from somewhere other than the
reset address can be a true test of both the loader and the &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;CPU’s
debugging port&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Loader&lt;/p&gt;

        &lt;p&gt;Did your software get loaded into the right place?  That is, if the CPU
is coming out of reset properly, and if it is reading from the right
addresses, is it getting the right values?  If not, then this is worth
chasing down through the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace&lt;/a&gt;.
You might find that you haven’t loaded the right values into memory in
the first place.  (Or … you might also find that either your
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction fetch&lt;/a&gt;
unit, your
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;, or
your memory controller are broken ….)&lt;/p&gt;

        &lt;p&gt;In my case, I often need to be reminded that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;big 
endian&lt;/a&gt; machine while my host
computer is a x86 type of &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little
endian&lt;/a&gt; machine.  Sometimes
a translation is required between the two.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/nfs.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Memory controller problems&lt;/p&gt;

    &lt;p&gt;Before you start your CPU, it’s often worth double checking the load
interface.  After writing to address XYZ, for example, can you read the
same value back from address XYZ that you have just written to it?  This
problem may be indistinguishable from a loader problem.  In both cases,
values will be read from memory, but they won’t be the right values.&lt;/p&gt;

    &lt;p&gt;To tell the difference between loader and memory controller problems, pick
one address that the
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;fetch&lt;/a&gt;
returns in error and track what’s written to it.
If the loader puts the right value into it, but the memory controller
returns something else, then you know to look into your memory controller
for the bug.  We’ll come back to this again in a moment.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/financial.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can often dig into this bug using a &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
  bus&lt;/a&gt;: While &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;holding
  the CPU in
  reset&lt;/a&gt;,
  write to the memory that will hold it’s program and then
  read the memory values back out.  They should match.  This doesn’t always
  work, however, since the CPU might use types of accesses to the memory
  that the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debug bus&lt;/a&gt;
  &lt;a href=&quot;/2021/12/30/dbgaxil.html&quot;&gt;doesn’t support–things like
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARLEN&amp;gt;0&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARBURST=WRAP&lt;/code&gt;&lt;/a&gt;–but
  it’s at least a good start.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/why-auto.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Bus addressing&lt;/p&gt;

    &lt;p&gt;There’s always the possibility that you have an error in how the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;bus interconnect&lt;/a&gt;
was set up.  Perhaps the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;bus interconnect&lt;/a&gt;
is routing the CPU’s reset address to the wrong slave, perhaps you have
the wrong number of address wires driving the slave.  Either way, you’ll
see this problem when tracing the instruction request from the CPU back
to the bus slave responding to it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; is just a bunch of memory copies.  Look for the loops.&lt;/p&gt;

    &lt;p&gt;The first piece of software any CPU starts is often known as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;.  This
is the software that sits between reset and main().  This is the software
responsible for placing your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; program into memory.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 1. CRT0 is primarily a bunch of memory copies&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/crt0.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first thing
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
   needs to do is to configure your RAM or ROM controllers.  The next step
   is usually a series of memory copies.&lt;/p&gt;

&lt;p&gt;On many computers, &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
   is written in assembler.  While I tried to avoid that with the
   &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, there’s still &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/bc3ced1d51c975b20877d39aac0a578a461835f5/sim/zipsw/zlib/crt0.c#L165-L219&quot;&gt;a small
   assembly routine required&lt;/a&gt;
   before I can transition to the C function that performs the actual
   memory copies–&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/bc3ced1d51c975b20877d39aac0a578a461835f5/sim/zipsw/zlib/crt0.c#L266&quot;&gt;a function I’ve named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;&lt;/a&gt;.
   The small assembler script is responsible for any hardware configurations
   necessary to get the RAM running, for then setting the
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
   and finally for calling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; function.  This is marked
   as step 1 in Fig. 1 above.  Because this step is so small, typically
   less than 20 instructions, it can easily be debugged using the
   &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace file&lt;/a&gt; if necessary.&lt;/p&gt;

&lt;p&gt;This is not the case with the step that follows.&lt;/p&gt;

&lt;p&gt;The first step of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; function, marked as step 2 in Fig. 1,
   is a big memory copy.  It will &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c#L324-L333&quot;&gt;copy instruction memory from ROM to RAM&lt;/a&gt;,
   and then again to &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c#L324-L333&quot;&gt;copy any pre-initialized global variables from ROM to
   RAM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Debugging this memory copy can be a challenge.&lt;/p&gt;

&lt;p&gt;So how do you go about debugging a
   &lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;?
   That piece of software 
   is just a huge loop!  The CPU may be copying millions of bytes, and
   so staring at this trace can quickly get frustrating.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/zippc.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here’s the trick: instruct your
   &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD&lt;/a&gt;
   &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;viewer&lt;/a&gt;
   (I use &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;)
   to display the CPU instruction address register, often called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program
   counter or PC (for short)&lt;/a&gt;,
   as an “analog” waveform.  Then zoom out.  Watch how this waveform changes,
   and you’ll quickly find where the loop begins and ends.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure the bus doesn’t freeze up while reading.  This is often a sign
that you didn’t formally verify a bus component.  It could be either
&lt;a href=&quot;https://zipcpu.com/zipcpu/2021/04/17/axilops.html&quot;&gt;CPU’s memory
controller&lt;/a&gt;, the
hardware memory controller, or the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt; between
the two.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Look for loops that do not end.  This is often a sign that either the
CPU can’t execute the instructions you think it can, or that the CPU
is reading the wrong data from memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now debug the beginning and ending of these loops&lt;/p&gt;

    &lt;p&gt;If the first word is correctly copied into memory but the last word is not,
then bisect the loop as many times as necessary to find the bug.  Perhaps
you are copying from a device that isn’t as big as you think it is?
Perhaps you have an incorrect copy size?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One problem I’ve often had here can be traced to trying to use one
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
   routine for many hardware situations.  For example, sometimes I’ll have a
   high speed (block RAM) address range to copy memory to in addition to a
   (slower speed) SDRAM address range.  To tell the difference, I need to
   check this block RAM address against NULL &lt;em&gt;after linking&lt;/em&gt;.  However, GCC
   will often &lt;em&gt;assume&lt;/em&gt; the address is not NULL (because of how I’ve declared
   it), and so skip this comparison.  In this case, the CPU didn’t run all the
   &lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;’s I had
   requested.  Looking over how
   &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c&quot;&gt;CRT0&lt;/a&gt;
   got translated to assembly should show you if the NULL checks were removed
   by the compiler or not.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/know-assembly.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;After copying program memory and initial variables, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;
   routine then needs to &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c#L335-L343&quot;&gt;zero
   out&lt;/a&gt;.
   the &lt;a href=&quot;https://en.wikipedia.org/wiki/.bss&quot;&gt;BSS data segment&lt;/a&gt;.  This basically
   requires a glorified
   &lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;,
   which can be debugged in the same fashion as the
   &lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt; above.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Verify the &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction
fetch&lt;/a&gt; following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; routine&lt;/p&gt;

    &lt;p&gt;Once &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c&quot;&gt;CRT0&lt;/a&gt;
completes, that is once both the (alternative)
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt; and
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;
functions complete, the CPU should jump to the beginning of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;.
This is illustrated as step 4 in Fig. 1 above, and shown in Fig. 2 below.
Therefore, let’s go back to the &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction
fetch&lt;/a&gt;
and see that it does so.&lt;/p&gt;

    &lt;p&gt;Does the CPU return from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; properly?  Or did
the return address get overwritten somehow?&lt;/p&gt;

    &lt;p&gt;Are the instructions provided to the CPU the correct ones?&lt;/p&gt;

    &lt;p&gt;In one case, I used the DMA to copy data from the
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash&lt;/a&gt;
to a DDR3 SDRAM via Xilinx’s DDR3 controller.  When I struggled to get the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; software to work, I called
a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/syscalls.c#L54-L68&quot;&gt;software serial port output
routine&lt;/a&gt;
from within &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; to help me debug what
was going on.  In that case, the serial port output routine
I used wanted to insert carriage return characters before newlines, and
so it needed to know if the last character was a carriage return.  This
value was supposed to be kept in SDRAM memory–the very memory I
was trying to use and load.  This shouldn’t be a problem, I reasoned,
since at most I might output an extra carriage return, and the
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;
routine would eventually overwrite this value with the correct one anyway.&lt;/p&gt;

    &lt;p&gt;The problem, however, was that using this memory region caused the CPU
to read memory &lt;em&gt;into the data cache before&lt;/em&gt; the DMA completed.  This
left me with with a corrupt copy of data memory in the cache once the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; completed.  In other words, don’t forget to clear the
cache once the DMA completes any memory copies.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;SIM instructions&lt;/p&gt;

    &lt;p&gt;Many CPU’s, to include both &lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt; and the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, have special simulation
only instructions.  These are basically &lt;a href=&quot;https://en.wikipedia.org/wiki/NOP_(code)&quot;&gt;NOOP
instructions&lt;/a&gt; that will cause
the CPU to perform a special task in simulation only.  In the case of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the instruction
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOUT&lt;/code&gt; can be used to dump a character to the simulation console.  The
instruction &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt; can be used to dump a register’s value to the console.
The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; assembler also
understands &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSTR&lt;/code&gt;, which can be used to create a series of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOUT&lt;/code&gt;
instructions to send a more readable string to the simulation console.
If these instructions are left in the code when it runs in actual hardware,
then they will simply be ignored like any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/NOP_(code)&quot;&gt;NOOP instruction&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;How can you use these?  You can use them to pepper your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; function with these
instructions, and therefore know how far your CPU got in the
bootup process before it died.&lt;/p&gt;

    &lt;p&gt;In my case, I’ve done this often enough that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;
function&lt;/a&gt;
has the appropriate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; commands (commented) throughout, so I can
uncomment these if necessary to tell how far it got in the loading process.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Use the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
bus&lt;/a&gt; to your advantage&lt;/p&gt;

    &lt;p&gt;I recently had the opportunity to test both a
&lt;a href=&quot;https://www.apmemory.com/products/psram-iot-ram/&quot;&gt;PSRAM&lt;/a&gt; and a
&lt;a href=&quot;https://1bitsquared.com/products/pmod-hyperram&quot;&gt;HyperRAM&lt;/a&gt; driver
with the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  In both cases,
however, the memory needed to be configured properly before it could be
used.  This meant that I needed to modify the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; function so that it
first configured the memory, and the memory controller, before attempting
to copy the CPU software to memory.&lt;/p&gt;

    &lt;p&gt;To get this right, I first fired up the hardware and used the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debug
bus&lt;/a&gt; to read and
write hardware memory controller configurations.  Any problems were
debugged using the &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBSCOPE&lt;/a&gt;
until the memory fully worked.  Then, with the same
&lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;,
I verified that I could read and write values to this memory using the
configuration I was testing.  Only after I tested these memory
configurations did I then tell the CPU to invoke them from its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; function.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/config-flash.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The problem was actually a bit worse, though, since I wanted to reconfigure
   the flash memory controller that was responsible for reading the initial
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; software.  This controller
   naturally started in SPI mode, but I wanted to reconfigure it to run using
   XiP in QSPI mode.  (Normally, my flash controller does this on startup,
   but I was testing an ASIC controller that day that didn’t have such an
   option.)  That meant I needed to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Configure the external RAM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Copy a small subroutine to the external RAM.  This got copied to the
same RAM location that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; would run from later.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using that small subroutine, take the flash driver off-line and
reconfigure it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Return to the original &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
function, to now perform the
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;s as
normal, but this time with a flash running in QSPI XiP mode&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure I flushed the instruction cache, now that my (own) program
memory had changed.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Debugging this was a bit of a pain, but still it was all quite doable.
   The trick was figuring out how to debug the small subroutine, running in
   RAM, that was reconfiguring the flash driver.  For that, I used the
   &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s BREAK instruction to force
   it to halt mid-run, where I could &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;inspect what the CPU had
   accomplished&lt;/a&gt;.&lt;/p&gt;

&lt;ol start=&quot;6&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;CPU Break instructions&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK
instruction&lt;/a&gt;.
Other CPU’s often have something similar.  Sometimes an
illegal instruction gets repurposed to accomplish the same thing.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; uses its
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;
for debugging.  When/if the CPU hits a
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;,
it will halt and wait for the debugger.  At this point, I can &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;step in and
check&lt;/a&gt; the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s register values and any
hardware configurations.  This is really powerful.  For example, you
might:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/fundamental.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Make the first instruction of &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
a &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;.
If the CPU hits the break, you know it managed to 1) boot from the right
address, and 2) read the right instruction at that address.  (While
it’s possible you might still read the right instruction in spite of
these being in error, this would break the fundamental assumption of all
debugging.)&lt;/p&gt;

    &lt;p&gt;This is a big help, especially if you are stuck debugging the CPU
from hardware.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Place a second
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;
after configuring memory.  Now go in and check: was the memory configured
correctly?  Can you still read and write your memory via a
&lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;?
If not, then back up and fix your bug.&lt;/p&gt;

    &lt;p&gt;In the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s case, the
debugger isn’t (yet) smart enough to handle more than one
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;.
I will therefore recompile the software without the first
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;,
but now including the second one.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Place another
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;
after each of the various
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;
functions within &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;.  Are each
of these
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instructions&lt;/a&gt;
getting hit?
When they are hit, has the memory that was supposed to be copied been
copied properly?  I usually just check a couple of addresses: the first
three and the last three.  I tend not to check the middle unless these
first and last ones are too repetitive to provide me with any confidence
that the copy was done properly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make the first instruction of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; a
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;.
Does the CPU get that far?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s back up to our original list and keep going.  For example …&lt;/p&gt;

&lt;ol start=&quot;7&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;What if your CPU doesn’t have a break instruction?&lt;/p&gt;

    &lt;p&gt;If your CPU doesn’t have a break instruction, sometimes you can get away
with a “branch to the current address” instruction, and so create a very
tight loop.  While it’s not quite the same thing, it can still work for this
purpose.&lt;/p&gt;

    &lt;p&gt;If your CPU doesn’t have a &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debug access port to read and write registers
from&lt;/a&gt;,
then you may need to spend a lot of time doing the same thing with
LEDs.  While slower, it’s still doable.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/clib-printf.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol start=&quot;8&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Console output, but without the console device driver&lt;/p&gt;

    &lt;p&gt;If you can get to the BREAK instruction at the beginning of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;,
then you are almost there.  Once you get this far, if you are still not
there then the problem must exist between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; and the first console
output.&lt;/p&gt;

    &lt;p&gt;The next check, therefore, is to make sure the console even works.&lt;/p&gt;

    &lt;p&gt;There are a couple of problems you might have here.  For example, is the
console port properly connected to the bus?  Is it at the right address?&lt;/p&gt;

    &lt;p&gt;For this, you can again use the
&lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;.
Use it to write to the console device while the CPU is halted.  Do the
values you write get written to the CPU’s console?  If not, then pull
it up in the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulator&lt;/a&gt;
and figure out why not.&lt;/p&gt;

    &lt;p&gt;If it fails in the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulator&lt;/a&gt;,
then you should have all the information you need to know how to fix it.&lt;/p&gt;

    &lt;p&gt;If it works in the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulator&lt;/a&gt;,
but not in actual hardware, then check that
the &lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;right IO pin is connected, and that the serial port is configured for
the baud right rate&lt;/a&gt;.
(You can read about &lt;a href=&quot;https://zipcpu.com/blog/2018/08/04/sim-mismatch.html&quot;&gt;other reasons why a design might work in simulation,
but not in real hardware,
here&lt;/a&gt;.)&lt;/p&gt;

    &lt;p&gt;This particular bug is actually a fairly rare bug for me, since I typically
use the serial port for the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
bus&lt;/a&gt;.  So, in my
case, if I have the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
bus&lt;/a&gt;
running in the first place then I’ve already &lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;debugged the serial port’s
hardware&lt;/a&gt;.
I know, for example, that I have the right IO pin, the right
baud rate, the right parity, the right number of bits per character, etc.&lt;/p&gt;

    &lt;p&gt;Once the raw serial port works, in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
first and then hardware,
and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt; still doesn’t, then it’s time to debug the standard library.
For this, I’ve been known to add more SIM instructions, either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; or
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt;, into the library to trace it through it’s operation and find out
where it’s failing.&lt;/p&gt;

    &lt;p&gt;Once the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_file_input/output&quot;&gt;stdio library&lt;/a&gt;
works (in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;),
but still fails in hardware, the next step would be
to add serial port accesses to your design that bypass the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_file_input/output&quot;&gt;stdio&lt;/a&gt;
see where the design is failing.  I have a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/txfns.h&quot;&gt;special set of functions, I
call them
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;txfns&lt;/code&gt;&lt;/a&gt;, that
I use for this purpose.  They’re designed to be as light and as simple
as possible, while writing outputs to the serial port.  Using them, I can
output strings and hexadecimal numbers directly to the serial port.  That’s
usually enough to debug the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_file_input/output&quot;&gt;stdio
library&lt;/a&gt;.  You can think
of these functions as hardware replacements to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt;, since
that’s how I typically use them.&lt;/p&gt;

    &lt;p&gt;You could also use
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instructions&lt;/a&gt;
here.  Again, the goal is to both figure out where the software is going
as it works its way through &lt;a href=&quot;https://en.wikipedia.org/wiki/C_file_input/output&quot;&gt;the
library&lt;/a&gt;,
as well as to dump enough values at any particular point along
the way so that you can “see” what’s going on.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/stupid-murphy.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol start=&quot;9&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Once you get to the console output, things get easier&lt;/p&gt;

    &lt;p&gt;Debug by printf is a thing.  It may not be ideal, but it does work.
When compared to debugging a blank cursor, debug by printf() will feel like
cooking with gas.&lt;/p&gt;

    &lt;p&gt;The task of this article, however, has been to illustrate how to
this far in the first place.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;crt0-example&quot;&gt;CRT0 Example&lt;/h2&gt;

&lt;p&gt;Just for understanding, let’s walk through this process by examining how
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would go about running
&lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello World&lt;/a&gt;.
We’ll look at this from
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt;, all drawn from the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/dev&quot;&gt;ZBasic&lt;/a&gt;
(&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt; only)
distribution, and I’ll show you some valuable things you can notice from these
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt; alone.&lt;/p&gt;

&lt;p&gt;Our first &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; shows an
overview of what &lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello
World&lt;/a&gt;
would look like from a &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
standpoint.  It shows the CPU from after reset, through loading &lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello
World&lt;/a&gt;, running
&lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello World&lt;/a&gt;,
and then cleaning up and closing the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
In this case, “cleanup” is another way of saying, “waiting for the serial
port to finish its writes.”&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. An overview of running Hello World on the ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/overview-annotated.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let me walk you quickly through the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt; shown in Fig. 2.&lt;/p&gt;

&lt;p&gt;The first two &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt;
are either the &lt;a href=&quot;/formal/2019/02/21/txuart.html&quot;&gt;serial
port&lt;/a&gt;’s input or its
output.  As you may &lt;a href=&quot;/formal/2019/02/21/txuart.html&quot;&gt;recall, serial
port&lt;/a&gt;s idle high, so here
you can see that the outgoing serial port wire is idle for most of the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;, until it finally sends
the “&lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello, World!&lt;/a&gt;”
output out.&lt;/p&gt;

&lt;p&gt;In the particular configuration shown here, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has been configured to drive the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt; from
either its instruction or its data cache.  An arbiter has already selected
one of these two, but you may watch it change from one to the other in
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt; to follow.
AutoFPGA has labeled the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s bus
signals with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bus_component_*&lt;/code&gt; prefix, in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wb_zip_&lt;/code&gt;. As you
might expect, the first access, following reset, is to read the first
instruction.  This is where our figure starts.  This access has been held up,
however, until the &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;Quad SPI flash
controller&lt;/a&gt;
finishes configuring the external flash device (model) for eXecute in
Place (XiP) Quad SPI mode.&lt;/p&gt;

&lt;p&gt;The “ipc” &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; shows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;Program Counter (PC)&lt;/a&gt;,
or more specifically the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;supervisor&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  (Another register, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;upc&lt;/code&gt;,
captures the &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;.)
I’ve also added the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc&lt;/code&gt; register to this display twice.  The first
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
shows it in its default hexadecimal display setting.  A quick glance will
illustrate this trace is generally unreadable unless you zoom in so far you
lose all of the surrounding context.  The second &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc&lt;/code&gt; trace is set to analog
mode.  Here you can see very distinctly where the CPU jumps from flash memory
to the block RAM used by the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/dev&quot;&gt;ZBasic
distro&lt;/a&gt; for most of its operation.
This is the indication that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has just began running
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;&lt;/a&gt;.
(If you look closely, you’ll also see where
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;&lt;/a&gt;
completes and returns control to &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The final &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; is that of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.  Since the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
is just a generic &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;register, and
specifically register 13&lt;/a&gt;,
that’s why it’s listed as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;regset[13][31:0]&lt;/code&gt; on the trace.  The big thing to
notice here is where the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack
pointer&lt;/a&gt; first changes.  This is
your indication that the CPU has &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dev/sw/zlib/crt0.c#L168&quot;&gt;started running
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRT0&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To see more, however, we’ll need to zoom in a bit.&lt;/p&gt;

&lt;p&gt;Let’s start by zooming into the first section of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; area.
In this case, we’ll zoom in a lot.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. CRT0 first copies instructions from flash to RAM&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/crt0insn-annotated.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first thing you’ll notice is that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc&lt;/code&gt; register shows clear looping.
This is to be expected of a memory copy loop.  It is a loop, after all.&lt;/p&gt;

&lt;p&gt;The next thing you’ll notice is that this loop takes place in sections
followed by pauses.  This is caused by the data cache.  Every pause you see
is a cache miss, where the data cache reads another cache line from the
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash&lt;/a&gt;.
The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; then writes the cache
line to RAM.  Since the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
data cache implementations are all &lt;em&gt;write-through&lt;/em&gt; caches, writes to memory
also go immediately to the bus.  These are the busy portions of the loop.&lt;/p&gt;

&lt;p&gt;Finally, you’ll notice that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
is constant throughout this whole section.  That’s an indication that it’s
all taking place within a single function.&lt;/p&gt;

&lt;p&gt;The second big section of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
operation where where the &lt;a href=&quot;https://en.wikipedia.org/wiki/.bss&quot;&gt;BSS segment&lt;/a&gt;
is cleared to zero.  You can see this in Fig. 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. CRT0 next clears uninitialized global (BSS) memory&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/bss-annotated.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this case, I’ve zoomed in around the transition from the instruction copy
to where the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; starts zeroing
the &lt;a href=&quot;https://en.wikipedia.org/wiki/.bss&quot;&gt;BSS segment&lt;/a&gt;.  The first thing I’d
like you to notice is how easy this transition is to see from the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;ipc&lt;/a&gt; trace.  Indeed, the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; suddenly changes shape.
Sure, the rest of the &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
changes shape as well, but if we zoomed out any more you might miss this and
only see the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;ipc&lt;/a&gt; change.&lt;/p&gt;

&lt;p&gt;As with the last section, the shape of this section is primarily driven by
the data cache.  This &lt;a href=&quot;https://en.wikipedia.org/wiki/.bss&quot;&gt;BSS&lt;/a&gt;
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;
loop just writes to one value of memory after another, with each value
passing straight through the cache to memory.&lt;/p&gt;

&lt;p&gt;What you may not notice is that there haven’t been any requests of the
bus for instructions.  If you look closer, however, you’ll see that’s not
quite true.  Just before the
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;
loop, there’s a cache request–this
time from the &lt;em&gt;instruction&lt;/em&gt; cache, to get the next eight instructions.  These
are sufficient to then run the
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;
function from cache alone.  Hence,
there are no more instruction requests of the bus until this loop exits.&lt;/p&gt;

&lt;p&gt;Just to show one final example of looping in
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt;,
Fig. 5 below shows the activity on the bus associated with the serial port
while the design finally sends
“&lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello, World!&lt;/a&gt;”
to the console.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Sending Hello World to the console&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/console-annotated.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now, if you look at the bus ports for the console, shown with the prefix
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wb_uart_&lt;/code&gt;, you’ll see a repeating pattern of two requests.  The first is
a read request, to verify that there’s room in the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;’s buffer
for another byte of data.  The second is a write request, sending the next
byte to the buffer.&lt;/p&gt;

&lt;p&gt;The big thing to learn here, if nothing else, is the utility of displaying
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; as an analog signal.&lt;/p&gt;

&lt;h2 id=&quot;debugging-a-memory-value&quot;&gt;Debugging a memory value&lt;/h2&gt;

&lt;p&gt;One common problem I’ve run into is where you get deep into the standard
library (i.e. into someone else’s software), and you see the CPU read some
value from memory and then do the wrong thing.  Or, rather, it does the right
thing but with the wrong value.  That leads to the question, why was that
value wrong?  When did it become wrong?  These are both things you may
need to answer.&lt;/p&gt;

&lt;p&gt;I discussed how to find a bug like this in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
in a previous post.&lt;/p&gt;

&lt;p&gt;What if you need to find this value while running from hardware?&lt;/p&gt;

&lt;p&gt;Ouch.  That’s harder.  Still, the same approach applies: pick the address of
interest, and track its value.&lt;/p&gt;

&lt;p&gt;In hardware, this often means that you’ll need to create a bus monitor
peripheral.  That monitor peripheral will then look to find &lt;em&gt;every&lt;/em&gt; time you
write to a given address, and keep track of what the value at that address
becomes when you write to it.  Beware, inserting such a peripheral into your
design might change your address map, so you might need to do a bit of
rework, but the basic idea applies.&lt;/p&gt;

&lt;p&gt;If your monitor detects a “wrong value” being written to the address of
interest, then it should be able to halt the CPU–so you can see what just
happened.  Or, perhaps, you might wish to simply &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;trigger a
trace&lt;/a&gt;
of the CPU to see what’s going on there.&lt;/p&gt;

&lt;p&gt;If, on the other hand, you never write a “wrong value” to the address of
interest, and yet still read a “wrong” value–then you know where to look: the
memory controller for the memory you are writing to.  You may need to
initiate reads of this address at various other times–at least enough to
narrow down and find when the value is changing.  Is it changing via a bus
write to some other address?  That would be important to know.  Is it not
changing when it’s being written to?  That would also be important.  Finding
out when, and the circumstances around it will be key to figuring this out.&lt;/p&gt;

&lt;p&gt;Your eventual goal here will be to encapsulate the basic
&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;bug-triggering sequence&lt;/a&gt;
so that you can &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;trigger&lt;/a&gt;
it in a much simplified setting–either with
the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;
and not the CPU, or perhaps in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
From there, you should (hopefully) be able to get a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
in order to narrow it down further.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;The big challenge with all of the above tasks is that you are likely going to
be debugging someone else’s work: either their design or their software
library.  In my case, it’s my CPU but Xilins’x MIG controller is not my
RTL, neither are &lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;newlib&lt;/a&gt; nor
&lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS&lt;/a&gt; my software.  Sure,
it’s &lt;a href=&quot;/about/zipcpu.html&quot;&gt;my CPU&lt;/a&gt;, but I didn’t
design any of the other components on the circuit board, nor have I designed
the external memory.  If I want all of these components to work together in
my project and for my purpose, then I need to know how to handle debugging
them.  This will often mean tracing through someone else’s software just
to find the bugs in my own stuff.&lt;/p&gt;

&lt;p&gt;What about &lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;No, I haven’t gone back to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
operating system I tried to boot on the
&lt;a href=&quot;https://beagleboard.org/black&quot;&gt;Beagle Bone&lt;/a&gt;.  I’ve just had too many other
paying opportunities to do something else, and I’ve now lost touch with the
potential customer who may have wanted that system.&lt;/p&gt;

&lt;p&gt;Still, if I needed to debug &lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;,
I think I’d use this same approach.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
kernel contains within it several simplified console output functions
that can be used for debugging the kernel prior to the entire operating system
being up and running.  While I haven’t tried using these personally (yet), I’ve
seen others do it to great success.  Similarly, my
&lt;a href=&quot;https://beagleboard.org/black&quot;&gt;Beagle Bone&lt;/a&gt;
has a JTAG port that I could use instead of the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debug
bus&lt;/a&gt;.  It’s not a
one to one replacement, but my bet is that it will still be good enough.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;In the beginning was the Word, and the Word was with God, and the Word was God. (John 1:1)&lt;/em&gt;</description>
        <pubDate>Sat, 03 Dec 2022 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/zipcpu/2022/12/03/no-boot.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2022/12/03/no-boot.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Thanksgiving!  I have much to be thankful for</title>
        <description>&lt;p&gt;We started a tradition in my family, years ago, of naming the things we are
thankful to God for on each Thanksgiving.&lt;/p&gt;

&lt;p&gt;This year, I would like to share with you those things that I am thankful
for.  The three primary things I am thankful to God for this year are
my salvation, my family, and the business that He has given me.  In many
ways, these blessings are the natural result of the service I’ve chosen
to give to God.  (&lt;a href=&quot;https://www.blueletterbible.org/kjv/heb/11/6&quot;&gt;Heb 11:6&lt;/a&gt;)
For this reason, I’d also like to take a short moment to walk through some
verses, and to try to describe the results of my attempts to follow the same.&lt;/p&gt;

&lt;h2 id=&quot;salvation&quot;&gt;Salvation&lt;/h2&gt;

&lt;p&gt;The salvation Jesus Christ offers is easily summarized in this verse:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kiss the Son, lest he be angry, and ye perish from the way, when his wrath
is kindled but a little.  Blessed are all they that put their trust in
him.  (&lt;a href=&quot;https://blueletterbible.org/kjv/psa/2/12&quot;&gt;Ps 2:12&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Salvation starts when a man chooses to trust God’s son, Jesus.  This is a
commitment.  As a result of trusting God, this man will keep God’s words and
obey as he is able.  The result, according to this verse, is such a blessing
as only God can give.  It’s value is greater than gold
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/psa/19/10&quot;&gt;Ps 19:10&lt;/a&gt;) or rubies
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/job/28/12-19&quot;&gt;Job 28:12-19&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/3/13-15&quot;&gt;Prov 3:13-15&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;My life changed significantly when I chose to trust God’s son, Jesus.  It
is because of these changes, and the results of following God, that I am
now so thankful this year.&lt;/p&gt;

&lt;h2 id=&quot;family&quot;&gt;Family&lt;/h2&gt;

&lt;p&gt;When I first committed my life to Christ, I was married but had no
&lt;em&gt;family&lt;/em&gt; to speak of.  My wife and I were separated, and we had no
children.&lt;/p&gt;

&lt;p&gt;My fiance and I both graduated from the US Air Force Academy.  She
went to Columbus, Mississippi to become a pilot, I went to Dayton,
Ohio, to get a masters degree.  We were married while we were apart.&lt;/p&gt;

&lt;p&gt;During this dark time, I still remember the first day I arrived at
&lt;a href=&quot;https://www.ebcbellbrook.org/&quot;&gt;Emmanuel Baptist Church, now in Bellbrook,
Ohio&lt;/a&gt;.  At the time I was deeply troubled,
not knowing if my wife and I would ever be together.  Joint assignments
were not sure things.  Much to my surprise, the pastor there was quite
convinced that we would be together.  How could he be so convinced?  This
made no sense to me, since he hardly knew me.  He explained that he
was convinced because he knew the character of the God he served.  At the
time, I wasn’t sure how to take this.  Was the pastor a crack, or did he
really know the Almighty God of heaven and earth that well?&lt;/p&gt;

&lt;p&gt;No, the military is not kind to couples where both are in the service.
Sometimes the personnel office is able to station military spouses
together.  Sometimes, as happened with me after our first assignment
together, the personnel officer will just throw his hands up in the
air and declare that military spouses aren’t guaranteed to live with
each other.&lt;/p&gt;

&lt;p&gt;Marrying a military spouse didn’t leave my wife and I in a happy place.
I would certainly not encourage others to take this path.&lt;/p&gt;

&lt;p&gt;Some time later, my wife and I found the verse in Titus, where God instructs
the older women to, …&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;… teach the younger women to be sober, to love their husbands, to love
their children, to be discrete, chaste, keepers at home, obedient to their
own husbands, that the word of God be not blasphemed.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/tit/2/4-5&quot;&gt;Titus 2:4-5&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The word “at”, found in the phrase “keepers at home”, convinced my wife that
she shouldn’t be in the military in spite of her training and experience as
a helicopter pilot.  She than began the (long and drawn out) process of
separating from the military.  The result of this process was that, after
four happy years together, we were separated for the next year.  During
this time, we didn’t know how long it would be until we’d be together
again.&lt;/p&gt;

&lt;p&gt;We also re-examined the verses where God instructs man to be fruitful
and multiply. (&lt;a href=&quot;https://www.blueletterbible.org/kjv/gen/1/28&quot;&gt;Gen 1:28&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/gen/9/1&quot;&gt;9:1&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/gen/9/7&quot;&gt;9:7&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/deu/28/4&quot;&gt;Deut 28:4&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/deu/28/11&quot;&gt;28:11&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/5/18&quot;&gt;Prov 5:18&lt;/a&gt;)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And you, be ye fruitful, and multiply; bring forth abundantly in the earth,
and multiply therein. (&lt;a href=&quot;https://www.blueletterbible.org/kjv/gen/9/7&quot;&gt;Gen 9:7&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Before coming across this verse, or rather before I took it seriously,
I had been of the belief that every couple should have two children,
and so to maintain the world’s population.  After evaluating these
verses, I chose to do as I was told.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Let thy fountain be blessed: and rejoice with the wife of thy youth.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/5/18&quot;&gt;Prov 5:18&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Those who know us would declare that we now have a “large” family.
I would simply say that every one of our children is a blessing that
I am genuinely thankful for.&lt;/p&gt;

&lt;p&gt;The Bible also teaches how to raise up the children God gives, and
provides encouragement and instruction for the same.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Correct thy son, and he shall give thee rest; yea, he shall give
delight unto thy soul.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/29/17&quot;&gt;Prov 29:17&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yes, we did choose to abandon all of the sage advice printed in
“Christianity Today” for the words of the Bible itself.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/13/24&quot;&gt;Prov 13:24&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/19/18&quot;&gt;19:18&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/22/15&quot;&gt;22:15&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/23/13-14&quot;&gt;23:13-14&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/29/15&quot;&gt;29:15&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/eph/6/4&quot;&gt;Eph 6:4&lt;/a&gt;)
Perhaps it was a risk doing so at first.  Now looking back, I am very
pleased with the result.  Today my children are one of the delights
of my life.&lt;/p&gt;

&lt;p&gt;What is the alternative?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;As for my people, children are their oppressors, and women rule over them.
O my people, they which lead thee cause thee to err, and destroy the way
of thy paths.  (&lt;a href=&quot;https://www.blueletterbible.org/isa/3/12&quot;&gt;Is 3:12&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No, I think I like the results of following God’s way better.  Indeed,
hath the LORD not promised,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Blessed is every one that feareth the LORD; that walketh in his ways.  For
thou shalt eat the labour of thine hands: happy shalt thou be, and it
shall be well with thee.  Thy wife shall be as a fruitful vine by the
sides of thine house: thy children like olive plants round about thy
table. (&lt;a href=&quot;https://www.blueletterbible.org/psa/128/1-3&quot;&gt;Ps 128:1-3&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This describes my life today.  Because of this, I am thankful for my
family: a family I would not have had, were it not for God’s instruction
and subsequent blessing.&lt;/p&gt;

&lt;h2 id=&quot;business&quot;&gt;Business&lt;/h2&gt;

&lt;p&gt;I am also thankful for my business.&lt;/p&gt;

&lt;p&gt;When I started Gisselquist Technology, LLC, I knew very little about
business.  I knew about technology.  I knew about signal processing.
I knew about the military acquisition process.  I knew a little
bit about digital logic.&lt;/p&gt;

&lt;p&gt;Why did I choose to start my own business?  Because of verses like,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ye are bought with a price; be not ye the servants of men.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/1co/7/23&quot;&gt;1Cor 7:23&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But just because a man goes into business doesn’t mean he’ll be successful
at it.  Perhaps I’m only “successful” because my goals are simple:  I only
wish to provide for myself and my family.&lt;/p&gt;

&lt;p&gt;On the other hand, God does make some promises here as well.  For example,
the very first Psalm talks about prospering at whatever you choose to do.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Blessed is the man that walketh not in the counsel of the ungodly, nor
standeth in the way of sinners, nor sitteth in the seat of the scornful.
But his delight is in the law of the Lord, and in his law doth he
meditate day and night.  And he shall be like a tree planted by the
rivers of water, that bringeth forth his fruit in his season; his leaf
also shall not wither; and whatsoever he doeth shall prosper.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/psa/1/1-3&quot;&gt;Ps 1:1-3&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;“Whatsoever he doeth shall prosper”, huh?  True?  Yes.&lt;/p&gt;

&lt;p&gt;Or how about the ending of the 23rd Psalm?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thou preparest a table before me in the presence of mine enemies: thou
annointest my head with oil; my cup runneth over.  Surely goodness and
mercy shall follow me all the days of my life: and I will dwell in the
house of the LORD forever.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/psa/23/5-6&quot;&gt;Ps 23:5-6&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;“My cup runneth over” sounds like a blessing that a man doesn’t have
room enough to receive.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mal/3/10&quot;&gt;Mal 3:10&lt;/a&gt;)  Today, I
feel like God’s blessing runs over from my cup onto those around me,
such as my family or those I work with.&lt;/p&gt;

&lt;p&gt;Well, does it?  Is this witness true?  Let me offer these evidences.
First, my oldest son graduated from college debt free, and now my
second child will be graduating from college this year, also debt
free.  My third child is still in college, and remains debt free.
This evidence, however, may be more due to their work than my own.
So let me offer a second piece of evidence and share that I’ve doubled
my gross receipts for the last two years, year over year.  This, mind
you, is in spite of a group of individuals that tried to cancel me
two years ago, and swore never to work with me.  It is also in spite
of all of the COVID shutdowns and subsequent chip shortages, which
in many ways I have been quite insulated from.  As my third evidence,
my wife and I were able to save up enough to purchase new vehicles
while on my business salary.  This year, it was a Honda Odyssey.
Finally, this year, I have someone joining me to help me out with
my tasks.&lt;/p&gt;

&lt;p&gt;If that’s not “success”, I’m not sure what is.&lt;/p&gt;

&lt;p&gt;So, again, I’m thankful this year for my success at Gisselquist
Technology, LLC.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This year, I am thankful for what God has done in my life and the
joy that I have to share.&lt;/p&gt;

&lt;p&gt;Let me encourage you to also join me in counting your blessings this year,
and in thanking the God of all blessings for what he has done in your own
life as well.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Rejoice in the Lord alway: and again I say, Rejoice!
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/phl/4/4&quot;&gt;Phil 4:4&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Bring ye all the tithes into the storehouse, that there may be meat in mine house, and prove me now herewith, saith the LORD of hosts, if I will not open you the windows of heaven, and pour you out a blessing, that there shall not be room enough to receive it. (Mal 3:10)&lt;/em&gt;</description>
        <pubDate>Thu, 24 Nov 2022 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/blog/2022/11/24/thanksgiving.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2022/11/24/thanksgiving.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Quiz #23: Can this assertion fail?</title>
        <description>&lt;!-- answer: &quot;2022/11/01/fv-answer22.html&quot; --&gt;

&lt;p&gt;At one time I thought that &lt;a href=&quot;/formal/2018/04/23/invariant.html&quot;&gt;swapping the assumptions regarding the inputs
of a design with the assertions over the outputs was a good
approach to handling
complexity&lt;/a&gt;.  Then
I came across this example.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Nov 2022 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/quiz/2022/11/24/quiz23.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2022/11/24/quiz23.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
      <item>
        <title>A first lesson in sales pitches: Honesty</title>
        <description>&lt;p&gt;I seem to be getting quite a few requests from those who would wish to help
me on this blog.  These tend to fall into a couple of categories:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Search Engine Optimization (SEO) offers&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web redesign&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Requests to submit an (irrelevant) article&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Requests for me to link to an article somewhere&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For all those to whom it may concern, therefore, let me offer the following
advice: 1) do your homework, and 2) &lt;em&gt;be honest!&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;zipcpu-funding&quot;&gt;ZipCPU Funding&lt;/h2&gt;

&lt;p&gt;First and foremost, few of these cold e-mailers bother to look through the web
site to see how it is funded.  If they did, they might notice that
&lt;a href=&quot;https://zipcpu.com&quot;&gt;zipcpu.com&lt;/a&gt; &lt;a href=&quot;/blog/2017/08/01/advertising.html&quot;&gt;doesn’t (currently)
advertise&lt;/a&gt;, it doesn’t
offer promotions, nor are there any links to click on to purchase ZipCPU
merchandise.&lt;/p&gt;

&lt;p&gt;The closest thing to blog funding is a &lt;a href=&quot;https://patreon.com/ZipCPU&quot;&gt;Patreon
link&lt;/a&gt; on the left of every page which people can
click on to provide a monthly contribution to encourage my work.  While I
appreciate everyone who contributes, and perhaps even more those who choose
to correspond and encourage, and while I am very thankful for all of those
who have chosen to &lt;a href=&quot;https://patreon.com/ZipCPU&quot;&gt;sponsor the ZipCPU blog on
Patreon&lt;/a&gt;, it doesn’t pay for my time.
Blog articles can take days, and sometimes weeks, to put together.&lt;/p&gt;

&lt;p&gt;That’s okay.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://zipcpu.com&quot;&gt;ZipCPU blog&lt;/a&gt; wasn’t written for that purpose.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://zipcpu.com&quot;&gt;ZipCPU blog&lt;/a&gt; was written (initially) to attract
businesses in my skills rather than to sell products.  To that end, it is
working quite well–especially since I don’t need to attract more than 1-3
businesses to keep my time occupied and my wallet filled.&lt;/p&gt;

&lt;p&gt;Beyond that, the &lt;a href=&quot;https://zipcpu.com&quot;&gt;ZipCPU blog&lt;/a&gt; is, in many ways, a
labor of love and fun.  I enjoy helping others, and I enjoy sharing my
own experiences.  Even better, the &lt;a href=&quot;https://zipcpu.com&quot;&gt;ZipCPU blog&lt;/a&gt;
offers me a chance to do a bit of &lt;a href=&quot;https://en.wikipedia.org/wiki/Rubber_duck_debugging&quot;&gt;rubber duck
debugging&lt;/a&gt;.  When I
write blog articles about designs I’ve written, those designs I blog about
tend to get cleaned up at the same time.&lt;/p&gt;

&lt;p&gt;The bottom line here is: there’s no money to fund hiring a web developer.
That’s not how this blog is funded.&lt;/p&gt;

&lt;p&gt;With this background, let’s look a bit deeper.&lt;/p&gt;

&lt;h2 id=&quot;seo-optimization&quot;&gt;SEO Optimization&lt;/h2&gt;

&lt;p&gt;Perhaps the biggest offer I get is from someone selling me search engine
optimization services.  These individuals offer to optimize the ZipCPU
web site so that search engines will find my content faster and easier.
Perhaps their biggest sales point is that they wish to make my content
the number one Google listing on (pick whatever topic).&lt;/p&gt;

&lt;p&gt;Those who’ve followed the blog for a while may have noticed that I tend to do
a yearly check up of my Google (and duck-duck-go) rankings.  You can find
blog summaries from &lt;a href=&quot;/blog/2018/01/01/top-ten.html&quot;&gt;2017&lt;/a&gt;,
&lt;a href=&quot;/blog/2019/01/01/top-ten.html&quot;&gt;2018&lt;/a&gt;,
&lt;a href=&quot;/blog/2020/01/01/2019-in-review.html&quot;&gt;2019&lt;/a&gt;,
&lt;a href=&quot;/blog/2022/01/03/2021-in-review&quot;&gt;2020 and 2021 here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My conclusion has been that, historically, I tend to do
rather well without any help.&lt;/p&gt;

&lt;p&gt;Could I do better?  Sure, I suppose: I could buy some Google key words and
guarantee my site comes up in the first page.  But why?  Would I make any more
money?  It’s not likely.  Again, that’s not how funding works for this blog.&lt;/p&gt;

&lt;p&gt;Look at it from the other perspective, however: a search engine that doesn’t
promote good content simply isn’t a very good search engine.  People just
won’t use it.  Therefore, as long as I can provide good and valuable content,
my web site will be found.  Providing valuable content is one of the tasks
I have enjoyed.&lt;/p&gt;

&lt;h2 id=&quot;web-redesign&quot;&gt;Web Redesign&lt;/h2&gt;

&lt;p&gt;The next common request I get is to from folks who would like to re-design my
web site.  This is something I would be more sympathetic to if my focus was
to make money from the blog.&lt;/p&gt;

&lt;p&gt;Let’s face it, the blog does need a good redesign.  The single landing page,
with everything linked off of it, can make it a challenge to find useful
information.  Worse, its mobile presence is broken to say the least: page
text tends to get cut off by the menu at the top of the page.  On the other
hand, links are valuable: I wouldn’t want to break anyone’s links in any
such redesign.&lt;/p&gt;

&lt;p&gt;But redesigning the web site to make it load faster?  A lot of the offers
I get promise faster loading.  In my mind, however, I don’t use a lot of
images on the landing page, so faster loading seems like a false promise.
Let’s get serious here: the main index for the blog uses less than 1kB
of data!  If someone offers me faster loading, therefore, it tells me that
they haven’t done their homework–they’re just copying vacuous claims
they’ve made regarding someone else’s web sites.&lt;/p&gt;

&lt;p&gt;This is not the way to build credibility in a sales pitch.&lt;/p&gt;

&lt;p&gt;The redesign that would be appropriate for the
&lt;a href=&quot;https://zipcpu.com&quot;&gt;ZipCPU web site&lt;/a&gt; isn’t going
to be something flashy.  It’s not about catching attention, it’s about finding
the information you need, and presenting it in an appropriate order.  No, I
don’t need more graphics to slow the page down, nor do I need to limit
each page to twenty carefully chosen links.&lt;/p&gt;

&lt;p&gt;The bottom line here, however, is that … there’s no money to fund hiring
someone to accomplish such a redesign.  Again, that’s not how this blog
works.  If or when it happens, I’ll probably be the one doing it.  That’s
also likely to keep it from happening for a while.&lt;/p&gt;

&lt;h2 id=&quot;submitting-articles&quot;&gt;Submitting Articles&lt;/h2&gt;

&lt;p&gt;I’ve also had several individuals offer to write articles for the
&lt;a href=&quot;https://zipcpu.com&quot;&gt;ZipCPU blog&lt;/a&gt;.  Admittedly, my first thought is: Awesome!
My next question is, on what topic?  And … that’s the rub.  The &lt;a href=&quot;https://zipcpu.com&quot;&gt;ZipCPU
blog&lt;/a&gt; is &lt;a href=&quot;/about/&quot;&gt;dedicated&lt;/a&gt; to the
topic of digital design, and to finding and fixing bugs in digital logic.&lt;/p&gt;

&lt;p&gt;If you want to write an article on FIFOs, therefore, it should contain a FIFO
implementation, a discussion of how the FIFO was verified, and why your design
is good, bad or indifferent.  This is in contrast to the person in the food
service industry who wanted me to post an article on how refrigerators need
to be organized in a first-in first-out fashion.&lt;/p&gt;

&lt;h2 id=&quot;submitting-links&quot;&gt;Submitting Links&lt;/h2&gt;

&lt;p&gt;No, I’m not opposed to linking to the articles of others either.  However, it
does need to fit the purpose of the blog: digital design and verification.&lt;/p&gt;

&lt;p&gt;For example, just because I mention the HDMI video standard doesn’t mean that
a link on HDMI cable standards is appropriate.  Sure, I get that you want to
sell HDMI cables, but that’s just not my topic.  An appropriate link might
instead point to where someone could find the HDMI standard, and details
someone might need to implement something following that standard.  To date,
Wikipedia has served this purpose well for me.  Wikipedia articles tend to
provide a nice overview of various topics I need that I can link to.&lt;/p&gt;

&lt;h2 id=&quot;cold-calling-do-your-homework&quot;&gt;Cold Calling: Do your homework&lt;/h2&gt;

&lt;p&gt;If you really want to cold-call, or rather cold e-mail me, then please do your
homework first.  My name is not “Owner”, nor is it “ZipCPU Team”.  There’s no
&lt;em&gt;team&lt;/em&gt; here, there is me.  I’m the only one here, and if you look around a
little you can find my name.&lt;/p&gt;

&lt;p&gt;As an example, I received an e-mail from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Richard Reynosa
&amp;lt;pelletgirl35@gmail.com&lt;/code&gt;.  Richard (or is it pelletgirl?) starts off his
(her?) letter with:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dear owner,&lt;/p&gt;

  &lt;p&gt;I recently spent some time doing a site review of Zipcpu.com (Yes, I do
random site reviews for a living.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;My first thought is that you didn’t do much of a site review at all.
If you had, 1) you would’ve found my name and appropriately addressed your
letter, and 2) you would’ve known that there’s no sales taking place on this
web site to support your business.&lt;/p&gt;

&lt;p&gt;If you are going to send me a cold e-mail, do your homework first.&lt;/p&gt;

&lt;p&gt;I make no promises that this will rescue you from my spam box.  I’ll only
promise that if you don’t your e-mail will simply get deleted from it without
getting a response.&lt;/p&gt;

&lt;h2 id=&quot;cold-calling-be-honest&quot;&gt;Cold Calling: Be Honest&lt;/h2&gt;

&lt;p&gt;The next thing I tend to notice about these e-mails is that the author’s
name and signature rarely matches the e-mail address name.  A case in
point might be Richard’s address above (or was it pelletgirl35’s?).  Which is
it?  It gets worse, too.  I get a lot of e-mail addresses that end up looking
like user234156@gmail.com.&lt;/p&gt;

&lt;p&gt;This is usually the first flag that the source isn’t legitimate: they aren’t
selling their product next to their name.  Chances are they’ve been hiding from
some Google spam detection filter, and so need to keep changing their name
to avoid being sent to my spam folder–where these e-mails tend to end up
anyway.&lt;/p&gt;

&lt;p&gt;At one time, I started getting a lot of emails from individuals
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@candycloudtech.com&lt;/code&gt;.  Some time later I started getting the same sort of
e-mails from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@webmarketingassist.com&lt;/code&gt;.  These were a bit better–at least
the e-mail user name tended to match the signature at the bottom, but it
doesn’t help that candycloudtech.com doesn’t have a web presence, nor am
I getting a request from a single individual at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@candycloudtech.com&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here’s the other thing about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;candycloudtech.com&lt;/code&gt;: Without a web presence
of their own, how are they going to convince me that they can improve my
web presence?  Seriously.  If you want to sell your web design ability,
demonstrate it for me, then advertise your services where I can evaluate your
website as your &lt;em&gt;portfolio&lt;/em&gt;.  Convince me your website is valuable, and
contains something I might wish to emulate, and then I might consider buying
your services.&lt;/p&gt;

&lt;p&gt;In this case, I’m not buying it.  Even if I was looking for someone to do
web redesign, I’m not buying from someone who isn’t going to show off their
own work.&lt;/p&gt;

&lt;p&gt;If you really want to cold-call, or rather cold-e-mail me, then get your
story straight and tell it honestly or I’m not interested.&lt;/p&gt;

&lt;p&gt;Chances are I’m not interested anyway, but I’ll continue.&lt;/p&gt;

&lt;h2 id=&quot;reviewing-sales-pitches&quot;&gt;Reviewing sales pitches&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;We are a professional web design company.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But you won’t tell me what the name of that company is, and you are sending
to me from an e-mail @gmail.com?  Not interested.  (Yes, I know that I’m using
an @gmail address, but I’m not cold e-mailing individuals …)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I work for a leading website design and development company …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then why won’t you tell me what it is?  @gmail.com doesn’t tell me much.
Do you have an on-line portfolio you’d like to share that I can examine?  No?
Not interested.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I built Android iOS software.  I have reviewed your requirements and …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Don’t lie to me.  I haven’t posted any requirements for mobile software.
If I needed to hire someone, my first priority would be to hire an honest
individual.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;From anna@smartwebexpert.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is at least a good start!  So, let’s look up smartwebexpert.com and see
what their web page looks like.  When I received this e-mail, the first page
looked like it might be interesting, but every second level page I looked at
was empty.  There were links there, but they didn’t contain any information.
That was then.  Today, smartwebexpert.com seems to be a non-existent domain.&lt;/p&gt;

&lt;p&gt;And … Anna wanted to redesign my web page given her broken examples?
Not interested.&lt;/p&gt;

&lt;p&gt;Also, Anna?  I got the same pitch from Sarah, word for word in one paragraph.
Somehow I think one of you is misrepresenting who you are.&lt;/p&gt;

&lt;p&gt;Honesty is required in a sales pitch, or I’m just going to close the door.
I’m not interested in any dishonest advertising.&lt;/p&gt;

&lt;h2 id=&quot;advertising&quot;&gt;Advertising&lt;/h2&gt;

&lt;p&gt;I’ve stated before that &lt;a href=&quot;/blog/2017/08/01/advertising.html&quot;&gt;I’m not opposed to advertising the products of
others&lt;/a&gt;
on this blog.  However, I am going to be particular about what gets advertised
here if I ever go there.&lt;/p&gt;

&lt;p&gt;For example, I would have no problems advertising FPGA jobs, professional
digital designers, FPGAs, FPGA boards, or even providing paid links to places
where you might purchase such a board or even where you might purchase IP
from any particular vendor.  However, if this sort of thing started limiting
my ability to speak about my experiences with your products (assuming I was
using them)–say with Xilinx’s (broken) training materials, then I’m not
interested.&lt;/p&gt;

&lt;p&gt;If you want me to promote your wonderful product, then I want to know and
be convinced that it is truly a wonderful product.  For example, as an unpaid
and unsolicited promotion: I’ve always liked &lt;a href=&quot;https://store.digilentinc.com&quot;&gt;Digilent’s
products&lt;/a&gt;.  They tend to be reliable,
have a good support forum, and they also tend to be very well documented.
Bottom line: Digilent FPGA products have been, in my experience, a joy to work
with.&lt;/p&gt;

&lt;p&gt;As for &lt;a href=&quot;https://www.terasic.com.tw/en&quot;&gt;Terasic&lt;/a&gt;?  That’s another story.
Did I tell you the pain I went through to try to find the correct schematic
for my DE-10 Nano?  Or how about the rework I had to do after building my
design against a DE0-Nano schematic that was marked as a DE-10 Nano schematic?&lt;/p&gt;

&lt;p&gt;I would, however, have a problem advertising immoral conduct.  This is one of
the reasons why the ZipCPU blog once had a relationship with disqus and why it
doesn’t use any of their material anymore.&lt;/p&gt;

&lt;p&gt;Bottom line here: I intend to approve or disapprove advertisements on a case
by case basis.  Still interested?  Then contact me.&lt;/p&gt;

&lt;h2 id=&quot;bottom-line-honesty&quot;&gt;Bottom line: Honesty&lt;/h2&gt;

&lt;p&gt;I guess my bottom line is that I would never be interested in hiring or
working with anyone who isn’t honest.  I could deal with a certain amount
of incompetence.  That’s normal.  Dishonesty?  No.  Sorry.  My recommendation,
therefore, for all those interested in sending me sales pitches?&lt;/p&gt;

&lt;p&gt;Be honest!&lt;/p&gt;

&lt;p&gt;Also know, honesty alone won’t get you hired.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;And if ye salute your brethren only, what do ye more than others?  Do not even the publicans so?  (Matt 5:47)&lt;/em&gt;</description>
        <pubDate>Sat, 12 Nov 2022 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/blog/2022/11/12/honesty.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2022/11/12/honesty.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Quiz #22: Handling cover failures</title>
        <description>&lt;p&gt;A failed formal cover check can be one of the most challenging things to debug.
All you know is that the formal tool failed to be able to make the covered
expression true.  You have no trace to work with to show you how close
you managed to get to making the expression true before ultimately failing.&lt;/p&gt;

&lt;p&gt;Where would you even start to debug something like this?&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Nov 2022 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/quiz/2022/11/01/quiz22.html</link>
        <guid isPermaLink="true">https://zipcpu.com/quiz/2022/11/01/quiz22.html</guid>
        
        
        <category>quiz</category>
        
      </item>
    
  </channel>
</rss>
