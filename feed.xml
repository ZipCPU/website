<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The ZipCPU by Gisselquist Technology</title>
    <description>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</description>
    <link>https://zipcpu.com/</link>
    <atom:link href="https://zipcpu.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 20 Jan 2024 20:20:26 -0500</pubDate>
    <lastBuildDate>Sat, 20 Jan 2024 20:20:26 -0500</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    <image>
      <url>https://zipcpu.com/img/gt-rss.png</url>
      <title></title>
      <link></link>
    </image>
    
      <item>
        <title>2023, Year in review</title>
        <description>&lt;p&gt;It should come as no surprise that a blog with &lt;a href=&quot;https://zipcpu.com/blog/2017/08/01/advertising.html&quot;&gt;no
advertisements&lt;/a&gt; has never
paid my bills–at least not directly.  I blog for fun, and to some extent for
&lt;a href=&quot;https://en.wikipedia.org/wiki/Rubber_duck_debugging&quot;&gt;rubber duck debugging&lt;/a&gt;.
As I learn new concepts, I enjoy sharing them here.  Going through the rigor
to write about a topic also helps to make sure I understand the topic as well.&lt;/p&gt;

&lt;p&gt;Why are there &lt;a href=&quot;https://zipcpu.com/blog/2017/08/01/advertising.html&quot;&gt;no
advertisements&lt;/a&gt;?  For
two reasons.  First, because I’m not doing this to make money.  Second, because
because I want more control over any advertising from this site than
most advertisers want to provide.  Perhaps some day the site will be supported
by advertising.  Until then, the web site works fine without advertisements.&lt;/p&gt;

&lt;p&gt;So how then does the blog fit into my business model?  Simply because the blog
helps me find customers via those who read articles here and write to me.&lt;/p&gt;

&lt;h2 id=&quot;business-projects&quot;&gt;Business Projects&lt;/h2&gt;

&lt;p&gt;So, if the blog doesn’t pay my bills, then what does?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;2023 Projects&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/2023-review/2023-funding.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Well, six projects have paid the bills this year.  Three of these have been
ASIC projects, to include the &lt;a href=&quot;https://www.arasan.com/product/xspi-psram-master/&quot;&gt;PSRAM/NOR flash
controller&lt;/a&gt;, and an &lt;a href=&quot;https://www.arasan.com/product/onfi-4-2-controller-phy/&quot;&gt;ONFI
NAND flash controller&lt;/a&gt;.
Three other projects this year have been FPGA projects, to include an &lt;a href=&quot;/blog/2023/11/25/eth10g.html&quot;&gt;open
source 10Gb Ethernet switch&lt;/a&gt;
and a SONAR front end based upon my
&lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;VideoZip&lt;/a&gt; design–after including several
very significant upgrades, such as handling ARP and ICMP requests in hardware.
That’s four of the six projects from this year.  Once the other two projects
become a bit more marketable, I may mention them here as well.&lt;/p&gt;

&lt;p&gt;Since I’ve already discussed the &lt;a href=&quot;/blog/2023/11/25/eth10g.html&quot;&gt;10Gb Ethernet
design&lt;/a&gt;, let me take a moment
and discuss the &lt;strong&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C controller&lt;/a&gt;&lt;/strong&gt; within it.
The &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C controller&lt;/a&gt; was originally designed
to support the SONAR project.  Perhaps you may remember the &lt;a href=&quot;/blog/2021/11/15/ultimate-i2c.html&quot;&gt;initial article,
outlining the design goals for this
controller&lt;/a&gt;.  Thankfully,
it’s met all of these goals and more–but we’ll get to that in a moment.  As
part of the SONAR project, its purpose was to sample various non-acoustic
telemetry data: temperature, power supply voltage, current usage, humidity
within the enclosure, and more.  All of these needed to be sampled at regular
intervals.  At first glance, &lt;a href=&quot;https://www.reddit.com/r/FPGA/comments/13ti5zx/when_do_you_solve_a_problem_in_software_instead/&quot;&gt;this sounds like a software
task&lt;/a&gt;–that
is until you start adding real-time requirements to it such as the need to
shut down the SONAR transmitter if it starts overheating, or using so much
power that the FPGA itself will brown out shortly.  So, the
&lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;I2C controller&lt;/a&gt; was designed to generate
(AXI stream) data packets automatically, without CPU intervention, which could
then be forwarded … somewhere.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;An example I2C-driven OLED output&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/2023-review/ssdlogo-demo.jpg&quot; width=&quot;260&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;This design&lt;/a&gt; was then incorporated into the
&lt;a href=&quot;/blog/2023/11/25/eth10g.html&quot;&gt;10Gb Ethernet design&lt;/a&gt;.  There
it provided the team the ability to 1) read the DDR3 memory stick
configuration–useful for making sure the &lt;a href=&quot;https://github.com/AngeloJacobo/DDR3_Controller&quot;&gt;DDR3
controller&lt;/a&gt; was properly
configured, 2) read the SFP+ configuration–and discover that we were using
1GbE SFP+ connectors initially instead of 10GbE connectors (Oops!), 3) read the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Display_Identification_Data&quot;&gt;Extended Display Identification Data
(EDID)&lt;/a&gt;
from the downstream &lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI&lt;/a&gt;
monitor, 4) configure and verify the &lt;a href=&quot;https://www.skyworksinc.com/-/media/Skyworks/SL/documents/public/data-sheets/Si5324.pdf&quot;&gt;Si5324&lt;/a&gt;’s register
settings, 5) draw a logo onto a
&lt;a href=&quot;https://www.amazon.com/Teyleten-Robot-Display-SSD1306-Raspberry/dp/B08ZY4YBHL/&quot;&gt;small OLED display&lt;/a&gt;,
all in addition to 6) actively monitoring hardware temperature.&lt;/p&gt;

&lt;p&gt;Supporting these additional tasks required two fundamental changes to the
&lt;a href=&quot;/blog/2021/11/15/ultimate-i2c.html&quot;&gt;initial vision for this I2C
controller&lt;/a&gt;.  First, I
needed an &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/wbi2c/wbi2cdma.v&quot;&gt;I2C
DMA&lt;/a&gt;, to
quietly transfer results read from the device to memory.  Only once I had
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/wbi2c/wbi2cdma.v&quot;&gt;this DMA&lt;/a&gt;
could the CPU then inspect and/or report on the results.  (It was probably one
of the easiest DMA’s I’ve written, since &lt;a href=&quot;/blog/2021/11/15/ultimate-i2c.html&quot;&gt;I2C is a rather slow
protocol&lt;/a&gt;.)
Second, each packet needed a designated &lt;em&gt;destination&lt;/em&gt; channel, so the design
could know where to forward the results.  This was useful for knowing if the
I2C information should be forwarded to &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/wbi2c/wbi2cdma.v&quot;&gt;the
DMA&lt;/a&gt;, for
storing in memory, or the &lt;a href=&quot;https://en.wikipedia.org/wiki/HDMI&quot;&gt;HDMI&lt;/a&gt;
slave controller, for forwarding the downstream monitor’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Display_Identification_Data&quot;&gt;EDID&lt;/a&gt;
to the upstream monitor.  The fact that &lt;a href=&quot;https://github.com/ZipCPU/wbi2c&quot;&gt;this
controller&lt;/a&gt;, designed for completely separate
project, in a completely different domain (i.e. SONAR), ended up working so
well in an &lt;a href=&quot;/blog/2023/11/25/eth10g.html&quot;&gt;10Gb Ethernet
design&lt;/a&gt; project
is a basic testament to a well designed interface.&lt;/p&gt;

&lt;p&gt;The year has also included some internally funded projects.  These include
a new &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO/eMMC controller&lt;/a&gt;, a (to-be-posted)
upgrade to &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;my standard debugging
bus&lt;/a&gt;, and a
&lt;a href=&quot;/zipcpu/2023/05/29/zipcpu-3p0.html&quot;&gt;ZipCPU upgrade&lt;/a&gt;.  Allow
me to take a moment to discuss these three (unfunded) projects in a bit more
detail.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO/eMMC controller&lt;/a&gt;&lt;/strong&gt; is new.  By
using all four data lanes and a higher clock rate, this upgrade offers a
minimum 8x transfer rate performance improvement over my prior SPI-only
version.  That’s kind of exciting.  Even better, the IP has been tested on
both an SD card as well as an &lt;a href=&quot;http://www.skyhighmemory.com/download/eMMC_4GB_SML_PKG_S40FC004_002_01112.pdf&quot;&gt;eMMC
chip&lt;/a&gt;
as part of the &lt;a href=&quot;/blog/2023/11/25/eth10g.html&quot;&gt;KlusterLab (i.e. 10Gb Ethernet
board)&lt;/a&gt; design.  The IP, &lt;a href=&quot;https://github.com/ZipCPU/sdspi/tree/master/sw&quot;&gt;plus
software&lt;/a&gt;, is so awesome I’m
likely to add it to any future designs I have with SD cards or eMMC chips in
the future.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;The difference between SPI and SDIO: Speed&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/2023-review/sdiovspi.svg&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That’s just the beginning, too.  Just because &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;this new SDIO
controller&lt;/a&gt; works on hardware, doesn’t mean
it works in all modes.  Since its original posting, I’ve added verification to
support all the modes our hardware doesn’t (yet) support.  I’ve also started
adding eMMC BOOT mode support, and I expect I’ll be (eventually) adding DMA
support to this IP as well.  My goal is also to make sure I can support
multiple sector read or write commands–something the SPI only version couldn’t
support, and something that’s supposed to be supported in this new version but
isn’t tested (yet).  (Remember, &lt;a href=&quot;/zipcpu/2022/07/04/zipsim.html&quot;&gt;if it’s not tested it doesn’t
work&lt;/a&gt;.)  In other
words, despite declaring this IP as “working”, it remains under very active
development.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;I will use Slave/Master Terms where appropriate&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/2023-review/slave.svg&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;!-- (COMSONICS, SoundWire) --&gt;

&lt;p&gt;Then there’s the upgrade to the &lt;strong&gt;&lt;a href=&quot;https://github.com/ZipCPU/dbgbus&quot;&gt;debuging
bus&lt;/a&gt;&lt;/strong&gt;.  This has been in the works now for
quite a while.  My current/best debugging bus implementation
uses six printable characters to transmit a control code (read request, write
data, or new address) plus 32-bits of data.  At six data bits per 8-bit
character transmitted, this meant six characters would need to be sent
(minimum) in order to send either a 32-bit address or 32-bit data word,
leading to a 36b internal word.  It also required &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10*6&lt;/code&gt; baud periods (10 baud
periods times six characters) for every uncompressed 32b of data transferred,
for a best case efficiency of 53%.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;The debugging bus multiplexes console and bus channels&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/2023-review/dbgbus.svg&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Since then, I’ve slowly been working on an upgrade to this protocol that will
use five (not necessarily printable) characters to transmit 32-bits of data
plus a control code.  This upgrade should achieve an overall 64% worst case
(i.e.  uncompressed) efficiency, for a speed improvement of about 16% over the
prior controller in worst case conditions.  The upgrade comes with some
synchronization challenges, but currently passes all of its simulation
checks–so at this point it’s ready for hardware testing.  My only problem
is … this upgrade isn’t paid for.  Inserting it into one of my business
projects is likely to increase the cost of that project–both in terms of
integration time as well as verification while chasing down any new bugs
introduced by this new implementation–at least until the upgraded bus is
verified.  This has kept this debugging bus upgrade at a lower priority to the
other paying projects.  Well, that and the fact that I only expect a 16%
improvement over the prior implementation.  As a result, the upgrade isn’t
likely to pay for itself for a long time.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Moving from 6 characters to 5 characters to send 32bits&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/2023-review/exbus.svg&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Finally, let’s discuss the &lt;a href=&quot;/zipcpu/2023/05/29/zipcpu-3p0.html&quot;&gt;ZipCPU’s big
upgrades&lt;/a&gt;.  As with the
other upgrades, these were also internally funded.  However, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has now formed a backdrop to a
majority of my projects.  Indeed, it’s &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;helped me verify ASIC IP in both
simulation&lt;/a&gt; and FPGA
contexts.  One upgrade in particular will keep on giving, and that is the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/master/rtl/zipdma&quot;&gt;new DMA
controller&lt;/a&gt;.  I’ve
already managed to integrate it into a &lt;a href=&quot;https://github.com/ZipCPU/wbsata&quot;&gt;(work in progress) SATA
controller&lt;/a&gt;, and I’m likely to retarget this
DMA engine (plus a small state machine) to meet the DMA needs of my new
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO/eMMC controller&lt;/a&gt;.  Indeed, it is so
versatile that I’m likely to use this controller across a lot of projects.
Better yet, at this rate, I’m likely to build an AXI version of this new DMA
supporting all of these features as well.  It’s just that good.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;All labour is profitable, whether or not it's paid for&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tweets/bible/all-labour.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;As for dollars?  Well, let’s put it this way: the year is now over, and I’m
still in business.  Not only that, but I’ve also managed to keep two kids in
college this year.  More specifically, I expect my third child to graduate
from college this year.  (Five to go …)  So, I’ve been hanging in there,
and I thank my God that my bills have been paid.&lt;/p&gt;

&lt;h2 id=&quot;articles&quot;&gt;Articles&lt;/h2&gt;

&lt;p&gt;2023 has been a slower year for articles than past years.  Much of this is due
to the fact that my time has been so well spent on other paying projects.
That’s left less time for blogging.  (No, it doesn’t help that my family
has fallen in love with Football, and that my major blogging times have been
spent watching my son’s high school games, Air Force Academy Falcon’s football,
the Kansas City Chiefs, Miami Dolphins, Philadelphia Eagles, and my own home
team–the disappointing Minnesota Vikings.) Still, I have managed to push out
seven new articles this year.  Let’s look at each, and see how easy they can
be found using DuckDuckGo.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/2023-review/vikings.svg&quot; width=&quot;320&quot; alt=&quot;What does a Vikings fan do after watching the Vikings win the super bowl?  He turns off the play-station 4.&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2023/02/13/eccdbg.html&quot;&gt;Debugging the hard stuff&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This article discusses some of the challenges I went through when debugging
modifications I made to a working ECC algorithm.  ECC, of course, is one of
those “hard” problems to debug since the intermediate data tends to look
meaningless when viewed.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;DuckDuckGo Ranking:&lt;/strong&gt; A search for “FPGA ECC Debugging” brings up the
&lt;a href=&quot;&quot;&gt;ZipCPU home page&lt;/a&gt; as return #111.&lt;/p&gt;

    &lt;p&gt;That’s kind of disappointing.  Let’s try a search using Google.  Google
finds &lt;a href=&quot;/blog/2023/02/13/eccdbg.html&quot;&gt;the correct page&lt;/a&gt;
immediately as its #1 result.  At first I thought the difference was because
Google knew I was interested in &lt;a href=&quot;&quot;&gt;ZipCPU&lt;/a&gt; results.  Then
I asked my daughter to repeat my test on her phone in private mode.  (She
has no interest in FPGA anything, so this would be a first for her.)  Her
Google ranking came up identical, so maybe I can trust this Google ranking.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2023/03/13/swic.html&quot;&gt;What is a SwiC&lt;/a&gt;?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/barecpu.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was originally designed
  to be a System within a Chip, or a SwiC as I called it.  This article
  discusses what a SwiC is, and tries to answer the question of whether or not
  a SwiC makes sense, or equivalently whether or not the
  &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; made for a good SwiC in the
  first place.  In many ways, this article was a review of whether or not the
  &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
  design goals were appropriate, and whether or not they’ve been met.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DuckDuckGo Ranking:&lt;/strong&gt; Searches on SwiC return all kinds of
  irrelevant results, and searches on “System within a Chip” return all kinds
  of results for “Systems on a Chip”.  If you cheat and search for “ZipCPU
  SwiC”, you get the &lt;a href=&quot;&quot;&gt;ZipCPU&lt;/a&gt; web site as the #1 page.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;What is a Virtual Packet FIFO&lt;/a&gt;?&lt;/p&gt;

    &lt;p&gt;A virtual FIFO is a first-in, first-out data structure built in hardware, but
using &lt;em&gt;external&lt;/em&gt; memory–such as a DDR3 SDRAM–for its memory.  A virtual
packet FIFO is a virtual FIFO that guarantees completed packets and packet
boundaries, in spite of any back pressure that might otherwise cause the FIFO
to fill or overflow.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/pktvfifo.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;This article&lt;/a&gt;
  goes over the why’s and how’s of a virtual packet FIFO: why you
  might need it, how to use it, and how it works.&lt;/p&gt;

&lt;p&gt;Since writing this article, I’ve now built and tested a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;Wishbone based
  virtual packet FIFO as part of the 10Gb Ethernet
  project&lt;/a&gt;.
  Conclusion?  First, verifying the FIFO is a pain.  Second, I might be able to
  tune its memory usage with some better buffering.  But, overall, the FIFO
  itself works quite nicely in all kinds of environments.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DuckDuckGo ranking:&lt;/strong&gt;  The &lt;a href=&quot;&quot;&gt;ZipCPU blog&lt;/a&gt; comes up as
  the #2 ranking on DuckDuckGo following a search for “Virtual Packet FIFO”.
  The &lt;a href=&quot;https://www.reddit.com/r/ZipCPU&quot;&gt;ZipCPU reddit page&lt;/a&gt; comes up as the #7
  ranking.  The page itself?  Not listed.  However, both of the prior pages
  point to this article, so I’m going to give this a DuckDuckGo ranking of #2.
  Sadly, most of DuckDuckGo’s other results are completely irrelevant to a
  Virtual Packet FIFO.  In general, they’re about Virtual FIFOs–not
  Virtual &lt;em&gt;Packet&lt;/em&gt; FIFOs.  As before, though, Google gets the right article
  as it’s number one search result.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/zipcpu/2023/05/29/zipcpu-3p0.html&quot;&gt;Introducing the ZipCPU 3.0&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;After years of updates, &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; 3.0 is
here!  This means that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
now has support for multiple bus structures, wide bus widths, clock stopping,
and a brand new DMA.  &lt;a href=&quot;/zipcpu/2023/05/29/zipcpu-3p0.html&quot;&gt;The
article&lt;/a&gt; announces this
new release, and discusses the importance of each of these major upgrades.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;DuckDuckGo Ranking:&lt;/strong&gt; A search for “ZipCPU” on DuckDuckGo yields
&lt;a href=&quot;&quot;&gt;ZipCPU.com&lt;/a&gt; as the #1 search result.  That’s good
enough for me.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2023/06/28/sdiopkt.html&quot;&gt;Using a Verilog task to simulate a packet generator for an SDIO
controller&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;I haven’t written a lot about either Verilog test benches, or how to build
them, so this is a bit of a new topic for me.  Specifically, the question
involved was how to make your test bench generate properly synchronous
stimuli.  No, the correct answer is &lt;em&gt;NOT&lt;/em&gt; to generate your stimulus on the
negative edge of the clock.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;DuckDuckGo Ranking:&lt;/strong&gt; A search for “SDIO Verilog Tasks” on DuckDuckGo
yields the &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO repository&lt;/a&gt; as the #31
search result.  (Google returns the correct article, after searching for
“SDIO Verilog” at #3.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/formal/2023/07/18/sdrxframe.html&quot;&gt;SDIO RX: Bugs found with formal methods&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;If you’ve read my blog often enough, you’ll know that I’m known for formally
verifying my designs.  In the case of the new &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO/eMMC
controller&lt;/a&gt;, I had it “working” on hardware
before either the formal verification or the full simulation model were
complete.  This leaves open the question, how many bugs were missed by my
hardware and (partial) simulation testing?&lt;/p&gt;

    &lt;p&gt;The article spends a lot of time also discussing “why” proper verification,
whether formal or simulation, is so important.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;DuckDuckGo Ranking:&lt;/strong&gt; A search for “SDIO formal verification” turns up the
&lt;a href=&quot;&quot;&gt;ZipCPU blog&lt;/a&gt; as result #69.  Adding “verilog” to the
search terms, returns the blog as number #46.  As before, Google returns
the right article as the #1 search result after only searching for “SDIO
formal”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2023/11/25/eth10g.html&quot;&gt;An Overview of a 10Gb Ethernet Switch&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;As I mentioned above, one of the big projects of mine this year was a &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb
Ethernet switch&lt;/a&gt;.  This article goes over
the basics of the switch, and how the various data paths within the design
move data around.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;DuckDuckGo Ranking:&lt;/strong&gt; A search for “10Gb Ethernet Switch FPGA” turns up
the &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;Ethernet design&lt;/a&gt; as the #16 result,
and a search on “10Gb Ethernet Switch Verilog” returns the same github result
as the #1 result.  Curiously, the &lt;a href=&quot;https://github.com/ZipCPU/blob/master/bench/rtl/tbenet.v&quot;&gt;10Gb Ethernet test bench
model&lt;/a&gt; for the same
repository comes up as the #2 result.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For all those who like to spam my email account, my conclusions from these
numbers are simple: 1) the &lt;a href=&quot;&quot;&gt;ZipCPU blog&lt;/a&gt; holds its own just
fine on a Google ranking, and 2) DuckDuckGo’s search engine needs work.  &lt;a href=&quot;/blog/2022/11/12/honesty.html&quot;&gt;If
you want to sell me web-based services and don’t know
this&lt;/a&gt;, I’ll assume you haven’t
done your homework and leave your email in my spam box.&lt;/p&gt;

&lt;h2 id=&quot;upcoming-projects&quot;&gt;Upcoming Projects&lt;/h2&gt;

&lt;p&gt;So, what’s next for 2024?  Here are some of the things I know of.  Some of
these are paid for, others still need funding.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float:none&quot;&gt;&lt;caption&gt;2024 Projects&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/2023-review/2024-funding.svg&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Still, this is a good list to start from:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;One of my ASIC projects is in the middle of a massive speed upgrade.  This is
not a clock upgrade, or a fastest supported frequency upgrade, but rather an
upgrade to adjust the internal state machine.  I’m anticipating an additional
speed up of between 8x and 256x as a result of this upgrade.&lt;/p&gt;

    &lt;p&gt;Status?  &lt;strong&gt;Funded.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;My brand new &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO/eMMC controller&lt;/a&gt;
has neither eMMC boot support, nor DMA support.  Boot support might allow me
to boot the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; directly from
an eMMC card, whereas DMA support would allow the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to read lots of data from the card without CPU interaction.
Both may be on the near-term horizon, although neither upgrade is funded.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Laptop projects have additional requirements&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/2023-review/laptop.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Status?  Not funded.  On the other hand, this project fits quite nicely on
  my laptop for those days when I have the opportunity to take my son to his
  basketball practice … (He’s a 6’4” high school freshman, who is new to
  the sport as of this year …)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/AutoFPGA&quot;&gt;AutoFPGA&lt;/a&gt; is now, and has for some time,
been a backbone of any of my designs.  I use it for everything.  It makes
adding and removing IP components easy.  One of its key capabilities is
&lt;a href=&quot;/zipcpu/2019/09/03/address-assignment.html&quot;&gt;address assignment (and adjustment)&lt;/a&gt;.
Sadly, it’s worked so well that it now needs some maintenance.  Specifically,
I’d like to upgrade it so that it can handle partially fixed addressing, such
as when some addresses are given and fixed while others are allowed to change
from one design to the next.  This is only a precursor, though, to supporting
2GB memories where the memory address range overlaps one of the ZipSystem’s
fixed address ranges.&lt;/p&gt;

    &lt;p&gt;Status?  A &lt;strong&gt;funded&lt;/strong&gt; (SONAR) project requires these upgrades.  Unlike my
current SONAR project, built around &lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;Digilent’s Nexys Video
board&lt;/a&gt;,
this one will be built around &lt;a href=&quot;https://www.enclustra.com/en/products/fpga-modules/mercury-kx2/&quot;&gt;Enclustra’s Mercury
KX2&lt;/a&gt;, and
so either &lt;a href=&quot;https://github.com/ZipCPU/AutoFPGA&quot;&gt;AutoFPGA&lt;/a&gt; gets upgraded or
I can’t use the full memory range.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s GCC backend urgently
needs a fix.  Specifically, it has a problem with &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail (sibling)
calls&lt;/a&gt; that jump to register
addresses.  This problem was revealed when testing the &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO/eMMC software
drivers&lt;/a&gt;, and needs a proper fix before I
can make any more progress on upgrading the
&lt;a href=&quot;https://zipcpu.com/zipcpu/2021/03/18/zipos.html&quot;&gt;ZipOS&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Did I mention working on the
&lt;a href=&quot;https://zipcpu.com/zipcpu/2021/03/18/zipos.html&quot;&gt;ZipOS&lt;/a&gt;?  Indeed.
realistically, further work on the &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO/eMMC
software&lt;/a&gt; really wants a proper OS of some
type, so … this may be a future and upcoming task.&lt;/p&gt;

    &lt;p&gt;Status?  This project isn’t likely to get any funding, but other projects
are likely to require this fix.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As another potential project, an old friend is looking into building a
“see-in-the-dark” capability–kind of like a “better” version of
night-vision goggles.  He’s currently arranging for funding, and after all of
my video work I might finally find a customer for it.  Yes, his work will
require some secret sauce processing–but it’s all quite doable, and could
easily fit nicely into this years upcoming work.&lt;/p&gt;

    &lt;p&gt;Status?  If this moves forward, it will be &lt;strong&gt;funded&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I’d also like to continue my work on a &lt;a href=&quot;https://github.com/ZipCPU/wbsata&quot;&gt;Wishbone controlled SATA
controller&lt;/a&gt; this year.  I started working
on this controller under the assumption that it would be required by my
SONAR project, and so funded.  Now it no longer looks like it will be funded
under this vehicle.  Still, the controller is now written, even though the
verification work is far from complete.  Specifically, I’ll need to work on
my &lt;a href=&quot;https://github.com/ZipCPU/wbsata&quot;&gt;SATA (Verilog) Verification IP&lt;/a&gt;, until
it’s sufficient enough to get me past knowing if I have the Xilinx GTX
transceivers modeled correctly or not.  Once I get that far, I can both
start testing against actual hardware (on my desk), as well as against
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
models.&lt;/p&gt;

    &lt;p&gt;Status?  Funding has been applied for.  Sadly, it’s not likely to be enough
to pay for my hours, but perhaps I can have a junior engineer work on this.
Still, whether or not the funding comes through remains to be determined.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Did I mention that the new debugging bus upgrades are on my list to be
tested?  Who knows, I may test their AXI counterparts first, or I may test
the UDP version first, or …  Only the Good Lord knows how this task will
move forward.&lt;/p&gt;

    &lt;p&gt;Status?  Not funded at all.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I am looking into getting some funding for a second version of an Ethernet
based Memory controller.  The SONAR project required a &lt;a href=&quot;https://zipcpu.com/blog/2022/08/24/protocol-design.html&quot;&gt;first version of this
controller&lt;/a&gt;,
and it smokes &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;my serial port based debugging
controller&lt;/a&gt;.  A
second version of this controller, designed for resource constrained FPGAs,
designed for speed, designed for throughput from the ground up … could
easily become a highly desired product.&lt;/p&gt;

    &lt;p&gt;We’ll see.&lt;/p&gt;

    &lt;p&gt;Status?  Sounds fun, but not (yet) funded.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, I have an outstanding task to test an open source memory controller,
using an open source synthesis, and place and route tool, for both Artix-7
and Kintex-7 devices.  I’ll let you know how that works out.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since these are business predictions about the future, I am required by the
Good Lord to add that these are subject to whether or not I live and the
Lord wills.  (See &lt;a href=&quot;https://www.blueletterbible.org/kjv/jam/4/13-15&quot;&gt;James
4:13-15&lt;/a&gt; for an explanation.)&lt;/p&gt;

&lt;p&gt;As always, let me know if you are interested in any of these projects, and
especially let me know if you are interested in funding one or more of them.
Either way, the upcoming year looks like it will be quite busy and it’s only
January.&lt;/p&gt;

&lt;p&gt;“My cup runneth over (&lt;a href=&quot;https://blueletterbible.org/kjv/psa/23/5&quot;&gt;Ps 23:5&lt;/a&gt;)”, and
so I shall also pray that God grants you the many blessings He has given me.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Let every thing that hath breath praise the LORD.  Praise ye the LORD. (Ps 150:6)&lt;/em&gt;</description>
        <pubDate>Sat, 20 Jan 2024 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/blog/2024/01/20/2023-in-review.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2024/01/20/2023-in-review.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>An Overview of a 10Gb Ethernet Switch</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The KlusterLab board used for the 10Gb Ethernet Switch testing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/klusterlab_1.0.jpeg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I’ve now been working with &lt;a href=&quot;https://www.symbioticeda.com/&quot;&gt;Symbiotic EDA&lt;/a&gt;
and &lt;a href=&quot;https://www.pcb-arts.com&quot;&gt;PCB Arts&lt;/a&gt; on a &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb Ethernet switch
project&lt;/a&gt; for
&lt;a href=&quot;https://www.netidee.at/fastopenswitch&quot;&gt;NetIdee&lt;/a&gt; for some time.  Indeed,
I’ve discussed &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;this project&lt;/a&gt; several times
on the blog.  I first brought it up in the context of building a &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;Virtual Packet
FIFO&lt;/a&gt;.  The topic then came
up again during two articles on building an &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO (SD-Card)
controller&lt;/a&gt;: first when &lt;a href=&quot;/blog/2023/06/28/sdiopkt.html&quot;&gt;discussing how to
build a Verilog test bench for
it&lt;/a&gt;, and then again when
&lt;a href=&quot;/formal/2023/07/18/sdrxframe.html&quot;&gt;discussing what bugs managed to slip past the verification, which then had to
be caught in hardware&lt;/a&gt;.
What we haven’t yet discussed is the switch itself, and how it works.&lt;/p&gt;

&lt;p&gt;When discussing this project, I’ve often shown the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/eth10g-busblocks.png&quot;&gt;component
diagram&lt;/a&gt; below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. The ETH10G project, from a bus component viewpoint&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;/img/eth10g/eth10g-busblocks.svg&quot;&gt;&lt;img src=&quot;/img/eth10g/eth10g-busblocks.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This illustrates the design based upon how the bus views the design–where the
two &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbars&lt;/a&gt;
are, and what components connect to them.  I’ve also used diagram
this from a management context to show how far the project is along.  Each
component was shaded in red initially, and it’s color slowly adjusted as the
project moved along.  It’s a color code I’ve used often to help communicate
project progress with others (i.e. customers), and it’s now worked nicely
across many projects.  The basic color legend works as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Red boxes indicate components that either haven’t yet been designed, or
whose design isn’t complete.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once a component has been designed and passes a basic Verilator lint check,
its color changes from red to yellow.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Components with formal proofs are then colored green.&lt;/p&gt;

    &lt;p&gt;Sometimes, I might also color as green components that aren’t going to
be formally verified, but that pass a test bench based simulation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once a component gets tested in hardware, an outline is given to it.  A
red outline indicates the component has failed hardware testing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A dark green outline is used to indicate a component that has passed all
hardware testing.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The diagram has been modified a bit from my basic encoding with annotations
underneath the components to indicate if a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
scope (a type of
internal logic analyzer) had been connected to the component, or if software
had been built for that component or not.  As you can see, I still have a bit
of work left to do on the &lt;a href=&quot;https://github.com/ZipCPU/wbsata&quot;&gt;SATA controller&lt;/a&gt;,
and the PCB still needs to go through another revision.  What is new, however,
is that the networking components of this design are now working.  The design
now functions as a switch.  Therefore, I thought this might be a good time to
discuss the network switch portion of this design, how it accepts 10Gb Ethernet
packets, processes them, and forwards the same 10Gb Ethernet packets on.&lt;/p&gt;

&lt;p&gt;We’ll work our way from the edges of this design, where the Ethernet packets
come in, all the way to the routing algorithm used by the switch.  We’ll
then discuss a special bus arbiter I needed to write, go through the network
components of this design that I expect will be reusable, and then discuss
some lessons learned from building the networking components.  Before we
get there, though, we have to take a moment to remind our readers of the
internal network protocol that is making all of this possible.&lt;/p&gt;

&lt;h2 id=&quot;the-internal-protocol&quot;&gt;The Internal Protocol&lt;/h2&gt;

&lt;p&gt;The entire packet processing system of this 10Gb switch is built around an
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;AXI Network (AXIN) packet
protocol&lt;/a&gt;.  I’ve &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;discussed
this some time before on this
blog&lt;/a&gt;.  However, since &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;this
protocol&lt;/a&gt; is so central
to everything that follows, it only makes sense to take a moment to quickly
review it here.  Specifically, let’s note the differnces between &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;this
AXIN protocol&lt;/a&gt; and the
&lt;a href=&quot;/doc/axi-stream.pdf&quot;&gt;standard AXI stream protocol&lt;/a&gt; it
was based upon.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 3. AXI Network protocol signals&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/axinsignals.png&quot; alt=&quot;&quot; width=&quot;472&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s start with why the
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt;
is necessary.  To put it in one word,
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN&lt;/a&gt;
is necessary because of &lt;em&gt;backpressure&lt;/em&gt;.  A &lt;a href=&quot;/doc/axi-stream.pdf&quot;&gt;true AXI
stream&lt;/a&gt; implementation
requires backpressure support–where a slave can tell the source it is not
ready, and hold the ready line false indefinitely.  However, in a network
context the incoming network source has a limited buffer to support any
backpressure.  Hence &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;the need for a new
protocol&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Many have argued that this isn’t a sufficient need to justify creating a new
protocol.  Why not, they have argued, just buffer any incoming packets until
a whole packet is in the buffer before forwarding it with full backpressure
support?  I’ve now seen several FIFO implementations which can do this sort of
thing: buffer until a full packet has been received, then forward the packet
via traditional AXI stream.  The reason why I haven’t chosen this approach is
because I had a customer ask for jumbo packet support (64kB+ packet sizes).
True “jumbo packets” will be larger than my largest incoming FIFO, so I haven’t
chosen this approach either.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt; differs
from &lt;a href=&quot;/doc/axi-stream.pdf&quot;&gt;AXI stream&lt;/a&gt; in two key respects.
The first is the addition of an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ABORT&lt;/code&gt; signal.  The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ABORT&lt;/code&gt; signal can be
raised by an &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN master&lt;/a&gt;
master at any time–even when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VALID &amp;amp;&amp;amp; !READY&lt;/code&gt;.  If raised, it signals that
to the &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN slave&lt;/a&gt;
that the current packet needs to be dropped in its entirety.
Many reasons might cause the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ABORT&lt;/code&gt; to be asserted.  For example, if the
initial packet source can’t handle the slave’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!READY&lt;/code&gt; signal, it could abort
the packet.  If the packet CRC doesn’t match, the packet might also be aborted.&lt;/p&gt;

&lt;p&gt;The second differences is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYTES&lt;/code&gt; field.  The &lt;a href=&quot;/doc/axi-stream.pdf&quot;&gt;original AXI stream
protocol&lt;/a&gt;
identified valid bytes via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TKEEP&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TSTRB&lt;/code&gt;.  This allows packet data to
be discontinuous, and requires processing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2*WIDTH/8&lt;/code&gt; signals per beat.  The
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;AXIN protocol&lt;/a&gt;
instead uses a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYTES&lt;/code&gt; field having only &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$clog2(WIDTH/8)&lt;/code&gt; bits.
This &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYTES&lt;/code&gt; field has the requirement that it must be zero (all bytes valid)
for all but the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LAST&lt;/code&gt; beat, where it can be anything.  This also carries
the implied requirement that all beats prior to the last beat must be full,
and the last beat must be right (or left) justified.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 4. Watch out for mixed endianness!&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/endianbug.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When defining &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;this
protocol&lt;/a&gt;, I didn’t define
whether or not it was little endian or big endian.  As a consequence, some of
the components of this design are little endian (Ethernet is little endian by
nature), and others are big endian–since I implement both
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; and the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; in a big-endian fashion.&lt;/p&gt;

&lt;h2 id=&quot;gtx-phy-front-end&quot;&gt;GTX PHY Front End&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;This design&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/xgtxphy.v&quot;&gt;uses Xilinx’s GTX IO
controllers&lt;/a&gt;
to generate and ingest the 10Gb/s links.  As &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/xgtxphy.v&quot;&gt;I’ve configured
them&lt;/a&gt;, the GTX
IO controllers within this project act like 1:32 and 32:1 I/OSERDES macros,
simplifying their implementation.  Some key features of these components is
that they can recover the clock when receiving and they
can perform some amount of receive decision feedback channel equalization (DFE).&lt;/p&gt;

&lt;p&gt;Although these transceivers appear amazing in capability, this great capability
seems also to be their Achilles heel.  I found myself reading, re-reading, and
then re-reading their user guide again and again only to find myself confused
regarding how to configure them.  It didn’t help that many of the configuration
options said that the Xilinx wizard’s configuration was to be used, and nothing
more explained about the respective option.  Nor did it help that many of the
ports remain as legacy from previous versions of the controller, and the user
guide suggests that they should not be used anymore.  The GTX transceivers have
many, many options associated with them, many of which are either not
documented at all or are only poorly documented within the user guide.  The
“official” solution to this problem is to use a Vivado wizard for that purpose,
and then to use one of the canned configurations Vivado offers.  Perhaps this
is ideal for Xilinx, who sells a fixed number of IP components based upon these
configurations.  However, this doesn’t really work well when you wish to
post or share an all–RTL design.  It also fails when you want to step off
of the beaten path.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 5. The next GTX project will bee SATA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/nextgtx.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As a result, I often ended up rather confused when configuring the GTX
components.&lt;/p&gt;

&lt;p&gt;The most obvious consequence of this is that I relied heavily on the GTX
simulation models.  This meant that I needed to &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/bench/rtl/tbenet.v&quot;&gt;model a 10Gb Ethernet link
in Verilog&lt;/a&gt;
to stimulate those models.  If you look, you’ll notice I’ve
got quite the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/fc846af41987236f1c00886e5f87e58ca7e6ba51/bench/rtl/tbenet.v#L162-L306&quot;&gt;clock recovery circuit&lt;/a&gt;
written there in Verilog as well, so
that I can recover the clock from the signal generated by the GTX simulation
model.  For those who know me, this is also a rather drastic departure from my
all-&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
approach to simulation.  This is understandable, though, given both the
complexity of these components and the fact that Xilinx did not provide a
simulation model that would work with
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A second consequence is that I was never able to get the GTX’s 64/66b
encoder/decoder working.  I’m sure the interface was quite intuitive to
whoever designed it.  I just couldn’t get it working–not even in simulation.
Then again, schedule pressure being what it was, it was just simpler to build
(and formally verify) my own
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66brxgears.v&quot;&gt;32:66&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66btxgears.v&quot;&gt;66:32&lt;/a&gt;
gearboxes, and to use my own &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66brxgears.v&quot;&gt;66b synchronization
module&lt;/a&gt;.
Perhaps I might’ve figured out how to do this with their GTX transceiver if I
had another month to work on it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 6. Note to Xilinx's designers&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/nowizard.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Were I to offer any suggestions to Xilinx regarding their GTX design, I
would simply suggest that they simplify it drastically.  A good hardware IO
module on an FPGA should handle any required high speed IO, while also leaving
the protocol processing to be implemented in the FPGA fabric.  It should also
be versatile enough to continue to support the same protocols it currently
supports (and more), without doing protocol specific handling, such as 64/66b
or 8b/10b encoding and decoding, in the PHY components themselves.  This
means I’d probably remove phase alignment and “comma detection” from the PHY
(I wasn’t using either of them for this project anyway) and force them back
into the FPGA fabric.  (Ask me again about these features, though, after I’ve
had to use the GTX for a project that requires them.)&lt;/p&gt;

&lt;p&gt;So, in the end, I used the GTX transceiver simply as a combined 32:1 OSERDES
(for the transmit side) and a 1:32 ISERDES with clock recovery (for receive).
Everything else was relegated to the fabric.&lt;/p&gt;

&lt;h2 id=&quot;the-digital-front-end&quot;&gt;The Digital Front End&lt;/h2&gt;

&lt;p&gt;Ethernet processing in FPGA Logic was split into two parts.  The first part,
what I call the “digital front end”, converts the 32b data interface
required by the PHY to the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;AXIN interfaces&lt;/a&gt; used by
everything else.  That’s all done in my
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netpath.v&quot;&gt;netpath&lt;/a&gt;
module.&lt;/p&gt;

&lt;p&gt;Early on in this project, I diagrammed out this path, as shown in Fig. 7 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Networking flow block diagram&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/eth10g-blocks.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The diagram begin as a simple block diagram of networking components that
needed to be built and verified for the switch to work.  (The color legend
for this component is roughly the same as the color legend for the bus
components shown in Fig. 2 above.)&lt;/p&gt;

&lt;p&gt;Let’s walk through that module briefly here, working through first the receive
chain followed by the transmit chain.  In each case, processing is accomplished
a discrete number of steps.&lt;/p&gt;

&lt;h3 id=&quot;the-incoming-rx-chain&quot;&gt;The (Incoming) RX Chain&lt;/h3&gt;

&lt;p&gt;The receive data processing chain starts with 32b words, sampled at
322MHz, and converts them to 128b wide &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN packet
streams&lt;/a&gt; sampled at 100MHz.
(Why 100MHz?  Because that was the DDR3 SDRAM memory controller’s speed in this
design.)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66brxgears.v&quot;&gt;32b/66b Gearbox&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;As I mentioned in the GTX section above, I could never figure out how to
get the 64/66b conversion working in the GTX front end.  I’m sure Xilinx’s
interface made sense to some, it just never quite made sense to me.  As a
result, it was just easier to use the PHY as a 32b ISERDES and process
everything from there.  This way I could control the signaling and gearbox
handling.  Even better, I could formally verify that I was doing things
right using the signals I had that were under my own control.&lt;/p&gt;

    &lt;p&gt;That means that the first step is a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66brxgears.v&quot;&gt;32:66b
gearbox&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This gearbox is also where the 66b synchronization happens.  For those not
familiar with the 64/66b protocol, the extra two bits are used for
synchronization.  These two bits are guaranteed (by protocol) to be
different.  One bit combination will indicate the presence of packet data,
the other indicates control information.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/fb19d04f46d5bb485020e2d8664c5606c6645612/rtl/net/p66brxgears.v#L114-L138&quot;&gt;alignment algorithm is fairly straightforward, and centers on an
alignment counter&lt;/a&gt;.
We first assume some arbitrary shift will produce aligned data.  &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/fb19d04f46d5bb485020e2d8664c5606c6645612/rtl/net/p66brxgears.v#L124&quot;&gt;If the two
control bits differ&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/fb19d04f46d5bb485020e2d8664c5606c6645612/rtl/net/p66brxgears.v#L127&quot;&gt;this counter is incremented by one&lt;/a&gt;.
Once the counter sets the MSB, this particular shift is declared
to be aligned.  If the two control bits are the same–that is if they are
invalid, then &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/fb19d04f46d5bb485020e2d8664c5606c6645612/rtl/net/p66brxgears.v#L128-L129&quot;&gt;the counter is decremented by three&lt;/a&gt;.
Once the counter gets to zero, an alignment failure is declared and
the algorithm moves on to check the next potential alignment by &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/fb19d04f46d5bb485020e2d8664c5606c6645612/rtl/net/p66brxgears.v#L131-L136&quot;&gt;incrementing
the shift amount&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;From a rate standpoint, data comes in at 32b/clk, and leaves &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66brxgears.v&quot;&gt;this
gearbox&lt;/a&gt;
via an &lt;a href=&quot;/doc/axi-stream.pdf&quot;&gt;AXI stream protocol&lt;/a&gt;
that requires &lt;em&gt;READY&lt;/em&gt; to be held high.  There’s no room to support any
backpressure here.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;CDC&lt;/a&gt; from 322.3MHz to 200MHz&lt;/p&gt;

    &lt;p&gt;The problem with data coming in from the GTX PHY is that the received data
is on a derived clock.  As with any other externally provided clock, this
means that the incoming clock (after recovery) will appear to be &lt;em&gt;near&lt;/em&gt;
its anticipated 10.3125GHz rate, but is highly unlikely to match any
internal reference we have to 10.3125GHz exactly.  Even when we divide it
down by 32x, it will only be somewhere &lt;em&gt;near&lt;/em&gt; a local 322.3MHz reference.
For this reason, we want to cross from the per-channel clock rate to a
common rate that can be used within our design–one allowing some timing
overhead.  In this case, we convert to a 200MHz clock.&lt;/p&gt;

    &lt;p&gt;The CDC is accomplished via a &lt;a href=&quot;/blog/2018/07/06/afifo.html&quot;&gt;basic asynchronous
FIFO&lt;/a&gt;, with the exception that
the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;FIFO has been modified to recognize and propagate ABORT
signals&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 8. Turning the scrambling off?&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/scrambleon.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p64bscrambler.v&quot;&gt;Descrambler&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Embedding clock and data together, as described above, requires having
data that is sufficiently pseudorandom–otherwise there might not be enough
bit transitions to reconstruct the clock signal.  Likewise, if the
incoming data isn’t sufficiently random, the 66b frame detector might suffer
from “false locks” and fail to properly detect packet data.  The 10Gb
Ethernet specification describes a feedthrough scrambling algorithm that is
to be applied to the 64 data bits of every 66b code word.  Our first task,
therefore, before we can process the 66b code word is to remove this
scrambling.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p642pkt.v&quot;&gt;Packet delimiter and fault detector&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;The next step is to convert these descrambled 66b codewords into our
internal AXI network (AXIN) packet stream format.&lt;/p&gt;

    &lt;p&gt;For those familiar with Ethernet, they may recall that the Ethernet
specification describes an &lt;a href=&quot;https://en.wikipedia.org/wiki/Media-independent_interface#XGMII&quot;&gt;XGMII “10Gigabit Media Independent
Interface”&lt;/a&gt;,
and suggests this interface should be used to feed the link.  This project
didn’t use the XGMII interface at all.  Why not?  Because the 66b encoding
describes a set of either 64b data or 64b codewords.  As a result, it makes
sense to process these words 64b at a time–rather than the 32b at a time
used by the XGMII protocol.  Transitioning from 64b at a time to the
32b/clk of the XGMII protocol would require either processing data at
the original 322.3MHz, or doing another clock domain crossing.  It was just
easier to go straight from the 66b format of the 10Gb interface directly
to a 64b &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN&lt;/a&gt; format.&lt;/p&gt;

    &lt;p&gt;Following this converter, we are now in a standard packet format.
Everything from here until a (roughly) equivalent point in the transmit
path takes place in this AXIN packet protocol.&lt;/p&gt;

    &lt;p&gt;While &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN&lt;/a&gt;
backpressure is supported from here on out, any backpressure will
likely cause a dropped packet.&lt;/p&gt;

    &lt;p&gt;This is the first place in our processing chain where an ABORT may be
generated.  Any ABORTs that follow in the receive chain will either be
propagated from this one, or due to subsequently detected errors in the
packet stream.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/dropshort.v&quot;&gt;Cull short packets&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Our next two steps massage our data just a little bit.  This first step
drops any packets shorter than the Ethernet minimum packet length: 64Bytes.
These packets are dropped via the
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN ABORT&lt;/a&gt; signal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/crc_axin.v&quot;&gt;CRC Checking&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;From here, we check packet CRCs.  Any packet whose CRC doesn’t match will
be dropped via an ABORT signal.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/01b6322d7950cf29035c6dfcfca077ebddf1669c/rtl/net/crc_axin.v#L124-L141&quot;&gt;Although a basic CRC algorithm is quite straightforward&lt;/a&gt;,
getting this algorithm to pass timing was a bit harder.  Remember, packets
arrive at 64b/clk, and can have any length.  Therefore, the four byte CRC
may be found on any byte boundary.  That means we need to be prepared to
check for any one of eight possible locations for a final CRC.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/01b6322d7950cf29035c6dfcfca077ebddf1669c/rtl/net/crc_axin.v&quot;&gt;Our first attempt to check CRCs&lt;/a&gt;
generated the correct CRC for each byte cut based upon the CRC from the
last byte cut.  This didn’t pass timing at 200MHz.&lt;/p&gt;

    &lt;p&gt;So, let’s take a moment to analyze the basic CRC algorithm.  You can &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/01b6322d7950cf29035c6dfcfca077ebddf1669c/rtl/net/crc_axin.v#L124-L141&quot;&gt;see
it summarized in Verilog here&lt;/a&gt;.
It works based upon a register I’ll call the “fill” (it’s called “current”
in &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/01b6322d7950cf29035c6dfcfca077ebddf1669c/rtl/net/crc_axin.v#L124-L141&quot;&gt;this Verilog summary&lt;/a&gt;).
On each new bit, this “fill” is
shifted right by one.  The bit that then falls off the end of the register
is exclusive OR’d with the incoming bit.  If the result is a ‘1’, then a
32b value is added to the register, otherwise the result is left as a
straight shift.&lt;/p&gt;

    &lt;p&gt;The important conclusion to draw from this is that the CRC “fill” register
is simply propagated via linear algebra over GF2.  &lt;em&gt;It’s just a linear
system!&lt;/em&gt;  This is important to understand when working with any algorithm
of this type.&lt;/p&gt;

    &lt;p&gt;Not only is this a linear system, but 1) the equations for each bit have
fixed coefficients, and 2) they are roughly pseudorandom.  That means that
it should be possible to calculate any bit in the next CRC value based upon
the previous fill and the new data using only 96 input bits, of which only
a rough half of them will be non-zero (due to the pseudorandomness of the
operator).  Exclusive OR’ing 48bits together can be done with only 12 LUT6s
and three levels of logic.  (My out-of-date version of Yosys maps this to
20 LUT6s and 4 LUT4s.)  My point is this: if you can convince your synthesis
tool to remap this into a set of independnt linear equations, each will
cheap and easy to implement.&lt;/p&gt;

    &lt;p&gt;Rewriting the CRC checker so that it first transformed the problem into a
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/crc_eqn.v&quot;&gt;linear equation set&lt;/a&gt;,
turned out to be just the juice needed to pass timing at 200MHz.&lt;/p&gt;

    &lt;p&gt;The result of this &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/crc_axin.v&quot;&gt;check
module&lt;/a&gt;
is that packets with failing CRCs will be ABORTed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;Resize from 64b/clk to 128b/clk&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Since the system clock for this design is 100MHz, we need to cross clock
domains one more time.  This requires more parallelism, so we first increase
our packet width from 64b/clk to 128b/clk in preparation of this final
clock domain crossing.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;width converter&lt;/a&gt;
used for this purpose has been designed to be very generic.  As a result,
you’ll find it used many times over in this design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;CDC&lt;/a&gt; from 200MHz to 100MHz – the bus clock speed&lt;/p&gt;

    &lt;p&gt;The last step of our incoming packet processor is to
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;cross clock domains&lt;/a&gt;
from our intermediate clock speed of 200MHz to 100MHz.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You may notice two additional blocks in Fig. 7 that aren’t connected to the
data stream.  These
are outlined with a dashed line to indicate that they are optional.  I placed
the components in the chain because I have used a similar component in previous
designs.  These components might check the IP version, and potentially check
that the header checksum or the packet length matches the one arriving.
In other designs, these components would also verify that arriving packets
were properly addressed to &lt;em&gt;this&lt;/em&gt; destination.  However, in
&lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;this project&lt;/a&gt;, a choice was made early on
that these IP-specific components wouldn’t be required for an &lt;em&gt;Ethernet&lt;/em&gt; (not
IP) switch, and so they have never been either built or integrated into the
design.&lt;/p&gt;

&lt;p&gt;From here on out, all processing takes place via the
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt;.  It is
possible for a long packet to come through this portion of the interface, only
to be ABORTed right at the end.&lt;/p&gt;

&lt;h3 id=&quot;the-outgoing-tx-chain&quot;&gt;The (Outgoing) TX Chain&lt;/h3&gt;

&lt;p&gt;The other half of the digital front end takes packets incoming, via the
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt;,
and converts them to a set of 32b words for the GTX PHY.  As with
the receive processing chain, this is also accomplish in a series of discrete
steps.  Both halves are found within the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netpath.v&quot;&gt;netpath.v&lt;/a&gt;
module.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;CDC&lt;/a&gt;
from 100MHz to 200MHz&lt;/p&gt;

    &lt;p&gt;Our first step is to cross from the 100MHz bus clock speed to a 200MHz
intermediate clock speed.  This simply moves us closer to the clock we
ultimately need to be on, while reducing the amount of logic required on
each step.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;Resize&lt;/a&gt; from 128b/clk to 64b/clk&lt;/p&gt;

    &lt;p&gt;Our first step, once we cross back into the 200MHz clock domain, is to
move from 128b/clk back to 64b/clk.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktgate.v&quot;&gt;Packet gate and FIFO&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;One problem with Ethernet transmission is that there’s no way to pause an
outgoing packet.  If the data isn’t ready when it’s time to send, the
packet will need to be dropped.  In order to keep this from happening, I’ve
inserted what I call a “&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktgate.v&quot;&gt;packet gate&lt;/a&gt;”.  This component first
loads incoming data into an &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;AXIN FIFO&lt;/a&gt;, and then it holds up each individual
packet until either 1) the entire packet has entered the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;FIFO&lt;/a&gt;, or
2) the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;FIFO&lt;/a&gt;
becomes full. (Remember, backpressure is fully supported on the input.)
This way we can have confidence, going forward, that any memory delays from
the &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual FIFO&lt;/a&gt;
feeding us our data from DDR3 memory will not cause us
to drop packets.  For shorter packets, this is a guarantee.  For longer
packets, the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;FIFO&lt;/a&gt;
just mitigates any potential problems.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spoiler&lt;/p&gt;

    &lt;p&gt;According to the Ethernet standard, I should have a packet spoiler at my
next step.  This spoiler would guarantee that any packets that must be
ABORTed (for whatever reason) have failing CRCs.&lt;/p&gt;

    &lt;p&gt;This spoiler is not (yet) a part of my design.  As a result, there is a
(low) risk of a corrupt packet crossing the interface and (somehow) having
a valid CRC on the other end.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pkt2p64b.v&quot;&gt;Packet assembler&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;At this point, it’s time to switch from the
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt;
back to the 66b/clk Ethernet network protocol.  This includes inserting idle
indications, link error (remote fault) indications, start and end of packet
indications, as well as the packet data itself.&lt;/p&gt;

    &lt;p&gt;The big thing to remember here is that, once a packet enters this component,
the packet data stream cannot be allowed to run dry without corrupting the
outgoing data stream.&lt;/p&gt;

    &lt;p&gt;The result of this stage is a 66b AXI stream, whose &lt;em&gt;VALID&lt;/em&gt; signal must be
held high.  &lt;em&gt;READY&lt;/em&gt; will not be constantly high, but will be adjusted as
necessary to match the speed of the ultimate transmit clock.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p64bscrambler.v&quot;&gt;Scrambler&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Just like the incoming packet data, we need to apply the same feedthrough
scrambler to the data going out.&lt;/p&gt;

    &lt;p&gt;The result of this stage remains a 66b AXI stream.  As with the prior
stage, &lt;em&gt;VALID&lt;/em&gt; needs to be held high.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66btxgears.v&quot;&gt;66/64b gearbox&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;As I mentioned earlier, the Xilinx GTX interface was a challenge to use
and get working.  I only use, therefore, the 32b interface as either a
ISERDES or in this case an OSERDES type of operator.  That means I need
to move from 66b/clk to 32b/clk.  The first half of this conversion takes
place at the 200MHz clock rate, converting to 64b/clock.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;CDC&lt;/a&gt; from 200MHz to 322.3MHz&lt;/p&gt;

    &lt;p&gt;From here, we can cross from our intermediate clock rate to the clock rate
of the GTX transmitter.  This is done via a &lt;a href=&quot;/blog/2018/07/06/afifo.html&quot;&gt;standard asynchronous FIFO–such
as we’ve written about on this blog
before&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;64/32b gearbox&lt;/p&gt;

    &lt;p&gt;The last step in the digital front end processor is to switch from 64b
at a time to 32b at a time.  Every other clock cycle reads a new 64b from
the asynchronous FIFO and sends 32b of those 64b, whereas the other 32b are
sent on the next clock.&lt;/p&gt;

    &lt;p&gt;Why not match the receive handler, and place the full 64/66b gearbox at
the 322.3MHz rate?  I tried.  It didn’t pass timing.  This two step approach,
first going from &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66btxgears.v&quot;&gt;66b to
64b&lt;/a&gt;,
and then from 64b to 32b is a compromise that works well enough.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s the two digital components of the PHY.  Ever after these two components,
everything takes place using the
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;the-switch&quot;&gt;The Switch&lt;/h2&gt;

&lt;p&gt;Now that we’ve moved to a common protocol, everything else can be handled via
more generic components.  This brings us to the core of the project, the 4x4
Ethernet switch function itself.  This switch function is built in two parts.
The first part is all about buffering incoming packets, and then routing them
to their ultimate destinations.  The second component, the routing algorithm,
we’ll discuss in the next section.&lt;/p&gt;

&lt;p&gt;The challenge of the switch is simply that packets may arrive at any time on
any of our interfaces, and we want to make sure those packets can be properly
routed to any outgoing interface–even if that outgoing interface is currently
busy.  While one approach might be to drop packets if the outgoing interface
is busy, I chose the approach in this project of instead trying to buffer
packets in memory via the &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual packet
FIFOs&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Notify all routing tables of the incoming MAC&lt;/p&gt;

    &lt;p&gt;The first step in the switch is to grab the MAC source address from the
incoming, and to notify all of the per-port routing tables of this MAC
address.&lt;/p&gt;

    &lt;p&gt;We’ll discuss the routing algorithm more in the next section.  It’s based
upon first observing the Ethernet MAC addresses of where packets come from,
and then routing packets to those ports when the addresses are known, or
to all ports when the destination port is unknown.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;Virtual packet FIFOs&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;The second step is to buffer the place the incoming packet into either a
&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;Virtual packet FIFO&lt;/a&gt;,
or (based upon a configuration choice) just run it through a block RAM
based &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;NetFIFO&lt;/a&gt;.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Resize from 128b/clk to 512b/clk&lt;/p&gt;

        &lt;p&gt;Pushing all incoming packets into memory requires some attention be paid
to memory bandwidth.  At 128b/clk, there’s not enough bandwidth to push
more than one incoming packet to memory, much less to read it back out
again.  For this reason, the DDR3 SDRAM width was selected to be wide
enough to handle 512b/clock, or (equivalently) just over four incoming
packets at once.&lt;/p&gt;

        &lt;p&gt;Sadly, that means we need to convert our packet width again.  This time,
we convert from 128b/clk to 512b/clk.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Incoming &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;NetFIFO&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;SDRAM memory is not known for its predictable timing.  Lots of things can
happen that would make an incoming packet stream suffer.  It could be that
the CPU is currently using the memory and the network needs to wait.  It
might be that the memory is in the middle of a refresh cycle, and so all 
users need to wait.  To make sure we can ride through any of these delays,
the first step is to push the incoming packet into a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;block-RAM based
AXIN FIFO&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Write packets to memory, then prefixing it with a 32b length word&lt;/p&gt;

        &lt;p&gt;Packet data is then written to memory.&lt;/p&gt;

        &lt;p&gt;My &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;Virtual packet FIFO&lt;/a&gt;
implementations work on a 32b alignment.  This means that the incoming
packet data may need to be realigned to avoid overwriting valid data that
might already be in the FIFO.&lt;/p&gt;

        &lt;p&gt;Once the entire packet has been written to memory, the 32b word following
is set to zero and the 32b word preceding the packet is then written with
the packets’ size.  This creates sort of a linked-list structure in memory,
but one that only gets updated once a completed packet has been written to
memory.&lt;/p&gt;

        &lt;p&gt;If the incoming packet is ever ABORTed, then the length word for the packet
is kept at zero, and the next packet is just written to the place this
one would’ve been written to.&lt;/p&gt;

        &lt;p&gt;Once the packet size word has been written to memory, and the memory
has acknowledged it, the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;virtual packet FIFO writer&lt;/a&gt;
then notifies the reader of its new write pointer.  This signals to the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
that a new packet may be available.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Read packets back from memory, length word first&lt;/p&gt;

        &lt;p&gt;Once a packet has been written to memory, and hence once the write pointer
changes, that packet can then be read from memory.  This task works by
first reading the packet length from memory, and then reading that many
bytes from memory to form an outgoing packet.&lt;/p&gt;

        &lt;p&gt;One thing to beware of is that
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
has no ability to offer read
backpressure on the bus.  (AXI has the ability, but for performance and
potential &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlock&lt;/a&gt;
reasons it really shouldn’t be used.)  This means
that the part of the bus handler requesting data needs to be very aware
of the number of words both requested by the bus as well as those contained
in the synchronous FIFO to follow.  Bus requests should not be issued
unless room in the subsequent FIFO can be guaranteed.&lt;/p&gt;

        &lt;p&gt;I’ve also made an attempt to guarantee that FIFO performance will be
handled on a &lt;em&gt;burst&lt;/em&gt; basis.  Hence,
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
requests will not be made
unless the FIFO is less than half full, and they won’t stop being made
until the FIFO is either fully committed, or the end of the packet has
been reached.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/sfifo.v&quot;&gt;Synchronous FIFO&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;This is just a basic &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/sfifo.v&quot;&gt;synchronous FIFO&lt;/a&gt;
with nothing special about it.  It’s almost identical to the &lt;a href=&quot;/blog/2017/07/29/fifo.html&quot;&gt;FIFO I’ve
written about before&lt;/a&gt;,
save that &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/sfifo.v&quot;&gt;this one&lt;/a&gt;
has been formally verified and gets used any time I need a FIFO.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Width adjustment, from 512b/clk back to 128b/clk&lt;/p&gt;

        &lt;p&gt;The last step in the &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual packet
FIFO&lt;/a&gt; is to convert
the bit width back from 512b/clk to 128b/clk.&lt;/p&gt;

        &lt;p&gt;Remember, 128b/clk is just barely enough to keep up at a 100MHz clock.
We needed the 512b/clk width to use the memory.  Now that we’re done with
the memory transactions, we can go back to the 128b/clk rate to lower
our design’s LUT count.&lt;/p&gt;

        &lt;p&gt;From this point forward, we can support as much backpressure as necessary.
In many ways, this is the purpose of the
&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual packet FIFOs&lt;/a&gt;:
allowing us to buffer unlimited packet sizes in memory, so that we can
guarantee full backpressure support following this point.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Get the packet’s destination MAC&lt;/p&gt;

    &lt;p&gt;Once a packet comes back out of the
&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;FIFO&lt;/a&gt;, the next step
is to look up its MAC destination address.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Ethernet_frame&quot;&gt;This can be found in the first
6 octets&lt;/a&gt; of the packet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Look up a destination for this MAC&lt;/p&gt;

    &lt;p&gt;We then send this MAC address to the routing algorithm, to look up where
it should be sent to.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broadcast the packet to all desired destinations&lt;/p&gt;

    &lt;p&gt;The final step is to &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinbroadcast.v&quot;&gt;broadcast&lt;/a&gt;
this packet to all of its potential destination ports at once.&lt;/p&gt;

    &lt;p&gt;This is built off of an &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinbroadcast.v&quot;&gt;AXIN broadcast&lt;/a&gt;
component to create many
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN&lt;/a&gt;
streams from one, followed by an
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinarbiter.v&quot;&gt;AXIN arbiter&lt;/a&gt;
used to select from many sources to determine which source should be
output at a given time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s how most packets are handled.  Packets to and from the CPU are handled
differently.  Unlike the regular packet paths, the CPU’s virtual FIFO
involves the CPU.  This changes the logic for this path subtly.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The CPUNet acts like its own port to the switch.  That means that,
internally, the switch is a 5x5 switch and not a 4x4 switch.  It still has
four physical ports, but it also has a virtual internal port going to
the CPU.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The CPU port doesn’t require a
&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual packet FIFO&lt;/a&gt;
within the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/routecore.v&quot;&gt;router core&lt;/a&gt;.  Instead, its
&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual packet FIFO&lt;/a&gt;
is kept external to the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/routecore.v&quot;&gt;router
core&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As a result, packets come straight in to the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/routecore.v&quot;&gt;switch
component&lt;/a&gt;,
get their MAC source recorded in the routing table, and then do all of
the route processing other packets go through, save that they don’t need
to through a &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual packet
FIFO&lt;/a&gt; since they come
from &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;a virtual packet
FIFO&lt;/a&gt; in the first place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Likewise, in the reverse direction, packets routed to the CPU leave the
router and go straight to the CPU’s
&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual packet FIFO&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On entry, the CPU path has the option to filter out packets not addressed
to its MAC–whatever assignment it is given.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;However, for packet inspection and testing, this extra filter has often been
turned off.  Indeed, a special routing extension has been added to allow
the CPU to “see” all ports coming in, and so it can inspect any packet
going through the switch if bandwidth allows.  (If bandwidth doesn’t allow
this, packets in the switch may be dropped as well.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;the-routing-algorithm&quot;&gt;The Routing Algorithm&lt;/h2&gt;

&lt;p&gt;The very first thing I built was the routing algorithm.  This I felt was the
core of the design, the soul and spirit of everything else.  Without routing,
there would be no switch.&lt;/p&gt;

&lt;p&gt;The problem was simply that I’d never built a routing algorithm before.&lt;/p&gt;

&lt;p&gt;My first and foremost goal, therefore, was to just build something that works.
I judged that I could always come back later and build something better.  Even
better, because this system is open source, released under the Apache 2.0
license, someone else is always welcome to come back later and build something
better.  That’s how open source worked, right?&lt;/p&gt;

&lt;p&gt;So let’s go through the basic requirements.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;All packets must be routed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hence, if the router can’t tell which destination to send a packet to, 
then that packet should be broadcast to all destinations.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Packets should not be looped back upon their source.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Packets sent to broadcast addresses must be broadcast.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In hindsight, I should have built the table with some additional requirements:&lt;/p&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;It should be possible for the internal CPU to read the state of the table at
any time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The CPU should be able to generate configure fixed routes.&lt;/p&gt;

    &lt;p&gt;These include both routes where all packets from a given port go to a
given destination port or set of ports, but also routes where a given MAC
address goes to a given port.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In hindsight, my routing algorithm used a lot of internal logic resources.
Perhaps a better solution might be to share the routing algorithm across
ports.  I didn’t do that.  Instead, each port had its own routing table.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given these requiremnts, I chose to build the routing algorithm around an
internal &lt;em&gt;routing table&lt;/em&gt;.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 9. Routing table columns&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/routetbl.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Each network port was given its own routing table.  As packets arrived,
the source MAC from the packet was isolated and then a doublet of source
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[PORT, MAC]&lt;/code&gt; was forwarded to the routing tables in the design
associated with all of the other ports.&lt;/p&gt;

&lt;p&gt;Each table entry has four components:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Each entry has a &lt;em&gt;valid&lt;/em&gt; flag.&lt;/p&gt;

    &lt;p&gt;When a new source MAC doublet arrives, it will be placed into the first
table entry without a valid entry within it.  That entry will then become
valid.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Each entry has a &lt;em&gt;MAC address&lt;/em&gt; associated with it.  This is the source address
of the packet used to create this entry.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Each entry has a &lt;em&gt;port number&lt;/em&gt; associated with it.  This is the number of the
port a packet with the given source address last arrived at.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Each entry has an &lt;em&gt;age&lt;/em&gt;.  (It’s really a timeout value …)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The age of any new entry to the table is given this timeout value.  The
timeout then counts down by one every clock cycle.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;If a MAC declaration arrives for an existing entry, its timeout is reset.
It will then start counting down from its full timeout value.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;If 1) a new MAC declaration arrives for an entry that isn’t in the table,
and , and 2) all entries are full, then 4) the oldest entry will be
rewritten with this new entry.&lt;/p&gt;

        &lt;p&gt;Calculating “oldest” turned out to be one of the more difficult parts of
this algorithm.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;After a period of time, if no packets arrive from a particular source,
then the entry will die of old age.&lt;/p&gt;

        &lt;p&gt;This allows us to accommodate routes that may need to change over time.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that no effort is made to sort this table one way or other.&lt;/p&gt;

&lt;p&gt;Now that we have this table, we can look up the destination port for a given
packet’s destination MAC address as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;If the packet’s destination MAC matches one from the table, the packet will
then be sent sent to the port associated with that MAC.&lt;/p&gt;

    &lt;p&gt;This basically sends packets to the last source producing a packet with that
MAC address.  This will fail if a particular source sends to a particular
destination, but that destination never responds.&lt;/p&gt;

    &lt;p&gt;Still, this constitutes a successful MAC table lookup.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the destination MAC can’t be found in the table, then it will be
forwarded to all possible destinations.&lt;/p&gt;

    &lt;p&gt;This constitutes a failed MAC lookup.  In the worst case, this will increase
network traffic going out by a factor of 4x in a 4x4 router.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This algorithm made a workable draft algorithm, up and until the network links
needed to be debugged.&lt;/p&gt;

&lt;p&gt;Just to make certain everything was working, the hardware was set up with the
bench-top configuration shown in Fig. 10.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. Testing configuration&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/netbench.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Ports #0 and #1 were connected in a loopback fashion.  Packets sent to port
#0 would be received at port #1, and vice versa–packets sent to port #1
would be received at port #0.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Port #2 was connected to an external computer via a coaxial cable.  We’ll
call this PC#2.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Port #3 was connected to an external computer via an optical fiber.  We’ll
call this PC#3.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, let me ask, what’s that loopback going to do to our routing algorithm?
Packets arriving on interface #2 for an unknown destination (PC#3’s address)
will then be forwarded to interfaces #0 and #1 in addition to port #3.
Ports #0 and #1 will then generate two incoming packets to be sent to the same
unknown MAC address (PC#3’s address), which will then cause our table to learn
that the MAC address generated by PC#2 comes from either port #0 or port #1.
(A race condition will determine which port it gets registered to.)  This
is also going to flood our virtual FIFOs with a never ending number of packets.&lt;/p&gt;

&lt;p&gt;This is not a good thing.&lt;/p&gt;

&lt;p&gt;I tried a quick patch to solve this issue.  The patch involved two new
parameters, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OPT_ALWAYS&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OPT_NEVER&lt;/code&gt;.  Using these two options, I was
able to adjust the outgoing port so that it read:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;NETH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// Number of ports&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NETH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;OPT_NEVER&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4'h3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NETH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;OPT_ALWAYS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;4'h0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;TX_PORT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lkup_port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_NEVER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OPT_ALWAYS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I could then use this to keep my design from forwarding packets to
port #0 or #1.&lt;/p&gt;

&lt;p&gt;It wasn’t good enough.&lt;/p&gt;

&lt;p&gt;For some reason, I was able to receive ARP requests from either ports #2
or #3, but they would never acknowledge any packets sent to them.  So … I
started instrumenting everything.  I wondered if things were misrouted,
so I tested sending packets everywhere arbitrarily.  Suddenly, ports #2
and #3 started acknowledging pings!  But when I cleaned up my arbitrary
routing, they no longer acknowledged pings anymore.&lt;/p&gt;

&lt;p&gt;This lead me into a cycle of adjusting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OPT_NEVER&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OPT_ALWAYS&lt;/code&gt; over
and over again, and rebuilding every time.  Eventually, this got so painful
that I turned these into run-time configurable registers.  (Lesson learned …)&lt;/p&gt;

&lt;p&gt;I’ll admit, I started getting pretty frustrated over this one bug.  The design
worked in simulation.  I could transmit packets from port #0 in simulation to
port #3, going through the router, so I &lt;em&gt;knew&lt;/em&gt; things should work–they just
weren’t working.  Like any good engineer, I started blaming the PCB designer
for miswiring the board.  To do that, though, I needed a good characterization
of what was taking place on the board.  So I started meticulously running
tests and drawing things out.  This lead to the following picture:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 11. The nightmare routing bug&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/20231122-nightmare.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This showed that packets sent to either ports #2 or #3 weren’t arriving.  If
I used the CPU to send to port #0, I could see the result on port #1.  However,
if I sent to port #1, nothing would be received on port #0.  Just to make
things really weird, if I sent to port #0 then ports #3 and #2 would see the
packet, but I couldn’t send packets to ports #2 or #3.&lt;/p&gt;

&lt;p&gt;Drawing the figure above out really helped.  Perhaps you can even see the bug
from the figure.&lt;/p&gt;

&lt;p&gt;If not, here it was: I used &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/xgtxphy.v&quot;&gt;one module to control all four GTX
transceivers&lt;/a&gt;.
This module had, as its input therefore, a value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_DATA&lt;/code&gt; containing 32-bits
for every port.  This module was not subject to lint testing, however, since
… the GTX PHY couldn’t be Verilated–or I might’ve noticed what was going
on.  I was then forwarding bits [63:0] of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_DATA&lt;/code&gt; to &lt;em&gt;every&lt;/em&gt; outgoing port,
rather than 32-bits of zero followed by bits &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[32*gk +: 32]&lt;/code&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_DATA&lt;/code&gt; to
port &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gk&lt;/code&gt;.  Because my network bench tests were limited to only look at
selected outputs, I then never noticed this issue.  The result was that anything
sent to port #0 would be sent to &lt;em&gt;all&lt;/em&gt; ports: #0-#3, and anything sent to
ports #1-#3 would go nowhere within the design.&lt;/p&gt;

&lt;p&gt;So let me apologize now to the PCB designer for this board.  This one was my
bug after all.&lt;/p&gt;

&lt;p&gt;Let me also suggest that this bug would’ve been much easier to find if I had
designed the routing algorithm from the beginning so that I could test specific
hardware paths.  The CPU, for example, should be able to override any and all
routing paths.  Likewise, the CPU should be able to read (and so verify) any
current routing paths.&lt;/p&gt;

&lt;p&gt;A second problem with the router algorithm was that it consumed too many
resources.  The routing tables were first designed to have 64 entries in each
of the four tables.  When space got tight, this was dropped to 32 entries,
and then to 16, and then down to 8.  Any rewrite of this algorithm should
therefore address the space used by the table–in addition to making it easier
for the CPU to read and modify the table at will.&lt;/p&gt;

&lt;h2 id=&quot;the-special-bus-arbiter&quot;&gt;The Special Bus Arbiter&lt;/h2&gt;

&lt;p&gt;This design required a special
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
arbiter.  To explain this need, though, I’ll need to do a little bit of math.&lt;/p&gt;

&lt;p&gt;Suppose a port is receiving data at 10Gb/s.  By the time we’ve adjusted the
data down so that the stream is moving 512b per clock at a 10ns clock period,
that means one 512b word will need to be written to memory 51.2ns.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 12. Bus width.  We had to go wide&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/buswidth.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The typical DDR3 SDRAM access takes about 20 clock cycles of latency or so,
with longer latency requirements if the SDRAM requires either a refresh cycle
or a bank swapping cycle.  Bank swapping can be avoided if the SDRAM accesses
are burst together in a group–a good reason to use a FIFO, but there’s no easy
way to avoid refresh cycles.&lt;/p&gt;

&lt;p&gt;That’s only the first problem.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 13. Wishbone can be very inefficient&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;/img/eth10g/b4drom.svg&quot;&gt;&lt;img src=&quot;/img/eth10g/b4drom.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The second problem is illustrated in Fig. 13 above.  In this diagram, the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S1_*&lt;/code&gt; signals are from the first source, while the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S2_*&lt;/code&gt; signals are from the second source.  The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M_*&lt;/code&gt; signals would then go
to the downstream device–such as the DDR3 SDRAM or, in this case, a second
arbiter (shown above in Fig. 2) to then go to the DDR3 SDRAM.  (Yeah, I know,
there’s a &lt;em&gt;lot&lt;/em&gt; of levels to bus processing …)&lt;/p&gt;

&lt;p&gt;The problem in this illustration is associated with how
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
normally works: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CYC &amp;amp;&amp;amp; STB&lt;/code&gt; are raised on the first beat of any transaction
from a given master, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STB&lt;/code&gt; is dropped once all requests have been accepted,
and then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CYC&lt;/code&gt; is dropped once all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;s have been received.  The arbiter
then takes a cycle to know that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CYC&lt;/code&gt; has dropped, before allowing the
second master to have access to the bus.  This creates a great inefficiency,
since the master isn’t likely to make any requests between when it drops &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STB&lt;/code&gt;
and when it drops &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CYC&lt;/code&gt;.  Given what we know of DDR3 SDRAM, this inefficiency
could cost about 200ns per access.&lt;/p&gt;

&lt;p&gt;However, if all four ports are receiving at the same time, then 512b will
need to be written four times every 51ns, from each of four masters.&lt;/p&gt;

&lt;p&gt;This requirement was impossible to meet with my normal
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt;.
That &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbar&lt;/a&gt;
would wait until a master dropped &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CYC&lt;/code&gt;, before allowing a second
master to access the bus–suffering the inefficiency each time.  This is all
illustrated in Fig. 13 above.&lt;/p&gt;

&lt;p&gt;The solution that I’ve chosen to use is to create a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/wbmarbiter.v&quot;&gt;special Wishbone
master arbiter&lt;/a&gt;:
one that multiplexes wishbone accesses together from multiple masters to a
single slave.  This way I could transition from one master’s bus requests to
a second master’s bus requests, and then just route the return data to the
next master looking for return data.&lt;/p&gt;

&lt;p&gt;You can see how this might save time in Fig. 14 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. Merging WB requests within the same cycle&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;/img/eth10g/aftrdrom.svg&quot;&gt;&lt;img src=&quot;/img/eth10g/aftrdrom.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Notice how, in this figure, the requests get tightly packed together going to
memory.&lt;/p&gt;

&lt;p&gt;(Yes, this is what AXI was designed to do naturally, even though my AXI
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;crossbars&lt;/a&gt; don’t yet do
this.)&lt;/p&gt;

&lt;p&gt;There are some consequences to this approach, however, that really keep
it from being used generally.  One consequence is the loss of the ability
to lock the bus and do atomic transactions by simply holding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CYC&lt;/code&gt; high.
(The virtual packet FIFOs don’t need atomic transactions, so this isn’t
an issue.)
A second consequence is in error handling.  Because the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; bus aborts
any outstanding transactions on any error return, all outstanding requests
need to be aborted should any master receive a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus
error&lt;/a&gt; return.  As a result, all
masters will report a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;
return even if only one master caused the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;error&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Given that the &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual packet
FIFO&lt;/a&gt;
bus masters would only ever interact with memory, this solution works in this
circumstance.  I may not be able to use it again.&lt;/p&gt;

&lt;h2 id=&quot;reusable-components&quot;&gt;Reusable Components&lt;/h2&gt;

&lt;p&gt;We’ve discussed &lt;a href=&quot;/blog/2020/01/13/reuse.html&quot;&gt;hardware reuse&lt;/a&gt;
on this blog before, and we’ll probably come back and do so again.  I’ve said
before, I will say again: well designed, well verified IP is gold in this
business.  It’s gold because it can be reused over and over again.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 15. Good as gold&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/ipgold.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As examples, the network portion of this project alone has reused many
components,
to include the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, my &lt;a href=&quot;/blog/2018/07/06/afifo.html&quot;&gt;asynchronous
FIFO&lt;/a&gt;, my &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/sfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt;,
my &lt;a href=&quot;/blog/2019/05/22/skidbuffer.html&quot;&gt;skidbuffer&lt;/a&gt;, and my
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;Wishbone crossbar&lt;/a&gt;.  If you
look over the bus diagram in Fig. 2 above, you’ll also see many other
components that may have either been reused, or are likely to be reused
again–to include my &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;Quad SPI flash
controller&lt;/a&gt;,
&lt;a href=&quot;/blog/2018/11/29/llvga.html&quot;&gt;HDMI Controller(s)&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/wbicapetwo&quot;&gt;ICAPE2 controller&lt;/a&gt;, &lt;a href=&quot;/blog/2021/11/15/ultimate-i2c.html&quot;&gt;I2C
Controller&lt;/a&gt;, and now my
new &lt;a href=&quot;/formal/2023/07/18/sdrxframe.html&quot;&gt;SD-Card Controller&lt;/a&gt;–but
I’m trying to limit today’s focus on the network specific components for now.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 16. A list of my various network designs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/netprojs.svg&quot; alt=&quot;&quot; width=&quot;520&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Sadly, this is my fourth network design and many of the components from my
first three network designs cannot be reused.  My first network design used
a 100M/s link.  The next two network designs were based off of a 1Gb/s
Ethernet, and so used either 8b/clk or 32b/clk–depending on which clock was
being used.  Any component specific to the bit-width of the network could
(sadly) not be reused.  Likewise, the first two of these three previous designs
didn’t use the
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt;–limiting
their potential reuse.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 17. What is a &quot;store+notify&quot; design?&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/storenotify.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Perhaps this is to be expected.  The first time you design a solution to a
problem, you are likely to make a lot of mistakes.  The second time you’ll
get a lot closer.  The third time even closer, etc.  This is one of the reasons
I like to tell students to “Plan for failure.”  Why?  Because “success” always
comes after failure, and sometimes many “failures” are required to get there.
Therefore, you need to start projects early enough that you have time to get
past your early failures.  Hence, you should always plan for these failures
if you wish to succeed.&lt;/p&gt;

&lt;p&gt;That said, this &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN
protocol&lt;/a&gt; was enough of a
success on my third network project that I’m likely to use it again and again.
The fact that I chose to use it here attests to the fact that it worked well
enough on the last project that it didn’t need to be rebuilt at all.&lt;/p&gt;

&lt;p&gt;That also means I’m likely going to be using and reusing many of the generic
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN&lt;/a&gt; components from this
project to the next.  These include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;NetFIFO&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This is a basic FIFO, but for the
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt;.
Packets that have been completely received by the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;FIFO&lt;/a&gt;
will not be aborted–no matter how the master adjusts the ABORT signal.
What makes this component different from other network FIFOs I’ve seen is
that the ABORT signal may still propagate from the input to the output prior
to a full packet being recorded in the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;FIFO&lt;/a&gt;.
This means that &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;this particular network FIFO implementation&lt;/a&gt;
is able to handle packet sizes that might be much larger than the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;FIFO&lt;/a&gt; itself.&lt;/p&gt;

    &lt;p&gt;Although &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;my particular
implementation&lt;/a&gt;
doesn’t include the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;AXIN
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYTES&lt;/code&gt;&lt;/a&gt; signal, the data
width can be adjusted to include it alongside the data signal for no loss of
functionality.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netskid.v&quot;&gt;NetSkid&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This is a version of your
&lt;a href=&quot;/blog/2019/05/22/skidbuffer.html&quot;&gt;basic skidbuffer&lt;/a&gt;,
but this time applied to the
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt;.
As a result, it supports the ABORT signal, but in all other ways it’s just a
basic &lt;a href=&quot;/blog/2019/05/22/skidbuffer.html&quot;&gt;skidbuffer&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This particular component was easy enough to design, and it would make a good
classroom exercise for the student to design his own.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;Virtual Packet FIFOs&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The most challenging component to verify, and hence to build, has been the
&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual Packet FIFOs&lt;/a&gt;.
On the other hand, these are &lt;em&gt;very&lt;/em&gt; versatile, and so I’m likely to use them
again and again in the future.  This verification work, therefore, has been
time well spent.  You can read more about virtual packet FIFOs, what they are
and how they work, in &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;this article&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;As of writing this, my
&lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual Packet FIFO&lt;/a&gt;.
work isn’t quite done.  There’s still a bit of a signaling issue, and the
formal proof of the memory reader portion isn’t passing.  However, the
component is working in hardware so this is something I’ll just have to
come back to as I have the opportunity.&lt;/p&gt;

    &lt;p&gt;Once completed, the only real upgrade potential remaining might be to
convert these virutal FIFOs to AXI.  Getting &lt;a href=&quot;/blog/2020/06/16/axiaddr-limits.html&quot;&gt;AXI
bursting&lt;/a&gt; right
won’t be easy, but it would certainly add value to my &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;AXI
library&lt;/a&gt; to have such a component within
it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;Width converter&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;AXIN width converter&lt;/a&gt;
will likely be reused.  It should be generic enough
to convert &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN streams&lt;/a&gt;
from any power of two byte width to any other.  That
means it will likely be reused on my next network project again as well.
It’s just necessary network infrastructure, so that’s how it will be used
and reused.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktgate.v&quot;&gt;Packet Gate&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;This component buffers either a whole packet, or fills its buffer with a
full packet before releasing the packet downstream.  It’s really nothing more
than a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;network
FIFO&lt;/a&gt;
with some additional logic added.  Still, this one is
generic enough that it can be reused in other projects as necessary.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/dropshort.v&quot;&gt;Dropping short packets&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;I’ve now written multiple components that can/will drop short packets.
This new one, however, should be versatile enough to be able to be reused
across projects.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/crc_axin.v&quot;&gt;CRC checker&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;As with the short packet detector, my CRC checker should work nicely across
projects–even when the widths are different.  This will then form the
basis for future network CRC projects.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 18. The AXIN broadcaster and AXIN arbiter work together&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/bcastarb.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinbroadcast.v&quot;&gt;AXIN Broadcaster&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinbroadcast.v&quot;&gt;AXIN broadcasting component&lt;/a&gt;
is only slightly modified from my &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axisbroadcast.v&quot;&gt;AXI stream
broadcaster&lt;/a&gt;.  It’s a simple component: an
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN stream&lt;/a&gt;
comes in, specifying one (or more) destinations that this &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN
stream&lt;/a&gt; should be
broadcast to.  The broadcaster then sends a beat to each
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN stream&lt;/a&gt;
and, as beats are accepted from all outgoing streams, sends more beats.&lt;/p&gt;

    &lt;p&gt;Or, rather, that was the initial design.&lt;/p&gt;

    &lt;p&gt;As it turns out, this approach had a serious design flaw in it contributing
to an honest to goodness, bona-fide
&lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlock&lt;/a&gt;.  As a result, both this
component, and the corresponding arbiter that follows it, needed fixing.&lt;/p&gt;

    &lt;p&gt;The new/updated algorithm includes two non-&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN&lt;/a&gt; signals:
CHREQ (channel request, from the master) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALLOC&lt;/code&gt; (channel allocated,
returned from the slave).  When “broadcasting” to a single port, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHREQ&lt;/code&gt;
will equal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VALID&lt;/code&gt;.  When broadcasting to multiple ports, it will first set
this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHREQ&lt;/code&gt; signal to indicate each of the downstream ports it is attempting
to broadcast to.  This will be done before setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VALID&lt;/code&gt; to forward any
data downstream.  The downstream ports, on seeing a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHREQ&lt;/code&gt; signal, will
raise the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALLOC&lt;/code&gt; (allocated channel) return signal if they aren’t busy.
The design then waits for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALLOC&lt;/code&gt; to match &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHREQ&lt;/code&gt;.  Once the two match, the
packet will be forwarded.  If, however, after 64 clock cycles, enough
channels haven’t been allocated to match the channel requests, then we may
have detected a &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlock&lt;/a&gt;.  In this
case, all requests will be dropped for a pseudorandom time period before
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHREQ&lt;/code&gt; will be raised to try again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinarbiter.v&quot;&gt;AXIN Arbiter&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;As shown in Fig. 18 above, the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinarbiter.v&quot;&gt;AXIN
arbiter&lt;/a&gt;
is the other side of the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinbroadcast.v&quot;&gt;AXIN broadcaster&lt;/a&gt;.
Whereas the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinbroadcast.v&quot;&gt;AXIN
broadcaster&lt;/a&gt;
takes a single &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN
stream&lt;/a&gt; input and
(potentially) forwards it to multiple output streams, the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinarbiter.v&quot;&gt;arbiter&lt;/a&gt;
takes multiple
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN&lt;/a&gt; input streams
and selects from among them to source a single output stream.&lt;/p&gt;

    &lt;p&gt;As with the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinbroadcast.v&quot;&gt;broadcaster&lt;/a&gt;,
the original design was quite simple: select from among many packet sources
based upon the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VALID&lt;/code&gt; signal, and then hold on to that selection until
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VALID &amp;amp;&amp;amp; READY &amp;amp;&amp;amp; LAST&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlock&lt;/a&gt;
occurred when at least two simultaneous attempts were made to broadcast
packets to two (or more) separate destinations, as shown in FIG:.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 19. Deadlock!&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/deadlock.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If one destination arbitrated to allow the first source to transmit but the
  second destination chose to allow the second source, then the whole system
  would lock up and fail.&lt;/p&gt;

&lt;p&gt;Now, the
  &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinarbiter.v&quot;&gt;arbiter&lt;/a&gt;
  selects its incoming signal based upon &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHREQ&lt;/code&gt;, and then
  sets the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALLOC&lt;/code&gt; return signal once arbitration has been granted to let
  the source know it has arbitration.  Arbitration is then lost once &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CHREQ&lt;/code&gt;
  is dropped–independent of whether a packet has (or has not) completed.
  In this way, a failed arbitration (i.e. detected
  &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlock&lt;/a&gt;)
  can be dropped and try again before any packet information gets lost.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;AXIN CDC&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;As long as there are multiple clocks in a design, there will be a need for
&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;crossing clock domains&lt;/a&gt;.
This is uniquely true when there’s a difference a data input clock, data
output, and memory clock domains.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/2017/10/20/cdc.html&quot;&gt;Crossing clock domains&lt;/a&gt;
with the &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;AXIN protocol&lt;/a&gt;
isn’t as pretty as when using the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;network
FIFO&lt;/a&gt;.
Indeed, there’s no easy way to ABORT and free the FIFO resources of a packet
that’s been only partially accepted by an &lt;a href=&quot;/blog/2018/07/06/afifo.html&quot;&gt;asynchronous
FIFO&lt;/a&gt;.
Instead, the ABORT signal is converted into a data wire and simply forwarded
as normal through a &lt;a href=&quot;/blog/2018/07/06/afifo.html&quot;&gt;standard asynchronous
FIFO&lt;/a&gt;.
It’s a simple enough approach, but it does nothing to free up
FIFO resources on an ABORTed packet.  However, freeing up FIFO resources
can still be (mostly) accomplished by placing a small
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;AXIN CDC&lt;/a&gt;
(i.e. an &lt;a href=&quot;/blog/2018/07/06/afifo.html&quot;&gt;asynchronous
FIFO&lt;/a&gt;)
back to back with the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;standard network
FIFO&lt;/a&gt;.
discussed above.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/wbmarbiter.v&quot;&gt;WBMArbiter (Wishbone master arbiter)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;I mentioned this one in the last section.  Although it’s not unique to
networking, I may yet use this component again.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 20. Gearboxes can (and should) be formally verified&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/frmlgearbox.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;There is another item worth mentioning in this list, and those are the two
gearboxes.
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66brxgears.v&quot;&gt;[1]&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p66btxgears.v&quot;&gt;[2]&lt;/a&gt;.
I’m not listing these with the reusable components above, simply
because I’m not likely to use these particular gearboxes outside of a 64/66b
encoding system, so they aren’t really all that generic.  However, the
lessons learned from building them, together with the methodology for
formally verifying them, is likely something I’ll remember long into the
future when building gearboxes of other ratios.&lt;/p&gt;

&lt;h2 id=&quot;lessons-learned&quot;&gt;Lessons Learned&lt;/h2&gt;

&lt;p&gt;Perhaps the biggest lesson (re)learned during this design is that you need
to plan for debugging from the beginning.  This includes some of the following
lessons:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 21. For debugging purposes, count all ABORTs&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/abortctr.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Anytime a component generates an ABORT signal, that should be logged and
counted somewhere.  This is different from components propagating an ABORT
signal.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Testing requires that the router have static paths, at least until the
rest of the network interface works.&lt;/p&gt;

    &lt;p&gt;Port forwarding can also permit the CPU to inspect any packet crossing
through the interface.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bit-order in the ethernet specification is quite confusing.&lt;/p&gt;

    &lt;p&gt;I had to build and then rebuild the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/p642pkt.v&quot;&gt;66b to AXIN protocol
component&lt;/a&gt;
and its &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pkt2p64b.v&quot;&gt;transmit
counterpart&lt;/a&gt;
many times over during this project–mostly because of misunderstandings
of the Ethernet specification.  This included confusions over how bytes
are numbered within the 66b message word, the size of control bytes (7b) in
66b message words vs the size of data bytes (8b), whether the synchronization
pattern was supposed to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10&lt;/code&gt; for control words or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;01&lt;/code&gt; and so forth.
As a result, even though I was able to get the design working with GTX
transceivers in a 10Gb Ethernet test bench early on, I would later discover
more than once that the “working” test bench and design didn’t match
10Gb Ethernet hardware components on the market.&lt;/p&gt;

    &lt;p&gt;For example, the Ethernet specification indicates that the start of packet
indication must include bits, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;... 10101010 10101010&lt;/code&gt; followed by the octet
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10101011&lt;/code&gt;.  What it doesn’t make clear is that these bits need to be read
right to left.  This meant that the final three bytes of any start of
packet delimeter needed to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x55&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x55&lt;/code&gt;, followed by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xd5&lt;/code&gt; rather
than (as I first read the specification) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xaa&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xaa&lt;/code&gt;, followed by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xab&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The routing algorithm above doesn’t work well in loopback situations.&lt;/p&gt;

    &lt;p&gt;As I mentioned above, this particular problem turned into a debugging
nightmare.  Even now that I have a working algorithm, I’m not yet convinced
it does a good job handling this reality.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Look out for &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlocks&lt;/a&gt;!&lt;/p&gt;

    &lt;p&gt;Others who have dealt with
&lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlocks&lt;/a&gt; before have told me
that 1) &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlocks&lt;/a&gt; are system
architecture level problems, and 2) that they are easy enough to spot
after you’ve had enough experience with them.  In my case, I studied them
back in my college days, but had never seen a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlocks&lt;/a&gt; in real life before.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;caption&gt;Fig 22. Deadlocks are very real&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eth10g/bigfoot.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;Because the routing tables were written entirely in RTL using Flip-Flops,
and not using any block RAM, the CPU has no ability to read the tables back
out to verify their functionality.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finally, I’ve really enjoyed &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;this network (AXIN)
protocol&lt;/a&gt;.  It’s met my
needs now on multiple projects.  Better yet, because I’ve made this protocol
common across these projects, I can now re-use components between them.&lt;/p&gt;

&lt;p&gt;Perhaps that should be a final lesson learned as well: well designed internal
protocols facilitate design reuse.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So the big question I imagine on everybody’s mind at this point is, now that
you have a 10Gb Ethernet switch, how well does it work?&lt;/p&gt;

&lt;p&gt;Sadly, my answer to that (at present) is … I don’t know.&lt;/p&gt;

&lt;p&gt;I’ve tested the design using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scp&lt;/code&gt; to move files from one PC to another,
only to discover &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scp&lt;/code&gt; has internal speed limitations within it.  This leaves
me and the project needing better test cases.&lt;/p&gt;

&lt;p&gt;How about the hardware?&lt;/p&gt;

&lt;p&gt;As with any PCB design, the original PCB design for this project has had some
issues.  The work presented above has been done with the &lt;em&gt;original&lt;/em&gt;, first/draft
board design.  Part of my task has been to build enough RTL design to identify
these issues.  As of the this date, I’ve now worked over all of the hardware
design save the SATA port.  Yes, there are some issues that will need to be
corrected in the next revision of the board.  These issues, however, weren’t
significant enough that they kept us from verifying the components on the board.
As a result, I can now say with certainty that the 10GbE components of the
board work–although, IIRC, we were going to change the polarity of some of
the LED controls associated with it.  Still, its enough to say it works.&lt;/p&gt;

&lt;p&gt;The flash, SD card, and eMMC interfaces?  Those will need some redesign work,
and so they should be fixed on the next revision of the board.  As for the
10GbE interfaces?  Those work.&lt;/p&gt;

&lt;p&gt;If you are interested in one of these boards to work with, then please
contact &lt;a href=&quot;mailto:edmund@symbioticeda.com&quot;&gt;Edmund, at Symbiotic EDA&lt;/a&gt;, for details.&lt;/p&gt;

&lt;p&gt;If the Lord wills, there are several components of this design that might
be fun to blog about.  These include the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/bench/formal/faxin_slave.v&quot;&gt;formal property
set&lt;/a&gt;
that I’ve been using to verify AXIN components, the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netskid.v&quot;&gt;AXIN
Skidbuffer&lt;/a&gt;
or even the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;NetFIFO&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For now, I’ll just note that the design is &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;posted on
github&lt;/a&gt;, licensed under Apache 2.0, and
I will invite others to examine it and make comments on it.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;This also cometh from the LORD of Hosts, which is wonderful in counsel, and excellent in working.  (Is 28:29)&lt;/em&gt;</description>
        <pubDate>Sat, 25 Nov 2023 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/blog/2023/11/25/eth10g.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2023/11/25/eth10g.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>SDIO RX: Bugs found w/ Formal methods</title>
        <description>&lt;p&gt;This post is the second post regarding my new &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO/eMMC
controller&lt;/a&gt;.  The SDIO protocol is commonly
used on SD cards, and the eMMC protocol for eMMC chips.  The two protocols
are so similar that, when using
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;this controller&lt;/a&gt;, they will differ in
software only.  Today’s bottom line is that, although &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;the
controller&lt;/a&gt; is still quite new and only
barely silicon proven, this week I had the chance to formally verify the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receive portion&lt;/a&gt;
of the controller and so I thought I might write about what took place.
My goal will be to answer the question of whether this extra step of doing
formal verification was worth it or not.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;This SDIO controller&lt;/a&gt; is being written as
part of the &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;Klusterlab project&lt;/a&gt;.  I’ve been
calling &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;this same project the ETH10G
project&lt;/a&gt;, because at its core it is a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/routecore.v&quot;&gt;10Gb
Ethernet switch&lt;/a&gt;.
The project team, however, has named it KlusterLab because of all of the
various hardware and IO interfaces that have been integrated into it.
This has given me plenty of opportunities for testing hardware components, and
for writing blog articles about them.  As a result, I’ve now written about the
development of this project a couple times.  First, I wrote about &lt;a href=&quot;/blog/2023/04/08/vpktfifo.html&quot;&gt;virtual
packet FIFOs&lt;/a&gt;,
then about &lt;a href=&quot;/blog/2023/06/28/sdiopkt.html&quot;&gt;using Verilog tasks to script the SDIO
transmitter&lt;/a&gt;, and now today
I want to discuss formally verifying the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;SDIO
receiver&lt;/a&gt;
that will soon be tested on this board.  I’ll even go so far as to discuss
the remaining bugs that were found during hardware verification.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. SDIO progress&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdrxframe/progress.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You might argue this &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;SDIO
receiver&lt;/a&gt;
had already been verified.  Indeed, you might argue that the &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;entire
controller&lt;/a&gt; had been verified.  Let’s walk
through the various development steps.  At this point in its development, the
entire &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO controller&lt;/a&gt; has been written.  It
passes a &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator&quot;&gt;Verilator&lt;/a&gt;
lint check.  I’ve also generated simulation test scripts to verify the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v&quot;&gt;divided clock
generator&lt;/a&gt; and the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdtxframe.v&quot;&gt;transmitter&lt;/a&gt; in
isolation.  A final &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/verilog/tb_sdio.v&quot;&gt;simulation
environment&lt;/a&gt;
drives the entire controller through its paces: starting up the
SDIO controller in a simulated environment all the way from sending the
CMD0 (GO IDLE) all the way through reading and writing a page of data
(CMD24 and CMD17).  It passes these simulation steps nicely.  I’ve integrated
the controller into the &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;larger design&lt;/a&gt;, and
it passes both Vivado synthesis and timing.  Indeed, it’s been implemented in
hardware.  Most recently, it failed in hardware testing for PCB reasons, not
logic reasons–but that still counts as a &lt;em&gt;failure&lt;/em&gt; in hardware, so I’ve got
more work to do before I can call this silicon proven.  At the end of this
article, I’ll share the results of my next round silicon testing–once I
finished verifying the receiver.&lt;/p&gt;

&lt;p&gt;The question before us today is whether or not I’ve skipped any necessary
tests.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 2. The rule of gold&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vlog-wait/rule-of-gold.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One might argue at this point that this is all the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;controller&lt;/a&gt; needs to do in practice, and so
I should stop here.  In the past, I might’ve done so.  However, the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;controller&lt;/a&gt; can do a lot more than I’ve
tested so far.  It’s designed to operate with either 1 data bit, 4 data bits
(SDIO/eMMC), or 8 data bits (eMMC only), in either SDR and DDR modes, and
both with (eMMC only) and without (SDIO/eMMC) a data strobe.  The &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v&quot;&gt;clock
divider&lt;/a&gt; is designed
to allow the IOs to be driven at less than one
edge per clock cycle, two edges per clock cycle, or even four edges per
clock cycle.  That’s a lot of features, and due to the way the current board
is designed, I won’t be able to test all of them.  (Specifically, the PCB
design connected the clock line to the CCLK pin, and it doesn’t allow a
card voltage change from 3.3V to 1.8V, so I can’t use either
&lt;a href=&quot;/blog/2020/08/22/oddr.html&quot;&gt;ODDR&lt;/a&gt;
or OSERDES controllers to drive it any faster than than half the clock rate.)&lt;/p&gt;

&lt;p&gt;Here’s my problem with stopping here: I want to place this &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO/eMMC
controller&lt;/a&gt;
in my “library” of working components, and I’ve had too many experiences in the
past of pulling something out of my library only to end up debugging it when
I place it onto hardware.  In practice, it’s worse than that–because by the
time I pull it out of my library, I typically won’t remember that I only tested
&lt;em&gt;some&lt;/em&gt; of the modes the IP supports, or whether or not it’s been updated since
I last used it on hardware.  I just remember that it has “worked” in the past,
so I consider it a piece of “working” IP from my library.  What that means is
that, when things don’t work in hardware, I won’t be suspecting this piece of
IP.  Hence, I’ll find myself looking all over some large SOC design for a bug,
instrumenting everything and its brother, before I finally realize that a
“working” IP component from my library had been left with a bug in it.&lt;/p&gt;

&lt;p&gt;This is unsatisfactory.&lt;/p&gt;

&lt;p&gt;Debugging a large design is a painful process.  It takes a lot of time–often
time that’s been allocated for other purposes–you know, like the new
capabilities the design is supposed to have–capabilities the sponsor is paying
for.  It delays product delivery with unscheduled debugging.  Frankly, I don’t
like spending my time on unplanned projects like that.  As a result, I want a
solid assurance that every IP component in my “library” &lt;em&gt;works&lt;/em&gt; before I add
it to a larger design.  It’s not enough that it worked in silicon the last
time it was used.  I want to know if any updates made since that time still
work.  I want to know to all the features work, to include features that
haven’t yet been tested in silicon.&lt;/p&gt;

&lt;p&gt;This requires a more rigorous approach to IP verification than just
demonstrating the IP once in silicon.&lt;/p&gt;

&lt;p&gt;For me, that more vigorous approach involves formally verifying each leaf
component, and then simulating the library component as a whole.  When it
comes to &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;this SDIO/eMMC controller&lt;/a&gt;,
I have formal proofs of &lt;em&gt;most&lt;/em&gt; of the major components.  I have a proof of the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v&quot;&gt;clock generator&lt;/a&gt;,
the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v&quot;&gt;Wishbone
controller&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v&quot;&gt;command wire handler&lt;/a&gt;
and the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdtxframe.v&quot;&gt;transmitter&lt;/a&gt;.
What I didn’t have, which we’ll be discussing today, is a formal proof of the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receiver&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Yes, I now have a formal proof of the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;SDIO/eMMC
receiver&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, before we get started, let me ask: how many bugs do you think I found
going through this process?&lt;/p&gt;

&lt;h2 id=&quot;fitting-the-receiver-into-the-design&quot;&gt;Fitting the Receiver into the Design&lt;/h2&gt;

&lt;p&gt;Let me take a moment, though, to introduce you to &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;this
subcomponent&lt;/a&gt; and
discuss how it is supposed to work, prior to discussing the problems it had.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. The SDIO/eMMC receive component&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdrxframe/pinlist.svg&quot; width=&quot;400&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;SDIO/eMMC receive
framer&lt;/a&gt;, as I
call it, is responsible for receiving a block of data, checking the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;(s), and writing
that block of data to an external &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics&quot;&gt;ping-pong
buffer&lt;/a&gt;.
A separate &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v&quot;&gt;Wishbone
component&lt;/a&gt;
acts as its controller in two ways.  First, it tells
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;the receiver&lt;/a&gt;
what IO mode is in operation.  The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_cfg_width&lt;/code&gt; setting tells us if we are
using 1, 4 (SDIO/eMMC), or 8 (eMMC only) IO pins.  The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_cfg_ddr&lt;/code&gt; setting
controls whether or not we’ll need to check separate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s
for each clock edge.  Similarly, if we are using the data strobe pin, as
indicated by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_cfg_ds&lt;/code&gt;, then we’ll be accepting data via the asynchronous
data port from the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt;,
rather than the simpler synchronous port.&lt;/p&gt;

&lt;p&gt;When the user issues a CMD17 to read a block, the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v&quot;&gt;Wishbone
controller&lt;/a&gt; will
raise the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_en&lt;/code&gt; line to indicate a block of data is on the way.  It
will also set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_length&lt;/code&gt; to the length of the block to be expected.  The
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_crc_en&lt;/code&gt; pin also allows us to receive things that may, or may not–counter
to protocol–have &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s
attached.  Since the protocol requires
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s,
I may remove this (unused) configuration bit in the future.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;front end&lt;/a&gt;
provides two sets of inputs for us, of which we will pick and
choose only one.  The first set is the &lt;em&gt;synchronous&lt;/em&gt; path.  This is the path
used in all SDIO modes and most of the eMMC modes–the path that doesn’t
depend upon the data strobe return from the eMMC device.  The second path is
the &lt;em&gt;asynchronous&lt;/em&gt; path from the front end.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 4. The PHY supports three operating modes&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdrxframe/phymodes.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Both of these paths come to us from a &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;front end
component&lt;/a&gt; that
I’m going to call the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt;.  The
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt; can be
built in one of three ways, as shown in Fig. 4.  First, it can be built in
“standard” mode, where the IO buffers are driven directly from logic.  It can
also be built where the IO buffers are all driven via
&lt;a href=&quot;/blog/2020/08/22/oddr.html&quot;&gt;ODDR&lt;/a&gt; components, and the
returns come back via IDDR sampling.  Finally, there’s a front end mode which
will drive the IOs via 8:1 OSERDES elements, and read the results back via
a 1:8 ISERDES.  Which IO mode is used controls the maximum clock speed.
Likewise, only the SERDES IO mode supports the data strobe.&lt;/p&gt;

&lt;p&gt;All data messages in the SDIO/eMMC protocol start with a zero start bit.  This
is used as a synchronization point.  In our case one of the key features of
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;the front end&lt;/a&gt;
is that it strips off the start bit.  It also samples our data for us–either
by sampling the outgoing clock edges to discover a sample point, or by
sampling data when the return data strobe is present (eMMC only).&lt;/p&gt;

&lt;p&gt;A second key feature is specific to the synchronous path.  In this case, the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt;
measures the outgoing clock signal (before it gets to the pins), and sets a
sample time some programmable delayed time afterwards.  In this way, for high
speed IO, we allow ourselves to sample the incoming data at a programmable
fraction of a clock cycle later than the outgoing clock itself, to allow
for any clock propagation time from our controller, through the PCB to the
SDIO/eMMC chip, and then coming back from the SDIO/eMMC chip through the PCB to
our FPGA.&lt;/p&gt;

&lt;p&gt;All this is to say that by the time we get any data, all the hard work of
discovering when to sample the various IO bits has been taken care of for us.&lt;/p&gt;

&lt;p&gt;On the synchronous interface, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb&lt;/code&gt; signal will indicate whether we
have new data available.  It will either indicate no sampling clock edges
(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb==0&lt;/code&gt;), one edge (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb==2'b10&lt;/code&gt;), or two edges
(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb==2'b11&lt;/code&gt;) of data.  If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb[1]&lt;/code&gt; is true, then either 1, 4, or
8 bits of data will be available on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_data[15:8]&lt;/code&gt; ports.  If
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb[0]&lt;/code&gt; is also true, then 1, 4, or 8 bits of data will also be present
in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_data[7:0]&lt;/code&gt; inputs.&lt;/p&gt;

&lt;p&gt;The asynchronous interface is even simpler to use.  If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_ASYNC_VALID&lt;/code&gt; is ever
true, then we’ll have 32-bits of incoming data available to us.  There will
never be less.  This is due in part due to how the front end IOs are set up,
and also in part due to the nature of how the data strobe line is used.
Specifically, it is never used in one or four bit modes–always 8 bit.
Likewise, the data strobe is only ever used in
&lt;a href=&quot;/blog/2020/08/22/oddr.html&quot;&gt;DDR&lt;/a&gt; mode, when data is
transmitted on both clock edges.&lt;/p&gt;

&lt;p&gt;That describes what comes into this &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receive
component&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are two interfaces on the output.  The first is the control interface.
For every request that is made, that is for every time &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_en&lt;/code&gt; is enabled,
the controller will process a received packet.  Once the packet is complete,
this receiver will raise the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o_done&lt;/code&gt; flag.  At that time, it will also
raise the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o_err&lt;/code&gt; flag if there were any errors associated with the packet.
Such errors could either be 1) a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
mismatch, or 2) a watchdog timeout error.&lt;/p&gt;

&lt;p&gt;Let me pause here for a moment to point out, whenever you use a return
data strobe for sampling data coming back to a chip, you &lt;em&gt;always&lt;/em&gt; need to
add a watchdog timer.  This is to keep your controller from hanging in
the event you make a mistake and either 1) don’t properly wire up the
data strobe, or 2) make a mistake in your protocol handling so that the
downstream chip doesn’t return the number of data strobes you are expecting.
In our case, the watchdog timer will also generate a timeout if the start
bit isn’t received within its timeout window–something that will come back
to haunt us when we get to hardware testing.&lt;/p&gt;

&lt;p&gt;The last interface, coming out of this controller, is the memory interface.
This is designed to feed one of two &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics&quot;&gt;ping-pong
buffers&lt;/a&gt;.
My vision is that these &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics&quot;&gt;ping-pong
buffers&lt;/a&gt;
will be as wide as the bus, so they can be used in high speed DMA operations on
wider buses if necessary–although to date I’ve only tried them at 32-bits
each.  (Yes, the &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;ETH10G
project&lt;/a&gt; uses a 512-bus, but I’m initially
only going to connect this to the 32-bit control bus portion of that design.)&lt;/p&gt;

&lt;p&gt;The memory interface has valid, strobe, and data lines.  If the valid line
is high, then the strobe lines will tell you which bytes within the data lines
to write.&lt;/p&gt;

&lt;p&gt;If all goes well, once &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_en&lt;/code&gt; is set, memory will flow from the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt;,
get collected into bytes and/or words, and then sent out the memory interface.
Once complete, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o_done&lt;/code&gt; signal will be raised and the controller will
then drop the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_en&lt;/code&gt; line, and only raise it following another command from
the user–or perhaps the to-be written DMA.&lt;/p&gt;

&lt;p&gt;At least, that’s how this portion of the design is &lt;em&gt;supposed&lt;/em&gt; to work.&lt;/p&gt;

&lt;h2 id=&quot;outlining-the-formal-proof&quot;&gt;Outlining the Formal Proof&lt;/h2&gt;

&lt;p&gt;One of the reasons why &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;this
component&lt;/a&gt;
took so long to verify was because I had a sort of writer’s block when I first
looked at it.  I didn’t really know where to start.  &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;The
design&lt;/a&gt;,
I said to myself, was so simple–what could possibly be done to verify it?&lt;/p&gt;

&lt;p&gt;Yeah.&lt;/p&gt;

&lt;p&gt;As a result, &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;this
component&lt;/a&gt;
sat on the shelf for a week or two while I worked on other things.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. When do I get to the real stuff?&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdrxframe/realstuff.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;/formal/2020/06/12/four-keys.html&quot;&gt;minimum requirement&lt;/a&gt;
of any formal proof is something I call “The Contract.” The contract describes
how the IP is supposed to operate if everything is working.  In this case, the
contract is fairly easy to express in words: given an arbitrary byte, arriving
at an arbitrary position in the received data stream, formally &lt;em&gt;prove&lt;/em&gt; that
this arbitrary byte gets processed properly and sent to the output.&lt;/p&gt;

&lt;p&gt;As with most things in life, however, you need some sort of structure to hang
all of this verification logic off of.  You can think of it like a skeleton.
Just like a skeleton holds all your joints, ligaments, and muscles in place, a
good formal verification structure can be used to hold all of the formal
verification logic in place.&lt;/p&gt;

&lt;p&gt;I chose two pieces for my skeleton.  The first was a bit counter.  Starting
from the beginning of the operation, I would count the number of bits
arriving on our interface.  If we were in one bit mode, that would be the
number of ones arriving on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb&lt;/code&gt;.  For the four or eight bit interface,
it would be four or eight times that much.  It simply counts how many bits of
valid data we’ve received.  The second key component was a memory counter.
This memory counter would count the number of bytes written to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics&quot;&gt;ping-pong
buffer&lt;/a&gt;
control outputs.&lt;/p&gt;

&lt;p&gt;I then needed some assertions to tie these two together.&lt;/p&gt;

&lt;p&gt;Those two counters alone were enough to find the first several bugs.&lt;/p&gt;

&lt;p&gt;They were also enough to allow me to build and express the contract.&lt;/p&gt;

&lt;p&gt;A third component of the skeleton that I added at a later time was a 1-bit
state machine.  This one bit state machine would become high upon a request
for operation–one cycle after &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_en&lt;/code&gt; goes high, and then it would go low
once we completed our task.  I needed this to prove that the design wouldn’t
hang–especially since I was seeing it hang at the time.&lt;/p&gt;

&lt;p&gt;At this point, we can come back to our original question, and ask: how
many bugs did I find?&lt;/p&gt;

&lt;h2 id=&quot;bugs-discovered-via-formal-verification&quot;&gt;Bugs discovered via formal verification&lt;/h2&gt;

&lt;p&gt;Let’s count the bugs I found.  Since I’m using &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;,
it’s not all that hard.  I’m just doing a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git diff&lt;/code&gt;, or rather
&lt;a href=&quot;https://meldmerge.org/?utm_source=Logiciels.Pro&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;meld&lt;/code&gt;&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sdrxframe&lt;/code&gt;&lt;/a&gt; to
be more specific, and counting all of the differences between the commit before
verifying the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receiver&lt;/a&gt; and
the changes after now that the verification now passes.  Let’s walk through
the differences, shall we?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first difference doesn’t really count.  I discovered, via simulation
testing, that I had stripped off the start bit in two locations: first in the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt;,
and second in the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receive
framer&lt;/a&gt;.
The result was both lost data and a failing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;, since the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receive framer&lt;/a&gt;
would remove one or more clock cycles of data from the beginning of any
packet, while looking for that start bit.  This change just hadn’t made
it into my baseline commit.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next big change is sort of borderline as to whether it should count
or not.  Since I had let the design sit for a couple weeks before coming
back to it to verify it, I came at it with fresh eyes and noticed a big
bug while simply desk checking: I never implemented the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s for the
negative clock edge.&lt;/p&gt;

    &lt;p&gt;When using the SDIO/eMMC protocol, each data wire used in transmission
gets its own &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
at the end of the data block.  These
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s are each
16-bits in length, and they protect the entire data block.  That’s in single
data rate (SDR) mode.  When operating in dual data rate (DDR) mode and
sending data on each edge of the clock, there’s one
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; for each data
wire on the positive edge of the clock, and a separate
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; for each data
wire protecting the data sent on the negative edge of the clock.  Both
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s
are 16-bits, and they are interleaved–so the positive edge
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
will alternate transmission with the negative edge
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
at the end of the packet.&lt;/p&gt;

    &lt;p&gt;When building the receive controller, however, I had only implemented the
positive edge
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s.&lt;/p&gt;

    &lt;p&gt;Oops.&lt;/p&gt;

    &lt;p&gt;I’m not sure I’d call that a formal verification bug, though, since the
tools didn’t really find it.  I found it via a desk check.  That is, I found
it via a desk check that I was only doing because I was adding formal
properties to the design in order to verify it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next bug was associated with the logic for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o_done&lt;/code&gt;.  This bug
didn’t really show up as an assertion failure, rather it showed up as I
was trying to formally describe how the logic was supposed to operate.&lt;/p&gt;

    &lt;p&gt;The first problem here was that I had &lt;em&gt;two&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done&lt;/code&gt; signals.  One was used
internally, and the other was my external signal.  Further, I couldn’t
really make out (from my own design even!) what the real difference was
between these two signals.  How were they supposed to relate?  Were they
supposed to be identical?&lt;/p&gt;

    &lt;p&gt;Let me back up and explain this a bit more.  I want to formally verify
the entire operation of the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receive
framer&lt;/a&gt;.
That means I want to verify,
formally, that it can properly receive 512 bytes of data in all modes,
to include the mode where it only receives one bit at a time for a minimum
total of 4096 clock cycles.  This is a minimum, however, because when I
operate the design at 100kHz (the slowest potential clock speed), there
will be
1,000 clock cycles between every bit.  Hence, a full operation will
take more than 4M clock cycles.  Most formal proofs will die on anything
over about 20 clock cycles, with the longest proof I have running at about
350 clock cycles.  There would be no way I’d verify 4M clock cycles of
operation, therefore, without using
&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;Induction&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;Induction&lt;/a&gt;,
however, requires assertions to both verify and then guarantee
all of the relationships between registers.  That means I need assertions
to describe the differences between these two done registers.&lt;/p&gt;

    &lt;p&gt;Yeah, the second &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done&lt;/code&gt; register was quickly dropped when I couldn’t decide
what it’s real purpose was.&lt;/p&gt;

    &lt;p&gt;Even that wasn’t enough, since there were several registers that needed
to act on the clock prior to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o_done&lt;/code&gt;.  Therefore, I ended up creating
a signal I called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w_done&lt;/code&gt; to indicate that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;o_done&lt;/code&gt; was about to be
set, and everything remaining should clean itself up.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next bug was that
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; errors (not
tested by my simulation), wouldn’t show up coincident with the done signal.
Yes, my &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done&lt;/code&gt; logic was really messed up.  At first I was declaring the
design &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done&lt;/code&gt; once all the data (not
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s)
had been received.  Then I tried setting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done&lt;/code&gt; once all the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s
had been received, but not allowing for the last bit(s) to impact the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s,
nor for a test of whether or not the last
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
successfully received its data.&lt;/p&gt;

    &lt;p&gt;In many ways this didn’t surprise me: I rarely test fault conditions in
simulation.  I should.  Indeed, I need to make it a habit of doing so, but
my simulation setup for this design was still somewhat new, so I hadn’t yet
verified failed &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
handling.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At full speed, data would get written to the wrong memory address.&lt;/p&gt;

    &lt;p&gt;Remember how I said that the skeleton of the proof would help?  Well, it
turns out my address counting was messed up.  I would calculate the
next memory address on the cycle I wrote to memory.  That wasn’t a problem.
However, I’d then use that memory address to shift the next memory strobe
and data into position, and so my logic required a dead cycle between
memory writes in order to be successful.  That would be fine when operating
on four data bits (SDIO/eMMC) in SDR mode, when not using the OSERDES (i.e.
when using the CCLK pin).  In other words, it would work fine
the way both my simulation and my hardware were setup.  However, this
approach would fail quickly when/if I ever transitioned to one of the high
speed modes this IP was supposed to support.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdrxframe/pride-shame.svg&quot; width=&quot;240&quot; alt=&quot;When pride cometh, then cometh shame: but with the lowly is wisdom. (Prov 11:2)&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Remember how I commented earlier on my frustrations when taking a design
   out of my library to add to a larger SOC-based design?  This would’ve lead
   directly to one of those problems.  Had I not verified this IP, I would’ve
   run it on hardware and been really proud of it.  I’d put it, in my pride,
   into my library and declare it to be “working”, only to come back later,
   configure it for a (supposed to be supported) high frequency mode, only
   to discover that mode didn’t work.&lt;/p&gt;

&lt;p&gt;This is why I like formal methods.&lt;/p&gt;

&lt;ol start=&quot;6&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;I also came across a bug whereby the receiver might ingest one too many
clock cycles.  What happens, for example, if you want to receive a five
byte packet, the data width is set to 8-bits, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb==2'b11&lt;/code&gt; on
every clock cycle?  The answer is that, on the last clock cycle, the
data associated with the second clock edge would need to be discarded.&lt;/p&gt;

    &lt;p&gt;In this case, I needed to generate a new signal, one I called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last_strb&lt;/code&gt;,
to keep the IP from ingesting more than one clock edge with the last data
set.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next bug was associated with disabling
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
checking.  When I built &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;this
receiver&lt;/a&gt;,
I built it with a mode for receiving something that doesn’t have a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;.  This was to
support reading particular registers that weren’t
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; protected.
In hindsight, however, I’m not really sure I need this mode–since 1) all
of those registers transfer their data over the CMD wire, and 2) even those
unprotected registers still have
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s–they
just can’t be trusted.  Regardless of whether it is needed or not, however,
the formal tool decided to test it and found it broken.&lt;/p&gt;

    &lt;p&gt;Of course, my simulation didn’t check this mode.  There was no reason to.
All data transactions require
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s.  However,
design lock ups are bad, and that was what the formal tool found.  If ever
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
checking was disabled, the design might accept its packet (but not the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;)
and then hang waiting on the remaining
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
that would never come.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last bug was more serious.  It involved those cases where I might
receive data on two separate clock edges within a single clock cycle.
This might be the case when using either the
&lt;a href=&quot;/blog/2020/08/22/oddr.html&quot;&gt;ODDR&lt;/a&gt; component in DDR
mode, or the SERDES component in a multiple IO clock per system clock mode.
The bug would only be triggered if I receive data on one clock edge at
first (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb==2'b10&lt;/code&gt;), and then ever after received data on both
clock edges (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb==2'b11&lt;/code&gt;).  Not only that, it’s only triggered
in 8-bit mode.&lt;/p&gt;

    &lt;p&gt;Here’s how the bug works.  When the first 8-bits of data arrive,
those bits get written to bits [31:24] of the memory bus–assuming it’s
32-bits, which it is for these runs.  On all subsequent clock cycles,
16-bits arrive and get forwarded to the memory.  Hence you’d write to
bits [23:8] of memory on the second write, and then you’d want to write to
bits [7:0] of the current memory word and (oops) bits [31:24] of the
subsequent word.  This is called an &lt;em&gt;unaligned data access&lt;/em&gt;, and herein
lies the bug.  I didn’t account for writing unaligned data to memory.&lt;/p&gt;

    &lt;p&gt;Fixing this bug wasn’t hard, but it did require logic to handle the
unaligned memory write request.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One of the tricks I often use when formally verifying components is to assume
difficult things won’t happen.  It helps the proof along, and can often help
me get through the simpler logic.  Of course, difficult things &lt;em&gt;do&lt;/em&gt; happen in
real life, and so these assumptions can easily render a proof invalid.  For
this reason, I make sure to place all such assumptions in a specially marked
block at the end of the file–a block I like to call “Careless assumptions,”
because of the likelihood that they will void a proof.  Over time, as I get
the opportunity, I’ll slowly work off these “careless assumptions” until none
remain.&lt;/p&gt;

&lt;p&gt;In this case, my “Careless assumptions” section held two assumptions for a while
that I needed to come back to.  The first was that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i_rx_strb&lt;/code&gt; would only ever
be either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2'b11&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2'b10&lt;/code&gt;.  This allowed me to get the proof to pass first,
and then come back later to handle the unaligned memory requests.  My second
assumption is that the watchdog timeout would never fire.  In both cases, I
had to come back later and work through removing these assumptions before the
proof could really be declared complete.&lt;/p&gt;

&lt;p&gt;Today, I can now say with confidence that this design and proof no longer
contains any “careless” assumptions.&lt;/p&gt;

&lt;h2 id=&quot;hardware-bringup&quot;&gt;Hardware bringup&lt;/h2&gt;

&lt;p&gt;Yes, but … &lt;em&gt;does it work?&lt;/em&gt;  Alternatively, I might ask, did all that formal
verification work actually make a dent when it came to how long it took to
bringup &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;the controller&lt;/a&gt; in silicon to talk
to its first device?&lt;/p&gt;

&lt;p&gt;To answer that question, let’s go over the bugs found during hardware bringup.&lt;/p&gt;

&lt;p&gt;First, as background, the design did need a hardware change before starting.
The FPGA was driving the SD Card at 1.8Volts via a TI TXB0108 voltage
translator to 3.3V, and the voltage translator couldn’t handle the open
drain signaling required during startup.&lt;/p&gt;

&lt;p&gt;Second, I was quite pleased to see the card respond to the very first
command I gave it, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEND_IF_COND&lt;/code&gt; command.  Not only did it respond, but
it also returned a valid response.  This helped to add momentum to the
subsequent testing, knowing that at least the interaction via the
command wire worked.&lt;/p&gt;

&lt;p&gt;Now let’s go over the bugs I found.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The next command in the bringup of an SD card, following the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEND_IF_COND&lt;/code&gt;
command, is to ask the card to send its Operating Conditions Register (OCR).
This is part of a voltage negotiation that takes place between &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;the
controller&lt;/a&gt; and the card.  It’s supposed
to be a &lt;em&gt;handshake&lt;/em&gt;.  &lt;strong&gt;The bug:&lt;/strong&gt; in my first software drafts, I never
told the card what voltages I could provide.  Hence, from the card’s
perspective, we had never come to an agreement on the required voltage
and so the card never booted up.&lt;/p&gt;

    &lt;p&gt;Reading through the specification helped here.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; This was a &lt;em&gt;software&lt;/em&gt; bug.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The next problem was that I couldn’t get the card to respond
to the next command, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL_SEND_CID&lt;/code&gt;.  This is where every card sharing the
bus sends its identification via an open-drain setup, and whoever sends a
‘0’ wins the bus for that bit and following.  It’s a part of the protocol
designed to allow multiple cards to share a bus–although I’ve never actually
seen this used in practice.  In this case, I just couldn’t get the card to
respond at &lt;em&gt;all&lt;/em&gt; to this request.  The card had responded fine to the
previous command, just not this one.&lt;/p&gt;

    &lt;p&gt;The problem here turned out to have nothing to do with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALL_SEND_CID&lt;/code&gt;
command at all–it was how I handled the response to the reading the
OCR.  Bit [31] of the OCR is listed in the specification as “Card power up
status bit (busy)”.  So, I figured that once the bit was clear, the card
was no longer busy.  &lt;strong&gt;The bug:&lt;/strong&gt; Re-reading the specification revealed I
had the sense wrong–the bit needed to become a one before moving on.
Because I wasn’t waiting, the card hadn’t finished powering up when I
gave it its next command, hence it wasn’t responding.&lt;/p&gt;

    &lt;p&gt;I found this bug via simulation, once I tried increasing the power up time
in simulation to the point where it would have an impact.  Then, when &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/verilog/tb_sdio.v&quot;&gt;the
simulation&lt;/a&gt;
didn’t match my software, I knew I was on to something.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; This was a second &lt;em&gt;software&lt;/em&gt; bug.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 6. Voodoo computing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdrxframe/voodoo.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;During this time I should point out I did a lot of return code debugging.
Specifically, &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v&quot;&gt;my command wire
processor&lt;/a&gt; got a
lot of scrubbing to make sure I was getting the right return code for
any error I encountered.  I’m not sure I really found anything here, but I
did change a bunch of stuff in the process.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; I’m not sure there was a bug here at all.  I think the
bottom line issue here was that I had forgotten, between when I wrote this
module and when I came back to it, exactly how the interface was supposed
to work.  So I ended up rewriting how errors should be reported, even though
they may have not been reported incorrectly in the first place.&lt;/p&gt;

    &lt;p&gt;Sadly, I also discovered that I had left a “Careless assumption” in my
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v&quot;&gt;command wire processor&lt;/a&gt;,
an assumption that kept the formal proof of this processor from ever
examining a timeout situation.  So, I had to pause here to remove this
last assumption–especially since I was getting timeout errors, and I
had no confidence that these errors were correct.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I then managed to get far enough to read several registers from the SD
card.  Two in particular, the Card Identification (CID) register and the
Card Specific Register (CSR) deserve some extra mention.  These are each
128’bit registers (including
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;).
.  They follow what would normally be an echo of the
8’b command, and end with a 7-bit
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; followed by a
stop bit for a total of 136 bits.  In testing, I could read these registers
just fine.  The bug the problem was that the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v&quot;&gt;command
wire processor&lt;/a&gt;
was indicating a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
error every time it read from these registers.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;The bug:&lt;/strong&gt; Digging further, I discovered I had calculated the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
over the 8’bit prefix to the 120’bit data register, not just the 120’bit
data bits.  In this case, both &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/verilog/mdl_sdio.v&quot;&gt;my SDIO
model&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v&quot;&gt;my controller&lt;/a&gt;
were in error.  This is a classic example of building the wrong thing
right.&lt;/p&gt;

    &lt;p&gt;I’m not sure I would’ve found this apart from hardware testing.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; This one was a hardware bug.  The hardware did everything
I had designed it to do and it did it all properly, I had just designed
it to do the wrong thing.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also came across a second problem with these 128-bit registers, and that
was that I could read them once, and once only.  Ever after that first
success, the register would always read zero.&lt;/p&gt;

    &lt;p&gt;To understand this bug, we have to look a bit deeper into the design.&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDIO controller&lt;/a&gt; is designed to
handle data transfer via two internal FIFOs–the &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics&quot;&gt;ping-pong
buffer&lt;/a&gt;s.
Normally, those buffers are only used for data transfer: Either software
writes a sector into them that is then forwarded to the SD Card, or the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;controller&lt;/a&gt; reads a sector from the SD
Card and places the results into the buffer for software to come back and
read once the operation is complete.  The exception to this rule is that
these 128-bit registers are also written to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics&quot;&gt;ping-pong
buffer&lt;/a&gt;s,
not by the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receive
framer&lt;/a&gt;, but by
the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdcmd.v&quot;&gt;command wire
handler&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The problem in this case had to do with the pointers to the FIFO.
&lt;strong&gt;The bug:&lt;/strong&gt; I wasn’t
resetting the read pointer when I issued a command to read these registers.
As a result, the first time I read the registers properly from addresses
0, 1, 2, and 3.  When I issued the command again, the pointers weren’t reset
and so I was attempting to read the 128-bit register value from addresses
4, 5, 6, and 7–after it had been stored in addresses 0, 1, 2, and 3.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; While you might argue this was bad user interface design,
it required a hardware fix.  Therefore this falls into the category of a
hardware bug.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once the card identifies itself, it is then picks its relative address and
the protocol clock can speed up from 400kHz to 25MHz.  Later, if I want
to restart things, I might wish to slow the clock back down to 400kHz.
&lt;strong&gt;Design bug:&lt;/strong&gt; Along the way, I discovered that my register design
provided me no way of knowing what the current clock speed was.  Hence,
I might change the clock speed, but never know how long to wait until that
new speed was active.&lt;/p&gt;

    &lt;p&gt;I solved this by adjusting the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v&quot;&gt;Wishbone
controller&lt;/a&gt; and
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v&quot;&gt;clock divider&lt;/a&gt; so
that &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdwb.v&quot;&gt;the controller&lt;/a&gt;
would return, upon a read request, the &lt;em&gt;current&lt;/em&gt;
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdckgen.v&quot;&gt;clock divider&lt;/a&gt;
setting, not necessarily the most recently commanded one.  Once the two
matched, I could then know the clock rate had properly changed and so I
could move on.&lt;/p&gt;

    &lt;p&gt;This still creates a sudden clock change.  Were the card to try to lock a
PLL to this clock, it wouldn’t have time to lock it before I was sending
the next command.  On the other hand, the specification does say that the
clock can be stopped or paused at any time if need be, a criteria that would
probably preclude such an implementation.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; This was a flaw in my user interface design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SD Cards have two command sets.  There are regular commands, called CMDs
and followed by a decimal number, such as CMD0 (GO IDLE) or CMD17
(READ SECTOR).  There are also application specific commands, or ACMDs.
To send an ACMD, you first send a CMD55, and then the following command is
interpreted as an ACMD.  I now needed to issue an ACMD6 to set the bus width
to four bits.  However, much as I tried, I couldn’t get the card to respond
to my CMD55 at all.  &lt;strong&gt;The bug:&lt;/strong&gt; It was only after much frustration that I
looked up the CMD55’s argument, only to discover I was supposed to
address the card in the CMD55 via the card’s relative address–and I was just
setting the address field to zero.  This was appropriate earlier in the
setup, before the card had assigned itself a non-zero relative address, but
not once the address had been assigned.  No wonder it wasn’t responding–I
wasn’t addressing it.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; This makes for a third software bug.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At this point, I was finally at the point in the sequence where I could
issue a command to read a sector from the SD Card and … I got stuck here
again.  I kept issuing read commands, only to have them end in
a failure with a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
failing error code.  In the end, this turned out to be a couple of bugs.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;The bug:&lt;/strong&gt; The first problem was that I couldn’t tell the difference
between a read failure and a command response failure.  Both might return
the same &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
failure code, both shared the same three bits.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; I really need to adjust the user interface here, so I can
tell the difference between failures on the command wire, and read failures
on the data lines–whether they be timeout errors or actual
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; errors.&lt;/p&gt;

    &lt;p&gt;Now for the other problems …&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also made the mistake at one point of not enabling the FIFOs.  Sure
enough, by design, the read wasn’t enabled because the FIFOs hadn’t been
enabled.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt;  This was a software bug, caused by my thrashing around
trying to determine if I had a read error or a command wire error, and
so I had turned off the FIFOs to get the command to end early enough that
I might trigger the internal logic analyzer on something useful, and then
I later forgot that I had them turned off.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;At this point, I still wasn’t able to read a sector from the device,
and it took a bit longer to figure out why.  Not only that, I had to dig
into the trace from my internal logic analyzer to discover the next bug.
Remember how I said when discussing the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receiver
design&lt;/a&gt;, that
the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt;
would remove the start bit?  Well, in order to do that, the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt;
needs to be told when to expect a packet so it can reset its start-bit
search algorithm.  Nothing in my internal interfaces allowed for this
communication–I just hadn’t foreseen the need.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; This was definitely a hardware bug.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then I got lucky.  &lt;strong&gt;The bug:&lt;/strong&gt; I just managed to (by chance) adjust the
scope enough that I could see there was a packet (i.e. the sector) coming
back across the interface, but the design just wasn’t seeing it.  This was
key, because it told me I wasn’t somehow messing up the command.  I had
the command sequence right, and the card was returning data, I just wasn’t
seeing it.&lt;/p&gt;

    &lt;p&gt;Was it a problem in the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receiver&lt;/a&gt;?&lt;/p&gt;

    &lt;p&gt;No.  The formally verified
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receiver&lt;/a&gt;
worked nicely as designed.&lt;/p&gt;

    &lt;p&gt;The problem was in my watchdog timer.  The timer was set, by a parameter in
the &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdrxframe.v&quot;&gt;receiver&lt;/a&gt;,
to wait a maximum of 8M clock cycles for the first data bit.  That timer was
overridden at the top level, so that it would only wait 64 clock cycles for
the first data bit.  Needless to say, the card didn’t respond that fast.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; Yeah, this was another hardware bug.  This time, it was in
the design’s configuration.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point, I’d like to write that all my formally verified modules worked
as intended.  Was this really the case?  Let’s work through the issues
identified above.  Issue three wasn’t clearly a bug.  Issues one, two,
seven, and nine were all software issues,
and issues six and eight were user interface design issues.&lt;/p&gt;

&lt;p&gt;That leaves four hardware issues that were revealed during bringup.  The
first was the 128-bit register CRC issue.  This flaw passed both formal
and simulation based verification–the design did what I told it to, I had
just told it to do the wrong thing.  The second issue, that of the FIFO
pointers, should’ve been caught when I verified the user interface, or at least
when I ran the whole design in simulation.  The last two issues, that of when
to start looking for the start bit and how long the watchdog timeout should
be, were both issues rooted in the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt;.
They were missed simply because 1) I didn’t formally verify the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/rtl/sdfrontend.v&quot;&gt;PHY&lt;/a&gt;,
and 2) my simulation never checked more than one packet, and 3) never
waited a significantly long period of time before returning a packet.
(Given how expensive simulation can be, I dislike waiting if I don’t have to.
Unfortunately, this led to missing two bugs in simulation that had to be caught 
later in hardware.)&lt;/p&gt;

&lt;p&gt;One item I haven’t yet mentioned is how long this hardware bringup session
took.  Once everything was formally verified, I managed to run through all the
hardware bringup over the course of two days.  The work often took place when
another project was running simulations, and it had to be paused for nearly
a whole day in the middle due to internet connectivity issues.  So, let’s
say hardware bringup–from synthesis to reading a sector took no more than
a day of work in total.  This is in contrast to my first attempts to bring
up &lt;a href=&quot;https://github.com/ZipCPU/sdsdpi/blob/master/sw/sdiodrv.c&quot;&gt;this controller&lt;/a&gt;,
taken before either simulation or formal were accomplished,
where I just embarrassed myself when not only did the controller not work but
I had no idea why not.  At least this time I had more confidence in what
was going on.&lt;/p&gt;

&lt;p&gt;I should also caveat this list by pointing out that I haven’t (yet) verified
either &lt;a href=&quot;https://github.com/ZipCPU/sdsdpi/blob/master/sw/sdiodrv.c&quot;&gt;my software
driver&lt;/a&gt;, or the
hardware’s ability to write a sector.  So far, I’ve only tested a piece of
well instrumented &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/dev/sw/zipcpu/board/sdiochk.c&quot;&gt;test
software&lt;/a&gt;–nothing
that can really be used beyond initial hardware verification.  My work,
therefore, isn’t complete yet.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;I like to ask myself, after going through all this pain, was it really worth
it?  Was it worth all the pain of going through a formal verification process?
Were the bugs I found ones that justified the extra work?&lt;/p&gt;

&lt;p&gt;In this case, let’s think of the alternative.  The alternative is that I
would run this design on silicon, convince myself over the next week or two
that it worked, and then put this design away, in my library, containing
bugs associated with features never tested in silicon.  I’d be proud of my
work, and pat myself on the back.  Then, sometime later–perhaps a year or
more, I’d come back to this design, remember how proud I was of it, pull it off
the shelf, and place it into a new design using an IO mode that had never been
properly tested, only to
discover things not working.  I’d then re-run the simulation, get a “success”
result, and convince myself that some other part of the design must be in error.
Then, after a painful week of debugging–perhaps even two–I’d be forced back
to this portion of the design only to kick myself for allowing such bugs to be
left in my “library”.&lt;/p&gt;

&lt;p&gt;This is definitely one of those cases where an ounce of prevention is worth
a pound of cure.  It’s certainly easier to debug a design shortly after
writing it than it is to come back to it years later wondering what’s wrong
with it.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Prepare thy work without, and make it fit for thyself in the field; and afterwards build thine house. (Prov 24:27)&lt;/em&gt;</description>
        <pubDate>Tue, 18 Jul 2023 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/formal/2023/07/18/sdrxframe.html</link>
        <guid isPermaLink="true">https://zipcpu.com/formal/2023/07/18/sdrxframe.html</guid>
        
        
        <category>formal</category>
        
      </item>
    
      <item>
        <title>Using a Verilog task to simulate a packet generator for an SDIO controller</title>
        <description>&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The KlusterLab board&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdiopkt/klusterlab_1.0.jpeg&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One of my current projects is to test and bring up a &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb Ethernet
test board&lt;/a&gt;.  The board has been fondly named
the “KlusterLab”, because of all of the various interfaces present on it.
Among those interfaces are &lt;a href=&quot;https://github.com/pcbarts/fast-open-switch-hardware/blob/8c531c306c93a31ff30c5851e233dbd086ae79f1/fast-open-switch%20r1.0/Documentation/KlusterLab%20Schematics%20r1.0.pdf&quot;&gt;an SD port and an eMMC port&lt;/a&gt;.
Now, how shall I verify their functionality?&lt;/p&gt;

&lt;h2 id=&quot;building-an-sdioemmc-controller&quot;&gt;Building an SDIO/eMMC Controller&lt;/h2&gt;

&lt;p&gt;My first round of testing the SD port used my SPI-based SD card controller,
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI&lt;/a&gt;.  Using that controller, the card
responded in much the way I expected, save that the first sector of the card
wasn’t what &lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS&lt;/a&gt; was expecting.
Since this is simply board bringup, where we are just trying to verify that the
hardware is working, I signed the component off as working.  I could obviously
write to the device, and I could read from the device.  (Okay, I signed it
off too early, but we’re getting there.)&lt;/p&gt;

&lt;p&gt;The eMMC port, however, that was going to require more work.  I didn’t have
an eMMC controller.&lt;/p&gt;

&lt;p&gt;On the other hand, I had the beginning scribbles of an SDIO controller I’d
started to work on years earlier.  SDIO is actually the native SD card
protocol.  It includes a clock, a bidirectional command wire, and four
bidirectional data wires that can be used to send blocks of memory back and
forth.  Moreover, it the SDIO and eMMC protocols are electrically so similar
that a single hardware controller can work for both of them–even if they would
need different software drivers.  Still, maybe I could breathe some life into
my draft controller components?&lt;/p&gt;

&lt;p&gt;In the end, I didn’t breathe life into any dead corpse of a project.  I pretty
much started over.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 2. SDIO/eMMC IO modes&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdiopkt/iomodes.svg&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Why?  Well, I figured, if I was going to build a &lt;em&gt;new&lt;/em&gt; controller, I should
build a design to support all of the IO modes used by eMMC and SDIO.  This
meant I wanted to support both the open-drain IO these interfaces start out
at, as well as their faster push-pull speeds.  I wanted to support the
bidirectional command and data pins.  Since the ports will work with either 1,
4, or 8 (eMMC only) data pins, I wanted to support all of these modes.  Finally,
the clock speed could run anywhere from 100kHz at the slowest, all the way up
to 200MHz.  The faster protocols even ran in DDR mode, with the fastest
protocol requiring return data capture using a data strobe.&lt;/p&gt;

&lt;p&gt;Thankfully, this is all doable.  It just needs a little planning.&lt;/p&gt;

&lt;p&gt;Over the course of a weekend or two, I managed to draft all of the components
to the entire controller.  You can see the various parts and pieces of this
new controller in Fig. 3 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. SDIO/eMMC controller components&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdiopkt/sdioparts.svg&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Once I built the front end hardware, I realized I couldn’t use an OSERDES
with the FPGAs CCLK pin, so I had to rebuild it without IO elements.  I
then built it again using DDR elements, and then built it again without
Xilinx IO elements at all.&lt;/p&gt;
&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 4. Approaches to front-end IO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdiopkt/sdfrontend.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The first front end I built was for the highest speed modes.  This was to handle
anything above 50MHz, and it did so using both 8:1 OSERDES and 1:8 ISERDES
elements.  I allowed the return data path to be captured any number of 1.25ns
intervals from an outgoing clock edge (when not using the data strobe).  Even
better, all of the data strobe qualified signals were placed nicely into
appropriate asynchronous buffers.  Then I realized, the current
version of the board will drive the eMMC clock through the CCLK pin, so I have
no access to the OSERDES when driving this pin.  Hence I built a second version
of the front end that just did direct IO pin control–allowing nothing to move
at less than a clock cycle and limiting the controller to 50MHz.  This I built
both with and without Xilinx IO support–to make sure I could handle the speeds
CCLK would generate.  The final version, shown as #2 in Fig. 4, was a DDR based
version.  This allowed me to run at 50MHz DDR from a 100MHz primary clock.  It
also allowed me to simulate something quickly without needing to simulate
Xilinx primitives.&lt;/p&gt;

&lt;p&gt;(I know, Xilinx primitives aren’t all that hard to simulate in Vivado.
In fact, they’re pretty easy to simulate.  However, I was using open source
tools up to that point and wasn’t yet ready to fire Vivado up.)&lt;/p&gt;

&lt;p&gt;All that remained was to verify the controller worked.&lt;/p&gt;

&lt;p&gt;But, hey, why let that stand in the way of progress if you have hardware
available to you?  I mean, look at it this way, properly verifying this
brand new controller would require I have a simulation model of an SD Card.
Proper simulation models take at least as much time to develop as the IP itself,
whereas in this case I have an actual SD card to test against.  Why not test
against reality?&lt;/p&gt;

&lt;p&gt;So, I did.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Initial hardware results&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdiopkt/initialfail.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;As you might expect, nothing worked.  I wasn’t really all that surprised.
Indeed, I sort of expected that.  (I’m not really a miracle worker …)  What
I wasn’t expecting was the controller to fail as early as when the board first
came up.  That was kind of embarrassing.&lt;/p&gt;

&lt;p&gt;The problem was even worse than that.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 6. What failed?  I couldn't tell&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdiopkt/whichfail.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;My whole goal at this portion of the project was to tell if the PCB design
had bugs in it or not.  Since I had no confidence in my own controller, I
couldn’t tell.  Was it my controller failing or the PCB?&lt;/p&gt;

&lt;p&gt;Even more embarrassing was that I couldn’t read known constant values back from
my own controller’s &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
registers&lt;/a&gt;.  You’d think
after all these years I could draft a &lt;a href=&quot;/zipcpu/2017/05/29/simple-wishbone.html&quot;&gt;Wishbone register
handler&lt;/a&gt; and get it
right on the first try.  (I certainly thought so.)  Nope.  I didn’t even get
that part right.  Reading a register which was supposed to have a 4’hc in
bits [31:28] returned 4’h0 for those bits.  Writing to that register didn’t
have any effect.  Frankly, I had no idea what the IP was doing when I wrote
to or read from it.  Yikes!&lt;/p&gt;

&lt;p&gt;So that left me in the middle of the longer, slower process of verifying the
various components of this IP.  I’ve made some progress at this task, and
so I now have formal proofs for the divided clock generator, the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
controller and the command pin processor.  The proofs aren’t
&lt;a href=&quot;/formal/2020/06/12/four-keys.html&quot;&gt;complete&lt;/a&gt;, but
they were enough to get me moving a step closer to success.  They were also
enough to find some rather embarrassing bugs–like writing when I was supposed
to be reading, or not setting the output register properly at all.  That said,
I can (now) read and write registers like I expect to, even when testing in
hardware(–now).  It’s for this reason that I colored these components in
green in Fig. 3 above.&lt;/p&gt;

&lt;p&gt;Unfortunately, when I got to verifying the packet transmit component, I ran
into trouble.&lt;/p&gt;

&lt;p&gt;Specifically, I wanted to verify that any packet sent to the packet transmitter
would be faithfully forwarded to the front end, with a proper start bit,
CRC(s), and stop bit.  It needed to do this when transmitting 1bit, 2bits,
4bits, 8bits, 16bits, or 32bits per clock cycle.  However, once I got to the
point where the controller “passed” its &lt;a href=&quot;/blog/2018/03/10/induction-exercise.html&quot;&gt;formal induction
proof&lt;/a&gt;, I switched
to &lt;a href=&quot;/formal/2018/07/14/dev-cycle.html&quot;&gt;checking cover traces&lt;/a&gt;
and the formal solver couldn’t demonstrate the ability to complete a packet at
all.  Something in my logic was broken, and cover checks are horrible for not
telling you what the problem is.&lt;/p&gt;

&lt;p&gt;I needed to switch to simulation.&lt;/p&gt;

&lt;p&gt;This, now, is the background behind what I’m going to discuss next.&lt;/p&gt;

&lt;h2 id=&quot;simulation-tasks&quot;&gt;Simulation Tasks&lt;/h2&gt;

&lt;p&gt;A full and proper Verilog simulation test bench, such as the one shown in
Fig. 7, contains several specific components.  These include:&lt;/p&gt;
&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. Simulation components&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdiopkt/fulltb.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A test bench environment.  This is the “top level” of the simulated design.
All other components will be submodules of this one.  The top level
test bench will typically define any and all clocks and resets used by
the design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The device under test (DUT). In this case, it would be my new controller
with all of its pieces.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A bus functional model (BFM) to send commands to the DUT.  This is one of
those build once use everywhere kinds of components.  In this case, it
would need to be a Wishbone BFM, since this controller has a &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone
interface&lt;/a&gt;.  Indeed,
I have &lt;a href=&quot;https://github.com/ZipCPU/sdspi/blob/master/bench/cpp/wb_tb.h&quot;&gt;such a model that I
use&lt;/a&gt;
often when controlling a design from
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;.
I just don’t (yet) have a Verilog one–and the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; doesn’t really count,
although &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;I have used it for that purpose in the
past&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A device hardware model.  This would model the component you intend to
communicate with.  In this case, it would model either an eMMC or an SD
card.  It’s also going to be the most complex piece of all the components
I’m discussing here, since it will need to support all of the IO modes
used by the DUT, as well as responding autonomously to the DUT–just like
and SD card or eMMC chip would.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final component of a test bench is a test script, designed to drive
the BFM so that it tests the DUT from the perspective of the user.&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;/zipcpu/2022/07/04/zipsim.html&quot;&gt;I’ve learned&lt;/a&gt; that
this portion of the test really needs to be in its own file.  That way,
you can swap which test script you run from one test to the next and
verify and test different portions of the design at a time.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I colored the missing pieces as black in Fig. 7 above.  Unlike the draft and
untrusted components I often draw in red, these components haven’t even been
drafted.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 8. Lessons learned when flagging failures&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdiopkt/lsnlearned.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;A good test bench will also include lots of checks within it, either within the
BFM or the device model, in order to make sure everything is done according
to protocol at all stages in the process.  Any failure in this whole
setup should be flagged as a failure (if it isn’t an expected and intended
failure), and should then be
&lt;a href=&quot;/zipcpu/2022/07/04/zipsim.html&quot;&gt;recorded&lt;/a&gt;
as a failed test case for later fault analysis.&lt;/p&gt;

&lt;p&gt;Putting all these components together takes a lot of work.  I just wanted to
know if my transmit controller worked, and what was causing its &lt;a href=&quot;/formal/2018/07/14/dev-cycle.html&quot;&gt;formal cover
check&lt;/a&gt; to fail.&lt;/p&gt;

&lt;p&gt;So I just built a quick and dirty test bench, as shown in Fig. 9.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 9. Quick and dirty simulation components&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/sdiopkt/verilogtb.svg&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I then wanted to share a piece of this test bench here, since it uses
Verilog tasks and I wanted to point out some key features of using tasks
together with AXI streams.&lt;/p&gt;

&lt;p&gt;The test bench component I wish to share below is a Verilog task designed to
send a packet, via an AXI stream port, to this transmit controller.  Further,
it controls one additional transmit control wire–the transmit enable signal,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tx_en&lt;/code&gt;.  This is the signal from the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
controller to the transmit controller enabling its operation.&lt;/p&gt;

&lt;p&gt;Let’s walk through this task.&lt;/p&gt;

&lt;p&gt;It starts with a task declaration.  The task accepts one parameter: the
length of the packet to be transmitted in 32-bit words.  (It helps that
nothing in either the SDIO or the eMMC protocol will need to transmit
or receive something that’s not a multiple of 32-bits.)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;&lt;span class=&quot;k&quot;&gt;task&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;send_packet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;integer&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As with all Verilog task inputs, or outputs for that matter, they are passed
by value.  Hence even if this length parameter were to change while the task
was operating, the value would remain constant within this environment.&lt;/p&gt;

&lt;p&gt;There are two other details of tasks to be noted here.  The first is that
this is a “static” task.  “Automatic” tasks are defined by placing the
word “automatic” between the task and its name.  “Automatic” tasks get
a new set of variables assigned to them every time they are called.  Since
this task is “static”, however, the “counter” value declared above will be
shared across all invocations of it.  This will also make it easier to debug,
since most Verilog simulators have an option to include these values in their
generated traces.&lt;/p&gt;

&lt;p&gt;The second thing to note is that this is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task&lt;/code&gt; and not a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function&lt;/code&gt;.
Tasks are great when an operation needs to consume time.  As such, they
aren’t always synthesizable, whereas functions can be used to encapsulate
complex but synthesizable operations.&lt;/p&gt;

&lt;p&gt;Finally, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;integer counter&lt;/code&gt; declaration just gives us a register we can
work with.  It’s identical to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reg signed [31:0] counter&lt;/code&gt;, but just a bit
simpler to declare.&lt;/p&gt;

&lt;p&gt;We’ll start our task off by initializing all the values we are going to
control.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tx_en&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;S_VALID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;S_DATA&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;S_LAST&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;No, these values are not declared within the task.  This is the task
controlling values defined within the task’s external context–something
I’ve only seen done in test bench contexts like this one.&lt;/p&gt;

&lt;p&gt;Do take careful note that all of these signals going into my DUT are clock
synchronous.  Clock synchronous inputs should be set on the clock edge,
and they should be set using non-blocking assignments.&lt;/p&gt;

&lt;p&gt;I come across a lot of designs that don’t do this.&lt;/p&gt;

&lt;p&gt;One common approach I find is where an engineer will attempt to set things
on the clock edge using blocking assignments, but without referencing the
clock itself.  These engineers might reason that, since the clock has
positive edges every 10ns, they should just set test bench inputs every 10ns.
Sadly, this leads to a race condition within the simulator, since the values
will either then be set before or after the clock edge and not at the clock
edge.  Worse, you can’t tell from the trace on which side of the clock
edge such values were set on.  While I’ve seen this mistake often, the lesson
learned here tends to come quickly.&lt;/p&gt;

&lt;p&gt;I’ve also seen things where engineers will offset their logic from the clock
edge.  Perhaps they might transition their signals on the negative edge of
the clock.  This, however, creates a coherence problem within the design,
making debugging a challenge.  (Yes, this is still the approach I use with
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;–it
is flawed, and I am likely to change how I handle such things in the future.)&lt;/p&gt;

&lt;p&gt;In one recent project I worked on, however, I did find that I needed to model
the hold time following the clock edge.  This was due to the partial modeling
of physical realities, to the point where the clock was arriving at multiple
times during the clock cycle.  My solution to this problem was to add a hold
time model, such as:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tx_en&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HOLD_TIME&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;S_VALID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HOLD_TIME&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;S_DATA&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HOLD_TIME&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;S_LAST&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HOLD_TIME&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Had the right hand side of any of these expressions required calculation
with the current (before clock) data, this would guarantee that the correct
calculation was made, and the correct value set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#HOLD_TIME&lt;/code&gt; time units
following the clock edge.&lt;/p&gt;

&lt;p&gt;As a last note, let me point out that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tx_en&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_VALID&lt;/code&gt; really need to
already be clear (zero) coming into this routine.  Otherwise, if they were
not, it is possible we might’ve just broken the AXI protocol by lowering
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_VALID&lt;/code&gt; without checking &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_READY&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that we have this setup behind us, we can start up the DUT.  The first
step is to enable the transmitter.  Then one clock later, we’ll start the
packet stream.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tx_en&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;S_VALID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Why wait a clock cycle?  Simply because the actual packet generator will
take a clock cycle (or two) to read from its local block RAM before setting
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_VALID&lt;/code&gt; signal.  That’s just the way this particular controller works.&lt;/p&gt;

&lt;p&gt;The next step is to send the packet data.&lt;/p&gt;

&lt;p&gt;When using AXI streams, there are only two times when you are allowed to
set or adjust any stream values.  The first is on a reset, when the VALID
signal must be brought low.  Ever after that, stream information may only
be adjusted when either valid is low (which it won’t be here) or when ready
is high.  Hence, we check for these conditions before adjusting anything.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_VALID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S_READY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;S_VALID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_LAST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;S_DATA&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;S_LAST&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Checking for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_READY&lt;/code&gt; is very important for this controller.  Depending
on the IO settings, the transmitter might be able to send 32 bits per clock
cycle (i.e. 200MHz eMMC clock, 8 data lines, and DDR mode driven from a 100MHz
bus clock), or it might take 32,000 cycles to send 32-bits (i.e. 100kHz clock,
1 data line, and SDR mode), or any number of possibilities in between.&lt;/p&gt;

&lt;p&gt;The trick, however, is that we need to keep running this loop until all
data words have been sent.  If only sometimes through the loop the data
is accepted, then we need to make sure we keep looping–hence the while
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;counter &amp;lt; length&lt;/code&gt; condition.&lt;/p&gt;

&lt;p&gt;But what about the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait(!clk)&lt;/code&gt; condition?&lt;/p&gt;

&lt;p&gt;That’s there because the non-blocking statements above don’t take any
simulation time.  You need to get past them to a point where the simulation
is forced to step forward for the statements above to take effect.  If we
didn’t have this wait condition, we might find ourselves looping back up
to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@(posedge clk)&lt;/code&gt; statement before our assignments had taken effect.
Waiting for the clock to become negative breaks this cycle, and doesn’t
really effect anything otherwise.&lt;/p&gt;

&lt;p&gt;Once all the data has been sent, there’s one more important step: clearing
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S_VALID&lt;/code&gt; at the end of the packet.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_READY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;S_VALID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S_VALID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The rest of this task is just simulation maintenance.  For example, you
don’t want to return from sending a packet while the transmitter is still
busy, so we’ll wait for it to finish it’s task.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx_valid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once the transmitter completes its task, we need to drop the transmit enable
line.  We’ll wait a clock cycle first.  Then, we have to drop it on a clock
edge, since this is a source synchronous signal.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tx_en&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1'b0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Lest we allow the controller to start immediately with the next packet,
we’ll force a minimum packet separation of another two clock cycles.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;endtask&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This was enough to stimulate the DUT into sending a packet.  It was also enough
to find out why the cover check was failing–so I can now return to my
formal proof.&lt;/p&gt;

&lt;p&gt;It wasn’t enough to check that the packet CRC was valid.&lt;/p&gt;

&lt;p&gt;CRC checking can be a challenge with formal methods, so I wanted to check
it via simulation anyway.  Worse, there are many types of CRCs I need to check.
Specifically, both SDIO and eMMC protocol place CRCs at the end of every
packet, and those CRCs are one per data line.  That’s right.  The CRC on
data line zero covers only the data on data line zero.  The CRC on data line
7 covers the data transmitted on data line 7.  Moreover, when working in one
of the DDR modes, the CRC checks are split between the two clock edges.
There’s one CRC per data line per clock edge, so up to a maximum of 16 CRCs
that can be transmitted and then must be checked.&lt;/p&gt;

&lt;p&gt;Did I find bugs?  Definitely.  How many?  Too many for my ego.  I was convinced
I had a wonderful design, with only a few minor bugs before going through this
effort.  Those “few minor” bugs, however, were causing the transmitter to
lock up mid operation–something my formal proof wasn’t catching.  This
simulation, however, caught the bug nicely.&lt;/p&gt;

&lt;p&gt;Unfortunately, because this was an ad-hoc simulation setup, it fails several
of the criteria of a “good” simulation.  For example, most of the verification
that took place was done by looking over the resulting trace.  It wasn’t until
I got to CRC checking that I started adding assertions to my simulation
to automatically catch and flag bugs.  As a result, while this helped me get
further along in the project, it’s not really good enough to keep around long
term.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So, did I find the initial failure?  Absolutely!  The design came up broken
because … the PCB design was broken.  The PCB design used an approach to
crossing from 1.8V to 3.3V that didn’t allow open drain signals to cross
properly.  As a result, once I had confidence that my IP was working, I
could tell that when the board started up it didn’t pull the data lines high
through the voltage translator.  Instead, the voltage translator sampled the
line low and maintained it at a low level in spite of the pull up resistors
that were intended to pull it high.  As a result, when the SD card processed
the first command I sent, it would notice that data line 3 was also low, and
it would go into SPI mode even if I wanted it to stay in SDIO mode.&lt;/p&gt;

&lt;p&gt;Yes, that’s right, it’s not just the SDIO controller that is a work in
progress, and I’m not the only one who makes mistakes when bringing things
up for the first time.&lt;/p&gt;

&lt;p&gt;If this is a piece of IP you are interested in, then watch &lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;this
space&lt;/a&gt;.  I intend to post it and maintain
it there once I’m done getting it to work.  Once done, it will have an
interface similar to the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI&lt;/a&gt; controller that’s currently there,
and I intend to maintain the two alongside each other.  The two big
improvements I’d still like to make are 1) adding a DMA, to push data around
to and from memory at the full speed of the bus, and 2) I’d also like to
add support for reading or writing a stream of blocks in a row–something the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI&lt;/a&gt; controller has no ability to do.&lt;/p&gt;

&lt;p&gt;If you are too impatient to wait, you can take a peek at the controller
under development
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/sdspi/sdio_top.v&quot;&gt;here&lt;/a&gt;,
but I’d caution you that if I were to offer any guarantees or warranties at
this point, it would be that there are still bugs in the design.  Frankly,
it’s a work in progress.&lt;/p&gt;

&lt;p&gt;I am tempted, though, to come back to this controller later and write another
article about how to process the data strobe returned by the eMMC controller.
Such data strobes are becoming commonplace in high speed memory controllers,
to such an extent that I’ve now had to build controllers that could handle
data strobes from &lt;a href=&quot;https://www.arasan.com/product/xspi-psram-master/&quot;&gt;NOR flash (xSPI protocol),
HyperRAM&lt;/a&gt;,
&lt;a href=&quot;https://www.arasan.com/product/onfi-4-2-controller-phy/&quot;&gt;NAND flash (ONFI)&lt;/a&gt;,
and now this eMMC interface.  Another project I’m involved in, where I’m only
mentoring an amazing engineer, is that of a &lt;a href=&quot;https://github.com/AngeloJacobo/DDR3_Controller&quot;&gt;Verilog DDR3
controller&lt;/a&gt; and the
DDR3 protocol includes return strobes as well.  All told, I may have now seen
four or five different ways of processing these return data strobe signals–so
it might be ripe for a future blog post and/or a discussion on the topic.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Give instruction to a wise man, and he will be yet wiser: teach a just man, and he will increase in learning.  (Prov 9:9)&lt;/em&gt;</description>
        <pubDate>Wed, 28 Jun 2023 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2023/06/28/sdiopkt.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2023/06/28/sdiopkt.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Introducing the ZipCPU v3.0</title>
        <description>&lt;p&gt;It’s time to announce a new version of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;:
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; v3.0!&lt;/p&gt;

&lt;p&gt;For reference, here’s how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
development has taken place over the years:&lt;/p&gt;

&lt;h2 id=&quot;zipcpu-v01&quot;&gt;ZipCPU v0.1&lt;/h2&gt;

&lt;p&gt;Way back in the beginning, the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; had four bit opcodes and only
16x16-bit multiplies.  It truly had a very limited instruction set.  That said,
the instruction set design was too limited to be very functional.&lt;/p&gt;

&lt;p&gt;This original instruction set didn’t even last a half a year.&lt;/p&gt;

&lt;h2 id=&quot;zipcpu-v10&quot;&gt;ZipCPU v1.0&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
v1.0, had 32-bit bytes and no octet level access.  If you wanted to read or
write an octet (8bit value) in memory, you needed to read a 32b word, modify
the 8b value within it, and write the 32b word back.&lt;/p&gt;

&lt;p&gt;As a result, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, v1.0, did not
have C library support.&lt;/p&gt;

&lt;h2 id=&quot;zipcpu-v20&quot;&gt;ZipCPU v2.0&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; v2.0 provided 8-bit byte support,
better compiler support, and full C-library support.  The instruction set
also included changes to the supported condition codes as well.&lt;/p&gt;

&lt;h2 id=&quot;now-announcing-zipcpu-v30&quot;&gt;Now: Announcing ZipCPU v3.0&lt;/h2&gt;

&lt;p&gt;The good news is that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
instruction set, as shown in Fig. 1, has not changed as part of this release.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. The ZipCPU instruction set and encoding&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/nextgen.png&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Although there have been (essentially) no changes to the instruction set
with this release, it feels like everything else associated with the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has changed:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;This upgrade started with a core refactor, so that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
could support more than just the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt;.  As a
result, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can now support
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;Wishbone&lt;/a&gt;,
&lt;a href=&quot;/zipcpu/2021/04/17/axilops.html&quot;&gt;AXI-Lite&lt;/a&gt;, and &lt;a href=&quot;/zipcpu/2021/09/30/axiops.html&quot;&gt;(full)
AXI&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The new memory interfaces are now bus width independent, allowing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to work on buses larger than 32-bits.  Indeed, it’s since been used on
64-bit and 512-bit buses quite successfully.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The core refactor led to better formal proofs, since the memory components
can now be verified independently.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The DMA has also been rewritten for bus width independence.  This rewrite
provides even more capabilities along the way.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The debug port has been rewritten.  This change is the one really
necessitating a new major release, as it won’t even appear to be backwards
compatible with prior releases.  Instead of two registers, the
rewritten &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
debug port is now accessed via 33 registers: a control
register and one debug register address per each of the 32 internal registers.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The companion core configuration file has been replaced by parameter settings
at the CPU wrapper level.  Parameter names have been formalized across
wrappers, so common names configure common capabilities.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; now has &lt;a href=&quot;/zipcpu/2022/07/04/zipsim.html&quot;&gt;its own
simulation infrastructure for CPU level
testing&lt;/a&gt;.
This new infrastructure makes it possible to 1) test multiple configurations
of the CPU, 2) test the CPU in multi-processor environments, 3) verify that
the clock can be stopped and restarted, 4) verify the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; in both
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
and AXI configurations, 5) verify the lock instructions, and 6) verify the
CPU’s new debugging port.  This new simulation infrastructure also includes
the ability to measure test coverage.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In perhaps the only downgrade of capabilities, the NOOP/SIM instructions
NEXIT and SEXIT have lost their ability to exit a simulation with a given
exit code.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has the ability to stop its clock if necessary.  Using this outside of the
simulator will likely require hardware level support, so for the time being
this may be a simulation only capability.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Put together, these are enough changes to warrant a new major release.&lt;/p&gt;

&lt;p&gt;Let’s take a moment to discuss these changes.&lt;/p&gt;

&lt;h2 id=&quot;expanding-the-bus&quot;&gt;Expanding the Bus&lt;/h2&gt;

&lt;p&gt;Perhaps the one reason driving this upgrade more than any other was the bus,
both in width and in type.  I needed to test a variety of AXI peripherals I
was building and wanted (needed, really) a CPU that could speak both AXI and
AXI-Lite.  Some of these peripherals required bus sizes wider than 32-bits.
Worse, the prior version of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
core included the memory ports within the CPU core itself forcing the CPU
to be &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; only.&lt;/p&gt;

&lt;p&gt;This proved to be a verification nightmare.  It meant that, in order to verify
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s core functionality, I
needed to verify the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
against every possible memory interface it might have.&lt;/p&gt;

&lt;p&gt;To make matters worse, which memory model the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
used was determined not by parameter, but by macro.  This made the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
harder to configure or adjust in any design.&lt;/p&gt;

&lt;p&gt;The fix was to refactor the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  In
the process, the interfaces to the prefetch, and the interface to the memory
unit, were both standardized as shown in Fig. 2 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. The ZipCPU's refactored architecture&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tweets/zipcpu/cpu-verification.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; core
was then verified against a pair of formal interface specifications,
as were the instruction fetch and memory units.  This made it possible to
formally verify those units separate from
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; core.&lt;/p&gt;

&lt;p&gt;The refactor wasn’t quite seamless.  &lt;a href=&quot;/zipcpu/2021/09/30/axiops.html&quot;&gt;AXI exclusive
access&lt;/a&gt; required a different
interface to the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; than
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
exclusive access (i.e. bus locking) required.  In
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;, all you need
to do is hold the cycle line high between any two accesses to do any sort of
“read-modify-write” routine.  In AXI, on the other hand, any
“read-modify-write” routine won’t know until the write return whether the
sequence was successful or not.  Then, if the sequence was not successful, the
“read-modify-write” routine needs to be repeated.  To add this new capability,
the core now provides the AXI module the instruction pointer at the beginning
of any “read-modify-write” sequence.  If the “read-modify-write” sequence then
fails, the memory module returns as if it were returning from a “load into the
program counter” access causing a jump to the beginning of the sequence.&lt;/p&gt;

&lt;p&gt;The good news is that, once I had the AXI interface I needed, &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;I could then
test and demonstrate ASIC IP using this
approach&lt;/a&gt;.  As a result, I’ve
used this upgraded &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to test both
a &lt;a href=&quot;https://www.arasan.com/product/xspi-master-ip/&quot;&gt;NOR flash controller&lt;/a&gt;
and a &lt;a href=&quot;https://www.arasan.com/product/xspi-psram-master/&quot;&gt;hyperRAM controller&lt;/a&gt;
using my &lt;a href=&quot;http://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists&quot;&gt;Arty board&lt;/a&gt;,
as well as an &lt;a href=&quot;https://www.arasan.com/products/nand-flash/&quot;&gt;ONFI flash
controller&lt;/a&gt; (via simulation only).
This has provided me with the valuable ability of &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;debugging system software
entirely in simulation&lt;/a&gt;–and
thus being able to answer why the device did (or did not) respond as expected.&lt;/p&gt;

&lt;h2 id=&quot;upgrading-the-dma&quot;&gt;Upgrading the DMA&lt;/h2&gt;

&lt;p&gt;Some time ago, someone contacted me to ask if I’d be willing to work with them
to build an “ideal-DMA”.  They had noticed that it seemed like every IP
component they integrated into their SOC required a DMA, and so it felt like
they had DMA’s running all through their SOC.  Wouldn’t it make more sense,
they asked, if we could just build one “better”/”ideal” DMA and not to keep
building all these special purpose DMAs throughout their SOC?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/one-dma.svg&quot; alt=&quot;&quot; width=&quot;240&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;No, the deal didn’t go through.  I didn’t have the hours to spare at the time,
and we had some disagreements over the legal terms of working together.
However, this did leave me asking the question, what would constitute an ideal
DMA?&lt;/p&gt;

&lt;p&gt;Then I needed to use &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/peripherals/wbdmac.v&quot;&gt;my
DMA&lt;/a&gt;
with one of these wider bus sizes.  Specifically, I was working on a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/&quot;&gt;project
requiring a 512b bus
width&lt;/a&gt;, and &lt;a href=&quot;/zipcpu/2018/02/12/zbasic-intro.html&quot;&gt;I use the DMA as part of
the process of loading CPU memory images from flash to RAM in the first
place&lt;/a&gt;.
At this point, my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/peripherals/wbdmac.v&quot;&gt;one-32b-size-fits-all DMA&lt;/a&gt;
just couldn’t connect to the bus.
It &lt;em&gt;needed&lt;/em&gt; to be upgraded.  I no longer had a choice.&lt;/p&gt;

&lt;p&gt;So, let’s think of all the lessons I’ve learned over the last couple of years
using the last DMA.  What would a better DMA look like?  Specifically, a DMA
is designed to move data around without CPU intervention.  What kinds of data
moves are required?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The most obvious requirement is for a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy()&lt;/code&gt; type of data move, that
moves memory from one location to somewhere else.  Such a capability needs
to move memory as fast as possible (it &lt;em&gt;is&lt;/em&gt; a DMA, right?), and so it really
needs to use the whole bus width.&lt;/p&gt;

    &lt;p&gt;It also needs octet level alignment in order to be relevant–unaligned
requests need to be expected, and handled appropriately.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;What about peripherals?  Consider audio peripherals, for example.&lt;/p&gt;

    &lt;p&gt;A microphone peripheral might capture 16b audio samples, generate an
interrupt after each sample is captured, and then need its sample to be read
and copied to memory.&lt;/p&gt;

    &lt;p&gt;A D/A peripheral might be similar: generating an interrupt whenever it
consumes a sample and needs another.  The DMA should then need to read the
new sample from memory and write it to this peripheral.&lt;/p&gt;

    &lt;p&gt;In both cases, the data source address for the microphone peripheral,
or the data destination address of the speaker, won’t change but the
address in memory will.&lt;/p&gt;

    &lt;p&gt;To make matters worse, the audio peripheral might require 8b or 16b values
which would be packed in memory.  Hence the DMA needs to be able to read
or write less than a full bus word at a time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Years ago, I wrote a controller for an &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/master/rtl/wboledrgb.v&quot;&gt;RGB based OLED
peripheral&lt;/a&gt;.
I demonstrated the capability of this controller by alternately placing the
Gisselquist Technology logo and my own mug onto the display.  In this case,
the peripheral understood 32b command and data words, but the data had to
be transferred one word at a time.  An interrupt would then tell the CPU
when it was time to transfer the next 32b word.  To use a DMA, the DMA
would need to wait for the interrupt, transfer the next word from memory
to a constant destination address, then wait for the next interrupt again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How about block peripherals?  For example, I have an
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI peripheral&lt;/a&gt;
which allows me access to an SD card via its (optional) SPI interface.  The
peripheral has two 32b data ports for transfers.  Each port leads to a 512B
FIFO, and the controller is expected to ping-pong between the two ports
for speed.&lt;/p&gt;

    &lt;p&gt;Reading from the SD card will fill one of these FIFOs and then trigger
an interrupt.  At that point, a DMA needs to read (many times) from the
same 32b address, form wide bus words together, and then write the results
to memory.&lt;/p&gt;

    &lt;p&gt;Writing to the same FIFO is similar, only the interrupt works in a different
fashion.  The CPU would first call the DMA to transfer a block (typically
512 bytes) of memory to the data port FIFO.  This block would need to be
read at whatever the bus size is, and then packaged into 32bit writes to fill
the FIFO.  Once the transfer is done, the CPU should be interrupted, and
the CPU can then instruct the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI peripheral&lt;/a&gt;
to write the information to the external SD card.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 3. Requirements of an upgraded DMA&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/betterdma.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;From these requirements alone, what does a good DMA need to do?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(Optinally) Wait on an interrupt before starting any transfer.  Which
interrupt will need to be user selectable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Transfer a given per-interrupt amount, perhaps less than the whole transfer.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Be able to read either 8b, 16b, 32b, or the full bus width at a time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Be able to write either 8b, 16b, 32b, or the full bus width at a time.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Accessing peripheral memory may require that the DMA not increment the
source or destination address, whereas accesses to memory will require both
that the source/destination address increment and that accesses may (or may
not) be aligned.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/zipdma/zipdma.v&quot;&gt;new ZipDMA&lt;/a&gt;
now offers all these abilities.  It’s an awesome DMA capability.&lt;/p&gt;

&lt;p&gt;You can see the basic structure of this &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/rtl/zipdma/zipdma.v&quot;&gt;new
DMA&lt;/a&gt; in Fig. 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. The new ZipCPU DMA's structure&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/zipdma-blocks.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Requests are made to the DMA, then sent to an FSM.  The FSM then breaks those
DMA requests into chunks.  Remember, unlike AXI,
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; can only operate
in one direction at a time.  Therefore, all operations need to take place in
chunks where data is first read, then written.  In terms of the chunk processing
itself, there’s a memory to stream processor to read data from the bus.  This
will read 8b, 16b, 32b, or the full bus width of data per clock cycle.  Data
are then packed by a gearbox prior to going into a FIFO.  Coming out of the
FIFO, the same data words are now unpacked into the user’s desired transfer
width: 8b, 16b, 32b, or the full width of the bus.  As the final per-chunk step,
this data is placed onto the bus and written.&lt;/p&gt;

&lt;p&gt;The biggest problem with this new capability?  There’s only one ZipDMA.  If
it’s so good that every process needs it, there will be contention for it.
The second biggest problem?  This DMA capability is (currently) a
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;em&gt;only&lt;/em&gt; capability.  I don’t (yet) have an AXI version of it.  Further work on
this DMA will
concentrate on making sure all of the various capabilities within it are
properly verified–as I don’t yet have a good set of DMA focused test cases
for that purpose.&lt;/p&gt;

&lt;h2 id=&quot;a-better-debugging-interface&quot;&gt;A Better Debugging Interface&lt;/h2&gt;

&lt;p&gt;The original &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; had only two
registers for its in-hardware debugging interface.  One register could be used
to &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;reset, start, stop, and step the
CPU&lt;/a&gt;.  This same
register could be used to select which internal
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; register the
second register would access.  Reads and writes to this second register would
then either read or update the actual (selected) register within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  While this worked, it didn’t
work well.&lt;/p&gt;

&lt;p&gt;To illustrate the problem, consider Fig. 5 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Before the update: two round-trips per request&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/slowdbg.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Reading any register from this interface required &lt;em&gt;two&lt;/em&gt; accesses, and therefore
&lt;em&gt;two&lt;/em&gt; round trips through the &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
bus&lt;/a&gt; to the FPGA.&lt;/p&gt;

&lt;p&gt;This interface struggled when I tried to debug
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; programs over my serial port
“&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;”.
The debugger wanted the ability to read all of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
registers.  The two register interface then required that I first write the
to the first register, that write then needed to complete, then I would read
the data register, and that read would need to complete, all before I could
move on to reading the second CPU register.  That required two round trip
transactions just to read one register, or sixty four round trip transactions
to read all of the CPU’s registers.  (There are 16 supervisor register and
16 user registers.)&lt;/p&gt;

&lt;p&gt;This could take a long time over a serial port.&lt;/p&gt;

&lt;p&gt;My &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;
has another type of read command: one where you can read multiple sequential
addresses in a row.  This operation only requires sending
the request (read thirty two 32b registers) and then waiting for the results.
There’s no requirement for a round-trip handshake in the meantime.  Instead,
any handshaking is complete once the entire operation is complete.  The
CPU just needed a minor upgrade to provide enough addresses on the bus to do
this.&lt;/p&gt;

&lt;p&gt;You can see how this operation is different in Fig. 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 6. After the update, one request yields all results&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/zipcpuv3/fastdbg.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Even better, I formalized how the CPU was to respond to accesses.  Debug
register reads shouldn’t need to stop the CPU–that way you can monitor
registers while the CPU is running, at the risk of reading an incoherent set
of registers.  This might be useful to know that the CPU is running, or where
it might be in its processing.  Bus writes, on the other hand, do need to stop
the CPU.&lt;/p&gt;

&lt;h2 id=&quot;upgrading-the-simulation-environment&quot;&gt;Upgrading the Simulation Environment&lt;/h2&gt;

&lt;p&gt;The original &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
purpose was to be absolutely as light on resources as
possible.  However, depending on the project, the “lightest resource” CPU might
have too little power.  I therefore quickly learned that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
would need the ability to expand or adjust its area to fit the available area,
while optimizing the CPU’s speed in that area.  Example configurations might
include whether or not the CPU used caches, or just very simple data accessing
routines, whether the hardware supported multiplies via hardware-specific
DSP elements, whether &lt;a href=&quot;/zipcpu/2021/07/03/slowmpy.html&quot;&gt;an all–RTL
multiply&lt;/a&gt; was required, or
whether the CPU should be built with no capability for multiplies at all.  All
this led to an early on requirement that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; needed to be highly configurable.&lt;/p&gt;

&lt;p&gt;My original approach to all this configurability was to create a separate
configuration file containing a set of macros in it.  The CPU’s configuration
would then depend on if or how those macros were configured.  I also had a
separate project, one I called &lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic&lt;/a&gt;,
which would be used to test the CPU.  Within the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic&quot;&gt;ZBasic project&lt;/a&gt;
was a piece of CPU testing software that could then
be used to test whether each of the CPU’s instructions worked.  All of this put
together worked great for testing a single configuration–the one described by
the macro file.  However I kept running into problems where I’d port the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to some piece of hardware or other and it wouldn’t work.  Perhaps I had made
some change some time earlier, and only tested other configurations to prove
that change.  Whatever the cause, I was often left debugging the CPU in
hardware–the one place you don’t want to debug the CPU.&lt;/p&gt;

&lt;p&gt;As it turns out, &lt;a href=&quot;/zipcpu/2022/07/04/zipsim.html&quot;&gt;it takes some engineering thought to build a test
setup that can check all configurations of a highly configurable
CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Version 3.0 of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
comes with such an infrastructure.  &lt;a href=&quot;/zipcpu/2022/07/04/zipsim.html&quot;&gt;I’ve written about
it before&lt;/a&gt;.
It centers around a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/sim_run.pl&quot;&gt;Perl script&lt;/a&gt;
and a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/rtl/sim_testcases.txt&quot;&gt;file describing a series of tests&lt;/a&gt;.
Each test specifies a canned configuration, a piece of CPU software,
and one of two environments: a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/rtl/wb_tb.v&quot;&gt;Wishbone
environment&lt;/a&gt;
and an &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/8a05953d059158d4fa85eacd5ba86dfc84a4a1bf/sim/rtl/axi_tb.v&quot;&gt;AXI environment&lt;/a&gt;.
Each test can also include any parameter overrides, so the default environments
can be overridden for the test.  I override these defaults, for example, to
adjust the bus width for non-32bit bus testing.  All told, there are 105 tests
that take just over an hour to run under
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;, or just over five days when
using &lt;a href=&quot;https://steveicarus.github.io/iverilog/&quot;&gt;Icarus Verilog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Simulation testing, however, is perhaps the one place where the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
instruction set is now less capable than before.&lt;/p&gt;

&lt;p&gt;As background, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; had two
special instructions, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instructions, that took specialized
arguments when run in simulation.  In hardware, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; instructions turned
into standard no-operation instructions, whereas the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIM&lt;/code&gt; instructions turned
into illegal instructions.  That functionality alone left 22-bits of instruction
space which I could use for additional functionality,
from which I had carved out sub-instructions to write characters or even
register values to the simulation log.  One special instruction would dump the
entire register set.  Another special instruction, encoded as either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEXIT&lt;/code&gt;
(NOOP based) or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEXIT&lt;/code&gt; (SIM based) was supposed to cause the simulation to
end with a given exit code.  It’s this x&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXIT&lt;/code&gt; code’s functionality that’s
been lost.&lt;/p&gt;

&lt;p&gt;The reason had to do with the implementation of these instructions.  They were
originally implemented by the
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;
C++ wrapper, and that wrapper required the ability to take a sneak-peek into the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s internals to know when to
execute these instructions.  This lead to two problems.  First, the instructions
would never work in a more traditional simulator that didn’t have or need such
a wrapper–such as &lt;a href=&quot;https://steveicarus.github.io/iverilog/&quot;&gt;Icarus
Verilog&lt;/a&gt; or a commercial simulator.
The second problem was that the interface used by the wrapper kept changing.
Since the features it depended upon weren’t standard Verilog
but rather depended upon &lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;’s
internals, the interface broke every time
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;
changed its internal data structure.&lt;/p&gt;

&lt;p&gt;In the end, I resolved these problems by rewriting how the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOOP&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIM&lt;/code&gt;
instructions were handled, and the new rewrite was done entirely in Verilog.
Using Verilog only, I could guarantee that all Verilog compliant simulators
would correctly implement these instructions.  However, I could not properly
implement the exit code requirement of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NEXIT&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEXIT&lt;/code&gt; instructions.
Hence, while the CPU has gained the capability of executing NOOP and SIM
instructions under a general purpose Verilog simulator, it has lost the
capability to exit the simulation with a specific exit code.&lt;/p&gt;

&lt;p&gt;In many ways, this is a small price to pay for better interoperability
between simulators, and the ability to simulate/test the CPU under a large
number of configurations.&lt;/p&gt;

&lt;h2 id=&quot;clock-gating&quot;&gt;Clock Gating&lt;/h2&gt;

&lt;p&gt;One of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
goals has always been low-logic.  A truly low logic CPU &lt;em&gt;should&lt;/em&gt; also be able
to be a low-power CPU.  In ASIC designs, low power often means
&lt;a href=&quot;/blog/2021/10/26/clkgate.html&quot;&gt;clock gating&lt;/a&gt;,
and the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has had a plan for
&lt;a href=&quot;/blog/2021/10/26/clkgate.html&quot;&gt;clock gating&lt;/a&gt;
since the beginning.&lt;/p&gt;

&lt;p&gt;Here’s how it works: the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
supports two special modes, a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HALT&lt;/code&gt; mode and a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SLEEP&lt;/code&gt; mode.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SLEEP&lt;/code&gt; will
cause the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to stop executing
instructions until the next interrupt.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HALT&lt;/code&gt; causes the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to stop executing instructions
at all, and thus to come to a complete halt until either the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debug port&lt;/a&gt; or an
external reset restarts the CPU.  These modes were originally envisioned to
allow the clock to be stopped by the CPU.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&quot;/blog/2021/10/26/clkgate.html&quot;&gt;clock gating capability&lt;/a&gt;
is now a reality–in simulation at least.&lt;/p&gt;

&lt;p&gt;I’ve also now used
&lt;a href=&quot;/blog/2021/10/26/clkgate.html&quot;&gt;clock gating&lt;/a&gt;
several times, although never in actual
hardware.  The biggest lesson I’ve learned?  The
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debug port&lt;/a&gt;
&lt;em&gt;must&lt;/em&gt; automatically restart the clock to handle requests.  There’s been more
than once when I’ve tried to load a program into the CPU externally from the
&lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging port&lt;/a&gt;,
only to find out later that the reason the CPU was non responsive was
because its clock was stopped.  The next biggest lesson?  Stopping the clock
&lt;em&gt;might&lt;/em&gt; lower simulation time, but this isn’t a given.&lt;/p&gt;

&lt;p&gt;The end result of this work is that the CPU now has a program to test its
ability to stop the clock.&lt;/p&gt;

&lt;h2 id=&quot;profiling&quot;&gt;Profiling&lt;/h2&gt;

&lt;p&gt;There was one more minor update to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, this one having to do with
profiling.&lt;/p&gt;

&lt;p&gt;Yes, I’ve profiled software–mostly benchmarks–running on the 
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, although only in simulation.
My current approach involves recording, for every instruction in a given
program, both the number of times that instruction was executed and the
number of clock cycles used to execute that instruction.  The resulting data
has done wonders for speeding up the CPU.&lt;/p&gt;

&lt;p&gt;While I’ve been using this data for quite some time, my previous method of
collecting it involved examining
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;’s internal data structures to
access it.  While that has worked in the past, it forces me to update the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; every time
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt; changes
their internal data structures.  (This was the same problem I had with the
simulation only instructions.)  The solution is to create a proper external
port, coming out of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
containing this data.  It’s then there if you want to use it, or it can be
ignored if you do not.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s simulation monitor
program had the same problem, where it was also accessing values internal
to the design.  Such values tend to move or get renamed with
&lt;a href=&quot;https://www.veripool.org/verilator/&quot;&gt;Verilator&lt;/a&gt;
updates.  As with the profiler interface, this is easily solved by generating
proper Verilog ports to the CPU containing references to these values for
the monitor.&lt;/p&gt;

&lt;p&gt;In both cases, I expect my updated solution to handling these values will
need less maintenance as I use (and maintain) the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; over time.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As with any project, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
remains a work in progress.  It will likely remain so for the foreseeable
future.  This is a good thing.  It means the CPU remains supported.&lt;/p&gt;

&lt;p&gt;In the meantime, I’ve now used the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; on a variety of commercial
projects.  I’ve written about some of them.  For example, it’s been used in
a couple of SONAR applications, and I’m now importing it into a
&lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb Ethernet switch&lt;/a&gt;
application.  I’ve also used it to test, via both simulation and hardware,
pre-ASIC IP cores.  (I.e. IP cores designed for ASICs, but tested in FPGAs
first.)&lt;/p&gt;

&lt;p&gt;At present, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has two
drawbacks that I’d still like to address in the future.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;It still doesn’t have a memory management unit (MMU) to give it access to
virtual memory.  Worse, the MMU I designed years ago for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is now abandonware.  It needs to be rebuilt.  Since all of the internal
interfaces have changed between the core and the memory components, the
MMU’s required interfaces have changed as well.  Worse, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s core infrastructure may
also need to be adjusted so that it can handle page faults.  For example,
what happens in a compressed instruction if the second half of the
instruction suffers from a page fault?  At present, compressed instructions
do not need to be, and therefore cannot be restarted mid-instruction.&lt;/p&gt;

    &lt;p&gt;This upgrade will be required before I can truly run Linux on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;The good news is that I don’t have any applications that require such an MMU
at present.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Although the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; supports AXI,
it doesn’t really do so by the book.  AXI is, by the book,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little endian&lt;/a&gt;
whereas the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; remains a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;big-endian&lt;/a&gt;
machine.  Yes, it now has options to run in a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little endian&lt;/a&gt;
fashion, but the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little endian&lt;/a&gt;
options within the tool chain haven’t been
tested, and so I have no confidence that they will work.  What this means
is that bytes within words are mis-ordered when using AXI.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
will still write byte zero to bits [31:24], and byte one to bits [23:16]
and so forth.&lt;/p&gt;

    &lt;p&gt;This has lead me to no end of troubles when testing AXI IP that is properly
ordered.  Not only that, but I now have an optimized software routine for
byte-reordering–a patch, written instead of a proper upgrade.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’ve imagined a third upgrade over the years as well: adding a floating point
capability to the CPU.  Moreover, I’ve reserved several instruction op-codes to
support 32-bit single precision floating point operations.  In hindsight,
however, I’m not sure to what extent I would use these instructions even if I
did implement them.  I don’t normally use &lt;em&gt;single&lt;/em&gt; precision floating point.
I default to using &lt;em&gt;double&lt;/em&gt; precision floating point.  Not only that, but the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
will never be a hard core floating point processing machine.  It just
doesn’t fit that role.  It will always be better as a fixed point system.
Hence, floating point is no longer one of my goals for the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This v3.0 release also marks the first time the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has synthesized (with caches) on a Kintex-7 device with &lt;em&gt;200MHz clock&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Yes, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has been well used (by me), and remains well loved.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Every man's work shall be made manifest: for the day shall declare it, because it shall be revealed by fire; and the fire shall try every man's work of what sort it is.  (1Cor 3:13)&lt;/em&gt;</description>
        <pubDate>Mon, 29 May 2023 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2023/05/29/zipcpu-3p0.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2023/05/29/zipcpu-3p0.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>What is a Virtual Packet FIFO?</title>
        <description>&lt;p&gt;I first came across virtual packet FIFOs in a &lt;a href=&quot;/blog/2022/04/29/proto-bringup.html&quot;&gt;SONAR
project&lt;/a&gt; by necessity.
The &lt;a href=&quot;/blog/2022/04/29/proto-bringup.html&quot;&gt;SONAR device&lt;/a&gt;’s
only means of communicating with the outside world was
via Gb Ethernet.  There was no
&lt;a href=&quot;/formal/2019/02/21/txuart.html&quot;&gt;UART&lt;/a&gt; and no JTAG.
Everything went over Ethernet.  Collected data went over Ethernet.
Device control was over Ethernet.  &lt;a href=&quot;/blog/2022/08/24/protocol-design.html&quot;&gt;Debugging had to be done over
Ethernet&lt;/a&gt;.  FPGA
reconfiguration and all software updates had to go over Ethernet.  Last of
all, the CPU needed to talk to the outside world over Ethernet.  This was
where I first came up with the idea of a virtual packet FIFO.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 1. A Virtual Packets FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/pktvfifo.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The idea came from necessity, given how &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/enet/enetpackets.v&quot;&gt;my previous network
controller&lt;/a&gt;
operated.  In &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/enet/enetpackets.v&quot;&gt;that
controller&lt;/a&gt;,
packets would be received into a small block RAM connected the controller.
That block RAM could hold only one packet at a time.  Once a packet was
received, therefore, the network controller would be deaf until the CPU
processed the packet and then notified the controller it could use its
memory for another packet.  Likewise, when the CPU wished to transmit a
packet, it would write a single packet to the controller’s memory, notify
it that a packet was present, and then wait for the controller to finish
transmitting it before writing the next packet to memory.&lt;/p&gt;

&lt;p&gt;This works great–on a low bandwidth interface.  But what happens if two
packets arrive in short succession?  Or, similarly, what happens if
packets arrive that are larger than the &lt;a href=&quot;https://github.com/ZipCPU/zipversa/blob/master/rtl/enet/enetpackets.v&quot;&gt;controller’s internal
buffer&lt;/a&gt;?
What about “Jumbo packets”?&lt;/p&gt;

&lt;p&gt;All of these problems necessitated a new solution, and the solution I chose was
a virtual packet FIFO.  This solution has two big upgrades to the previous
one.  The first is a size upgrade.  A virtual packet FIFO can be &lt;em&gt;much&lt;/em&gt; larger
than its block RAM counterpart.  The second upgrade is the number of packets
that can be held.  Frankly, it doesn’t make much sense if you can hold
lots of data, if you can’t also fill that with either lots of packets or
a small number of jumbo packets.&lt;/p&gt;

&lt;p&gt;Since this is a neat idea, let’s take a moment and discuss it.&lt;/p&gt;

&lt;h2 id=&quot;packet-streams&quot;&gt;Packet streams&lt;/h2&gt;

&lt;p&gt;Some time ago, I discussed &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;the problems with the AXI stream
protocol&lt;/a&gt;.
At the time, I based my discussion on three specific applications:
&lt;a href=&quot;/video/2022/03/14/axis-video.html&quot;&gt;video&lt;/a&gt;,
&lt;a href=&quot;/blog/2019/11/14/sdspi.html&quot;&gt;data capture&lt;/a&gt;, and network
packet handling.  In each of these applications, data would arrive at the
incoming interface independent of whether or not there was space available
to handle it.  &lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;Backpressure&lt;/a&gt;, a
key feature of the AXI stream protocol, could not be supported properly
without risking data corruption.&lt;/p&gt;

&lt;p&gt;At that time, &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;I suggested a new AXI stream field:
ABORT&lt;/a&gt;.
If the &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt; signal
was ever asserted from an upstream source, the rest of any data packet
would need to be dropped, and data handling would need to start over with
the first beat of the next packet.  This new
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;
signal has worked nicely in network packet handling constructs.  Indeed, it
has worked &lt;em&gt;very&lt;/em&gt; well.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Yes, it’s a bit harder to work with and harder to verify than straight AXI
streams.  This is to be expected.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;However, it was joy to watch the network design “just work” with this
protocol.  In particular, I watched network data get captured, formed
into packets, and then dropped as the design started up–because either
the network interface hadn’t finished its negotiation into 1Gb mode
(it could never keep up at less than 1Gb/s), or because the data hadn’t
been told where to go yet.  (Yes, it still needed a destination addresses
for the SONAR data, both IP and Ethernet, before it could send it out.)&lt;/p&gt;

    &lt;p&gt;Once configuration completed, the protocol started blasting captured
packets without a hitch.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I loved it!&lt;/p&gt;

&lt;p&gt;Others, however, have argued that my proposed
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;
field was unnecessary.  Why create a new protocol, they argued, vs. just using
straight AXI stream?  The answer to this is twofold:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Jumbo_frame&quot;&gt;Jumbo Frames&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;In order to use straight AXI stream, you have to first convert the incoming
network packet to AXI stream in the first place.  The follows simply because
that incoming network interface doesn’t know anything about
&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;.
To do this conversion, incoming packets need to first go into a buffer.
If there’s not sufficient space in the buffer, the packet is simply dropped.
If there’s sufficient space, the packet is “committed” and can then be read
out of the buffer via standard AXI stream.&lt;/p&gt;

    &lt;p&gt;The size of this buffer forces a limit on the maximum packet size that can
be handled.  Packets larger than the buffer size will need to be dropped.&lt;/p&gt;

    &lt;p&gt;While I was designing the original SONAR Ethernet controller, my customer
asked about &lt;a href=&quot;https://en.wikipedia.org/wiki/Jumbo_frame&quot;&gt;jumbo
frames&lt;/a&gt;–packets much larger than
the (otherwise) maximum
Ethernet packet size of 1500 Bytes.  How much larger?  They didn’t say.
All of a sudden, I could no longer size my buffer prior to hardware
layout (place and route).&lt;/p&gt;

    &lt;p&gt;The Virtual Packet FIFO we’ll discuss today can solve this problem of
converting an (otherwise) unsized packet to AXI stream proper.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Vendor Infrastructure&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;If I used Xilinx (or any other vendor’s) AXI stream infrastructure, I might
be tied to that protocol.  The choice of whether or not to use AXI stream
is really a business decision: either rebuild the AXI stream infrastructure
from scratch to support a modified protocol, or stick to the AXI stream
protocol as is.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: right&quot;&gt;&lt;caption&gt;Fig 2. Advantages to using your own IP&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/personal-ip.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If I rebuild the infrastructure from scratch, I incur additional costs
   above and beyond what I might have incurred had I used someone else’s
   (free) infrastructure.  I can release any IP I build under my chosen user
   license.  I can also formally verify anything I build.  I will also gain
   the ability (and responsibility, and cost associated with) debugging and
   maintaining it.  The good news, though, is that I can guarantee the quality
   of any IP I control.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: left&quot;&gt;&lt;caption&gt;Fig 3. Advantages to using vendor IP&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/vendor-ip.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;If I use a vendor’s infrastructure then I might save some money–while
   risking my project’s success on the vendor’s responsiveness to bugs found in
   their infrastructure.  Given that I’m aware of bugs that’ve lived in Xilinx
   IP for nearly 10 years, and given that I’m a small one-man nobody shop, I
   don’t have a strong confidence that they’ll fix anything that’s broken.&lt;/p&gt;

&lt;p&gt;Yes, I suppose this is a business decision.&lt;/p&gt;

&lt;p&gt;Frankly, I don’t use vendor infrastructure unless I have to.  It’s just the
   nature of how I’ve structured my own business at &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
   Technology&lt;/a&gt;.
   I’ve now built &lt;a href=&quot;/about/zipcpu.html&quot;&gt;my own CPU&lt;/a&gt;, my own
   GNU compiler and assembler back ends, &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;my own bus
   interconnects&lt;/a&gt;,
   &lt;a href=&quot;https://github.com/ZipCPU/dspfilters&quot;&gt;my own DSP filters&lt;/a&gt;,
   &lt;a href=&quot;/dsp/2017/08/30/cordic.html&quot;&gt;CORDICs&lt;/a&gt;,
   &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFTs&lt;/a&gt;, etc.  So it should come
   as no surprise that I’d have no problems building &lt;a href=&quot;https://github.com/ZipCPU/eth10g/tree/master/rtl/net&quot;&gt;an AXI stream
   infrastructure&lt;/a&gt; based
   around a new “&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;”
   field.&lt;/p&gt;

&lt;p&gt;Yes, there are risks with this approach.  One common risk is that I might
   need to interface with a vendor protocol, so I often have &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;conversion
   routines&lt;/a&gt; available to move back and
   forth between one protocol and another when necessary.  For example, it’s
   not enough to use
   &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; if you need
   to interact with Xilinx’s MIG–so I use a &lt;a href=&quot;/blog/2020/03/23/wbm2axisp.html&quot;&gt;bridge from one protocol to the
   other&lt;/a&gt;.  I &lt;a href=&quot;https://github.com/ZipCPU/wb2axip&quot;&gt;also
   have&lt;/a&gt; sufficient infrastructure to
   use AXI without bridges if necessary.&lt;/p&gt;

&lt;p&gt;Still, AXI stream is a really simple protocol, and &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;this modified AXI
   network stream
   protocol&lt;/a&gt;,
   while more complex, isn’t really that much more difficult to deal with.&lt;/p&gt;

&lt;p&gt;Since writing &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;that
article&lt;/a&gt;, I’ve had great
success with this new
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt; field.
Indeed, I’ve had so much success, that I’m now rebuilding all of my network
data handling components to use it.&lt;/p&gt;

&lt;p&gt;However, there is one (more) problem this &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;new
protocol&lt;/a&gt; needs
to address: stream widths.&lt;/p&gt;

&lt;p&gt;When working with 1Gb Ethernet, I could operate at 8b/clock at 125MHz, and
stream widths weren’t really a problem–every beat contained exactly one byte.
Well, not quite.  Stream widths became a bit of a problem when crossing clock
domains, since I would need to guarantee sufficient handling width.  To
handle the CDC case, I first converted to a wider (32b) AXI stream, and
then prepended a 32b packet length to the packet.  This kept me from
supporting &lt;a href=&quot;https://en.wikipedia.org/wiki/Jumbo_frame&quot;&gt;jumbo frames&lt;/a&gt;,
so when rebuilding for a 10Gb interface, I needed a new solution.&lt;/p&gt;

&lt;p&gt;Standard AXI stream solves this problem with their TSTRB and TKEEP fields.
Each field has one bit per byte per beat within it, and allows the stream
processor to handle less than a full beat of information.  For example, when
dealing with a 32-bit interface, a 16-bit value might contain two NULL bytes,
where a NULL byte is defined as one where TKEEP and TSTRB are both low.&lt;/p&gt;

&lt;p&gt;This seemed insufficient for me for a variety of reasons.  In general, to use
an AXI stream of this type, you’d first want to pack it and remove all
NULL bytes.  This would force any unused bytes into the last beat, while also
requiring that the last beat had at least one valid byte.  The last beat would
also need to be packed, so that all used bytes would be on the low end–when
using little endian semantics, or the high end otherwise.  Further, I never
saw a reason for keeping “position” bytes (TKEEP &amp;amp;&amp;amp; !TSTRB) around.  The
result was that TKEEP and TSTRB contained too many bits for my purpose.&lt;/p&gt;

&lt;p&gt;So I created a new field: BYTES.  At first, the BYTES field had &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$clog2(DW/8+1)&lt;/code&gt;
bits to it, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW&lt;/code&gt; is the number of bits in the DATA field–sometimes
called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C_AXIS_DATA_WIDTH&lt;/code&gt;.  This BYTES field would then be equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt;
for every beat prior to the last one, and between one and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt; inclusive for
the last beat.  (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 &amp;lt; BYTES &amp;lt;= DW/8&lt;/code&gt;)  Then, on second thought, I realized the
top bit of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYTES&lt;/code&gt; was irrelevant: Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BYTES&lt;/code&gt; was never zero, and never
more than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt;, I could map the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt; value to zero and drop a bit.  So,
now, BYTES has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$clog2(DW/8)&lt;/code&gt; bits and a value of zero (representing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt;
bytes) for all but the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LAST&lt;/code&gt; beat where it might represent fewer bytes per
beat.&lt;/p&gt;

&lt;p&gt;So, in summary, to support packet data I made the following changes to the
AXI stream protocol:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;&lt;/strong&gt;: A new
field, indicating that the upstream processor needed to drop the packet
for any reason.  Possible reasons I’ve come across include: 1) CRC errors,
2) protocol errors, 3) hardware errors, or even 4) insufficient memory
for handling &lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;,
from downstream.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TKEEP/TSTRB&lt;/strong&gt;: I dropped both of these fields.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BYTES&lt;/strong&gt;: A new field to replace the TSTRB/TKEEP fields, while still
indicating how many bytes are active in a given beat.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;And, of course, all beats are fully packed.  Hence, all but the LAST
beat will have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DW/8&lt;/code&gt; valid bytes in it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’ve named &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/doc/axin.pdf&quot;&gt;this (new) protocol the AXI-networking, or AXIN,
protocol&lt;/a&gt;, for lack
of a better name.  As a result, if you look through &lt;a href=&quot;https://github.com/ZipCPU/eth10g/tree/master/rtl/net&quot;&gt;the designs I’ve built
to use this protocol&lt;/a&gt;,
you’ll find “AXIN” in a lot of the names.&lt;/p&gt;

&lt;p&gt;I also have a lot of infrastructure for this new protocol, and that
infrastructure is growing on a daily basis.  For example, I have AXIN
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netskid.v&quot;&gt;skidbuffers&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;asynchronous&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/netfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt;s,
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinbroadcast.v&quot;&gt;broadcasters&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinarbiter.v&quot;&gt;arbiters&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;width
converter&lt;/a&gt;,
and more.  (A CRC checker is still being verified, but will likely be posted
soon.)&lt;/p&gt;

&lt;p&gt;This brings us to the topic of virtual FIFOs.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-virtual-fifo&quot;&gt;What is a virtual FIFO?&lt;/h2&gt;

&lt;p&gt;A virtual FIFO is simply a FIFO that uses external instead of internal memory.
That external memory is typically accessed via a bus, shared among many
potential users, and commonly exists off-chip.  A classic example would be a
DDR3 SDRAM memory accessed via an AXI (or
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;) bus.  You can
see the difference between a traditional and a virtual FIFO in Fig. 4.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: right&quot;&gt;&lt;caption&gt;Fig 4. Difference between a FIFO and a Virtual FIFO&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/fifo-comparison.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Some time ago, I built a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v&quot;&gt;Virtual FIFO for the AXI
protocol&lt;/a&gt;.  The
flow went as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The first step was to &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L486-L490&quot;&gt;buffer a burst of data&lt;/a&gt;
into a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt;.  To work
smoothly, the &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt; needed
space for at least two AXI bursts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once a full burst’s worth of data was available in the &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L486-L490&quot;&gt;local
FIFO&lt;/a&gt;,
that data would be &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L486-L490&quot;&gt;burst to the AXI
bus&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;When using &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;,
I’d do the same thing, save that the burst would only
end after the incoming FIFO was completely drained.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L409-L427&quot;&gt;Once BVALID was then received&lt;/a&gt;,
we would know that a full AXI burst’s
worth of memory was now available in the external RAM to be &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L681-L735&quot;&gt;read
back&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;In the case of
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;,
I’d count data words, not burst sizes, but it’s the same principle.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There was again another (local, block RAM) &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt; on the read
memory side.  Like the first FIFO, &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L788-L796&quot;&gt;this
one&lt;/a&gt;
also required enough room to contain at least two AXI bursts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once a burst’s worth of data has been placed into the external RAM, &lt;em&gt;and&lt;/em&gt;
there is sufficient (uncommitted) data in the second FIFO to hold it,
a &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L681-L735&quot;&gt;burst read request would be issued&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Again, when using
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;,
I’d make requests until the entire FIFO’s size was committed–not just the
initial burst size.  Hence, as reads might be made from the FIFO while
requesting data from the bus, additional reads would be made.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data read back from memory would then get sent straight into &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L788-L796&quot;&gt;this second
buffer&lt;/a&gt;
once it returned from the bus.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final, outgoing AXI stream, would then be fed &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L786&quot;&gt;straight from this
second buffer&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Only when the incoming FIFO is full would
&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;,
attempt to slow down the upstream source.&lt;/p&gt;

    &lt;p&gt;The incoming FIFO would be “full” if it wasn’t getting emptied.  This
would happen if either 1) &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L535-L536&quot;&gt;the memory was full&lt;/a&gt;,
or 2) the &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/49f06ea0219c48a1010f95d72d78ba535b075217/rtl/axivfifo.v#L540-L541&quot;&gt;FIFO couldn’t write to memory fast
enough&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Success, when using this technique, required that the stream bandwidth be
less than 50% of the memory bandwidth.  This will often require that any stream
necessitating a high throughput might first need to be resized to a wider
width–just to reduce the throughput to something the memory can handle.
Remember, when sizing memory bandwidth, there are lots of things that can
use up your bandwidth:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 5. Calculating memory bandwidth&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/mem-bw.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need bandwidth for the data to come in and get written to memory&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need that much again to read the data back out&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll need to allocate time for bus latency.&lt;/p&gt;

    &lt;p&gt;This can be worse for any bus that needs to stop in order to switch
directions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A memory can only read or write on any given clock cycle, and also needs
a couple cycles to switch from reading to writing and back again.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Don’t forget, you’ll also need to allocate some number of memory clock
cycles for refresh.  How many cycles will be required here depends upon
your memory, your bus structure, and whether or not your memory allows
pulling refresh cycles or whether such pulled cycles are supported in your
controller.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Xilinx’s MIG controller also uses a couple of clock cycles per refresh
to keep it’s IO PLL locked on the memories DQS strobe signal(s).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You’ll also need memory bandwidth for everything else that might use the
memory.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In short, &lt;em&gt;it depends&lt;/em&gt;.  The best way to size memory bandwidth requirements is
to calculate how many beats per second you will need, and then make sure
your memory can support perhaps four times that amount.&lt;/p&gt;

&lt;p&gt;A key problem with the standard virtual FIFO, described above, is that there’s
no (good) way to store non-data information such as packet boundaries in
memory.  Either you increase the memory storage requirement to hold a LAST bit
(often by 2x!), or it just gets dropped.  Indeed, my &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/axivfifo.v&quot;&gt;basic AXI virtual
FIFO&lt;/a&gt;
implementation simply drops this data.  As a result, it works well on a
proper &lt;em&gt;stream&lt;/em&gt; interface, but not very well on a &lt;em&gt;packet&lt;/em&gt; interface.&lt;/p&gt;

&lt;p&gt;I have a &lt;a href=&quot;https://github.com/ZipCPU/wbscope/blob/master/rtl/memscope.v&quot;&gt;separate virtual FIFO that I’ve built for my
&lt;em&gt;scope&lt;/em&gt;&lt;/a&gt;,
sometimes called an internal logic analyzer.  (This one’s been formally
verified, but never used in any practical context.  It was fun to build, and
a good learning exercise, it just hasn’t fit into any important usage
scenarios … yet.)  In this case, if the
&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;scope&lt;/a&gt;
ever gets overrun and can’t keep up, all the data will be dropped
and it will start collecting all over again with new data.&lt;/p&gt;

&lt;p&gt;Again, the problem with the stream protocol is
&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;&lt;/em&gt;,
and what to do if you overrun the FIFO, and where/when in your stream processing
will that information be known.  When dealing with packets, the rule
is data needs to be dropped at packet boundaries.  That information needs
to be communicated to the place where the decision can be made.&lt;/p&gt;

&lt;p&gt;So how do we mix the &lt;em&gt;packet&lt;/em&gt; concept with the concept of a &lt;em&gt;virtual FIFO&lt;/em&gt;?
The answer is a virtual packet FIFO.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-virtual-packet-fifo&quot;&gt;What is a virtual packet FIFO?&lt;/h2&gt;

&lt;p&gt;A virtual packet FIFO is simply a virtual FIFO that maintains packet
boundaries.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Virtual FIFO definitions&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/vpktdefns.svg&quot; alt=&quot;&quot; width=&quot;560&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That means two things.&lt;/p&gt;

&lt;p&gt;First, it means we have to preserve packet boundaries.  That &lt;em&gt;LAST&lt;/em&gt; signal
is important when working with packets.  Moreover, packet boundaries need
&lt;em&gt;octet&lt;/em&gt; level precision.&lt;/p&gt;

&lt;p&gt;Second, it means that packets are written to the FIFO before being
&lt;em&gt;committed&lt;/em&gt; to the FIFO.  Only after a full packet has been written to
the FIFO can it ever get committed.&lt;/p&gt;

&lt;p&gt;To handle both of these requirements, I rearranged how I stored packets
in memory.  Instead of storing packet data alone, or packet data plus a LAST
bit, or packet data plus some number of ancillary bits (TSTRB, TKEEP, TUSER,
and TLAST), I store the length of the packet &lt;em&gt;before&lt;/em&gt; the packet.&lt;/p&gt;

&lt;p&gt;Fig. 6 shows this pictorally.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: right&quot;&gt;&lt;caption&gt;Fig 6. Virtual packets in memory&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/vfifo/vpktmem.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Specifically:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;All packet length fields precede the packet they describe.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All packet lengths are 32’bits.  Yes, this is an arbitrary length.
However, 1) this seems to be the smallest bus size I’ve ever needed to work
with.  2) I rarely have more than 4GB of memory, so this seems sufficient.
3) It allows for jumbo packet sizes up to whatever memory size I have on hand.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I also force a minimum 32-bit alignment on all accesses.  So, for a 128-bit
wide bus, this word will be aligned on a 32-bit boundary.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Before a packet is committed, its packet length shall be NULL.  (i.e. 32’h0)
You can think of this like the NULL pointer at the end of a linked list.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The packet data is written to memory using the full width of the bus.&lt;/p&gt;

    &lt;p&gt;In the context of the &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb Ethernet switch&lt;/a&gt;
I’m working on, maintaining memory throughput is important.  As a result, I
need to use the full memory width (512 bits) as often as possible.  Anything
less would reduce my memory bandwidth.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If ever a packet gets dropped, the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;packet
writer&lt;/a&gt;
just goes back to the beginning of the packet data area and starts over
following the NULL packet length word when the next packet starts.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Packets can be dropped for any upstream reason.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Packets are also dropped if the virtual packet FIFO runs out of room.&lt;/p&gt;

        &lt;p&gt;This is a necessary criteria to prevent a deadlock created if the upstream
source never needs to abort, and yet there’s no room in memory to hold
the last of the packet in memory.&lt;/p&gt;

        &lt;p&gt;In order to support packet length pointers, a packet may not be completed
unless there’s room for both the packet length before and the packet
length of the packet to follow.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As I mentioned, I’m now working on building a Virtual Packet FIFO.  It hasn’t
yet been verified, or I’d present the entire FIFO here.  For now, let me point
out the three major components and discuss how they work together:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;There’s the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;Controller&lt;/a&gt;,&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;, and&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You may expect these components to change as they eventually get verified,
and then tested and proven in hardware.  (As of today, only the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;
has passed a formal check, and even that check didn’t properly include the
&lt;a href=&quot;/formal/2020/06/12/four-keys.html&quot;&gt;contract&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Let’s discuss each of these components briefly.&lt;/p&gt;

&lt;h3 id=&quot;the-virtual-packet-fifo-controller&quot;&gt;The Virtual Packet FIFO Controller&lt;/h3&gt;

&lt;p&gt;The controller is responsible for setting the base address and memory size
allocated to the virtual FIFO.  These two values are then propagated down to
both &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;
and &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;.
It’s also responsible for resetting the FIFO, and (depending on the
configuration) releasing it from reset.&lt;/p&gt;

&lt;p&gt;Even though this is only my second virtual packet FIFO, I’ve already had several
diverse needs for this controller.  In one design, the controller was given a
fixed memory allocation.  This is appropriate if the controller is required to
start up and operate without any CPU intervention.  In another design, the CPU
could allocate memory for the FIFO and then enable or disable the FIFO.  When
I can’t decide which of the two I want, sometimes I will generate a combination
of the two, so that the FIFO may start with a default allocation that the CPU
can come back to and adjust later if necessary.&lt;/p&gt;

&lt;p&gt;What happens if the CPU gives it a bad allocation?  One of the challenges of
controller design is determining how the virtual packet FIFO should handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt;.
In general, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; indicates
that the FIFO has a bad memory allocation.  This might be the case if the
CPU has allocated memory to the FIFO that isn’t present in the system.  In
this case, it makes the most sense for the FIFO to shut down with some type of
error condition, and to then wait for the CPU to correct its memory allocation.
On the other hand, if the CPU will get its instructions for “fixing” any faults
from the network, then the network must be able to heal itself without any
CPU intervention.&lt;/p&gt;

&lt;p&gt;A similar problem might be generated by the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
if it ever comes across an invalid packet length word.  Such a packet length
migth be equal to zero, greater than the total size of the allocated memory,
or perhaps just big enough to pass the write pointer.&lt;/p&gt;

&lt;p&gt;In both of these cases, either a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; or an invalid
packet length, there should be an appropriate way to fix the situation.
In a hands-off implementation, the FIFO will need to just reset
itself–hopefully in that case memory allocation issues will be handled before
implementation.  In another case, the FIFO will wait for the CPU to issue a
new address before releasing itself from reset.  The same could be done with
the read packet length, or alternatively the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;packet
reader&lt;/a&gt;
might just skip to where the write pointer is at–skipping any packets in the
way.&lt;/p&gt;

&lt;p&gt;Which method of resolving faults is appropriate depends upon the particular
design requirements.&lt;/p&gt;

&lt;h3 id=&quot;the-write-state-machine&quot;&gt;The Write State Machine&lt;/h3&gt;

&lt;p&gt;Once the base address and memory size are known, and once the FIFO has been
released from reset, incoming packets may be written to memory.&lt;/p&gt;

&lt;p&gt;This takes place in several discrete steps.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, prior to any packet, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L397-L423&quot;&gt;the packet’s length word must be written as
zero&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Then, as packet data enters the FIFO, its data &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L424-L464&quot;&gt;gets written directly to
memory&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Unfortunately, the 32-bit packet length word guarantees that further writes
to memory can not be guaranteed to have any particular alignment.  Incoming
data must then be &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L450-L457&quot;&gt;realigned as it is written to memory&lt;/a&gt;.
This also means that there may need to be &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L483-L488&quot;&gt;N+1 memory writes for
every N memory words&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;A second problem here is associated with the data pointer.  Specifically,
pointers wrap.  Hence, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L226-L237&quot;&gt;any calculation of the next memory
address&lt;/a&gt;
must include &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L232-L234&quot;&gt;a check against the last memory address, and a wrap back
to the first address if it passes the end of
memory&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Finally, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L461-L462&quot;&gt;this is the only place where committed memory space is
checked&lt;/a&gt;.
If a packet uses all of the available memory space, not just the remaining
memory space, then it must be aborted locally.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On any packet &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;s,
the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L435-L440&quot;&gt;write pointer is set to follow the prior NULL
length&lt;/a&gt;.  On a local
packet &lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;, such
as might take place if the packet overflowed memory, then we need to
resync to the beginning of the next packet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once a packet is complete, the next word becomes the length field of the
next packet.  &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L495-L523&quot;&gt;It is set to
NULL&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;After this next word has been set to NULL, the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;FIFO
writer&lt;/a&gt;
can then &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L524-L557&quot;&gt;go back and write the length of the current (just written) packet
into memory&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This is what actually commits the packet to memory.  We can know the
packet has been committed once all bus requests have been completed.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once the bus becomes idle, we tell the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/8e4af12717cfc96611e47b260236e52f5412d95c/rtl/net/pktvfifowr.v#L579&quot;&gt;our new start-of-packet pointer&lt;/a&gt;
and go back to step #2 above to handle the next packet.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All of this is handled via a (monster) state machine that can master the bus.&lt;/p&gt;

&lt;h3 id=&quot;the-read-state-machine&quot;&gt;The Read State Machine&lt;/h3&gt;

&lt;p&gt;Once a packet is committed, a second state machine can then read the packet
back from the bus.  (This one still needs a lot of verification work …)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;First, the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
reads the length word from memory.&lt;/p&gt;

    &lt;p&gt;Knowing when to read this length word is a bit of a problem.  Were this a
piece of CPU software, we might poll this memory word.  If the memory word
was ever non-zero, we’d know a packet was present.  However, this design is
intended for a hardware implementation.  Hardware can poll memory on every
clock cycle, so much so that the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;
wouldn’t have any cycles left to write the packet to memory.  To prevent
this, we’d need to specify a polling interval, which would then increase our
latency.  Supporting minimum latency requires a different solution.&lt;/p&gt;

    &lt;p&gt;My solution to this problem has been to use an out-of-band communication
scheme through the controller.  In this scheme, the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifowr.v&quot;&gt;writer&lt;/a&gt;
tells the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
a pointer to the length word of the last packet committed.  If this address
doesn’t match the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;’s
last memory address, then a packet is present that may be read.
In another version of this FIFO, one with the CPU in the middle, the CPU
provides the reader with the same pointer.  Again, this tells the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
when it’s safe to go and read the packet length counter for the next packet.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Once returned, the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;
then verifies the packet length word.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;It’s not allowed to be zero.&lt;/li&gt;
      &lt;li&gt;The packet length may not pass the write pointer.  This would indicate
a memory overrun condition.&lt;/li&gt;
      &lt;li&gt;The packet length must be less than the size of memory.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;On any failure, we can either reset the entire FIFO, or (alternatively) just
drop all packets between our current location and the write pointer.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If the length pointer is good, we start reading from memory.&lt;/p&gt;

    &lt;p&gt;There are two challenges with this task.  The first challenge is that
the memory will (in general) be misaligned.  The second challenge is that
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; has no
concept of &lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt;,
and our outgoing stream interface may require it.&lt;/p&gt;

    &lt;p&gt;To handle misalignment, we need to keep track of the previously read
memory word.  That, plus the current memory word, both shifted
appropriately, we’ll yield an outgoing stream word.  The trick is that
we may need to read an additional word to get all of the outgoing
stream data associated with this packet.&lt;/p&gt;

    &lt;p&gt;The way to handle
&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt; when using
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; is to
guarantee that we don’t issue a read request in the first place unless
there’s space available in the following outgoing FIFO for a packet word.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One of the nice things about the
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfiford.v&quot;&gt;reader&lt;/a&gt;,
is that we don’t need to generate any
&lt;a href=&quot;/blog/2022/02/23/axis-abort.html&quot;&gt;ABORT&lt;/a&gt;s.  That’s
a pleasant simplification.  Indeed, at this point in our return processing, we
could finally handle (infinite)
&lt;a href=&quot;https://en.wikipedia.org/wiki/Back_pressure&quot;&gt;backpressure&lt;/a&gt; if need be.&lt;/p&gt;

&lt;h3 id=&quot;a-new-interconnect&quot;&gt;A New Interconnect&lt;/h3&gt;

&lt;p&gt;One piece I wasn’t expecting in this new architecture was an updated/better
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As perspective, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;this virtual packet
FIFO&lt;/a&gt;, is
designed to support a &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb, 4-way Ethernet
switch&lt;/a&gt;.  That means I want to be able to
support 10Gb arriving (and departing) on each of the 4 interfaces at the same
time.  When using our planned hardware, the memory will run on a 200MHz clock,
reading (or writing) 512-bits (64-bytes) of data per clock cycle.  However, a
10Gb Ethernet switch will generate one 512-bit word every 51.s ns, or (roughly)
once every 11 clocks at 200MHz.  Hence, when the interface is running full
speed, we’ll be getting requests from rotating controllers.  The first
controller might want a beat, but then not need anything for another 10 beats
while the second controller wants a beat, etc.&lt;/p&gt;

&lt;p&gt;Typically, I run
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; in a fashion
where I burst data to the bus (i.e. to memory) and then wait for the response
before shutting the interface down.  When using Xilinx’s MIG, this can take
up 20 clock cycles of latency.  If I did that here, I’d never have enough
memory bandwidth to keep up.&lt;/p&gt;

&lt;p&gt;My solution to this problem is to use a &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/wbmarbiter.v&quot;&gt;special type of
interconnect&lt;/a&gt;–one
I first developed for an AXI project.  When using &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/wbmarbiter.v&quot;&gt;this
interconnect&lt;/a&gt;, N
masters may request bus accesses of a single slave.  In this case, as each bus
master makes its request, the master’s ID is placed in a FIFO.  Since
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; requests are
always returned in the order they are received, I can then use this FIFO to
route responses back to the appropriate master.  This will allow me to
interleave requests from multiple masters together on their way to memory.&lt;/p&gt;

&lt;p&gt;That’s the good news–more bandwidth.  The bad news is that this N:1 arbiter
will break &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; in
two ways.  First, since there’s no guaranteed concept of the end of a
transaction, there’s no way to know when to lock the bus.  Second, as I
implement &lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt;, a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; terminates any ongoing
transaction.  This means that if N masters are active and only one of those
masters receives a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt;–in
response to some erroneous transaction, then all
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone&lt;/a&gt; masters will
receive a &lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus error&lt;/a&gt; in return to
their ongoing operations.  For now, this will work: 1) these virtual packet
FIFOs will not be locking the bus, and 2) any
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot;&gt;bus errors&lt;/a&gt; should be rare or
even non-existent.  Still, it’s a risk, and I’ll need to make sure it’s
well documented throughout the project.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;This is now the &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;second virtual packet FIFO I’ve
created&lt;/a&gt;.
If any design becomes so useful that you need to build it more than once,
then it’s going to become useful again.&lt;/p&gt;

&lt;p&gt;In this case, this &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;virtual packet
FIFO&lt;/a&gt; will
play an important part of the &lt;a href=&quot;https://github.com/ZipCPU/eth10g&quot;&gt;10Gb Ethernet
switch&lt;/a&gt;) I’m working on.  As packets arrive
from the PHY, their CRC’s will be validated, their &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;stream width
expanded&lt;/a&gt;,
they’ll then &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;cross clock
domains&lt;/a&gt;,
their source MACs will recorded in the router, and they will enter &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;this virtual
packet FIFO&lt;/a&gt;.
Once these packets come out of
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/pktvfifo.v&quot;&gt;the FIFO&lt;/a&gt;,
the’ll go into a separate &lt;a href=&quot;https://github.com/ZipCPU/wb2axip/blob/master/rtl/sfifo.v&quot;&gt;synchronous
FIFO&lt;/a&gt;, have
their destination MACs checked, get routed to an outgoing interface, &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axincdc.v&quot;&gt;cross
clock domains&lt;/a&gt;
(again), have &lt;a href=&quot;https://github.com/ZipCPU/eth10g/blob/master/rtl/net/axinwidth.v&quot;&gt;their widths
adjusted&lt;/a&gt;
back to the interface width, and finally get blasted out the network.  Feel
free to check out
&lt;a href=&quot;https://github.com/ZipCPU/eth10g/doc/eth10g-blocks.png&quot;&gt;this picture&lt;/a&gt; to see
an overview of this entire operation, as well as the status of the various
components required of this project.&lt;/p&gt;

&lt;p&gt;For now, however, the project is still draft.  The hardware, while drafted,
isn’t yet built and I’m still working on the RTL components within it.
&lt;a href=&quot;https://www.blueletterbible.org/kjv/jas/4/15/&quot;&gt;Lord willing&lt;/a&gt;,
I’ll have the RTL done by the time the hardware is available.&lt;/p&gt;

&lt;p&gt;Still, the overall concept of a Virtual Packet FIFO was one I felt would
be worth sharing.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;There is that scattereth, and yet increaseth; and there is that withholdeth more than is meet, but it tendeth to poverty.  (Prov 11:24)&lt;/em&gt;</description>
        <pubDate>Sat, 08 Apr 2023 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/blog/2023/04/08/vpktfifo.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2023/04/08/vpktfifo.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>What is a SwiC?</title>
        <description>&lt;p&gt;Central to the motivation behind the development of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
is the concept of a System within a Chip (SwiC).  As I’m now preparing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; for a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/79a3f19a8ab8b7786319c71019700e86f5918075&quot;&gt;version
3.0&lt;/a&gt;
release, it’s worth revisiting this concept to see what it means and then to
compare that with how the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has been used in practice.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 1. A SwiC consists of a small CPU within a chip&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/swic-concept.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I have defined a SwiC to be a small soft-core CPU within a chip, but
specifically where the CPU is neither the purpose of the chip nor the main
application within it.  Key to this definition is the requirement that the
purpose of the chip is not the CPU nor the application the CPU is supporting,
but rather that the CPU is more incidental to the application.&lt;/p&gt;

&lt;p&gt;Today, I’d like to examine this concept of a SwiC in light of the many years of
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
application and development, to see how well it (or any other CPU for that
matter) lives up to this concept.&lt;/p&gt;

&lt;h2 id=&quot;the-initial-motivation-for-the-zipcpu-gps&quot;&gt;The initial motivation for the ZipCPU: GPS&lt;/h2&gt;

&lt;p&gt;The initial application that motivated the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
was that of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
correlator.  A &lt;a href=&quot;https://en.wikipedia.org/wiki/Global_Positioning_System&quot;&gt;GPS&lt;/a&gt;
correlator consists of a data feed coming from an Analog to Digital Converter
(A/D), possibly entering via a DMA to memory, and correlation outputs–perhaps
even going as far as soft-bit outputs.  The hardware in this case is is
centered on the correlator.  The correlator just reads and then correlates the
data in memory with the spreading code of a GPS satellite.  It requires several
logic &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFTs&lt;/a&gt; and a lot of internal
memory, together with whatever glueware is required to connect them
all together.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 2. Controlling a GPS correlator&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/gps-correlator.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;An example of one such correlator is shown in Fig. 2 on the left.&lt;/p&gt;

&lt;p&gt;So where does the CPU fit in?&lt;/p&gt;

&lt;p&gt;My original plan for the CPU was to have it control which satellite’s ranging
code would be loaded into the correlator, together with estimating which
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt; offsets to search.&lt;/p&gt;

&lt;p&gt;Determining which satellites to correlate against and which
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt; offsets to check
requires a CPU.  The CPU takes an estimate of where the system thinks the user
is on the ground, together with a coarse estimate of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Ephemeris&quot;&gt;ephemerides&lt;/a&gt; for each
of the satellites in the constellation.  It then uses this information to
determine first which satellites are in view, and then second what
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt;
shifts can be expected from each of them.  The better the CPU can do this
task, the fewer correlations that need to be checked and so the sooner the
correlators will lock on to the various satellite signals.  Once lock has been
achieved, the CPU will continue to look for new satellites that might be in
view, and estimate what their
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt; offsets would be
given the receiver’s known location.&lt;/p&gt;

&lt;p&gt;Sure, this task could be offloaded to an external CPU.  But what about the
task of loading the coefficients and setting things up given the satellite
number and the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Doppler_effect&quot;&gt;Doppler&lt;/a&gt; estimate?&lt;/p&gt;

&lt;p&gt;Handling nuisance tasks like this isn’t a major portion of the design logic,
but it is a necessary part.  Further, since the CPU exists, it can also be
used to coordinate reporting and the control of the DMAs to move data around.
It could even be used to take the correlation estimates and turn them into
positions, but in my world that was always handled externally by a full
featured processor.&lt;/p&gt;

&lt;p&gt;This is where I came up with the idea of a SwiC: it’s a small, disadvantaged
computer, occupying a minor portion of a chip which is devoted to another task
entirely.&lt;/p&gt;

&lt;p&gt;As an added benefit to starting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
project, the hardware required for a minimal CPU is also going to be minimal
and even cheap.  In contrast, the hardware required for the correlators
wouldn’t be cheap at all–especially since the algorithm I wanted to implement
was block RAM limited.  Indeed, it may have required a
&lt;a href=&quot;https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html&quot;&gt;VC707&lt;/a&gt;–something I couldn’t
afford at the time, which kept the project from getting off the ground.
The CPU hardware on the other hand?  That would definitely form the cheaper
part of the project.  Indeed, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
even demonstrated its ability to run a small Operating System on a $60 Spartan
6 LX4 (smallest Spartan 6).  This made it easier to justify the business end of
getting started–but I’m getting ahead of myself.&lt;/p&gt;

&lt;h2 id=&quot;properties-of-a-swic&quot;&gt;Properties of a SwiC&lt;/h2&gt;

&lt;p&gt;A SwiC, therefore, must be a small CPU.  It must be small enough that it can
be added to a design as an after thought.  Ideally, it shouldn’t significantly
impact the logic or area requirements of the design, simply because it uses so
few resources.&lt;/p&gt;

&lt;p&gt;That’s the most basic requirement: it must be small.&lt;/p&gt;

&lt;p&gt;Must it be fast?  Not necessarily, although faster is usually better.&lt;/p&gt;

&lt;p&gt;Must it be low power?  Maybe, maybe not.  Again, that depends on your
requirements.&lt;/p&gt;

&lt;p&gt;Like all CPUs, however, a SwiC must be a bus master and it must be able
to communicate with the environment around it.  It must also be responsive
to &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupts&lt;/a&gt; that
may be generated by the application handler.  For example, an interrupt might
tell the CPU that one round of correlation processing had completed.&lt;/p&gt;

&lt;p&gt;These are then the minimum requirements: 1) a small 2) bus master, that is 3)
responsive to &lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupts&lt;/a&gt;.
Further requirements may insist that it be 3) fast and/or 4) low power, but
these are more ancillary than core requirements.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 3. Mandatory interfaces&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/barecpu.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;After that, however, the requirements of a CPU in general start to dominate
the problem space.  To see how this is so, let’s start at the top.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Instruction memory&lt;/p&gt;

    &lt;p&gt;A CPU, by definition, processes instructions in a serial manner.  Therefore
a SwiC, like any CPU, must have access to memory containing instructions.
These instructions are generally constant, so one may often assume the
instruction stream is kept in a ROM.&lt;/p&gt;

    &lt;p&gt;Sadly, there are enough exceptions to this rule to keep it from being
absolutely true.  For example, programs must be loaded, updated, and
modified over time.  It may also be advantageous to move the instruction
memory from an offline storage such as an SD Card into an accessible
memory.  A ROM therefore is a good approximation, but only an approximation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data memory&lt;/p&gt;

    &lt;p&gt;A CPU also needs the ability to store and process data in some kind of RAM.
This means the CPU must have access to a read and writable memory
somewhere, and not just the ROM containing the instructions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Application peripherals&lt;/p&gt;

    &lt;p&gt;Finally, the CPU needs to interact with the part of the design it was
intended to control.  These are application specific peripherals that
may exist in some designs and not in others.  Optionally, these
peripherals may generate
&lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupts&lt;/a&gt;
that the CPU is required to process.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This might leave you imagining a small bare bones CPU, such as the one shown
in Fig. 3 above.&lt;/p&gt;

&lt;p&gt;At least, that’s what you might imagine before you try implementing such a CPU.&lt;/p&gt;

&lt;p&gt;Reality starts to look more like Fig. 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 4. Mapping the SwiC to hardware&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/naiive-flash.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let’s start with how we might go about implementing the instruction memory.
Marrying these requirements to commodity FPGA hardware lends to placing
the instruction memory into
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt;.
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;Flash memory&lt;/a&gt;
tends to be slow, but generally abundant for these purposes.  The problem with
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt; is that
you need a way to program it before activating the CPU.  My general solution
to this problem has been to add a second bus master to any system, something
I call a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus&lt;/a&gt;.
This bus master can then access the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt; to program
it.  As a bonus, the &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debugging bus master can also reach into and control
and/or debug the CPU
itself&lt;/a&gt;.
That’s actually important, since the CPU needs to be kept from accessing the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt;
while it is being programmed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;Flash memory&lt;/a&gt;,
however, won’t pass for data memory.  While it is easy to read from, it is
hard to write to.  So we’ll still need some data memory.  Worse, unlike
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt; where the
common 16MB size is typically more than enough, a CPU’s data memory usage can
quickly expand beyond the capability of any nearby memory.  For example, while
the standard C library can greatly simplify working with a CPU, that same
standard C library may require a minimum of 16kB of memory, and often something
closer to 64kB of memory.  Over the course of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
lifetime, this data memory has been provided by
&lt;a href=&quot;https://github.com/ZipCPU/s6soc/blob/0d7b428abe5c9a02d86a0272e290baafae00f13f/rtl/memdev.v&quot;&gt;block RAM&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/icozip/blob/master/rtl/icozip/sramdev.v&quot;&gt;SRAM&lt;/a&gt;, an
&lt;a href=&quot;https://github.com/ZipCPU/arrowzip/blob/599d5fa02975c693849bb138995b15800d8a36e8/rtl/arrowzip/wbsdram.v&quot;&gt;external SDRAM&lt;/a&gt;,
or even an external DDR3 SDRAM–all depending on the development board hosting
the design.  That leaves us with a minimal system having two bus masters, the
debugging bus and the CPU, and a minimum of three items on the bus: the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;,
data memory, and any application peripherals.&lt;/p&gt;

&lt;p&gt;Adding the application peripherals only makes this worse: we now need a &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;bus
interconnect&lt;/a&gt; that can handle
two bus masters and three or more peripherals.  Many applications also require
access to memory as well, via some form of automated memory transfer or more.
All of these accesses need to be arbitrated.  Hence, a CPU must now have a
general purpose
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;bus interconnect&lt;/a&gt;–something
not necessarily obvious from our minimum requirements above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Minimum SwiC system&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/minsystem.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;When implementing the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, there has
been a small set of peripherals that also keep coming up over and over again.
Fig. 5 on the right shows an example setup including many of these common
peripherals.  The first of these is a console port, by which a user can
communicate with the CPU.  The second is a set of &lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;single bit input or output
wires, what I call a GPIO
peripheral&lt;/a&gt;.
The next two important peripherals are one or more
&lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timers&lt;/a&gt; and an
&lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That means that our simple CPU from Fig. 3 above has now become a much more
complicated design component, even more than Fig. 4 suggested, as shown in
Fig. 5.&lt;/p&gt;

&lt;p&gt;This also means that any minimum CPU can quickly become much more than the
bare minimum CPU we started our outline from.&lt;/p&gt;

&lt;h2 id=&quot;examples-of-the-vision&quot;&gt;Examples of the Vision&lt;/h2&gt;

&lt;p&gt;Now that you know the initial application that motivated the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
let’s take a moment and look at some other applications.  I’ll start this list
off with a set of applications I’ve come across where a SwiC, such as the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, might do nicely.  Then, in the
next section, we’ll discuss the reality of how the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has actually been used.
Let’s start with the exceptionally simple.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;PLL controller&lt;/p&gt;

    &lt;p&gt;Some time ago, a user asked on Xilinx’s forums what the easiest way would
to control a PLL with an AXI4 interface.  A kind helper replied that the
easiest way to control a PLL on chip would be with an AXI4 input driven
by a MicroBlaze computer.&lt;/p&gt;

    &lt;p&gt;Herein lies the problem of the SwiC:  A simple SwiC having 20-100
instructions might’ve solved the problem nicely.  However, if the SwiC needs
access to RAM, &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;,
and an &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;,
then … it might have been easier just to drive the PLL with a &lt;a href=&quot;/blog/2021/12/30/dbgaxil.html&quot;&gt;simple
state machine&lt;/a&gt;
instead of a full blown CPU.  Still, a small SwiC might’ve solved this
problem nicely–even if it was a bit of overkill for the problem.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this level, the SwiC competes with a state machine, and a good state machine
will easily use less area.  However, a good SwiC will only need to be written,
simulated, and verified once in order to know it might properly drive a PLL.
Still, the advantage here goes to the state machine.  Once you need to drive
many dissimilar peripherals, or alternatively once the interaction becomes
sufficiently complex, then a single SwiC might start to make sense again.&lt;/p&gt;

&lt;p&gt;What other uses might one find for a SwiC?&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Power Controller&lt;/p&gt;

    &lt;p&gt;Digilent sells a &lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;small color OLEDrgb PMod&lt;/a&gt;,
suitable for drawing any small image on it.
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;This OLEDrgb&lt;/a&gt;,
however, has some very specific timing requirements associated with when the
various power rails of the OLEDrgb chip within it need to be turned on.
Once the power rails had been turned on properly, the
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;OLEDrgb&lt;/a&gt;
then needed to be configured via a long string of SPI commands.&lt;/p&gt;

    &lt;p&gt;In a system with a hardware
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;OLEDrgb&lt;/a&gt;
controller, a small CPU could easily manage this power sequence, followed
by the required initialization sequence before getting out of the way
of the rest of the hardware.&lt;/p&gt;

    &lt;p&gt;Yes, a state machine might have worked as well.  However, if you have a
state machine to control your PLL, and another one to control your
&lt;a href=&quot;https://store.digilentinc.com/pmod-oledrgb-96-x-64-rgb-oled-display-with-16-bit-color-resolution/&quot;&gt;OLEDrgb&lt;/a&gt;s
power and startup SPI, then the cost of the separate areas for these
separate state machines, and the cost of there respective memory areas, will
soon start adding up.  At some point, the SwiC becomes a cheaper
solution–especially if it can be kept small, and kept from dominating the
rest of the design.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;Flash memory&lt;/a&gt; startup
handler&lt;/p&gt;

    &lt;p&gt;Many of my &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash controller
designs&lt;/a&gt; begin the
interaction with the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt; using &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/b75249d6db61db041008a2a8eafcd62aa0f1d0b5/rtl/qflexpress.v#L388-L751&quot;&gt;a small
startup script&lt;/a&gt;.
This script is necessary to first reset the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
into a known mode, and then second to issue sufficient commands to the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
to place it into its highest speed mode–typically &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;QSPI with a high speed
clock&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;This gets more difficult in an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt; device where the
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt; needs to be
manufactured before the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
device is selected.  The more modern protocols allow for the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
to be queried regarding which modes it supports, followed by issuing
appropriate commands to place the
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt; into a chosen high
speed mode.  This is a complicated enough exchange that it makes the
most sense to handle this in software.  A small SwiC, therefore, might be
useful for this purpose.&lt;/p&gt;

    &lt;p&gt;Here, though, I would note that this should only be required for non–System
on a Chip (SOC) ASIC chips.  If you had a processor available to you on the
chip already, then a simpler solution would have been to start the processor
using &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt; in
its default state (slow SPI), and then to read the necessary instructions
from the &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
to move it into a higher speed state for operation normal operation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;Flash memory&lt;/a&gt; programmer&lt;/p&gt;

    &lt;p&gt;Yes, I once thought to use the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
as a &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt;
programmer on an FPGA.  The problem here lies in how a
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt; is operated.
Basically, a &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash memory&lt;/a&gt;
is divided into sectors and pages.  Writing to a
&lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
device means either erasing a sector (64k Bytes), whereby all
the bits in the sector are set to one, or programming a page (256 Bytes),
whereby one or more bits within that page are cleared.  This means that
programming the &lt;a href=&quot;/blog/2018/08/16/spiflash.html&quot;&gt;flash&lt;/a&gt;
requires &lt;a href=&quot;https://github.com/ZipCPU/openarty/blob/b75249d6db61db041008a2a8eafcd62aa0f1d0b5/sw/host/flashdrvr.cpp#L416-L444&quot;&gt;first 1) reading a whole sector, 2) copying it somewhere, and then
3) determining if the sector needs to be erased as a whole, before 4) one
or more pages within it needs to be programmed&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;While I normally &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;handle this over a serial
port&lt;/a&gt;, the
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;serial port&lt;/a&gt;
can be quite slow for this purpose.  Why, for example, should a whole
sector’s worth of data be read and then written when one might just as easily
write the sector to the CPU’s memory and then have the CPU determine locally
if the sector needs to be fully erased, or only partially programmed?  What
if, even better, the data were compressed when going over the &lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;serial
port&lt;/a&gt;,
and a CPU on the other end uncompressed it?&lt;/p&gt;

    &lt;p&gt;In my case, although I built the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
software necessary to do this, I never quite got annoyed enough to build
the host software that would interact with it in order to finish following
through with the experiment.  Instead, it’s still waiting for me to come
back to it and report on how well it works.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2021/11/15/ultimate-i2c.html&quot;&gt;(Multi) I2C Sensor handler&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;In one project involving a robotic SONAR device, something was needed to
periodically poll and report on multiple voltage level, temperature, and
accelerometer sensor readings and to create a telemetry stream from them.
A first cut of this project suggested the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; could handle this task
quite nicely.  Indeed, communicating with the originally intended sensor
set based upon a Dallas Semiconductor 1–wire protocol would’ve required
something as complex as a CPU to handle this coordination and communication.&lt;/p&gt;

    &lt;p&gt;In the end, I chose not to use the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  The sensor readings needed
strict time stamps, and a minimum of logic was required to guarantee things
would be shut down if the voltage or temperature measurements were ever out
of normal limits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hi-Res &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; test bench&lt;/p&gt;

    &lt;p&gt;One of my earlier projects was to build a &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;high resolution
FFT&lt;/a&gt;.  The algorithm primarily
involved a special pre-processor that would take place before a
&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;traditional FFT&lt;/a&gt;.  The results
on paper and in off-line testing, however, were
&lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;spectacular&lt;/a&gt;.
One individual wrote me, after testing the &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;hi-res FFT
algorithm&lt;/a&gt; on a &lt;a href=&quot;https://en.wikipedia.org/wiki/Frequency-shift_keying&quot;&gt;frequency shift
keyed signal&lt;/a&gt;, at his
amazement that the &lt;a href=&quot;/dsp/freq-teaser.html&quot;&gt;hi-res FFT&lt;/a&gt;
could then distinguish between which “bit” was being sent.&lt;/p&gt;

    &lt;p&gt;This project earns its place on this list, however, not because of the FFT,
nor because of the pre-processor’s implementation, but rather because of the
challenge associated with testing it.  My initial tests involved sending
a tone into the &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;
at a &lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;programmable frequency&lt;/a&gt;,
and then evaluating the sidelobes to see how well the tone was isolated.
The problem?  The amount of data getting sent back and forth rendered
sweeping the tone across all frequencies and examining the data from
it an exercise in patience.&lt;/p&gt;

    &lt;p&gt;This project took place before the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  Had I placed a small
CPU on board, this task might have become much easier: The CPU might have
&lt;a href=&quot;/dsp/2017/12/09/nco.html&quot;&gt;controlled the tone’s
frequency&lt;/a&gt;, and then estimated
the maximum sidelobe–all taking place within the FPGA–reducing the data
requirement over the
&lt;a href=&quot;/blog/2017/06/05/wb-bridge-overview.html&quot;&gt;serial port&lt;/a&gt;
to something much more reasonable, and speeding up the testing significantly.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is just a short list of the sorts of ideas that have motivated my
interest in SwiCs in general.  At least, this describes the vision.  What
about the reality?&lt;/p&gt;

&lt;h2 id=&quot;zipcpu-the-reality&quot;&gt;ZipCPU: The Reality&lt;/h2&gt;

&lt;p&gt;Now that I’ve worked with the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
over the course of several projects, it’s worth asking: how well has this
vision panned out to reality?  To answer that, I’d like to look through
several projects that have included a
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, to see how well the vision
fits or doesn’t.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Doorbell controller&lt;/p&gt;

    &lt;p&gt;One of &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;my earlier projects was a doorbell
controller&lt;/a&gt;.  This probably fits more into
the category of SOC than SwiC, but the story is worth telling anyway.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 6. Our beloved security officer&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/security.svg&quot; alt=&quot;&quot; width=&quot;280&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The background behind this project was a 2AM visitor that … well, I have
   no idea who it was, or why they knocked on our door at 2AM.  (By the time
   I got to the door with my security officer, they were no longer there.)  But
   this got me thinking: it would’ve been nice to turn on the outdoor lights
   when this person rang the doorbell, and to make sure the lights were
   otherwise turned off automatically at night.&lt;/p&gt;

&lt;p&gt;My thought was to use a small FPGA to control the doorbell and outdoor light
   together.  The outdoor light would be turned on initially at dusk, but
   eventually turned off–unless the doorbell rang.  If anyone rang the
   doorbell, the outdoor light would turn on for a period of time.
   That meant that the FPGA would need to know time of day–requiring user
   interaction to set, hence there was a small keypad and a 2–line LED display.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/ZipCPU/s6soc&quot;&gt;this project&lt;/a&gt;, the
   &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
   controlled the light, the keypad, the 2–line display, and the audio
   doorbell.&lt;/p&gt;

&lt;p&gt;Wouldn’t a small microcontroller have been more appropriate?  Perhaps a
   &lt;a href=&quot;https://www.raspberrypi.org/&quot;&gt;Raspberry Pi&lt;/a&gt; or even an
   &lt;a href=&quot;https://www.arduino.cc/&quot;&gt;Arduino&lt;/a&gt;?  Absolutely.&lt;/p&gt;

&lt;p&gt;However, my true purpose was to see how small a system containing the
   &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; could be, and whether or not
   the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; could handle
   &lt;a href=&quot;/zipcpu/2019/11/23/multithreaded-blinky.html&quot;&gt;multi-tasking&lt;/a&gt;.
   The answer was, &lt;a href=&quot;/zipcpu/2021/03/18/zipos.html&quot;&gt;yes it could handle multi-tasking&lt;/a&gt;
   while &lt;a href=&quot;/blog/2017/06/12/minimizing-luts.html&quot;&gt;still fitting on Xilinx’s smallest
   Spartan 6&lt;/a&gt;: the LX4.&lt;/p&gt;

&lt;p&gt;(This project was internally funded …)&lt;/p&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2019/11/14/sdspi.html&quot;&gt;Test recorder&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;In another project, the customer wanted to generate a special communications
signal on an I/O pin.  Part of the project involved deciding what signaling
standard to use, so several were tried to include two different types of
on-off keying and two types of pulse position modulation.&lt;/p&gt;

    &lt;p&gt;In this case, the application used only a small amount of logic within the
FPGA to generate these signals.&lt;/p&gt;

    &lt;p&gt;A more substantial problem was how to record the results from a test like
this.  In this case, the ideal recorder was the FPGA: it had access to
the incoming signals, a large DDR3 SDRAM attached, as well as an SD Card
to make recordings with.  While an SD card can become an ideal medium
for recording data, the challenge is how to deal with the file system
present on the card.&lt;/p&gt;

    &lt;p&gt;Enter the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the
&lt;a href=&quot;https://github.com/ZipCPU/sdspi&quot;&gt;SDSPI Controller&lt;/a&gt;,
and the &lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS&lt;/a&gt; library.&lt;/p&gt;

    &lt;p&gt;The next challenge was how to deliver the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s program to the customer,
who didn’t have the &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/tree/master/hexbus&quot;&gt;debugging bus
infrastructure&lt;/a&gt;
available to him on his host computer in order to load the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
&lt;a href=&quot;https://store.digilentinc.com/nexys-video-artix-7-fpga-trainer-board-for-multimedia-applications/&quot;&gt;The particular board&lt;/a&gt;
we had chosen for this project, however, permitted loading the FPGA from an
SD Card.  Therefore, we chose to load the board from this SD card, and I
placed a boot loader for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
into 64kB of ROM.  (The program required 168 bytes more than the 32kB,
forcing a 64kB ROM built out of block RAM.)  The boot loader would then
walk through a small script to start up the SD Card, and then read a file
from it into memory, before jumping to the first address of memory.&lt;/p&gt;

    &lt;p&gt;Once loaded, the user could interact with the design via a CPU provided
menu, allowing the user to configure the test, capture data, and save any
data captured to a file on the SD card.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.extremesonar.com/projects&quot;&gt;Broadband High-Frequency Active
SONAR&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;A more recent project involved the development of a controller for a SONAR
transmitter.  As with the last project, the amount of logic involved in the
transmitter turned out to be a small portion of the project.  Still, small
or not, it did need to be configured.  A small
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; program attached to
the serial port provided the customer with a way to control the transmitter,
to both turn it on and off, as well as to control the waveform produced by
the transmitter: frequency, pulse duration, pulse repetition rate, chirp,
pseudorandom noise pattern, etc.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Video&lt;/p&gt;

    &lt;p&gt;When first learning about HDMI video, I struggled to get the timing right
to lock onto the HDMI clock using the IDELAYE2 function on my FPGA.  (In
hindsight, I didn’t understand how the IDELAYE2 element worked, and could’ve
greatly simplified this problem …)  While
I couldn’t lock automatically, I could tell if things were locked.  My
solution was to use the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; to
&lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/6e4215b3b6ea96595a4083603636a88a5599604d/sw/board/hdmistest.c&quot;&gt;measure whether or not the received HDMI signal quality was good enough,
and then to adjust the subsample delay timing until it
was&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Also, in &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;the same project&lt;/a&gt;, I had to
deal with the challenge of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Display_Identification_Data&quot;&gt;EDID&lt;/a&gt;
display data.  The &lt;a href=&quot;https://github.com/ZipCPU/videozip&quot;&gt;project&lt;/a&gt;
involved a pass through HDMI signal.  Therefore, the downstream
&lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Display_Identification_Data&quot;&gt;EDID&lt;/a&gt;
information needed to be read and forwarded upstream.  There was an
opportunity for software to adjust things in the middle.  In the end,
however, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;https://github.com/ZipCPU/videozip/blob/6e4215b3b6ea96595a4083603636a88a5599604d/sw/board/hdmistart.c#L157-L158&quot;&gt;just copied the
EDID information from the downstream monitor to the upstream RPi
source&lt;/a&gt; and everything worked.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;One potential customer has asked me about the feasability of
&lt;a href=&quot;https://github.com/ZipCPU/vgasim/blob/dev/rtl/axisvoverlay.v&quot;&gt;overlaying&lt;/a&gt;
graphical information, such as text and/or menus, onto a video stream.  The
FPGA would sample data from a camera, apply some special processing
algorithms to clean up the image, and then forward the results down stream.
It just needed an ability for user control and feedback somewhere. Here,
again, the majority of the processing will take place within the FPGA
logic.  Indeed, it might be possible to do all of the processing in the
FPGA logic without a CPU at all.  The problem was … the technology was
still in development.  While in development, it makes sense to be able to
reconfigure things.  Therefore, the CPU is present to be able to read
&lt;a href=&quot;/dsp/2019/12/21/histogram.html&quot;&gt;histogram&lt;/a&gt; data,
operate on it, adjust scaling constants, and in general
to rearrange the configuration as necessary.&lt;/p&gt;

    &lt;p&gt;In this last case, the CPU may evolve into a more necessary function as well.
Because the project is designed to be a “bump” in the video stream, i.e.
HDMI and power in, maybe a couple buttons, and then HDMI out, any user
feedback regarding the algorithm or its performance will need to be placed
onto the video output stream itself.  This can easily be done with a text
overlay, however a CPU will be required to determine what text to overlay
and where.  Perhaps I’ll even port the &lt;a href=&quot;https://invisible-island.net/ncurses/announce.html&quot;&gt;nCurses
library&lt;/a&gt; to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
and integrate that.  We’ll see, however, as this project develops–assuming
it gets funded in the first place.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt; testing&lt;/p&gt;

    &lt;p&gt;There’s another place where a small soft-core CPU can have a big impact,
and that’s in &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;simulation
testing&lt;/a&gt;.  When building
and &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;testing an ASIC
peripheral&lt;/a&gt; recently, it
helped to be able to simulate the peripheral’s interactions with a nearby
soft-core CPU.  This, of course, requires having a Verilog CPU nearby
which can stimulate the peripheral.&lt;/p&gt;

    &lt;p&gt;Being an open source CPU, or perhaps more because the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was &lt;a href=&quot;/blog/2020/01/13/reuse.html&quot;&gt;internally
sourced&lt;/a&gt;,
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; fit this role quite 
nicely.&lt;/p&gt;

    &lt;p&gt;The proposal ended up being a challenge on two fronts, however.  The
first was speed.  A Verilog test script will always beat a Verilog CPU
in processing speed.  The second was in maintainability.  At some point, I
needed to hand the software to someone else to maintain, and they weren’t
necessarily comfortable with the risk of needing to maintain the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s tool base.  Doh!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you can see from the above examples, the amount of CPU interaction with
the design has ranged from something that might be replaced by a &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/9a83c98a0b2d27d5715813364391cd8860a906ff/hexbus/rtl/hbexecaxi.v&quot;&gt;small
AXI4-lite state machine&lt;/a&gt;,
to something rivaling an SOC in its own right.&lt;/p&gt;

&lt;h2 id=&quot;logic-usage&quot;&gt;Logic Usage&lt;/h2&gt;

&lt;p&gt;How about logic usage?  Let’s take a quick look at logic usage.  Does the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; truly qualify as small enough
to be used in a SwiC?  This question isn’t so easy to answer, since CPU design
always involves a trade off between performance and area.  Specifically, you
can buy more, better, faster performance with more on-chip area.  That means
to compare logic usage, we’ll need to define a feature set to measure logic
usage from.  So let’s define and then compare a couple of configurations:&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 7. Supporting multiple configurations is a hassle&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/config-testing.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ASM&lt;/strong&gt;: If you strip the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; of
every single optional feature, you get to this ASM mode.  I call it the
“ASM” mode because it doesn’t include instructions that the toolchain would
require–such as multiplies, divides, or shifts of more than one bit.  Worse,
because this mode doesn’t include the &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user
mode&lt;/a&gt;, there’s no way
to trap on an unimplemented instruction–the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would either just halt
or restart–depending on its configuration.  This means that any
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; program using this mode will
likely need to be written in assembly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TRAP&lt;/strong&gt;: This is a compromise from the ASM support above.  In this mode,
shift instructions are now implemented, and there’s now a
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user mode&lt;/a&gt; that can
be used to trap unimplemented multiply or divide instructions.  Further,
the LOCK instruction is now implemented, allowing atomic access from
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user mode&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;For those buses that don’t support the LOCK instruction, such as the AXI-lite
bus, the LOCK instruction instead implements a interrupt block–preventing
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; from responding to an
interrupt for three instructions.  Sadly, this includes all of the
Wishbone wrappers prior to the pipelined controller, since the LOCK
instruction would otherwise cause a dead lock: the data bus would hold
the Wishbone cycle line high during the lock operation, and so otherwise
it would lock out the instruction bus interface from fetching the next
instruction.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Minimum&lt;/strong&gt;: This configuration includes support for &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;all
CPU instructions&lt;/a&gt;.
In particular, it also supports the compressed instruction set not
supported by the TRAP configuration above.  This isn’t quite a full featured
configuration, however, since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; isn’t (yet) pipelined.
(That’s the next configuration.)
Instructions, therefore, take a minimum of four cycles to complete.&lt;/p&gt;

    &lt;p&gt;The savings between this mode and the pipelined mode (next) is primarily
captured by the difference between the memory controllers, shared registers,
and some simplified pipeline signaling.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pipelined&lt;/strong&gt;: The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; was
originally designed to be a pipelined CPU.  This configuration turns
pipelining on, while also including a powerful memory controller that’s
not (yet) quite as capable as a cache.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cached&lt;/strong&gt;: This configuration adds a 4kB instruction and a 4kB data cache
to the CPU’s configuration.&lt;/p&gt;

    &lt;p&gt;In general, cache sizes are configurable–but this configuration arbitrarily
uses 4kB caches.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Low Power&lt;/strong&gt;: This final configuration adds both &lt;a href=&quot;/blog/2021/10/26/clk-gate.html&quot;&gt;clock
gating&lt;/a&gt; (unusable on
most FPGAs, but we’ll ignore that for now), as well as zeroing unused
registers for the purpose of lowering the CPU’s power requirements.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Just for review, you can see these configurations compared in Fig. 8 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 8. Comparing the basic configuration options&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/config-comparison.png&quot; alt=&quot;&quot; width=&quot;778&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That covers the configurations of the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/core/zipcore.v&quot;&gt;core of the CPU&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This isn’t sufficient, however, to measure the CPU’s logic usage, since the
CPU needs to be married to a wrapper containing the bus interface and memory
controllers.  Since the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/tree/zipcore&quot;&gt;new ZipCPU
distribution&lt;/a&gt;
supports Wishbone &lt;em&gt;and&lt;/em&gt; AXI-lite and AXI4, there are three basic wrappers:
the &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxil.v&quot;&gt;Zip-AXIL&lt;/a&gt;,
and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxi.v&quot;&gt;ZipAXI&lt;/a&gt;
wrappers.  A &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;fourth
wrapper&lt;/a&gt;,
one I call the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;,
connects the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
to an immediate set of local peripherals: one or two
&lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt controller&lt;/a&gt;s,
three &lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timers&lt;/a&gt;,
a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/zipjiffies.v&quot;&gt;jiffies peripheral&lt;/a&gt;,
some &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/zipcounter.v&quot;&gt;performance counters&lt;/a&gt;,
and a &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/wbdmac.v&quot;&gt;Wishbone DMA&lt;/a&gt;.
Each of these wrappers has a different logic requirement when attached to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/core/zipcore.v&quot;&gt;core&lt;/a&gt;.  So examine them one at a time.&lt;/p&gt;

&lt;p&gt;For accounting purposes, I’ll measure CPU usage in terms of both 4-LUTs on
an iCE40, and Xilinx 6-LUTs.  I will use &lt;a href=&quot;http://www.clifford.at/yosys/&quot;&gt;Yosys&lt;/a&gt;
for the measurements, and &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/usage.pl&quot;&gt;this
script&lt;/a&gt;
to make them automatically.&lt;/p&gt;

&lt;p&gt;Let’s start with the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
area usage, as shown in Fig. 9 on the left.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 9. ZipBones logic usage&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-zipbones.png&quot; alt=&quot;&quot; width=&quot;332&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As you can see from this table, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipbones.v&quot;&gt;ZipBones&lt;/a&gt;
configuration fits nicely in the smallest of areas.  Indeed, I was quite
pleased with myself that the CPU can be made to fit in as few as 576 6-LUTs.
No, it’s not very usable in that configuration, but that’s about as good as
I can get for low-area bragging rights.&lt;/p&gt;

&lt;p&gt;The next wrapper we’re examining is the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;.
As mentioned above, the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;
is not a bare CPU, but rather includes includes several local peripherals:
three &lt;a href=&quot;/zipcpu/2018/04/17/ziptimer.html&quot;&gt;timers&lt;/a&gt;,
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/peripherals/wbdmac.v&quot;&gt;a Wishbone DMA&lt;/a&gt;,
&lt;a href=&quot;/zipcpu/2019/04/02/icontrol.html&quot;&gt;interrupt controller&lt;/a&gt;s,
and more.  As one might expect, there’s a logic cost to these new features,
and this cost can be seen in the
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipsystem.v&quot;&gt;ZipSystem&lt;/a&gt;’s
logic usage chart shown in Fig. 10 on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 10. ZipSystem logic usage&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-zipsystem.png&quot; alt=&quot;&quot; width=&quot;332&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In general, the cost of these extra peripherals runs about 1150 6-LUTs or so.&lt;/p&gt;

&lt;p&gt;The chart for the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxil.v&quot;&gt;AXI-Lite wrapper&lt;/a&gt;’s
logic usage is just a little different.  Specifically, I have yet to build any
AXI-_lite_ cache implementations.  (I have an AXI cache implemention …)
Therefore, the usage chart for AXI-lite shown in Fig. 11 doesn’t have any
cache options to it.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 11. ZipAXI4-Lite logic usage&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-zipaxil.png&quot; alt=&quot;&quot; width=&quot;346&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;For reference, all of these AXI-Lite configurations, prior to the pipelined
one, make use of the &lt;a href=&quot;/zipcpu/2021/04/17/axilops.html&quot;&gt;AXI-lite memory controller we discussed some time
ago&lt;/a&gt;.  As you might guess,
there’s no bus support for the LOCK instruction in this configuration since
AXI-Lite has no support for exclusive access.&lt;/p&gt;

&lt;p&gt;That brings us to the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/zipaxi.v&quot;&gt;final wrapper&lt;/a&gt;,
showing the AXI4 (full) interface logic usage in Fig. 12 on the right.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 12. ZipAXI4 logic usage&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-zipaxi.png&quot; alt=&quot;&quot; width=&quot;332&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This includes the &lt;a href=&quot;/zipcpu/2021/09/30/axiops.html&quot;&gt;bare minimum AXI4 memory controller we
discussed&lt;/a&gt;
for the minimum modes as well.  Since making this measurement, however, I’ve
added an exclusive access option to my &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/beab0639f840ea0673a30d7aaa37e5c055004cfb/rtl/core/axidcache.v&quot;&gt;AXI data cache
implementation&lt;/a&gt;.
So, the numbers may not quite match the current performance.&lt;/p&gt;

&lt;p&gt;Having this kind of information, though, is really cool.  That means that I
can now compare logic usage requirements between the various bus
implementations, as shown in Fig. 13 on the left.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 20px&quot;&gt;&lt;caption&gt;Fig 13. Bus logic usage comparison&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/usage-bus.png&quot; alt=&quot;&quot; width=&quot;520&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One of my contentions has always been that &lt;a href=&quot;https://www.reddit.com/r/FPGA/comments/egkrce/is_axi_too_complicated/&quot;&gt;AXI4 is unnecessarily
complicated&lt;/a&gt;.
Here, you can see that, in spite of the extra complications of working with
the AXI4 bus, the CPU 6–LUT logic usage difference is only 100-200 LUTs
between the Wishbone and AXI4 implementations.  On an FPGA with 200k LUTs,
this difference isn’t a big deal.  On an FPGA with 1,500 LUTs?  A 200 LUT
difference could mean the difference between fitting and not.&lt;/p&gt;

&lt;p&gt;While informative, this bus comparison really isn’t complete.  To be complete,
the comparison should also the cost of the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt; and all of
the peripherals–each of which would magnify the differences shown here.&lt;/p&gt;

&lt;p&gt;When comparing logic usage options, one of the things not shown in these
charts is the cost of a Finite State Machine bus controller such as one might
use instead of a CPU for relatively simple tasks.  For reference, therefore, a
&lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/9a83c98a0b2d27d5715813364391cd8860a906ff/hexbus/rtl/hbexecaxi.v&quot;&gt;simple AXI-lite FSM–based bus
controller&lt;/a&gt;,
reading from a (not-included) memory script, can be made as simple as 88~LUTs.&lt;/p&gt;

&lt;h2 id=&quot;comparison-to-socs&quot;&gt;Comparison to SOCs&lt;/h2&gt;

&lt;p&gt;So, how does a &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
compare against a full blown SOC?  Something like a Zynq, for example?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Hardware support&lt;/strong&gt;.  The Zynq is bigger (i.e. more capable), and supports
more hardware out of the box.  It has hard macros for such things
as DDR3 memory, SD Cards, ethernet, displays, and more.  Further, because
the ARM CPU within the Zynq is implemented out of raw gates, rather than
FPGA fabric, it runs at a much higher clock speed.&lt;/p&gt;

    &lt;p&gt;A SwiC isn’t going to compete well here.&lt;/p&gt;

    &lt;p&gt;On the other hand, the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
memory controller tends to &lt;a href=&quot;/zipcpu/2019/02/09/cpu-blinky.html&quot;&gt;compare favorably to the ARM when measuring
the raw bus access speed of the CPU accessing FPGA
logic&lt;/a&gt;.  I can’t
explain this, but I have seen it multiple times over.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Logic Portability&lt;/strong&gt;.  One problem with the Zynq, or any other SOC for that
matter, is that its peripherals are unique to it.  Some may have a device
independent interface, similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt; for the ability to interact
with a console, but getting to that interface takes a lot of work and
capability away from a raw CPU.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;,
on the other hand, is a soft core CPU.  It can therefore (theoretically)
run on any hardware, and its peripherals can be ported from one piece of
hardware to another for a similar user experience across multiple vendors’
FPGAs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Bare-Bones Programming&lt;/strong&gt;.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; runs quite well without
any operating system.  As &lt;a href=&quot;/zipcpu/2019/11/23/multithreaded-blinky.html&quot;&gt;we’ve discussed
earlier&lt;/a&gt;,
it’s pretty easy to run multiple threads on the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;–even without an operating
system.&lt;/p&gt;

    &lt;p&gt;How does this compare the the ARM within a Zynq?  Frankly, I haven’t written
any bare bones software for the ARM to really know.  I know plenty of others
have, so I know it’s quite doable.  I’d personally be tempted to give
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; the advantage here,
simply because of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
approach to interrupt handling, but my own subjective view of this matter
is hardly definitive and quite likely biased.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Simulation&lt;/strong&gt;. What the Zynq cannot do, however, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; can:
&lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;simulation&lt;/a&gt;.  Since the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is an all Verilog CPU based
upon publicly available Verilog, it can easily be &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;verilated into
C++&lt;/a&gt;,
integrated into the host O/S of the simulator, and therefore offer more
realistic cycle by cycle simulation of a system under test.  If
&lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;simulation&lt;/a&gt;
is what you want, therefore, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; (or any other soft-core for
that matter) easily wins here.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ASIC&lt;/strong&gt;.  If I ever need to build a CPU into an
&lt;a href=&quot;/blog/2017/10/13/fpga-v-asic.html&quot;&gt;ASIC&lt;/a&gt;, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; will be my go to solution.
It’s proven,
&lt;a href=&quot;/blog/2018/04/02/formal-cpu-bugs.html&quot;&gt;verified&lt;/a&gt;,
fits into a small (and controllable) area, and costs less than an ARM.&lt;/p&gt;

    &lt;p&gt;(I might be a touch biased in this opinion.  Use your own discretion.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Having now reviewed the concept of a SwiC, and seen how such a device might
be used, what conclusions might we draw?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;For a single need, an FSM may make more sense&lt;/p&gt;

    &lt;p&gt;Even at it’s lowest logic usage of 576 Xilinx 6–LUTs (plus the &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash
controller&lt;/a&gt;, data
memory, and &lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
which we didn’t count), the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
cannot compete with an 88 6-LUT &lt;a href=&quot;https://github.com/ZipCPU/dbgbus/blob/9a83c98a0b2d27d5715813364391cd8860a906ff/hexbus/rtl/hbexecaxi.v&quot;&gt;FSM based bus
controller&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;Sorry, that’s just not going to happen.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;For multiple needs, an
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;
and console become indispensable.  The measure of the CPU’s impact on the
rest of the system really needs to include these components.&lt;/p&gt;

    &lt;p&gt;Simply put, the more things the CPU needs to control, the more things
it needs to be connected to.&lt;/p&gt;

    &lt;p&gt;Why the console?  Simple: it’s really easy to use, and even easier to debug
with.  Debug by printf() is just so much easier than debug by debugger, or
even debug via &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace&lt;/a&gt;,
that I’d use it in a heartbeat any time I can.&lt;/p&gt;

    &lt;p&gt;Unfortunately, the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt; and DDR3
SDRAM controller by themselves can easily be so costly as to void the whole
SwiC vision.  Why use a SwiC at all, then?  Why not a regular soft core?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Even in the presence of big SOC+FPGA devices, small soft-core CPUs can still
have a big impact.&lt;/p&gt;

    &lt;p&gt;While the impact might be reserved to &lt;a href=&quot;/zipcpu/2021/07/23/cpusim.html&quot;&gt;simulation and
testing&lt;/a&gt;, or vendor
independence only, impacts are still impacts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In most of my actual, real-life use cases, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; hasn’t really fulfilled
my original vision of a SwiC.  Instead, it seems to grow and expand to
fill whatever space is left on my device.&lt;/p&gt;

    &lt;p&gt;On the other hand, perhaps that was the vision–especially since I have
yet to come across a project where the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; won’t fit.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The one thing I haven’t tried, though, is connecting the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s fetch directly to a small
attached block RAM implemented as an instruction ROM.  Doing so would probably
both speed up the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; and lower its
memory usage.  Let me add this one to my to-do list as well.  It won’t be the
first item on my list, though–that’s still finalizing the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; for it’s version 3.0 release.&lt;/p&gt;

&lt;p&gt;Expect to hear more of this in the future.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 14. A short ZipCPU to do list&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/swic/zipcpu-todo.svg&quot; alt=&quot;&quot; width=&quot;640&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Of course, the sad part of this to-do list, like any good to-do list, is that
it just keeps on growing.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Were there is no vision, the people perish: but he that keepeth the law, happy is he.  (Prov 29:18)&lt;/em&gt;</description>
        <pubDate>Mon, 13 Mar 2023 00:00:00 -0400</pubDate>
        <link>https://zipcpu.com/zipcpu/2023/03/13/swic.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2023/03/13/swic.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Debugging the Hard Stuff</title>
        <description>&lt;p&gt;There are a couple of really hard problems in digital design.  These include
debugging &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;s,
cryptographic algorithms, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;Error Correction Coding
(ECC)&lt;/a&gt;.
Debugging a good compression algorithm is also a solid runner up, but it’s
not quite as difficult as the others.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/dbgchallenge.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;What makes these problems hard is the debugging challenge: put simply,
given a failing design, pinpoint the line (or lines) of failing logic.
This debugging challenge is hard because these particular problems don’t
break down easily into visually reducible sub-problems.  That is, it can
be a real challenge when working with problems like these is to first
identify the problem in the trace, and then to be able to walk backwards
from there to the bug.&lt;/p&gt;

&lt;p&gt;Take, for example, an &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;.
Some time ago, a user came to me telling me my
&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;
was broken.  Nonsense I said, it works fine for me.  So he sent me a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD
trace&lt;/a&gt;, and sure enough, the
I&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; of an
&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; wasn’t producing the
input again.
It wasn’t even close.  The challenge here was that this user had introduced
random data into the system.  Because it was &lt;em&gt;random&lt;/em&gt;, it was hard to tell at
every stage what the &lt;em&gt;right&lt;/em&gt; answer should’ve been and therefore where in
the algorithm did the design break.&lt;/p&gt;

&lt;p&gt;How then do you debug these complex algorithms?&lt;/p&gt;

&lt;h2 id=&quot;to-debug-build-new-tools-when-necessary&quot;&gt;To debug: Build new tools when necessary&lt;/h2&gt;

&lt;p&gt;Remember, the goal is to find the one (or more) lines of HDL that are broken.&lt;/p&gt;

&lt;p&gt;Recently, I was asked to do some
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
work.  It started out simple: here’s a working
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
design, now generate a piece of software that will replicate it.
Okay, there’s more to the backstory.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
was part of a non-volatile memory controller, and the customer wanted to
pre-load the device at the factory with data and valid
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
parity bits.  Not a problem, right?  Most, but not all,
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
is just straight linear algebra over &lt;a href=&quot;https://en.wikipedia.org/wiki/GF%282%29&quot;&gt;Galois Field 2
(GF2)&lt;/a&gt;, so this should be basic, no?&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: left&quot;&gt;&lt;caption&gt;Fig 1. ECC wraps the CRC, which then wraps the user data&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/eccpkt.svg&quot; alt=&quot;&quot; width=&quot;360&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The problems got worse from there.  Gee, Dr. Dan, since you’re an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; expert (Wait, what?
I am?), why not maintain some logic for me?  Here’s your first task: a
customer wants 32-bit error correction.  Our standard 16-bit error correction
isn’t good enough for this customer.  Then, once that task was done, the next
task was for a customer who wanted even more error correction than just
32-bits per packet.  Then there was the customer who wanted not just
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;, but an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; protected
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
so that he could tell if the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; ever failed.&lt;/p&gt;

&lt;p&gt;This is all well and good, but how do you debug this stuff?  Remember, the
debugging challenge is to find the line (or lines) of HDL (VHDL or Verilog)
containing the bug.  Also remember, I didn’t write the original logic–I’m
just the one getting paid to maintain it.&lt;/p&gt;

&lt;p&gt;Here’s the method I came up with:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start with a golden reference.&lt;/p&gt;

    &lt;p&gt;This may seem like the hardest part at first.  I mean, if you are building
an algorithm for the first time, how will you know that your golden
reference works properly in the first place?&lt;/p&gt;

    &lt;p&gt;It helps to start with the references from others.  &lt;a href=&quot;https://www.amazon.com/Numerical-Recipes-Scientific-Computing-Second/dp/0521431085/&quot;&gt;Numerical Recipes in
C &lt;/a&gt;
publishes the C source of an
&lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt; algorithm that I’ve since
used often.  There’s even a &lt;a href=&quot;https://www.amazon.com/Numerical-Recipes-Art-Scientific-Computing/dp/8175960965&quot;&gt;Numerical Recipes in
C++&lt;/a&gt;,
which I would expect is the same recipes but with an updated coding
standard.  Then there’s the “Advanced Encryption Standard” (AES), which
includes an appendix showing what the outputs should look like at each
stage of the encryption standard given a known key and a known input.
There’s also at least one &lt;a href=&quot;https://opencores.org/projects/tiny_aes&quot;&gt;AES algorithm on
OpenCores&lt;/a&gt; that you might use.
In general, references are available for your work with digital design,
you might just need to spend some time looking for them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add debug &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$display&lt;/code&gt; statements to the design, and make them both human
readable and computer friendly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use those debug statements to feed the golden reference.&lt;/p&gt;

    &lt;p&gt;This is the key feature I’ll be discussing in a moment.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now look for the first difference between the reference and any broken 
trace.&lt;/p&gt;

    &lt;p&gt;Remember, the golden reference &lt;em&gt;works&lt;/em&gt;.  Therefore, any discrepancy or
other difference between the golden reference and your design will be
something you want to dig into.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s walk through how this works, by discussing the last
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
problem I worked on: adding a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
to a memory controller, prior to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
parity generator and then checking it at the back end.&lt;/p&gt;

&lt;p&gt;What made this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
task challenging was that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
parity bits were packed together–even across byte boundaries.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; bits, therefore,
needed to be packed together with the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
parity bits.  Not only that, both needed to be gathered together and assembled
separate from the data itself.  Together, this created data blocks looking
somewhat like Fig. 2 below when transmitted.  (Note that the Fig 2. is not
drawn to scale by any means.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. Data backs consisted of data blocks, followed by CRC then parity&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/packet.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The original algorithm I was given handled this via a combined shift
register and memory implementation that had grown to over 2k lines
of Verilog.  It read like a series of cascaded case statements: if this
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
option, this data block size, the data block number, then adjust these bits,
etc.)  Indeed, by the time I started working with this logic, it had
gotten so repetitive that I was using a C++ program to write and update these
thousands of lines of Verilog for me.  Now, this may have been fine originally,
for the simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
codes this controller was originally built to handle, but the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
bit-vector had now grown to over 7k bits, each individually accessed, and none
able to be optimized into memory properly.  It got so bad that this part of
the algorithm was starting to dominate the total area cost–and I was going to
add &lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;s
to this mess?  No, that wasn’t going to happen–not without a rewrite.&lt;/p&gt;

&lt;p&gt;So, I rewrote the algorithm with a proper gearbox coupled with a proper FIFO.
Moreover, in the hopes that I might be able to reuse the implementation, I
built the gearboxes using standard interfaces: AXI stream, VALID, READY, LAST,
etc, and I even parameterized the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
size so the customer could change it at a later time if they wished to.  All
told, the new implementation took just over 1k Verilog lines of code, and at
least half of that was either comments or formal properties.  That meant
there was a rough 4x reduction in the number of lines of code.  Does this
mean the design is simpler?  In this case, definitely!  It was both simpler
to understand, easier to see what was going on within it, and therefore
simpler to maintain.  The giant tables had been replaced.  The new design
also used less area, so we’re good all around.&lt;/p&gt;

&lt;p&gt;But, how to debug this?&lt;/p&gt;

&lt;p&gt;To give you an idea, then general test setup I was given looked something like
Fig. 3 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. Test bench setup&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/dbgpath.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;A test bench script would drive the entire test.  This script would generate
commands to write pseudorandom data to the memory device.  Then, once all the
data had been written, the script would command an error generator to
insert errors into the read path, and then generate commands to read from
the memory device.  The results would be compared against the data written to
the device.  If (and &lt;em&gt;only&lt;/em&gt; if) the number of errors inserted was beyond the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;’s
correction ability, then the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
failure flag was to be set.  In all other cases, the data returned from the
device was required to match the data sent to it.&lt;/p&gt;

&lt;p&gt;Now consider all the steps involved in this process, and ask yourself where
and how would you debug all of this?&lt;/p&gt;

&lt;p&gt;The (obvious) answer should be: starting with unit tests.  Each individual
unit should be tested and verified separately, and known to work before
being integrated into the larger whole.  For unit tests, I turn to formal
methods.  One of the things I like about formal methods is that, any time you
get a property (i.e. an assertion) failure, that failure will lead you directly
to the failed assertion, which is usually nearby the logic it defends, and so
formal methods will typically find bugs in about 5-10 steps.  In my case here,
the gearboxes required 40 steps.  Why so many?  Because of a technical problem.
Formal methods don’t handle division very well, and a full induction description
would require that the formal methods implement a divide.  As a result, I
didn’t get induction working.  Still, 40 time steps was enough to give me
strong confidence the gearboxes worked.&lt;/p&gt;

&lt;p&gt;My next step was to use a bench test with
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;.
You can see this basic setup in Fig. 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. Verilog unit testing&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/vgolden.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this case, the &lt;em&gt;unit&lt;/em&gt; under test was the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
block separated from the
rest of the design.  In particular, this unit testing approach allowed me
to separate my test from the AXI bus interface, the device interface, and the
device model.  Data came into the test design via the AXI stream protocol,
and then the same protocol was used to take data back out once encoded or
decoded.  Still, as you can see from the figure, the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
block under test wasn’t quite the &lt;em&gt;working&lt;/em&gt; design given to me, but
rather my modified version of it, now containing
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;
generation and checking.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;caption&gt;Fig 5. Test vector choice&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/tbdesign.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One key to this type of testing was the test vectors chosen.  For example,
when building an &lt;a href=&quot;/dsp/2018/10/02/fft.html&quot;&gt;FFT&lt;/a&gt;,
you’ll want to use both impulses and sine waves.  Since this is
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;, i.e. linear math
over &lt;a href=&quot;https://en.wikipedia.org/wiki/GF%282%29&quot;&gt;GF2&lt;/a&gt;, I started with vectors of
all zeros, and then vectors with a single bit set, and only then a small number
of countable bits set.  From there I moved on to all bits set and then random
settings.&lt;/p&gt;

&lt;p&gt;What if the design fails with random data?  In that case, you just reduce the
random data vector back to the relevant basis vectors, and try again.&lt;/p&gt;

&lt;p&gt;Thankfully, it wasn’t too difficult to get this
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
based test bench working.
In general, the trace led me straight to any bugs–well, that and the fact that
I knew that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
algorithm worked initially, so the only thing that could’ve
broken would be associated with one of my changes.  That meant that this
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
test bench could then become my “golden reference” model.&lt;/p&gt;

&lt;p&gt;Once things worked in this “golden” model, I could then integrate this updated
design back into the memory controller it was originally a part of. 
Not only that, but remember this was a maintenance task.  In other words,
I needed to modify logic someone else had written years ago, logic that
I wasn’t familiar with–a recipe for problems, no?&lt;/p&gt;

&lt;p&gt;This brings us back to the integrated test bench design shown in Fig. 3.
The good news is that we come into this integrated test design with something
known to work.&lt;/p&gt;

&lt;p&gt;Now, let me point out a problem with the type of integrated testing shown in
Fig. 3: the test bench script won’t notice any data failures until late in
the process.  This is just the nature of the perspective of a black box.
Data will first need to be written to a staging area, then pushed through
the device path, transferred to the external memory device model, then
transferred back, then copied out of the controller–and only then would any
errors be noted and flagged–all in good &lt;a href=&quot;https://en.wikipedia.org/wiki/Black-box_testing&quot;&gt;black box testing
fashion&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This wonderful &lt;a href=&quot;https://en.wikipedia.org/wiki/Black-box_testing&quot;&gt;black box
testing&lt;/a&gt;
fashion might be great for proving that a
design does what it is supposed to, but it is horrible for telling you what
fails when it fails.  Why?  Because the failure isn’t noticed until microseconds
of simulation time later, and only after thousands of data transfers.  That’s
a lot of trace you have to back through manually to find any bugs.  There’s
another word for that: pain.&lt;/p&gt;

&lt;p&gt;This is where the debugging statements came into the design.  To show you what
I mean, the following lines have been clipped from the design.  First,
as every word went into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;, and now the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt;+&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
algorithm, I dumped it to the simulation log.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;	&lt;span class=&quot;k&quot;&gt;localparam&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;OPT_ECC_DEBUG&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mb&quot;&gt;1'b1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OPT_ECC_DEBUG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GEN_ECC_DEBUG&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_enabled&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_data_valid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_data_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-TX: %08x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_data_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can call this test point #1.&lt;/p&gt;

&lt;p&gt;Once an entire block of data had gone through the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
encoder, it would then generate parity bits.  I dumped these to the same
log as well.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_enabled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_parity_valid&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_parity_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-TX: RES&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PARITY_BITS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; %04x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx_parity_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ik&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;(This test point doesn’t get a number, because my diagram in Fig. 3
doesn’t really show this part of the path very well.)&lt;/p&gt;

&lt;p&gt;I repeated the same process on receive.  As data came into the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; decoder,
it was also dumped to the log.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx_data_valid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_enabled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx_data_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-RX: %08x -- LAST at %t&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
							&lt;span class=&quot;n&quot;&gt;rx_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-RX: %08x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can call this test point #2.&lt;/p&gt;

&lt;p&gt;Before moving on, I should point out a key feature of this test point that
I don’t want to pass up, and that is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$time&lt;/code&gt;.  One of the challenges of
working with both simulation logs and trace files together is synchronizing the
two.  That’s where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$time&lt;/code&gt; comes in handy, and I’ve gotten to using it in
this manner often.  Because this test point outputs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$time&lt;/code&gt;, I can now use
the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$time&lt;/code&gt; in this log to find the associated step in the trace and to
then see the context associated with this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$display()&lt;/code&gt; function call.&lt;/p&gt;

&lt;p&gt;Finally, when the decoder made it’s error correction decisions, those were
also dumped to the log.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-verilog&quot; data-lang=&quot;verilog&quot;&gt;		&lt;span class=&quot;k&quot;&gt;always&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;posedge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i_clk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i_reset_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_enabled&lt;/span&gt;
				&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_data_valid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_data_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ECC-MASK: %08x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecc_data_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We can call this test point #3.&lt;/p&gt;

&lt;p&gt;For reference, you can see all of these test points in Fig. 6 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 6. Test points&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/testpoints.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first step to analyzing this log file was to search for all lines
starting with “ECC-“.  In the future, if I do this again, I’ll probably write
to a specific
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
log file, but for now these messages were dumped together
with the rest of the simulation log.  The good news is that the rest of the
simulation log provides the context for what’s going on.  The bad news is that
dumping 16kB of data for an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
engine doesn’t make a pseudo human-readable log any more legible.  Because
of the mess this makes of the simulation log, I’ve gated all of this logic
with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OPT_ECC_DEBUG&lt;/code&gt; parameter and only turn the parameter on when I
need to.&lt;/p&gt;

&lt;p&gt;Even before building any better capabilities, this helped: it allowed me to
see the data going into the gearboxes, and then coming out again.  I could
then make sure that things were lined up properly.&lt;/p&gt;

&lt;p&gt;It wasn’t enough.&lt;/p&gt;

&lt;p&gt;One particular problem was that the TX and RX data were so far separated in
time.  That made it difficult to tell whether any problem lied between
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt; components, such
as in the transmitter to the device, the memory model, the test-bench error
generator, or the receive logic on the other end.  However, it wasn’t all
that hard to generate a simple C++ program to process this pseudo human-readable
data, to place the TX data next to the RX data and then notice if anything had
changed.  This one piece of software alone helped me catch nearly all of my
bugs.  (Remember, I started with a &lt;em&gt;working&lt;/em&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
design–that means most bugs should be confined to my changes alone.
Unfortunately, I changed a lot of stuff.)&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 7. Feeding the golden reference model&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/binfile.svg&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;That software alone, however, wasn’t sufficient.  It was close, but not quite
there, and this is where today’s particular problem comes into play: because
&lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
is a challenge to debug, I needed to know more of what was going on &lt;em&gt;inside&lt;/em&gt;
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_correction_code&quot;&gt;ECC&lt;/a&gt;
algorithm.  This is where the third debugging step comes
into play: feeding the golden reference model.  That is, I adjusted my
log reading program so that it could generate a binary file that could then
be ingested into my golden reference model, as shown in Fig. 7 above.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;padding: 25px; float: left&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/feedref.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;At one point, it was only by comparing the trace coming out of the golden
reference model with the one from my larger integrated test environment that
I found the bug.  One of the bugs I found was even in
the &lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
translation of my Verilog, and so I thank the
&lt;a href=&quot;/blog/2017/06/21/looking-at-verilator.html&quot;&gt;Verilator&lt;/a&gt;
team, and in this case Mr. Snyder in particular, for fixing it quickly.&lt;/p&gt;

&lt;h2 id=&quot;customers&quot;&gt;Customers&lt;/h2&gt;

&lt;p&gt;I wish I could say this was the end of the story: the design worked, and should
now be shipped.  Sadly, it wasn’t.  Three further problems then turned the
simple update listed above into a nightmare for both my team and our customer.&lt;/p&gt;

&lt;p&gt;First, as a simple background, let me set the stage: I offered to make this
maintenance upgrade for a simple two weeks of work.  The updates were simple
enough, they should’ve only taken two weeks.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/eccdbg/requirements.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;It was only once those two weeks were over that the challenges began.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Once I was ready to turn in the work, the customer started demanding
other changes.  (Changes that they had no intention of paying for …)
Worse, they were asking for fundamental changes which would force me
back to the drawing board for this design.&lt;/p&gt;

    &lt;p&gt;The laughable part of these demands?  In the same breath they asked for
a fundamental redesign, they also asked for the current design to be
shipped in order to support their RTL freeze date in less than two more
weeks.  Then they were upset when we didn’t deliver according to their
schedule, when they were the ones who changed the requirements mid-task.
Seriously.  You just can’t make this stuff up.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;One problem I wasn’t expecting was that the memory device model implemented
address regions not present in the actual memory device.  Adding a four byte
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclic_redundancy_check&quot;&gt;CRC&lt;/a&gt; required all
of the addresses within to be updated to make room for these extra four
bytes.  How many places did these addresses need to be updated in?  Let’s
just say that I really dislike &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic
numbers&lt;/a&gt;, since
their usage in this project by the prior developer made this part of the
update all the more painful.&lt;/p&gt;

    &lt;p&gt;You can read some more of &lt;a href=&quot;/blog/2022/09/21/vlog-wait.html&quot;&gt;my thoughts on test bench design
here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The last problem was a repository merge nightmare.  Sadly, I had made my
changes to a design that wasn’t the “latest” design–the customer had
submitted changes to the design that I was unaware of.  I didn’t discover
this until after I had turned my changes in.  Then I discovered I was
about two versions behind the official latest version.  Bugs discovered
here were …  anything but what I was expecting.&lt;/p&gt;

    &lt;p&gt;For example, one of the test scripts depended upon a 1000 clock cycle
reset.  This script would wait 100 cycles, then set a “fixed” value that
needed to be referenced when the design came out of reset.  The test bench
script then then waited for the signal that this (optional) startup process
had taken place.  Not knowing this, I had come along and tried to speed
up the simulation by switching to a 3-cycle reset and … all kinds of
regression hell broke lose when the two “working” designs needed to be
merged.  Was there any documentation discussing why a 1000 clock cycle
reset was necessary, or why a key reset input wouldn’t get set until 100
clock cycles into the simulation?  Well, one might hope.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The end result was that I spent another 2-3 months, beyond the 2-week update
task, working on the test bench, rebuilding the model, fixing &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_number_(programming)&quot;&gt;magic
numbers&lt;/a&gt;,
fixing &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)&quot;&gt;the many places the same task was
accomplished&lt;/a&gt; in error, and more.&lt;/p&gt;

&lt;p&gt;My simple two week task?  Sure, it took two weeks to do.  It then took another
two months arguing with the customer over what the requirements needed to be.
Another month was then spent chasing down bugs associated with merging
the repository, and then another two were spent dealing with further
consequences of the original merge as they continued to ripple through the
&lt;a href=&quot;/blog/2022/09/21/vlog-wait.html&quot;&gt;test model and test script
library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And the customer?  The customer wanted to know why the design couldn’t be
delivered the same afternoon that I submitted my changes to the official
repository.  Worse, they are now convinced that the problems associated with
these updates are due to the unreliability of the IP they purchased, rather
than rippling consequences of the changes they made working their way
through the design.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;When faced with a really &lt;em&gt;hard&lt;/em&gt; HDL problem, consider using a golden
reference model and comparing your design against that reference.  Any
differences between the two should lead you directly to any bugs.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/tweets/bible/diligence.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As for difficult customers?  Be honest.  Smile, and do your best.  There will
be other customers.&lt;/p&gt;

&lt;p&gt;Oh, and the end of this tale?  I’m now working to port those same changes to
another controller, which means I get to reuse both my golden reference model,
as well as the software I used to reformat the data into something that could
be ingested into it.  Once I post this article, I’ll go back to looking for
the differences between the two.  The good Lord only knows what I’ll find
at this point.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Be careful for nothing; but in every thing by prayer and supplication with thanksgiving let your requests be made known unto God.&lt;/em&gt;</description>
        <pubDate>Mon, 13 Feb 2023 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/blog/2023/02/13/eccdbg.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2023/02/13/eccdbg.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Your soft-core CPU won't boot.  Where should you start debugging?</title>
        <description>&lt;p&gt;When I first decided to start &lt;a href=&quot;/about/gisselquist-technology.html&quot;&gt;Gisselquist
Technology&lt;/a&gt;, one of my
first internal projects was to see if I could get the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt; kernel to boot from a read-only
file system–to promote longevity on a flash device, using a kernel that I
could swap out remotely at a later time via a call to
&lt;a href=&quot;https://wiki.archlinux.org/title/kexec&quot;&gt;kexec()&lt;/a&gt;.  I intended to
do this using a &lt;a href=&quot;https://beagleboard.org/black&quot;&gt;Beagle Board Black&lt;/a&gt;, and then
to sell the capability to a customer as something they could do with their
own internally developed boards.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/blank-screen.svg&quot; alt=&quot;&quot; width=&quot;320&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;So, I made a bunch of kernel configuration changes, and then tried to boot
my newly configured kernel.&lt;/p&gt;

&lt;p&gt;Nothing happened.&lt;/p&gt;

&lt;p&gt;I just stared at a blank screen.&lt;/p&gt;

&lt;p&gt;At the time, I had no idea where to start.&lt;/p&gt;

&lt;p&gt;Since that time, I’ve gone on to build &lt;a href=&quot;/about/zipcpu.html&quot;&gt;my own
CPU&lt;/a&gt;.  In other words, I’ve now had
to deal with this problem many times over, where I “start” my CPU and
nothing happens.  No, I haven’t gone back to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
kernel, but I’ve
still had the same basic problem.&lt;/p&gt;

&lt;p&gt;There is one key difference, however: with a soft-core CPU, 1) I know my
hardware (I never knew the ARM that well), and 2) I can run a
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
of that hardware and &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;get a
trace&lt;/a&gt;
leading me straight to the problem.  (Yes, this is a
painful approach, but it is a reliable one.)&lt;/p&gt;

&lt;p&gt;So, let me offer you some of the lessons I’ve learned while trying to debug
the startup of the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.
Specifically, how shall the CPU be debugged between when it is released from
reset and the first (successful) call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt;?&lt;/p&gt;

&lt;h2 id=&quot;how-to-debug-a-boot-failure&quot;&gt;How to debug a boot failure&lt;/h2&gt;

&lt;p&gt;So, let’s look into how one might debug a “boot failure”.  In this case, by
“boot failure”, I mean that you’ve “loaded” both your soft-core CPU either
into &lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
or onto an FPGA, and your program onto your memory device
and then something goes wrong between &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;releasing the CPU from
reset&lt;/a&gt;
and the first console output.  The question here and now is, how do you
debug that?  I mean, a CPU represents a lot of logic to dig through, and
there’s a lot of software between reset and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;.  How do you go about
narrowing down the problem to find the bug?&lt;/p&gt;

&lt;p&gt;Here’s some of the approaches I’ve found valuable.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start at the &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction
fetch&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;My first step is almost always to look at a
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
trace of the &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction
fetch&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;For this, you’ll first need a hex dump of the program you are trying to run.
I usually get this from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;objdump -S -D &amp;lt;program&amp;gt;&lt;/code&gt;.  Indeed, I use this
command so often, I have a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/board/Makefile#L80-L81&quot;&gt;common “make”
target&lt;/a&gt;
that I will use to produce this dump file.&lt;/p&gt;

    &lt;p&gt;Now, looking at the dump file, open a &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;simulation
trace&lt;/a&gt; and look at the
address and value of the first several instructions coming from the
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction fetch&lt;/a&gt;
and going to the CPU’s core.  These address/value pairs
should match a dump of your executable file.&lt;/p&gt;

    &lt;p&gt;If they don’t match, that should tell you where to look next:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Reset problems&lt;/p&gt;

        &lt;p&gt;Are you getting any instructions from the
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction fetch&lt;/a&gt;
at all?  If not, you might have a bug in your &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;reset
control&lt;/a&gt;.
Does the CPU come out of reset at all?  If it does, does it come out
of reset reading from the right address?&lt;/p&gt;

        &lt;p&gt;It can be a challenge to get a CPU, configured to boot from a
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash memory&lt;/a&gt;
address, to start from a different address describing some other memory
that might be easier to work with–such as block RAM.  I often do this to
initially verify the CPU, before verifying the
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash memory&lt;/a&gt;, but
getting a program to load and start properly from somewhere other than the
reset address can be a true test of both the loader and the &lt;a href=&quot;/zipcpu/2017/07/26/cpu-sim-debugger.html&quot;&gt;CPU’s
debugging port&lt;/a&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Loader&lt;/p&gt;

        &lt;p&gt;Did your software get loaded into the right place?  That is, if the CPU
is coming out of reset properly, and if it is reading from the right
addresses, is it getting the right values?  If not, then this is worth
chasing down through the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace&lt;/a&gt;.
You might find that you haven’t loaded the right values into memory in
the first place.  (Or … you might also find that either your
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction fetch&lt;/a&gt;
unit, your
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt;, or
your memory controller are broken ….)&lt;/p&gt;

        &lt;p&gt;In my case, I often need to be reminded that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;big 
endian&lt;/a&gt; machine while my host
computer is a x86 type of &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;little
endian&lt;/a&gt; machine.  Sometimes
a translation is required between the two.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/nfs.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Memory controller problems&lt;/p&gt;

    &lt;p&gt;Before you start your CPU, it’s often worth double checking the load
interface.  After writing to address XYZ, for example, can you read the
same value back from address XYZ that you have just written to it?  This
problem may be indistinguishable from a loader problem.  In both cases,
values will be read from memory, but they won’t be the right values.&lt;/p&gt;

    &lt;p&gt;To tell the difference between loader and memory controller problems, pick
one address that the
&lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;fetch&lt;/a&gt;
returns in error and track what’s written to it.
If the loader puts the right value into it, but the memory controller
returns something else, then you know to look into your memory controller
for the bug.  We’ll come back to this again in a moment.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/financial.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;You can often dig into this bug using a &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
  bus&lt;/a&gt;: While &lt;a href=&quot;/zipcpu/2017/07/14/cpu-debugging-needs.html&quot;&gt;holding
  the CPU in
  reset&lt;/a&gt;,
  write to the memory that will hold it’s program and then
  read the memory values back out.  They should match.  This doesn’t always
  work, however, since the CPU might use types of accesses to the memory
  that the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debug bus&lt;/a&gt;
  &lt;a href=&quot;/2021/12/30/dbgaxil.html&quot;&gt;doesn’t support–things like
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARLEN&amp;gt;0&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARBURST=WRAP&lt;/code&gt;&lt;/a&gt;–but
  it’s at least a good start.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/why-auto.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Bus addressing&lt;/p&gt;

    &lt;p&gt;There’s always the possibility that you have an error in how the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;bus interconnect&lt;/a&gt;
was set up.  Perhaps the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;bus interconnect&lt;/a&gt;
is routing the CPU’s reset address to the wrong slave, perhaps you have
the wrong number of address wires driving the slave.  Either way, you’ll
see this problem when tracing the instruction request from the CPU back
to the bus slave responding to it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol start=&quot;2&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; is just a bunch of memory copies.  Look for the loops.&lt;/p&gt;

    &lt;p&gt;The first piece of software any CPU starts is often known as
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;.  This
is the software that sits between reset and main().  This is the software
responsible for placing your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; program into memory.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;caption&gt;Fig 1. CRT0 is primarily a bunch of memory copies&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/crt0.svg&quot; alt=&quot;&quot; width=&quot;480&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first thing
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
   needs to do is to configure your RAM or ROM controllers.  The next step
   is usually a series of memory copies.&lt;/p&gt;

&lt;p&gt;On many computers, &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
   is written in assembler.  While I tried to avoid that with the
   &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, there’s still &lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/bc3ced1d51c975b20877d39aac0a578a461835f5/sim/zipsw/zlib/crt0.c#L165-L219&quot;&gt;a small
   assembly routine required&lt;/a&gt;
   before I can transition to the C function that performs the actual
   memory copies–&lt;a href=&quot;https://github.com/ZipCPU/zipcpu/blob/bc3ced1d51c975b20877d39aac0a578a461835f5/sim/zipsw/zlib/crt0.c#L266&quot;&gt;a function I’ve named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;&lt;/a&gt;.
   The small assembler script is responsible for any hardware configurations
   necessary to get the RAM running, for then setting the
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;,
   and finally for calling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; function.  This is marked
   as step 1 in Fig. 1 above.  Because this step is so small, typically
   less than 20 instructions, it can easily be debugged using the
   &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD trace file&lt;/a&gt; if necessary.&lt;/p&gt;

&lt;p&gt;This is not the case with the step that follows.&lt;/p&gt;

&lt;p&gt;The first step of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; function, marked as step 2 in Fig. 1,
   is a big memory copy.  It will &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c#L324-L333&quot;&gt;copy instruction memory from ROM to RAM&lt;/a&gt;,
   and then again to &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c#L324-L333&quot;&gt;copy any pre-initialized global variables from ROM to
   RAM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Debugging this memory copy can be a challenge.&lt;/p&gt;

&lt;p&gt;So how do you go about debugging a
   &lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;?
   That piece of software 
   is just a huge loop!  The CPU may be copying millions of bytes, and
   so staring at this trace can quickly get frustrating.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/zippc.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here’s the trick: instruct your
   &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;VCD&lt;/a&gt;
   &lt;a href=&quot;https://gtkwave.sourceforge.net&quot;&gt;viewer&lt;/a&gt;
   (I use &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;)
   to display the CPU instruction address register, often called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;program
   counter or PC (for short)&lt;/a&gt;,
   as an “analog” waveform.  Then zoom out.  Watch how this waveform changes,
   and you’ll quickly find where the loop begins and ends.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure the bus doesn’t freeze up while reading.  This is often a sign
that you didn’t formally verify a bus component.  It could be either
&lt;a href=&quot;https://zipcpu.com/zipcpu/2021/04/17/axilops.html&quot;&gt;CPU’s memory
controller&lt;/a&gt;, the
hardware memory controller, or the
&lt;a href=&quot;/blog/2019/07/17/crossbar.html&quot;&gt;interconnect&lt;/a&gt; between
the two.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Look for loops that do not end.  This is often a sign that either the
CPU can’t execute the instructions you think it can, or that the CPU
is reading the wrong data from memory.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now debug the beginning and ending of these loops&lt;/p&gt;

    &lt;p&gt;If the first word is correctly copied into memory but the last word is not,
then bisect the loop as many times as necessary to find the bug.  Perhaps
you are copying from a device that isn’t as big as you think it is?
Perhaps you have an incorrect copy size?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One problem I’ve often had here can be traced to trying to use one
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
   routine for many hardware situations.  For example, sometimes I’ll have a
   high speed (block RAM) address range to copy memory to in addition to a
   (slower speed) SDRAM address range.  To tell the difference, I need to
   check this block RAM address against NULL &lt;em&gt;after linking&lt;/em&gt;.  However, GCC
   will often &lt;em&gt;assume&lt;/em&gt; the address is not NULL (because of how I’ve declared
   it), and so skip this comparison.  In this case, the CPU didn’t run all the
   &lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;’s I had
   requested.  Looking over how
   &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c&quot;&gt;CRT0&lt;/a&gt;
   got translated to assembly should show you if the NULL checks were removed
   by the compiler or not.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/know-assembly.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;After copying program memory and initial variables, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;
   routine then needs to &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c#L335-L343&quot;&gt;zero
   out&lt;/a&gt;.
   the &lt;a href=&quot;https://en.wikipedia.org/wiki/.bss&quot;&gt;BSS data segment&lt;/a&gt;.  This basically
   requires a glorified
   &lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;,
   which can be debugged in the same fashion as the
   &lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt; above.&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Verify the &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction
fetch&lt;/a&gt; following the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; routine&lt;/p&gt;

    &lt;p&gt;Once &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c&quot;&gt;CRT0&lt;/a&gt;
completes, that is once both the (alternative)
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt; and
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;
functions complete, the CPU should jump to the beginning of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;.
This is illustrated as step 4 in Fig. 1 above, and shown in Fig. 2 below.
Therefore, let’s go back to the &lt;a href=&quot;/zipcpu/2018/03/21/dblfetch.html&quot;&gt;instruction
fetch&lt;/a&gt;
and see that it does so.&lt;/p&gt;

    &lt;p&gt;Does the CPU return from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; properly?  Or did
the return address get overwritten somehow?&lt;/p&gt;

    &lt;p&gt;Are the instructions provided to the CPU the correct ones?&lt;/p&gt;

    &lt;p&gt;In one case, I used the DMA to copy data from the
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash&lt;/a&gt;
to a DDR3 SDRAM via Xilinx’s DDR3 controller.  When I struggled to get the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; software to work, I called
a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/syscalls.c#L54-L68&quot;&gt;software serial port output
routine&lt;/a&gt;
from within &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; to help me debug what
was going on.  In that case, the serial port output routine
I used wanted to insert carriage return characters before newlines, and
so it needed to know if the last character was a carriage return.  This
value was supposed to be kept in SDRAM memory–the very memory I
was trying to use and load.  This shouldn’t be a problem, I reasoned,
since at most I might output an extra carriage return, and the
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;
routine would eventually overwrite this value with the correct one anyway.&lt;/p&gt;

    &lt;p&gt;The problem, however, was that using this memory region caused the CPU
to read memory &lt;em&gt;into the data cache before&lt;/em&gt; the DMA completed.  This
left me with with a corrupt copy of data memory in the cache once the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt; completed.  In other words, don’t forget to clear the
cache once the DMA completes any memory copies.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&quot;4&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;SIM instructions&lt;/p&gt;

    &lt;p&gt;Many CPU’s, to include both &lt;a href=&quot;https://openrisc.io&quot;&gt;OpenRISC&lt;/a&gt; and the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, have special simulation
only instructions.  These are basically &lt;a href=&quot;https://en.wikipedia.org/wiki/NOP_(code)&quot;&gt;NOOP
instructions&lt;/a&gt; that will cause
the CPU to perform a special task in simulation only.  In the case of the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;, the instruction
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOUT&lt;/code&gt; can be used to dump a character to the simulation console.  The
instruction &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt; can be used to dump a register’s value to the console.
The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; assembler also
understands &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSTR&lt;/code&gt;, which can be used to create a series of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOUT&lt;/code&gt;
instructions to send a more readable string to the simulation console.
If these instructions are left in the code when it runs in actual hardware,
then they will simply be ignored like any other
&lt;a href=&quot;https://en.wikipedia.org/wiki/NOP_(code)&quot;&gt;NOOP instruction&lt;/a&gt;.&lt;/p&gt;

    &lt;p&gt;How can you use these?  You can use them to pepper your
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; function with these
instructions, and therefore know how far your CPU got in the
bootup process before it died.&lt;/p&gt;

    &lt;p&gt;In my case, I’ve done this often enough that the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dc132be3af68e430bf6f915880d1d7256e0f307f/sw/zlib/crt0.c&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_bootloader&lt;/code&gt;
function&lt;/a&gt;
has the appropriate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; commands (commented) throughout, so I can
uncomment these if necessary to tell how far it got in the loading process.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ol start=&quot;5&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Use the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
bus&lt;/a&gt; to your advantage&lt;/p&gt;

    &lt;p&gt;I recently had the opportunity to test both a
&lt;a href=&quot;https://www.apmemory.com/products/psram-iot-ram/&quot;&gt;PSRAM&lt;/a&gt; and a
&lt;a href=&quot;https://1bitsquared.com/products/pmod-hyperram&quot;&gt;HyperRAM&lt;/a&gt; driver
with the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  In both cases,
however, the memory needed to be configured properly before it could be
used.  This meant that I needed to modify the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; function so that it
first configured the memory, and the memory controller, before attempting
to copy the CPU software to memory.&lt;/p&gt;

    &lt;p&gt;To get this right, I first fired up the hardware and used the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debug
bus&lt;/a&gt; to read and
write hardware memory controller configurations.  Any problems were
debugged using the &lt;a href=&quot;/blog/2017/07/08/getting-started-with-wbscope.html&quot;&gt;WBSCOPE&lt;/a&gt;
until the memory fully worked.  Then, with the same
&lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;,
I verified that I could read and write values to this memory using the
configuration I was testing.  Only after I tested these memory
configurations did I then tell the CPU to invoke them from its
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; function.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/config-flash.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The problem was actually a bit worse, though, since I wanted to reconfigure
   the flash memory controller that was responsible for reading the initial
   &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; software.  This controller
   naturally started in SPI mode, but I wanted to reconfigure it to run using
   XiP in QSPI mode.  (Normally, my flash controller does this on startup,
   but I was testing an ASIC controller that day that didn’t have such an
   option.)  That meant I needed to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Configure the external RAM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Copy a small subroutine to the external RAM.  This got copied to the
same RAM location that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; would run from later.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using that small subroutine, take the flash driver off-line and
reconfigure it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Return to the original &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
function, to now perform the
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;s as
normal, but this time with a flash running in QSPI XiP mode&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure I flushed the instruction cache, now that my (own) program
memory had changed.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Debugging this was a bit of a pain, but still it was all quite doable.
   The trick was figuring out how to debug the small subroutine, running in
   RAM, that was reconfiguring the flash driver.  For that, I used the
   &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s BREAK instruction to force
   it to halt mid-run, where I could &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;inspect what the CPU had
   accomplished&lt;/a&gt;.&lt;/p&gt;

&lt;ol start=&quot;6&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;CPU Break instructions&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has a &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK
instruction&lt;/a&gt;.
Other CPU’s often have something similar.  Sometimes an
illegal instruction gets repurposed to accomplish the same thing.  The
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; uses its
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;
for debugging.  When/if the CPU hits a
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;,
it will halt and wait for the debugger.  At this point, I can &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;step in and
check&lt;/a&gt; the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s register values and any
hardware configurations.  This is really powerful.  For example, you
might:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/fundamental.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Make the first instruction of &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
a &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;.
If the CPU hits the break, you know it managed to 1) boot from the right
address, and 2) read the right instruction at that address.  (While
it’s possible you might still read the right instruction in spite of
these being in error, this would break the fundamental assumption of all
debugging.)&lt;/p&gt;

    &lt;p&gt;This is a big help, especially if you are stuck debugging the CPU
from hardware.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Place a second
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;
after configuring memory.  Now go in and check: was the memory configured
correctly?  Can you still read and write your memory via a
&lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;?
If not, then back up and fix your bug.&lt;/p&gt;

    &lt;p&gt;In the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s case, the
debugger isn’t (yet) smart enough to handle more than one
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;.
I will therefore recompile the software without the first
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;,
but now including the second one.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Place another
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;
after each of the various
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memcpy/&quot;&gt;memcpy()&lt;/a&gt;
functions within &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;.  Are each
of these
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instructions&lt;/a&gt;
getting hit?
When they are hit, has the memory that was supposed to be copied been
copied properly?  I usually just check a couple of addresses: the first
three and the last three.  I tend not to check the middle unless these
first and last ones are too repetitive to provide me with any confidence
that the copy was done properly.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make the first instruction of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; a
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instruction&lt;/a&gt;.
Does the CPU get that far?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s back up to our original list and keep going.  For example …&lt;/p&gt;

&lt;ol start=&quot;7&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;What if your CPU doesn’t have a break instruction?&lt;/p&gt;

    &lt;p&gt;If your CPU doesn’t have a break instruction, sometimes you can get away
with a “branch to the current address” instruction, and so create a very
tight loop.  While it’s not quite the same thing, it can still work for this
purpose.&lt;/p&gt;

    &lt;p&gt;If your CPU doesn’t have a &lt;a href=&quot;/zipcpu/2017/08/25/hw-debugging.html&quot;&gt;debug access port to read and write registers
from&lt;/a&gt;,
then you may need to spend a lot of time doing the same thing with
LEDs.  While slower, it’s still doable.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: left; padding: 25px&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/clib-printf.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol start=&quot;8&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Console output, but without the console device driver&lt;/p&gt;

    &lt;p&gt;If you can get to the BREAK instruction at the beginning of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;,
then you are almost there.  Once you get this far, if you are still not
there then the problem must exist between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; and the first console
output.&lt;/p&gt;

    &lt;p&gt;The next check, therefore, is to make sure the console even works.&lt;/p&gt;

    &lt;p&gt;There are a couple of problems you might have here.  For example, is the
console port properly connected to the bus?  Is it at the right address?&lt;/p&gt;

    &lt;p&gt;For this, you can again use the
&lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;.
Use it to write to the console device while the CPU is halted.  Do the
values you write get written to the CPU’s console?  If not, then pull
it up in the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulator&lt;/a&gt;
and figure out why not.&lt;/p&gt;

    &lt;p&gt;If it fails in the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulator&lt;/a&gt;,
then you should have all the information you need to know how to fix it.&lt;/p&gt;

    &lt;p&gt;If it works in the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulator&lt;/a&gt;,
but not in actual hardware, then check that
the &lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;right IO pin is connected, and that the serial port is configured for
the baud right rate&lt;/a&gt;.
(You can read about &lt;a href=&quot;https://zipcpu.com/blog/2018/08/04/sim-mismatch.html&quot;&gt;other reasons why a design might work in simulation,
but not in real hardware,
here&lt;/a&gt;.)&lt;/p&gt;

    &lt;p&gt;This particular bug is actually a fairly rare bug for me, since I typically
use the serial port for the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
bus&lt;/a&gt;.  So, in my
case, if I have the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging
bus&lt;/a&gt;
running in the first place then I’ve already &lt;a href=&quot;/blog/2017/05/24/serial-port.html&quot;&gt;debugged the serial port’s
hardware&lt;/a&gt;.
I know, for example, that I have the right IO pin, the right
baud rate, the right parity, the right number of bits per character, etc.&lt;/p&gt;

    &lt;p&gt;Once the raw serial port works, in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
first and then hardware,
and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt; still doesn’t, then it’s time to debug the standard library.
For this, I’ve been known to add more SIM instructions, either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; or
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt;, into the library to trace it through it’s operation and find out
where it’s failing.&lt;/p&gt;

    &lt;p&gt;Once the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_file_input/output&quot;&gt;stdio library&lt;/a&gt;
works (in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;),
but still fails in hardware, the next step would be
to add serial port accesses to your design that bypass the
&lt;a href=&quot;https://en.wikipedia.org/wiki/C_file_input/output&quot;&gt;stdio&lt;/a&gt;
see where the design is failing.  I have a &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/txfns.h&quot;&gt;special set of functions, I
call them
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;txfns&lt;/code&gt;&lt;/a&gt;, that
I use for this purpose.  They’re designed to be as light and as simple
as possible, while writing outputs to the serial port.  Using them, I can
output strings and hexadecimal numbers directly to the serial port.  That’s
usually enough to debug the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_file_input/output&quot;&gt;stdio
library&lt;/a&gt;.  You can think
of these functions as hardware replacements to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSTR&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NDUMP&lt;/code&gt;, since
that’s how I typically use them.&lt;/p&gt;

    &lt;p&gt;You could also use
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;BREAK instructions&lt;/a&gt;
here.  Again, the goal is to both figure out where the software is going
as it works its way through &lt;a href=&quot;https://en.wikipedia.org/wiki/C_file_input/output&quot;&gt;the
library&lt;/a&gt;,
as well as to dump enough values at any particular point along
the way so that you can “see” what’s going on.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;table align=&quot;center&quot; style=&quot;float: right&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/stupid-murphy.svg&quot; alt=&quot;&quot; width=&quot;420&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;ol start=&quot;9&quot;&gt;
  &lt;li&gt;
    &lt;p&gt;Once you get to the console output, things get easier&lt;/p&gt;

    &lt;p&gt;Debug by printf is a thing.  It may not be ideal, but it does work.
When compared to debugging a blank cursor, debug by printf() will feel like
cooking with gas.&lt;/p&gt;

    &lt;p&gt;The task of this article, however, has been to illustrate how to
this far in the first place.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;crt0-example&quot;&gt;CRT0 Example&lt;/h2&gt;

&lt;p&gt;Just for understanding, let’s walk through this process by examining how
the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; would go about running
&lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello World&lt;/a&gt;.
We’ll look at this from
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt;, all drawn from the
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/dev&quot;&gt;ZBasic&lt;/a&gt;
(&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt; only)
distribution, and I’ll show you some valuable things you can notice from these
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt; alone.&lt;/p&gt;

&lt;p&gt;Our first &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; shows an
overview of what &lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello
World&lt;/a&gt;
would look like from a &lt;a href=&quot;http://gtkwave.sourceforge.net&quot;&gt;GTKWave&lt;/a&gt;
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
standpoint.  It shows the CPU from after reset, through loading &lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello
World&lt;/a&gt;, running
&lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello World&lt;/a&gt;,
and then cleaning up and closing the
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
In this case, “cleanup” is another way of saying, “waiting for the serial
port to finish its writes.”&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 2. An overview of running Hello World on the ZipCPU&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/overview-annotated.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Let me walk you quickly through the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt; shown in Fig. 2.&lt;/p&gt;

&lt;p&gt;The first two &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt;
are either the &lt;a href=&quot;/formal/2019/02/21/txuart.html&quot;&gt;serial
port&lt;/a&gt;’s input or its
output.  As you may &lt;a href=&quot;/formal/2019/02/21/txuart.html&quot;&gt;recall, serial
port&lt;/a&gt;s idle high, so here
you can see that the outgoing serial port wire is idle for most of the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;, until it finally sends
the “&lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello, World!&lt;/a&gt;”
output out.&lt;/p&gt;

&lt;p&gt;In the particular configuration shown here, the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; has been configured to drive the
&lt;a href=&quot;/zipcpu/2017/11/07/wb-formal.html&quot;&gt;Wishbone bus&lt;/a&gt; from
either its instruction or its data cache.  An arbiter has already selected
one of these two, but you may watch it change from one to the other in
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt; to follow.
AutoFPGA has labeled the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s bus
signals with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bus_component_*&lt;/code&gt; prefix, in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wb_zip_&lt;/code&gt;. As you
might expect, the first access, following reset, is to read the first
instruction.  This is where our figure starts.  This access has been held up,
however, until the &lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;Quad SPI flash
controller&lt;/a&gt;
finishes configuring the external flash device (model) for eXecute in
Place (XiP) Quad SPI mode.&lt;/p&gt;

&lt;p&gt;The “ipc” &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; shows the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;Program Counter (PC)&lt;/a&gt;,
or more specifically the
&lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;supervisor&lt;/a&gt;’s
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; within the
&lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;.  (Another register, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;upc&lt;/code&gt;,
captures the &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;user&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt;.)
I’ve also added the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc&lt;/code&gt; register to this display twice.  The first
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
shows it in its default hexadecimal display setting.  A quick glance will
illustrate this trace is generally unreadable unless you zoom in so far you
lose all of the surrounding context.  The second &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc&lt;/code&gt; trace is set to analog
mode.  Here you can see very distinctly where the CPU jumps from flash memory
to the block RAM used by the &lt;a href=&quot;https://github.com/ZipCPU/zbasic/tree/dev&quot;&gt;ZBasic
distro&lt;/a&gt; for most of its operation.
This is the indication that the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;
has just began running
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;&lt;/a&gt;.
(If you look closely, you’ll also see where
&lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/master/sw/board/hello.c&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;&lt;/a&gt;
completes and returns control to &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The final &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; is that of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;.  Since the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
is just a generic &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; &lt;a href=&quot;/zipcpu/2018/01/01/zipcpu-isa.html&quot;&gt;register, and
specifically register 13&lt;/a&gt;,
that’s why it’s listed as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;regset[13][31:0]&lt;/code&gt; on the trace.  The big thing to
notice here is where the &lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack
pointer&lt;/a&gt; first changes.  This is
your indication that the CPU has &lt;a href=&quot;https://github.com/ZipCPU/zbasic/blob/dev/sw/zlib/crt0.c#L168&quot;&gt;started running
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CRT0&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To see more, however, we’ll need to zoom in a bit.&lt;/p&gt;

&lt;p&gt;Let’s start by zooming into the first section of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt; area.
In this case, we’ll zoom in a lot.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 3. CRT0 first copies instructions from flash to RAM&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/crt0insn-annotated.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;The first thing you’ll notice is that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc&lt;/code&gt; register shows clear looping.
This is to be expected of a memory copy loop.  It is a loop, after all.&lt;/p&gt;

&lt;p&gt;The next thing you’ll notice is that this loop takes place in sections
followed by pauses.  This is caused by the data cache.  Every pause you see
is a cache miss, where the data cache reads another cache line from the
&lt;a href=&quot;/blog/2019/03/27/qflexpress.html&quot;&gt;flash&lt;/a&gt;.
The &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; then writes the cache
line to RAM.  Since the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt;’s
data cache implementations are all &lt;em&gt;write-through&lt;/em&gt; caches, writes to memory
also go immediately to the bus.  These are the busy portions of the loop.&lt;/p&gt;

&lt;p&gt;Finally, you’ll notice that the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stack_register&quot;&gt;stack pointer&lt;/a&gt;
is constant throughout this whole section.  That’s an indication that it’s
all taking place within a single function.&lt;/p&gt;

&lt;p&gt;The second big section of this &lt;a href=&quot;https://en.wikipedia.org/wiki/Crt0&quot;&gt;CRT0&lt;/a&gt;
operation where where the &lt;a href=&quot;https://en.wikipedia.org/wiki/.bss&quot;&gt;BSS segment&lt;/a&gt;
is cleared to zero.  You can see this in Fig. 4 below.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 4. CRT0 next clears uninitialized global (BSS) memory&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/bss-annotated.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;In this case, I’ve zoomed in around the transition from the instruction copy
to where the &lt;a href=&quot;/about/zipcpu.html&quot;&gt;ZipCPU&lt;/a&gt; starts zeroing
the &lt;a href=&quot;https://en.wikipedia.org/wiki/.bss&quot;&gt;BSS segment&lt;/a&gt;.  The first thing I’d
like you to notice is how easy this transition is to see from the 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;ipc&lt;/a&gt; trace.  Indeed, the
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt; suddenly changes shape.
Sure, the rest of the &lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
changes shape as well, but if we zoomed out any more you might miss this and
only see the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;ipc&lt;/a&gt; change.&lt;/p&gt;

&lt;p&gt;As with the last section, the shape of this section is primarily driven by
the data cache.  This &lt;a href=&quot;https://en.wikipedia.org/wiki/.bss&quot;&gt;BSS&lt;/a&gt;
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;
loop just writes to one value of memory after another, with each value
passing straight through the cache to memory.&lt;/p&gt;

&lt;p&gt;What you may not notice is that there haven’t been any requests of the
bus for instructions.  If you look closer, however, you’ll see that’s not
quite true.  Just before the
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;
loop, there’s a cache request–this
time from the &lt;em&gt;instruction&lt;/em&gt; cache, to get the next eight instructions.  These
are sufficient to then run the
&lt;a href=&quot;https://cplusplus.com/reference/cstring/memset/&quot;&gt;memset()&lt;/a&gt;
function from cache alone.  Hence,
there are no more instruction requests of the bus until this loop exits.&lt;/p&gt;

&lt;p&gt;Just to show one final example of looping in
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;traces&lt;/a&gt;,
Fig. 5 below shows the activity on the bus associated with the serial port
while the design finally sends
“&lt;a href=&quot;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&quot;&gt;Hello, World!&lt;/a&gt;”
to the console.&lt;/p&gt;

&lt;table align=&quot;center&quot; style=&quot;float: none&quot;&gt;&lt;caption&gt;Fig 5. Sending Hello World to the console&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;/img/no-boot/console-annotated.png&quot; alt=&quot;&quot; width=&quot;780&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Now, if you look at the bus ports for the console, shown with the prefix
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wb_uart_&lt;/code&gt;, you’ll see a repeating pattern of two requests.  The first is
a read request, to verify that there’s room in the
&lt;a href=&quot;https://github.com/ZipCPU/wbuart32&quot;&gt;serial port&lt;/a&gt;’s buffer
for another byte of data.  The second is a write request, sending the next
byte to the buffer.&lt;/p&gt;

&lt;p&gt;The big thing to learn here, if nothing else, is the utility of displaying
the &lt;a href=&quot;https://en.wikipedia.org/wiki/Program_counter&quot;&gt;PC&lt;/a&gt; as an analog signal.&lt;/p&gt;

&lt;h2 id=&quot;debugging-a-memory-value&quot;&gt;Debugging a memory value&lt;/h2&gt;

&lt;p&gt;One common problem I’ve run into is where you get deep into the standard
library (i.e. into someone else’s software), and you see the CPU read some
value from memory and then do the wrong thing.  Or, rather, it does the right
thing but with the wrong value.  That leads to the question, why was that
value wrong?  When did it become wrong?  These are both things you may
need to answer.&lt;/p&gt;

&lt;p&gt;I discussed how to find a bug like this in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
in a previous post.&lt;/p&gt;

&lt;p&gt;What if you need to find this value while running from hardware?&lt;/p&gt;

&lt;p&gt;Ouch.  That’s harder.  Still, the same approach applies: pick the address of
interest, and track its value.&lt;/p&gt;

&lt;p&gt;In hardware, this often means that you’ll need to create a bus monitor
peripheral.  That monitor peripheral will then look to find &lt;em&gt;every&lt;/em&gt; time you
write to a given address, and keep track of what the value at that address
becomes when you write to it.  Beware, inserting such a peripheral into your
design might change your address map, so you might need to do a bit of
rework, but the basic idea applies.&lt;/p&gt;

&lt;p&gt;If your monitor detects a “wrong value” being written to the address of
interest, then it should be able to halt the CPU–so you can see what just
happened.  Or, perhaps, you might wish to simply &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;trigger a
trace&lt;/a&gt;
of the CPU to see what’s going on there.&lt;/p&gt;

&lt;p&gt;If, on the other hand, you never write a “wrong value” to the address of
interest, and yet still read a “wrong” value–then you know where to look: the
memory controller for the memory you are writing to.  You may need to
initiate reads of this address at various other times–at least enough to
narrow down and find when the value is changing.  Is it changing via a bus
write to some other address?  That would be important to know.  Is it not
changing when it’s being written to?  That would also be important.  Finding
out when, and the circumstances around it will be key to figuring this out.&lt;/p&gt;

&lt;p&gt;Your eventual goal here will be to encapsulate the basic
&lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;bug-triggering sequence&lt;/a&gt;
so that you can &lt;a href=&quot;/blog/2017/06/08/simple-scope.html&quot;&gt;trigger&lt;/a&gt;
it in a much simplified setting–either with
the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debugging bus&lt;/a&gt;
and not the CPU, or perhaps in
&lt;a href=&quot;/blog/2018/08/22/what-is-simulation.html&quot;&gt;simulation&lt;/a&gt;.
From there, you should (hopefully) be able to get a
&lt;a href=&quot;/blog/2017/07/31/vcd.html&quot;&gt;trace&lt;/a&gt;
in order to narrow it down further.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;The big challenge with all of the above tasks is that you are likely going to
be debugging someone else’s work: either their design or their software
library.  In my case, it’s my CPU but Xilins’x MIG controller is not my
RTL, neither are &lt;a href=&quot;https://sourceware.org/newlib/&quot;&gt;newlib&lt;/a&gt; nor
&lt;a href=&quot;http://elm-chan.org/fsw/ff/00index_e.html&quot;&gt;FATFS&lt;/a&gt; my software.  Sure,
it’s &lt;a href=&quot;/about/zipcpu.html&quot;&gt;my CPU&lt;/a&gt;, but I didn’t
design any of the other components on the circuit board, nor have I designed
the external memory.  If I want all of these components to work together in
my project and for my purpose, then I need to know how to handle debugging
them.  This will often mean tracing through someone else’s software just
to find the bugs in my own stuff.&lt;/p&gt;

&lt;p&gt;What about &lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;No, I haven’t gone back to the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
operating system I tried to boot on the
&lt;a href=&quot;https://beagleboard.org/black&quot;&gt;Beagle Bone&lt;/a&gt;.  I’ve just had too many other
paying opportunities to do something else, and I’ve now lost touch with the
potential customer who may have wanted that system.&lt;/p&gt;

&lt;p&gt;Still, if I needed to debug &lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;,
I think I’d use this same approach.  The
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linux&quot;&gt;Linux&lt;/a&gt;
kernel contains within it several simplified console output functions
that can be used for debugging the kernel prior to the entire operating system
being up and running.  While I haven’t tried using these personally (yet), I’ve
seen others do it to great success.  Similarly, my
&lt;a href=&quot;https://beagleboard.org/black&quot;&gt;Beagle Bone&lt;/a&gt;
has a JTAG port that I could use instead of the &lt;a href=&quot;/2017/06/05/wb-bridge-overview.html&quot;&gt;debug
bus&lt;/a&gt;.  It’s not a
one to one replacement, but my bet is that it will still be good enough.&lt;/p&gt;

&lt;hr /&gt;&lt;p&gt;&lt;em&gt;In the beginning was the Word, and the Word was with God, and the Word was God. (John 1:1)&lt;/em&gt;</description>
        <pubDate>Sat, 03 Dec 2022 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/zipcpu/2022/12/03/no-boot.html</link>
        <guid isPermaLink="true">https://zipcpu.com/zipcpu/2022/12/03/no-boot.html</guid>
        
        
        <category>zipcpu</category>
        
      </item>
    
      <item>
        <title>Thanksgiving!  I have much to be thankful for</title>
        <description>&lt;p&gt;We started a tradition in my family, years ago, of naming the things we are
thankful to God for on each Thanksgiving.&lt;/p&gt;

&lt;p&gt;This year, I would like to share with you those things that I am thankful
for.  The three primary things I am thankful to God for this year are
my salvation, my family, and the business that He has given me.  In many
ways, these blessings are the natural result of the service I’ve chosen
to give to God.  (&lt;a href=&quot;https://www.blueletterbible.org/kjv/heb/11/6&quot;&gt;Heb 11:6&lt;/a&gt;)
For this reason, I’d also like to take a short moment to walk through some
verses, and to try to describe the results of my attempts to follow the same.&lt;/p&gt;

&lt;h2 id=&quot;salvation&quot;&gt;Salvation&lt;/h2&gt;

&lt;p&gt;The salvation Jesus Christ offers is easily summarized in this verse:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kiss the Son, lest he be angry, and ye perish from the way, when his wrath
is kindled but a little.  Blessed are all they that put their trust in
him.  (&lt;a href=&quot;https://blueletterbible.org/kjv/psa/2/12&quot;&gt;Ps 2:12&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Salvation starts when a man chooses to trust God’s son, Jesus.  This is a
commitment.  As a result of trusting God, this man will keep God’s words and
obey as he is able.  The result, according to this verse, is such a blessing
as only God can give.  It’s value is greater than gold
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/psa/19/10&quot;&gt;Ps 19:10&lt;/a&gt;) or rubies
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/job/28/12-19&quot;&gt;Job 28:12-19&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/3/13-15&quot;&gt;Prov 3:13-15&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;My life changed significantly when I chose to trust God’s son, Jesus.  It
is because of these changes, and the results of following God, that I am
now so thankful this year.&lt;/p&gt;

&lt;h2 id=&quot;family&quot;&gt;Family&lt;/h2&gt;

&lt;p&gt;When I first committed my life to Christ, I was married but had no
&lt;em&gt;family&lt;/em&gt; to speak of.  My wife and I were separated, and we had no
children.&lt;/p&gt;

&lt;p&gt;My fiance and I both graduated from the US Air Force Academy.  She
went to Columbus, Mississippi to become a pilot, I went to Dayton,
Ohio, to get a masters degree.  We were married while we were apart.&lt;/p&gt;

&lt;p&gt;During this dark time, I still remember the first day I arrived at
&lt;a href=&quot;https://www.ebcbellbrook.org/&quot;&gt;Emmanuel Baptist Church, now in Bellbrook,
Ohio&lt;/a&gt;.  At the time I was deeply troubled,
not knowing if my wife and I would ever be together.  Joint assignments
were not sure things.  Much to my surprise, the pastor there was quite
convinced that we would be together.  How could he be so convinced?  This
made no sense to me, since he hardly knew me.  He explained that he
was convinced because he knew the character of the God he served.  At the
time, I wasn’t sure how to take this.  Was the pastor a crack, or did he
really know the Almighty God of heaven and earth that well?&lt;/p&gt;

&lt;p&gt;No, the military is not kind to couples where both are in the service.
Sometimes the personnel office is able to station military spouses
together.  Sometimes, as happened with me after our first assignment
together, the personnel officer will just throw his hands up in the
air and declare that military spouses aren’t guaranteed to live with
each other.&lt;/p&gt;

&lt;p&gt;Marrying a military spouse didn’t leave my wife and I in a happy place.
I would certainly not encourage others to take this path.&lt;/p&gt;

&lt;p&gt;Some time later, my wife and I found the verse in Titus, where God instructs
the older women to, …&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;… teach the younger women to be sober, to love their husbands, to love
their children, to be discrete, chaste, keepers at home, obedient to their
own husbands, that the word of God be not blasphemed.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/tit/2/4-5&quot;&gt;Titus 2:4-5&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The word “at”, found in the phrase “keepers at home”, convinced my wife that
she shouldn’t be in the military in spite of her training and experience as
a helicopter pilot.  She than began the (long and drawn out) process of
separating from the military.  The result of this process was that, after
four happy years together, we were separated for the next year.  During
this time, we didn’t know how long it would be until we’d be together
again.&lt;/p&gt;

&lt;p&gt;We also re-examined the verses where God instructs man to be fruitful
and multiply. (&lt;a href=&quot;https://www.blueletterbible.org/kjv/gen/1/28&quot;&gt;Gen 1:28&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/gen/9/1&quot;&gt;9:1&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/gen/9/7&quot;&gt;9:7&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/deu/28/4&quot;&gt;Deut 28:4&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/deu/28/11&quot;&gt;28:11&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/5/18&quot;&gt;Prov 5:18&lt;/a&gt;)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;And you, be ye fruitful, and multiply; bring forth abundantly in the earth,
and multiply therein. (&lt;a href=&quot;https://www.blueletterbible.org/kjv/gen/9/7&quot;&gt;Gen 9:7&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Before coming across this verse, or rather before I took it seriously,
I had been of the belief that every couple should have two children,
and so to maintain the world’s population.  After evaluating these
verses, I chose to do as I was told.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Let thy fountain be blessed: and rejoice with the wife of thy youth.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/5/18&quot;&gt;Prov 5:18&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Those who know us would declare that we now have a “large” family.
I would simply say that every one of our children is a blessing that
I am genuinely thankful for.&lt;/p&gt;

&lt;p&gt;The Bible also teaches how to raise up the children God gives, and
provides encouragement and instruction for the same.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Correct thy son, and he shall give thee rest; yea, he shall give
delight unto thy soul.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/29/17&quot;&gt;Prov 29:17&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yes, we did choose to abandon all of the sage advice printed in
“Christianity Today” for the words of the Bible itself.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/13/24&quot;&gt;Prov 13:24&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/19/18&quot;&gt;19:18&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/22/15&quot;&gt;22:15&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/23/13-14&quot;&gt;23:13-14&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/pro/29/15&quot;&gt;29:15&lt;/a&gt;,
&lt;a href=&quot;https://www.blueletterbible.org/kjv/eph/6/4&quot;&gt;Eph 6:4&lt;/a&gt;)
Perhaps it was a risk doing so at first.  Now looking back, I am very
pleased with the result.  Today my children are one of the delights
of my life.&lt;/p&gt;

&lt;p&gt;What is the alternative?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;As for my people, children are their oppressors, and women rule over them.
O my people, they which lead thee cause thee to err, and destroy the way
of thy paths.  (&lt;a href=&quot;https://www.blueletterbible.org/isa/3/12&quot;&gt;Is 3:12&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;No, I think I like the results of following God’s way better.  Indeed,
hath the LORD not promised,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Blessed is every one that feareth the LORD; that walketh in his ways.  For
thou shalt eat the labour of thine hands: happy shalt thou be, and it
shall be well with thee.  Thy wife shall be as a fruitful vine by the
sides of thine house: thy children like olive plants round about thy
table. (&lt;a href=&quot;https://www.blueletterbible.org/psa/128/1-3&quot;&gt;Ps 128:1-3&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This describes my life today.  Because of this, I am thankful for my
family: a family I would not have had, were it not for God’s instruction
and subsequent blessing.&lt;/p&gt;

&lt;h2 id=&quot;business&quot;&gt;Business&lt;/h2&gt;

&lt;p&gt;I am also thankful for my business.&lt;/p&gt;

&lt;p&gt;When I started Gisselquist Technology, LLC, I knew very little about
business.  I knew about technology.  I knew about signal processing.
I knew about the military acquisition process.  I knew a little
bit about digital logic.&lt;/p&gt;

&lt;p&gt;Why did I choose to start my own business?  Because of verses like,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ye are bought with a price; be not ye the servants of men.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/1co/7/23&quot;&gt;1Cor 7:23&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But just because a man goes into business doesn’t mean he’ll be successful
at it.  Perhaps I’m only “successful” because my goals are simple:  I only
wish to provide for myself and my family.&lt;/p&gt;

&lt;p&gt;On the other hand, God does make some promises here as well.  For example,
the very first Psalm talks about prospering at whatever you choose to do.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Blessed is the man that walketh not in the counsel of the ungodly, nor
standeth in the way of sinners, nor sitteth in the seat of the scornful.
But his delight is in the law of the Lord, and in his law doth he
meditate day and night.  And he shall be like a tree planted by the
rivers of water, that bringeth forth his fruit in his season; his leaf
also shall not wither; and whatsoever he doeth shall prosper.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/psa/1/1-3&quot;&gt;Ps 1:1-3&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;“Whatsoever he doeth shall prosper”, huh?  True?  Yes.&lt;/p&gt;

&lt;p&gt;Or how about the ending of the 23rd Psalm?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thou preparest a table before me in the presence of mine enemies: thou
annointest my head with oil; my cup runneth over.  Surely goodness and
mercy shall follow me all the days of my life: and I will dwell in the
house of the LORD forever.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/psa/23/5-6&quot;&gt;Ps 23:5-6&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;“My cup runneth over” sounds like a blessing that a man doesn’t have
room enough to receive.
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/mal/3/10&quot;&gt;Mal 3:10&lt;/a&gt;)  Today, I
feel like God’s blessing runs over from my cup onto those around me,
such as my family or those I work with.&lt;/p&gt;

&lt;p&gt;Well, does it?  Is this witness true?  Let me offer these evidences.
First, my oldest son graduated from college debt free, and now my
second child will be graduating from college this year, also debt
free.  My third child is still in college, and remains debt free.
This evidence, however, may be more due to their work than my own.
So let me offer a second piece of evidence and share that I’ve doubled
my gross receipts for the last two years, year over year.  This, mind
you, is in spite of a group of individuals that tried to cancel me
two years ago, and swore never to work with me.  It is also in spite
of all of the COVID shutdowns and subsequent chip shortages, which
in many ways I have been quite insulated from.  As my third evidence,
my wife and I were able to save up enough to purchase new vehicles
while on my business salary.  This year, it was a Honda Odyssey.
Finally, this year, I have someone joining me to help me out with
my tasks.&lt;/p&gt;

&lt;p&gt;If that’s not “success”, I’m not sure what is.&lt;/p&gt;

&lt;p&gt;So, again, I’m thankful this year for my success at Gisselquist
Technology, LLC.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This year, I am thankful for what God has done in my life and the
joy that I have to share.&lt;/p&gt;

&lt;p&gt;Let me encourage you to also join me in counting your blessings this year,
and in thanking the God of all blessings for what he has done in your own
life as well.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Rejoice in the Lord alway: and again I say, Rejoice!
(&lt;a href=&quot;https://www.blueletterbible.org/kjv/phl/4/4&quot;&gt;Phil 4:4&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;&lt;p&gt;&lt;em&gt;Bring ye all the tithes into the storehouse, that there may be meat in mine house, and prove me now herewith, saith the LORD of hosts, if I will not open you the windows of heaven, and pour you out a blessing, that there shall not be room enough to receive it. (Mal 3:10)&lt;/em&gt;</description>
        <pubDate>Thu, 24 Nov 2022 00:00:00 -0500</pubDate>
        <link>https://zipcpu.com/blog/2022/11/24/thanksgiving.html</link>
        <guid isPermaLink="true">https://zipcpu.com/blog/2022/11/24/thanksgiving.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
