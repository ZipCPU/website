<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a high speed Finite Impulse Response (FIR) Digital Filter</title>
  <meta name="description" content="Some time ago, an individual posted on Digilent’sforum that he wasn’t able to getXilinx’sFinite Impulse Response (FIR)filtercompilergenerated code to work.  ...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2017/09/15/fastfir.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building a high speed Finite Impulse Response (FIR) Digital Filter</h1>
    <p class="post-meta"><time datetime="2017-09-15T00:00:00-04:00" itemprop="datePublished">Sep 15, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Some time ago, an individual posted on <a href="https://forum.digilentinc.com">Digilent’s
forum</a> that he wasn’t able to get
<a href="https://www.xilinx.com">Xilinx</a>’s
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">Finite Impulse Response (FIR)</a>
filter
<a href="https://www.xilinx.com/support/documentation/ip_documentation/fir_compiler/v7_1/pg149-fir-compiler.pdf">compiler</a>
generated code to work.  While I can understand that there are good reasons
for using a
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://www.xilinx.com/support/documentation/ip_documentation/fir_compiler/v7_1/pg149-fir-compiler.pdf">compiler</a>,
this individual was attempting to
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">low-pass filter</a>
a signal with less than a handful of taps.</p>

<p>No wonder why he was getting frustrated when he didn’t see much difference
in the filtered signal.</p>

<p>He’s not alone.  Indeed, I was answering forum posts from a similar individual
on another forum just this morning.  It seems like requests for help with
the vendor supplied <a href="https://en.wikipedia.org/wiki/Digital_filter">digital
filtering</a>
libraries are fairly common place, while many of those asking for help
don’t necessarily understand what goes on within a typical
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>.</p>

<p>If you would like to apply a
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>
to a signal, I am going to suggest that you should first learn what a
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>
is.  I’m also going to suggest that you learn how the
<a href="https://en.wikipedia.org/wiki/Frequency_response">frequency response</a>
of a <a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
is defined, to the point where you can calculate the
<a href="https://en.wikipedia.org/wiki/Frequency_response">frequency response</a>
yourself and so know what to expect from your any
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>
implementation.</p>

<p>When you think you are ready to learn how to implement a
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>,
then let me welcome you to continue reading.</p>

<p>Today, let’s look at what’s required to implement an
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>.</p>

<h2 id="uses-for-digital-filters">Uses for Digital Filters</h2>

<p>Years ago I asked a math professor why I should be interested in
<a href="https://en.wikipedia.org/wiki/Linear_algebra">Linear Algebra</a>.
He was rather flabbergasted and floored by the question.
<a href="https://en.wikipedia.org/wiki/Linear_algebra">Linear Algebra</a>,
he tried to explain, underpinned so much of mathematics that it was
hard to define just one use.</p>

<p>The same is true of
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filtering</a>–which
just so happens to be one of those many uses of <a href="https://en.wikipedia.org/wiki/Linear_algebra">Linear
Algebra</a> that my instructor
didn’t reference.  <a href="https://en.wikipedia.org/wiki/Digital_filter">Digital
filters</a>
are used in so many <a href="https://en.wikipedia.org/wiki/Digital_signal_processing">Digital Signal Processing
(DSP)</a>
applications within digital logic, such as
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s,
that it’s hard to identify just one application to use when arguing
for their relevance.</p>

<p>The following, though, are some common uses of the sorts of
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filters</a>
you can create within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>:</p>

<ol>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Emphasis_(telecommunications)">Audio pre/post emphasis</a>, often used in commercial audio transmission channels</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Radio-receiver">Channel separation and selection</a>,
such as your radio receiver might do.</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Echo_suppression_and_cancellation">Echo cancellation</a>
in telephony</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Equalization_(audio)">Audio equalization</a>,
such as you might find on any higher quality stereo set</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Matched_filter">Matched Filtering</a>
to maximize SNR, often used within digital communications</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Pulse_shaping">Pulse Shaping</a></p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/intersymbol_interference">Intersymbol Interference</a>
mitigation in digital communications</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Anti-aliasing_filter">Anti-aliasing filters</a>,
so that you can process your signals at a slower rate without distortion</p>
  </li>
  <li>
    <p>In <a href="https://en.wikipedia.org/wiki/Hearing_aid">hearing aids</a>, to clean
up audio signals so that they may be understood again</p>
  </li>
</ol>

<p>Indeed, as I’m putting this list together, I feel like I’ve only started
to touch the surface on the uses of
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filters</a>.  Their
usage has become quite ubiquitous, even if they are not well understood by all
who design and use them.</p>

<p>Today, let’s build some <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">generic filter
logic</a> that
can be used for any or all of the
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filtering</a> tasks listed
above.  It may not be the best implementation, nor the most practical
implementation, for such tasks, but it will at least be a valid implementation.</p>

<p>First, though, let’s briefly discuss what a
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filtering</a> is.</p>

<h2 id="what-is-an-fir-filter">What is an FIR Filter</h2>

<p>If you start with the only requirement that you want to apply a
<a href="https://en.wikipedia.org/wiki/Linear_map">linear mathematical operation</a>
to an infinite set of equidistant input samples (i.e.
a sampled data stream), and then insist that this operation be
<a href="https://en.wikipedia.org/wiki/Time-invariant_system">shift invariant</a>,
you will discover a <a href="https://en.wikipedia.org/wiki/Digital_filter">linear
filter</a>.</p>

<p>Such <a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>s
are completely characterized by their
<a href="https://en.wikipedia.org/wiki/Impulse_response">impulse response</a>.
That is, if you feed the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
a single non-zero value (i.e. an impulse), then the response the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
produces is called its
<a href="https://en.wikipedia.org/wiki/Impulse_response">impulse response</a>.
If the response is only finite in duration, then the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
is said to be a <a href="https://en.wikipedia.org/wiki/Finite_impulse_response">Finite Impulse
Response (FIR)</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.
If the response is not finite in duration, the filter is said to be an
<a href="https://en.wikipedia.org/wiki/Infinite_impulse_response">Infinite Impulse Response
(IIR)</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.</p>

<p>If you allow the function <code class="language-plaintext highlighter-rouge">h[k]</code> to represent the response of this
filter, then the mathematical operation that describes how the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
applies to an input sequence <code class="language-plaintext highlighter-rouge">x[n]</code> is a
<a href="https://en.wikipedia.org/wiki/Convolution">convolution</a>, and defined by the
equation:</p>

<table align="center" style="float: none"><tr><td><img src="/img/convolution.png" alt="x o h = SUM_k h[k] x[n-k]" width="540" /></td></tr></table>

<p>If <code class="language-plaintext highlighter-rouge">h[k]</code> is zero for all <code class="language-plaintext highlighter-rouge">k&lt;0</code>, as well as all <code class="language-plaintext highlighter-rouge">k&gt;=N</code>, then <code class="language-plaintext highlighter-rouge">h[k]</code> can be
used to define a <em><a href="https://en.wikipedia.org/wiki/Causal_filter">causal</a></em>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>.
The importance of this distinction is that <em>only</em>
<a href="https://en.wikipedia.org/wiki/Causal_filter">causal</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filters</a>
can be implemented in hardware.  Hence if you wish to implement an
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>, causality is
a good first assumption.  The operation of a
<a href="https://en.wikipedia.org/wiki/Causal_filter">causal</a>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
can be simplified and represented by:</p>

<table align="center" style="float: none"><tr><td><img src="/img/fir-convolution.png" alt="y[n] = SUM_k=0^N-1 h[k] x[n-k]" width="380" /></td></tr></table>

<p>where <code class="language-plaintext highlighter-rouge">x[n]</code> is again the input sequence, <code class="language-plaintext highlighter-rouge">h[n]</code> is the
<a href="https://en.wikipedia.org/wiki/Impulse_response">impulse response</a>
of this <a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>, and
<code class="language-plaintext highlighter-rouge">y[n]</code> is the output of the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.</p>

<p>That’s the operation of a
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>.
Any and every
<a href="https://en.wikipedia.org/wiki/Causal_filter">causal</a>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a> will have this form,
and will need to carry out this operation.</p>

<p>Let’s spend some time discussing how to build this type of
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital FIR filter</a>
within an <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
The full topic of how to generate and implement one of
<a href="https://en.wikipedia.org/wiki/Digital_filter">these filters</a>
is way too big to fit in one post.  So, we’ll try to break it down into
several.  However, these several posts are likely to depend upon each other
to do.  For example, we already discussed how to generate two of the simplest
<a href="https://en.wikipedia.org/wiki/Digital_filter">filters</a>.
Today we’ll discuss how to build a very generic
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.</p>

<h2 id="tap-coefficient-selection">Tap Coefficient Selection</h2>

<p>Often, the first task in generating an
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR filter</a>
is to determine the <code class="language-plaintext highlighter-rouge">h[n]</code>
values referenced above.  These are known as the <em>coefficients</em> of the filter.
They completely define and characterize any
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>.
If you’ve never had to select
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a> coefficients
before, then know that there is a real science behind the process.
The most generic filter design algorithm that I like to recommend is the
<a href="https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm">Parks-McClellan filter design
method</a>.
It tends to produce <em>optimal</em> filters, in that the coefficients produced
minimize the maximum error between the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>’s
<a href="https://en.wikipedia.org/wiki/Frequency_response">frequency response</a>
and the design criteria.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm">Parks-McClellan filter design
method</a>
isn’t anything new.  It’s been around long enough that many implementations
of it exist.  For example, here’s an
<a href="http://t-filter.engineerjs.com">online version</a>
that you can use to design your filter coefficients.</p>

<p><a href="https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm">The Parks-McClellan filter design algorithm</a>,
however, creates coefficients with no practical
<a href="https://en.wikipedia.org/wiki/Quantization_(signal_processing)">quantization</a>
limit to their precision.  What I mean by that is that most
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
implementations don’t need the double-precision floating point values that the
<a href="https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm">Parks-McClellan filter design algorithm</a>
can create, not that double-precision floating point numbers have unlimited
precision.  <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
based <a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>s,
on the other hand, need to represent their filter coefficients within a
finite number of bits—usually much less than a double-precision floating
point number.  This is for cost and performance reasons.  As a result,
a conversion needs to take place from abundant precision to a finite bit
precision.</p>

<p>As with generating the coefficients, generating or converting them to a
smaller number of bits is also quite the science.  Many papers have been
written on the topic of how to carefully select the proper quantized
coefficients for a <a href="https://en.wikipedia.org/wiki/Digital_filter">digital
filter</a>
[<a href="http://ieeexplore.ieee.org/document/365314">Ref</a>].  However,
for our purposes today, these papers are beyond the limits of what we can
discuss here in a simple blog post.  Therefore, I am going to share an ad-hoc
technique instead for today’s discussion.  I offer no promises of optimality,
rather only the suggestion that this approach should work for many purposes.</p>

<ul>
  <li>
    <p>The first step is to know your sample rate, and the passband, <code class="language-plaintext highlighter-rouge">f_p</code> and
stopband, <code class="language-plaintext highlighter-rouge">f_s</code>, frequencies your application can handle.  Most problems
also define how small the response is supposed to be during the stop-band
(<code class="language-plaintext highlighter-rouge">f&gt;f_s</code>), as well as how tightly the passband (<code class="language-plaintext highlighter-rouge">f&lt;f_p</code>) filter response
must hold to unity.</p>

    <p>Figure 1 shows a chart illustrating these regions as defined for a
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass filter</a>.</p>

    <table align="center" style="float: none"><caption>Fig 1: Lowpass filter design criteria</caption><tr><td><img src="/img/fir-lpf-design.png" alt="Lowpass filter design criteria chart, showing relationship between fp and fs" width="780" /></td></tr></table>

    <p>Indeed, this is a good chart for understanding filter design in general.
Your goal as a designer will be to create a filter whose
<a href="https://en.wikipedia.org/wiki/Frequency_response">frequency response</a>
(the blue line) fits within your criteria (the white region).  Your
application will typically define this white region, although the tighter
this region is the more your filter is likely to <em>cost</em> in terms of
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
resources.</p>
  </li>
  <li>
    <p>Once you know your design criteria, the next step is to determine the number
of taps, <code class="language-plaintext highlighter-rouge">N</code>, that your
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
will require, as well as an identified number of bits, <code class="language-plaintext highlighter-rouge">M</code>, to use to
represent the coefficients of these taps.  Too many taps or too many bits
and your
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
will not fit on your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
Too few, and your
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
will not match your design criteria above.  As a result,
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
design is often a give and take between requirements and
cost–much like any other engineering task.</p>

    <p>You may find that the inverse of the normalized transition bandwidth,
i.e. <code class="language-plaintext highlighter-rouge">1/(f_s-f_p)</code>,
is often linearly related to how many coefficients you will need.  Two
to four times this number, when using normalized frequency units,
(i.e. <code class="language-plaintext highlighter-rouge">0&lt;f&lt;1/2</code>) is often
a good starting place for how many taps your
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
will require.  As a result of this relationship, any time you
drop the transition width by a factor of two, you can expect to need twice
as many coefficients for the same cutoff transition bandwidth.</p>
  </li>
  <li>
    <p>Design a set of filter
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
coefficients using the <a href="https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm">Parks-McClellan filter design
algorithm</a>
or similar.  <a href="http://t-filter.engineerjs.com">Canned filter design
methods</a> are usually not hard to find
that will generate the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
coefficients you need.</p>

    <p>Once designed, then examine the pass band, stop band, and transition band
performance to to see how well the resulting
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
approximates your design criteria.  Adjust as appropriate.  More
taps for the same criteria can be used to deepen the stopband and tighten
up the pass band.</p>
  </li>
</ul>

<p>These first steps are common to any
<a href="https://en.wikipedia.org/wiki/Digital_filter">Digital</a>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR filter</a>
design problem.  The next steps, though, are required in order to try to
reduce your bit-width from double-precision floating point to something that
can be implemented on an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<ul>
  <li>
    <p>Multiply each tap by <code class="language-plaintext highlighter-rouge">(2^(M-1) -1) / max h[n]</code> so that the maximum
tap coefficient becomes the maximum positive <a href="https://en.wikipedia.org/wiki/Two's_complement">two’s
complement</a> number
that can be represented in your bit-width.</p>

    <p>Since most
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filters</a>
tend to follow the shape of a <a href="https://en.wikipedia.org/wiki/Sinc_function">sinc
function</a>, the biggest
coefficient will be in the center of the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.
That largest value becomes, by this multiplication algorithm, <code class="language-plaintext highlighter-rouge">2^(M-1)-1</code>.</p>
  </li>
  <li>
    <p>Round the rest of the coefficients to the nearest integer.</p>

    <p>If we’ve done this right, no coefficients will be greater than <code class="language-plaintext highlighter-rouge">2^(M-1)-1</code>
in magnitude.</p>

    <p>This will also adjust the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>’s
<a href="https://en.wikipedia.org/wiki/Frequency_response">frequency response</a>.
You may wish to go back and measure your
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>’s
<a href="https://en.wikipedia.org/wiki/Frequency_response">frequency response</a>
at this point to ensure that it’s still within any bounds you application
requires.</p>
  </li>
</ul>

<p>If this approach seems ad-hoc, that’s because it is.  There are more
scientific methods to do this.
[<a href="http://ieeexplore.ieee.org/document/365314">Ref</a>]</p>

<p>These steps should be sufficient to generate the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
coefficients you will need.</p>

<h2 id="bit-growth">Bit Growth</h2>

<p>Once you have the coefficients, the next step is to allocate any bits you need
throughout the design.  We discussed
<a href="/dsp/2017/07/21/bit-growth.html">bit growth</a>
some time ago,  so we can use those principles for this step.
For the purpose of this discussion, we’ll let <code class="language-plaintext highlighter-rouge">IW</code> be the number of bits
in the input samples, <code class="language-plaintext highlighter-rouge">TW</code> be the number of bits in the individual coefficients
(we called this <code class="language-plaintext highlighter-rouge">M</code> above), and <code class="language-plaintext highlighter-rouge">OW</code> be the output width and the width
of the accumulator.  These will then be the names we’ll use to define these
values in Verilog parameters later when we actually implement our
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.</p>

<p>From our
<a href="/dsp/2017/07/21/bit-growth.html">discussion of bit growth</a>,
you know that the multiplication step of the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>,
the step that calculates <code class="language-plaintext highlighter-rouge">h[k]x[n-k]</code>, will need to be allocated more bits
to represent the desired outcome than either input.  The number of bits
will be the number of bits in the input, <code class="language-plaintext highlighter-rouge">IW</code>, plus the number of bits in the
coefficients, <code class="language-plaintext highlighter-rouge">TW</code>.  Hence, following the multiply you will need <code class="language-plaintext highlighter-rouge">TW+IW</code> bits
to hold the output product from one multiply.</p>

<p>Also from the
<a href="/dsp/2017/07/21/bit-growth.html">same discussion</a>,
you know that the number of bits required to add <code class="language-plaintext highlighter-rouge">N</code> values of <code class="language-plaintext highlighter-rouge">TW+IW</code> bits
together is going to go with the log of <code class="language-plaintext highlighter-rouge">N</code>.  This means that you will
nominally need <code class="language-plaintext highlighter-rouge">TW+IW+log_2(N)</code> bits to hold your result.</p>

<p>This number, though, is often still too many.  You can often get by with less
than <code class="language-plaintext highlighter-rouge">log_2(N)</code> bits for the accumulation section simply because most of the
taps will be much less than their maximum value, many of them being a factor
of two (or more) less than that maximum
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
coefficient.</p>

<p>One way to figure out how many additional accumulator bits you will need for
adding the multiplication
results together is to try running a sample signal through the design.  The
most stressing case is to let every input have the maximum value,
<code class="language-plaintext highlighter-rouge">2^(IW-1)-1</code>, and the sign of the corresponding <code class="language-plaintext highlighter-rouge">h[k]</code> tap that it will be
multiplied by.  You can then adjust the accumulation width as necessary
to be certain to avoid overflow.</p>

<p>With this as background, we are now ready to consider building our design.
We’ll pause first, though, before we get into the Verilog code to discuss
our design goals.</p>

<h2 id="rtl-design-goals">RTL Design Goals</h2>

<p>For the purpose of the design presented below, we are going to build the most
general purpose high speed
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
that we can.  By “high speed” I mean running at the speed of your system
clock—whatever that may be.  By “general purpose” I mean three things:
First, the number of taps and their values will be arbitrary.  They will be
fixed at implementation time, but easily adjusted post implementation.  Second,
I intend to make this
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
a reconfigurable filter, so that the values of the various coefficients can
be reloaded post-synthesis as the application may require.  Third, I intend
to create and present
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">a design</a>
that can easily (within limits) be adjusted to accommodate more taps, or to
adjust tap, data, or output widths, to the design with little change.</p>

<p>Put together, these goals are:</p>

<ol>
  <li>
    <p>Easily reconfigured</p>
  </li>
  <li>
    <p>Adjustable length and variable widths (at design time)</p>
  </li>
  <li>
    <p>Adjustable coefficients (at runtime)</p>
  </li>
  <li>
    <p>Runs at the system clock rate, one input sample per system clock</p>
  </li>
</ol>

<p>The sad consequence of these choices is that this is also likely to be
one of the more expensive
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filters</a>
you will ever build.  However,
we shall build it anyway and later discuss methods which may be used to
reduce this cost.  Indeed, such discussions may form the basis of many
posts to come.</p>

<h2 id="chosen-structure">Chosen Structure</h2>

<p>If you look into a text book that describes how an
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR filter</a>
should be implemented, you are likely to find a picture looking like Fig 2:</p>

<table style="float: right"><caption>Fig 2: Filter Implementation</caption><tr><td><img src="/img/fir-form.svg" alt="Generic FIR implementation structure" width="380" /></td></tr></table>

<p>From this figure, you can see conceptually how each incoming data element
goes into a “tapped delay-line” structure (the bar across the top).  On ever
clock a new sample comes in, and all the samples within this structure shift
to the right.  Also, during that clock, every sample in the delay-line is
multiplied by the respective
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
coefficient, <code class="language-plaintext highlighter-rouge">h[k]</code>, and the results
are summed together.  The result of this summation is the output of the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>,
<code class="language-plaintext highlighter-rouge">y[n]</code>.</p>

<p>The number of “taps”, <code class="language-plaintext highlighter-rouge">N</code>, in this figure is easily identified by the number of
stages in the tapped delay line.</p>

<p>What Figure 2 doesn’t show is the second operand, <code class="language-plaintext highlighter-rouge">h[k]</code>, to each of the
multiplies (they wouldn’t fit in the image).  These are given by the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>’s
<a href="https://en.wikipedia.org/wiki/Impulse_response">impulse response</a>
values–the coefficients that we discussed above.</p>

<p>Were you to try to implement the
filter shown in the diagram, you would
quickly discover that the accumulator can easily cost many system clock ticks
to implement (depending upon the speed of your system clock).  Your design may
well fail timing as a result.  This would be unsatisfactory.</p>

<table style="float: right"><caption>Fig 3: A Single FIR Tap</caption><tr><td><img src="/img/fir-tap-single.svg" alt="A Single FIR tap" width="240" /></td></tr></table>

<p>Therefore, we shall consider a different approach.  Let’s instead separate
the circuitry of one tap from the circuitry of the next, as shown in Fig 3.</p>

<p>The neat thing about this approach is that we can keep the various stages
of this
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
within a localized area on the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
While that makes
timing easier, it still hasn’t fundamentally solved the problem of adding
many values together within a single clock.  Indeed, the only way to
get our clock frequency back up to speed will be to add a clock tick (or more)
within this string of taps.  The simplest place to do that is between pairs
of taps in the accumulator.  This leaves us with tap logic shown in Fig 4.</p>

<table style="float: left"><caption>Fig 4: Adding an extra delay per tap</caption><tr><td><img src="/img/fir-tap-w-delay.svg" alt="Figure: Tap structure with an extra delay per tap" width="240" /></td></tr></table>

<p>This <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap structure</a>
is actually quite unusual.  With this approach, the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
delay line now requires not <code class="language-plaintext highlighter-rouge">N</code> stages but <code class="language-plaintext highlighter-rouge">2N</code>, with the multiplies only
being applied every other stage.  Further, it’s not clear from this structure
that all of the additions are being applied to the right values in the
accumulation chain.</p>

<p>For now, I’ll present as a hand-waving evidence that this works the fact
that both tap output and accumulator output have been delayed together.
When we present the test bench for this design, you’ll see that this is
indeed the case.
Later, when we convert this filtering structure into something that can
handle a <a href="https://en.wikipedia.org/wiki/Linear_phase">symmetric filter</a>,
we’ll have to examine how we came up with this approach and explain it in
more detail.</p>

<p>For now, notice that by using this
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap structure</a>,
we can <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">string several of these taps
together</a>.
An overall view of this <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">strung out
design</a>
is shown in Fig 5 below.</p>

<table align="center" style="float: none"><caption>Fig 5: A filter is a sequence of taps</caption><tr><td><img src="/img/fir-generic.svg" alt="Figure: Creating a generic FIR from a series of tap structures" width="480" /></td></tr></table>

<p>Indeed, using this approach, we can string any arbitrary number of taps
together–subject only to the timing and logic capacity of your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<p>The amount of resources this
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
will use is likely to become a thorn in our side in a moment, but we’ll
ignore that today–for the sake of building the most <em>generic</em>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR filter</a>.</p>

<p>Before leaving this section, I must acknowledge all of those experts that might
also read this blog.  Having gotten this far, I am certain that many of
these experts are <em>cringing</em> at the design choices we have just made.
If you get a chance to chat with them, they will wisely declare that
<a href="https://en.wikipedia.org/wiki/Digital_filter">filtering</a>
at the full speed of the system clock is resource intensive–it shouldn’t be
done <em>if</em> it can be avoided.  They will also loudly proclaim that a
shift-register accumulator structure is a waste of resources–an accumulator
tree might make more sense.  Finally, they’ll point out that variable filter
coefficients can cost of lot of logic.  In deference to these experts, I will
first acknowledge the wisdom of their words and then beg their pardon.
Today, though, I am trying to keep the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
implementation simple and completely generic.</p>

<p>We can come back to <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">this
filter</a>
later to improve upon it.  All of these improvements just mentioned, and
perhaps others as well, are fair game for that later discussion.</p>

<p>In the meantime, let’s examine how to build these two components: the
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap structure</a>
itself, as well as the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">tapped delay line
structure</a>
holding these taps together.</p>

<h2 id="a-simple-fir-tap">A simple FIR tap</h2>

<p>The first component of our
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
that we shall discuss is the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap structure</a>.
Remember that our goal is to <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">string
together</a>
many <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">taps with the same code and
structure</a>
to them.  Further, you may also remember that the logic necessary for this
tap (Fig 4 above) is primarily multiplying by a filter coefficient, <code class="language-plaintext highlighter-rouge">h[k]</code>,
and accumulating the result.  So, that’s what we’ll do here.</p>

<p>We’ll start with the multiply.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">product</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">o_tap</span> <span class="o">*</span> <span class="n">i_sample</span><span class="p">;</span></code></pre></figure>

<p>Don’t forget to declare both <code class="language-plaintext highlighter-rouge">o_tap</code> and <code class="language-plaintext highlighter-rouge">i_sample</code> as <em>signed</em>
values, as the results of a signed digital multiply are different from those
of an unsigned multiply.</p>

<p>On the next clock (multiplies can be slow), we’ll add the result of the
multiply to a partial accumulator value that has been passed to us in
<code class="language-plaintext highlighter-rouge">i_partial_acc</code>.  This will create our tap’s output, <code class="language-plaintext highlighter-rouge">o_acc</code>.  After the last
tap, this will be the final output of the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_acc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">o_acc</span> <span class="o">&lt;=</span> <span class="n">i_partial_acc</span>
			<span class="o">+</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="o">-</span><span class="p">(</span><span class="n">TW</span><span class="o">+</span><span class="n">IW</span><span class="p">))</span><span class="o">{</span><span class="n">product</span><span class="p">[(</span><span class="n">TW</span><span class="o">+</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">}}</span><span class="p">,</span>
					<span class="n">product</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>You may notice in this example that both of these always blocks used a
synchronous reset input.  This allows all of the logic to clear, together
with any memory within the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>,
on any reset.  If you don’t need the reset structure, just set the value
to a constant <code class="language-plaintext highlighter-rouge">1'b0</code> and the synthesizer should remove it.  The other thing
to notice is that we are using a <a href="/blog/2017/08/14/strategies-for-pipelining.html">global CE based pipelining
strategy</a>.
Under that strategy, nothing is allowed to change unless the CE is true.  This
is why all of the subsequent logic is gated by <code class="language-plaintext highlighter-rouge">i_ce</code>.</p>

<p>It is worth mentioning that some
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
architectures can combine the high speed multiply with the accumulation
step into one operation.  Feel free to design for your hardware as you see
fit.</p>

<p>The next required step, though, is to forward the input sample data through
a series of registers.  At a first glance, this might look simply like,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="n">o_sample</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="n">o_sample</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span></code></pre></figure>

<p>This simple sample in to sample out structure would implement the tap
structure shown in Fig 3 above.
However, were we to keep this logic as is, the outputs from the individual
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">filter taps</a>.
wouldn’t line up with the accumulator’s output chain.  Both would
move through the process at the same speed, and so you’d end up accumulating
<code class="language-plaintext highlighter-rouge">H(0)x[n]</code> instead of the desired
<a href="https://en.wikipedia.org/wiki/Convolution">convolution</a>.</p>

<p>So, instead, we’ll add an extra delay, <code class="language-plaintext highlighter-rouge">delayed_sample</code>, between the
samples–as we discussed with Fig 4 above.
This will allow the partial accumulator structure to remain aligned with the
data as they both work their way through the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap structures</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">delayed_sample</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">o_sample</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">delayed_sample</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span>
		<span class="n">o_sample</span> <span class="o">&lt;=</span> <span class="n">delayed_sample</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>That leaves one piece of logic remaining in our
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">generic tap</a>:
how to set the coefficients in the first place.  We’ll choose to do this in
one of two ways, dependent upon the logic parameter <code class="language-plaintext highlighter-rouge">FIXED_TAPS</code>.</p>

<p>If <code class="language-plaintext highlighter-rouge">FIXED_TAPS</code> is true (not zero), then the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">parent
module</a>
will feed us our tap
values and we don’t need to do anything with them but use them.  While my
preference would be to set each tap via a <code class="language-plaintext highlighter-rouge">parameter</code>, this causes a problem
in the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">parent
module</a>
which would like to set all of the tap values at the
same time via a <code class="language-plaintext highlighter-rouge">$readmemh</code>.  Instead, we allow our taps coefficients, the
<code class="language-plaintext highlighter-rouge">h[k]</code> values we discussed above, to be set from wires passed to this
module.  This allows the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">parent module</a>
(to be discussed next) to set all of the filter coefficients
via a single <code class="language-plaintext highlighter-rouge">$readmemh</code> command within an initial statement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">generate</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FIXED_TAPS</span><span class="p">)</span>
	<span class="k">assign</span>	<span class="n">o_tap</span> <span class="o">=</span> <span class="n">i_tap</span><span class="p">;</span>
<span class="k">else</span> <span class="p">...</span></code></pre></figure>

<p>This works well for fixed coefficients, but we still need the logic for
our variable coefficient capability.</p>

<p>For variable coefficients, we’ll set <code class="language-plaintext highlighter-rouge">FIXED_TAPS</code> to false (i.e. <code class="language-plaintext highlighter-rouge">1'b0</code>).
We’ll also create logic to set our taps dynamically.
Further, each tap will start with an <code class="language-plaintext highlighter-rouge">INITIAL_VALUE</code> (typically zero).  Then,
during any design run, on any clock where the user is setting taps we’ll just
shift each tap down the line.  We’ll use the input <code class="language-plaintext highlighter-rouge">i_tap_wr</code> to indicate that
we need to shift the tap value down the line.</p>

<p>This leads us to the following code to set the taps within our design.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="p">...</span>
<span class="k">else</span> <span class="k">begin</span>
	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">TW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">tap</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">tap</span> <span class="o">=</span> <span class="n">INITIAL_VALUE</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_tap_wr</span><span class="p">)</span>
			<span class="n">tap</span> <span class="o">&lt;=</span> <span class="n">i_tap</span><span class="p">;</span>
	<span class="k">assign</span> <span class="n">o_tap</span> <span class="o">=</span> <span class="n">tap</span><span class="p">;</span>
<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Notice that here’s no reset in this structure.  That allows us to reset
the sample values separate from the coefficients.  This also allows us to
set the coefficients while holding the rest of the filter in reset.</p>

<p>I should warn you: this code can be expensive in terms of logic resources.
Should we count logic resources, you may notice that this requires no LUTs.
The <code class="language-plaintext highlighter-rouge">i_tap_wr</code> line can be connected directly to the CE input of the for
tap, and no further logic is required.  However, this structure <em>will</em> require
one flip flop per bit per tap in your design.  Hence a 256-tap
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
with 16-bit values will cost you 4096 flip-flops.</p>

<p>The other problem with this dynamic tap coefficient approach is that your
synthesis tool cannot optimize any of the multiplies.  Logic that might
recognize a multiplication by zero cannot be optimized away with this
approach.  Multiplication by smaller coefficients cannot be
trimmed.  Neither is it possible to reduce the logic when multiplying by a
power of two.  Hence, there is a cost for such a dynamic implementation.</p>

<p>As a homework project, try this:  Look at how much logic gets used on a per
tap, per bit basis.  Then turn on <code class="language-plaintext highlighter-rouge">FIXED_TAPS</code>, apply the same coefficients,
and see what changes.</p>

<h2 id="stringing-the-taps-together-into-a-filter">Stringing the taps together into a filter</h2>

<p>Now that we’ve defined our
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap structures</a>,
all that remains is to <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">string them
together</a>
as in Fig 5 above.  This will entail connecting the data inputs
from one tap to the next in a streaming fashion, as well as connecting the
tap values–should the user wish to change them.  Finally, we’ll need to
pull our final accumulator value together to return to the rest of the design.</p>

<p>The first step, though, is going to be setting the tap coefficients for
the case where they are fixed.  We’d like to do this via a <code class="language-plaintext highlighter-rouge">$readmemh</code>
command–since it’s the simplest to do.  So, if we have <code class="language-plaintext highlighter-rouge">FIXED_TAPS</code>, we’ll
use a <code class="language-plaintext highlighter-rouge">$readmemh</code> to set the <code class="language-plaintext highlighter-rouge">h[k]</code> inputs to the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap structures</a>.
On the other hand, if <code class="language-plaintext highlighter-rouge">FIXED_TAPS</code> is not true, we’ll only set the first tap
and then let the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap-modules</a>
push the taps down the line.</p>

<p>We’re also going to use a <code class="language-plaintext highlighter-rouge">generate</code> statement, since this will allow us to
use a <code class="language-plaintext highlighter-rouge">for</code> loop in a moment.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">genvar</span>	<span class="n">k</span><span class="p">;</span>
<span class="k">generate</span>
<span class="k">if</span><span class="p">(</span><span class="n">FIXED_TAPS</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">initial</span> <span class="p">$</span><span class="nb">readmemh</span><span class="p">(</span><span class="s">"taps.hex"</span><span class="p">,</span> <span class="n">tap</span><span class="p">);</span>

	<span class="k">assign</span>	<span class="n">tap_wr</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
	<span class="k">assign</span>	<span class="n">tap_wr</span> <span class="o">=</span> <span class="n">i_tap_wr</span><span class="p">;</span>
	<span class="k">assign</span>	<span class="n">tap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i_tap</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>At this point I feel like I’m teaching a drawing class.  I’ve outlined two
items, and then I’m about to tell the class to just fill in the details.
That’s about what happens next.</p>

<p>This next step is to create a for loop where we instantiate each of the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">taps</a>.</p>

<p>This loop first sets the parameters of
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">each tap structure</a>
to match our overall
parameters: the input data width, <code class="language-plaintext highlighter-rouge">IW</code>, the output width, <code class="language-plaintext highlighter-rouge">OW</code>, the width of
the taps, <code class="language-plaintext highlighter-rouge">TW</code>, etc.  Then we apply the rest of the logic.  Each
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap-module</a> is
given an input <code class="language-plaintext highlighter-rouge">h[k]</code> coefficient and then connected to an <code class="language-plaintext highlighter-rouge">h[k+1]</code> value to
be sent to the next tap.
Each <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap-module</a>
is also passed a sample, and it produces the next sample
to be passed down the sample line.  Finally, we pass the partial accumulator
from one
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap-module</a>
to the next.</p>

<p>You can see all three of these steps below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">NTAPS</span><span class="p">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span>
<span class="nl">begin:</span> <span class="n">FILTER</span>

	<span class="n">firtap</span> <span class="p">#(.</span><span class="n">FIXED_TAPS</span><span class="p">(</span><span class="n">FIXED_TAPS</span><span class="p">),</span>
			<span class="p">.</span><span class="n">IW</span><span class="p">(</span><span class="n">IW</span><span class="p">),</span> <span class="p">.</span><span class="n">OW</span><span class="p">(</span><span class="n">OW</span><span class="p">),</span> <span class="p">.</span><span class="n">TW</span><span class="p">(</span><span class="n">TW</span><span class="p">),</span>
			<span class="p">.</span><span class="n">INITIAL_VALUE</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
		<span class="n">tapk</span><span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="n">i_reset</span><span class="p">,</span>
			<span class="c1">// Tap update circuitry</span>
			<span class="n">tap_wr</span><span class="p">,</span> <span class="n">tap</span><span class="p">[</span><span class="n">NTAPS</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">],</span> <span class="n">tapout</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
			<span class="c1">// Sample delay line</span>
			<span class="n">i_ce</span><span class="p">,</span> <span class="n">sample</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">sample</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
			<span class="c1">// The output accumulation line</span>
			<span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FIXED_TAPS</span><span class="p">)</span>
		<span class="k">assign</span>	<span class="n">tap</span><span class="p">[</span><span class="n">NTAPS</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tapout</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>When all is said and done, all that remains is to produce our
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
output value and we are done.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">NTAPS</span><span class="p">];</span></code></pre></figure>

<p>That’s all that it takes to build a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">generic</a>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR filter</a>.
You don’t need a core generator to do this.  You don’t need a GUI.  You just
need to understand what an
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR filter</a>
is, how it operates, and then just a touch of Verilog code.  In this case,
you can find the code for the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/firtap.v">tap module
here</a>, and the
code for the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">overall generic filter module
here</a>.</p>

<p>We’ll save the <a href="/dsp/2017/11/04/genfil-tb.html">test bench for another
post</a>, as this one is long
enough already.</p>

<h2 id="how-did-we-do">How did we do?</h2>

<p>While this is a <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">basic
generic</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>,
and while the approach behind it will work for the general filtering case,
it isn’t a very powerful
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.
The reason is not that this Verilog code
cannot describe an arbitrarily long
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>,
nor is it because this code cannot describe the taps with enough fidelity to
create a truly powerful
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>.
Instead, what I mean to say is that this approach to
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
implementation tends to be too resource expensive for powerful
<a href="https://en.wikipedia.org/wiki/Digital_filter">filters</a>: it is likely to cost
too many LUTs, too many multiplies, and in general too much of your precious
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>’s
resources.  This may force you to buy a more expensive
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
or keep you from having as much free space to do other things on your current
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
As a result, we’ll need to do better.</p>

<p>Indeed, we can often build better
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR filters</a>
than this.</p>

<p>Here are some basic improvements that we can make to <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">this filter
design</a>:</p>

<ul>
  <li>
    <p>We could use an addition tree.</p>

    <p>An addition tree would start by adding adjacent values together, then add
the results of those adjacent sums and so on rather than adding values
together in a long line.  This will allow us to use the log base two of
the number of additions.</p>

    <p>Doing this would remove all the extra data stages, as well as trimming
the number of accumulator stages.  It would also increase the wire length
necessary to send the addition results from one place to the next–but this
may be negligible for low enough clock speeds.  The problem is that such
addition trees aren’t easily reconfigured for different filter lengths–not
that they aren’t valuable, useful, or less expensive.</p>
  </li>
  <li>
    <p>We could exploit the structure of the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a> coefficients.</p>

    <p>Most filter design methods, to include the <a href="https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm">Parks-McClellan filter design
algorithm</a>,
produce <a href="https://en.wikipedia.org/wiki/Digital_filter">filters</a>
with <a href="https://en.wikipedia.org/wiki/Linear_phase">linear phase</a>.
Such <a href="https://en.wikipedia.org/wiki/Linear_phase">linear phase</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filters</a>
have coefficients that are symmetric about some mid-point.  As a result,
these can be implemented using only half as many multiplies.</p>
  </li>
  <li>
    <p>We could also choose a filter, or combination of filters, that is easier to
implement.</p>

    <p>For example, a <a href="/dsp/2017/10/16/boxcar.html">block average</a>
is easier to implement than a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">generic</a>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR filter</a>.
Much easier in fact.  A series of
<a href="/dsp/2017/10/16/boxcar.html">block average</a>,
one after another,
<em>might</em> be able to implement a filter of the type you might need or want.
It might also fit nicely as a component of a larger
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.</p>
  </li>
  <li>
    <p>We could fix the filter coefficients</p>

    <p>For the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">design presented
above</a>,
this is as simple as adjusting the <code class="language-plaintext highlighter-rouge">FIXED_TAPS</code> parameter and
creating a hex file containing the coefficients for <code class="language-plaintext highlighter-rouge">$readmemh</code>.</p>
  </li>
  <li>
    <p>We could use multirate techniques</p>

    <p>By “multirate techniques”, I mean that we might include an <a href="https://en.wikipedia.org/wiki/Sample-rate_conversion">upsampler or
downsampler</a> as
part of our filter design and implementation.  If we could,
for example, downsample the incoming data stream sufficiently, then it might
be possible to use a block RAM based tapped-delay line and a single shared
multiply for a tremendous resource savings.</p>

    <p>These techniques can often form the basis of some of the cheapest
<a href="https://en.wikipedia.org/wiki/Digital_filter">filtering</a>
approaches, especially when small bandwidths are of interest.</p>

    <p>We’ll need to come back and examine these, though we will by no means be
able to exhaust this approach to
<a href="https://en.wikipedia.org/wiki/Digital_filter">filtering</a>.</p>
  </li>
</ul>

<p>The one thing we haven’t done in this post is to generate a
<a href="/dsp/2017/11/04/genfil-tb.html">test bench</a> for
this <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">generic
filter</a>.
We’ll save that task for a <a href="/dsp/2017/11/04/genfil-tb.html">later
post</a>–after
we’ve created the <a href="/dsp/2017/10/02/cordic-tb.html">test bench
for our</a>
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>.</p>

<p>Since writing this post, a friend has shown me an <a href="/dsp/2017/09/29/cheaper-fast-fir.html">even better, cheaper
method</a> of creating a
generic high-frequency
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.
Hence, while the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/genericfir.v">code presented
above</a>
works, the task could be done without the input sample delay line.  We’ll
have to <a href="/dsp/2017/09/29/cheaper-fast-fir.html">come back to that
later</a>,
therefore, and examine <a href="/dsp/2017/09/29/cheaper-fast-fir.html">this alternative
implementation</a>.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And before him shall be gathered all nations: and he shall separate them one from another, as a shepherd divideth his sheep from the goats (Matt 25:32)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
