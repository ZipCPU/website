<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A better filter implementation for slower signals</title>
  <meta name="description" content="Fig 1. A Generic filter implementation">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2017/12/30/slowfil.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">A better filter implementation for slower signals</h1>
    <p class="post-meta"><time datetime="2017-12-30T00:00:00-05:00" itemprop="datePublished">Dec 30, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <table align="center" style="float: right"><caption>Fig 1. A Generic filter implementation</caption><tr><td><img src="/img/fir-form.svg" alt="" width="480" /></td></tr></table>

<p>We’ve slowly been working through several
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">DSP</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
<a href="https://github.com/ZipCPU/dspfilters/tree/master/rtl">implementations</a> on
<a href="https://zipcpu.com/">this blog</a>.  Each of these
<a href="https://github.com/ZipCPU/dspfilters/tree/master/rtl">implementations</a>
includes the logic necessary to evaluate a typical
<a href="https://en.wikipedia.org/wiki/Convolution">convolution</a>,
such as the one shown in Fig 1 on the right.</p>

<p>We’ve presented both a
<a href="/dsp/2017/09/15/fastfir.html">fairly generic FIR filter implementation</a>
for high rate data signals, as well as a
<a href="/dsp/2017/09/29/cheaper-fast-fir.html">simple modification to that implementation</a>
that uses fewer resources but has a higher fanout.  We’ve also discussed a
<a href="/dsp/2017/11/04/genfil-tb.html">generic test harness</a>
that can be used to test and prove some of
<a href="https://github.com/ZipCPU/dspfilters">these filters</a>,
and even showed <a href="/dsp/2017/12/06/fastfir-tb.html">how that harness might be
applied</a>.
Further, we’ve discussed the usefulness of a
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>’s
<a href="https://en.wikipedia.org/wiki/Frequency_response">frequency response</a>,
as well as
<a href="/dsp/2017/11/22/fltr-response.html">how to measure it</a>
using the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp">same test harness</a>.</p>

<p>However, if you want to try any of these initial filter implementations
on signals with a slower sample rate, such as audio signals, you’ll
quickly find these <em>faster</em> filtering implementations to be very resource
intensive.</p>

<p>For example, if you want to apply a 2047 tap filter to a 48kHz audio
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>,
while running your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
at a 100MHz system clock, then the
<a href="/dsp/2017/09/15/fastfir.html">generic filter implementation</a>
will cost you 2047 hardware multiplies.  This will force you to the most
expensive and feature rich Virtex-7 FPGA, the
<a href="https://www.digikey.com/product-detail/en/xilinx-inc/XC7VH870T-1FLG1932C/XC7VH870T-1FLG1932C-ND/5247347">XC7VH870T</a>–a chip that will cost
you a minimum of $18k USD today on
<a href="https://www.digikey.com">Digikey</a>.  On the other hand, if you used the
implementation presented below, you might still be able to use an
<a href="https://www.digikey.com/product-detail/en/xilinx-inc/XC7A15T-1FTG256C/122-1930-ND/5248117">Artix-7 priced at less than $26</a> on
<a href="https://www.digikey.com">Digikey</a>, and available as part of many hobby
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
boards for fairly reasonable prices (about $100USD).
<a href="https://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/">[1]</a>
<a href="https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/">[2]</a></p>

<p>For all of these reasons, it’s important to know how to build a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
that re-uses its hardware multiplies to the maximum extent possible.  The
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
that we’ll present below, for example, uses only one hardware
multiply–although that will limit the number of coefficients this
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">implementation</a>
can handle.</p>

<p>Let’s take a look at what how this
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
will need to operate, and then look at how to
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">implement</a>
it.  Once implemented, we’ll show how easy it is
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">to test</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>
using the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp">test harness</a>
we built some time ago.</p>

<h2 id="the-operation">The Operation</h2>

<p>If you’ve gone through the posts above, then you are already aware that a
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a>
evaluates a
<a href="https://en.wikipedia.org/wiki/Convolution">convolution</a>.
For example, if <code class="language-plaintext highlighter-rouge">x[n]</code> were our input, <code class="language-plaintext highlighter-rouge">y[n]</code> our output, and <code class="language-plaintext highlighter-rouge">h[n]</code> a
series of coefficients, then we might write that,</p>

<table align="center" style="float: none"><tr><td><img src="/img/fir-convolution.png" alt="" width="255" /></td></tr></table>

<p>Pictorially, this equation describes the operation shown in Fig 1 above.</p>

<p>Today’s <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter
implementation</a>
will follow directly from a straight-forward evaluation of the summation
in the equation above.  In other words, we’ll start by setting an
accumulator to the first value,</p>

<table align="center" style="float: none"><tr><td><img src="/img/slowfil/fir-slowfil-acc-zero.png" alt="" width="205" /></td></tr></table>

<p>Then, on each subsequent clock we’ll add the next value to it,</p>

<table align="center" style="float: none"><tr><td><img src="/img/slowfil/fir-slowfil-acc-step.png" alt="" width="409" /></td></tr></table>

<table align="center" style="float: right"><caption>Fig 2. A Time Multiplexed filter implementation</caption><tr><td><img src="/img/slowfil/fir-slow-form.svg" alt="" width="480" /></td></tr></table>

<p>Fig 2 on the right shows a diagram of how this approach might look.
Basically, at every step we’ll read both an <code class="language-plaintext highlighter-rouge">h[k]</code> value and an <code class="language-plaintext highlighter-rouge">x[n-k]</code>
value from separate memories, multiply the two together, and add the product
together with the value from an accumulator.  Once all the values have
been added together, we’ll use this accumulated result as our output.</p>

<table align="center" style="float: none"><tr><td><img src="/img/slowfil/fir-slowfil-acc-done.png" alt="" width="204" /></td></tr></table>

<p>In Verilog, this might look something like the following.  On the first
clock, we’d read one tap from the tap (coefficient) memory, and multiply
it by our incoming data sample, <code class="language-plaintext highlighter-rouge">i_sample</code>.  The result of that product
could then be used to initialize an accumulator, <code class="language-plaintext highlighter-rouge">r_acc</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// first clock</span>
	<span class="n">tap</span> <span class="o">&lt;=</span> <span class="n">tapmem</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="c1">// second clock</span>
	<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">tap</span> <span class="o">*</span> <span class="n">i_sample</span><span class="p">;</span>

	<span class="c1">// third clock</span>
	<span class="n">r_acc</span> <span class="o">&lt;=</span> <span class="n">product</span><span class="p">;</span></code></pre></figure>

<p>Sounds simple so far, right?  Okay, so we’ve ignored any pipeline scheduling
(<code class="language-plaintext highlighter-rouge">i_ce</code> will only be true for one clock in <code class="language-plaintext highlighter-rouge">N</code>), but let’s come back to that
in a moment.</p>

<p>Further, we’re going to need to read from block RAM memory on every clock
following.  This means we’ll need to place this new sample value into
memory, and then increment the write pointer.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Write the new data to memory, then increment the memory pointer</span>
	<span class="n">dmem</span><span class="p">[</span><span class="n">dwidx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span>
	<span class="n">dwidx</span> <span class="o">&lt;=</span> <span class="n">dwidx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>	<span class="c1">// increment the memory write pointer</span></code></pre></figure>

<p>We’re also going to want to be able to read the coefficient index pointer
and the data index pointer on the next clock, so let’s set these as part
of the same clock that the new data shows in on.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Still on i_ce</span>
	<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">dwidx</span><span class="p">;</span></code></pre></figure>

<p>After the accumulator has been given an initial value, we’ll then need to read
both the coefficient values and the data values from an on-chip block RAM
memory.  Placing
the data into a data memory to make this happen will require a memory write
and some memory address manipulation.  That means that the second part of
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this algorithm</a>
might look like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// Now, between clocks, we'll need to read the data and the coefficient</span>
	<span class="n">data</span> <span class="o">&lt;=</span> <span class="n">dmem</span><span class="p">[</span><span class="n">didx</span><span class="p">];</span>	<span class="c1">// Read data from the sample memory, x[n-k]</span>
	<span class="n">tap</span> <span class="o">&lt;=</span> <span class="n">tapmem</span><span class="p">[</span><span class="n">tidx</span><span class="p">];</span>	<span class="c1">// Read from the coefficient memory, h[k]</span>

	<span class="c1">// Update the pointers to each.  Notice that the coefficient index,</span>
	<span class="c1">// tidx increases while the data index decreases--just as we have</span>
	<span class="c1">// above.</span>
	<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">didx</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="n">tidx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="c1">// and calculate the product</span>
	<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">tap</span> <span class="o">*</span> <span class="n">data</span><span class="p">;</span>

	<span class="c1">// Use the product to update the accumulator</span>
	<span class="n">r_acc</span> <span class="o">&lt;=</span> <span class="n">r_acc</span> <span class="o">+</span> <span class="n">product</span></code></pre></figure>

<p>Once we are done with all of the above, we’ll set the <a href="/blog/2017/08/14/strategies-for-pipelining.html">traveling
CE</a>
values associated with the output, <code class="language-plaintext highlighter-rouge">o_ce</code>, and set the output
value according to the last <code class="language-plaintext highlighter-rouge">r_acc</code> value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">end</span> <span class="k">else</span> <span class="c1">// if (done)</span>
<span class="k">begin</span>
	<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="n">r_acc</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>That’s the general gist of what we need to do.  Sadly, however, the code above
has multiple timing errors and pipeline scheduling conflicts within it.
For example, there should
be a clock delay between reading from memory and using the result, and another
clock delay between multiplying two numbers together and using that result.
As a result, the logic above will never work, but as a simple first draft
it should be able to convey (roughly) what it is we hope to do.</p>

<h2 id="the-basic-filter-written-in-c">The basic filter, written in C++</h2>

<p>Perhaps if you have a software background, you might appreciate seeing this
code written out in C++.  The following is an excerpt from an
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
implementation found in my own personal signal processing library.  The code
uses double’s instead of fixed point, but it’s still basically the same thing.</p>

<p>This C++ algorithm depends upon an array of <code class="language-plaintext highlighter-rouge">m_len</code> coefficients, <code class="language-plaintext highlighter-rouge">m_coeff</code>.
This array will be initialized with the coefficients associated with the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
before starting.</p>

<p>It also needs an array of data, <code class="language-plaintext highlighter-rouge">m_data</code>, of the same length.  Rather than
moving all the data through the array at every point in time, we’ll just
keep track of the address of the last data element in the tapped delay line,
<code class="language-plaintext highlighter-rouge">m_loc</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">FIR</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">m_len</span><span class="p">;</span>	<span class="c1">// Number of taps in the filter</span>
	<span class="kt">double</span>	<span class="o">*</span><span class="n">m_coeff</span><span class="p">;</span>

	<span class="c1">// ...</span>
	<span class="kt">int</span>	<span class="n">m_loc</span><span class="p">;</span>		<span class="c1">// Location of the last sample in the buffer</span>
	<span class="kt">double</span>	<span class="o">*</span><span class="n">m_data</span><span class="p">;</span>	<span class="c1">// Data buffer, double[m_len]</span>

	<span class="c1">// ...</span>
	<span class="c1">// Declare our operator</span>
	<span class="kt">double</span>	<span class="n">apply</span><span class="p">(</span><span class="kt">double</span> <span class="n">i_sample</span><span class="p">);</span>
<span class="p">};</span></code></pre></figure>

<p>Were this written in Verilog, such as we will do in the next section, these two
arrays would be captured in block RAMs.</p>

<p>To evaluate the
<a href="https://en.wikipedia.org/wiki/Convolution">convolution</a> via the
equation above, we’ll run the following code when given a new sample,
<code class="language-plaintext highlighter-rouge">i_sample</code>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">double</span>	<span class="n">FIR</span><span class="o">::</span><span class="n">apply</span><span class="p">(</span><span class="kt">double</span> <span class="n">i_sample</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span>             <span class="n">i</span><span class="p">,</span> <span class="n">ln</span><span class="p">;</span>
	<span class="kt">double</span>  <span class="n">acc</span><span class="p">,</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span></code></pre></figure>

<p>Our first step will be to record the new sample into the data memory.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_data</span><span class="p">[</span><span class="n">m_loc</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">dat</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m_loc</span> <span class="o">&gt;=</span> <span class="n">m_len</span><span class="p">)</span>
		<span class="n">m_loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>After this point, we’ll enter a loop whereby we grab one sample from
data memory and one coefficient from the coefficient memory, multiply the
two together, and accumulate the result into an accumulator, <code class="language-plaintext highlighter-rouge">acc</code>.  We’ll
start the accumulator at zero.  Further, after each sample,
we’ll increase the address in coefficient memory, and decrease the address
in data memory–just as the formula above indicated.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">acc</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
	<span class="n">d</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_loc</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">c</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ln</span>  <span class="o">=</span> <span class="n">m_loc</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ln</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">acc</span> <span class="o">+=</span> <span class="o">*</span><span class="n">c</span><span class="o">++</span> <span class="o">*</span> <span class="o">*</span><span class="n">d</span><span class="o">--</span><span class="p">;</span></code></pre></figure>

<p>The fact that the data memory isn’t centered makes this a touch more
complicated.  What that means is that if you start reading backwards
from the middle of memory (where the most recent sample was), you
will eventually run off the beginning of the memory.  Fig 3 shows this below.</p>

<table align="center" style="float: none"><caption>Fig 3. Data memory contains both old and new data</caption><tr><td><img src="/img/slowfil/fir-slow-memory.svg" alt="" width="780" /></td></tr></table>

<p>In this figure, you can see the location <code class="language-plaintext highlighter-rouge">m_loc</code> (just right of the center
of the figure) which is one past where
the new data, <code class="language-plaintext highlighter-rouge">i_sample</code>, has just been written.  You can also see how
the <code class="language-plaintext highlighter-rouge">x[n-k]</code> sequence extends to the left of this location.  Once this
data sequence runs off the end of memory to the left, a second pass is
required to get the rest of the data coming from the far end on the right.
This second pass continues back to where we started, making sure every data
sample in memory, and every coefficient value, is used exactly once.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">d</span>   <span class="o">=</span> <span class="n">m_data</span><span class="p">[</span><span class="n">m_len</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">ln</span>  <span class="o">=</span> <span class="n">ln</span><span class="o">-</span><span class="n">m_loc</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ln</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">acc</span> <span class="o">+=</span> <span class="o">*</span><span class="n">c</span><span class="o">++</span> <span class="o">*</span> <span class="o">*</span><span class="n">d</span><span class="o">--</span><span class="p">;</span></code></pre></figure>

<p>Once all of the multiplies have been completed, the result is returned.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">return</span> <span class="n">acc</span><span class="p">;</span>
<span class="err">}</span></code></pre></figure>

<p>This is the basic algorithm we will write in Verilog below.  There will be
some differences though.  The first and most obvious difference is the fact
that several parts of this algorithm will run in parallel–this is <a href="/blog/2017/09/18/clocks-for-sw-engineers.html">running in
hardware</a>
after all.  The next, not
quite so obvious difference, is that if the memory address is limited to
some finite number of bits, then we won’t need to pay any attention to the
memory break shown above in Fig 3.  Finally, the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
algorithm <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">implemented in
Verilog</a>
will be written using fixed point numbers instead of the <code class="language-plaintext highlighter-rouge">double</code>-precision
floating point numbers that are so easy to use in the C++ above.</p>

<p>Before moving on, I should make one point about the code above.  This C/C++
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
implementation is only practical for
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>s
with <a href="https://en.wikipedia.org/wiki/Impulse_response">impulse responses</a>
shorter than about 64 samples.  Anything more than 64 samples and you’ll
want to use an <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">FFT</a>
based
<a href="https://en.wikipedia.org/wiki/Digital_filter">filtering</a>
approach.  The differences between the two approaches will become
particularly stark after doubling the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
length only a few times.</p>

<h2 id="verilog">Verilog</h2>

<table align="center" style="float: right"><caption>Fig 4. Test Harness Filter Interface</caption><tr><td><img src="/img/fir-ports.svg" alt="" width="240" /></td></tr></table>

<p>You may remember from our
<a href="/dsp/2017/11/04/genfil-tb.html">test harness discussion</a>
that as long as a
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
implementation has the ports we discussed then, and shown again here in
Fig 4 at the right, that we can continue using our <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp">generic filtering test
harness</a>.
While we’ll be able to
<a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">inherit</a>
and modify
the <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp">test harness</a>
with additional functionality in the next section, we’ll
need to start out this section by remembering that our
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
implementation will need to have a reset, and the ability to load
taps, in addition to samples coming in and going out.</p>

<p>We’ll start with the ability to set our
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
coefficients.  As with many of our
<a href="https://github.com/ZipCPU/dspfilters/tree/master/rtl">other filters</a>,
we’ll allow a parameter <code class="language-plaintext highlighter-rouge">FIXED_TAPS</code> to express whether or not this
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
has a tap-update capability at all.  If the coefficients are fixed, then
we’ll <code class="language-plaintext highlighter-rouge">$readmemh</code> them from a <code class="language-plaintext highlighter-rouge">.hex</code> file whose name is given in
<code class="language-plaintext highlighter-rouge">INITIAL_COEFFS</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">FIXED_TAPS</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">initial</span> <span class="p">$</span><span class="nb">readmemh</span><span class="p">(</span><span class="n">INITIAL_COEFFS</span><span class="p">,</span> <span class="n">tapmem</span><span class="p">);</span>
		<span class="c1">// ...</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>On the other hand, if our
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
coefficients are not fixed, <code class="language-plaintext highlighter-rouge">FIXED_TAPS</code> will be false, and we’ll need
to load our coefficients into memory.  To do this, we’ll start with a
memory index, <code class="language-plaintext highlighter-rouge">tapwidx</code>, or tap writing index.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="kt">reg</span>	<span class="p">[(</span><span class="n">LGNTAPS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">tapwidx</span><span class="p">;</span></code></pre></figure>

<p>We’ll set this index to zero initially, and to return to zero upon any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">initial</span>	<span class="n">tapwidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
				<span class="n">tapwidx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Otherwise, anytime the <code class="language-plaintext highlighter-rouge">i_tap_wr</code> signal is high, a new coefficient is present
in <code class="language-plaintext highlighter-rouge">i_tap</code> which we’ll write to coefficient memory.  We’ll also need to
increment this index.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_tap_wr</span><span class="p">)</span>
				<span class="n">tapwidx</span> <span class="o">&lt;=</span> <span class="n">tapwidx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Here’s where we actually use the tap (coefficient) writing index, <code class="language-plaintext highlighter-rouge">tapwidx</code>
to write into the coefficient memory, <code class="language-plaintext highlighter-rouge">tapmem</code>.  This is also the section
of the code to specify any memory initialization, so we’ll initialize the
memory if the <code class="language-plaintext highlighter-rouge">INITIAL_COEFFS</code> file name is empty.  Note that the <code class="language-plaintext highlighter-rouge">if</code>
statement is <em>outside</em> of the <code class="language-plaintext highlighter-rouge">initial</code> block.  That will keep the
synthesizer from looking for this file if the name hasn’t been given.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">INITIAL_COEFFS</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">initial</span> <span class="p">$</span><span class="nb">readmemh</span><span class="p">(</span><span class="n">INITIAL_COEFFS</span><span class="p">,</span> <span class="n">tapmem</span><span class="p">);</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_tap_wr</span><span class="p">)</span>
				<span class="n">tapmem</span><span class="p">[</span><span class="n">tapwidx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_tap</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>That’s all that’s required for dynamically setting or adjusting coefficient
memory.  We started with an <code class="language-plaintext highlighter-rouge">i_reset</code> signal to clear the index, and then
wrote one coefficient and stepped the index on any clock where <code class="language-plaintext highlighter-rouge">i_tap_wr</code> was
true.</p>

<p>So let’s now turn our attention to the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter
implementation</a>
itself.</p>

<p>We’ll start with updating the data memory, herein called <code class="language-plaintext highlighter-rouge">dmem</code>.  We’ll
use a data memory write index, <code class="language-plaintext highlighter-rouge">dwidx</code> to do this.  Hence, on every <code class="language-plaintext highlighter-rouge">i_ce</code>
value, we’ll increment the data memory write index,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">dwidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
			<span class="n">dwidx</span> <span class="o">&lt;=</span> <span class="n">dwidx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>and write the new sample into the data memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
			<span class="n">dmem</span><span class="p">[</span><span class="n">dwidx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span></code></pre></figure>

<p>That may be about as simple as any logic could get!</p>

<p>That said, there is a subtlety associated with this approach.
Notice in this process how the data memory update process is <em>independent</em>
of the <code class="language-plaintext highlighter-rouge">i_reset</code> signal.  It is dependent upon new sample data
only.  Further, this will allow the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
to immediately start with valid data following any reset.</p>

<p>This <em>feature</em>, however, will become a thorn in our side when we build our
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a>.
The basic problem is that we’ll want to apply test vectors to the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
that assume the memory is clear (all zeros).  While the preferred solution
might be to clear all memory elements any time <code class="language-plaintext highlighter-rouge">i_reset</code> is asserted, this
isn’t how most memories are built.  That means that, when we wish to clear
this memory later, we’ll need to write as many zeros to it as are necessary
to fill it with zeros.</p>

<p>Those two parts, loading tap coefficients and incoming data, are the easy
parts of the algorithm, though.  The next step is to calculate
the indices to be used for both reading from coefficient and data memories.
Since this gets into scheduling, let’s take a moment to start scribbling
a draft pipeline schedule.</p>

<p>Usually, when I build a pipeline schedule, I start by writing out my code and
marking each line with the appropriate clock.  Doing this might result in
pseudocode looking something like the following.</p>

<p>The first clock would set the memory read indices.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Clock 1 -- i_ce and i_sample are true, tidx and didx are set</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">dwidx</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="n">tidx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">didx</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Notice how we are using the <code class="language-plaintext highlighter-rouge">i_ce</code> signal as an indication of when to reset
the indices for the data and coefficient memories, <code class="language-plaintext highlighter-rouge">didx</code> and <code class="language-plaintext highlighter-rouge">tidx</code>,
to the beginning of our run.  At the same time, we’ll write the new data
sample into memory–we discussed that above.  That’s the first clock.</p>

<p>The second clock would read from memory,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Clock 2.</span>
	<span class="n">tap</span> <span class="o">&lt;=</span> <span class="n">tapmem</span><span class="p">[</span><span class="n">tidx</span><span class="p">];</span>
	<span class="n">data</span> <span class="o">&lt;=</span> <span class="n">dmem</span><span class="p">[</span><span class="n">didx</span><span class="p">];</span></code></pre></figure>

<p>This will give us the information we need to calculate <code class="language-plaintext highlighter-rouge">h[k][x[n-k]</code>, hence
we can multiply these two values together on the third clock cycle,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Clock 3.</span>
	<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">tap</span> <span class="o">*</span> <span class="n">data</span><span class="p">;</span></code></pre></figure>

<p>Once the product is available, we’d add it to our accumulator.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Clock 4.</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_product_data</span><span class="p">)</span>
		<span class="n">acc</span> <span class="o">&lt;=</span> <span class="n">product</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">subsequent_product_data</span><span class="p">)</span>
		<span class="n">acc</span> <span class="o">&lt;=</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">product</span><span class="p">;</span></code></pre></figure>

<p>The final step would be to create our output.  This will need to take place
some time into the future–at a time we’ll need to come back to and determine
later.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Clock ... some distance into the future</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_product_data</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="n">acc</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span>
		<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Before moving on, I tried to draw this basic pipeline schedule out in Fig 5
below for reference.  You should know, though, that whenever
I build an algorithm like this I usually just start by writing
the clock numbers in my code as we just did above.  I find these diagrams,
like Fig 5 below, are most useful to me when telling someone else about one
of my designs, such as I am doing now, then they are when I write them.</p>

<table align="center" style="float: none"><caption>Fig 5. Initial draft pipeline schedule</caption><tr><td><img src="/img/slowfil/fir-slow-schedule-one.svg" alt="" width="780" /></td></tr></table>

<p>If you aren’t familiar with this sort of table, I use it to communicate
when variables are <em>valid</em> within a design.  In this case, on the clock that
any new data is present, i.e.  <a href="/blog/2017/08/14/strategies-for-pipelining.html">the clock where <code class="language-plaintext highlighter-rouge">i_ce</code> is
high</a>,
the write
index for the data memory will also be valid.  These clock numbers are off by
one from the ones above, simply because variables set on one clock (as shown
in the code above) will be valid on the next clock–as shown in Fig 5.</p>

<p>So, that’s generally what we wish to do.  To make this happen, though, let’s
add some
<a href="/blog/2017/08/14/strategies-for-pipelining.html">traveling valid flags</a>
to this pipeline.  Specifically, we are going to want to know when to reset
the accumulator with a new product, and when to add other products into the
accumulator.  We’re also going to need to know when to set <code class="language-plaintext highlighter-rouge">o_ce</code> and
<code class="language-plaintext highlighter-rouge">o_result.</code></p>

<p>The first <a href="/blog/2017/08/14/strategies-for-pipelining.html">traveling valid
flag</a>
we’ll call <code class="language-plaintext highlighter-rouge">pre_acc_ce</code>–or the pre clock
enable for the accumulator.  We’ll use a shift register for this purpose.
Hence, on the first clock we’ll set <code class="language-plaintext highlighter-rouge">pre_acc_ce[0]</code> to let us know that the
indices will be valid on the next clock.  On that next clock, we’ll set
<code class="language-plaintext highlighter-rouge">pre_acc_ce[1]</code> to indicate that the memory reads are valid.  Finally, we’ll
set <code class="language-plaintext highlighter-rouge">pre_acc_ce[2]</code> to indicate that the product is valid.  Further, we’ll
clear <code class="language-plaintext highlighter-rouge">pre_acc_ce[0]</code> as soon as the last tap has been read.  This will then
be the indicator needed to know when to stop accumulating values.</p>

<p>The only real trick in this logic chain is knowing when to shut <code class="language-plaintext highlighter-rouge">pre_acc_ce[0]</code>
off.  In particular, it needs to be shut off once we have exhausted all of the
coefficients in the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>.
We’ll come back to this in a moment, but for now
we are talking about a simple piece of scheduling logic such as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">wire</span>	<span class="n">last_tap_index</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">pre_acc_ce</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">pre_acc_ce</span> <span class="o">=</span> <span class="mh">3'h0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">pre_acc_ce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
			<span class="n">pre_acc_ce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">pre_acc_ce</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">last_tap_index</span><span class="p">))</span>
			<span class="n">pre_acc_ce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pre_acc_ce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="c1">// ...</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">pre_acc_ce</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mb">2'b0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pre_acc_ce</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pre_acc_ce</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span></code></pre></figure>

<p>Once <code class="language-plaintext highlighter-rouge">i_ce</code> is valid, the memory index will be valid on the next clock–so
we’ll set <code class="language-plaintext highlighter-rouge">pre_ce_acc[0]</code> to true.  We’ll leave it true until we get to the
last tap index.  Likewise the values will flow through this structure just
like a shift register.</p>

<p>But when shall we cut it off?  It needs to be cut off such that, when
the coefficient index, <code class="language-plaintext highlighter-rouge">tidx</code>, is referencing the last coefficient,
<code class="language-plaintext highlighter-rouge">pre_acc_ce[0]</code> will be false on the next clock.  Since our coefficient index
is counting from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">NTAPS-1</code>, this can be expressed as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">last_tap_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">NTAPS</span><span class="p">[</span><span class="n">LGNTAPS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">tidx</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>The neat thing about this piece of logic, as you’ll see as we move forward,
is that it keeps the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
from outputting an invalid answer any time
too many clocks are given between <code class="language-plaintext highlighter-rouge">i_ce</code> values.  Hence, if you have a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
with <code class="language-plaintext highlighter-rouge">NTAPS</code> coefficients, yet there are more than <code class="language-plaintext highlighter-rouge">NTAPS</code> clocks between
samples, then the accumulator will only pay attention to the first
<code class="language-plaintext highlighter-rouge">NTAPS</code> products.</p>

<p>This brings us to our next step: the block RAM read indices.  Upon any new
value, the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
starts accumulating from the product of coefficient zero
and the most recent data sample.  Coefficients then work forwards in their
array, while the data indexes work backwards–just like they did in the
<a href="https://en.wikipedia.org/wiki/Convolution">convolution</a>
formula we started with.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">didx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">tidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">dwidx</span><span class="p">;</span>
			<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">didx</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span>
			<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="n">tidx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">end</span></code></pre></figure>

<p>Indeed, this logic is essentially identical to our last draft.</p>

<p>We’ll also follow the clocks through the pipeline with a second
<a href="/blog/2017/08/14/strategies-for-pipelining.html">traveling CE</a>
approach that will use a <a href="/blog/2017/08/14/strategies-for-pipelining.html">couple of other CE
signals</a>.
The first of these, <code class="language-plaintext highlighter-rouge">m_ce</code> is memory
index valid signal,
indicating that the first indices is valid.  As you follow through the code,
you’ll see other similar CE signals, such as the <code class="language-plaintext highlighter-rouge">d_ce</code> signal to indicate
the first set of data and coefficient values are valid and <code class="language-plaintext highlighter-rouge">p_ce</code> to indicate
the first product is valid.  We’ll use these in a moment to determine when to
load the accumulator vs adding a new value to it.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// m_ce is valid when the first index is valid</span>
	<span class="k">initial</span>	<span class="n">m_ce</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">m_ce</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">);</span></code></pre></figure>

<p>On every clock cycle, we’ll read two values from block RAM–a
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
<a href="https://en.wikipedia.org/wiki/Impulse_response">coefficient value</a>
and a data value.  Note how the block RAM reading code below is explicitly
kept very simple.  This is to make certain that the tools recognize these as
reads from block RAM’s, rather than more complex logic such as one would need
to implement via a
<a href="/blog/2017/06/12/minimizing-luts.html">look-up-tables</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">tap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">tap</span> <span class="o">&lt;=</span> <span class="n">tapmem</span><span class="p">[</span><span class="n">tidx</span><span class="p">[(</span><span class="n">LGNTAPS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]];</span>

	<span class="k">initial</span>	<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">&lt;=</span> <span class="n">dmem</span><span class="p">[</span><span class="n">didx</span><span class="p">];</span></code></pre></figure>

<p>Once read, we’ll set a data CE, or <code class="language-plaintext highlighter-rouge">d_ce</code>, to indicate that the first data
value is now valid.  This will follow the first memory indices are valid
CE, <code class="language-plaintext highlighter-rouge">m_ce</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">d_ce</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">d_ce</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">m_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">);</span></code></pre></figure>

<p>After all this work, we
can now calculate the product of <code class="language-plaintext highlighter-rouge">h[k]x[n-k]</code>, herein referenced as just
<code class="language-plaintext highlighter-rouge">tap * data</code>.  Another <a href="/blog/2017/08/14/strategies-for-pipelining.html">traveling CE
value</a>,
this time <code class="language-plaintext highlighter-rouge">p_ce</code>, denotes when this first product is valid.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">p_ce</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">p_ce</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">d_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">);</span>

	<span class="k">initial</span>	<span class="n">product</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">tap</span> <span class="o">*</span> <span class="n">data</span><span class="p">;</span></code></pre></figure>

<p>Only now can we can finally get to the accumulator at the penultimate
stage of this chain.  On the first value given to it, that is
any time <code class="language-plaintext highlighter-rouge">p_ce</code> is true–which will be true with the first product value,
<code class="language-plaintext highlighter-rouge">h[0]x[n]</code>, the accumulator is set to the result of that first product.
Otherwise, any time a subsequent product is valid–as noted by
<code class="language-plaintext highlighter-rouge">pre_acc_ce[2]</code> being high, the accumulator value is increased
by that clock’s <code class="language-plaintext highlighter-rouge">h[k]x[n-k]</code> value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">r_acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p_ce</span><span class="p">)</span>
			<span class="n">r_acc</span> <span class="o">&lt;={</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="o">-</span><span class="p">(</span><span class="n">IW</span><span class="o">+</span><span class="n">TW</span><span class="p">))</span><span class="o">{</span><span class="n">product</span><span class="p">[(</span><span class="n">IW</span><span class="o">+</span><span class="n">TW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">}}</span><span class="p">,</span> <span class="n">product</span> <span class="o">}</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pre_acc_ce</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
			<span class="n">r_acc</span> <span class="o">&lt;=</span> <span class="n">r_acc</span> <span class="o">+</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="o">-</span><span class="p">(</span><span class="n">IW</span><span class="o">+</span><span class="n">TW</span><span class="p">))</span><span class="o">{</span><span class="n">product</span><span class="p">[(</span><span class="n">IW</span><span class="o">+</span><span class="n">TW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">}}</span><span class="p">,</span>
						<span class="n">product</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>This almost looks like the draft code we created to work out pipeline
scheduling.  The biggest difference is that we’ve done some sign extension
work above to make sure this works across multiple synthesis tools and
lint checkers.</p>

<p>On the same clock we place a new value into the accumulator, we can also read
the last value out.  Hence we set <code class="language-plaintext highlighter-rouge">o_result</code> to the output of the accumulator
on that same clock, and <code class="language-plaintext highlighter-rouge">o_ce</code> to indicate this result is valid.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p_ce</span><span class="p">)</span>
			<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="n">r_acc</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">o_ce</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">p_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_reset</span><span class="p">);</span>
<span class="k">endmodule</span></code></pre></figure>

<p>Note that, as a consequence of this approach, <code class="language-plaintext highlighter-rouge">o_ce</code> will always be true a
fixed number of clock ticks from <code class="language-plaintext highlighter-rouge">i_ce</code>.  Hence, if the data stops coming, the
last accumulator value will not be read out.  Likewise, if the <code class="language-plaintext highlighter-rouge">i_ce</code> values
come with fewer than <code class="language-plaintext highlighter-rouge">NTAPS</code> steps between them, then the <code class="language-plaintext highlighter-rouge">o_ce</code> values will
only report partial
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
products.  There is no error detection or correction here–but you can feel
free to add it if you would like.</p>

<p>Still, that’s what it takes to generate a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">slow</a>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
in Verilog for an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.  Sadly,
though, the code is complex enough that we are going to lean heavily on our
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a>
code to know if it works or not.</p>

<h2 id="test-bench">Test bench</h2>

<p>When it comes time to building a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a> for
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>,
we’ve really already done most of the work in the <a href="/dsp/2017/11/04/genfil-tb.html">generic filtering
test harness</a>
we built for the
<a href="/dsp/2017/09/15/fastfir.html">generic filter</a>’s
<a href="/dsp/2017/12/06/fastfir-tb.html">test bench</a>.
As a result, testing
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>
only requires making a couple of small changes.  Indeed, if you run a
<a href="https://en.wikipedia.org/wiki/Diff_utility">diff</a>
between the original
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genericfir_tb.cpp">test bench for a generic filter</a>
and the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a> for
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>,
you’ll see the changes we are about to discuss below.  You might even be
surprised at how much code is in common between the two.</p>

<p><a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">This</a>
will, however, be the first
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
that will test the fixed number of clocks
per input clock enable, <code class="language-plaintext highlighter-rouge">i_ce</code>  associated with the sample value.  As it
turns out, we did a good job
<a href="/dsp/2017/11/04/genfil-tb.html">building the initial</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp">test harness</a>,
so there’s not much that needs to be changed there.</p>

<p>Second, unlike the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/genfil_tb.cpp">prior filter</a>, resetting this one so that all the memory is
zero requires more work than just setting the reset flag.  In particular,
the way block RAM’s are built, they cannot be cleared in a single clock.
As a result, we’ll need to write a routine to explicitly write zero samples to
the filter’s internal memory so that any test vector generator can start
from a known state.</p>

<p>With those two caveats aside, let’s start looking at the code.</p>

<p>As with any code using our <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp">basic filtering test
bench</a>,
it starts out be declaring constants shared between the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp">test bench code</a>
and the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
itself.  These include the number of bits in the input, the
coefficients, the output, the number of coefficients, the delay between
input and the first output resulting from that input, and the number of
clocks per input sample.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">const</span>	<span class="kt">unsigned</span> <span class="n">IW</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="n">TW</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="n">OW</span> <span class="o">=</span> <span class="n">IW</span><span class="o">+</span><span class="n">TW</span><span class="o">+</span><span class="mi">7</span><span class="p">,</span>
		<span class="n">NTAPS</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
		<span class="n">DELAY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
		<span class="n">CKPCE</span> <span class="o">=</span> <span class="n">NTAPS</span><span class="p">;</span></code></pre></figure>

<p>These values are not only declared as constants at the beginning of the
test bench, but they are also used to when initializing our test bench
class.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">SLOWFIL_TB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FILTERTB</span><span class="o">&lt;</span><span class="n">Vslowfil</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">bool</span>		<span class="n">m_done</span><span class="p">;</span>

	<span class="n">SLOWFIL_TB</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IW</span><span class="p">(</span><span class="o">::</span><span class="n">IW</span><span class="p">);</span>
		<span class="n">TW</span><span class="p">(</span><span class="o">::</span><span class="n">TW</span><span class="p">);</span>
		<span class="n">OW</span><span class="p">(</span><span class="o">::</span><span class="n">OW</span><span class="p">);</span>
		<span class="n">NTAPS</span><span class="p">(</span><span class="o">::</span><span class="n">NTAPS</span><span class="p">);</span>
		<span class="n">DELAY</span><span class="p">(</span><span class="o">::</span><span class="n">DELAY</span><span class="p">);</span>
		<span class="n">CKPCE</span><span class="p">(</span><span class="o">::</span><span class="n">CKPCE</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<p>This is just normal setup though.  Now we need to get into the actual
details of the test bench changes.</p>

<p>The first change that needs to be made is to the <code class="language-plaintext highlighter-rouge">test()</code> routine.  This
routine, as you <a href="/dsp/2017/11/04/genfil-tb.html">may
remember</a>,
takes an input data stream, applies the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>,
and returns the result.  It also depends upon the filter having a zero
internal state.  Since clearing the state in this
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp">test bench</a>
is a little more awkward, we’ll make certain to call a function to make
certain the state is cleared before calling the <code class="language-plaintext highlighter-rouge">test()</code> function in the
<a href="/dsp/2017/11/04/genfil-tb.html">test harness</a>
itself.  The neat part of this change, though, is that by
<a href="https://en.wikipedia.org/wiki/Method_overriding">overloading</a>,
this <code class="language-plaintext highlighter-rouge">test()</code> operator and using
<a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">inheritance</a>,
this change only requires the following four lines of code.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">nlen</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_filter</span><span class="p">();</span>
		<span class="n">FILTERTB</span><span class="o">&lt;</span><span class="n">Vslowfil</span><span class="o">&gt;::</span><span class="n">test</span><span class="p">(</span><span class="n">nlen</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<p>Unlike the
<a href="/dsp/2017/12/06/fastfir-tb.html">other filters</a>
we’ve tested, this one requires a reset prior to loading any
new <a href="https://en.wikipedia.org/wiki/Impulse_response">coefficients</a>.  As
you may recall from above, resetting
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>
sets the index into the coefficient memory back to zero, so it is an
important part of loading a new set of
<a href="https://en.wikipedia.org/wiki/Impulse_response">coefficients</a>.  Just a
slight modification to the
<a href="/dsp/2017/11/04/genfil-tb.html">test bench</a>,
and this change has now been made as well.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">load</span><span class="p">(</span><span class="kt">int</span> <span class="n">nlen</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reset</span><span class="p">();</span>
		<span class="n">FILTERTB</span><span class="o">&lt;</span><span class="n">Vslowfil</span><span class="o">&gt;::</span><span class="n">load</span><span class="p">(</span><span class="n">nlen</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<p>Perhaps the most important change, though, is the function that we need to
write to clear the data memory within
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>.
We’ll call this function <code class="language-plaintext highlighter-rouge">clear_filter()</code>.  It will work by
providing one clock with <code class="language-plaintext highlighter-rouge">i_ce</code> high and <code class="language-plaintext highlighter-rouge">i_sample</code> set to zero per element
in the memory array.  Since the array will always be a length given by a power
of two, the internal memory may also be longer than the number of
taps, <code class="language-plaintext highlighter-rouge">NTAPS()</code> in
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>.
For this reason, we’ll round up to the next power of two using <code class="language-plaintext highlighter-rouge">nextlg()</code>.</p>

<p>What may surprise you, though, is that we are going to hit
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>
with one new sample per clock, while ignoring the output.  The result of this
will be that the output of this run will be invalid, although the new data will
loaded into he memory as desired.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="kt">void</span>	<span class="nf">clear_filter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_tap_wr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="c1">// ..</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_ce</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_sample</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nextlg</span><span class="p">(</span><span class="n">NTAPS</span><span class="p">());</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>As one final step, once the memory has been loaded, we’ll let the last sample
propagate through
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">the filter</a>,
so as to make certain
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">the filter</a>
is in a usable state when we apply our test vectors.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_ce</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">CKPCE</span><span class="p">();</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="n">tick</span><span class="p">();</span>
	<span class="err">}</span>
<span class="err">}</span><span class="p">;</span></code></pre></figure>

<p>At this point, all we need to do is switch our main program to running the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a>
created for this new code, and everything is roughly the same as before.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">SLOWFIL_TB</span>	<span class="o">*</span><span class="n">tb</span><span class="p">;</span>

<span class="kt">int</span>	<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Verilated</span><span class="o">::</span><span class="n">commandArgs</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="n">tb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SLOWFIL_TB</span><span class="p">();</span></code></pre></figure>

<p>How’s that for fairly simple?  Indeed, implementing the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter itself</a>
was harder than this
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a>.</p>

<p>Of course, it’s only that simple because of the work we’ve already done,
but that just underscores the power of
<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">Object Oriented Programming (OOP)</a>.</p>

<h2 id="example-traces">Example Traces</h2>

<p>If you’d like to see a trace of how this all works, there’s a commented line
in the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a>,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">// tb-&gt;opentrace("trace.vcd");</span></code></pre></figure>

<p>which, if uncommented, will create a
<a href="/blog/2017/07/31/vcd.html">VCD file</a>
containing a trace of what
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>
does in response to the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a>’s
stimulus.  Be careful–the trace can quickly
become hundreds of megabytes, if not several gigabytes, in length.</p>

<p>Still, let’s turn that on to see if we can get a feel for how
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>
works.  We’ll stop the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a>
after the
<a href="/blog/2017/07/31/vcd.html">trace file</a>
gets to about 28MB–which is still more than we need for this demo.  We
can then use
<a href="https://gtkwave.sourceforge.net">GTKwave</a>
to display the results.  You can see a screen capture of the result
in Fig 6 below.</p>

<table align="center" style="float: none"><caption>Fig 6. Trace of the First Impulse Test</caption><tr><td><img src="/img/slowfil/fir-slowfil-trace.png" alt="" width="780" /></td></tr></table>

<p>The figure shows several key steps in the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a>.</p>

<ol>
  <li>
    <p>First, at the far left, <code class="language-plaintext highlighter-rouge">i_tap_wr</code> is high for many clocks as the
coefficients (<code class="language-plaintext highlighter-rouge">i_tap</code>) are loaded into the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>.</p>
  </li>
  <li>
    <p>The <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
is then <em>cleared</em> by writing a series of (roughly) <code class="language-plaintext highlighter-rouge">NTAPS()</code>
zeros into the memory.</p>
  </li>
  <li>
    <p>The <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/slowfil_tb.cpp">test bench</a>
then applies an
<a href="https://en.wikipedia.org/wiki/Kronecker_delta">impulse</a> to the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>,
to verify the <a href="https://en.wikipedia.org/wiki/Impulse_response">response</a>.
Both <a href="https://en.wikipedia.org/wiki/Kronecker_delta">impulse</a>
and coefficient value are negative maximums, to see if the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>
will overflow as a result.  What that means, though, is that the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">filter</a>’s
output given these coefficients and this input will be a
single positive
<a href="https://en.wikipedia.org/wiki/Kronecker_delta">impulse</a>,
as shown in the figure above.</p>
  </li>
</ol>

<p>Suppose we zoomed in some more on how
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>
operated?  In this case, see Fig 7 below.</p>

<table align="center" style="float: none"><caption>Fig 7. Zooming in on the first test vector</caption><tr><td><img src="/img/slowfil/fir-slowfil-trace-zoom.png" alt="" width="780" /></td></tr></table>

<p>At this zoom level, you can see how the various <code class="language-plaintext highlighter-rouge">CE</code>s (really misnamed
valid signals) make their way through the system until the final <code class="language-plaintext highlighter-rouge">o_ce</code> and
<code class="language-plaintext highlighter-rouge">o_result</code> are valid.  You can also see the <code class="language-plaintext highlighter-rouge">pre_acc_ce[2:0]</code> shift register
note when the tap index and data index became valid, <code class="language-plaintext highlighter-rouge">m_ce</code>, when the memory
reads were valid, <code class="language-plaintext highlighter-rouge">d_ce</code>, and when the products became valid, <code class="language-plaintext highlighter-rouge">p_ce</code>.</p>

<p>The point here is, even if you are struggling to understand the code itself
above, sometimes a trace becomes easier to make sense of.</p>

<h2 id="conclusions">Conclusions</h2>

<p>This filtering approach is really quite powerful.  Not only were we able
to reduce the number of multiplies required in order to implement
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>,
but we were also able to prove it using little more than the <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/filtertb.cpp">test harness
code</a>
we’ve already built.</p>

<p>Remember the discussion we started out with regarding a 2047 tap
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>?
Such a <a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
would be sufficient to generate a
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
with a 480Hz
<a href="https://en.wikipedia.org/wiki/Passband">passband</a>,
a 176Hz transition band, and a 70dB stop band.  That’s probably
good enough for any audio work you might wish to do.</p>

<p>That doesn’t mean
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this</a>
is the best (or worst)
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
out there, just one to place into your tool box.  It has a purpose, and it
works well in its own niche.</p>

<p>What other approaches might we have tried?</p>

<p>I’ve mentioned for some time that I’d like to build and demonstrate a
<a href="https://en.wikipedia.org/wiki/Linear_phase">symmetrical filter</a>.
At high speed, that filter is now built and just waiting
for a good blog post.  Similarly, a fun challenge might be to modify
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>
to handle
<a href="https://en.wikipedia.org/wiki/Linear_phase">symmetric coefficients</a>,
something that would allow it to run twice as many coefficients at once.</p>

<p>Another future
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
that will be fun to present is what I’m going to call
a cascaded
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.
By cascaded
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>, I mean one that
is basically identical to
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/slowfil.v">this filter</a>,
except that it allows multiple
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>s
of this type to be cascaded together in order to effectively create a <em>much</em>
longer <a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.
In many ways, this may seem like the holy grail of generic
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
implementation–a
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
that can be adjusted to use only as many hardware multiplies
as it is required to use given the incoming data rate.</p>

<p>Perhaps the ultimate
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>,
however, is the multirate implementation of a
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.
Using multirate techniques, it should be possible to apply a
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a> of
any bandwidth to full speed data for a cost of only 10-12 multiplies.</p>

<p>But these are all topics for another day.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Then took Mary a pound of ointment of spikenard, very costly, and anointed the feet of Jesus, and wiped his feet with her hair: and the house was filled with the odour of the ointment. (John 12:3)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
