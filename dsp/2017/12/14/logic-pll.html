<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a Simple Logic PLL</title>
  <meta name="description" content="There’s one signal processing component that has always felt like a blackart to me, and that is a Phase Locked Loop orPLL.If you aren’t familiar withPLLs, aP...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2017/12/14/logic-pll.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building a Simple Logic PLL</h1>
    <p class="post-meta"><time datetime="2017-12-14T00:00:00-05:00" itemprop="datePublished">Dec 14, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>There’s one signal processing component that has always felt like a black
art to me, and that is a <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">Phase Locked Loop or
PLL</a>.
If you aren’t familiar with
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s, a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> is a
<a href="https://en.wikipedia.org/wiki/Feedback">closed loop</a>
<a href="https://en.wikipedia.org/wiki/Control_system">control system</a>
designed to match an incoming
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a> with a reconstructed
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a> that tracks both the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> and (optionally) the
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
of an incoming
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>.</p>

<p><a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s are important parts
of many
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">Digital Signal Processing
(DSP)</a>
systems, including (but not limited to):</p>

<ul>
  <li>
    <p>Recovering the implicit (or explicit) clock from an incoming signal.
Inside digital logic, clock recovery
becomes very important when you are trying to transfer data between two
components.  Even components that have two independent clocks, each supposedly
tuned to “the same” clock
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>,
will likely have their clocks wander in
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
with respect to each other.</p>

    <p>You may be familiar
with the hard <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
components on your board which are used to do this exact thing.</p>
  </li>
  <li>
    <p>New clock signal generation.  For example, a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> can often be used
to create a clock <code class="language-plaintext highlighter-rouge">N</code> times faster or slower than an incoming reference
clock.</p>
  </li>
  <li>
    <p>In a commercial <a href="https://en.wikipedia.org/wiki/FM_broadcasting">broadcast FM
signal</a>,
a <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> is often used
to undo the <a href="https://en.wikipedia.org/wiki/Frequency_modulation">FM
modulation</a>.  This may
also include a separate
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> component used to
lock onto the stereo component of the signal–and even to determine if
it is present.</p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Amplitude_modulation">AM demodulation</a></p>
  </li>
  <li>
    <p>Of course, my favorite use for a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
is to lock onto the <a href="https://en.wikipedia.org/wiki/Baud">baud rate</a>
and <a href="https://en.wikipedia.org/wiki/Carrier_recovery">carrier phase</a>
of a <a href="https://en.wikipedia.org/wiki/Data_transmission">digital communications
waveform</a>.
The <a href="https://en.wikipedia.org/wiki/Baud">baud</a>
clock recovery portion of this circuit in the receiver is used to determine
the sampling point (the middle) of any received bits.</p>
  </li>
</ul>

<p>My own first experience with
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s came as part of
an “Everything you need to know about
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">DSP</a>”
type of course offered at my workplace.  In this course, the instructor
presented two very simple
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> structures that have
served me well ever since.</p>

<p>If <a href="https://www.blueletterbible.org/kjv/jas/4/15">the Lord permits</a>, I
may have the opportunity to share some of these same fundamental
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> structures here
with you here on <a href="https://zipcpu.com/">this blog</a>.  I’ll try
to keep them as simple as I can.  For example, the
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
I’ll present below has only about 84 lines of logic to its implementation.
Sound simple enough?</p>

<p>Since that first class, though, I decided that I didn’t know enough about this
black art, and that I wanted to learn more about
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s.  After a bit of
browsing on <a href="https://www.amazon.com">Amazon</a>, I came across
<a href="https://www.amazon.com/Phaselock-Techniques-Floyd-M-Gardner/dp/0471430633/">Floyd M. Gardner’s book, <em>Phaselock Techniques</em></a>.
One particular comment in his introductory chapter caught my eye, and I’d
like to repeat it for you here:</p>

<blockquote>
  <p>Every <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> is
<a href="https://en.wikipedia.org/wiki/Nonlinear_system">nonlinear</a>.
Tools for analysis of
<a href="https://en.wikipedia.org/wiki/Nonlinear_system">nonlinear system</a>s are
exceedingly cumbersome and provide meager benefits compared to the powerful
analytical tools available for
<a href="https://en.wikipedia.org/wiki/Linear_system">linear system</a>s.  Fortunately,
most (but not all) <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s
of interest can be analyzed by
<a href="https://en.wikipedia.org/wiki/Linear_system">linear</a> techniques
when in their locked condition.  This book argues throughout that
<a href="https://en.wikipedia.org/wiki/Linear_system">linear</a> methods are
sufficient for the bulk of the analysis and initial design of most
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s.
Therefore, linear approximations are employed wherever feasible.</p>
</blockquote>

<p>I was instantly sold!  I’ve not regretted this purchase since then, for Mr.
Gardner was true to his word and I have learned much from <a href="https://www.amazon.com/Phaselock-Techniques-Floyd-M-Gardner/dp/0471430633/">his
book</a>.
That said, I’ve never taken any academic classes studying
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> design or analysis,
so I can’t really comment on whether or not other books are better or worse
than <a href="https://www.amazon.com/Phaselock-Techniques-Floyd-M-Gardner/dp/0471430633/">Gardner’s</a>.</p>

<p>So today let’s talk about how to build a really simple
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>.  I’m going to call
this a <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">logic PLL</a>
for the simple reason that it will take as an input a logical
(<a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean</a>)
clock signal (<code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">1</code>).  Internally, the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">logic PLL</a>
will use only simple <a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean</a>
logic–there will be no <code class="language-plaintext highlighter-rouge">N</code>-bit samples or even
any <a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>
<a href="https://github.com/ZipCPU/cordic">generation</a>
within the logic below.  Indeed, you might need to look carefully if you want
to find the multiplies.</p>

<h2 id="components-of-a-pll">Components of a PLL</h2>

<p>The basic form of a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
is that of a <a href="https://en.wikipedia.org/wiki/Feedback">control loop</a>.  The
input to this loop is a
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>.</p>

<table align="center" style="float: none"><caption>Fig 1. PLL feedback</caption><tr><td><img src="/img/dpll-block-diagram.svg" alt="Components of a PLL" width="780" /></td></tr></table>

<p>Outputs can be taken from any number of locations, depending upon the purpose
of the <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>.</p>

<p>The loop begins with an incoming <a href="https://en.wikipedia.org/wiki/Sine_wave">sine
wave</a> that is passed into a
<a href="https://en.wikipedia.org/wiki/Phase_detector">phase detector</a>.
The <a href="https://en.wikipedia.org/wiki/Phase_detector">phase detector</a>
is used to compare the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
of the incoming <a href="https://en.wikipedia.org/wiki/Sine_wave">sine
wave</a> against a reconstructed
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>
produced internally.  The output of this
<a href="https://en.wikipedia.org/wiki/Phase_detector">phase detector</a>
is an error signal.  This error signal is then optionally filtered, and fed
into two portions of the circuit: one to track
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
and the other to track
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>.
These two portions combine within a
<a href="/dsp/2017/12/09/nco.html">Numerically Controlled Oscillator (NCO)</a>
to create a new
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> for the reconstructed
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>.
That <a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> is then used
as an input to a <a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>
<a href="https://github.com/ZipCPU/cordic">generator</a> to create a reconstructed
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>, which is then used as the
second input to the
<a href="https://en.wikipedia.org/wiki/Phase_detector">phase detector</a>
and the loop repeats.</p>

<p>The <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">PLL presented
below</a>
will contain all of these basic components, with the exception that
the incoming <a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a> will be
represented by a 1-bit clock signal, and the reconstructed
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a> will have only a
1-bit amplitude.  Put together, these two changes will allow us to keep the
<a href="/blog/2017/06/12/minimizing-luts.html">logic count</a>
of this “logic <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>”
quite low.  Since low
<a href="/blog/2017/06/12/minimizing-luts.html">logic count</a>
often correlates with high
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
speed, these two changes should allow this
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
to run at a high internal speed within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<h2 id="a-basic-pll-interface">A Basic PLL interface</h2>

<table align="center" style="float: right"><caption>Fig 2. PLL interface</caption><tr><td><img src="/img/pll-block-component.svg" alt="Components of a PLL" width="360" /></td></tr></table>

<p>A typical <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
component might have a component I/O diagram like the one in Fig 2 to the right.
Indeed, today’s <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">logic
PLL</a>
will implement most of this interface–with the exception of the lock indicator
output.</p>

<p>The basic signals are:</p>

<ul>
  <li>
    <p>An incoming clock signal, <code class="language-plaintext highlighter-rouge">i_clk</code>.  While not shown in Fig 2, today’s logic
is going to be
<a href="https://en.wikipedia.org/wiki/Synchronous_circuit">synchronous</a>,
and hence everything will take place on clock edges.</p>
  </li>
  <li>
    <p>A means of setting the
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
of the internal <a href="/dsp/2017/12/09/nco.html">NCO</a>
component.  In this case, any time the <em>load new frequency</em> flag is true,
we’ll call this <code class="language-plaintext highlighter-rouge">i_ld</code> below, the internal
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
increment of the
<a href="/dsp/2017/12/09/nco.html">NCO</a>
will be forced to the <em>frequency control</em> value, <code class="language-plaintext highlighter-rouge">i_step</code>.  While <code class="language-plaintext highlighter-rouge">i_ld</code> is
high, the <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">logic PLL</a>
will not track any <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
changes.</p>
  </li>
  <li>
    <p>The bandwidth of this control loop will be set via the <em>loop bandwidth
control</em> input, <code class="language-plaintext highlighter-rouge">i_lgcoeff</code> which I may reference as <code class="language-plaintext highlighter-rouge">LGCOEFF</code> below, so that
the internal loop gain is set to <code class="language-plaintext highlighter-rouge">2^(-LGCOEFF)</code>.  This will control how
fast the loop locks on to an incoming clock signal.</p>
  </li>
  <li>
    <p>This leaves the incoming
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>,
<code class="language-plaintext highlighter-rouge">i_input</code>.  We’ll assume this is either on
or off, much like any logical clock signal.  We’ll also use the <a href="/blog/2017/08/14/strategies-for-pipelining.html">“global CE”
strategy</a>,
captured by the clock enable (CE) line, referenced below as <code class="language-plaintext highlighter-rouge">i_ce</code>.  Under
this
<a href="/blog/2017/08/14/strategies-for-pipelining.html">strategy</a>,
both <code class="language-plaintext highlighter-rouge">i_input</code> and the outputs <code class="language-plaintext highlighter-rouge">o_phase</code> and <code class="language-plaintext highlighter-rouge">o_err</code> will need to be valid
any time <code class="language-plaintext highlighter-rouge">i_ce</code> is true, and should only change at that time.</p>

    <p>From a timing standpoint, we’ll want to be able to handle the case where
<code class="language-plaintext highlighter-rouge">i_ce</code> is held at one, so as to make this a high speed
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
implementation.</p>
  </li>
</ul>

<p>There are two basic outputs of
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this PLL</a>:</p>

<ul>
  <li>
    <p>The error signal coming out of the
<a href="https://en.wikipedia.org/wiki/Phase_detector">phase detector</a>.</p>

    <p>Changes in this
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error signal, since they will be proportional to
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>, are often used within an
<a href="https://en.wikipedia.org/wiki/FM_broadcasting">FM</a> demodulator.</p>

    <p>You could also use this error signal to create a locked indication if you
wanted.</p>
  </li>
  <li>
    <p>We’ll also produce the basic
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
of the internal oscillator, <code class="language-plaintext highlighter-rouge">o_phase</code>.
This signal is the same as the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
counter we used in our
<a href="/dsp/2017/12/09/nco.html">NCO</a> discussion.</p>

    <p>Because this
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
tracks the incoming signal, it can also be used as an indication of when
to sample an incoming data bit.</p>

    <p>Further, since we’ll be matching the most-significant bit of this
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
value to the incoming clock signal, this also creates a stable clock output.</p>
  </li>
</ul>

<p>Put together, you can see the prototype for our
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">logic PLL</a>
written out in Verilog below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">sdpll</span><span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="n">i_ld</span><span class="p">,</span> <span class="n">i_step</span><span class="p">,</span> <span class="n">i_ce</span><span class="p">,</span> <span class="n">i_input</span><span class="p">,</span> <span class="n">i_lgcoeff</span><span class="p">,</span> <span class="n">o_phase</span><span class="p">,</span> <span class="n">o_err</span><span class="p">);</span>
	<span class="k">parameter</span>		<span class="n">PHASE_BITS</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="k">parameter</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_TRACK_FREQUENCY</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">localparam</span>		<span class="n">MSB</span><span class="o">=</span><span class="n">PHASE_BITS</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="n">i_clk</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_ld</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[(</span><span class="n">MSB</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_step</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_ce</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_input</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_lgcoeff</span><span class="p">;</span>
	<span class="kt">output</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="n">PHASE_BITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">o_phase</span><span class="p">;</span>
	<span class="kt">output</span>	<span class="kt">reg</span>	<span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">o_err</span><span class="p">;</span>
	<span class="c1">//</span></code></pre></figure>

<p>One item to note is that
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this PLL</a> design can
be set to optionally track
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>, as well as
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>,
by just setting the <code class="language-plaintext highlighter-rouge">OPT_TRACK_FREQUENCY</code> flag above.</p>

<p>As discussed above, the goal of
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this PLL</a>
is to track the incoming signal, <code class="language-plaintext highlighter-rouge">i_input</code>, and to produce a reconstructed clock
signal.  This reconstructed clock signal will be captured by the most
significant bit of the output, <code class="language-plaintext highlighter-rouge">o_phase</code>.</p>

<p>Further, while we are not creating a <em>lock</em> signal today, we could easily
create one later by using the <code class="language-plaintext highlighter-rouge">o_err</code> signal if we wanted to.  Indeed, such
a <em>lock</em> signal isn’t really all that hard to create: just pass the
<code class="language-plaintext highlighter-rouge">(o_err == 2'b00)</code> signal into a <a href="/dsp/2017/08/19/simple-filter.html">recursive
average</a>.
Once the output of such a <a href="/dsp/2017/08/19/simple-filter.html">recursive
average</a>
falls below a threshold, the loop may be assumed to be <em>locked</em>.</p>

<p>These, though, are the basic components of any
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>, and specifically the
components we will implement as part of <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">our
module</a> today.</p>

<h2 id="the-logic-based-nco">The Logic Based NCO</h2>

<p>We discussed <a href="/dsp/2017/12/09/nco.html">how to build an
NCO</a> in an
<a href="/dsp/2017/12/09/nco.html">earlier article</a>.
Today, we are going to use nearly the same logic to create a clock signal,
and we’ll then approximate the
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>
generator with the most significant bit of the
<a href="/dsp/2017/12/09/nco.html">NCO</a>’s
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
accumulator.</p>

<p>This is also the same logic used by the <em>fractional counter</em> timing approach
<a href="/blog/2017/06/02/generating-timing.html">we discussed
earlier</a>.
As you may recall from
<a href="/blog/2017/06/02/generating-timing.html">that discussion</a>,
a clock of an arbitrary
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
may be generated by just examining the most significant bit of a counter.</p>

<p>That means we’ll be starting with logic that looks like the following.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
			<span class="n">ctr</span> <span class="o">&lt;=</span> <span class="n">ctr</span> <span class="o">+</span> <span class="n">r_step</span><span class="p">;</span></code></pre></figure>

<p>In this case, the <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a> of the
clock generated by this counter will be given by the product of the counter’s
<a href="/dsp/2017/12/09/nco.html">phase step</a> (divided by
<code class="language-plaintext highlighter-rouge">2^(PHASE_BITS)</code>) times the overall clock rate.</p>

<table align="center" style="float: none"><tr><td><img src="/img/dpll-frequency-step.png" alt="f = r_step * f_clk / 2^(PHASE_BITS)" width="228" /></td></tr></table>

<p>Feel free to reference the
<a href="/dsp/2017/12/09/nco.html">NCO</a> article if any of this
doesn’t look familiar to you here.</p>

<p>Setting the <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a> of this
<a href="/dsp/2017/12/09/nco.html">phase accumulator</a>
(really a <em><a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
step</em>) is as simple as setting the <code class="language-plaintext highlighter-rouge">r_step</code> value any time the user
wishes to adjust the <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
of the basic <a href="/dsp/2017/12/09/nco.html">NCO</a>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_ld</span><span class="p">)</span>
			<span class="n">r_step</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">i_step</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>This is just our starting point, however, as both of these blocks will need
some adjustment if we wish to track the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> and (optionally) the
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
of an incoming <a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>.</p>

<p>As we work through the logic of
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this</a>
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>,
you’ll find this
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
<a href="/dsp/2017/12/09/nco.html">accumulator</a> value,
<code class="language-plaintext highlighter-rouge">ctr</code>, comes back again and again.</p>

<h2 id="a-logic-phase-detector">A Logic Phase Detector</h2>

<p>The goal of the
<a href="https://en.wikipedia.org/wiki/Phase_detector">phase detector</a>
is to create a signal that is proportional to how far the
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
needs to be made faster or slowed down.  Traditionally, a
<a href="https://en.wikipedia.org/wiki/Phase_detector">phase detector</a>
is created by taking a product of the input
<a href="https://en.wikipedia.org/wiki/Sine_wave">(co)sine wave</a>
with a reconstructed
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>
separated by ninety degrees.  The resulting
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error signal is then proportional to how far the
<a href="/dsp/2017/12/09/nco.html">phase accumulator</a>
is from the incoming signal.</p>

<p>This is not going to be our chosen approach today.  Instead, we’ll use an
<em>ad-hoc</em> approach–one that generates a two-bit
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error signal indicating not
only the presence of an error but also the direction the internal counter
needs to be adjusted.  This will not be proportional, since we are only going to
capture a two bit
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error signal, but rather somewhat
nonlinear–perfect, though, for
a <a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean</a>
logic implementation.</p>

<table align="center" style="float: left"><caption>Fig 3. The regenerated clock leads the input</caption><tr><td><img src="/img/dpll-lead.svg" alt="The regenerated clock leads the incoming clock" width="360" /></td></tr></table>

<p>Let’s consider how this
<a href="https://en.wikipedia.org/wiki/Phase_detector">phase detector</a>
needs to work.  If the regenerated
clock changes before the incoming clock, as shown in Fig 3, then we’ll say
that this regenerated clock <em>leads</em> the input.  Such a <em>leading</em> situation
will create a negative
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> error,
indicating that we will want to slow down
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">our PLL</a>.
Further, any time the two signals, both the incoming clock and the
regenerated one, are identical we’ll design our
<a href="https://en.wikipedia.org/wiki/Phase_detector">phase detector</a>
to indicate zero
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> error.</p>

<table align="center" style="float: right"><caption>Fig 4. The regenerated clock lags (doesn't lead) the input</caption><tr><td><img src="/img/dpll-lag.svg" alt="The regenerated clock lags behind the incoming clock" width="360" /></td></tr></table>

<p>On the other hand, if the regenerated clock changes <em>after</em> the incoming clock,
such as is shown in Fig 4, then our reconstructed clock isn’t transitioning
fast enough.  We’ll say in this case that the regenerated clock <em>lags</em> the
input.  To correct this, we’ll want to speed up our internal clock to “catch
up” to the incoming clock, hence we want to create a <em>positive</em>
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> error in this case.
As before, though, any time the two signals agree we’ll want to keep the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> error at zero.</p>

<p>But how shall we tell whether we are leading or lagging?</p>

<p>We’ll start by keeping track of the input sign from the last time the input
and reconstructed signal agree.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">agreed_output</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i_input</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="n">MSB</span><span class="p">]))</span>
			<span class="n">agreed_output</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">i_input</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">ctr</span><span class="p">[</span><span class="n">MSB</span><span class="p">]))</span>
			<span class="n">agreed_output</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Whether or not we are <em>leading</em> the incoming clock, can then be determined
with respsct to this last agreed upon output.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">agreed_output</span><span class="p">)</span>
			<span class="c1">// We were last high.  Lead is true now</span>
			<span class="c1">// if the counter goes low before the input</span>
			<span class="n">lead</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">ctr</span><span class="p">[</span><span class="n">MSB</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_input</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="c1">// The last time we agreed, both the counter</span>
			<span class="c1">// and the input were low.   This will be</span>
			<span class="c1">// true if the counter goes high before the input</span>
			<span class="n">lead</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="n">MSB</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_input</span><span class="p">);</span></code></pre></figure>

<p>Since the above logic didn’t capture whether or not the current regenerated
bit, <code class="language-plaintext highlighter-rouge">ctr[MSB]</code> matched the <code class="language-plaintext highlighter-rouge">i_input</code>, we’ll capture that in an internal
<code class="language-plaintext highlighter-rouge">phase_err</code> exists signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Any disagreement between the high order counter bit and the input</span>
	<span class="c1">// is a phase error that we will need to correct</span>
	<span class="k">assign</span>	<span class="n">phase_err</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctr</span><span class="p">[</span><span class="n">MSB</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i_input</span><span class="p">);</span></code></pre></figure>

<p>We can put these two values together, <code class="language-plaintext highlighter-rouge">phase_err</code> and <code class="language-plaintext highlighter-rouge">lead</code>, to create a
2-bit output error value, representing either <code class="language-plaintext highlighter-rouge">-1</code>, <code class="language-plaintext highlighter-rouge">0</code>, or <code class="language-plaintext highlighter-rouge">1</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_err</span> <span class="o">=</span> <span class="mh">2'h0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">o_err</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">phase_err</span><span class="p">)</span> <span class="o">?</span> <span class="mb">2'b00</span> <span class="o">:</span> <span class="p">((</span><span class="n">lead</span><span class="p">)</span> <span class="o">?</span> <span class="mb">2'b11</span> <span class="o">:</span> <span class="mb">2'b01</span><span class="p">);</span></code></pre></figure>

<p>We won’t actually use this value internally, but rather the <code class="language-plaintext highlighter-rouge">phase_err</code> and
<code class="language-plaintext highlighter-rouge">lead</code> signals.  However, the <code class="language-plaintext highlighter-rouge">o_err</code> signal should make it easier to understand
the <code class="language-plaintext highlighter-rouge">phase_err</code> and <code class="language-plaintext highlighter-rouge">lead</code> signals.</p>

<h2 id="a-logic-pll-type-1">A Logic PLL: Type 1</h2>

<p>A “Type 1”
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
is one that tracks <a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>,
but not <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>.  This portion of a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
accepts as an input the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error, (optionally) <a href="https://en.wikipedia.org/wiki/Digital_filter">filters</a>
it, and then corrects the internal
<a href="/dsp/2017/12/09/nco.html">phase accumulator</a>,
<code class="language-plaintext highlighter-rouge">ctr</code>, based upon the result.  In general, this involves applying some sort
of linear operator to the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error signal, and then adding the result of that operator to the
<a href="/dsp/2017/12/09/nco.html">phase accumulator</a>.</p>

<table align="center" style="float: none"><caption>Fig 5. The type-1 open loop transform</caption><tr><td><img src="/img/pll-type-1-open-loop.svg" alt="The open loop transform function of a type-1 system" width="780" /></td></tr></table>

<p>Today’s
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">logic PLL</a>
is no different.  In this case, though, we’ll skip the optional
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass filter</a>
and just multiply our incoming
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error by a constant before adding it to our
<a href="/dsp/2017/12/09/nco.html">phase accumulator</a>.
Even better, because the incoming error was either -1, 0, or 1, no real
multiplication is required–we can use a nested <code class="language-plaintext highlighter-rouge">if</code> instead.</p>

<p>As for the constant, what constant shall we use?  As we suggested above, we’ll
use the absolutely simplest constant we can pick: <code class="language-plaintext highlighter-rouge">2^(-LGCOEFF)</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">phase_correction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">phase_correction</span> <span class="o">&lt;=</span> <span class="o">{</span><span class="mb">1'b1</span><span class="p">,</span><span class="o">{</span><span class="p">(</span><span class="n">MSB</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}}</span> <span class="o">&gt;&gt;</span> <span class="n">i_lgcoeff</span><span class="p">;</span></code></pre></figure>

<p>We’ll show some charts later on illustrating how this coefficient changes
things.  In general, the larger <code class="language-plaintext highlighter-rouge">2^(-LGCOEFF)</code> is,
the faster the loop will track any changes.  At the same time, larger values of
<code class="language-plaintext highlighter-rouge">2^(-LGCOEFF)</code> will also cause the
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
to pass any jitters in the incoming clock directly into the reconstructed
signal.</p>

<p>Now with this information, we can adjust our
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
value, <code class="language-plaintext highlighter-rouge">ctr</code>, using what we now know.</p>

<p>First, if there is no
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error, then all we need to do is to continue to step our
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
forward at the <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a> rate
<a href="/dsp/2017/12/09/nco.html">set by <code class="language-plaintext highlighter-rouge">r_step</code></a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="c1">// ...</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phase_err</span><span class="p">)</span>
				<span class="n">ctr</span> <span class="o">&lt;=</span> <span class="n">ctr</span> <span class="o">+</span> <span class="n">r_step</span><span class="p">;</span></code></pre></figure>

<p>Otherwise, if <code class="language-plaintext highlighter-rouge">phase_err != 0</code>, then the incoming and regenerated clocks didn’t
match.  In this case we’ll need to bump our counter a little more forward than
just a normal
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
step, or slow it down by a little less than the normal
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
step.  The difference between these two is going to be
based upon whether or not the <code class="language-plaintext highlighter-rouge">lead</code> flag is true–as we discussed above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lead</span><span class="p">)</span>
				<span class="n">ctr</span> <span class="o">&lt;=</span> <span class="n">ctr</span> <span class="o">+</span> <span class="n">r_step</span> <span class="o">-</span> <span class="n">phase_correction</span><span class="p">;</span>
			<span class="c1">// ...</span>
			<span class="k">else</span>
				<span class="n">ctr</span> <span class="o">&lt;=</span> <span class="n">ctr</span> <span class="o">+</span> <span class="n">r_step</span> <span class="o">+</span> <span class="n">phase_correction</span><span class="p">;</span>
		<span class="k">end</span></code></pre></figure>

<p>As a final step, we’ll place this counter on the output for examination
and/or re-use as desired.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_phase</span> <span class="o">=</span> <span class="n">ctr</span><span class="p">;</span></code></pre></figure>

<p>That’s all there is to the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
correction step!  There’s no more black magic to it than the logic above.
Indeed, if you wanted to we could stop here and have a fully functional
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>.
If the <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
step, <code class="language-plaintext highlighter-rouge">r_step</code>,
of that <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
was close enough to the right value, then nothing more would need to be
done–this <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> would track
the <a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
an incoming 1-bit clock signal.</p>

<p>On the other hand, if you need (or want) to discover what
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
<a href="/dsp/2017/12/09/nco.html">step</a>
to use (within reason, from a good initial guess), then you’ll want to add the
type-2 <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
logic in the next section to the logic we just discussed above.</p>

<h2 id="a-logic-pll-type-2">A Logic PLL: Type 2</h2>

<p>In many cases when using a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>,
you will want to track both the
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
of the incoming signal as well as its
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>.
As we discussed in our
<a href="/dsp/2017/12/09/nco.html">NCO</a>
article,
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
is represented as a regular change of
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>.
You may have noticed how we kept track of this above in <code class="language-plaintext highlighter-rouge">r_step</code>.  If you want
to track
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
as well as
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>,
then you’ll want to adjust this <code class="language-plaintext highlighter-rouge">r_step</code> value based upon the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error as well.  Such a
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
that tracks
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
as well as
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
is called a type-2
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>.</p>

<p>The basic means of extending the type-1
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
into a type-2
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
is to multiply the
(optionally) <a href="https://en.wikipedia.org/wiki/Digital_filter">filtered</a>
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error by a constant and then adjust the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
step due to <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>, i.e.
the <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
<code class="language-plaintext highlighter-rouge">r_step</code>, by that amount.  This basic logic is shown below in addition
to the type-1 logic we developed above.</p>

<table align="center" style="float: none"><caption>Fig 6. The additional type-2 frequency tracking logic</caption><tr><td><img src="/img/pll-type-2-open-loop.svg" alt="" width="780" /></td></tr></table>

<p>Up until this point, there hasn’t been much black magic.  We’ve just pushed
a counter forward or backwards by some nominal amount based upon the sign of
a measured <a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error.  Here, though, I’m going to introduce the
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
adjustment coefficient, <code class="language-plaintext highlighter-rouge">1/4 2^(-2LGCOEFF)</code>, that I’m not going to derive
today.  This particular coefficient is designed to make sure this
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
is <a href="https://en.wikipedia.org/wiki/Damping_ratio">critically damped</a>.
Practically, this just means that this
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
will converge faster than any other
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
having a <a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
correction coefficient of <code class="language-plaintext highlighter-rouge">2^(-LGCOEFF)</code>.</p>

<p>That’s a good thing.</p>

<p>Hence, our <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
correction constant is given by,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">freq_correction</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">freq_correction</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">3'b001</span><span class="p">,</span> <span class="o">{</span><span class="p">(</span><span class="n">MSB</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span> <span class="o">}</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i_lgcoeff</span><span class="p">);</span></code></pre></figure>

<p>So, how shall we update our step?  First, we’ll allow this number to be
loaded–so that you can set what
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
you expect
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this PLL</a>
to converge around.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_ld</span><span class="p">)</span>
			<span class="n">r_step</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">i_step</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Likewise, we’ll use the parameter,
<code class="language-plaintext highlighter-rouge">OPT_TRACK_FREQUENCY</code>, to control whether or not
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
tracking is enabled.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">OPT_TRACK_FREQUENCY</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">phase_err</span><span class="p">))</span>
		<span class="k">begin</span></code></pre></figure>

<p>Beyond that, any time we need to slow down, we’ll subtract this
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
correction value and any time we need to speed up we’ll add this
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
correction value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			<span class="k">if</span> <span class="p">(</span><span class="n">lead</span><span class="p">)</span>
				<span class="n">r_step</span> <span class="o">&lt;=</span> <span class="n">r_step</span> <span class="o">-</span> <span class="n">freq_correction</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">r_step</span> <span class="o">&lt;=</span> <span class="n">r_step</span> <span class="o">+</span> <span class="n">freq_correction</span><span class="p">;</span>
		<span class="k">end</span></code></pre></figure>

<p>You can find all of this code in the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">sdpll.v</a>
file within my new repository holding demonstration
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
implementations.</p>

<h2 id="performance">Performance</h2>

<p>Shall we see how well
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this PLL</a>
performs?</p>

<p>You can find a
<a href="https://veripool.org/wiki/verilator">Verilator</a>
based
<a href="/blog/2017/06/21/looking-at-verilator.html">test bench</a>
<a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">here, called sdpll_tb.cpp</a>.
This <a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">test bench
code</a>
primarily
works by starting with a set of initial conditions and then running the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">PLL</a>
to see what happens.  Unlike most of my test benches, there’s no <code class="language-plaintext highlighter-rouge">SUCCESS</code>
output at the end of
<a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">this test bench</a>
to indicate that it <em>worked</em>.  Instead, the
<a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">test bench</a>
will print <code class="language-plaintext highlighter-rouge">Simulation complete</code> to indicate that it
to completion–you’ll still need to check the results produced by <a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">the
simulation</a>
to know if it worked.</p>

<p>For our purpose today, I’ve chosen to use a random
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>.
for our initial condition, together with a
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
that’s about five system clocks per input clock.  Where the
test setup gets interesting is the fact that we’ll start by loading the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">PLL</a>
with a <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
that’s too fast by about 12%.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">tb</span><span class="p">.</span><span class="n">i_lgcoeff</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="n">lclphase</span>     <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>
	<span class="n">lclstep</span>      <span class="o">=</span> <span class="mh">0x31415928</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">i_step</span>    <span class="o">=</span> <span class="n">lclstep</span> <span class="o">+</span> <span class="p">(</span><span class="n">lclstep</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// Too fast</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">i_ld</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">i_ce</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Then, within the
<a href="https://veripool.org/wiki/verilator">Verilator</a>
per-clock loop,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">65536</span><span class="o">*</span><span class="mi">32</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">eval</span><span class="p">();</span>
		<span class="n">tfp</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">eval</span><span class="p">();</span>
		<span class="n">tfp</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">eval</span><span class="p">();</span>
		<span class="n">tfp</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">15</span><span class="p">);</span></code></pre></figure>

<p>we’ll record several performance numbers.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="p">{</span>
			<span class="kt">int</span>	<span class="n">od</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
			<span class="n">od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lclphase</span><span class="p">;</span>
			<span class="n">od</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="p">.</span><span class="n">v__DOT__r_step</span><span class="p">;</span>
			<span class="n">od</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="p">.</span><span class="n">i_input</span><span class="p">;</span>
			<span class="n">od</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="p">.</span><span class="n">o_err</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">od</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">od</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">od</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="p">.</span><span class="n">v__DOT__ctr</span><span class="p">;</span>
			<span class="n">od</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="p">.</span><span class="n">v__DOT__ctr</span> <span class="o">-</span> <span class="n">lclphase</span><span class="p">;</span>
			<span class="n">od</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="p">.</span><span class="n">o_dbg</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">od</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="mi">10</span><span class="p">);</span>

			<span class="n">fwrite</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">7</span><span class="p">,</span> <span class="n">intfp</span><span class="p">);</span></code></pre></figure>

<p>These are …</p>

<ol>
  <li>
    <p>The local simulation
<a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
that’s driving <a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">the
test</a>,
<code class="language-plaintext highlighter-rouge">lclphase</code>.</p>
  </li>
  <li>
    <p>The <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
step from within the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the PLL</a>,
<code class="language-plaintext highlighter-rouge">r_step</code>.</p>
  </li>
  <li>
    <p>The incoming input signal to
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the PLL</a>,
<code class="language-plaintext highlighter-rouge">i_input</code></p>
  </li>
  <li>
    <p>The error signal, <code class="language-plaintext highlighter-rouge">o_err</code>, created by
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the PLL</a>,
and interpreted here as a signed value</p>
  </li>
  <li>
    <p>The internal
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">PLL</a>
counter, <code class="language-plaintext highlighter-rouge">ctr</code></p>
  </li>
  <li>
    <p>The difference between the internal
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">PLL</a>
counter, <code class="language-plaintext highlighter-rouge">ctr</code> and the
<a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">simulation</a>
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>,
<code class="language-plaintext highlighter-rouge">lclphase</code>, truncated to the number of
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error bits (32)</p>
  </li>
  <li>
    <p>Finally, a
<a href="https://en.wikipedia.org/wiki/Digital_filter">filtered</a>
error output signal, <code class="language-plaintext highlighter-rouge">o_dbg</code>.  This signal isn’t really part of our
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">PLL</a>
implementation, but since I already had
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">the filter</a>
lying around from a
<a href="/dsp/2017/10/16/boxcar.html">previous post</a>
it made sense to re-use it here.</p>
  </li>
</ol>

<p>At the end of the loop, and so once per clock, we’ll update our
<a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">simulation</a>
<a href="/dsp/2017/12/09/nco.html">phase accumulator</a>,
<code class="language-plaintext highlighter-rouge">lclphase</code>, and create the next input for <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the
PLL</a>
to act upon.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">tb</span><span class="p">.</span><span class="n">i_ld</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lclphase</span> <span class="o">+=</span> <span class="n">lclstep</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">i_input</span> <span class="o">=</span> <span class="p">(</span><span class="n">lclphase</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Now that we have
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this PLL</a>
instrumented, we can answer the question of,
how well does <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this PLL</a>
work?</p>

<p>While we could look at the error output of the PLL, as shown in Fig 7,</p>

<table align="center" style="float: none"><caption>Fig 7. Output phase error</caption><tr><td><img src="/img/dpll-chart-oerr.png" alt="" width="780" /></td></tr></table>

<p>the result isn’t really all that meaningful.</p>

<p>Sadly, because the error is a discretized signal of -1, 0, or 1, it’s rather
difficult to get a good feel for what is going on.  Clearly there’s more
error on the left side, but by how much?</p>

<p>So, instead, let’s compare the difference between the
<a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">simulation</a>’s
internal <code class="language-plaintext highlighter-rouge">lclphase</code> variable and the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">reconstructed</a>
<code class="language-plaintext highlighter-rouge">ctr</code> value.  This is shown in Fig 8 as the <em>actual phase error</em>.</p>

<table align="center" style="float: none"><caption>Fig 8. Actual phase error</caption><tr><td><img src="/img/dpll-chart-actual-perr.png" alt="" width="780" /></td></tr></table>

<p>This is more revealing.  Here we can see that the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> difference on the
left side of the chart is wandering all over the place.  Why?  Because
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the PLL</a>
has yet to lock.  Eventually, it comes to a locked position and then the
error settles out into a steady state.</p>

<p>Where this gets fascinating, though, is if you evaluate the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error of
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the PLL</a>
across multiple coefficient choices.  We’ll try
<code class="language-plaintext highlighter-rouge">i_lgcoeff</code> ranging from <code class="language-plaintext highlighter-rouge">4</code> to <code class="language-plaintext highlighter-rouge">6</code>, and plot the results in Fig 9.</p>

<table align="center" style="float: none"><caption>Fig 9. Actual phase error</caption><tr><td><img src="/img/dpll-chart-actual-perr2.png" alt="" width="780" /></td></tr></table>

<p>There’s a couple of things to notice in Fig 9.  First, the larger the
coefficient (i.e. the smaller <code class="language-plaintext highlighter-rouge">i_lgcoeff</code>), the faster
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the PLL</a>
converges.  However,
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the PLL</a>
doesn’t settle as nicely when <code class="language-plaintext highlighter-rouge">i_lgcoeff</code> is <code class="language-plaintext highlighter-rouge">4</code> compared to how it settles
when <code class="language-plaintext highlighter-rouge">i_lgcoeff</code> is <code class="language-plaintext highlighter-rouge">6</code>.  On the other hand, even though the smaller
values of <code class="language-plaintext highlighter-rouge">2^(-i_lgcoeff)</code> take longer to converge, once they do converge
the remaining residual error is much smaller.</p>

<p>We can also return to
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the PLL</a>’s
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
error output and average it using a 3839 point
<a href="/dsp/2017/10/16/boxcar.html">boxcar filter</a>.
(There is no particular significance to this number, 3839.  Feel free to
try other amounts if you would like.)
This will help to accumulate the errors long enough to draw a conclusion
from them.  You can see this result in Fig 10.</p>

<table align="center" style="float: none"><caption>Fig 10. Filtered Phase Error</caption><tr><td><img src="/img/dpll-chart-averr2.png" alt="" width="780" /></td></tr></table>

<p>The first conclusion to draw from Fig 10 is that we
<a href="/dsp/2017/10/16/boxcar.html">averaged</a>
too many sample points together for <code class="language-plaintext highlighter-rouge">i_lgcoeff=4</code> and <code class="language-plaintext highlighter-rouge">i_lgcoeff=5</code>.  This is
seen by the fact that the filtered error signals appear like negative rectangle
functions.  In spite of this artifact, you can see that the
<code class="language-plaintext highlighter-rouge">i_lgcoeff=6</code> trace accumulates a much larger error before it finally locks.
Further, when each of these traces gets to the locked condition, they <em>suddenly</em>
go to zero.  Finally, as before with the residual error, the <code class="language-plaintext highlighter-rouge">i_lgcoeff=6</code> ends
up with smaller residual error.  (This is harder to see on the chart.)</p>

<p>The last variable to consider is the
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
step size.  Remember, we started
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this PLL</a>
with a <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
value that was about 12% too fast.  Hence, the step size
needs to come down a bit.  In Fig 11, you can see the step size, <code class="language-plaintext highlighter-rouge">r_step</code>,
coming down for all three traces until the respective
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">PLL</a>’s
lock.  Once lock has been achieved, the traces appear to flatten out.</p>

<table align="center" style="float: none"><caption>Fig 11. Frequency Step</caption><tr><td><img src="/img/dpll-chart-fstep2.png" alt="" width="780" /></td></tr></table>

<p>However, as before, the <code class="language-plaintext highlighter-rouge">i_lgcoeff=4</code> trace has the most noise on it following
convergence, whereas the <code class="language-plaintext highlighter-rouge">i_lgcoeff=6</code> trace has less noise.</p>

<p>Together, these charts should be sufficient to not only demonstrate that
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this PLL</a>
implementation “works”, but also to give you an indication as to <em>how well</em>
it works.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Building a <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> doesn’t
need to be the black art I once thought it was.  All of the parts and pieces
have fairly simple definitions, and
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">the implementation</a>
of this simple
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
really wasn’t all that complex.  Even better, since I’ve posted
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">this code</a>
on <a href="https://github.com/ZipCPU">GitHub</a>, you are welcome to try it out yourself
to see how well (or poorly) it works for your problem set.</p>

<p>Of course, I haven’t exhausted the topic of
either <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> design or
analysis–I’ve just presented a single
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">implementation</a>
that has worked well for me over many years.  As examples of some of the things
we haven’t discussed:</p>

<ol>
  <li>
    <p>There’s a real reason and theory behind why we chose the
<a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
correction value we did.  Perhaps if someone is interested, I could go
through this theory.  Be prepared, though, it depends upon a solid
understanding of <a href="https://en.wikipedia.org/wiki/Frequency"><em>Z</em> transforms</a>.</p>
  </li>
  <li>
    <p>You may also remember that I skipped the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a> error
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>s
in this implementation.  While a simple
<a href="/dsp/2017/08/19/simple-filter.html">recursive average</a>
filter works nicely, the
<a href="/dsp/2017/08/19/simple-filter.html">recursive average</a>
coefficient couples with the
<a href="https://en.wikipedia.org/wiki/Instantaneous_phase">phase</a>
and <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>
correction coefficients of the
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>,
necessitating a change to how these coefficients need to be calculated
should you go this route.</p>
  </li>
  <li>
    <p>The actual study and analysis of
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s
includes a study of how to predict many of the charts I presented above
in Figures 7-11.  While it’s a valuable study that I would commend to anyone
interested, it’s not required to understand any of the figures.</p>
  </li>
</ol>

<p>Further, I know I said
that <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s could be used for
clock recovery.  While
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">today’s logic PLL</a>
implements a valuable circuit that can handle that task,
you may find that the hardware implemented
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s within your
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
are much more appropriate for this purpose than the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">PLL we designed today</a>.</p>

<p>Finally, this isn’t the last word on
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> implementation.
Other <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> implementations
are also valuable, such as the more traditional
(non-<a href="https://en.wikipedia.org/wiki/Boolean_algebra">binary</a>)
<a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a> implementations,
or even logic <a href="https://en.wikipedia.org/wiki/Phase-locked_loop">PLL</a>s
designed to run at many samples per clock.  These will need to remain a
topic for future posts.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>But the men marvelled, saying, What manner of man is this, that even the winds and the sea obey him! (Matt 8:24)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
