<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Generating Pseudo-Random Numbers on an FPGA</title>
  <meta name="description" content="At some point or other, when working withFPGAs,you will need a pseudorandomnumber sequence.  Trust me, it’s just going to happen.">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2017/10/27/lfsr.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Generating Pseudo-Random Numbers on an FPGA</h1>
    <p class="post-meta"><time datetime="2017-10-27T00:00:00-04:00" itemprop="datePublished">Oct 27, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>At some point or other, when working with
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>s,
you will need a <a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom</a>
number sequence.  Trust me, it’s just going to happen.</p>

<p>In my case it happened this last week.  I needed to do some
<a href="https://en.wikipedia.org/wiki/System_identification">channel estimation</a>,
and I reasoned that a
<a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom</a> sample stream
would make a nice input to
<a href="https://store.digilentinc.com/pmod-cable-kit-12-pin">the channel</a>.
Specifically, my ultimamte plan is to
transmit <a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom bits</a>
out of an <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
output pin at the fastest speed I can:
<a href="https://www.xilinx.com/support/documentation/data_sheets/ds181_Artix_7_Data_Sheet.pdf">950 Mbps</a>
on my
<a href="https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf">Artix-7</a>
<a href="https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/">Arty</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> board.
I can then receive the bits at the other end of
<a href="https://store.digilentinc.com/pmod-cable-kit-12-pin">the channel</a>, and
examine them to get an <a href="https://en.wikipedia.org/wiki/System_identification">estimate of the channel
distortion</a>.  If all goes
well, I should even be able to apply <a href="https://en.wikipedia.org/wiki/Channel_capacity">Shannon’s Capacity
theorem</a> to determine the
maximum speed of <a href="https://store.digilentinc.com/pmod-cable-kit-12-pin">the
channel</a>.</p>

<p>All I needed to get started was a source of
<a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom bits</a>.</p>

<p>One common source for
<a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom bits</a>
in digital logic is a
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">Linear Feedback Shift Register
(LFSR)</a>.
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSRs</a> are simple
to build and so they are commonly used for this purpose.  They have some
wonderful mathematical properties associated with them, guaranteeing a
certain amount of
<a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandomness</a>.
Be forwarned, however, the one thing
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s are not
is <a href="https://wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">cryptographically random/secure</a>.
<em>Do not use
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s
in place of a proper
<a href="https://wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">cryptographically secure sequence</a>.</em>
That said, they are worth learning how to create and use.</p>

<p>Much of my <a href="https://en.wikipedia.org/wiki/System_identification">System
Identification</a>
project will need to wait for a later post.  Until that time, I’ll be
accepting gentlemen’s wagers (no money involved) regarding what this ultimate
maximum speed will be.</p>

<p>Today’s topic though is just a simple discussion of how to implement an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
in Verilog.  We’ll skip the worst of the mathematics, although I would
recommend you look them up.</p>

<p>Basically, the idea behind an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
is that given a current register state, I’ll call it a “fill”, you can
compute the next state via a linear combination of the bits in the current
state.  I’ll use the term “taps” or “polynomial” interchangeably to describe
this formula–although you might need to dig into more of the mathematics
to understand why.</p>

<p>In this post, we’ll discuss these registers and how to create them
in Verilog.</p>

<h2 id="basic-math">Basic Math</h2>

<p>Let’s start, though, by looking at some very simple math.  This math involves
the <a href="https://en.wikipedia.org/wiki/Finite_field">Galois Field</a> having only
two elements, 0 and 1.  We’ll use the term
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a> to describe this field.</p>

<p>If you are not familiar with what a
<em><a href="https://en.wikipedia.org/wiki/Field_(mathematics)">field</a></em> is in this
context, it’s simply a mathematical abstraction of a number system based upon
a set of values, together with the definitions of addition and multiplication
defined on those values.  The neat thing about
<a href="https://en.wikipedia.org/wiki/Field_(mathematics)">field</a>s is that much of
the math you are already likely to be familiar with is based upon
<a href="https://en.wikipedia.org/wiki/Field_(mathematics)">field</a>s.  For example,
I’m going to guess that you are probably familiar with
<a href="https://en.wikipedia.org/wiki/Linear_algebra">linaer algebra</a>.
<a href="https://en.wikipedia.org/wiki/Linear_algebra">Linaer algebra</a>, though,
is all based upon
<a href="https://en.wikipedia.org/wiki/Field_(mathematics)">field</a>s.
Although I learned
<a href="https://en.wikipedia.org/wiki/Linear_algebra">linaer algebra</a> using
<a href="https://en.wikipedia.org/wiki/Integer">integers</a>,
<a href="https://en.wikipedia.org/wiki/Real_number">real numbers</a>,
and <a href="https://en.wikipedia.org/wiki/Complex_number">complex numbers</a>,
<a href="https://en.wikipedia.org/wiki/Linear_algebra">linaer algebra</a> is actually
based upon <a href="https://en.wikipedia.org/wiki/Field_(mathematics)">field</a>s:
arbitrary algebraic systems with a defined set of values, as well as
two primary operations defined upon that set.</p>

<p>We already said today’s topic would focus on the
<a href="https://en.wikipedia.org/wiki/Field_(mathematics)">field</a> known as
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a>, and that this
<a href="https://en.wikipedia.org/wiki/Field_(mathematics)">field</a> contains the
numbers zero and one.</p>

<p>What we haven’t mentioned are the two two mathematical operators that define
this field: addition and multiplication.  Both are used in the implementation
of an <a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>.</p>

<p>The difference between the addition and multiplication operators you might be
familiar with, and the operators defined by
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a>, is that the
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a> operators are followed by
a <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modulo two</a>.
Hence, the result will be a ‘1’ if the traditional addition (or
multiplication) result was odd, or ‘0’ if it was even.</p>

<table style="float: right"><caption>Fig 1: Addition in GF(2)</caption><tr><td><img src="/img/gf2-add.svg" alt="" width="180" /></td></tr></table>

<p>If you look at the addition operator under
<a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modulo two</a>,
you’ll find the first couple values to be what you expect:
<code class="language-plaintext highlighter-rouge">0+0=0</code>, <code class="language-plaintext highlighter-rouge">0+1=1</code>, and <code class="language-plaintext highlighter-rouge">1+0=1</code>.  Where things get a little interesting is when
adding <code class="language-plaintext highlighter-rouge">1+1</code> together.  In the traditional integer arithmetic you’re likely
familiar with, you’d get a <code class="language-plaintext highlighter-rouge">2</code>.  In arithmetic over
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a>,
you need to take the result
<a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modulo two</a>,
and so <code class="language-plaintext highlighter-rouge">1+1</code> results in zero, as shown in Fig 1.</p>

<p>Think about that operation again for a moment: <code class="language-plaintext highlighter-rouge">0+0=0</code>, <code class="language-plaintext highlighter-rouge">0+1=1</code>, and <code class="language-plaintext highlighter-rouge">1+1=0</code>.
That describes an
<a href="https://en.wikipedia.org/wiki/Exclusive_or">exclusive or operation, or XOR</a>.</p>

<table style="float: left; padding: 15px"><caption>Fig 2: Multiplication in GF(2)</caption><tr><td><img src="/img/gf2-multiply.svg" alt="" width="180" /></td></tr></table>

<p>We’ll do the same thing for multiplication.  In this case, multiplying numbers
from the set of zero and one will only yield the result zero and one, so
you might not notice the
<a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modulo two</a>.  Then,
when you look at the results as shown in Fig 2, you’ll quickly see that
multiplication over
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a>
is nothing more than a
<a href="https://en.wikipedia.org/wiki/Logical_conjunction">bitwise-and</a>.</p>

<p>Given these two operators, let’s define a bit-vector, <code class="language-plaintext highlighter-rouge">sreg</code>, whose elements
are either zero or one—elements from
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a>.  We’ll also state that
this bit-vector has an initial value given by <code class="language-plaintext highlighter-rouge">INITIAL_FILL</code>.  In a similar
manner,
we can construct a linear operator, <code class="language-plaintext highlighter-rouge">T(x)</code>, that can be
applied to <code class="language-plaintext highlighter-rouge">sreg</code> to yield a new or updated value for <code class="language-plaintext highlighter-rouge">sreg</code> at the next
time-step.  This operator will be defined by another vector, <code class="language-plaintext highlighter-rouge">TAPS</code>, but
we’ll come back to this in a moment.  For now, just remember that <em>any</em>
linear operation on a finite set can be represented by a matrix–another
fact we’ll come back to.</p>

<p>In pseudocode notation, an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
just applies the linear operator to the current <code class="language-plaintext highlighter-rouge">sreg</code> value over and over
again.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">sreg = INITIAL_FILL;
while(!armageddon)
	sreg &lt;= T(sreg);</code></pre></figure>

<p>A key thing to point out, though, is that any linear operation on the all
zeros vector will always return the all zeros vector, hence <code class="language-plaintext highlighter-rouge">T(zero)==0</code>.  As
we go along, we’ll need to be careful to keep <code class="language-plaintext highlighter-rouge">sreg</code> from becoming zero.</p>

<p>What makes
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s so special
is that as you apply this linear operator, the bottom bit will appear
to be <a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom</a>.  If you
choose your linear system well, an <code class="language-plaintext highlighter-rouge">N</code> bit shift register will walk through
all possible <code class="language-plaintext highlighter-rouge">2^N-1</code> combinations before repeating–generating <code class="language-plaintext highlighter-rouge">2^(N-1)</code>
ones, and <code class="language-plaintext highlighter-rouge">2^(N-1)-1</code> zeros along the way.  You do need to be aware, though,
not all linear systems have this property.  Those that do are said to
create <a href="https://en.wikipedia.org/wiki/Maximum_length_sequence">Maximal Length
Sequences</a>.
These <a href="https://en.wikipedia.org/wiki/Maximum_length_sequence">maximal length
sequences</a>, however,
tend to be well known, and <a href="https://docs.google.com/spreadsheets/d/1hnFigZpPEBg9hdFjImPzOgRsgZWAYupFBaTePN0BuAw/">tables even
exist</a>
containing examples of
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s
that will generate anything from short
<a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom sequences</a>
all the way up to <em>very long</em> ones.</p>

<p>Ok, I promised not to get deep into the math, but it is important to understand
that <a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s
implement a <em>linear</em> operation on a bit-vector.  These linear
operations can be represented as a matrix operation–but only if the
linear system described by the matrix follows the rules of
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a>.</p>

<h2 id="galois">Galois</h2>

<p>As the <a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">wikipedia article on LFSR</a>s explains, there are two forms of expressing
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s.  The first
is a Galois form, the second is known as the Fibonacci form.  Both will yield
the same sequences, although their initial parameters, <code class="language-plaintext highlighter-rouge">INITIAL_FILL</code>,
and their <code class="language-plaintext highlighter-rouge">TAPS</code> values will be difference from one form to the other.
(Don’t worry, we’ll define these more formally in a moment.) Pictorially, a
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">Galois shift register
implementation</a>
looks like Fig 3.</p>

<table align="center" style="float: none"><caption>Fig 3: A Galois Shift Register Configuration</caption><tr><td><img src="/img/lfsr-galois.svg" alt="Picture of a Galois shift register" width="480" /></td></tr></table>

<p>Let’s let the number of stages in this register be <code class="language-plaintext highlighter-rouge">LN</code>, and the initial
value of all of the stages given by <code class="language-plaintext highlighter-rouge">INITIAL_FILL</code>.  The last item needed
to implement a general purpose <a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">Galois shift register
implementation</a>
are the coefficients of the multiplies shown in the figure above.  We’ll
call these the <code class="language-plaintext highlighter-rouge">TAPS</code>–mostly because they “tap-into” the shift register
sequence when one, and ignore it when zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">parameter</span>	<span class="n">LN</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span> <span class="c1">// the size of your bit-vector</span>
<span class="k">parameter</span>	<span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">TAPS</span> <span class="o">=</span> <span class="p">...,</span> <span class="c1">// some value in your design</span>
				<span class="n">INITIAL_FILL</span> <span class="o">=</span> <span class="p">...</span> <span class="p">;</span><span class="c1">// Another design parameter</span></code></pre></figure>

<p>Looking at Fig 3 again, you can see an input going through
several (<code class="language-plaintext highlighter-rouge">LN</code>) stages
(<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">Flip-flops</a>)
of processing to create an output.  That output is then
fed-back to affect the stages along the way.  Notice also the adds and the
multiplies.  These are the adds
(<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>)
and multiplies
(<a href="https://en.wikipedia.org/wiki/Logical_conjunction">AND</a>)
we discussed in our last section.</p>

<p>The multiplication values are given by the <code class="language-plaintext highlighter-rouge">TAPS</code> of the
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>.  They do
not change during sequence generation.
The mathematicians will describe the <code class="language-plaintext highlighter-rouge">TAPS</code> as the coefficients of a
polynomial in <a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a>.
These coefficients can either be a one or a zero–as with everything in
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a>.
As we mentioned above, <a href="https://docs.google.com/spreadsheets/d/1hnFigZpPEBg9hdFjImPzOgRsgZWAYupFBaTePN0BuAw/">specific
choices</a>
will yield <a href="https://en.wikipedia.org/wiki/Maximum_length_sequence">maximal length
sequences</a>.
If you would rather, though, I tend to think of <code class="language-plaintext highlighter-rouge">TAPS</code> as just a particular
<code class="language-plaintext highlighter-rouge">N</code> bit binary vector.</p>

<p>One of the reasons why I wanted to point out, in the last section, that an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a> is nothing
but a linear operator over
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a>, is that it allows us to
write out this formula as a series of linear equations.</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-galois.png" alt="Matrix equation for a Galois shift register" width="665" /></td></tr></table>

<p>In this form, I’ve used <code class="language-plaintext highlighter-rouge">g_1</code> through <code class="language-plaintext highlighter-rouge">g_(N-1)</code> to represent the taps.  The
bit vector,  <code class="language-plaintext highlighter-rouge">x</code>, has <code class="language-plaintext highlighter-rouge">N</code> bits to it ranging from <code class="language-plaintext highlighter-rouge">x[0]</code> through <code class="language-plaintext highlighter-rouge">x[N-1]</code> or
<code class="language-plaintext highlighter-rouge">x[MSB]</code>.  This equation provides the formula for calculating the next
bit vector, <code class="language-plaintext highlighter-rouge">x</code>, from the last one.  It’s worth noting that the entire
matrix is nearly upper right triangular, save for the <code class="language-plaintext highlighter-rouge">g</code> coefficients in the
first column.</p>

<p>Okay, so that’s the operation we want to perform.  Now, let’s finish <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_gal.v">building
it</a>.</p>

<p>In pseudocode, I’m going to represent the <code class="language-plaintext highlighter-rouge">x</code>’s in a register I’ll call <code class="language-plaintext highlighter-rouge">sreg</code>,
and the <code class="language-plaintext highlighter-rouge">g</code>’s will be our <code class="language-plaintext highlighter-rouge">TAPS</code> bit-vector parameter.</p>

<p>The other value of interest is the <code class="language-plaintext highlighter-rouge">INITIAL_FILL</code>.  For a <a href="https://en.wikipedia.org/wiki/Maximum_length_sequence">maximal length
sequence</a>, the only
restriction on the <code class="language-plaintext highlighter-rouge">INITIAL_FILL</code> is that it <em>cannot be</em> zero.  Any other
value is allowed.  This <code class="language-plaintext highlighter-rouge">INITIAL_FILL</code> will determine your starting point in
the random sequence created by the
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>.</p>

<p>You may also have noticed the “input” in Fig 3.  We’ll set this to zero
for today’s task.  Setting it to another value has the effect of creating a
<a href="https://en.wikipedia.org/wiki/Scrambler">feed-through randomizer</a>, rather than
the <a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom number
generator</a> we are building
today.</p>

<p>The code necessary to implement a Galois shift register can be drawn directly
from Fig 3.  We’ll use <code class="language-plaintext highlighter-rouge">sreg</code> to describe the values in the register, so that
our output, <code class="language-plaintext highlighter-rouge">o_bit</code>, is just the LSB of <code class="language-plaintext highlighter-rouge">sreg</code>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">o_bit</span> <span class="o">=</span> <span class="n">sreg</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span></code></pre></figure>

<p>On a reset, we’ll initialize <code class="language-plaintext highlighter-rouge">sreg</code> to our <code class="language-plaintext highlighter-rouge">INITIAL_FILL</code>.  Likewise, we’ll use
the “global-CE” <a href="/blog/2017/08/14/strategies-for-pipelining.html">pipeline
strategy</a>,
so nothing is allowed to change unless <code class="language-plaintext highlighter-rouge">i_ce</code> is also true.  This will make our
circuit useful for
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">DSP</a>
tasks that need to run synchronously at data rates other than our clock rate.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">sreg</span> <span class="o">&lt;=</span> <span class="n">INITIAL_FILL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>With that aside, our logic is straight-forward.  On every clock, we move all
the bits forward by one step.  If the LSB is a one, we add
(<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>) the
<code class="language-plaintext highlighter-rouge">TAPS</code> vector to our state vector as the bits step forward.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">sreg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">sreg</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">}</span> <span class="o">^</span> <span class="n">TAPS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sreg</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Note how we checked for a <code class="language-plaintext highlighter-rouge">1</code> bit in the bottom bit of <code class="language-plaintext highlighter-rouge">sreg</code>.  This is how to
implement the multiply.  If the bottom bit is a zero, then the <code class="language-plaintext highlighter-rouge">TAPS</code> times
zero will be the zero vector which will not affect anything when added.  On
the other hand, if <code class="language-plaintext highlighter-rouge">sreg[0]</code> is a <code class="language-plaintext highlighter-rouge">1</code>, we’ll add the taps to our result.</p>

<p>The astute observer may note here that <code class="language-plaintext highlighter-rouge">TAPS[LN-1]</code> must be a one, or the
most significant bit (MSB) will be trivially zero.</p>

<p>Incidentally, this version of an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
is <em>really</em> easy to calculate in software, and its C++ equivalent is given
by:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span>	<span class="nc">LFSR</span> <span class="p">{</span>
	<span class="c1">// ... LN is given by 8*size(unsigned) below</span>
	<span class="c1">//</span>
	<span class="c1">// ... define INITIAL_FILL, TAPS, etc</span>
	<span class="c1">//</span>
	<span class="kt">unsigned</span>	<span class="n">m_sreg</span><span class="p">;</span>

	<span class="n">LFSR</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_sreg</span> <span class="o">=</span> <span class="n">INITIAL_FILL</span><span class="p">;</span> <span class="p">}</span>

	<span class="kt">void</span>	<span class="n">reset</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_sreg</span> <span class="o">=</span> <span class="n">INITIAL_FILL</span><span class="p">;</span> <span class="p">};</span>

	<span class="kt">int</span>	<span class="n">step</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Calculate the output value up front</span>
		<span class="kt">int</span>	<span class="n">out</span> <span class="o">=</span> <span class="n">m_sreg</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>

		<span class="c1">// Shift the register</span>
		<span class="n">m_sreg</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="c1">// Use the output value to determine if the TAPS</span>
		<span class="c1">// need to be added (XORd) in</span>
		<span class="n">m_sreg</span> <span class="o">^=</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">?</span> <span class="n">TAPS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>If you look hard through the Linux kernel sources, you’ll even find an
implementation of <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/tree/lib/crc32.c?h=v4.13.10">this algorithm</a>
 within them.  .
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/tree/lib/crc32.c?h=v4.13.10">There</a>, though
it’s used to implement a <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">Cyclic Redundancy Check
(CRC)</a>
and so their input isn’t zero.</p>

<p>You can find a <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_gal.v">copy of the code for the
Galois</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
on <a href="https://github.com/ZipCPU">Github</a>, as a part of
my <a href="https://github.com/ZipCPU/dspfilters">filtering repository</a>.</p>

<h2 id="fibonacci">Fibonacci</h2>

<p>The other
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a> form is
the Fibonacci form.  The Fibonacci form of an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
is mathematically equivalent to the Galois
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>,
save that the outputs are calculated in a different manner, and the <code class="language-plaintext highlighter-rouge">TAPS</code>
need to be “reversed”.  The diagram in Fig 4 shows the basic form of the
Fibonacci <a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>.</p>

<table align="center" style="float: none"><caption>Fig 4: A Fibonacci Shift Register Configuration</caption><tr><td><img src="/img/lfsr.svg" alt="" width="480" /></td></tr></table>

<p>In this figure, it’s the intermediate stages whose values are added
(<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>‘d)
together to produce an update value that is then added
(<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>‘d)
to the input.</p>

<p>In many ways, this makes an ideal form for implementing an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
on an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>:
The feedback bit is usually calculated from just a small
number of taps (2-4) into the shift register, making it <a href="/blog/2017/06/12/minimizing-luts.html">fit within a single
LUT</a> quite easily.
Another unique feature to this form is that the values in the shift
register aren’t modified between when they are originally calculated and
the output–making it possible to see then next <code class="language-plaintext highlighter-rouge">LN</code> output bits by
just examining the shift register state.  (We’ll use this in our next
post on
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s,
showing how to generate more than one bit at a time.)</p>

<p>As with the Galois
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>,
the Fibonacci version also implements a linear system.  This time, though,
it has a different structure.</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-fibonacci.png" alt="Matrix equation for a Fibonacci shift register" width="687" /></td></tr></table>

<p>where the <code class="language-plaintext highlighter-rouge">MSB</code> is the feedback bit above.</p>

<p>When it comes to implementation, the initial implementation steps are the
same as with the Galois implementation.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">sreg</span> <span class="o">&lt;=</span> <span class="n">INITIAL_FILL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>The difference is what you do to determine the next output bit.  When using
the Fibonacci form, we take an <a href="https://en.wikipedia.org/wiki/Inner_product_space">inner
product</a> between or
bit-vector, <code class="language-plaintext highlighter-rouge">sreg</code>, and our TAPS vector.  This is nothing more than a point by
point multiply (<a href="https://en.wikipedia.org/wiki/Logical_conjunction">AND</a>),
followed by summing
(<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>)
all of the results of the multiplies together to create the new high order
bit.  As before, we’ll hold the “input” to zero, and so we get the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">following
formula</a></p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">sreg</span><span class="p">[</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">^</span><span class="p">(</span><span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">TAPS</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>It’s not often that you get a chance to use an
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>
reduction operator, however
this is one of those times.  Note the expression <code class="language-plaintext highlighter-rouge">^(sreg[..] &amp; TAPS)</code>.  The
<code class="language-plaintext highlighter-rouge">^</code> in the front of this specifies that all of the values in <code class="language-plaintext highlighter-rouge">sreg[..] &amp; TAPS</code>
are to be added together, in a
<a href="https://en.wikipedia.org/wiki/Exclusive_or">modulo two sum</a>–just
what we need to do here.</p>

<p>This isn’t the only way to build a Fibonacci
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
For example, <a href="http://www.xilinx.com/support/documentation/application_notes/xapp210.pdf">this Xilinx app
note</a>
discusses how to implement an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
using the shift register
<a href="https://en.wikipedia.org/wiki/Logic_block">logic blocks</a>
within a <a href="http://www.xilinx.com">Xilinx</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
<a href="http://www.xilinx.com">Xilinx</a>’s
development is different from
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">mine</a>
primarily because the
shift register <a href="https://en.wikipedia.org/wiki/Logic_block">logic block</a>
that <a href="http://www.xilinx.com">Xilinx</a> depended upon does not support a
reset signal.</p>

<p>You can find a <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">copy of the code for this
Fibonacci</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
on <a href="https://github.com/ZipCPU">Github</a>, also a part of
my <a href="https://github.com/ZipCPU/dspfilters">filtering repository</a>.</p>

<p>If you would rather see this example in VHDL, there is a
<a href="http://opencores.org/project,lfsr_randgen">VHDL version</a>
on <a href="http://opencores.org">OpenCores</a> that you may find useful.</p>

<h2 id="test-bench">Test Bench</h2>

<p>I’ve also placed a test bench for each of these two shift register
implementations <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/lfsr_gal_tb.cpp">here</a>
and <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/lfsr_fib_tb.cpp">here</a>.
Since the two are nearly identical, I’ll walk through the salient portions
of one of them only.  For a more detailed description of how to build
a <a href="https://www.veripool.org/wiki/verilator">Verilator</a>
based-test bench in general, please take a look at
<a href="/blog/2017/06/21/looking-at-verilator.html">this article</a>.
The one thing we’ll do different here from many of my other projects is that
we’ll call <a href="https://www.veripool.org/wiki/verilator">Verilator</a> directly
rather than using a subclass–just because our simulation needs for
this component are so simple.</p>

<p>You’ll find this test bench starts out very simply.  We call
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>’s
initialization routine, and declare a test bench based object upon our
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">implementation</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span>	<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Verilated</span><span class="o">::</span><span class="n">commandArgs</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="n">Vlfsr_fib</span>	<span class="n">tb</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">clocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ones</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>We’re also going to declare three more variables: <code class="language-plaintext highlighter-rouge">clocks</code>, <code class="language-plaintext highlighter-rouge">nout</code>, and <code class="language-plaintext highlighter-rouge">ones</code>.
We’ll use the <code class="language-plaintext highlighter-rouge">clocks</code> variable to count the number of <code class="language-plaintext highlighter-rouge">clocks</code> we use, to keep
from overloading the user’s screen with numbers.  <code class="language-plaintext highlighter-rouge">nout</code> will be used to
help us place spaces in the output, and <code class="language-plaintext highlighter-rouge">ones</code> will be used to count the
number of ones in our output.</p>

<p>This <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/lfsr_fib_tb.cpp">test bench</a> also
assumes that our result will be a <a href="https://en.wikipedia.org/wiki/Maximum_length_sequence">maximal length
sequence</a>.  In this
case, there should be exactly <code class="language-plaintext highlighter-rouge">2^(LN)-1</code> unique outputs (clock ticks before
<code class="language-plaintext highlighter-rouge">sreg</code> equals one again), and <code class="language-plaintext highlighter-rouge">2^(LN-1)</code> ones in those outputs.  This will
be our evidence of success.</p>

<p>Our next step will be to start our core with a reset pulse.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">// reset our core before cycling it</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">i_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">i_ce</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">eval</span><span class="p">();</span>
	<span class="n">TRACE_POSEDGE</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">i_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">eval</span><span class="p">();</span>
	<span class="n">TRACE_NEGEDGE</span><span class="p">;</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">TRACE_POSEDGE</code> and <code class="language-plaintext highlighter-rouge">TRACE_NEGEDGE</code> are macros used to write the
simulation state to a
<a href="/blog/2017/07/31/vcd.html">VCD file</a>.</p>

<p>Once the reset is complete, we’ll assert that the shift register initial state
is <code class="language-plaintext highlighter-rouge">1</code>.  While this doesn’t necessarily need to be the case, setting
<code class="language-plaintext highlighter-rouge">INITIAL_FILL</code> to anything else within the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">Verilog file</a>
will necessitate coming back and updating it here.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">assert</span><span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">v__DOT__sreg</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>Finally, we’ll move on to the simulation itself.  We’ll start out with
<code class="language-plaintext highlighter-rouge">16384</code> clocks of simulation.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">while</span><span class="p">(</span><span class="n">clocks</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="o">*</span><span class="mi">32</span><span class="o">*</span><span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">ch</span><span class="p">;</span>

		<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">i_ce</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">eval</span><span class="p">();</span>
		<span class="n">TRACE_POSEDGE</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">eval</span><span class="p">();</span>
		<span class="n">TRACE_NEGEDGE</span><span class="p">;</span></code></pre></figure>

<p>On each of these clocks, we’ll print an output bit to the screen.  This should
allow you to visually verify that the bits <em>look</em> random.  We’ll place
spaces between every eight bits for easier reading as well.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="n">ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">o_bit</span><span class="p">)</span> <span class="o">?</span> <span class="sc">'1'</span> <span class="o">:</span> <span class="sc">'0'</span><span class="p">;</span>
		<span class="n">ones</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">o_bit</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">putchar</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
		<span class="n">nout</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">nout</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">56</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">putchar</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">putchar</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">clocks</span><span class="o">++</span><span class="p">;</span></code></pre></figure>

<p>Finally, if the shift register value ever returns to our <code class="language-plaintext highlighter-rouge">INITIAL_FILL</code> of one,
then we know we’ve exhausted the sequence.  We can therefore break.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">v__DOT__sreg</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="err">}</span>
	<span class="n">TRACE_CLOSE</span><span class="p">;</span></code></pre></figure>

<p>In case you want to test for a <em>really long</em> sequence, the <code class="language-plaintext highlighter-rouge">16k</code> clocks
won’t be enough.  Rather than continue to fill your screen, the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/lfsr_fib_tb.cpp">test bench</a>
just quietly continues crunching here.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">while</span><span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">v__DOT__sreg</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">eval</span><span class="p">();</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">i_clk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">eval</span><span class="p">();</span>

		<span class="n">ones</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">o_bit</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">clocks</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>As a final step, let’s compare the number of clocks we used in our output
to determine whether or not the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/lfsr_fib_tb.cpp">test bench</a>
was ultimately successful.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Simulation complete: %d clocks (%08x), %d ones</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">clocks</span><span class="p">,</span> <span class="n">clocks</span><span class="p">,</span> <span class="n">ones</span><span class="p">);</span>

	<span class="k">const</span> <span class="kt">int</span> <span class="n">LN</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">clocks</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LN</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">ones</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">))))</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"SUCCESS!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="nf">printf</span><span class="p">(</span><span class="s">"FAILURE!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="err">}</span></code></pre></figure>

<p>Of course, since I’m posting this, I’ve already proven it …</p>

<h2 id="conclusion">Conclusion</h2>

<p>There you go!  That’s all there is to building an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
and demonstrating that it works.</p>

<p>Sadly, though, neither of our implementations today was sufficient for my
<a href="https://en.wikipedia.org/wiki/System_identification">channel estimation</a>
problem at 950MHz.  Even if I <em>could</em> run this logic that fast, the rest of my
logic wouldn’t be able to keep up.  As a result, we’ll need to come back to
this topic and see if we can’t build an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
that produces multiple outputs in parallel.</p>

<p>Still, <a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s are
a fundamental <a href="https://en.wikipedia.org/wiki/Digital_signal_processing">DSP</a>
tool, that’s easy to implement within an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.
Feel free to try yourself!</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>I returned, and saw under the sun, that the race is not to the swift, nor the battle to the strong, neither yet bread to the wise, nor yet riches to men of understanding, nor yet favour to men of skill; but time and chance happeneth to them all.  (Eccl 9:11)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
