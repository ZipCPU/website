<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A CORDIC testbench</title>
  <meta name="description" content="Some time ago, I presented aCORDIC algorithmonthis blog.This CORDIC algorithmmakes it possible to generate sine and cosines usingnormalized integers as phase...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2017/10/02/cordic-tb.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>


<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">A CORDIC testbench</h1>
    <p class="post-meta"><time datetime="2017-10-02T00:00:00-04:00" itemprop="datePublished">Oct 2, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Some time ago, I presented a
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
on
<a href="https://zipcpu.com/">this blog</a>.
This <a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
makes it possible to generate sine and cosines using
normalized integers as phase angles and only additions and shifts.
The <a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
is unique because of the simple fact that it does not require any multiplies
to calculate these
<a href="https://en.wikipedia.org/wiki/Trigonometry">trigonometric</a> values.</p>

<p>Since that time, we’ve demonstrated the utility of
<a href="/dsp/2017/08/30/cordic.html">this algorithm</a>
when <a href="/dsp/2017/09/16/pwm-demo.html">testing</a>
a <a href="/dsp/2017/09/04/pwm-reinvention.html">proposed/modified PWM
algorithm</a>.</p>

<p>This is only the beginnings of what a
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
can be used for.  You can also modulate baseband signals to
intermediate/carrier frequencies, and downconvert them back to base band,
using the same approach.  It is really quite versatile.</p>

<p><a href="/dsp/2017/08/30/cordic.html">CORDIC</a>s
can also be used for generating test functions for
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
based <a href="https://en.wikipedia.org/wiki/Digital_filter">filters</a>.
This is particularly where I’d like to go with the technology
on <a href="https://zipcpu.com/">this blog</a>.
This means that our filtering test bench will depend upon this
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a> algorithm, and hence
any failure in the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a> will have a ripple
affect into our future articles.</p>

<p>For this reason, we need to get the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a> <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
right.</p>

<p>It also turns out that we made our problem more difficult by creating a
core generator approach to our
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>.
Because of the core generation approach, our
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a> <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
will need to run across all manner of parameters: number of stages, input
data width, phase bit-width, extra internal bits, and output bit width.  So
that we could handle this extra variability, we took a pause in our
development in order to present some <a href="/dsp/2017/09/27/quantization.html">probabilistic quantities related to
quantization</a>
which we can now use to predict the performance we expect so as to measure
how well we do in comparison to it.</p>

<p>Building this <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
is going to take several steps.  The first several of those will estimate
how close we can expect the
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
to get to the right result.  This is important, because it will then form the
basis for any performance thresholds we might create to know if
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v">our implementation</a>
works.  These results can also be used as an estimate of how well the
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
will perform for arbitrary input parameters.</p>

<p>Hence, after discussing both what
<a href="/dsp/2017/09/27/quantization.html">quantization</a>
and phase <a href="https://en.wikipedia.org/wiki/Variance">variance</a>
one might expect, we’ll turn our attention to building the actual <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>.</p>

<h2 id="theorem-rules">Theorem Rules</h2>

<p>A <a href="/dsp/2017/09/27/quantization.html">previous post</a> put
together a couple of probabilistic formulas and
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
rules.  Let’s just reiterate these for background here.</p>

<ol>
  <li>
    <p><a href="/dsp/2017/09/27/quantization.html">Quantization noise</a>
has a <a href="https://en.wikipedia.org/wiki/Variance">variance</a>
given by <code class="highlighter-rouge">1/12</code>th of a perfect <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">Analog to Digital Converter
(ADC)</a>’s step
size.</p>
  </li>
  <li>
    <p>The <a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of a <a href="https://en.wikipedia.org/wiki/Random_variable">random variable</a>
multiplied by a constant is given by the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a> of that
<a href="https://en.wikipedia.org/wiki/Random_variable">variable</a>
times the constant squared.</p>

    <table align="center" style="float: none"><tr><td><img src="/img/eqn-variance-scale.png" alt="Equation showing how scale affects variance" width="193" /></td></tr></table>

    <p>This applies to all
<a href="https://en.wikipedia.org/wiki/Random_variable">random variables</a>.</p>
  </li>
  <li>
    <p>We’ll assume that any
<a href="https://en.wikipedia.org/wiki/Random_variable">random variables</a>
we deal with are
<a href="https://en.wikipedia.org/wiki/Independence_(probability_theory)">independent</a>.</p>
  </li>
  <li>
    <p>The <a href="https://en.wikipedia.org/wiki/Variance">variance</a> of the sum of two
<a href="https://en.wikipedia.org/wiki/Random_variable">random variables</a> is given
by the sum of the
<a href="https://en.wikipedia.org/wiki/Variance">variances</a>:</p>

    <table align="center" style="float: none"><tr><td><img src="/img/eqn-variance-sum.png" alt="Equation showing the variance of the sum of two values" width="283" /></td></tr></table>

    <p>This follows from our assumption that the two
<a href="https://en.wikipedia.org/wiki/Random_variable">random variables</a>,
<code class="highlighter-rouge">X</code> and <code class="highlighter-rouge">Y</code>, are
<a href="https://en.wikipedia.org/wiki/Independence_(probability_theory)">independent</a>.</p>
  </li>
  <li>
    <p>The
<a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> of a
<a href="https://en.wikipedia.org/wiki/Random_variable">random variable</a>
is given by the square root of the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>.</p>

    <table align="center" style="float: none"><tr><td><img src="/img/eqn-defn-stdev.png" alt="Equation defining the standard deviation of a random variable" width="145" /></td></tr></table>
  </li>
</ol>

<p>These will form the basis of the error estimation work that follows.  Indeed,
we’ll use several of these properties at every step.</p>

<h2 id="from-core-generator-to-test-bench">From Core Generator to Test Bench</h2>

<p>One of the hassles of any test bench for a core generated algorithm is
communicating information from the core generator to other parts of the
design, such as the <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>.
The problem has a simple solution.</p>

<p>The approach we’ll take for dealing with this problem is to have the
<a href="https://github.com/ZipCPU/cordic/tree/master/sw/">core generator</a> generate
not only the <a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v">CORDIC</a>
code itself, but also a
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h">C header file</a>
describing the relevant choices that were made in the
<a href="https://github.com/ZipCPU/cordic/tree/master/sw/">core generator</a>.
The <a href="https://github.com/ZipCPU/cordic/tree/master/sw">core generator</a>
will create <a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h">this C header
file</a>
any time the command line parameter <code class="highlighter-rouge">-c</code> is given to it.</p>

<p>The basic information found within <a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h">this
file</a>
includes the bit widths of the input (<code class="highlighter-rouge">IW</code>), output (<code class="highlighter-rouge">OW</code>), and phase (<code class="highlighter-rouge">PW</code>).
It also includes the number of extra bits, <code class="highlighter-rouge">NEXTRA</code>,
used in the <a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
computations, as well as the number of
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
stages, <code class="highlighter-rouge">NSTAGES</code>.  Finally, this
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h">header file</a>
will contain information regarding whether or not the reset wire
or the <a href="/blog/2017/08/14/strategies-for-pipelining.html">traveling
CE</a>
wire (<code class="highlighter-rouge">aux</code>) were included within the design.</p>

<p>We’ll add to this basic information some probabilistic prediction information
we’ll develop below.</p>

<p>You can see an example of such a
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h">C header file</a>,
produced by our <a href="https://github.com/ZipCPU/cordic/blob/master/sw/basiccordic.cpp">core
generator</a>,
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h">here</a>.</p>

<h2 id="input-quantization">Input Quantization</h2>

<p>Now let’s start our run through the various errors or noise sources within the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a> algorithm.</p>

<p>The first noise source is the
<a href="/dsp/2017/09/27/quantization.html">quantization</a>
of the input samples.  We can assume that both <code class="highlighter-rouge">i_xval</code> and <code class="highlighter-rouge">i_yval</code> come with
an input <a href="/dsp/2017/09/27/quantization.html">quantization
variance</a>
of <code class="highlighter-rouge">1/12</code>th–as we <a href="/dsp/2017/09/27/quantization.html">discussed in our last
post</a>.  Likewise, the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a> of the phase is <code class="highlighter-rouge">1/12</code>th of
the lowest phase unit squared.</p>

<p>In our
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>,
though, our first step was to multiply these input values by a programmable
number of extra bits.  The number of these extra bits was used to create a
working width, <code class="highlighter-rouge">WW</code>, used below,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="c1">// WW is the number of XTRA bits plus the maximum of IW and OW
// These lines therefore add XTRA bits to our values
//
</span><span class="kt">wire</span>	<span class="kt">signed</span> <span class="p">[(</span><span class="n">WW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">e_xval</span><span class="o">,</span> <span class="n">e_yval</span><span class="o">;</span>
<span class="k">assign</span>	<span class="n">e_xval</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="n">i_xval</span><span class="p">[(</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">},</span> <span class="n">i_xval</span><span class="o">,</span> <span class="o">{</span><span class="p">(</span><span class="n">WW</span><span class="o">-</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span> <span class="o">};</span>
<span class="k">assign</span>	<span class="n">e_yval</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span><span class="n">i_yval</span><span class="p">[(</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">},</span> <span class="n">i_yval</span><span class="o">,</span> <span class="o">{</span><span class="p">(</span><span class="n">WW</span><span class="o">-</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span> <span class="o">};</span></code></pre></figure>

<p>To express this mathematically, we’ll let <code class="highlighter-rouge">x_i</code> and <code class="highlighter-rouge">y_i</code> represent the
inputs to the algorithm, and <code class="highlighter-rouge">x_0</code> and <code class="highlighter-rouge">y_0</code> represent the inputs to the first
rotation.  Since the precision of these values is not affected by the
pre-rotation step, no additional error is inserted there.  Hence, we have the
following representation for the inputs to our first rotation:</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-premul.png" alt="Eqn for the pre-multiplication step" width="281" /></td></tr></table>

<p>In this equation, <code class="highlighter-rouge">e_xi</code> and <code class="highlighter-rouge">e_yi</code> are any errors associated with the
inputs <code class="highlighter-rouge">x_i</code> and <code class="highlighter-rouge">y_i</code>.  Once the multiply has been accomplished, we’ll
express the output as a sum of both the desired output <code class="highlighter-rouge">x_0</code> and <code class="highlighter-rouge">y_0</code>,
together with the differences from perfection, <code class="highlighter-rouge">e_x0</code> and <code class="highlighter-rouge">e_y0</code>.  These latter
two <a href="https://en.wikipedia.org/wiki/Random_variable">random values</a>
are the errors in our precision following this step.</p>

<p>Using our <a href="https://en.wikipedia.org/wiki/Variance">variance</a>
rule for multiplying an input by a constant, the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of these two error terms, <code class="highlighter-rouge">e_x0</code> and <code class="highlighter-rouge">e_y0</code>, is then given by,</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-premul-variance.png" alt="Variance adjustment from the pre-multiplication step" width="212" /></td></tr></table>

<p>This is the then <a href="https://en.wikipedia.org/wiki/Variance">variance</a>
at the input to our <a href="/dsp/2017/08/30/cordic.html">CORDIC rotation
stages</a>.`
From here we’ll move to the rotation steps themselves.</p>

<h2 id="internal-truncation-error">Internal Truncation Error</h2>

<p>The next source of error within our <a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v">CORDIC
implementation</a>
may be found within the
<a href="/dsp/2017/08/30/cordic.html">CORDIC rotation stages</a>
themselves.</p>

<p>As you may recall, each
<a href="/dsp/2017/08/30/cordic.html">CORDIC stage</a>
rotates the previous <code class="highlighter-rouge">x,y</code> values using a transform matrix using the equations:</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-eqns-pm.png" alt="Cordic equations" width="350" /></td></tr></table>

<p>There was also a corollary transform for when we wished to rotate in the
other direction.  To represent both, we used the plus-or-minus
character above.  Further, the minus-or-plus character above captures the fact
that two separate signs need to change together, but that they need to be
opposites of each other.</p>

<p>However, while this was the rotation equation
<a href="/dsp/2017/08/30/cordic.html">we presented</a>,
it wasn’t quite what our
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v">code</a>
accomplished within our
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v">implementation</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="n">PW</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span> <span class="c1">// Negative phase
</span><span class="k">begin</span>
	<span class="c1">// If the phase is negative, rotate by the
</span>	<span class="c1">// CORDIC angle in a clockwise direction.
</span>	<span class="n">xv</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">yv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">;</span>
	<span class="n">yv</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">yv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">xv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">;</span>
	<span class="n">ph</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">cordic_angle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
	<span class="c1">// On the other hand, if the phase is
</span>	<span class="c1">// positive ... rotate in the
</span>	<span class="c1">// counter-clockwise direction
</span>	<span class="n">xv</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">yv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">;</span>
	<span class="n">yv</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">yv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">xv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">;</span>
	<span class="n">ph</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">cordic_angle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">;</span>
<span class="k">end</span></code></pre></figure>

<p>Within our
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v">implementation</a>,
we truncated the values of <code class="highlighter-rouge">x_k</code> and
<code class="highlighter-rouge">y_k</code> after shifting them to the right.  This is equivalent to adding
<a href="https://en.wikipedia.org/wiki/Random_variable">random variable</a>s,
<code class="highlighter-rouge">d_xk</code> and <code class="highlighter-rouge">d_yk</code> to each of the <code class="highlighter-rouge">x_{k+1}</code> and <code class="highlighter-rouge">y_{k+1}</code>
values in addition to the error terms brought to this stage from the prior
stage.  We can separate the desired result, <code class="highlighter-rouge">x_(k+1)</code> and <code class="highlighter-rouge">y_(k+1)</code> from the
accumulated errors in the result, <code class="highlighter-rouge">e_x(k+1)</code> and <code class="highlighter-rouge">e_y(k+1)</code> and re-represent
this as,</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-stage-w-err-terms.png" alt="Cordic equations with noise" width="617" /></td></tr></table>

<p>Using our addition of
<a href="https://en.wikipedia.org/wiki/Variance">variances</a>
rule, together with the scale rule, we can calculate a
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
for the error term at the end of this stage.</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-stage-variance.png" alt="V[e_x] = (1+2^(-2k))*v[e_k]+V[d_k]" width="393" /></td></tr></table>

<p>At this point, we know <code class="highlighter-rouge">V[e_k]</code> from the previous stage, and with the
exception of <code class="highlighter-rouge">V[d_k]</code> we can calculate <code class="highlighter-rouge">V[e_(k+1)]</code> for the next stage.
But … what is <code class="highlighter-rouge">V[d_k]</code>?</p>

<p>Unlike the
<a href="/dsp/2017/09/27/quantization.html">quantization</a>
error we calculated earlier, truncation error is neither zero
<a href="https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution">mean</a>
nor does it have a <code class="highlighter-rouge">1/12</code>
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>.
However, if we assume that the choice of direction is made randomly,
with a probability of one half for each rotation direction, then the truncation
error becomes zero
<a href="https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution">mean</a>.
(Half the time the
<a href="https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution">mean</a>
is negative by one half, half the time it is positive by one half, etc.)
The <a href="https://en.wikipedia.org/wiki/Variance">variance</a>,
though, is given by <code class="highlighter-rouge">1/3</code> since we need to integrate from
<code class="highlighter-rouge">0</code> to <code class="highlighter-rouge">1</code> instead of from <code class="highlighter-rouge">-1/2</code> to <code class="highlighter-rouge">1/2</code>:</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-truncation-variance.png" alt="Truncation Variance = 1/3" width="341" /></td></tr></table>

<p>Well, okay, that’s close but not quite right.  In reality, the truncation
error associated with truncating an already
<a href="/dsp/2017/09/27/quantization.html">quantizated</a>
number requires an analysis of a <a href="https://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution">discrete probability
distribution</a>.
If we suppose that a finite number of bits, <code class="highlighter-rouge">k</code>, are dropped in the
truncation then the variance is not <code class="highlighter-rouge">1/3</code>rd but</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-discrete-truncation-variance.png" alt="Discrete truncation variance only approximates 1/3" width="380" /></td></tr></table>

<p>The proof of this doesn’t fit on a single line, however, so we’ll leave the
details as an exercise for the student.</p>

<p>After the
<a href="/dsp/2017/08/30/cordic.html">CORDIC rotation stages</a>,
we rounded the result and produced an ouput.  That step, therefore, is next.</p>

<h2 id="output-variance">Output Variance</h2>

<p>The last step in calculating the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>’s
output, is to adjust the resulting output
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
due to the last rounding step:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">assign</span>	<span class="n">pre_xval</span> <span class="o">=</span> <span class="n">xv</span><span class="p">[</span><span class="n">NSTAGES</span><span class="p">]</span> <span class="o">+</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}},</span>
			<span class="n">xv</span><span class="p">[</span><span class="n">NSTAGES</span><span class="p">][(</span><span class="n">WW</span><span class="o">-</span><span class="n">OW</span><span class="p">)]</span><span class="o">,</span>
			<span class="o">{</span><span class="p">(</span><span class="n">WW</span><span class="o">-</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{!</span><span class="n">xv</span><span class="p">[</span><span class="n">NSTAGES</span><span class="p">][</span><span class="n">WW</span><span class="o">-</span><span class="n">OW</span><span class="p">]</span><span class="o">}}};</span>
<span class="k">assign</span>	<span class="n">pre_yval</span> <span class="o">=</span> <span class="n">yv</span><span class="p">[</span><span class="n">NSTAGES</span><span class="p">]</span> <span class="o">+</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}},</span>
			<span class="n">yv</span><span class="p">[</span><span class="n">NSTAGES</span><span class="p">][(</span><span class="n">WW</span><span class="o">-</span><span class="n">OW</span><span class="p">)]</span><span class="o">,</span>
			<span class="o">{</span><span class="p">(</span><span class="n">WW</span><span class="o">-</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{!</span><span class="n">yv</span><span class="p">[</span><span class="n">NSTAGES</span><span class="p">][</span><span class="n">WW</span><span class="o">-</span><span class="n">OW</span><span class="p">]</span><span class="o">}}};</span>

<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">o_xval</span> <span class="o">&lt;=</span> <span class="n">pre_xval</span><span class="p">[(</span><span class="n">WW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">WW</span><span class="o">-</span><span class="n">OW</span><span class="p">)]</span><span class="o">;</span>
	<span class="n">o_yval</span> <span class="o">&lt;=</span> <span class="n">pre_yval</span><span class="p">[(</span><span class="n">WW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">WW</span><span class="o">-</span><span class="n">OW</span><span class="p">)]</span><span class="o">;</span>
	<span class="n">o_aux</span> <span class="o">&lt;=</span> <span class="n">ax</span><span class="p">[</span><span class="n">NSTAGES</span><span class="p">]</span><span class="o">;</span>
<span class="k">end</span></code></pre></figure>

<p>As you may recall, <code class="highlighter-rouge">WW</code> was the working width we were using for the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
transform stages, and <code class="highlighter-rouge">OW</code> is the output width.  If <code class="highlighter-rouge">WW</code> is greater than <code class="highlighter-rouge">OW</code>,
then this stage drops bits and rounds the result.  This rounding step also
adds some more
<a href="/dsp/2017/09/27/quantization.html">quantization</a>
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>.</p>

<p>Mathematically, we might write what is taking place with,</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-final-transform-step.png" alt="The final CORDIC rounding step" width="360" /></td></tr></table>

<p>At this point, we know the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of just about all of the components.
<code class="highlighter-rouge">x_k</code> and <code class="highlighter-rouge">y_k</code> are fixed values (not random), so their
<a href="https://en.wikipedia.org/wiki/Variance">variance</a> is zero.
The <a href="https://en.wikipedia.org/wiki/Variance">variance</a>
<code class="highlighter-rouge">e_xk</code> and <code class="highlighter-rouge">e_yk</code> were both calculated in the last step.
Using our
<a href="/dsp/2017/09/27/quantization.html">scale and addition rules</a>,
we can express the final
<a href="https://en.wikipedia.org/wiki/Variance">variance</a> as,</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-final-transform-variance.png" alt="The final CORDIC transform variance" width="361" /></td></tr></table>

<p>The <a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of <code class="highlighter-rouge">d_xo</code> is the only thing left to discuss.  This is the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
associated with our rounding step.  If we treat the value as continuous, then
the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of <code class="highlighter-rouge">d_xo</code> would be <code class="highlighter-rouge">1/12</code>th.  This isn’t quite the case, since
<code class="highlighter-rouge">d_xo</code> is quantized, but it makes a decent approximation.  (The actual number
starts at <code class="highlighter-rouge">1/8</code> for dropping one bit, and asymptotes at <code class="highlighter-rouge">1/12</code> for dropping
an infinite number of bits.)</p>

<p>We can now use this value to calculate the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
both at the end of each
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
stage, as well as at the end of the entire algorithm.
We’ll place the code to calculate this value within our generic
<a href="https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp">CORDIC library</a>:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">double</span>	<span class="nf">transform_quantization_variance</span><span class="p">(</span><span class="kt">int</span> <span class="n">nstages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xtrabits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dropped_bits</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">double</span>	<span class="n">current_variance</span><span class="p">;</span>

	<span class="n">current_variance</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">xtrabits</span><span class="p">)</span><span class="o">/</span><span class="mf">12.</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nstages</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">current_variance</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">pow</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">current_variance</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">;</span>

	<span class="c1">// If we drop bits from this on the output, then we add more variance
</span>	<span class="c1">// in the process.  This is rounding variance, so the variance is
</span>	<span class="c1">// (roughly) 1/12th.
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">dropped_bits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">current_variance</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">dropped_bits</span><span class="p">)</span><span class="o">*</span><span class="n">current_variance</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mf">12.</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">current_variance</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The result of this calculation will be passed to the <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
by passing a <code class="highlighter-rouge">QUANTIZATION_VARIANCE</code> value to the <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
within our core-generated
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h">header file</a>:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">double</span>	<span class="n">QUANTIZATION_VARIANCE</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">actual</span> <span class="n">value</span> <span class="n">goes</span> <span class="n">here</span><span class="o">&gt;</span><span class="p">;</span> <span class="o">//</span> <span class="p">(</span><span class="n">Units</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span></code></pre></figure>

<p>This will then inform our <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test bench
code</a>
the average sum of square errors that it can expect.</p>

<p>At this point, we’re almost done with our pre-work.  We have only one step
left, and that is looking into any
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
associated with the phase accumulator.</p>

<h2 id="phase-error">Phase Error</h2>

<p>There’s one last component to the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of our result, and that’s the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
associated with the phase accumulator.  You may recall that, at each
stage of our
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>, we added
or subtracted an amount of phase to a phase accumulator.  We calculated
these phase values within
<a href="https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp">cordiclib.cpp</a>
and placed these values into the <code class="highlighter-rouge">cordic_angle</code> array within our <a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v">generated
routine</a>.</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-phase.png" alt="theta_k = atan(2^{-k})" width="168" /></td></tr></table>

<p>The problem with this array is that the phase values had to be
<a href="/dsp/2017/09/27/quantization.html">quantized</a>
in order to be placed into this integer array.  This quantization can be
found within our
<a href="https://github.com/ZipCPU/cordic/blob/master/sw/cordiclib.cpp">CORDIC library</a>:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>	<span class="nf">cordic_angles</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nstages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phase_bits</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// ...
</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">nstages</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">double</span>		<span class="n">x</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">phase_value</span><span class="p">;</span>

		<span class="n">x</span> <span class="o">=</span> <span class="n">atan2</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
		<span class="c1">// ...
</span>		<span class="c1">// Convert this value from radians to our integer phase units
</span>		<span class="n">x</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1ul</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">phase_bits</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span> <span class="o">/</span> <span class="p">(</span><span class="n">M_PI</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">);</span>

		<span class="c1">// Here's where we truncate our phase from a double to an
</span>		<span class="c1">// integer.
</span>		<span class="n">phase_value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
		<span class="c1">// ...
</span>	<span class="p">}</span>
	<span class="c1">// ...
</span><span class="p">}</span></code></pre></figure>

<p>This means that though we intended to rotate by one angle,
we ended up rotating by an approximation of that angle.  If we let
<code class="highlighter-rouge">gamma</code> reference the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
gain, <code class="highlighter-rouge">R(theta)</code> represent the rotation we
wanted to accomplish, and <code class="highlighter-rouge">e_ox</code> and <code class="highlighter-rouge">e_oy</code> be the algorithm errors we’ve
been discussing so far, then our result should be:</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-desired.png" alt="[X,Y] = gR(theta)+errs" width="337" /></td></tr></table>

<p>The problem with this representation is that it doesn’t acknowledge any of these
phase errors.  In other words, because we’ve only <em>approximated</em> the
phase errors with integers, we ended up rotating by a different phase–one
that was <em>close</em> to what we wanted to rotate by:</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-err-rotation.png" alt="[X,Y] = gR(theta+eta)+errs" width="375" /></td></tr></table>

<p>If we separate the rotation into two rotations, one by the rotation we want,
<code class="highlighter-rouge">R(theta)</code>, and the other by the rotation we didn’t want, <code class="highlighter-rouge">R(eta)</code>, we can
rewrite this as:</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-rotation-separated.png" alt="[X,Y] = gR(theta)R(eta)+errs" width="544" /></td></tr></table>

<p>Finally, if we use a small angle approximation for <code class="highlighter-rouge">eta</code>, then this can be
rewritten as something a touch more useful:</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-rotation-variance.png" alt="EQN approximating eta with a small angle formula" width="446" /></td></tr></table>

<p>At this point, our results are separated between the results we want, together
with an additive “noise” term that we didn’t want.  From here, then, we can use
our <a href="/dsp/2017/09/27/quantization.html">scale and addition
rules</a>
to determine the <a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of the result.  This is given by first the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
we worked out in the last session, <code class="highlighter-rouge">V[e_o]</code>, as well as a new term
associated with the rotation error.  This new term consists of a couple
of scalar values, both the known
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
gain, <code class="highlighter-rouge">gamma</code> and the outputs of our algorithm, <code class="highlighter-rouge">x_k</code> and <code class="highlighter-rouge">y_k</code>.  It also
consists of the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of our random phase variable, <code class="highlighter-rouge">eta</code>.</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-cordic-rotation-err-variance.png" alt="V[ghx+ey]=g^2x^2V[h]+V[ey]" width="363" /></td></tr></table>

<p>That’s how random phase errors are going to affect our output.</p>

<p>But, what is this last phase
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>, <code class="highlighter-rouge">V[eta]</code>?</p>

<p>To understand that, let’s go back and look through the logic for the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
stages again.  At each stage, we approximated a phase with an integer
(quantized) value.  Unlike before, where the difference between the true value
and the quantized value was unknown,
in this case we know the difference between the original phase
value and its truncated representation.  Hence, with a probability of one
half that this difference should be positive, and one half that it is
negative, we can calculate the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
of the accumulated phase.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">double</span>	<span class="nf">phase_variance</span><span class="p">(</span><span class="kt">int</span> <span class="n">nstages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phase_bits</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">double</span>	<span class="n">RAD_TO_PHASE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">phase_bits</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="o">/</span> <span class="n">M_PI</span><span class="p">;</span>
	<span class="kt">double</span>	<span class="n">variance</span><span class="p">;</span>

	<span class="c1">// Start with an initial quantization variance, before we do anything
</span>	<span class="n">variance</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">12.</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">nstages</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">double</span>		<span class="n">x</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">phase_value</span><span class="p">;</span>

		<span class="n">x</span> <span class="o">=</span> <span class="n">atan2</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">RAD_TO_PHASE</span><span class="p">;</span>
		<span class="n">phase_value</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
		<span class="c1">// Calculate the error between the phase we want, and our
</span>		<span class="c1">// integer phase representation
</span>		<span class="n">err</span> <span class="o">=</span> <span class="n">phase_value</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
		<span class="c1">// Square it to turn it into a variance.
</span>		<span class="n">err</span> <span class="o">*=</span> <span class="n">err</span><span class="p">;</span>
		<span class="c1">// Accumulate it with the rest of the variance(s)
</span>		<span class="c1">// from the cordic angles
</span>		<span class="n">variance</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Convert the calculated variance back to radians
</span>	<span class="n">variance</span> <span class="o">/=</span> <span class="n">pow</span><span class="p">(</span><span class="n">RAD_TO_PHASE</span><span class="p">,</span><span class="mf">2.</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">variance</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>We’ll calculate and place this rotation phase error into its own value
within our core-generated
<a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.h">C header file</a>:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">double</span>	<span class="n">PHASE_VARIANCE_RAD</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">actual</span> <span class="n">value</span> <span class="n">goes</span> <span class="n">here</span><span class="o">&gt;</span><span class="p">;</span> <span class="o">//</span> <span class="p">(</span><span class="n">Radians</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span></code></pre></figure>

<p>So, at this point we’ve worked out the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
associated with our
<a href="/dsp/2017/08/30/cordic.html">CORDIC rotation</a>s,
and now we’ve worked out the
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
associated with truncated our phase accumulator values.  With these values, we
can now begin to put our <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
together.</p>

<h2 id="building-the-test-bench">Building the Test Bench</h2>

<p>This has taken a lot of background, but it’s now time to build our <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>.
Our test bench will be based around the idea of rotating a fixed, maximal
valued, input through all of the possible phase rotations.</p>

<p>To start, we’ll define some helper values, both the log (based two) of the
number of test samples as well as the number of test samples, that the
rest of our code here can reference.  Since we’re going to go through one
wavelength of a sine wave, these are determined by the phase width parameter,
<code class="highlighter-rouge">PW</code>.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span>	<span class="n">LGNSAMPLES</span><span class="o">=</span><span class="n">PW</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span>	<span class="n">NSAMPLES</span><span class="o">=</span><span class="p">(</span><span class="mi">1ul</span><span class="o">&lt;&lt;</span><span class="n">LGNSAMPLES</span><span class="p">);</span></code></pre></figure>

<p>We’ll also set our sine wave’s amplitude to the maximum value that will not
overflow,</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_xval</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1ul</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_yval</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>This value will be necessary to maximize our
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">Carrier-to-noise ratio</a>
in the face of a fixed amount of background noise.</p>

<p>With this as background, we can create <code class="highlighter-rouge">NSAMPLES</code> test cases, pushing the
inputs into our
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>’s
<a href="https://github.com/ZipCPU/cordic/blob/master/rt/cordic.v">HDL routine</a>.
The difference from one test to the next will be the phase rotation.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NSAMPLES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">PW</span><span class="o">-</span><span class="p">(</span><span class="n">LGNSAMPLES</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span>	<span class="n">sv</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1ul</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">)))</span>
				<span class="c1">// Odd value, round down
</span>				<span class="n">sv</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1ul</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">sv</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1ul</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_phase</span> <span class="o">=</span> <span class="n">sv</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_phase</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">;</span>
		<span class="n">pdata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_phase</span><span class="p">;</span>
		<span class="n">ixval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_xval</span><span class="p">;</span>
		<span class="n">iyval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_yval</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_aux</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tick</span><span class="p">();</span>

		<span class="o">//</span> <span class="p">...</span></code></pre></figure>

<p>We’re also going to insist that this algorithm uses the <a href="/blog/2017/08/14/strategies-for-pipelining.html">travelling
CE</a>
form of pipeline management.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="n">assert</span><span class="p">(</span><span class="n">HAS_AUX</span><span class="p">);</span></code></pre></figure>

<p>This means that we set <code class="highlighter-rouge">i_aux</code> on any input
with a valid value, and anytime <code class="highlighter-rouge">o_aux</code> is true on the output we’ll have a
valid output value.  So that we can work on all these values at the same
time, we’ll place the output values into an array as they become valid.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_aux</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">OW</span><span class="p">);</span>
			<span class="c1">// Make our values signed..
</span>			<span class="n">xval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_xval</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">shift</span><span class="p">);</span>
			<span class="n">yval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_yval</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">shift</span><span class="p">);</span>
			<span class="n">xval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
			<span class="n">yval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
			<span class="c1">// printf("%08x&lt;&lt;%d: %08x %08x\n", (unsigned)pdata[i], shift, xval[idx], yval[idx]);
</span>			<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span></code></pre></figure>

<p>You may notice how <code class="highlighter-rouge">idx</code> is used to separate the actual loop variable, <code class="highlighter-rouge">i</code>,
from the array index associated with the return values.  This allows us to
compensate for whatever delay the algorithm might have.</p>

<p>Since the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
takes a couple clocks to process its results, our last output will likely
not be available to us as soon as we provide our last input.  Hence, we’ll need
to flush these last results out.  To do this, we set the input <a href="/blog/2017/08/14/strategies-for-pipelining.html">traveling
CE</a>
bit, <code class="highlighter-rouge">i_aux</code>, to zero and wait till the output CE bit, <code class="highlighter-rouge">o_aux</code> goes to zero
as well.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_aux</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_aux</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="n">OW</span><span class="p">);</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_aux</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tick</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_aux</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">xval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_xval</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">shift</span><span class="p">);</span>
			<span class="n">yval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_yval</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">shift</span><span class="p">);</span>
			<span class="n">xval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
			<span class="n">yval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="n">shift</span><span class="p">;</span>
			<span class="c1">// printf("%08x %08x\n", xval[idx], yval[idx]);
</span>			<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">NSAMPLES</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span></code></pre></figure>

<p>Finally, let’s pull all these results together and examine them.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="kt">double</span>	<span class="n">mxerr</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">averr</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">mag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sumxy</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
		<span class="n">sumsq</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sumd</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NSAMPLES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>	<span class="n">shift</span><span class="p">;</span>
		<span class="kt">double</span>	<span class="n">ph</span><span class="p">,</span> <span class="n">dxval</span><span class="p">,</span> <span class="n">dyval</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

		<span class="o">//</span> <span class="p">...</span></code></pre></figure>

<p>The first step in evaluating these results is going to be determine the
answers that the <a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
algorithm was <em>supposed</em> to produce.  In other words,
what angle was given to it, what rectangular coordinates were given to it,
and therefore what values, <code class="highlighter-rouge">dxval</code> and <code class="highlighter-rouge">dyval</code>, <em>should’ve</em> been returned.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">		<span class="n">ph</span> <span class="o">=</span> <span class="n">pdata</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">ph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">*</span> <span class="n">M_PI</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="mi">1u</span><span class="o">&lt;&lt;</span><span class="n">PW</span><span class="p">);</span>
		<span class="n">dxval</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span> <span class="o">*</span> <span class="n">ixval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span> <span class="o">*</span> <span class="n">iyval</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">dyval</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span> <span class="o">*</span> <span class="n">ixval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span> <span class="o">*</span> <span class="n">iyval</span><span class="p">[</span><span class="n">i</span><span class="p">];</span></code></pre></figure>

<p>The <a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
applied a gain to our inputs, as we
<a href="/dsp/2017/08/30/cordic.html">discussed earlier</a>.
Hence, the output is not just the rotated input, but that rotated result needs
to be multiplied by the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
gain before we can tell if it was done right or not.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">		<span class="n">dxval</span> <span class="o">*=</span> <span class="n">GAIN</span><span class="p">;</span>
		<span class="n">dyval</span> <span class="o">*=</span> <span class="n">GAIN</span><span class="p">;</span></code></pre></figure>

<p>As a last step in trying to figure out what our answer <em>should</em> be, we’ll need
to compensate our <em>perfect</em> answer for any change in word width.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">		<span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">IW</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">OW</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IW</span> <span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">OW</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dxval</span> <span class="o">*=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="mi">1u</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">);</span>
			<span class="n">dyval</span> <span class="o">*=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="mi">1u</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">OW</span> <span class="o">&gt;</span> <span class="n">IW</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dxval</span> <span class="o">*=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="mi">1u</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">));</span>
			<span class="n">dyval</span> <span class="o">*=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="mi">1u</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">));</span>
		<span class="p">}</span></code></pre></figure>

<p>Now that we know the value we wanted the
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
to produce,
let’s compare it to the value that was produced.  We’ll estimate the
squared differences between what we think the algorithm should produce
and what it actually produced in the variable, <code class="highlighter-rouge">err</code>.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">		<span class="c1">// The error between the value requested and the value resulting
</span>		<span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">dxval</span> <span class="o">-</span> <span class="n">xval</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">dxval</span> <span class="o">-</span> <span class="n">xval</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">err</span><span class="o">+=</span> <span class="p">(</span><span class="n">dyval</span> <span class="o">-</span> <span class="n">yval</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">dyval</span> <span class="o">-</span> <span class="n">yval</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span></code></pre></figure>

<p>We can even calculate an average of this squared error, by accumulating these
square values into <code class="highlighter-rouge">averr</code>.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">		<span class="n">averr</span> <span class="o">+=</span> <span class="n">err</span><span class="p">;</span></code></pre></figure>

<p>As a final value to examine, let’s keep track of the maximum difference
between our expected and returned values.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">		<span class="n">err</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="n">mxerr</span><span class="p">)</span>
			<span class="n">mxerr</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>To turn the sum of the squared errors into an estimated
<a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>,
we’ll need to divide by the number of samples and take the square root of the
result.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="n">averr</span> <span class="o">/=</span> <span class="p">(</span><span class="n">NSAMPLES</span><span class="p">);</span>
	<span class="n">averr</span>  <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">averr</span><span class="p">);</span></code></pre></figure>

<p>We can check whether or not this average squared error is within bounds, and
fail if not.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="k">if</span> <span class="p">(</span><span class="n">averr</span> <span class="o">&gt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">QUANTIZATION_VARIANCE</span><span class="p">))</span>
		<span class="n">failed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span></code></pre></figure>

<p>The <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)">magic number</a>
in this comparison, <code class="highlighter-rouge">1.5</code>, is simply a heuristic that has worked for me so far.
While a threshold could be calculated from a proper <a href="https://en.wikipedia.org/wiki/Statistical_hypothesis_testing">statistical hypothesis
test</a> basis, this
number has worked well enough for me.</p>

<p>In a similar fashion, the maximum error should lie within a fixed number
of <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>s
from zero.  The
<a href="https://en.wikipedia.org/wiki/Magic_number_(programming)">magic number</a>
<code class="highlighter-rouge">5.2</code> below is a heuristic, though, since we haven’t done the proper
statistical analysis to make this exact.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="k">if</span> <span class="p">(</span><span class="n">mxerr</span> <span class="o">&gt;</span> <span class="mf">5.2</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">expected_err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"ERR: Maximum error is out of bounds</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">failed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span></code></pre></figure>

<p>Perhaps a more useful result is the
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">Carrier-to-noise ratio</a>
that can be achieved.  This should be given by the energy in the sine wave
input, times the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
gain, squared and then divided by the estimated
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>.  Since we already have the
sine wave magnitude times the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
gain captured by our <code class="highlighter-rouge">scale</code> variable, we can just square this to get our
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
carrier energy.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="n">scale</span> <span class="o">*=</span> <span class="n">GAIN</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"CNR    : %.2f dB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mf">10.0</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">scale</span>
			<span class="o">/</span> <span class="p">(</span><span class="n">averr</span> <span class="o">*</span> <span class="n">averr</span><span class="p">))</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mf">10.0</span><span class="p">));</span></code></pre></figure>

<p>As a last test of whether or not this
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
works, let’s check out the <a href="https://en.wikipedia.org/wiki/Spurious-free_dynamic_range">Spurious Free Dynamic Range
(SFDR)</a>.</p>

<p>We’ll use the
<a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">FFT</a>
of the core’s output to find the maximum spur energy for our
<a href="https://en.wikipedia.org/wiki/Spurious-free_dynamic_range">SFDR</a>
estimate.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">	<span class="k">if</span> <span class="p">((</span><span class="n">PW</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">NSAMPLES</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="n">PW</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">typedef</span>	<span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>	<span class="n">COMPLEX</span><span class="p">;</span>
		<span class="n">COMPLEX</span>	<span class="o">*</span><span class="n">outpt</span><span class="p">;</span>
		<span class="k">const</span>	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">FFTLEN</span><span class="o">=</span><span class="p">(</span><span class="mi">1ul</span><span class="o">&lt;&lt;</span><span class="n">PW</span><span class="p">);</span>

		<span class="n">outpt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">COMPLEX</span><span class="p">[</span><span class="n">FFTLEN</span><span class="p">];</span>

		<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">FFTLEN</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">outpt</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">real</span><span class="p">()</span> <span class="o">=</span> <span class="n">xval</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
			<span class="n">outpt</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">imag</span><span class="p">()</span> <span class="o">=</span> <span class="n">yval</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="c1">// Now we need to do an FFT
</span>		<span class="n">cfft</span><span class="p">((</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span><span class="n">outpt</span><span class="p">,</span> <span class="n">FFTLEN</span><span class="p">);</span></code></pre></figure>

<p>We’ll then use the energy in the
<a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">FFT</a>
output bin related to our signal for our signal’s energy, while using the
maximum output bin energy across the rest of the
<a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform">FFT</a>
for the maximum spur energy.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">		<span class="kt">double</span>	<span class="n">master</span><span class="p">,</span> <span class="n">spur</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="c1">// Master is the energy in the signal of interest
</span>		<span class="n">master</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">outpt</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="c1">// SPUR is the energy in any other FFT bin output
</span>		<span class="n">spur</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">outpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">FFTLEN</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">outpt</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">spur</span><span class="p">)</span>
				<span class="n">spur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="p">}</span></code></pre></figure>

<p>The ratio of these two values is the
<a href="https://en.wikipedia.org/wiki/Spurious-free_dynamic_range">SFDR</a>,
another indication of the quality of how well this algorithm works.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">		<span class="n">printf</span><span class="p">(</span><span class="s">"SPFR = %7.2f dBc</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			<span class="mi">10</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">master</span> <span class="o">/</span> <span class="n">spur</span><span class="p">)</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">));</span></code></pre></figure>

<p>Unlike the average error, though, which we could calculate from the
<a href="https://en.wikipedia.org/wiki/Expected_value">expected</a>
<a href="https://en.wikipedia.org/wiki/Variance">variance</a>
above, predicting the
<a href="https://en.wikipedia.org/wiki/Spurious-free_dynamic_range">SFDR</a>
isn’t as simple.  Therefore, we’ll only calculate it as part of our <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
and leave you to decide whether it is good enough.</p>

<h2 id="performance-numbers">Performance Numbers</h2>

<p>We can now measure both <em>if</em> our
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a> works,
as well as how well it works.</p>

<p>So … how well <em>does</em> it work?</p>

<p>Just to find out, I ran the
<a href="/dsp/2017/08/30/cordic.html">CORDIC</a>
<a href="https://github.com/ZipCPU/cordic/tree/master/sw/">core generator software</a>,
and tested the
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
for a variety of bit widths and phase bit widths.  Shown below, in Table 1,
are the <a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">Carrier-to-noise ratio
(CNR)</a> and <a href="https://en.wikipedia.org/wiki/Spurious-free_dynamic_range">Spurious Free
Dynamic Range</a>
measurements the <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
recorded.</p>

<table align="center" border=""><tr><th>IW, OW Bits</th><th>Phase bits</th><th>Xtra Bits</th><th>CNR</th><th>SFDR</th></tr>
<tr><td> 8</td><td>13</td><td>1</td><td>42</td><td>43</td></tr>
<tr><td> 8</td><td>14</td><td>2</td><td>46</td><td>57</td></tr>
<tr><td> 8</td><td>15</td><td>3</td><td>49</td><td>62</td></tr>
<tr><td> 8</td><td>16</td><td>4</td><td>50</td><td>64</td></tr>
<tr><td>12</td><td>17</td><td>1</td><td>65</td><td>69</td></tr>
<tr><td>12</td><td>18</td><td>2</td><td>69</td><td>82</td></tr>
<tr><td>12</td><td>19</td><td>3</td><td>73</td><td>88</td></tr>
<tr><td>12</td><td>20</td><td>4</td><td>74</td><td>94</td></tr>
<tr><td>16</td><td>21</td><td>1</td><td>87</td><td>92</td></tr>
<tr><td>16</td><td>22</td><td>2</td><td>92</td><td>106</td></tr>
<tr><td>16</td><td>23</td><td>3</td><td>96</td><td>112</td></tr>
<tr><td>16</td><td>24</td><td>4</td><td>98</td><td>117</td></tr>
<tr><td>24</td><td>29</td><td>1</td><td>(136)</td><td>N/A</td></tr>
<tr><td>24</td><td>30</td><td>2</td><td>(140)</td><td>N/A</td></tr>
<tr><td>24</td><td>31</td><td>3</td><td>(144)</td><td>N/A</td></tr>
<tr><td>24</td><td>32</td><td>4</td><td>(146)</td><td>N/A</td></tr>
<caption>Table 1: Test-bench test results (simulation)</caption></table>

<p>As you can see from the table, the
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>’s
performance improves, for a given bit width, as the number of extra
internal bits increases until these get to about four.  At this point,
the improvement settles out, and little further gain can be had.</p>

<p>One common estimate of <a href="https://en.wikipedia.org/wiki/Quantization_(signal_processing)">quantization noise is that you can achieve 6-dB of
performance per bit of sample
width</a>.
By this measure, we might expect a 48 dB
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">CNR</a>
for an 8-bit output, a 72 dB
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">CNR</a>
for a 12-bit output, 96 dB
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">CNR</a>
for a 16-bit output, and 144 dB
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">CNR</a>
for a 24-bit output.  Our measured results are roughly consistent
with this rule, so they appear to be reasonably accurate.</p>

<p>Likewise the
<a href="https://en.wikipedia.org/wiki/Spurious-free_dynamic_range">SFDR</a>
measurements showed a clear increase in performance as the bit
widths involved increased.</p>

<p>Digging further, the predicted
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">CNR</a> values matched
the <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
measured values within a <a href="https://en.wikipedia.org/wiki/Decibel">dB</a> or two.</p>

<p>The <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>,
however, failed when it got to the larger phase widths: 29 and above.  In
particular, the test bench failed for all of the phase widths appropriate for
the 24-bit samples.  The error given, that of a memory allocation error,
illustrates a weakness in a test methodology that works by first recording all
of the answers into memory and then processes those results.</p>

<p>Because the <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
failed for the 24-bit case, the <em>expected</em>
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">CNR</a>
values are shown (in parentheses) rather than any <em>measured</em>
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">CNR</a> values.
Since these expected values were consistent with the predicted
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">CNR</a> values for
the rest of the test (comparison not shown), they are at least an indication
of what one might expect when using this routine for larger bit-widths.</p>

<h2 id="conclusion">Conclusion</h2>

<p>It’s taken us a lot of work to get to this point, where we can estimate the
<a href="https://en.wikipedia.org/wiki/Carrier-to-noise_ratio">CNR</a> performance that a
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a>
will achieve, and then verify that it has that performance.  Indeed, the math
wasn’t pretty, and I’d be surprised if a large number of folks made it this
far.</p>

<p>Please accept my apologies.  I would like to keep this blog as simple as the
RTL code I’m sharing, and this was not that simple.</p>

<p>The problem that lead us to this point, though, is simple: how do you know
when an algorithm’s results are “good enough.”  It was this particular
question that sent us this deep into the (hard-to-follow) mathematics above and
in our <a href="/dsp/2017/09/27/quantization.html">prior post</a>.</p>

<p>Further, despite the complexity of this development today, we still didn’t
solve <em>all</em> of the mathematical problems associated with a <a href="https://github.com/ZipCPU/cordic/blob/master/bench/cpp/cordic_tb.cpp">test
bench</a>
of this type.  In particular, we didn’t apply any proper statistical
bases to the <a href="https://en.wikipedia.org/wiki/Statistical_hypothesis_testing">hypothesis
test</a>s within
our test bench.  As a result, we cannot be certain that this <a href="https://github.com/ZipCPU/cordic/blob/master/rtl/cordic.v">CORDIC
implementation</a>
is as good as it can be.</p>

<p>Still, this should be <em>good enough</em> to move forward.</p>

<p>Using these results, we now have some confidence that not only does the
<a href="/dsp/2017/08/30/cordic.html">CORDIC algorithm</a> work,
but we also have the confidence that given the right parameters it will work
well enough for our purposes.</p>

<p>What purposes might that be?  That question, my friend, we’ll have to answer
in another post.  This one has been too long already.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>In the beginning was the Word, and the Word was with God, and the Word was God. (John 1:1)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
