<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Implementing the Moving Average (Boxcar) filter</title>
  <meta name="description" content="When we first examinedfiltering, we looked atthe two simplest digital filtersI knew of: a filter that averages adjacentvalues, and afilter that recursivelyav...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2017/10/16/boxcar.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Implementing the Moving Average (Boxcar) filter</h1>
    <p class="post-meta"><time datetime="2017-10-16T00:00:00-04:00" itemprop="datePublished">Oct 16, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>When we <a href="/dsp/2017/08/19/simple-filter.html">first examined
filtering</a>, we looked at
the two simplest <a href="https://en.wikipedia.org/wiki/Digital_filter">digital filters</a>
I knew of: a <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/smplfir.v">filter that averages adjacent
values</a>, and a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/iiravg.v">filter that recursively
averages</a>
multiple numbers together.  These two simple filters required only a
<a href="/blog/2017/06/12/minimizing-luts.html">few FPGA resources</a>,
and so they were easy to implement.  Sadly, they weren’t very configurable and
so their filtering capability was quite limited.</p>

<p>We then came back to the topic and discussed how to create a
<a href="/dsp/2017/09/15/fastfir.html">generic Finite Impulse Response (FIR) filter</a>.  Such a
<a href="/dsp/2017/09/15/fastfir.html">generic</a>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
is <em>very</em> configurable.  Using the approach I presented, you can describe <em>any</em>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filter</a> in logic.
We then came back to the topic a bit later, and <a href="/dsp/2017/09/29/cheaper-fast-fir.html">discussed how to
create</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v">a filter</a>
that required fewer
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>,
while still maintaining the complete configurability of any
<a href="/dsp/2017/09/15/fastfir.html">generic</a>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.</p>

<p>The problem with both of these generic approaches is their cost.  As with
most
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filters</a>,
this cost is often measured in the number of multiplies (i.e. the number of
taps).  While the number of
<a href="https://en.wikipedia.org/wiki/Logic_block">logic block</a>s
and <a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>
is also of interest, even this logic scales with the number of filter
taps required.</p>

<p>As an example of this problem, suppose you wanted to select an
<a href="https://en.wikipedia.org/wiki/Frequency_modulation">FM</a>
<a href="https://en.wikipedia.org/wiki/FM_broadcast_band">broadcast</a>
signal (200 kHz) from somewhere within the
<a href="https://en.wikipedia.org/wiki/Frequency_modulation">FM</a>
<a href="https://en.wikipedia.org/wiki/FM_broadcast_band">broadcast band</a> (87-108MHz
<a href="https://en.wikipedia.org/wiki/Radio_frequency">RF</a>
in the US).  Now suppose you also wanted to do all of this processing within
your <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>,
and that you could afford a <a href="https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/">$99
Arty</a> (plus an
<a href="https://en.wikipedia.org/wiki/Frequency_modulation">FM</a> antenna, pre-amp,
<a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">ADC</a>, etc.).
The <a href="https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/">Arty</a> contains an
<a href="https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf">Artix-7/35T</a>
<a href="https://www.xilinx.com">Xilinx</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
with 90 DSP slices.  That means you can implement 90 multiplies within your
logic on any given clock tick.  This would allow you to create a
<a href="/dsp/2017/09/15/fastfir.html">generic</a>
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
with 89 taps.  (Most
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>s
have an <a href="https://en.wikipedia.org/wiki/Parks-McClellan_filter_design_algorithm">odd number of
taps</a>.)
With an 89 tap <a href="/dsp/2017/09/15/fastfir.html">generic
filter</a>, you’d
only be able to get about a 6dB separation between your channel and any other
<a href="https://en.wikipedia.org/wiki/Frequency_modulation">FM</a> channel, and even
the rest of your
<a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">ADC</a>s
<a href="https://en.wikipedia.org/wiki/Passband">passband</a>.
Such performance is pitiful.  It’s a far cry from the 70dB that I was taught
to design to.  Indeed, it would take an
<a href="https://en.wikipedia.org/wiki/Finite_impulse_response">FIR</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
of roughly <em>ten thousand</em> taps to provide a required 70dB separation.</p>

<p>Not only does the
<a href="https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf">Artix 7/35T</a> (<a href="https://www.digikey.com/product-detail/en/xilinx-enc/XC7A35T-1FTG256C/122-1910-ND/5039074">$35</a>)
on the <a href="https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/">$99 Arty</a>
not have this many taps, <em>none of the
<a href="https://www.xilinx.com">Xilinx</a>
<a href="https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf">7-series parts</a>
 has enough multiplies (DSP blocks) to implement a filter this large</em>.
The closest is the heftiest Virtex-7, which has 2,820 DSP elements.  I couldn’t
find this on <a href="https://www.digikey.com">Digikey</a> today, though.  The
closest Virtex 7 that I can find today on <a href="https://www.digikey.com">Digikey</a>
is the <a href="https://www.digikey.com/product-detail/en/xilinx-inc/XC7V2000T-1FHG1761C/XC7V2000T-1FHG1761C-ND/3925283">Virtex 7/2000T with 2,160 DSP blocks for
$18,000</a>.  In other words, money won’t buy you
out of this problem.</p>

<p>On the other hand, if you could
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
your signal down to less than 2MHz, without using any multiplies, you can then
save your multiplies for a later step when you could share a single multiply
between multiple taps.  Indeed, if you could do that then you might be able to
select an <a href="https://en.wikipedia.org/wiki/Frequency_modulation">FM</a> channel
for the cost of only a pair of multiplies–sparing your other 88 multiplies for
some other purpose.</p>

<p>This is where the
<a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
comes into play.
A <a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
requires no multiplies, only two additions, two incrementing pointers, and
some block RAM.  Although the
<a href="https://en.wikipedia.org/wiki/Moving_average">filter</a>
has a <code class="language-plaintext highlighter-rouge">-13</code> dB <a href="https://en.wikipedia.org/wiki/Stopband">stopband</a>, applying the
<a href="https://en.wikipedia.org/wiki/Moving_average">filter</a>
in a cascaded fashion <code class="language-plaintext highlighter-rouge">N</code> times would give you a
<code class="language-plaintext highlighter-rouge">-13 * N</code> dB
<a href="https://en.wikipedia.org/wiki/Stopband">stopband</a>.
Six rounds of
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">such a filter</a>
may well be sufficient, especially when each
<a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>
round uses only a
<a href="/blog/2017/06/12/minimizing-luts.html">minimum amount</a> of
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
logic.</p>

<p>So, let’s take a look at what it takes to implement a
<a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.
(I’ll call it a
<a href="https://en.wikipedia.org/wiki/Boxcar_function">boxcar</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>,
based upon the fact that the
<a href="https://en.wikipedia.org/wiki/Impulse_response">impulse response</a>
of this <a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
is a <a href="https://en.wikipedia.org/wiki/Boxcar_function">boxcar function</a>.)
We’ll start by examining how to build a
<a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a> in general,
and then discuss an initial (broken) implementation of such a
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.
We’ll then simplify the basic idea a bit more, and show
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">an example</a>
of how a “<a href="https://en.wikipedia.org/wiki/Moving_average">boxcar filter</a>” <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">might
be implemented</a>.
We’ll then round out the discussion with a discussion on performance,
explaining what sort of
<a href="https://en.wikipedia.org/wiki/Frequency_response">response</a>
you might expect from this filter.</p>

<h2 id="the-formula">The Formula</h2>

<p>Since what we’re doing might not look so clear when we dig into <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">the code
itself</a>, let’s
pause for a moment first to discuss what we are intending to do.
Our goal is to create a
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
that adds an adjacent <code class="language-plaintext highlighter-rouge">N</code> samples together.  As time progresses, the values
that will get averaged together will also rotate through our window as well.
This is why the operation is called a
“<a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>”: because
the choice of which samples get averaged together moves with time.</p>

<table style="float: right"><caption>Fig 1: A Generic Filter Implementation structure</caption><tr><td><img src="/img/fir-form.svg" alt="Generic FIR implementation structure" width="380" /></td></tr></table>

<p>Let’s back up a small step first, though.  If you recall
<a href="/dsp/2017/09/15/fastfir.html">from before</a>,
a <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/fastfir.v">generic FIR
filter</a>
has the form shown in Fig 1.  In that figure, you can see how each incoming
input sample goes into a delay line (at the top) and, at each stage of the
delay line, gets multiplied by a constant.  (The constant isn’t shown.)
All of the multiplication products are then added together to form the output.</p>

<p>Formally, we might write the operation of this filter as,</p>

<table align="center" style="float: none"><tr><td><img src="/img/fir-convolution.png" alt="Formula for an FIR Convolution" width="388" /></td></tr></table>

<p>where there are <code class="language-plaintext highlighter-rouge">N</code> taps to the filter, <code class="language-plaintext highlighter-rouge">x[n]</code> is a sequence of input samples,
<code class="language-plaintext highlighter-rouge">h[k]</code> is the sequence of <a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
coefficients, and <code class="language-plaintext highlighter-rouge">y[n]</code> is the output of the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a> fits this form as well,
with the unique feature that all the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
coefficients, <code class="language-plaintext highlighter-rouge">h[k]</code> are all ones.  This means that the multiplies are all
by one, and so they they can be removed from the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">implementation</a>.</p>

<p>Hence, you might draw this simplified
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
as shown in Fig 2, without the multiplies.</p>

<table align="center" style="float: none"><caption>Fig 2: A Conceptual Moving Average Implementation structure</caption><tr><td><img src="/img/fir-mvavg-form.svg" alt="A conceptual moving average filter implementation structure" width="380" /></td></tr></table>

<p>Formally, we might write this as,</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-mvavg-raw.png" alt="Moving Average filter" width="216" /></td></tr></table>

<p>With this simplification, the
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
has turned into nothing more than a
summation of a set of input values made on every clock tick.</p>

<p>Even in this form, we’re not ready to implement this
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a> yet.
Instead, consider what would happen if we subtracted two of these <code class="language-plaintext highlighter-rouge">y[n]</code>
values from each other.  You can see this conceptually in Fig 3.</p>

<table align="center" style="float: none"><caption>Fig 3: Subtracting one output from another</caption><tr><td><img src="/img/fir-mvavg-subtract.svg" alt="Moving averages--subtracting the previous output from the current one" width="480" /></td></tr></table>

<p>Did you catch that?  The difference between two adjacent outputs of our
filter, <code class="language-plaintext highlighter-rouge">y[n]-y[n-1]</code> is given by the difference between two input samples,
<code class="language-plaintext highlighter-rouge">x[n]-x[n-N]</code>.</p>

<p>Mathematically, we could write this as,</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-mvavg.png" alt="Moving Average filter simplified" width="356" /></td></tr></table>

<p>This subtle change in formula, from the generic formula for a convolution to
the one above, will spare us a lot of logic–allowing us to use a running
accumulator and a block RAM instead of hardware multiplies and a lot of
<a href="https://en.wikipedia.org/wiki/Flip-flop_(electronics)">flip-flops</a>.</p>

<p>Further, despite this formula referencing <code class="language-plaintext highlighter-rouge">y[n-1]</code>, it is <em>not</em> an
<a href="https://en.wikipedia.org/wiki/Infinite_impulse_response">IIR filter</a>.
Careful design will keep it from becoming one.</p>

<p>Let’s look at how we might
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">implement</a>
this <a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>.</p>

<h2 id="the-basic-equations">The Basic Equations</h2>

<p>A very quick, though incomplete, draft of this algorithm might look like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="c1">// Write the incoming sample to memory</span>
	<span class="n">mem</span><span class="p">[</span><span class="n">wraddr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span>
	<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="n">wraddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="c1">// Read the x[n-N] value from memory</span>
	<span class="n">memval</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">rdaddr</span><span class="p">];</span>
	<span class="n">rdaddr</span> <span class="o">&lt;=</span> <span class="n">rdaddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="c1">// Subtract x[n-N] from the incoming sample, x[n]</span>
	<span class="c1">// sub = x[n] - x[n-N]</span>
	<span class="n">sub</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i_sample</span> <span class="o">-</span> <span class="n">memval</span><span class="p">);</span>

	<span class="c1">// Add the result to the last output</span>
	<span class="c1">// y[n] = y[n-1] + sub = y[n-1]+x[n]-x[n-N]</span>
	<span class="n">acc</span> <span class="o">&lt;=</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">sub</span><span class="p">;</span>

	<span class="c1">// rounded() is shorthand for what we wish to do</span>
	<span class="c1">// but not really valid Verilog</span>
	<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="n">rounded</span><span class="p">(</span><span class="n">acc</span><span class="p">);</span>
<span class="k">end</span></code></pre></figure>

<p>Walking through this implementation, our first step was to write this
new sample to memory, and update our write pointer.  At the same time, we
read the value out from <code class="language-plaintext highlighter-rouge">N</code> samples ago, and updated our read pointer.</p>

<p>We then subtracted the value we read from memory, <code class="language-plaintext highlighter-rouge">memval</code> also known as
<code class="language-plaintext highlighter-rouge">x[n-N]</code>, from the new value, <code class="language-plaintext highlighter-rouge">i_sample</code> or <code class="language-plaintext highlighter-rouge">x[n]</code>, we just received.  The
result of that subtraction was then added into our accumulator, <code class="language-plaintext highlighter-rouge">y[n]</code>, just
like we discussed in the last section.  The final step was to
<a href="/dsp/2017/07/22/rounding.html">round</a>
the output to the desired number of bits and we were done.</p>

<p>You’ll find by the end of this article that our finished
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">algorithm</a>,
is not going to be all that much more complex than the algorithm above,
although you may also find that it doesn’t look much like the algorithm above.</p>

<h2 id="reset">Reset</h2>

<p>The first problem with our first attempt is making certain that the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">the filter</a>
has a proper initial value.  One mistake in the accumulator, one mistake
that gets <code class="language-plaintext highlighter-rouge">y[n]</code> wrong, and
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">this filter</a>
might be turned into an
<a href="https://en.wikipedia.org/wiki/Infinite_impulse_response">IIR filter</a> with
an unwanted DC offset.  To keep that from happening, let’s create a reset
capability so that we can guarantee the filter starts in a known configuration.</p>

<p>Specifically, at the time of reset, the accumulator must be set to zero,
as with any intermediate calculation values, such as <code class="language-plaintext highlighter-rouge">sub</code> and <code class="language-plaintext highlighter-rouge">memval</code>.</p>

<p>The other thing we’ll need to pay attention to is the memory.  One difficulty
when using block RAM, as with all memories I know of, is that there’s no
circuitry for initializing all of our memory at once.  Instead, we’ll
“pretend” the memory is zero for a number of clocks following a reset, and
then we’ll use the memory as normal.</p>

<p>Hence, we’ll need to modify our code such as,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">acc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">full</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="n">sub</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rdaddr</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">navg</span><span class="p">;</span>
<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="n">wraddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="n">rdaddr</span> <span class="o">&lt;=</span> <span class="n">rdaddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="n">full</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">full</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">rdaddr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full</span><span class="p">)</span>
		<span class="c1">// Value read from memory is valid</span>
		<span class="n">sub</span> <span class="o">&lt;=</span> <span class="n">i_sample</span> <span class="o">-</span> <span class="n">memval</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="c1">// Value read from memory was never initialized</span>
		<span class="c1">// We'll assume here that it is zero</span>
		<span class="n">sub</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span>

	<span class="n">acc</span> <span class="o">&lt;=</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">sub</span><span class="p">.</span>
<span class="k">end</span></code></pre></figure>

<p>This creates a new value, <code class="language-plaintext highlighter-rouge">full</code>, which we can use to determine whether the
memory value is valid or not.</p>

<p>These are the big broad-brush differences between the quick draft above,
and what we’re about to present below.  Our next step, then, will be to build
our final algorithm.</p>

<h2 id="the-actual-algorithm">The Actual Algorithm</h2>

<p>Let’s now use the lessons from above to build our <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">verilog
algorithm</a>.
Feel free to examine the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">final code
here</a>,
as you follow along below.</p>

<p>As a step number one, we’ll make <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">this
filter</a>
as generic as we can.  To do that, we’ll parameterize our input width,
<code class="language-plaintext highlighter-rouge">IW</code>, and output width, <code class="language-plaintext highlighter-rouge">OW</code>.  Further, we’ll parameterize the number of
averages allowable, which we shall controll by the log (based two) of the
maximum number of averages, <code class="language-plaintext highlighter-rouge">LGMEM</code>.  This will allow us to average by
any amount between <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">(1&lt;&lt;LGMEM)-1</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">parameter</span>	<span class="n">IW</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>		<span class="c1">// Input bit-width</span>
		<span class="n">LGMEM</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>	<span class="c1">// Size of the memory</span>
		<span class="n">OW</span><span class="o">=</span><span class="p">(</span><span class="n">IW</span><span class="o">+</span><span class="n">LGMEM</span><span class="p">);</span>	<span class="c1">// Output bit-width</span></code></pre></figure>

<p>Hence, if you want to average fifty-five 16-bit values together, you’d set <code class="language-plaintext highlighter-rouge">IW</code>
to 16 and <code class="language-plaintext highlighter-rouge">LGMEM</code> to 6.  If you want an output without any
<a href="/dsp/2017/07/22/rounding.html">rounding</a>,
then the output width, <code class="language-plaintext highlighter-rouge">OW</code>,
<a href="/dsp/2017/07/21/bit-growth.html">needs to be set to</a>
the input width plus the log of the number of averages.  In the example of
averaging fifty-five 16-bit items together, this means we’d need an output
width of <code class="language-plaintext highlighter-rouge">16+6</code>, or <code class="language-plaintext highlighter-rouge">OW=22</code>.  Any fewer output bits than that will require
<a href="/dsp/2017/07/22/rounding.html">rounding</a>
the internal result to the desired number of output bits.</p>

<p>We’ll also allow the number of averages to be configurable as well–or not,
if the <code class="language-plaintext highlighter-rouge">FIXED_NAVG</code> parameter is set.  If <code class="language-plaintext highlighter-rouge">FIXED_NAVG</code> is set, then the number
of averages will be fixed, and set by an <code class="language-plaintext highlighter-rouge">INITIAL_AVG</code> parameter.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">FIXD_NAVG</span><span class="o">=</span><span class="mb">1'b0</span><span class="p">;</span>	<span class="c1">// True if number of averages is fixed</span>

<span class="c1">// Always assume we'll be averaging by the maximum amount, unless told</span>
<span class="c1">// otherwise.  Minus one, in two's complement, will become this number</span>
<span class="c1">// when interpreted as an unsigned number.</span>
<span class="k">parameter</span> <span class="p">[(</span><span class="n">LGMEM</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">INITIAL_AVG</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>If <code class="language-plaintext highlighter-rouge">FIXED_NAVG</code> is not set, we’ll allow the user to set the number of averages
they want.  However, because of the dependence of the feedback relationship,
<code class="language-plaintext highlighter-rouge">y[n]</code> on <code class="language-plaintext highlighter-rouge">y[n-1]</code>, we’ll insist that the number of averages must not change
except on an <code class="language-plaintext highlighter-rouge">i_reset</code> signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="kt">wire</span>	<span class="p">[(</span><span class="n">LGMEM</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">w_requested_navg</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">w_requested_navg</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIXED_NAVG</span><span class="p">)</span> <span class="o">?</span> <span class="n">INITIAL_NAVG</span> <span class="o">:</span> <span class="n">i_navg</span><span class="p">;</span></code></pre></figure>

<p>As we’ll see later, the only part of our algorithm that depends upon this
number of averages is the initial/reset value of the memory read address.
For this reason, we won’t store the value in a register.  We’ll come back to
this later when we discuss the read address.</p>

<p>That brings us to the logic required for accessing memory–both writing and
then reading.  Of these two, the write address is simple: we’ll start writing
to the first address of memory (address zero) on our first data
sample, and then rotate through memory locations from there.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">wraddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="n">wraddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>What that means, though, is that we have to implement the time difference
between the initial value and the value <code class="language-plaintext highlighter-rouge">N</code> samples ago using the <em>read</em>
memory address.  We’ll do so by initializing the read address to the negative
number of averages.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">rdaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">rdaddr</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">w_requested_navg</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">rdaddr</span> <span class="o">&lt;=</span> <span class="n">rdaddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>As with the write address, we increment the read address on every sample clock.</p>

<p>Following the address calculation, we’ll write out incoming sample to memory,
and read our delayed sample from memory as well.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">mem</span><span class="p">[</span><span class="n">wraddr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span>

<span class="c1">// ...</span>

<span class="k">initial</span>	<span class="n">memval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">memval</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">rdaddr</span><span class="p">];</span></code></pre></figure>

<p>So far, this is all straightforward.  Other than initial values, we haven’t
really deviated from our initial draft above.  However, things get a little
trickier when adding the input sample to this logic.  In particular, if we
want our input value to be aligned with the output of the memory read, <code class="language-plaintext highlighter-rouge">memval</code>,
associated with <code class="language-plaintext highlighter-rouge">x[n-N]</code>, then we’ll need to delay the input by one sample.</p>

<p>It’s not really that obvious why this would be so.  Why does the input need to
be delayed by a sample?  The answer has to do with pipeline scheduling.
So, let’s look at how the internal values within our algorithm get set on
subsequent clocks, as shown in Fig 4.</p>

<table align="center" style="float: none"><caption>Fig 4: Scheduling the moving average pipeline</caption><tr><td><img src="/img/mvavg-pipeline.svg" alt="Table, showing when the various values are getting assigned" width="780" /></td></tr></table>

<p>This figure shows a list of all of our internal registers, binned within the
clocks they are set within–starting on the clock before a particular sample,
<code class="language-plaintext highlighter-rouge">i_sample[t]</code>, is provided, <code class="language-plaintext highlighter-rouge">t-1</code> until four clocks later at <code class="language-plaintext highlighter-rouge">t+4</code>.  Hence, since <code class="language-plaintext highlighter-rouge">memval</code> depends upon <code class="language-plaintext highlighter-rouge">rdaddr</code>, it
shows in the clock following the one when <code class="language-plaintext highlighter-rouge">rdaddr</code> gets set.  Likewise, since
the memory is set following the write address being set, <code class="language-plaintext highlighter-rouge">mem[wraddr]</code> gets
set following <code class="language-plaintext highlighter-rouge">wraddr</code>.</p>

<p>While our presentation through <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">the
code</a> below
is going to be in chronological order, from time <code class="language-plaintext highlighter-rouge">t</code> through <code class="language-plaintext highlighter-rouge">t+4</code>, the chart
above was built/scheduled backwards.  <code class="language-plaintext highlighter-rouge">o_result</code> is the
<a href="/dsp/2017/07/22/rounding.html">rounded</a>
version of <code class="language-plaintext highlighter-rouge">acc</code>.  It took
one clock to calculate.  <code class="language-plaintext highlighter-rouge">acc</code> is the sum of the last accumulator and the
result of the subtraction, <code class="language-plaintext highlighter-rouge">sub</code>.  Further, we know that we want to subtract
our new input value from the last memory value, <code class="language-plaintext highlighter-rouge">memval</code>, etc.</p>

<p>So why do we have the register <code class="language-plaintext highlighter-rouge">preval</code> in this pipeline chart?  It doesn’t
seem to do anything, so why is it there?</p>

<p>The answer is simple: we needed to delay the input by one clock in order to get
it to line up with the memory that was just written and then read.</p>

<p>For example, let’s suppose we only wished to average one
element–a pass-through filter.  Hence, we’d want to add
our new value, <code class="language-plaintext highlighter-rouge">x[n]</code>, and subtract the prior value, <code class="language-plaintext highlighter-rouge">x[n-1]</code>, delayed by only
one clock.  Given that’s what we want to do, let’s follow that new value through
this pipeline schedule in Fig 5 below.</p>

<table align="center" style="float: none"><caption>Fig 5: Tracing the last sample through the moving average pipeline</caption><tr><td><img src="/img/mvavg-pipeline-trace.svg" alt="Table, showing when the various values are getting assigned" width="780" /></td></tr></table>

<p><code class="language-plaintext highlighter-rouge">i_sample[t-1]</code> shows up at time <code class="language-plaintext highlighter-rouge">t-1</code>, and gets written into memory,
<code class="language-plaintext highlighter-rouge">mem[wraddr]</code>, at time
<code class="language-plaintext highlighter-rouge">t</code>.  It can then be read at time <code class="language-plaintext highlighter-rouge">t+1</code> into <code class="language-plaintext highlighter-rouge">memval</code>, and then subtracted
from the new value at <code class="language-plaintext highlighter-rouge">t+2</code> to create <code class="language-plaintext highlighter-rouge">sub</code>.  This time, <code class="language-plaintext highlighter-rouge">t+2</code>, is the earliest
the last value can be read back from memory.  This is also the time when we
need our new value, <code class="language-plaintext highlighter-rouge">x[n]</code>–one clock after it shows up.  To get the new sample
value from when it is given to us into this clock period, we need to delay it
by a single cycle, placing it into <code class="language-plaintext highlighter-rouge">preval</code> for that purpose.</p>

<p>The logic necessary to do this is trivial–unlike the reasoning behind it above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">preval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">preval</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">preval</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span></code></pre></figure>

<p>The other thing we’re going to need to know, at the same time we want to
know the value we just read from memory, is whether we’ve written enough
times to the memory for the values read out of the memory to be valid.  I’ve
chosen to call this <code class="language-plaintext highlighter-rouge">full</code>, to indicate that the tapped-delay line memory has
been filled.</p>

<p>Since we initialized the write address at zero, and then wrote to the zero
address in our first clock, we know that the value read from memory will
be valid as soon as we read from the zero address.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">full</span>   <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">full</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">full</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">full</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">rdaddr</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>We’ve now set all of the values shown in the time <code class="language-plaintext highlighter-rouge">t+1</code> column from Figs 4 and 5
above, so we’ll move on to the next clock.  In this clock, we’ll subtract
the sample falling off the end of our average list from our new sample.  We’ll
place this result into <code class="language-plaintext highlighter-rouge">sub</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">sub</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="n">sub</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
<span class="k">begin</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full</span><span class="p">)</span>
		<span class="n">sub</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">preval</span><span class="p">[(</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">preval</span> <span class="o">}</span>
				<span class="o">-</span> <span class="o">{</span> <span class="n">memval</span><span class="p">[(</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">memval</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sub</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">preval</span><span class="p">[(</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">preval</span> <span class="o">}</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>The rest is simple.  We add this difference to our accumulated value, creating
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">our filter</a>’s
output value, <code class="language-plaintext highlighter-rouge">y[n]</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">acc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">acc</span> <span class="o">&lt;=</span> <span class="n">acc</span> <span class="o">+</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">LGMEM</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="n">sub</span><span class="p">[</span><span class="n">IW</span><span class="p">]</span><span class="o">}}</span><span class="p">,</span> <span class="n">sub</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>The final stage of our pipeline
<a href="/dsp/2017/07/22/rounding.html">rounds</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">our filter</a>’s
outputs to the number of bits requested by the parameter, <code class="language-plaintext highlighter-rouge">OW</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">generate</span>
<span class="k">if</span> <span class="p">(</span><span class="n">IW</span><span class="o">+</span><span class="n">LGMEM</span> <span class="o">==</span> <span class="n">OW</span><span class="p">)</span>
	<span class="c1">// No rounding required, output is the acc</span>
	<span class="k">assign</span>	<span class="n">rounded</span> <span class="o">=</span> <span class="n">acc</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IW</span><span class="o">+</span><span class="n">LGMEM</span> <span class="o">==</span> <span class="n">OW</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1">// Need to drop one bit, round towards even</span>
	<span class="k">assign</span>	<span class="n">rounded</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span> <span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">}</span><span class="p">;</span>
<span class="k">else</span> <span class="c1">// if (IW+LGMEM &gt; OW + 1)</span>
	<span class="c1">// Drop more than one bit, rounding towards even</span>
	<span class="k">assign</span>	<span class="n">rounded</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">+</span> <span class="o">{</span>
			<span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span> <span class="n">acc</span><span class="p">[(</span><span class="n">IW</span><span class="o">+</span><span class="n">LGMEM</span><span class="o">-</span><span class="n">OW</span><span class="p">)],</span>
			<span class="o">{</span><span class="p">(</span><span class="n">IW</span><span class="o">+</span><span class="n">LGMEM</span><span class="o">-</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{!</span><span class="n">acc</span><span class="p">[(</span><span class="n">IW</span><span class="o">+</span><span class="n">LGMEM</span><span class="o">-</span><span class="n">OW</span><span class="p">)]</span><span class="o">}}</span> <span class="o">}</span><span class="p">;</span>
<span class="k">endgenerate</span></code></pre></figure>

<p>Once we are done
<a href="/dsp/2017/07/22/rounding.html">rounding</a>
the output value, we’ll take an extra clock stage
to deal with any delay associated with
<a href="/dsp/2017/07/22/rounding.html">rounding</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="n">rounded</span><span class="p">[(</span><span class="n">IW</span><span class="o">+</span><span class="n">LGMEM</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">IW</span><span class="o">+</span><span class="n">LGMEM</span><span class="o">-</span><span class="n">OW</span><span class="p">)];</span></code></pre></figure>

<p>While we might’ve skipped this delay if we didn’t need to drop any bits,
doing so would cause our filter to have a different delay depending on how
it was configured.  Rather than deal with that maintenance headache, the
result is always delayed
(<a href="/dsp/2017/07/22/rounding.html">rounded</a>
or not) by one clock here.</p>

<h2 id="performance">Performance</h2>

<p>The <a href="https://en.wikipedia.org/wiki/Frequency_response">frequency response</a>
of a <a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
is well known.  It’s easy enough to calculate that it makes a good assignment
for the beginning student.  It’s given by,</p>

<table align="center" style="float: none"><tr><td><img src="/img/eqn-mvavg-H.png" alt="H = sin(pi fN)/sin(pi f)" width="308" /></td></tr></table>

<p>If you examine this
<a href="https://en.wikipedia.org/wiki/Frequency_response">response</a>,
it’s really not that great.  At best, you can get a
<a href="https://en.wikipedia.org/wiki/Stopband">stopband</a>
of -13 dB from
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">this filter</a>.
That’s better than the -6dB
<a href="https://en.wikipedia.org/wiki/Stopband">stopband</a> from our
<a href="https://en.wikipedia.org/wiki/Frequency_modulation">FM</a>
example above, but still a far cry from the -70dB we might like.</p>

<p>On the other hand, if you cascade <code class="language-plaintext highlighter-rouge">M</code>  filters
of this type together, you can get a much deeper
<a href="https://en.wikipedia.org/wiki/Stopband">stopband</a>.
To illustrate this,
Fig 6 below shows, in blue, the response of a
<a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
that averages five adjacent values together.  The other lines on the chart show
what happens after cascading
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">this filter</a>
with itself two, three, four, five, or six times.</p>

<table align="center" style="float: none"><caption>Fig 6: Moving average frequency response</caption><tr><td><img src="/img/mvavg-response.png" alt="Image showing this filters response function" width="714" /></td></tr></table>

<p>The <a href="https://www.gnu.org/software/octave">Octave</a> code used to create this
figure can be found
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/boxcar.m">here</a>.</p>

<p>There are two important things to notice from this figure.  First, the
<a href="https://en.wikipedia.org/wiki/Stopband">stopband</a>
of the filter, when cascaded, can get <em>very</em> deep.  After cascading six of
these together, the
<a href="https://en.wikipedia.org/wiki/Stopband">stopband</a>
is <code class="language-plaintext highlighter-rouge">-78</code> dB–pretty impressive.  The second thing to notice is that the
“<a href="https://en.wikipedia.org/wiki/Passband">passband</a>”
is no longer flat.  As a result, we’ll need to follow
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">this filter</a>
with another one to clean up any distortion of our signal of interest.</p>

<h2 id="conclusion">Conclusion</h2>

<p>While a
<a href="https://en.wikipedia.org/wiki/Moving_average">moving average</a>
<a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
is a far cry from a well-designed
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">low-pass filter</a>, it’s also a
very simple <a href="https://en.wikipedia.org/wiki/Digital_filter">filter</a>
to implement.  From an engineering trade-off standpoint, this simplicity
makes it a very attractive component for dealing with many
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">DSP</a>
requirements on an
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.</p>

<p>We’re not done with our lessons on
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filtering</a>,
though.  I’ve still got plans to discuss
<a href="https://en.wikipedia.org/wiki/Linear_phase">symmetric filters</a>,
<a href="https://en.wikipedia.org/wiki/Half-band_filter">half-band filters</a>,
<a href="https://en.wikipedia.org/wiki/Hilbert_transform">Hilbert transforms</a>,
and more.  Further, I’d like to discuss not only their high speed
implementations, but also some slower implementations that would be appropriate
for those designs where there are many clocks between input samples.</p>

<p>Even at that, we’re not done, since <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/boxcar.v">the filter
above</a>,
when cascaded with itself any number of times and <em>followed by a downsampler</em>,
can be built without needing a block RAM.</p>

<p>We are also going to want to
<a href="/dsp/2017/11/04/genfil-tb.html">discuss how to go about proving that these
filters work</a>.  What sort of
test bench is appropriate for testing
<a href="https://en.wikipedia.org/wiki/Digital_filter">digital filters</a>?</p>

<p>These, however, are lessons still to come.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Lo, this only have I found, that God hath made man upright; but they have sought out many inventions. (Eccl 7:29)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
