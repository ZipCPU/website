<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A Configurable Signal Delay Element</title>
  <meta name="description" content="It’s always fun to design something simple every now and then–something thatdoesn’t take too much thought, yet still fits a needed place in something youare ...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zipcpu.com/dsp/2017/11/10/delayw.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="http://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">A Configurable Signal Delay Element</h1>
    <p class="post-meta"><time datetime="2017-11-10T00:00:00-05:00" itemprop="datePublished">Nov 10, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>It’s always fun to design something simple every now and then–something that
doesn’t take too much thought, yet still fits a needed place in something you
are building.</p>

<table style="float: right"><caption>Fig 1: A Signal Delay Element</caption><tr><td><img src="/img/delayw.svg" alt="Block Diagram showing the concept of a delay element: the incoming data line is split, one line gets delayed, both go through flip flops" width="360" /></td></tr></table>

<p>Today, let’s look at a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay element</a>.
This is a fundamental
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">signal processing</a>
operation that takes a single stream and creates two streams–with the second
stream delayed by some programmable amount of samples from the first one.</p>

<p>This is actually a very common
<a href="https://en.wikipedia.org/wiki/Digital_signal_processing">signal processing</a>
need.  Imagine if you will that you had one piece of processing code that was
applied to the input, took many samples (<code class="highlighter-rouge">N</code>) to accomplish, and that the
result of this processing told you how to lock onto the signal that began
<code class="highlighter-rouge">N</code> samples ago.</p>

<p>A classic example of this would be a
<a href="https://en.wikipedia.org/wiki/Syncword">burst preamble</a>–a
known sequence that occurs at the beginning of a burst transmission
to help you to synchronize to that transmission.  However, once synchronized,
you then want to go back and process any samples immediately following that
<a href="https://en.wikipedia.org/wiki/Syncword">preamble</a>.  Should you have any
delay in your <a href="https://en.wikipedia.org/wiki/Syncword">preamble</a>
processing chain, then you’d need to go “back in time” to start processing
your signal immediately following this
<a href="https://en.wikipedia.org/wiki/Syncword">preamble</a>.  This is one purpose of a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay element</a>.</p>

<p>So, just for fun and to have a change-up from some more serious
and complex topics, let’s examine a <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">simple delay
element</a>.</p>

<h2 id="pseudocode">Pseudocode</h2>

<p>At first blush, the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">logic for a delay
element</a>.
seems quite simple: just delay the incoming samples by some variable amount.
Indeed, you might wish to start coding the algorithm together immediately
(I did).  You’d start with a delay of zero, and then build the logic for the
delay of one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
begin
	if (i_delay == 0)
	begin
		o_word &lt;= i_word;
		o_delayed &lt;= i_word;
	end else if (i_delay == 1)
	begin
		o_word &lt;= i_word;
		o_delayed &lt;= o_word;
	end else begin</code></pre></figure>

<p>Then you’d get stuck.</p>

<p>It’s right here at this point in the pseudocode that you need to transition
to a block RAM delay, and so you need a memory value read from block RAM.
We’ll call this value <code class="highlighter-rouge">memval</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		o_word &lt;= i_word;
		o_delayed &lt;= memval;
	end
end</code></pre></figure>

<p>Ok, so we’ll need a memory.  That means we are going to want to write our
data into memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	mem[wraddr] &lt;= i_word;</code></pre></figure>

<p>We are also going to want to read it back out.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
	memval &lt;= mem[rdaddr];</code></pre></figure>

<p>And in order to make this all work, we’re going to need some memory address
manipulation code.  Most of this is straight boilerplate.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">always @(posedge i_clk)
begin
	if (i_reset)
	begin
		wraddr &lt;= 0;
		rdaddr &lt;= ... // Something ... but what?
	end else if (i_ce)
	begin
		wraddr &lt;= wraddr + 1'b1;
		rdaddr &lt;= rdaddr + 1'b1;
	end</code></pre></figure>

<p>The read address, though, is not boilerplate.  It needs to be related to the
write address.  Indeed, this is perhaps the <em>only</em> difficult part of building
a signal <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay
element</a>
such as this.</p>

<p>So how should the read address relate to the write address?</p>

<p>The first answer in this case would be that the read address should be less
than the write address by <code class="highlighter-rouge">i_delay</code> elements.  When you then try this code
within a <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/delayw_tb.cpp">test bench</a>,
you’ll find that this choice just doesn’t work.</p>

<p>So let’s think this through a touch more.</p>

<h2 id="scheduling-the-memory-pipeline">Scheduling the Memory Pipeline</h2>

<p>To get the read and write address correct, let’s examine how our signals
would move through this pipeline.  We can build a pipeline schedule as we’ve
done before on <a href="http://zipcpu.com/">this blog</a>.  You can see
the schedule for our delay logic shown in Fig 2.</p>

<table style="float: right"><caption>Fig 1: A Signal Delay Element</caption><tr><td><img src="/img/delayw-pipeline.svg" alt="The stages of the delay pipeline" width="480" /></td></tr></table>

<p>The basic concept of this diagram is that variables that are valid at one
time step lead to new variables that are valid on the next.  So if <code class="highlighter-rouge">i_data</code>
is valid on one time step, <code class="highlighter-rouge">o_data</code> will be valid on the next.  Likewise
if we write <code class="highlighter-rouge">i_data</code> to memory using the <code class="highlighter-rouge">wraddr</code> signal on one time step,
then the memory element, <code class="highlighter-rouge">mem[wraddr]</code> will have that value on the next time
step.</p>

<p>Let’s follow what happens to this memory a touch further.  If after writing
to memory we immediately read from it into <code class="highlighter-rouge">memval</code>, that will require a
read address, <code class="highlighter-rouge">rdaddr</code>.  We can then place this <code class="highlighter-rouge">memval</code> into our output
delay element, <code class="highlighter-rouge">o_delayed</code> and be done.</p>

<p>So how many clocks did that take?  Two.  Count the difference between when
<code class="highlighter-rouge">o_delay</code> was produced and when <code class="highlighter-rouge">o_data</code> was produced.  This is then our
minimum delay when using memory: two clocks.</p>

<p>If you’ve been following this blog, you may remember going through this same
exercise when we <a href="/dsp/2017/10/16/boxcar.html">built a moving average
filter</a>.</p>

<p>From here, we can work out how the read address corresponds to the write
address.  In particular, if <code class="highlighter-rouge">rdaddr == wraddr-1</code>, then we are delaying by
two.  So what we want, then, is to have <code class="highlighter-rouge">rdaddr = wraddr+1-i_delay</code> and
that’s all the missing logic required to make this work.</p>

<p>Ok, I’ll admit … I didn’t put any time into figuring out how to schedule
the pipeline.  I just built it wrong, and then adjusted the relationship between
<code class="highlighter-rouge">wraddr</code> and <code class="highlighter-rouge">rdaddr</code> in the <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/delayw_tb.cpp">test
bench</a>
until I got things right.  That should help illustrate for you, though, the
<a href="/blog/2017/06/23/my-dbg-philosophy.html">power of building a test bench and
simulating</a>–rather
than just implementing something and then wondering what went wrong later.</p>

<h2 id="building-this">Building this</h2>

<p>So let’s build our <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">final delay
element</a>!</p>

<p>Much of this logic is the logic you might expect from our discussion above.</p>

<p>For example, we need to increment the write address on every sample.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	wraddr = 0;
	always @(posedge i_clk)
		if (i_ce)
			wraddr &lt;= wraddr + 1'b1;</code></pre></figure>

<p>You may notice that this write address doesn’t depend upon a reset signal.
The reason is simply because it doesn’t need to.  As long as it increments by
one on every clock from whatever address it’s at, it will work.</p>

<p>Likewise we are going to want to write our incoming samples into memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
		if (i_ce)
			mem[wraddr] &lt;= i_word;</code></pre></figure>

<p>The difficult trick from above was that we need to make certain that the
read address equals the write address plus one minus the delay.  Making this
happen in clocked logic is a touch more difficult–particularly because of the
<code class="highlighter-rouge">i_ce</code> <a href="/blog/2017/08/14/strategies-for-pipelining.html">pipeline control
signal</a>.</p>

<p>So that we can keep the read address a fixed distance from the write address
any time the delay, herein called <code class="highlighter-rouge">w_delay</code>–you’ll see
why in a bit, changes, we’ll violate the <a href="/blog/2017/08/14/strategies-for-pipelining.html">rules of the global
CE bit</a>
and set this on every clock.  If <code class="highlighter-rouge">CE</code> is valid, we set the read address
to the write address minus the delay plus two–not one.  The two allows us
to compensate for the fact that the write address is also changing on this
clock.  However, if the <code class="highlighter-rouge">CE</code> line is low, then the write address isn’t changing
and the logic may appear more intuitive.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	initial	rdaddr = one;
	always @(posedge i_clk)
		if (i_ce)
			rdaddr &lt;= wraddr + two - w_delay;
		else
			rdaddr &lt;= wraddr + one - w_delay;</code></pre></figure>

<p>Now that we have our read address, we can simply read from memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
		if (i_ce)
			memval &lt;= mem[rdaddr];</code></pre></figure>

<p>With all this information, we can now make our delay logic.  You migt recognize
this from before–the delay of zero and the delay of one samples are identical.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	always @(posedge i_clk)
	if (i_ce)
	begin
		if (w_delay == 0)
		begin
			o_word &lt;= i_word;
			o_delayed &lt;= i_word;
		end else if (w_delay == 1)
		begin
			o_word &lt;= i_word;
			o_delayed &lt;= o_word;
		end else begin</code></pre></figure>

<p>Even the delay logic, which is implemented using memory, reads just about the
same as it did before.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">			o_word &lt;= i_word;
			o_delayed &lt;= memval;
		end
	end
endmodule</code></pre></figure>

<p>Pretty simple, right?</p>

<p>Well, okay, so let’s get one touch fancier.  Right now this
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay element</a>
works off of a variable, user-selectable delay.  Suppose instead that you
wanted this <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay
element</a>
to use a fixed delay instead.  You could just feed a constant value to
<code class="highlighter-rouge">i_delay</code> and allow the optimizer within the synthesizer to handle
everything that follows.  We’ll take a separate approach here.  We’ll
capture this desired fixed delay with a <code class="highlighter-rouge">FIXED_DELAY</code> parameter, and then use
this parameter to determine the delay any time
<code class="highlighter-rouge">FIXED_DELAY != 0</code>.</p>

<p>Remember that <code class="highlighter-rouge">w_delay</code> item I said we’d touch on later?  This value is set to
<code class="highlighter-rouge">i_delay</code> when the parameter isn’t forcing the delay amount, and <code class="highlighter-rouge">FIXED_DELAY</code>
when it is.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	assign	w_delay = (FIXED_DELAY != 0) ? FIXED_DELAY : i_delay;</code></pre></figure>

<p>That’s a nice improvement to our <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay
component</a>.</p>

<p>Still, the overall design isn’t all that different from the one we started
out with–even with the details filled in.</p>

<h2 id="building-a-test-bench">Building a Test Bench</h2>

<p>Since this is a fairly simple component, we can discuss the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/delayw_tb.cpp">test bench</a>
before we finally conclude–rather than separating the test bench into a
separate post.  The <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/delayw_tb.cpp">test
bench</a>
for this <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay
element</a>
follows from the same principles I laid out
<a href="/blog/2017/06/21/looking-at-verilator.html">earlier</a>,
when we examined
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>.
Basically, when you are using
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>
your <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/delayw_tb.cpp">test
bench</a>
is a C++ program that interacts with your design, and then compares
the responses from the design to known responses that we might expect.</p>

<p>We’ll capture our parameters before starting, since our test will be dependent
upon them.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">const</span> <span class="kt">int</span>	<span class="n">DW</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="n">LGDLY</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">NTESTS</span><span class="o">=</span><span class="mi">512</span><span class="p">;</span></code></pre></figure>

<p>Setting up the main program itself is fairly boilerplate.  You need to make
certain you call the <code class="highlighter-rouge">commandArgs</code> function to initialize
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>.
We’ll then declare our test class–wrapping it within the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/testb.h">TESTB</a>
class so that we can get clock ticks, resets, and 
<a href="/blog/2017/07/31/vcd.html">VCD file</a>
generation code for free.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span>	<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">Verilated</span><span class="o">::</span><span class="n">commandArgs</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
	<span class="n">TESTB</span><span class="o">&lt;</span><span class="n">Vdelayw</span><span class="o">&gt;</span>	<span class="n">tb</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;</span>
	<span class="kt">unsigned</span>	<span class="o">*</span><span class="n">mem</span><span class="p">;</span></code></pre></figure>

<p>Our first task will be to open a
<a href="/blog/2017/07/31/vcd.html">VCD trace file</a>
so that we can debug any problems later.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">tb</span><span class="p">.</span><span class="n">opentrace</span><span class="p">(</span><span class="s">"delayw.vcd"</span><span class="p">);</span></code></pre></figure>

<p>Then we’ll reset our core, so that we can start this test in a known state.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">tb</span><span class="p">.</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_ce</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tb</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span></code></pre></figure>

<p>You may recall from our <a href="/blog/2017/10/19/formal-intro.html">first formal methods
post</a>
the problem associated with testing a reset in a <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/delayw_tb.cpp">test
bench</a>:
that there are more combinations of when a reset can happen with respect to this
logic than I have the creativity to imagine.  It’s a problem we’re going to
ignore here, but a valid one and hence one worth remembering.</p>

<p>We’re going to need our own copy of the delay memory, so that we can also create
our own delay here in C++ to compare the unit under test to.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">mem</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">unsigned</span><span class="p">[(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGDLY</span><span class="p">)];</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGDLY</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>Let’s run our test across every delay that this
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay element</a>
may produce.
We’ll loop through each possible delay, testing and validating the results
along the way.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">tb</span><span class="p">.</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_ce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">dly</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">dly</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGDLY</span><span class="p">);</span> <span class="n">dly</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tb</span><span class="p">.</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_delay</span> <span class="o">=</span> <span class="n">dly</span><span class="p">;</span></code></pre></figure>

<p>The first step, following any change in delay value, is to load up that
many values in the memory without testing any of the output delays.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">dly</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span></code></pre></figure>

<p>To do this, we’ll generate a random number,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="kt">unsigned</span>	<span class="n">v</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">DW</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>and to write it to our core.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">tb</span><span class="p">.</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_word</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
			<span class="n">tb</span><span class="p">.</span><span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>We’ll also record that number into our own memory copy at the same time.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">mem</span><span class="p">[</span><span class="n">wptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
			<span class="n">wptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">wptr</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="p">}</span></code></pre></figure>

<p>After loading one element per delay, we can now come back and test whether
or not the output was properly delayed.  We’ll check <code class="highlighter-rouge">NTESTS</code> (512) of these
for each possible delay.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">NTESTS</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span></code></pre></figure>

<p>As before, each test consists of creating a random value,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="kt">unsigned</span>	<span class="n">v</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">DW</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>writing that value to the core,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">tb</span><span class="p">.</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">i_word</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
			<span class="n">tb</span><span class="p">.</span><span class="n">tick</span><span class="p">();</span></code></pre></figure>

<p>and recording a copy of it for ourselves.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">mem</span><span class="p">[</span><span class="n">wptr</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
			<span class="n">wptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">wptr</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">;</span></code></pre></figure>

<p>Now we can check whether or not the output from the core is the value from
<code class="highlighter-rouge">dly</code> clocks ago.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">			<span class="n">assert</span><span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_word</span> <span class="o">==</span> <span class="n">mem</span><span class="p">[(</span><span class="n">wptr</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">]);</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">m_core</span><span class="o">-&gt;</span><span class="n">o_delayed</span> <span class="o">==</span> <span class="n">mem</span><span class="p">[(</span><span class="n">wptr</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">dly</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span></code></pre></figure>

<p>At this point, the tests are complete and all we need to do is close nicely.</p>

<p>You may notice that, in the closing lines of the <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/delayw_tb.cpp">test
bench</a>,
there’s no possibility for failure.  The reason is simply because a failure
to match will cause a failure above in the <code class="highlighter-rouge">assert()</code> statements, and so on
any failure we’ll never reach this point.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">Simulation complete: %ld clocks</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tb</span><span class="p">.</span><span class="n">m_tickcount</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"SUCCESS!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>That’s it!  We’re all done with our <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/delayw_tb.cpp">test
bench</a>.</p>

<p>If you choose to look through the <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/delayw_tb.cpp">actual test
bench</a>,
you will notice one more capability that we haven’t discussed here: a certain
amount of fuzzing the <code class="highlighter-rouge">i_ce</code> line.  Specifically, I ticked the clock once with
<code class="highlighter-rouge">i_ce</code> valid, and then ticked it some (random) number of additional clocks with
<code class="highlighter-rouge">i_ce</code> equal to zero–just to see if it affected the behavior of the core.
(It didn’t)</p>

<p>All of this put together gives us confidence that this
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay element</a>
works as designed.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We’ve still got lots of other problems and examples to work through,
but it’s always fun to pick a simple one to go over that every one can
understand.</p>

<p>For now, let’s think about what can be done with a
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">delay element</a>.
We’ve already discussed one example above:
synchronizing to a packet based upon a
<a href="https://en.wikipedia.org/wiki/Syncword">preamble</a>.
That wasn’t my purpose in building
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/delayw.v">this element</a>
today, though.  My own purpose is to allow me to measure the
<a href="https://en.wikipedia.org/wiki/Spectral_density">Power Spectral Density (PSD)</a>
in a waveform input—but we’ll leave that discussion for another day.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>But and if that evil servant shall say in his heart, My lord delayeth his coming ... (Matt 24:48)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstreeam FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
