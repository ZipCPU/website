<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Generating more than one bit at a time with an LFSR</title>
  <meta name="description" content="This is now our third post onLinear Feedback Shift Registers(LFSRs).Ourfirst postexamined how to generate aLinear Feedback Shift Register(LFSR)in Verilog, an...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2017/11/13/lfsr-multi.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Generating more than one bit at a time with an LFSR</h1>
    <p class="post-meta"><time datetime="2017-11-13T00:00:00-05:00" itemprop="datePublished">Nov 13, 2017</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>This is now our third post on
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">Linear Feedback Shift Registers
(LFSRs)</a>.
Our
<a href="/dsp/2017/10/27/lfsr.html">first post</a>
examined how to generate a
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">Linear Feedback Shift Register
(LFSR)</a>
in Verilog, and our
second post
walked through an example of a 5-bit
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>.
However, neither of these developments have solved the problem I had
initially.</p>

<table style="float: right"><caption>Fig 1: System Identification Setup</caption><tr><td><img src="/img/chanid.svg" alt="System setup for System ID: one FPGA creates a noise source, the other examines it" width="320" /></td></tr></table>

<p>As you may recall, I wanted to use an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
to do <a href="https://en.wikipedia.org/wiki/System_identification">channel
estimation</a>.
My intention was to use a setup like Fig 1 to the right.  My plan is to
transmit <a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom bits</a>
out of an <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
output pin at the fastest speed I can:
<a href="https://www.xilinx.com/support/documentation/data_sheets/ds181_Artix_7_Data_Sheet.pdf">950 Mbps</a>
on my
<a href="https://www.xilinx.com/support/documentation/data_sheets/ds180_7Series_Overview.pdf">Artix-7</a>
<a href="https://store.digilentinc.com/arty-artix-7-fpga-development-board-for-makers-and-hobbyists/">Arty</a>
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a> board.
I’ll then receive the bits at the other end of a
<a href="https://store.digilentinc.com/pmod-cable-kit-12-pin">12” pmod cable</a>
representing my channel, and examine the waveform at the other end to get
an <a href="https://en.wikipedia.org/wiki/System_identification">estimate of the channel throughput and
distortion</a>.</p>

<p>Indeed, if all goes well I should be able to apply <a href="https://en.wikipedia.org/wiki/Channel_capacity">Shannon’s Capacity
theorem</a> to determine the
maximum speed of <a href="https://store.digilentinc.com/pmod-cable-kit-12-pin">the
channel</a>.</p>

<p>To do this, though, I need a source of
<a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom bits</a>.
Worse, <a href="/dsp/2017/10/27/lfsr.html">our last attempt</a>
at generating
<a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom bits</a> only
generated one bit per clock, and I will need several bits per clock in order
to drive an output serializer at high speed.</p>

<p>So let’s return to our <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">Fibonacci LFSR
generator</a>
and see if we can <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v">modify it to produce more than one output per clock
period</a>.
We’ll keep the setup identical to
<a href="/dsp/2017/10/27/lfsr.html">our first post</a>,
so the only thing that needs to change today is the number of outputs
bits we need to generate.  We’ll start with describing how we’ll go about
getting these extra bits, and then discuss the code that implements this.
We’ll also do one more: let’s <em>formally prove</em> at the end of our development,
that our resulting implementation actually works.</p>

<h2 id="getting-that-next-bit">Getting that next bit</h2>

<p>Our task is create an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
that produces <code class="highlighter-rouge">WS</code> bits at a time–rather than just one.  (<code class="highlighter-rouge">WS</code>= Word Size)
The question, though, is how shall we do this?</p>

<table style="float: right"><caption>Fig 2: Example LFSR</caption><tr><td><img src="/img/lfsr-fib5.svg" alt="An example 5-tap LFSR" width="360" /></td></tr></table>

<p>We’ll use the
<a href="/dsp/2017/11/11/lfsr-example.html">example</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
<a href="/dsp/2017/11/11/lfsr-example.html">we presented earlier</a>
for discussion and as an example along the way.  You can see
<a href="/dsp/2017/11/11/lfsr-example.html">this example</a>
in Fig 2 at the right.  It’s a simple five stage
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>,
with a feedback equation defined by <code class="highlighter-rouge">TAPS=5'b00101</code>.</p>

<p>Let’s begin our development by imagining an infinite stream of (constant)
bits in our shift register, <code class="highlighter-rouge">sreg</code>.  Each of these bits satisfies the
relationship given by the Fibonacci
<a href="https://en.wikipedia.org/wiki/Finite_field">GF(2)</a> equation
we started with.  When we presented this equation, we had bits <code class="highlighter-rouge">MSB:0</code> defined
and we just needed to calculate the next bit, <code class="highlighter-rouge">MSB+1</code>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="n">sreg</span><span class="p">[</span><span class="n">MSB</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">sreg</span><span class="p">[</span><span class="n">MSB</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">TAPS</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>You may also remember, from the discussion of an
<a href="/dsp/2017/11/11/lfsr-example.html">example</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>, that these
<code class="highlighter-rouge">MSB:0</code> bits have no required relationship between them–save that they cannot
all be zero.</p>

<p>Now let’s see what it will take to calculate bit <code class="highlighter-rouge">MSB+2</code>.  We can start with
our equation for the next bit, and apply it to bits <code class="highlighter-rouge">[MSB+1:1]</code> to get bit
<code class="highlighter-rouge">MSB+2</code>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="n">sreg</span><span class="p">[</span><span class="n">MSB</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>     <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">sreg</span><span class="p">[</span><span class="n">MSB</span><span class="o">+</span><span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">TAPS</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>We’ll have to get rid of the reference to <code class="highlighter-rouge">sreg[MSB+1]</code>, though, before this
equation will be useful for us.</p>

<p>To get there, let’s split this new equation into two parts.</p>

<table style="float: right"><caption>Fig 3: One more bit</caption><tr><td><img src="/img/lfsr-fib5-x1.svg" alt="Getting one extra bit from a 5-tap LFSR" width="420" /></td></tr></table>

<p>The first part will be due to the bits in <code class="highlighter-rouge">sreg[MSB:1]</code>.  We can represent
this part as <code class="highlighter-rouge">sreg[MSB:0]&amp;(TAPS&lt;&lt;1)</code>.  This represents the bits that we already
know.  You can see this how this would affect our
<a href="/dsp/2017/11/11/lfsr-example.html">example</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
in Fig 3.  If you compare Fig 3 with Fig 2, you can see how the taps to
generate the next bit are the same as the ones shown in Fig 2, save only that
they’ve been moved one stage to the left.</p>

<p>The <a href="/dsp/2017/11/11/lfsr-example.html">LFSR in our example</a>
is simple enough that we can apply this same technique
to even get a second bit from the taps we were given, as Fig 4 below shows.</p>

<table align="center" style="float: none"><caption>Fig 4: Two more bits</caption><tr><td><img src="/img/lfsr-fib5-x2.svg" alt="The second extra bit" width="480" /></td></tr></table>

<p>Where the <a href="/dsp/2017/11/11/lfsr-example.html">example</a>
falls apart is when you need to reference a bit that isn’t present in the
original shift register.  For that, we need to move to the second part of
our equation.</p>

<p>This second part, <code class="highlighter-rouge">sreg[MSB+1]&amp;TAPS[MSB]</code> will
need some work.  In this case, though, we already have an equation for
<code class="highlighter-rouge">sreg[MSB+1]</code> (above).  Therefore we can substitute that equation for
<code class="highlighter-rouge">sreg[MSB+1]</code> into our equation for <code class="highlighter-rouge">sreg[MSB+2]</code> in order to get a new
expression for <code class="highlighter-rouge">sreg[MSB+2]</code> that depends only upon <code class="highlighter-rouge">sreg[MSB:0]</code>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="n">sreg</span><span class="p">[</span><span class="n">MSB</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>     <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">sreg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TAPS</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span> <span class="o">^</span> <span class="p">(</span><span class="n">TAPS</span><span class="p">[</span><span class="n">MSB</span><span class="p">]</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sreg</span> <span class="o">&amp;</span> <span class="n">TAPS</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>Perhaps a picture will explain this better.  Consider Fig 5 below.</p>

<table align="center" style="float: none"><caption>Fig 5: Getting a third bit</caption><tr><td><img src="/img/lfsr-fib5-x3.svg" alt="Getting a bit not described by the initial register taps" width="540" /></td></tr></table>

<p>In this figure, you can see the remains of the taps that were being shifted
to the left, and a broken reference to a bit that isn’t in our set from
<code class="highlighter-rouge">MSB:0</code>.  However, instead of adding the bit we don’t have, we instead
add the equation for that bit.  The result is that our new bit, in this
<a href="/dsp/2017/11/11/lfsr-example.html">example</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
depends upon three bits from our shift register, instead of just the two.</p>

<p>Let’s simplify this expression a touch further, though.
If we take another look at the equation above, we can now use the <a href="https://en.wikipedia.org/wiki/Distributive_property">distributive
property</a>
to collect our terms.  Specifically, we’ll factor out the <code class="highlighter-rouge">sreg</code> term to the
left, and the values multiplied by the <code class="highlighter-rouge">sreg</code> vector together into a new
term on the right,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="n">sreg</span><span class="p">[</span><span class="n">MSB</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>     <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">sreg</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">TAPS</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">TAPS</span><span class="p">[</span><span class="n">MSB</span><span class="p">]</span> <span class="o">?</span> <span class="n">TAPS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)))</span><span class="o">;</span></code></pre></figure>

<p>In this equation, the portion of our expression to the right of
the <code class="highlighter-rouge">&amp;</code> looks very much like an expression similar to our expression for
<code class="highlighter-rouge">sreg[MSB+1]</code>.  Specifically, this right half expression looks like a vector
that, when taken as an inner product with <code class="highlighter-rouge">sreg</code>, produces our result–just
like the <code class="highlighter-rouge">TAPS</code> vector did for <code class="highlighter-rouge">sreg[MSB+1]</code>.  Even better, this vector
is a constant–depending only upon the <code class="highlighter-rouge">TAPS</code> parameter.  Let’s use this.
We’ll define <code class="highlighter-rouge">tapv[0]</code> to be our <code class="highlighter-rouge">TAPS</code>, and then <code class="highlighter-rouge">tapv[1]</code> to be this value.</p>

<p>We can then repeat this derivation.  Doing so will reveal a formula for
<code class="highlighter-rouge">tapv[k+1]</code> based upon <code class="highlighter-rouge">tapv[k]</code>.  In particular,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="n">tapv</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tapv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">tapv</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MSB</span><span class="p">]</span> <span class="o">?</span> <span class="n">TAPS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)))</span><span class="o">;</span></code></pre></figure>

<p>This <code class="highlighter-rouge">tapv</code> array is the key we need to build our code below.</p>

<h2 id="a-multi-step-lfsr-implementation">A Multi-Step LFSR Implementation</h2>

<p>Now that we have an equation for future output bits, it’s time to
build our multi-step shift register.  Feel free to
follow along in the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v">code we’re creating
here</a>, as
we’ll only discuss the basic highlights below.</p>

<p>Our goal is to extend <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">our origianal
Fibonacci</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">code</a>
to output <code class="highlighter-rouge">WS</code> bits per clock, where <code class="highlighter-rouge">WS</code> is given by a parameter.
This means we’ll need to calculate <code class="highlighter-rouge">WS-1</code> more bits than we did the
<a href="/dsp/2017/10/27/lfsr.html">last time</a>.  It also means
that our shift register, which only used to be <code class="highlighter-rouge">LN</code> bits long, will now need
to have <code class="highlighter-rouge">LN+(WS-1)</code> elements in it.  Of these, we’ll use the bottom <code class="highlighter-rouge">WS</code> bits
as our output bits.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">o_word</span><span class="o">=</span><span class="n">sreg</span><span class="p">[</span><span class="n">WS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>But I’m getting ahead of myself.  Before we can get to <code class="highlighter-rouge">o_word</code>, there’s a
lot of other work to be done first.</p>

<p>We’ll start with the equations we just worked out in the last section.  We’ll
place these <code class="highlighter-rouge">tapv[]</code> values into an array of <code class="highlighter-rouge">WS</code> elements, each as
wide as our underlying
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>,
or <code class="highlighter-rouge">LN</code> bits long.</p>

<p>The first of these equations is the one we’ve used before, <code class="highlighter-rouge">tapv[0]</code>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">tapv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TAPS</span><span class="o">;</span></code></pre></figure>

<p>From here we can use the recursive equation derived above to get the rest,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">genvar</span>	<span class="n">k</span><span class="o">;</span>
	<span class="k">generate</span> <span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">WS</span><span class="o">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">PRECALCULATING_TAP_VALUE</span>
		<span class="k">assign</span>	<span class="n">tapv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tapv</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="p">((</span><span class="n">tapv</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">][(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span><span class="o">?</span><span class="n">TAPS</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>If you didn’t manage to follow the development of these equations above,
don’t worry.  We’ll
“<a href="https://en.wikipedia.org/wiki/Formal_verification">prove</a>”
these equations work below in the next section.</p>

<p>The next trick is the reset value.</p>

<p>You may remember before, when we had one new bit per time step, that we set
our state space to an <code class="highlighter-rouge">INITIAL_FILL</code> value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">reset_value</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INITIAL_FILL</span><span class="o">;</span></code></pre></figure>

<p>This reset value then dictated the first <code class="highlighter-rouge">LN</code> bits out of our device.</p>

<p>This won’t quite work for our multi-step core.  First, the <code class="highlighter-rouge">INITIAL_FILL</code>
vector needs to have <code class="highlighter-rouge">WS-1</code> additional elements to it.  Then, to make matters
worse, all of those bits need to maintain the
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
relationship between them.  So while the statement above works for the first
<code class="highlighter-rouge">LN</code> bits, we’ll still need to determine the next <code class="highlighter-rouge">WS-1</code> bits.</p>

<p>We can get these next several bits of the <code class="highlighter-rouge">reset_value</code> by running the first
several bits of the <code class="highlighter-rouge">reset_value</code> through <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">our
Fibonacci</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
equation.  This is a zero cost operation: every part of this equation
is known and constant.  Therefore the synthesizer can simplify the code
before our core ever gets mapped to logic.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span>
	<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">WS</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">CALC_RESET</span>
		<span class="k">assign</span>	<span class="n">reset_value</span><span class="p">[(</span><span class="n">LN</span><span class="o">+</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">reset_value</span><span class="p">[</span> <span class="n">k</span> <span class="o">+:</span> <span class="n">LN</span><span class="p">]</span><span class="o">&amp;</span><span class="n">TAPS</span><span class="p">)</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>While this works well to develop <code class="highlighter-rouge">reset_value</code>, it doesn’t work as well
as an initial value for our <code class="highlighter-rouge">sreg</code>.  We’d like to say,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">initial</span>	<span class="n">sreg</span> <span class="o">=</span> <span class="n">reset_value</span><span class="o">;</span></code></pre></figure>

<p>However, this only works with some synthesizers, such as
<a href="http://www.clifford.at/yosys">yosys</a>,
and not with others, like
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>.
For those others, we’ll set <code class="highlighter-rouge">sreg</code> initially to
<code class="highlighter-rouge">INITIAL_FILL &lt;&lt; (WS-1)</code>, and then
use <code class="highlighter-rouge">reset_value</code> for any subsequent resets.  This will still give us the
same sequence, with the only problem being that the first <code class="highlighter-rouge">WS-1</code> values
will be zero instead of those associated with the fill.</p>

<p>Now that we have our tap equations, <code class="highlighter-rouge">tapv[]</code>, and our <code class="highlighter-rouge">reset_value</code>, we can
now move on to the state register itself.  In the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">typical</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>,
all but one bit of the new state register is known.  These known bits are
given by shifting the register one step to the right, whereas the last bit
is generated by the <code class="highlighter-rouge">TAPS</code> equation.</p>

<p>Let’s do the same thing here and shift these known bits first,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">reset_value</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
			<span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">+</span><span class="n">WS</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="n">WS</span><span class="p">]</span><span class="o">;</span></code></pre></figure>

<p>Those are the easy bits.</p>

<p>After those easy bits, our first next bit is determined by the
original Fibonacci
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
equation.  That’s the one we built into our first <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">Fibonacci
LFSR</a> module.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">sreg[MSB] &lt;= ^(sreg &amp; TAPS);</code></pre></figure>

<p>The rest of the bits are calculated in the same fashion, with the exception
that the equation for them, in particular the <code class="highlighter-rouge">tapv[k]</code> coefficients,
is different from one bit to the next.  So, our next step is then to
walk through those extra bits applying the <code class="highlighter-rouge">tapv[k]</code> equations as appropriate
to generate each new bit.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span>
	<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">WS</span><span class="o">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">RUN_LFSR</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
				<span class="n">sreg</span><span class="p">[</span><span class="n">LN</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">reset_value</span><span class="p">[</span><span class="n">LN</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
				<span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">&lt;=</span>
					<span class="o">^</span><span class="p">(</span><span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">+</span><span class="n">WS</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">WS</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">&amp;</span><span class="n">tapv</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Did you notice how we also cycled through the various <code class="highlighter-rouge">tapv[k]</code> expressions?
This is just implementing the equations we calculated above.</p>

<p>That’s it.  It’s still simple, but there is just a little more simple involved
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v">in this version</a>
over the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">last
version</a>.</p>

<p>Put together, we just calculated <code class="highlighter-rouge">LN+WS-1</code> bits.  <code class="highlighter-rouge">LN-1</code> of these are
calculated the same as before–by shifting the shift register.  The next bit
is still calculated by our original <code class="highlighter-rouge">TAPS</code> equation, just like we did with
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">our initial Fibonacci implementation</a>.
The last <code class="highlighter-rouge">WS-1</code> bits were then calculated in the
exact same way with the only exception being that the equation, <code class="highlighter-rouge">tapv[k]</code>,
changed on a bit-by-bit basis.</p>

<p>But, let’s come back to our earlier question, will this really “work”?  Will
all these equations really produce the sequence we want?</p>

<p>To answer that question, let’s see if we can get the computer to
“<a href="https://en.wikipedia.org/wiki/Formal_verification">prove</a>”
that <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v">this new
form</a> works.</p>

<h2 id="applying-formal-methods">Applying Formal Methods</h2>

<p>I discussed the basics of using
<a href="https://en.wikipedia.org/wiki/Formal_verification">formal methods</a>
using <a href="https://www.clifford.at/yosys">yosys-smtbmc</a> in a
<a href="/blog/2017/10/19/formal-intro.html">previous post</a>.
The basic idea behind
<a href="https://en.wikipedia.org/wiki/Formal_verification">formal methods</a>
is to define a state space, and within it the space of invalid states.
The state space is initially defined by all of the register values within
your design.  It is restricted further, made smaller that is, with <code class="highlighter-rouge">assume</code>
statements as necessary.  Invalid states are defined as well, but this time
using the <code class="highlighter-rouge">assert</code> statement.  We’ll use these two statements, <code class="highlighter-rouge">assume</code> and
<code class="highlighter-rouge">assert</code> with the ultimate goal of
<a href="https://en.wikipedia.org/wiki/Formal_verification">proving</a>
that the logic above will <em>never</em> enter into an illegal state.</p>

<p><a href="https://en.wikipedia.org/wiki/Formal_verification">These formal methods</a>
are particularly appropriate for this multi-bit
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
design, since
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s
are so mathematically based.  In particular, the output of the
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
needs to strictly satisfy a mathematical equation–one that the
<a href="https://en.wikipedia.org/wiki/Formal_verification">formal equation solver</a>
can verify for us.</p>

<p>As <a href="/blog/2017/10/19/formal-intro.html">before</a>,
we’ll use <a href="https://www.clifford.at/yosys">yosys</a>
to generate a list of properties in a
<a href="http://stp.github.io/smt-input-language/">format</a> that
<a href="http://yices.csl.sri.com">yices</a> can understand.  When processing a file in
this manner, <a href="https://www.clifford.at/yosys">yosys</a> will define the <code class="highlighter-rouge">FORMAL</code>
pre-processor directive for us.  That allows us to begin our <code class="highlighter-rouge">FORMAL</code>
verification section with an <code class="highlighter-rouge">ifdef</code>,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">FORMAL</span></code></pre></figure>

<p>Our plan will be to then use <a href="https://www.clifford.at/yosys">yosys-smtbmc</a>
to then drive the <a href="http://yices.csl.sri.com">yices</a> theorem prover to prove
that our
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v">multi-step</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a> actually
works.</p>

<p>The first step is to restrict the search state space.</p>

<p>We’ll use the <a href="/blog/2017/10/19/formal-intro.html">approach
we presented before</a>
to create a clock, and an <code class="highlighter-rouge">f_past_valid</code> flag.  This latter flag will tell
us whenever the <code class="highlighter-rouge">$past()</code> directive will yield valid results.</p>

<p>Now using that assumed clock, our first
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
specific step will restrict the space of all possibilities by
simply assuming that <code class="highlighter-rouge">i_reset</code> is true on startup.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="k">assume</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Next, we’ll assert that the bottom <code class="highlighter-rouge">LN</code> bits are equal to the <code class="highlighter-rouge">INITIAL_FILL</code>
on the clock following any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)))</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INITIAL_FILL</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>Now that we’ve dealt with the <code class="highlighter-rouge">i_reset</code> case, we can move on to the regular
register bits.</p>

<p>The first test is whether or not the first of the new register bits,
bit <code class="highlighter-rouge">LN-1</code>, is valid.  This bit is the one produced via the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">original Fibonacci
configuration</a>
<a href="/dsp/2017/10/27/lfsr.html">we presented before</a>.
Here we’ll just apply it to the values left in our
shift register, plus the one we just shifted out–the one still found in
<code class="highlighter-rouge">$past(sreg[WS-1])</code>.  Note that this wouldve been <code class="highlighter-rouge">$past(sreg[0])</code> in our
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr_fib.v">previous
version</a>, but
since we are now generating another <code class="highlighter-rouge">WS-1</code> bits, that last bit shifted out
is no longer the <code class="highlighter-rouge">0</code> bit from before.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">i_ce</span><span class="p">)))</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">sreg</span><span class="p">[</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="o">==</span> <span class="o">^</span><span class="p">(</span><span class="o">{</span><span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">,</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">sreg</span><span class="p">[</span><span class="n">WS</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">}</span>
					<span class="o">&amp;</span> <span class="n">TAPS</span><span class="p">))</span><span class="o">;</span></code></pre></figure>

<p>Our new implementation also defines another <code class="highlighter-rouge">WS-1</code> bits that we want to
validate.  Because this is a very mathematically defined
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>,
there’s a mathematical relationship between all of these bits.  All we
need to do to
<a href="/blog/2017/10/19/formal-intro.html">formally validate</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v">this code</a>
is to check our current state bits against the equation that was supposed
to generate them one at a time.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">generate</span>
	<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">WS</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)))</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">sreg</span><span class="p">[</span><span class="n">LN</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="o">^</span><span class="p">(</span><span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">k</span><span class="p">)</span><span class="o">:</span><span class="n">k</span><span class="p">]</span><span class="o">&amp;</span><span class="n">TAPS</span><span class="p">))</span><span class="o">;</span>
	<span class="k">endgenerate</span></code></pre></figure>

<p>This is the majority of the proof.  If this works, all of our <code class="highlighter-rouge">tapv[]</code> work
will be verified.</p>

<p>There is one more vital part to our proof: we need to prove that <code class="highlighter-rouge">sreg</code>
will never be equal to zero.  You may recall when we
<a href="/dsp/2017/10/27/lfsr.html">last discussed</a>
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>s
that we highlighted the problem with a
zero register: once the register <code class="highlighter-rouge">sreg</code> becomes zero (if ever) then it will
cease to produce
<a href="https://en.wikipedia.org/wiki/Pseudorandomness">pseudorandom</a>
numbers.  We’ll allow the <a href="http://yices.csl.sri.com">theorem prover</a>
to verify that this never happens.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">sreg</span><span class="p">[(</span><span class="n">LN</span><span class="o">+</span><span class="n">WS</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="n">WS</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">;</span></code></pre></figure>

<p>That’s the last of the file, and the last of the proof.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`endif</span>	<span class="c1">// FORMAL
</span><span class="k">endmodule</span></code></pre></figure>

<p>All that’s left is to run the
<a href="https://www.clifford.at/yosys">theorem prover</a>
and see how we did!</p>

<p>In case you haven’t been following along, you can find the example file we
just created
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v">here</a>.  You
can also find the <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/formal/Makefile">Makefile</a>
and other files associated with driving the
<a href="http://yices.csl.sri.com">formal theorem prover</a>
<a href="https://github.com/ZipCPU/dspfilters/tree/master/bench/formal">here</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Now that I have an
<a href="https://wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/lfsr.v">implementation</a>
that I can step 8-14 times per clock, I should be able to create a high speed
data stream from one
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
and send it to another.  The difference between what the second
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
observes and what was actually sent will be any channel effects.  In other
words, I’m now ready to move my
<a href="https://en.wikipedia.org/wiki/System_identification">channel identification</a>
problem forward one step to measure just how much information can be reasonably
stuffed through this
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>
<a href="https://store.digilentinc.com/pmod-cable-kit-12-pin">I/O channel</a>.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>For man also knoweth not his time: as the fishes that are taken in an evil net, and as the birds that are caught in the snare; so are the sons of men snared in an evil time, when it falleth suddenly upon them. (Eccl 9:12)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
