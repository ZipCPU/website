<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Spectrograms need Window Functions</title>
  <meta name="description" content="If you are going to be doing DSP on anFPGA, chances are you are going to want to know if yourDSP is working.  That requires beingable to visualize what’s goi...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2020/11/21/spectrogram.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102570964-1', 'auto');
  ga('send', 'pageview');

</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Spectrograms need Window Functions</h1>
    <p class="post-meta"><time datetime="2020-11-21T00:00:00-05:00" itemprop="datePublished">Nov 21, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>If you are going to be doing <a href="/dsp/dsp.html">DSP</a> on an
FPGA, chances are you are going to want to know if your
<a href="/dsp/dsp.html">DSP</a> is working.  That requires being
able to visualize what’s going on somehow.</p>

<p>How shall waveforms be visualized?</p>

<p>Perhaps the easiest answer, when dealing with audio rate signals, is not to
visualize them at all but just to play the sound into a set of headphones.  It’s
amazing how good the ear is at picking up sound quality–both good and bad.
The only problem is that while ears are good at telling you if there is a
problem, they’re not nearly as good for identifying the problem.  Worse,
from the standpoint of this blog, it’s hard to be communicate subtle
differences in sound within an article like this one.</p>

<p>Perhaps the next best answer is to visualize the waveform in time.  This works
okay enough for some sounds.  For example, it’s not that hard to find when
certain percussion instruments strike, but there’s often more to percussive
instruments than just the striking itself.  How, for example, shall a
<a href="https://en.wikipedia.org/wiki/Marimba">marimba</a> be differentiated from a
<a href="https://en.wikipedia.org/wiki/Snare_drum">snare drum</a> or a
<a href="https://en.wikipedia.org/wiki/Xylophone">xylophone</a> for example?</p>

<p>As an example, consider the
<a href="https://en.wikipedia.org/wiki/Humpback_whale">humpack whale</a> song shown in
Fig. 1 below.</p>

<table align="center" style="float: none"><caption>Fig 1. Humpback whale song in time</caption><tr><td><img src="/img/windowfn/humpbacksong-time.png" alt="" width="567" /></td></tr></table>

<p>Judging from this picture alone, what can you determine?  While I’m not trained
in <a href="https://en.wikipedia.org/wiki/Whale_vocalization">whale song</a>,
I can see that this whale has spoken twice in this clip, but that’s about it.</p>

<p>Were we examining music, a musician would want to know what notes are being
played and when.  This is great too, except … not all
“<a href="https://en.wikipedia.org/wiki/C_(musical_note)#Middle_C">middle C</a>”s sound the
same.  A piano playing a
<a href="https://en.wikipedia.org/wiki/C_(musical_note)#Middle_C">middle C</a>
sounds different from a
<a href="https://en.wikipedia.org/wiki/Trumpet">trumpet</a>, from a
<a href="https://en.wikipedia.org/wiki/Pipe_organ">pipe organ</a>, a
<a href="https://en.wikipedia.org/wiki/Clarinet">clarinet</a>, a
<a href="https://en.wikipedia.org/wiki/Flute">flute</a>, etc.  This information would
need to be able to be visualized somehow as well.</p>

<p>While I’m not a recording studio engineer, I’ve been told that there’s a big
difference between studio silence and other types of silence.  For example,
is your house really quiet when the dishwasher, laundry, and refrigerator are
all running?  How will you know your recording is good enough that these
background noises have been properly removed?</p>

<p>The problem isn’t limited to music, either, nor is it limited to the human
hearing range.  What about
<a href="https://en.wikipedia.org/wiki/Whale_vocalization">whale song</a> or
<a href="https://en.wikipedia.org/wiki/Seismology">seismic analysis</a>?  Or, for that
matter, what about microwave
<a href="https://en.wikipedia.org/wiki/Radar">radar</a>
analysis?  How shall you know if a
<a href="https://en.wikipedia.org/wiki/Radar">radar</a>,
or even a
<a href="https://en.wikipedia.org/wiki/Radar_jamming_and_deception">radar jammer</a> for
that matter, is producing the right waveform by looking at it?
You can’t listen to it–it’s too wideband, neither will it necessarily “sound”
like anything you might recognize.  (<a href="https://www.youtube.com/watch?v=B9K4N328OI8">I’ve known people who have found ways of
doing this anyway …</a>.)</p>

<p>As an example of what <a href="https://en.wikipedia.org/wiki/Spectral_density_estimation">spectral
analysis</a> might show, consider Fig. 2 below, showing the same
<a href="https://en.wikipedia.org/wiki/Whale_vocalization">whale song</a>
from Fig. 1 above.</p>

<table align="center" style="float: none"><caption>Fig 2. Humpback whale song spectra</caption><tr><td><img src="/img/windowfn/humpbacksong-an.png" alt="" width="567" /></td></tr></table>

<p>In this image, time goes from left to right, and frequency from DC at the
bottom to about 9kHz on the vertical axis.  From here, you can see that the
two whale sounds have very different spectral features.  In the first,
the whale has emitted a rough tone.  In the second, the whale has changed the
sound of the tone, and hence you can see the introduction of harmonics.
Further, there’s a bit of a sweep to the second tone.</p>

<p>Whales can also emit a series of clicks.  Fig. 3 below shows a series of
<a href="https://en.wikipedia.org/wiki/Humpback_whale">humpack whale</a>
clicks–also using the same spectral representation.</p>

<table align="center" style="float: none"><caption>Fig 3. Humpback whale click spectra</caption><tr><td><img src="/img/windowfn/humpbackclicks-an.png" alt="" width="567" /></td></tr></table>

<p>Now consider the <a href="https://en.wikipedia.org/wiki/Bowhead_whale">bowhead whale</a>
spectra, shown in Fig. 4 below.</p>

<table align="center" style="float: none"><caption>Fig 4. Bowhead whale spectra</caption><tr><td><img src="/img/windowfn/bowhead-an.png" alt="" width="567" /></td></tr></table>

<p>From here, you can see that the
<a href="https://en.wikipedia.org/wiki/Bowhead_whale">bowhead</a>
has a much higher pitch, and also that there are much larger frequency sweeps.</p>

<p>Would you have been able to see these details without dividing the signal into
time and frequency?</p>

<p>No, and that’s the bottom line: you’re going to want to do some type of
<a href="https://ieeexplore.ieee.org/document/679147">time-varying spectral analysis</a>
when processing signals.  The purpose of
<a href="https://ieeexplore.ieee.org/document/679147">time-varying spectral analysis</a>
is to determine the frequency content of a particular signal, and see
how that frequency content changes with time–much like we did with
the examples of the
<a href="https://en.wikipedia.org/wiki/Whale_vocalization">whale song</a> above.</p>

<p>Some time ago, we discussed a <a href="/dsp/2020/03/17/cheap-spectra.html">super cheap way of doing spectral
analysis</a>.
While this approach can work nicely in some circumstances–such as when
examining <a href="https://en.wikipedia.org/wiki/Stationary_process">stationary
processes</a>, it’s not a
<a href="https://en.wikipedia.org/wiki/Real-time_computing">real-time method</a>
for the simple reason that part of the algorithm involves
dropping data.  Sure, it’s useful for debugging, but it’s not very useful
for seeing how a signal’s spectral content develops and changes over time.</p>

<p>For all these reasons, let’s take a look today at the traditional way of
doing this within an FPGA:
<a href="https://en.wikipedia.org/wiki/Window_function">windowed</a>
<a href="/dsp/2018/10/02/fft.html">FFTs</a>.
Before we get there, though, let’s back up and develop the concept of a
<a href="https://en.wikipedia.org/wiki/Spectral_density">spectral density</a>.</p>

<h2 id="what-is-a-power-spectral-density">What is a Power Spectral Density</h2>

<p>One of the key purposes of
<a href="https://en.wikipedia.org/wiki/Spectral_density">spectral density</a>
estimation is to find out where the energy in a signal lies spectrally.
For this reason, let’s start back at the beginning and discuss both
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
and <a href="https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density">power spectral densities
(PSDs)</a>.</p>

<p>Let’s start at the top.  The voltage drop across a resistor, from <a href="https://en.wikipedia.org/wiki/Ohm%27s_law">Ohm’s
law</a>, is given by the product
of the current going through the resistor times the resistance of the resistor.</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-ohms-law.png" alt="" width="102" /></td></tr></table>

<p>The <a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
being consumed by this same resistor is given by
<img src="/img/windowfn/expr-p-is-vi.png" alt="P=VI" />.  Hence,
if you know the voltage and the resistance across which it is measured, then
you know the
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a> to be,</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-ohms-power.png" alt="" width="208" /></td></tr></table>

<p>You can use a <a href="https://en.wikipedia.org/wiki/Voltmeter">voltmeter</a>,
or even an <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">analog to digital
converter</a>, to
measure voltage, so let’s work with that.  Let’s say we do this and get samples,
<img src="/img/windowfn/expr-xn.png" alt="`x[n]`" />, from our <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">A/D
converter</a>.
<a href="https://en.wikipedia.org/wiki/Power_(physics)">Power</a> is then related to,</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-sampled-power.png" alt="" width="327" /></td></tr></table>

<p>where the <code class="language-plaintext highlighter-rouge">(scale factor)</code> captures the impact of both the
<a href="https://en.wikipedia.org/wiki/Resistor">resistor</a> and the <a href="https://en.wikipedia.org/wiki/Sampling_(signal_processing)#Sampling_rate">sample
rate</a>.
This scale factor is important when converting from
<a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">A/D</a> units
representing quantized values to true
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
measured in Watts, but for now we’re going to ignore it so that we can focus on
the algorithms used to separate this energy into separate frequency components.
In other words, now that I’ve noted the existence of this scale factor, I’m
going to drop it entirely from the discussion that follows.</p>

<p>The <img src="/img/windowfn/expr-1-over-n.png" alt="1/N" />
term comes from the simple fact that
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a> is a unit of
average energy per unit of time.  If, at every time instant, we get a new
<img src="/img/windowfn/expr-abs-x-n-squared.png" alt="`|x[n]|^2`" /> value,
then our
“<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>”
would appear to increase even if
<img src="/img/windowfn/expr-abs-x-n-squared.png" alt="`|x[n]|^2`" />
were constant and all these values were the same.  Indeed,
<img src="/img/windowfn/expr-abs-x-n-squared.png" alt="`|x[n]|^2`" />
is a measure of <a href="https://en.wikipedia.org/wiki/Energy"><em>energy</em></a>, not
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>.
Hold on to that thought, though, we’ll come back to it in a moment.</p>

<p>For now, let’s increase our averaging interval until we are averaging across
all time.  This then becomes the total
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
in our signal, and it allows us to talk about and reason about
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
that might change over time while still having a measure of total
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>.</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-total-power.png" alt="" width="349" /></td></tr></table>

<p>Now that we have this expression for the
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
measured by an
<a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">A/D</a>,
we’d like to know how much of this
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a> was captured in a
spectrally significant ways  Can we split this summation over frequency instead
of time?  Ideally, we’d like something that both measures our total
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>,
yet also isolates that
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
by frequency.  This is the purpose of the <a href="https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density">Power Spectral Density Function
(PSD)</a>.</p>

<p>How shall we get there?  Simple, let’s take a <a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier
transform</a> of the
elements of this summation.  We’ll start by letting
<img src="/img/windowfn/expr-Fx.png" alt="`F{x[n]}`" /> represent the
<a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier transform</a>
of our input.</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-spectral-operator.png" alt="" width="439" /></td></tr></table>

<p>The <a href="https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density">PSD</a>
of the signal, <img src="/img/windowfn/expr-p-of-expf.png" alt="`P(e^{j2pif})`" />
is then just the square of this value.</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-power-at-f.png" alt="" width="271" /></td></tr></table>

<p>This is where we run into our first problem.  What happened to the
<img src="/img/windowfn/expr-1-over-n.png" alt="1/N" /> term?
The answer is, we got sloppy and dropped it.  Worse, our
<a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier transform</a>
summation above doesn’t converge when we apply it either to a constant signal
or a constantly varying signal.  No, we’ll need to back up and rework this.
In particular, we’ll need to be explicit about the limits in our
<a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier transform</a>.</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-spectral-suboperator.png" alt="" width="450" /></td></tr></table>

<p>If we insist that
<img src="/img/windowfn/expr-N.png" alt="`N`" />
be finite, we’ll know that the transform converges.</p>

<p>We can now apply <a href="https://en.wikipedia.org/wiki/Parseval%27s_theorem">Parseval’s
theorem</a>, knowing that the
integral of this |X(f)|^2 function should give us back our total
<a href="https://en.wikipedia.org/wiki/Energy">energy</a>, and that
<a href="https://en.wikipedia.org/wiki/Energy">energy</a> averaged over time is
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>.</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-spectral-energy.png" alt="" width="335" /></td></tr></table>

<p>Therefore,</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-power-density-limit.png" alt="" width="367" /></td></tr></table>

<p>and</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-total-spectral-power.png" alt="" width="424" /></td></tr></table>

<table align="center" style="float: right"><tr><td><img src="/img/windowfn/rule-conservation-of-energy.svg" alt="" width="480" /></td></tr></table>

<p>This leads to the first important rule of
<a href="https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density">PSD</a>
estimation: No <a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
should be accidentally gained or lost during our analysis.  Our goal must be
to preserve this total received power measurement.</p>

<p>What happens, though, if we only look at a band of frequencies instead?</p>

<table align="center" style="float: right"><tr><td><img src="/img/windowfn/eqn-power-in-bw.png" alt="" width="318" /></td></tr></table>

<table align="center" style="float: left; padding: 20px"><tr><td><img src="/img/windowfn/rule-spectral-localization.svg" alt="" width="480" /></td></tr></table>

<p>We’d then have an estimate of how much
<a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
lied between these frequencies.</p>

<p>If you then take the limit of this power measurement as the bandwidth goes
to zero, you’ll get a
<a href="https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density">PSD</a>.</p>

<p>Sadly, this infinite limit over time makes the
<a href="https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density">PSD</a>
difficult to work with, if for no other reason than it’s impossible to sample
a signal for all time in order to estimate its
<a href="https://en.wikipedia.org/wiki/Spectral_density#Power_spectral_density">PSD</a>.
So, what if we didn’t take the limit as
<img src="/img/windowfn/expr-N-to-infty.png" alt="N-&gt;Infty" />?
We’d then have an <em><a href="https://en.wikipedia.org/wiki/Energy">energy</a></em> measurement,
rather than a <a href="https://en.wikipedia.org/wiki/Power_(physics)">power</a>
measurement.  Not only that, but our
measurements suddenly get a lot more practical to work with.</p>

<p>For example, if our signal were limited to
<img src="/img/windowfn/expr-N.png" alt="`N`" /> samples rather than an
infinite number, then we could use a <a href="https://en.wikipedia.org/wiki/Discrete-time_Fourier_transform">discrete time Fourier transform
(DTFT)</a> instead.</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-esd-defn.png" alt="" width="503" /></td></tr></table>

<p>Now we’re getting somewhere, right?  This is something I can calculate, and
a value I can use!</p>

<p>Only … it’s not that useful.</p>

<p>The problem has to do with our limits.  Our original signal was unlimited
in time.  We then arbitrarily forced limits in time upon it.  This will
cause spectral energy to spill from one frequency region to another.
The solution to this problem is to use a spectral taper, sometimes called
a <a href="https://en.wikipedia.org/wiki/Window_function">window function</a>.</p>

<h2 id="the-short-time-fourier-transform">The Short-Time Fourier Transform</h2>

<p>There have been a lot of discussions regarding how to ideally decompose a
signal into time and frequency.  One reference I’ve enjoyed has been <a href="https://www.amazon.com/Time-Frequency-Analysis-Theory-Applications/dp/0135945321">Cohen’s
book on Time-Frequency Analysis</a>.  It does a nice job of providing a good
overview of the topic.  That said, the first thing Cohen does is to reject
the <a href="https://en.wikipedia.org/wiki/Short-time_Fourier_transform">Short Time Fourier
Transform</a>
based methods for other more generic quadratic methods–methods that don’t even
preserve the concept of <a href="https://en.wikipedia.org/wiki/Energy"><em>energy</em></a>
in the first place.  Most of the methods he discusses will produce both
positive and negative
“<a href="https://en.wikipedia.org/wiki/Energy"><em>energy</em></a>” estimates.</p>

<table align="center" style="float: right"><tr><td><img src="/img/windowfn/scharfs-rules.svg" alt="" width="480" /></td></tr></table>

<p>Negative energy?  That doesn’t make any sense.  Sorry, but I’ll need another
approach.</p>

<p>The next important spectral estimation reference is <a href="http://ieeexplore.ieee.org/document/679147/">Scharf, Friedlander
and Mullis’ paper, Time-varying spectrum
estimators</a>, which works
out the form of the ideal spectral estimator from first principles.  If you
are interested in this topic, I would highly recommend this paper to you before
any other references.  By insisting that energy should always be non-negative,
<a href="http://ieeexplore.ieee.org/document/679147/">Scharf, et.al.</a>, are able to
drastically limit the kind of spectral estimation algorithms that need
to be examined.  By further limiting the set of all possible <a href="http://ieeexplore.ieee.org/document/679147/">time-varying
spectral estimators</a>
to only those which preserve our understanding of both time and frequency,
they are able to limit the set of spectral estimators to the
set of estimator’s generated by <a href="https://en.wikipedia.org/wiki/Window_function">multiple-taper
windows</a>.</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-multi-taper.png" alt="" width="559" /></td></tr></table>

<p>I’d like to add to this discussion the proof that, if you want the maximum
<a href="https://en.wikipedia.org/wiki/Uncertainty_principle">time-frequency
resolution</a>,
then <em>nothing</em> beats a <a href="https://en.wikipedia.org/wiki/Window_function">single
taper</a> representation.</p>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-single-taper.png" alt="" width="525" /></td></tr></table>

<p>There’s a nice proof available for this, so it’s something we may need to come
back to later.
Getting there, however, will take some work–so let’s just look at how to
implement a single taper estimate in the first place.  For that, we want
to look into how to implement the single-taper implementation known as a
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a>.</p>

<p>Here’s the basic idea of how this works:</p>

<ol>
  <li>
    <p>We’ll break a stream of incoming data into chunks, each the size of one
<a href="/dsp/2018/10/02/fft.html">FFT</a> and
each separated by
<img src="/img/windowfn/expr-D.png" alt="`D`" /> samples.
If <img src="/img/windowfn/expr-DltN.png" alt="`D &lt; N`" />
then there will necessarily be some amount of overlap between
these various chunks.</p>

    <p><img src="/img/windowfn/eqn-data-chunk.png" alt="`CHUNK[nD] = x[nD-(N-1)], ... x[nD]`" /></p>

    <p>We’ll come back to this in a moment, but for now remember that 50%
overlap is easy to build and (often) sufficient for most purposes.</p>
  </li>
  <li>
    <p>We’ll then apply our
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a>
to each chunk of data.</p>

    <p><img src="/img/windowfn/eqn-windowed-raw.png" alt="`WINDOWED[nD] = h[N-1]x[nD-(N-1)], ... h[0]x[nD]`" /></p>

    <p>As a notational simplification, if we insist that
<img src="/img/windowfn/eqn-hk-eq-zero.png" alt="`h[k] = 0`" /> for
<img src="/img/windowfn/ineq-k-lt-zero.png" alt="`k&lt;0`" /> or
<img src="/img/windowfn/ineq-k-geq-N.png" alt="`k&gt;=N`" />,
then we might just refer to
<img src="/img/windowfn/expr-hk-xnD-k.png" alt="`h[k]x[nD-k]`" />.</p>

    <p><img src="/img/windowfn/eqn-windowed-data.png" alt="`WINDOWED[nD] = ... h[k]x[nD-k] ...`" /></p>

    <p>You might also note that this
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a>
is starting to look like a <a href="/dsp/2017/08/19/simple-filter.html">digital
filter</a>.  That’s
because it <em>is</em> a <a href="/dsp/2017/09/15/fastfir.html">digital FIR
filter</a>.  Indeed, one of
<a href="http://ieeexplore.ieee.org/document/1162950/">Allen’s observations</a> is
that a <a href="https://en.wikipedia.org/wiki/Window_function">windowed</a>
<a href="/dsp/2018/10/02/fft.html">Fourier transform</a>
produces a series of filtered, downconverted,
and <a href="/dsp/2020/07/28/down-sampler.html">downsampled</a>
outputs.</p>
  </li>
  <li>
    <p>As a final step, we’ll apply an
<a href="/dsp/2018/10/02/fft.html">FFT</a> to that
<a href="https://en.wikipedia.org/wiki/Window_function">windowed</a>
chunk of data, and report and record the results.</p>
  </li>
</ol>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-ym.png" alt="" width="371" /></td></tr></table>

<p>To do this in a useful fashion, there are a couple of basic criteria you’ll
need:</p>

<ol>
  <li>
    <p>The <a href="https://en.wikipedia.org/wiki/Window_function">window function</a>,
h[k], needs to be a <a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass
filter</a> with a strong
<a href="https://en.wikipedia.org/wiki/Stopband">stopband</a> rejection.</p>

    <p>While they may not be <em>optimal</em>, most of your traditional
<a href="https://en.wikipedia.org/wiki/Window_function">window functions</a>
meet this criteria:
<a href="https://en.wikipedia.org/wiki/Hann_function">Hann</a>,
<a href="https://en.wikipedia.org/wiki/Window_function#Blackman_window">Blackman</a>,
<a href="https://en.wikipedia.org/wiki/Window_function#Hamming_window">Hamming</a>,
<a href="https://en.wikipedia.org/wiki/Window_function#Triangular_window">Bartlett</a>,
<a href="http://ieeexplore.ieee.org/document/1163506/">etc.</a></p>
  </li>
  <li>
    <p>To satisfy the requirements of the <a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">Nyquist sampling
theorem</a>,
it is important that the step size be related to the cutoff frequency of the
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass filter</a>.
In general, this means that
<img src="/img/windowfn/expr-D.png" alt="`D`" />
must be less than or equal to
<img src="/img/windowfn/expr-N-over-2.png" alt="`N/2`" />.</p>

    <p>This choice is actually related to the <a href="https://en.wikipedia.org/wiki/Window_function">window
function</a> design.
What should the cutoff frequency of the
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a> be?
One might argue that the ideal
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a>
would isolate various signal frequency components to their nearest bins.
For example, if a tone were anywhere within a frequency bin, it should
then create a response in that bin and that bin only.  Such a
<a href="https://en.wikipedia.org/wiki/Window_function">window</a>
would be a <a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass filter</a>
with a cutoff frequency of
<img src="/img/windowfn/expr-half-bin.png" alt="`1/2/N`" />, an
infinitesimal <a href="https://en.wikipedia.org/wiki/Transition_band">transition
band</a>, and an infinite
<a href="https://en.wikipedia.org/wiki/Stopband">stopband</a> rejection.</p>

    <p>If you’ve studied digital filter design at all, you’d recognize this
filter requirement as the first filter that gets studied–and then rejected
because it is unrealizable due to its infinite length.</p>

    <p><a href="/dsp/freq-teaser.html">Better windows</a> exist.</p>

    <p>If we instead compromised and allowed
<a href="https://en.wikipedia.org/wiki/Energy">energy</a> to spill a little bit
from one bin to the next, then we might allow
<a href="https://en.wikipedia.org/wiki/Energy">energy</a>
to spill into the two FFT bins on either side of any bin of interest.
As a tone moved from one bin to the next, the decomposed
spectral <a href="https://en.wikipedia.org/wiki/Energy">energy</a>
should also transition from one bin to the next.  This requires a filter
with a <a href="https://en.wikipedia.org/wiki/Stopband">stopband</a> region starting at
<img src="/img/windowfn/expr-1-over-n.png" alt="`1/N`" />,
but here’s the key criteria:
we don’t need a <a href="https://en.wikipedia.org/wiki/Passband">passband</a>.
The <em>entire</em> band of interest could be within the
<a href="https://en.wikipedia.org/wiki/Transition_band">transition band</a>
of this filter.  That makes the filter realizable.</p>

    <p>It also means we want to sample the output at twice this rate in order
to avoid any <a href="https://en.wikipedia.org/wiki/Aliasing">aliasing</a>,
which then brings us back to a minimum 50% overlap.</p>
  </li>
</ol>

<table align="center" style="float: left; padding: 15px"><tr><td><img src="/img/windowfn/zero-padding.svg" alt="" width="480" /></td></tr></table>

<p>While zero padding in time can help to create the illusion of better
   frequency resolution, you can also increase your overlap amount to create
   a similar illusion of better time resolution.  In this case, the right
   answer depends upon the cutoff frequency of your
   <a href="https://en.wikipedia.org/wiki/Window_function">window function</a>,
   and the sample rate required to avoid losing information.  As an example,
   when using a <a href="https://en.wikipedia.org/wiki/Hann_function">Hann</a> window,
   you might want to set
   <img src="/img/windowfn/eqn-D-N4.png" alt="`D=N/4`" /> to create a 75%
   overlap.  This will keep your spectral data from suffering any
   <a href="https://en.wikipedia.org/wiki/Aliasing">aliasing</a> artifacts.</p>

<p>The problem with using a greater overlap is simple: you end up with more
   data to process.  That is, if you have an incoming sample rate of
   <img src="/img/windowfn/expr-Rs.png" alt="`R_s`" />, and
   you set the decimation factor to
   <img src="/img/windowfn/eqn-D-N2.png" alt="`D=N/2`" />, you’ll now have
   a data rate that you need to process that’s twice as fast, or
   <img src="/img/windowfn/expr-two-Rs.png" alt="`2Rs`" />.  If you set
   <img src="/img/windowfn/eqn-D-N4.png" alt="`D=N/4`" /> on the other hand,
   you now have to process a data stream at a rate of
   <img src="/img/windowfn/expr-four-Rs.png" alt="`4Rs`" />, four times
   as fast as the original data stream.  While you can do this to avoid the
   <a href="https://en.wikipedia.org/wiki/Aliasing">aliasing</a>
   problems associated with the
   <a href="https://en.wikipedia.org/wiki/Hann_function">Hann</a> window,
   <a href="https://en.wikipedia.org/wiki/Window_function">window</a>,
   there are <a href="/dsp/freq-teaser.html">better
   window functions</a>
   with tighter cutoffs.</p>

<p>Still, the <a href="https://en.wikipedia.org/wiki/Hann_function">Hann</a>
   <a href="https://en.wikipedia.org/wiki/Window_function">window</a> will
   be a nice one to work with when using the algorithm that follows.  Indeed,
   it is one of my favorites among the classic
   <a href="https://en.wikipedia.org/wiki/Window_function">window</a> functions for the
   simple reason that it is fairly easy to analyze.</p>

<ol start="3">
  <li>
    <p>The important part of
<a href="/dsp/freq-teaser.html">window function</a>
selection is to make sure that whatever
<a href="/dsp/freq-teaser.html">window</a>
you choose, it should preserve the conservation of
energy principle that we started with.  That is, when we are done, we’ll
want to make certain that,</p>

    <p><img src="/img/windowfn/eqn-final-ptotal.png" alt="`PTOTAL = LIMIT N-&gt; INFTY (1/N) |ym[n]|^2`" /></p>

    <p>This is one of the drawbacks of most of your traditional
<a href="/dsp/freq-teaser.html">window functions</a>,
to include my favorite <a href="https://en.wikipedia.org/wiki/Hann_function">Hann</a>
<a href="/dsp/freq-teaser.html">window</a>.
Most of these functions will over or undercount certain spectral or temporal
energy.  The solution would be to use a root-Nyquist filter, of which
<a href="https://en.wikipedia.org/wiki/Root-raised-cosine_filter">Root-Raised
cosine filters</a>
are the best known subset despite their poor out-of-band performance.</p>
  </li>
  <li>
    <p>At this point, if we have a
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass</a>
<a href="/dsp/freq-teaser.html">windowing function</a>,
together with better than Nyquist sampling, together with our conservation
of energy requirement, we know that our
<a href="/dsp/freq-teaser.html">window function</a>
will localize the energy in the incoming signal to
a particular band.  Even better, we can take summations across multiple
band outputs to estimate the amount of energy limited by those spectral
bands.</p>
  </li>
</ol>

<table align="center" style="float: none"><tr><td><img src="/img/windowfn/eqn-psdhat-sum.png" alt="hat{P}BS(m/N) = SUM^{k=-BW/2}^{BW/2} |ym+k[n]|^2" width="243" /></td></tr></table>

<p>This was one of our success criteria, and it looks like we’ve achieved it.</p>

<p>It’s actually better than that.  Not only can we localize
<a href="https://en.wikipedia.org/wiki/Energy">energy</a> spectrally, but we can also
locate <a href="https://en.wikipedia.org/wiki/Energy">energy</a>
in time.  Hence, we have a <a href="http://ieeexplore.ieee.org/document/679147/">time–varying spectral energy
estimator</a> as desired.</p>

<p>Pretty cool, huh?</p>

<p>Curiously, the conservation of energy criteria together with the
<a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass filter</a>
cutoff criteria are sufficient for the transform to be invertible.
See <a href="http://ieeexplore.ieee.org/document/1162950/">Allen</a> or
<a href="https://www.amazon.com/Multirate-Digital-Signal-Processing-Crochiere/dp/0136051626">Crochiere</a>
for more information on this.</p>

<p>For now, the question I would like to focus on today is how the basic
<a href="https://en.wikipedia.org/wiki/Short-time_Fourier_transform">Windowed</a>
<a href="/dsp/2018/10/02/fft.html">FFT</a>
structure should be implemented within an FPGA.</p>

<h2 id="implementation-overview">Implementation Overview</h2>

<p>Let’s start out with just a simple and general overview of how a spectral
analysis design might work.</p>

<p>As with any data processing design, the data processing is typically done
within some tight data loop, where the first step is to grab data.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Get some number of data samples</span>
		<span class="n">get_adc_data</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span></code></pre></figure>

<p>If the data isn’t (yet) ready, the easy answer is to stall within this
function until a sufficient amount of data becomes ready.  Once a buffer is
ready, then it can be returned and further processed.</p>

<p>For the sake of discussion today, we’ll assume this buffer is a buffer of
<code class="language-plaintext highlighter-rouge">double</code> while working in C++.  Of course, we’ll have to change that to
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed point</a>
once we switch to Verilog, but I’m likely to gloss over any difference
in details between the two–even though the difference between
<a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">floating</a> and
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed point</a>
formats is far from inconsequential.</p>

<p>Once we have our data samples, we’ll apply our
<a href="/dsp/freq-teaser.html">window function</a>
as described above and as we’ll discuss further below.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Apply a window function</span>
		<span class="n">apply_window</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span></code></pre></figure>

<p>The result of applying a
<a href="/dsp/freq-teaser.html">window function</a>
to our new data is a buffer of data, sized to the size of our
<a href="/dsp/2018/10/02/fft.html">FFT</a>,
which we then send directly into the
<a href="/dsp/2018/10/02/fft.html">FFT</a>.
For now, let’s assume the incoming data buffer size is the same as the
<a href="/dsp/2018/10/02/fft.html">FFT</a> size–and fix this
in a second design attempt further down.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Take an FFT of the results</span>
		<span class="n">fft</span><span class="p">(</span><span class="n">FFTSIZE</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span></code></pre></figure>

<p>We now have the results of an
<a href="/dsp/2018/10/02/fft.html">FFT</a>, only we can’t plot them.
<a href="/dsp/2018/10/02/fft.html">FFT</a>s return
complex data: there’s both <a href="https://en.wikipedia.org/wiki/Complex_number">real and imaginary
components</a>.  There’s no easy
way to plot
<a href="https://en.wikipedia.org/wiki/Complex_number">complex</a>
data like that.  However, as described above, we don’t
really want
<a href="https://en.wikipedia.org/wiki/Complex_number">complex</a>
data: we want the absolute value squared of our data.
Therefore, we want to replace our data with its absolute value squared.
Optionally, we could also convert the result to
<a href="https://en.wikipedia.org/wiki/Decibel">Decibels</a> at this time as well.
(Note that this transformation is non-linear, so you may wish to keep a copy of
the original signal around when you do this.)</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Calculate absolute magnitude squared</span>
		<span class="c1">// of the complex results</span>
		<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span> <span class="n">FFTSIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">buffer</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>  <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span>  <span class="p">]</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span>  <span class="p">];</span>
			<span class="n">buffer</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>

			<span class="c1">// Optionally, convert to decibels</span>
			<span class="c1">// buffer[k] = 20 * log(buffer[k]) / log(10.0);</span>
		<span class="p">}</span></code></pre></figure>

<p>You might notice that I’m not being consistent here: I’m mixing real data and
<a href="https://en.wikipedia.org/wiki/Complex_number">complex</a>
data together.  Were the original data set real, the
<a href="/dsp/2018/10/02/fft.html">FFT</a> might return the
DC component in <code class="language-plaintext highlighter-rouge">buffer[0]</code> and the <code class="language-plaintext highlighter-rouge">N/2</code> component in <code class="language-plaintext highlighter-rouge">buffer[1]</code>.  In that
case, it would be inappropriate to mix these two components together.
Likewise, if the original data were
<a href="https://en.wikipedia.org/wiki/Complex_number">complex</a> that were then
<a href="https://en.wikipedia.org/wiki/Fourier_transform">Fourier transformed</a>,
you might now want to apply an <a href="/dsp/2018/10/02/fft.html">FFT</a>
shift to place the DC value in the center of the band.  I’m just glossing over
these details for now because it’s not the focus of what
I really want to discuss–the implementation of the
<a href="/dsp/freq-teaser.html">window function</a> itself.</p>

<p>The next step, required prior to displaying any spectral energy data, is to
scale it to what the screen can display.  For a graph plot, this might also
mean adjusting the vertical axis so things can fit.  For rastered time
varying energy spectral data, you’ll need to scale the data so that it then
represents an index into a color map–something we can discuss again in another
article.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Possibly scale the results</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OPTIONALLY_SCALE</span><span class="p">)</span>
			<span class="n">scale</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span></code></pre></figure>

<p>Finally, at this point, we can now plot our buffer and repeat this whole
process for the next incoming data buffer.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">		<span class="c1">// Plot the result</span>
		<span class="n">plot</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
	<span class="err">}</span></code></pre></figure>

<p>If you are curious what these steps might look like in Verilog, check out the
<a href="https://github.com/ZipCPU/fftdemo/blob/master/rtl/main.v">main verilog file</a>
from this <a href="https://github.com/ZipCPU/fftdemo">FFT raster demonstration</a>.
The biggest difference is that FPGAs operate on live data <em>streams</em> rather
than data <em>blocks</em>–but the concepts remain the same.</p>

<p>So now that we’ve looked over the context of how a
<a href="/dsp/freq-teaser.html">window function</a> might fit
into a larger algorithm, how should it be implemented?  It’s really
simple: we’d take our data, and multiply each sample of it by the
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a>
before returning it.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">double</span>	<span class="n">m_window</span><span class="p">[</span><span class="n">FFTSIZE</span><span class="p">];</span>

<span class="kt">void</span>	<span class="nf">apply_window</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">FFTSIZE</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
		<span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_window</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>If we could keep the algorithm that simple, then it would also be quite easy to
implement in Verilog.  All we’d need to do would be to multiply every
incoming sample by the
<a href="https://en.wikipedia.org/wiki/Window_function">window</a>’s
coefficient to create an outgoing sample.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span> <span class="c1">// For every incoming sample ...</span>
<span class="k">begin</span>
	<span class="c1">// 1. Calculate a windowed outgoing sample</span>
	<span class="n">o_sample</span> <span class="o">&lt;=</span> <span class="n">cmem</span><span class="p">[</span><span class="n">tidx</span><span class="p">]</span> <span class="o">*</span> <span class="n">i_sample</span><span class="p">;</span>

	<span class="c1">// 2. Mark the following outgoing sample as valid</span>
	<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// 3. Increment the index into our coeffficient table</span>
	<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="n">tidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// 4. Mark the first outgoing sample</span>
	<span class="n">o_frame</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">tidx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
	<span class="c1">// Clear the outgoing valid signal, making certain it's</span>
	<span class="c1">// only ever high for one cycle.</span>
	<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>This rudimentary implementation has a couple of problems, however.  One
problem is that you can’t read from block RAM and use the result on the same
cycle.  A second more fundamental problem is the fact that this
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a>
implementation doesn’t handle any overlap.</p>

<p>So let’s back up and discuss how we might handle overlap for a moment.</p>

<p>At a minimum, we need to keep track of the last half
<a href="/dsp/2018/10/02/fft.html">FFT</a>’s
worth of incoming data.  That will require a buffer.  Practically, we have
to keep track of more than just the last half of the
<a href="/dsp/2018/10/02/fft.html">FFT</a>’s incoming data, since
it will be hard to capture the next half
<a href="/dsp/2018/10/02/fft.html">FFT</a>’s
worth of data without destroying the data we still need to use along the way.</p>

<p>Therefore, let’s start out with a buffer the size of a full
<a href="/dsp/2018/10/02/fft.html">FFT</a>,
and an index into where the most recent data is within that buffer.  This
will allow us to use one half of the buffer, while reading new data into the
second half.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span>	<span class="n">m_loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="c1">// Index into our buffer</span>
<span class="kt">double</span>	<span class="n">m_window</span><span class="p">[</span><span class="n">FFTSIZE</span><span class="p">];</span>	<span class="c1">// Window function coefficients</span>
<span class="kt">double</span>	<span class="n">m_data</span><span class="p">[</span><span class="n">FFTSIZE</span><span class="p">;</span>		<span class="c1">// Data buffer</span></code></pre></figure>

<p>Now, every time we get <code class="language-plaintext highlighter-rouge">N/2</code> samples, herein noted as <code class="language-plaintext highlighter-rouge">FFTSIZE/2</code>, we’ll call
our <code class="language-plaintext highlighter-rouge">apply_window()</code> function.  This function will consume <code class="language-plaintext highlighter-rouge">FFTSIZE/2</code> samples,
and then produce <code class="language-plaintext highlighter-rouge">FFTSIZE</code> windowed samples as outputs.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">//</span>
<span class="c1">// FFTSIZE/2 data comes in, filling the first FFTSIZE/2 samples of the</span>
<span class="c1">// given buffer.  The input buffer's size, however, must be FFTSIZE in</span>
<span class="c1">// length to handle the returned window data</span>
<span class="c1">//</span>
<span class="kt">void</span>	<span class="nf">apply_window</span><span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span>	<span class="n">pos</span><span class="p">;</span>
	<span class="kt">double</span>	<span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">tap</span><span class="p">,</span> <span class="o">*</span><span class="n">inp</span><span class="p">,</span> <span class="o">*</span><span class="n">outp</span><span class="p">;</span></code></pre></figure>

<p>The first task of this function will be to copy the new data into the
oldest position in our buffer.  If we keep the new data location aligned
with the overlap, then this copy can be done quite simply.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">// Add the input to our buffers ...</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_loc</span><span class="p">];</span>
	<span class="n">inp</span> <span class="o">=</span> <span class="n">input</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pos</span><span class="o">&lt;</span><span class="n">FFTSIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">pos</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">inp</span><span class="o">++</span><span class="p">;</span></code></pre></figure>

<p>If the new data amount wasn’t a factor of the
<a href="/dsp/2018/10/02/fft.html">FFT</a>
size, we would’ve then also needed to check for overflowing the end of our
buffer in the middle of the loop.  With an exact 50% overlap, though, we can
skip that check.</p>

<p>We’ll then advance the data location pointer by a half
<a href="/dsp/2018/10/02/fft.html">FFT</a>
length, and force it to stay within one
<a href="/dsp/2018/10/02/fft.html">FFT</a>’s size.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">m_loc</span> <span class="o">+=</span> <span class="n">FFTSIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">m_loc</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">FFTSIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>We now have a full
<a href="/dsp/2018/10/02/fft.html">FFT</a>’s
worth of data to apply our
<a href="https://en.wikipedia.org/wiki/Window_function">window</a> to.  This data
will either be the <code class="language-plaintext highlighter-rouge">m_data</code> buffer itself, or the two halves of the <code class="language-plaintext highlighter-rouge">m_data</code>
buffer in reversed order.  That means we’d need to apply the
<a href="https://en.wikipedia.org/wiki/Window_function">window</a> one half at a time.</p>

<p>So, let’s start with the first half–the half that starts out with the data
left in the buffer from the last <a href="https://en.wikipedia.org/wiki/Window_function">window
function</a>
invocation.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="c1">// Apply the filter to generate a block for FFT'ing</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_loc</span><span class="p">];</span>
	<span class="n">outp</span> <span class="o">=</span> <span class="n">input</span><span class="p">;</span>
	<span class="n">tap</span> <span class="o">=</span> <span class="n">m_window</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pos</span><span class="o">&lt;</span><span class="n">FFTSIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">pos</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">outp</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">*</span> <span class="o">*</span><span class="n">tap</span><span class="o">++</span><span class="p">;</span></code></pre></figure>

<p>Again, because we’ve guaranteed that <code class="language-plaintext highlighter-rouge">m_loc</code> is either 0 or <code class="language-plaintext highlighter-rouge">FFTSIZE/2</code>, we
don’t need to check for pointer boundaries within this loop.</p>

<p>To handle the next half, we’ll need to update our data pointer.  This will
either leave it the same, or set it to the first half.  We can then loop
over the second half.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">	<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m_data</span><span class="p">[</span><span class="n">m_loc</span> <span class="o">^</span> <span class="p">(</span><span class="n">FFTSIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
	<span class="k">for</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pos</span><span class="o">&lt;</span><span class="n">FFTSIZE</span><span class="p">;</span> <span class="n">pos</span><span class="o">++</span><span class="p">)</span>
		<span class="o">*</span><span class="n">outp</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">*</span> <span class="o">*</span><span class="n">tap</span><span class="o">++</span><span class="p">;</span>
<span class="err">}</span></code></pre></figure>

<p>Voila!  We’ve just accomplished a <a href="https://en.wikipedia.org/wiki/Window_function">window
function</a>
while handling overlap.</p>

<p>How would we do this from Verilog?</p>

<p>Well, the first difference is that we’ll always have data coming in–whether
or not we’re ready for it.  That data will need to be stored into our buffer.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">dwidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="c1">// Data write index</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">dmem</span><span class="p">[</span><span class="n">dwidx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span>
		<span class="n">dwidx</span> <span class="o">&lt;=</span> <span class="n">dwidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>The next big problem will be how to handle the data rate change–data comes into
our algorithm at one rate, and it must go out at twice that rate.  To handle
that, I’m going to create two “clock enable” inputs: <code class="language-plaintext highlighter-rouge">i_ce</code>, for when valid
data comes in, and <code class="language-plaintext highlighter-rouge">i_alt_ce</code>, to describe the pipeline between valid data
samples.  Our rule will be that <code class="language-plaintext highlighter-rouge">i_alt_ce</code> must be high once, and only once,
between every pair of clocks having <code class="language-plaintext highlighter-rouge">i_ce</code> high.  That way we have a data
stream clocking signal handling both clocks.  You can see an example of what
this might look like in Fig. 5 for an 8-point
<a href="/dsp/2018/10/02/fft.html">FFT</a>.</p>

<table align="center" style="float: none"><caption>Fig 5. Two separate incoming CE signals, one outgoing CE signal</caption><tr><td><img src="/img/windowfn/wintrace.svg" alt="" width="780" /></td></tr></table>
<p><!-- about 9+4=13 wide --></p>

<p>Hence, for every incoming sample, <code class="language-plaintext highlighter-rouge">i_ce</code>, we’ll create an outgoing clock
enable.  Likewise for every incoming <code class="language-plaintext highlighter-rouge">i_alt_ce</code>, we’ll also create an outgoing
clock enable.  Further, at the beginning of every outgoing burst we’ll set an
<code class="language-plaintext highlighter-rouge">o_frame</code> signal to indicate the first clock cycle in the frame.
This alternate data valid signal, <code class="language-plaintext highlighter-rouge">i_alt_ce</code>, could easily be set to a one-clock
delayed version of <code class="language-plaintext highlighter-rouge">i_ce</code>.  I’ve chosen not to do that here, lest the output
need to go through a “slow” DSP processing engine that depends upon a
minimum number of idle clocks between outgoing samples.</p>

<p>You’ll also notice from Fig. 5 that the output starts with the first
four samples from the last <a href="/dsp/2018/10/02/fft.html">FFT</a>,
followed by the new four samples.  In the picture, these last four samples
are listed as <code class="language-plaintext highlighter-rouge">WX0</code> through <code class="language-plaintext highlighter-rouge">WX3</code>, whereas the new ones are listed as
<code class="language-plaintext highlighter-rouge">wD0</code> through <code class="language-plaintext highlighter-rouge">wD3</code>.  In the second block of data, those same samples are listed
as <code class="language-plaintext highlighter-rouge">WD0</code> through <code class="language-plaintext highlighter-rouge">WD3</code>–since they’ve now been multiplied by the second half
of the window function.</p>

<p>Having two clock enable signals, whether <code class="language-plaintext highlighter-rouge">i_ce</code> or <code class="language-plaintext highlighter-rouge">i_alt_ce</code>, will mean that
we need to update our internal indexes anytime either is true.  This would
lead to an indexing algorithm looking (almost) like:</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span> <span class="o">||</span> <span class="n">i_alt_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="n">tidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// Coefficient index</span>
		<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">didx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="c1">// Data index</span>
	<span class="k">end</span></code></pre></figure>

<p>That would be the first clock of our processing.  Once we know which data
to read and what memory to read it from, we’d then read from the two
memories–both data and coefficient.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">data</span> <span class="o">&lt;=</span> <span class="n">dmem</span><span class="p">[</span><span class="n">didx</span><span class="p">];</span>
		<span class="n">tap</span>  <span class="o">&lt;=</span> <span class="n">cmem</span><span class="p">[</span><span class="n">tidx</span><span class="p">];</span>
	<span class="k">end</span></code></pre></figure>

<p>On the next clock, now that we have both of these values, we can multiply
them together to get the window product we want to create.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">o_sample</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">*</span> <span class="n">tap</span><span class="p">;</span></code></pre></figure>

<p>We could then use a simple shift register to determine when an outgoing
sample should be valid.  We’ll use <code class="language-plaintext highlighter-rouge">d_ce</code> to represent when our data is valid,
<code class="language-plaintext highlighter-rouge">p_ce</code> to represent when our product is valid, and <code class="language-plaintext highlighter-rouge">o_ce</code> to represent when
the outgoing sample is valid.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">o_ce</span><span class="p">,</span> <span class="n">p_ce</span><span class="p">,</span> <span class="n">d_ce</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">p_ce</span><span class="p">,</span> <span class="n">d_ce</span><span class="p">,</span> <span class="p">(</span><span class="n">i_ce</span> <span class="o">||</span> <span class="n">i_alt_ce</span><span class="p">)</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Sounds easy enough, right?  Fig. 6 shows how some of these respective CE
signals might relate.</p>

<table align="center" style="float: none"><caption>Fig 6. A more detailed trace</caption><tr><td><img src="/img/windowfn/detailed-trace.svg" alt="" width="780" /></td></tr></table>
<p><!-- about 9+4=13 wide --></p>

<p>Not quite.</p>

<p>The first problem is the data index.  While it should go through the data
from <code class="language-plaintext highlighter-rouge">0...N-1</code> the first time through, we want to go through
samples <code class="language-plaintext highlighter-rouge">N/2...N-1, 0 ... N/2-1</code> the second time through.  We’ll then want
to alternate between these two index sequences.</p>

<p>How shall we know which sequence to use at any given time?  For that, we can
use the data writing index.  On the last sample of any window set, following
the last <code class="language-plaintext highlighter-rouge">i_ce</code> in the set, the data write index will then be set to write
a new sample to the next buffer.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_alt_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span>
	<span class="k">begin</span></code></pre></figure>

<p>We can then use this write index as an indication that the data sample
<em>read</em> index should be adjusted.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Restart on the first point of the next FFT</span>
		<span class="n">didx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="c1">// Maintain the top bit, so as to keep</span>
		<span class="c1">// the overlap working properly</span>
		<span class="n">didx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span></code></pre></figure>

<p>For all other samples, though, we’ll simply increment the data read
index as before.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_alt_ce</span><span class="p">))</span>
		<span class="c1">// Process the next point in this FFT</span>
		<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">didx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>Indeed, our process really shouldn’t be any more complicated than that.</p>

<h2 id="window-function-details">Window Function Details</h2>

<p>With all that background behind us, let’s turn our attention to the detailed
design and implementation of <a href="https://github.com/ZipCPU/dblclockfft/blob/master/rtl/windowfn.v">this window
function</a>.</p>

<table align="center" style="float: right"><caption>Fig 7. Window Function port diagram</caption><tr><td><img src="/img/windowfn/blockd.svg" alt="" width="360" /></td></tr></table>
<p><!-- about 9+4=13 wide --></p>

<p>We’ve gone over most of the ports already, so the port list of this function
shouldn’t be too surprising.</p>

<p>The one item we haven’t discussed yet is a mechanism for updating the
coefficients of the window function.  In this case, I’ve chosen to use
the <code class="language-plaintext highlighter-rouge">i_tap_wr</code> interface to indicate that a new coefficient is available
in <code class="language-plaintext highlighter-rouge">i_tap</code> to write into the filter.  I suppose I could have used a more
general purpose block RAM interface, but I’ve chosen this interface to be
consistent with those faster filters that can’t handle the block RAM interface.</p>

<p>We’ve discussed the rest of the ports above: <code class="language-plaintext highlighter-rouge">i_clk</code> and <code class="language-plaintext highlighter-rouge">i_reset</code> should
be self explanatory.  <code class="language-plaintext highlighter-rouge">i_ce</code> will be true for every incoming data value, and
<code class="language-plaintext highlighter-rouge">i_alt_ce</code> will need to be true once between every pair of <code class="language-plaintext highlighter-rouge">i_ce</code> values as
shown in Figs. 5 and 6 above.  When the output is ready, <code class="language-plaintext highlighter-rouge">o_ce</code> will be
asserted and the sample will be placed into <code class="language-plaintext highlighter-rouge">o_sample</code>.  We’ll also note
the first sample in any block by setting <code class="language-plaintext highlighter-rouge">o_frame</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`default_nettype</span>	<span class="n">none</span>
<span class="c1">//</span>
<span class="k">module</span>	<span class="n">windowfn</span><span class="p">(</span><span class="n">i_clk</span><span class="p">,</span> <span class="n">i_reset</span><span class="p">,</span> <span class="n">i_tap_wr</span><span class="p">,</span> <span class="n">i_tap</span><span class="p">,</span>
		<span class="n">i_ce</span><span class="p">,</span> <span class="n">i_sample</span><span class="p">,</span> <span class="n">i_alt_ce</span><span class="p">,</span>
		<span class="n">o_frame</span><span class="p">,</span> <span class="n">o_ce</span><span class="p">,</span> <span class="n">o_sample</span><span class="p">);</span></code></pre></figure>

<p>We’ll allow for an input width of <code class="language-plaintext highlighter-rouge">IW</code> bits, an outgoing width of <code class="language-plaintext highlighter-rouge">OW</code> bits,
and a coefficient width of <code class="language-plaintext highlighter-rouge">TW</code> bits.  (Sorry, but I consider filter
coefficients to be <em>taps</em>, and get my notation confused.  The term <em>tap</em>
more appropriately describes the structure of the filter rather than the
coefficients themselves.  Still, you’ll find <code class="language-plaintext highlighter-rouge">tidx</code> referencing a coefficient
index below, and <code class="language-plaintext highlighter-rouge">TW</code> referencing the bit-width of coefficients here.)
The default implementation will also support an
<a href="/dsp/2018/10/02/fft.html">FFT</a> size of <code class="language-plaintext highlighter-rouge">2^LGNFFT</code>, or
16 samples.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>		<span class="n">IW</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">OW</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">TW</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">LGNFFT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span></code></pre></figure>

<p>Why is the default so short?  It makes coverage easier to check.  That’s all.</p>

<p>If you want to be able to update the coefficients on the fly, then you’ll want
to leave <code class="language-plaintext highlighter-rouge">OPT_FIXED_TAPS</code> at zero.  Likewise, if you want to load the
initial coefficients from a file, we’ll offer an <code class="language-plaintext highlighter-rouge">INITIAL_COEFFS</code> filename
for that purpose.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_FIXED_TAPS</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">parameter</span>		<span class="n">INITIAL_COEFFS</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span></code></pre></figure>

<p>The next optional parameter, <code class="language-plaintext highlighter-rouge">OPT_TLAST_FRAME</code> deserves some more discussion.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">OPT_TLAST_FRAME</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>If you want to convert this design from my own signaling scheme into an
AXI-stream based signaling protocol, you’ll run into a problem with <code class="language-plaintext highlighter-rouge">TLAST</code>.
Yes, most of the conversion is easy.
For example, a small FIFO on the back end can handle stopping the window
on any <a href="https://en.wikipedia.org/wiki/Back_pressure">back pressure</a>.
Just be careful to update the fill of that FIFO
based upon the data going into the front end.  The problem lies with the
<code class="language-plaintext highlighter-rouge">o_frame</code> output.  I’ve chosen to set <code class="language-plaintext highlighter-rouge">o_frame</code> on the first sample of any
data set.  AXI Stream likes a <code class="language-plaintext highlighter-rouge">TLAST</code> value, where <code class="language-plaintext highlighter-rouge">TLAST</code> would be true on
the <em>last</em> item in any data set.  Hence the parameter, <code class="language-plaintext highlighter-rouge">OPT_TLAST_FRAME</code>.</p>

<p>If <code class="language-plaintext highlighter-rouge">OPT_TLAST_FRAME</code> is set, then <code class="language-plaintext highlighter-rouge">o_frame</code> will be set on the last sample
in any <a href="/dsp/2018/10/02/fft.html">FFT</a> frame–overriding my
favorite behavior.</p>

<p>The rest of the port declarations are fairly unremarkable.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span>	<span class="n">AW</span><span class="o">=</span><span class="n">IW</span><span class="o">+</span><span class="n">TW</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_clk</span><span class="p">,</span> <span class="n">i_reset</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_tap_wr</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[(</span><span class="n">TW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_tap</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_ce</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[(</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">i_sample</span><span class="p">;</span>
	<span class="kt">input</span>	<span class="kt">wire</span>			<span class="n">i_alt_ce</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="kt">output</span>	<span class="kt">reg</span>			<span class="n">o_frame</span><span class="p">,</span> <span class="n">o_ce</span><span class="p">;</span>
	<span class="kt">output</span>	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">o_sample</span><span class="p">;</span></code></pre></figure>

<p>As I mentioned above, we’ll need two memories: one for the coefficients, and
one for the
<a href="/dsp/2018/10/02/fft.html">FFT</a> data
itself so that we can maintain proper overlapping.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">TW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">cmem</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGNFFT</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="kt">reg</span>	<span class="p">[(</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">dmem</span>	<span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">LGNFFT</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span></code></pre></figure>

<p>The coefficients themselves can be loaded from a basic <code class="language-plaintext highlighter-rouge">$readmemh</code> function
call.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">//</span>
	<span class="c1">// LOAD THE TAPS</span>
	<span class="c1">//</span>
	<span class="kt">wire</span>	<span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">tapwidx</span><span class="p">;</span>
	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_FIXED_TAPS</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">SET_FIXED_TAPS</span>

		<span class="k">initial</span>	<span class="p">$</span><span class="nb">readmemh</span><span class="p">(</span><span class="n">INITIAL_COEFFS</span><span class="p">,</span> <span class="n">cmem</span><span class="p">);</span>

		<span class="c1">// ...</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">DYNAMICALLY_SET_TAPS</span></code></pre></figure>

<p>The more interesting case is the dynamic handling.</p>

<p>In this case, we’ll need a coefficient writing index.  Then, on any
write to the coefficient memory, we’ll write to the value at this index
and increment it by one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">// Coef memory write index</span>
		<span class="kt">reg</span>	<span class="p">[(</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">r_tapwidx</span><span class="p">;</span>

		<span class="k">initial</span>	<span class="n">r_tapwidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">r_tapwidx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_tap_wr</span><span class="p">)</span>
			<span class="n">r_tapwidx</span> <span class="o">&lt;=</span> <span class="n">r_tapwidx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">INITIAL_COEFFS</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">initial</span> <span class="p">$</span><span class="nb">readmemh</span><span class="p">(</span><span class="n">INITIAL_COEFFS</span><span class="p">,</span> <span class="n">cmem</span><span class="p">);</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_tap_wr</span><span class="p">)</span>
			<span class="n">cmem</span><span class="p">[</span><span class="n">r_tapwidx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_tap</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">tapwidx</span> <span class="o">=</span> <span class="n">r_tapwidx</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>From here, let’s work our way through the algorithm clock by clock in the
pipeline.</p>

<p>Data is available on clock zero.  We’ll need to simply write this to our data
memory and increment the pointer.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">dwidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">dwidx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">dwidx</span> <span class="o">&lt;=</span> <span class="n">dwidx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">dmem</span><span class="p">[</span><span class="n">dwidx</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span></code></pre></figure>

<p>I’m also going to suppress the first block of
<a href="/dsp/2018/10/02/fft.html">FFT</a> data.
This would be the block prior to where a full
<a href="/dsp/2018/10/02/fft.html">FFT</a>’s worth
of data is available.  Hence, on the <code class="language-plaintext highlighter-rouge">first_block</code>, I’ll set a flag noting
that fact, and I’ll then clear it later once we get to the last coefficient
index associated with processing that block.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">first_block</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">first_block</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_alt_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tidx</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">dwidx</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span>
		<span class="n">first_block</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>The next thing I want to keep track of is the top of the block.  That is,
I want a signal set prior to the first data element in any block, that I can
then use as an indication to reset things as part of the next run through any
data.  We’ll call this signal <code class="language-plaintext highlighter-rouge">top_of_block</code>.  We’ll set it when we get the
<code class="language-plaintext highlighter-rouge">i_alt_ce</code> signal just prior to writing the first data value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">top_of_block</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">top_of_block</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_alt_ce</span><span class="p">)</span>
		<span class="n">top_of_block</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tidx</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">((</span><span class="o">!</span><span class="n">first_block</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">dwidx</span><span class="o">==</span><span class="mi">0</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">top_of_block</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Later on, we’ll dig into how to go about verifying this IP core.  In general,
my rule is that anything with a multiply within it cannot be formally verified.
But I’d like to pause here and note that neither the <code class="language-plaintext highlighter-rouge">first_block</code> flag,
nor the <code class="language-plaintext highlighter-rouge">top_of_block</code> flags above involve any multiplies.  Neither did I get
them right the first time I wrote this algorithm.  My point is simply this: just
because you can’t use formal methods to verify all of the functionality of an
IP core, doesn’t mean that you can’t use them at all.  For now, just think
about how much of the logic below can be easily verified formally, and how
much we’d need to verify using other methods.  I think you’ll find as we walk
through this implementation that the majority of it can be nicely verified
formally before you even fire up your simulator.</p>

<p>Let’s now turn our attention to the data and coefficient memory indices.
As we noted above, it takes a clock to read from a memory.  Therefore, these
indices need to be available and ready <em>before</em> the first sample arrives.
In general, the indices will need to keep pace with the incoming samples, and
be synchronized with that same clock zero stage of the pipeline.</p>

<p>The data (read) index is the strange one.  This is the one that increments all
except for the top bit.  The top bit repeats itself between
<a href="/dsp/2018/10/02/fft.html">FFT</a>s
in order to implement the 50% overlap we’ve asked for.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">didx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">didx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_alt_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="c1">// Restart on the first point of the next FFT</span>
		<span class="n">didx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="c1">// Maintain the top bit, so as to keep</span>
		<span class="c1">// the overlap working properly</span>
		<span class="n">didx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_alt_ce</span><span class="p">))</span>
		<span class="c1">// Process the next point in this FFT</span>
		<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">didx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>When it comes to the coefficient index, all but the top bit of that index
will match the data index.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">tidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">didx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span></code></pre></figure>

<p>At one time when building this design, I had a second counter for the <code class="language-plaintext highlighter-rouge">tidx</code>
coefficient index.  One counter was for <code class="language-plaintext highlighter-rouge">didx</code>, and a second one for <code class="language-plaintext highlighter-rouge">tidx</code>.
Then, when verifying the two, I discovered the bottom <code class="language-plaintext highlighter-rouge">LGNFFT-1</code> bits needed
to be identical.  Why then maintain two counters?  Hence the combinatorial
expression above.</p>

<p>The top bit of the coefficient index, however, takes some more work.  It
follows the same pattern as <code class="language-plaintext highlighter-rouge">didx</code>, with the exception that we reset the
top bit at the beginning of any run.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">tidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">tidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_alt_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="c1">// Restart the counter for the first point</span>
		<span class="c1">// of the next FFT.</span>
		<span class="n">tidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_alt_ce</span><span class="p">))</span>
	<span class="k">begin</span></code></pre></figure>

<p>To maintain the top bit function, it needs to be set to the carry from all of
the lower bits when incrementing.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">tidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">tidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">end</span></code></pre></figure>

<p>The next counter, <code class="language-plaintext highlighter-rouge">frame_count</code>, is kind of a misnomer.  It counts down
three clocks from the beginning of a frame–rather than frames themselves.
Indeed, this is really a pipeline counter.  It counts the stages going
through the pipeline after we receive the element that’s going to turn on
the <code class="language-plaintext highlighter-rouge">o_frame</code> flag once it gets through the pipeline.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">frame_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">frame_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">OPT_TLAST_FRAME</span> <span class="o">&amp;&amp;</span> <span class="n">i_alt_ce</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tidx</span><span class="p">)</span><span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">first_block</span><span class="p">)</span>
		<span class="n">frame_count</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_TLAST_FRAME</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">top_of_block</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">first_block</span><span class="p">))</span>
		<span class="n">frame_count</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">frame_count</span> <span class="o">&lt;=</span> <span class="n">frame_count</span> <span class="o">-</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>We’ll discuss this more later when we get to the <code class="language-plaintext highlighter-rouge">o_frame</code> value below.</p>

<p>Finally, as the last step for this pipeline stage, let’s keep track of when
data values and product results are valid within our pipeline using <code class="language-plaintext highlighter-rouge">d_ce</code>
(for data) and <code class="language-plaintext highlighter-rouge">p_ce</code> (for the product results).</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="o">{</span> <span class="n">p_ce</span><span class="p">,</span> <span class="n">d_ce</span> <span class="o">}</span> <span class="o">=</span> <span class="mh">2'h0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="o">{</span> <span class="n">p_ce</span><span class="p">,</span> <span class="n">d_ce</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="mh">2'h0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="o">{</span> <span class="n">p_ce</span><span class="p">,</span> <span class="n">d_ce</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">d_ce</span><span class="p">,</span> <span class="p">(</span><span class="o">!</span><span class="n">first_block</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_alt_ce</span><span class="p">))</span><span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>That’s it for the first clock, or rather the first pipeline stage of the
algorithm.</p>

<p>For the next stage, we’ll want to read the data and coefficient from memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">tap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">data</span> <span class="o">&lt;=</span> <span class="n">dmem</span><span class="p">[</span><span class="n">didx</span><span class="p">];</span>
		<span class="n">tap</span>  <span class="o">&lt;=</span> <span class="n">cmem</span><span class="p">[</span><span class="n">tidx</span><span class="p">];</span>
	<span class="k">end</span></code></pre></figure>

<p>Remember, because this is block RAM we are reading from, we need to be careful
that we don’t do anything more than simply read from it.</p>

<p>Once the block RAM values are ready, we can multiply the two of them together.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">*</span> <span class="n">tap</span><span class="p">;</span></code></pre></figure>

<p>As before with the block RAM, you’ll want to be careful not to do anything more
than a single multiply, or possibly a multiply with a clock enable, in order
to insure the DSP will be properly inferred.</p>

<p>Only, if you look through the <a href="https://github.com/ZipCPU/dblclockfft/blob/master/rtl/windowfn.v">actual
logic</a>
for this component, you’ll see something that looks quite a bit different.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">// Multiply the two values together</span>
<span class="cp">`ifdef</span>	<span class="n">FORMAL</span>
	<span class="c1">// We'll implement an abstract multiply below--just to make sure the</span>
	<span class="c1">// timing is right.</span>
<span class="cp">`else</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">data</span> <span class="o">*</span> <span class="n">tap</span><span class="p">;</span>
<span class="cp">`endif</span></code></pre></figure>

<p>Why the difference?</p>

<p>Because formal methods can’t handle multiplies very well.  There are just
too many possibilities for the formal engine to check.  Therefore, we’ll let
the formal tool generate whatever <code class="language-plaintext highlighter-rouge">product</code> value it wants when using formal
methods–subject to only a small number of pipeline verification criteria.</p>

<p>That’ll get us around the problem with the multiply.
More on that when we get to the formal methods section below.</p>

<p>That brings us to the last stage of the pipeline–what I call clock #3.</p>

<p>Now that we have our product, all that remains is to set the outgoing
indicators, <code class="language-plaintext highlighter-rouge">o_ce</code>, <code class="language-plaintext highlighter-rouge">o_frame</code>, and the outgoing sample, <code class="language-plaintext highlighter-rouge">o_sample</code>.</p>

<p>The first, <code class="language-plaintext highlighter-rouge">o_ce</code>, simply notes when the outgoing data is valid.  It will be
valid one clock after the product, allowing us to register the result of the
product.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_ce</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="n">p_ce</span><span class="p">;</span></code></pre></figure>

<p>The frame signal, <code class="language-plaintext highlighter-rouge">o_frame</code>, is only a touch different.  This is the signal that
marks frame boundaries.  In general, it will be true on the first sample of
any frame.  I can use the <code class="language-plaintext highlighter-rouge">frame_count</code> counter, generated above from the
first sample at the top of the frame, or if <code class="language-plaintext highlighter-rouge">OPT_TLAST_FRAME</code> is set from
the last sample at the bottom of the frame, to generate this signal.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_frame</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_frame</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">o_frame</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">o_frame</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>The last step in the algorithm is to set the outgoing sample.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_sample</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">o_sample</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p_ce</span><span class="p">)</span>
		<span class="n">o_sample</span> <span class="o">&lt;=</span> <span class="n">product</span><span class="p">;</span></code></pre></figure>

<p>For the purpose of this article, I’ve kept this final output sample logic
simple, although in the actual algorithm
<a href="https://zipcpu.com/dsp/2017/07/22/rounding.html">I rounded it</a> to the output
bit width (<code class="language-plaintext highlighter-rouge">OW</code>) instead.  This is just a touch cleaner to examine and discuss,
although in practice <a href="https://zipcpu.com/dsp/2017/07/22/rounding.html">that rounding operation is
pretty important</a>.</p>

<h2 id="cover-checks">Cover Checks</h2>

<p>As we get into verification, let me ask you, where would you start?</p>

<p>You could start with a simple verilog test bench, or even a more complex
C++ test bench integrating all of the stages of your
<a href="/dsp/2018/10/02/fft.html">FFT</a>
together.  I chose to do something simpler instead.  I started with a simple
formal cover statement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">reg</span>	<span class="n">cvr_second_frame</span><span class="p">;</span>

	<span class="k">initial</span>	<span class="n">cvr_second_frame</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">o_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_frame</span><span class="p">))</span>
		<span class="n">cvr_second_frame</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">((</span><span class="n">o_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">o_frame</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">cvr_second_frame</span><span class="p">));</span></code></pre></figure>

<p>Presenting it here, however, feels a bit out of order.  Normally, I group all
my cover statements at the end of the <a href="https://github.com/ZipCPU/dblclockfft/blob/master/rtl/windowfn.v">design
file</a>.
Presenting cover here makes it more challenging to compare my draft blog
article against the original Verilog file to make sure the two remain in sync.</p>

<p>Chronologically, however, I started verifying <a href="https://github.com/ZipCPU/dblclockfft/blob/master/rtl/windowfn.v">this
core</a>
using cover.</p>

<p>From just this cover statement above, I could easily get a trace from my
design.  Of course, the first trace looked horrible, and none of the logic
matched, but it was still a good place to start from.</p>

<p>The next step that I’ve found useful for a lot of DSP algorithms is to create
a counter to capture the current phase of the processing.  Where are we,
for example, within a block?  I can then hang assertions and/or assumptions on
this counter if necessary.</p>

<p>For this design, I called this backbone counter, <code class="language-plaintext highlighter-rouge">f_phase</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_phase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">f_phase</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">top_of_block</span><span class="p">))</span>
		<span class="n">f_phase</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_alt_ce</span><span class="p">))</span>
		<span class="n">f_phase</span> <span class="o">&lt;=</span> <span class="n">f_phase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>This forms the backbone, or the spine of the formal proof.</p>

<p>To see how this works, consider how I can now make assumptions about the
relationship between the <code class="language-plaintext highlighter-rouge">i_ce</code> and <code class="language-plaintext highlighter-rouge">i_alt_ce</code> signals.</p>

<p>After <code class="language-plaintext highlighter-rouge">i_ce</code>, <code class="language-plaintext highlighter-rouge">f_phase</code> will be odd and so <code class="language-plaintext highlighter-rouge">f_phase[0]</code> will be set.  No
more <code class="language-plaintext highlighter-rouge">i_ce</code>’s can then follow, until after we’ve an <code class="language-plaintext highlighter-rouge">i_alt_ce</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_phase</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_ce</span><span class="p">);</span></code></pre></figure>

<p>I can say the same thing about <code class="language-plaintext highlighter-rouge">i_alt_ce</code> and <code class="language-plaintext highlighter-rouge">!f_phase[0]</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_phase</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_alt_ce</span><span class="p">);</span></code></pre></figure>

<p>That’s all it takes to get a trace.</p>

<table align="center" style="float: none"><caption>Fig 8. A quick cover trace</caption><tr><td><a href="/img/windowfn/first-cover.png"><img src="/img/windowfn/first-cover.png" alt="" width="780" /></a></td></tr></table>

<p>From that trace, I can look over the various signals and adjust them as
necessary until things <em>look</em> right.  At that point, the logic should be
starting to work.  The next step is to pin down the various signals in the
design using assertions, so that we’ll know that the signals within our
design will always work this way.</p>

<p>Even better, if we ever make a wrong assertion at this point, we know it should
fail within however many steps it took to generate the <code class="language-plaintext highlighter-rouge">cover()</code> trace above
(52).  That limits our maximum formal depth.  Once I finished with
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
though, I managed to get the minimum depth down to four steps.  At less than
a second, the proof is pretty quick too.</p>

<h2 id="formal-verification">Formal Verification</h2>

<p>Let’s now work our way down through the design and see if we can pin down
the various relationships between our signals along the way.  Initially,
I’ll just be stating relationships I want to prove.  However, as we get
closer to
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
I’ll be relating these signals more and more to the <code class="language-plaintext highlighter-rouge">f_phase</code> backbone we
generated earlier.</p>

<p>If you were to watch me do this sort of thing, you might think I was just
throwing assertions at the wall to see what sticks.  Perhaps there is some
truth to that.  Indeed, someone once asked me, in a video chat I hosted as
he watched me throw assertions at a design, what would happen if you added
too many assertions.  Might the design accidentally pass, and so the formal
tool might convince you that your design was working when it wasn’t?</p>

<p>That’s a good question.
If a design passes the proof, without actually getting properly checked, it’s
called a <a href="https://en.wikipedia.org/wiki/Vacuous_truth"><em>vacuous</em> proof</a>.
<a href="https://en.wikipedia.org/wiki/Vacuous_truth"><em>Vacuous</em> proof</a>s
are a real possibility, and
something the designer should be concerned with when verifying his logic.
However, additional <em>assertions</em> won’t lead to
<a href="https://en.wikipedia.org/wiki/Vacuous_truth">vacuous proof</a>s.  Additional
<em>assumptions</em> will.  This makes assumptions dangerous.  Therefore, you should
always be careful when you assume something.  1) Never add more assumptions
than you need.  2) Never make assumptions about your internal logic.  3)
<a href="/formal/2020/06/12/four-keys.html">Verify your assumptions against a custom interface property
set</a> whenever
possible.  4) Finally, always run a cover check to make sure that the proper
operation of the design is still possible in spite of any assumptions you may
have made.</p>

<p>What happens, though, if you have too many assertions, or what happens if you
make an assertion that isn’t true about your design?  The design will fail to
prove and the formal tool will return a trace illustrating and showing what’s
wrong.  Even better, it’ll tell you which assertion failed.</p>

<p>That I can work with.  Even better, the process is often faster than simulating,
and it’s certainly much faster than implementing the design, so that’s why I
use formal methods.</p>

<p>If you have too many assertions, so much so that you have redundant assertions,
then that may or may not result in a performance problem–a slower proof.
Those I typically clean up when (if) I write a blog article about the
logic in question–like I’m doing today.</p>

<p>That said, let’s throw some assertions on the wall and see what sticks.</p>

<p>Let’s start with the <code class="language-plaintext highlighter-rouge">top_of_block</code> signal.  We wanted this signal to be true
whenever we were about to start a new
<a href="/dsp/2018/10/02/fft.html">FFT</a>
frame.  When that first sample comes
in, we’ll want to make certain that all of our data indexes point to the
beginning of a block.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">top_of_block</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">didx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">top_of_block</span><span class="p">);</span></code></pre></figure>

<p>We can also check our <code class="language-plaintext highlighter-rouge">first_block</code> signal.  As you may recall, this was
the signal we used to make certain that nothing was output until a whole
frame of data was available to charge our
<a href="/dsp/2018/10/02/fft.html">FFT</a>.  Here, let’s just make
sure that whenever that <code class="language-plaintext highlighter-rouge">first_block</code> signal clears, the <code class="language-plaintext highlighter-rouge">top_of_block</code>
signal also rises to indicate that we’re ready for a new full block of data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">($</span><span class="nb">past</span><span class="p">(</span><span class="n">first_block</span><span class="p">))</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">first_block</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">top_of_block</span><span class="p">);</span></code></pre></figure>

<p>What’s the point of that <code class="language-plaintext highlighter-rouge">first_block</code> signal?  To make certain that we
never output any valid data until we’ve received a full first block.  Let’s
just double check that we got that right.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_block</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_ce</span><span class="p">);</span></code></pre></figure>

<p>This may not be the best check, since <code class="language-plaintext highlighter-rouge">o_ce</code> might still be erroneously high
due to a first block–simply because the two signals represent different
stages of the pipeline, but it should get us pretty close to what we want.</p>

<p>Let’s now create a new signal to capture when we are waiting for that first
frame to come true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_waiting_for_first_frame</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">first_block</span><span class="p">))</span>
		<span class="n">f_waiting_for_first_frame</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">o_ce</span><span class="p">)</span>
		<span class="n">f_waiting_for_first_frame</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>Let me pause here and note that one struggle students often have with formal
verification is that they think formal verification is limited to assertions
and assumptions.  As a result, they may be reluctant to generate additional
registers or signals to help them verify a design.</p>

<p>Let me just point out that, as long as those additional signals lie within the
<code class="language-plaintext highlighter-rouge">ifdef FORMAL</code> block that won’t end up in the final synthesized result, I don’t
see any problem with doing it.  Indeed, it can often dramatically simplify your
verification tasks.  Perhaps the most classic example is when working with
a bus: use a counter to count requests minus responses, and then make certain
every request gets a response.</p>

<p>Now that we have this signal, we can make verify that the first <code class="language-plaintext highlighter-rouge">o_ce</code> output
will have the <code class="language-plaintext highlighter-rouge">o_frame</code> flag set, and that <code class="language-plaintext highlighter-rouge">o_frame</code> won’t be
set unless <code class="language-plaintext highlighter-rouge">o_ce</code> is also set.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o_ce</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_frame</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OPT_TLAST_FRAME</span> <span class="o">&amp;&amp;</span> <span class="n">f_waiting_for_first_frame</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_frame</span><span class="p">);</span></code></pre></figure>

<p>This only checks <code class="language-plaintext highlighter-rouge">o_frame</code> if <code class="language-plaintext highlighter-rouge">OPT_TLAST_FRAME</code> is clear.  What about
in the <code class="language-plaintext highlighter-rouge">OPT_TLAST_FRAME</code> case?</p>

<p>For this, I tried to capture that <code class="language-plaintext highlighter-rouge">o_frame</code> followed <code class="language-plaintext highlighter-rouge">top_of_block</code> by two
clock periods.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_TLAST_FRAME</span> <span class="o">&amp;&amp;</span> <span class="n">f_past_valid</span> <span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">f_past_valid</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">o_ce</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_frame</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">top_of_block</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span></code></pre></figure>

<p>Sadly, this property didn’t pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
at first, so I threw another assertion into the design to see if it would
help.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">OPT_TLAST_FRAME</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frame_count</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">top_of_block</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frame_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">top_of_block</span> <span class="o">||</span> <span class="n">d_ce</span> <span class="o">||</span> <span class="n">p_ce</span><span class="p">);</span></code></pre></figure>

<p>It helped, but it wasn’t enough to keep the proof to three timesteps.
Adding a fourth helped, and so I continued.  Why did I need a fourth timestep?
In this case, it was because I was referencing <code class="language-plaintext highlighter-rouge">$past(top_of_block,2)</code> and
<code class="language-plaintext highlighter-rouge">top_of_block</code> was allowed to get out of sync with the <code class="language-plaintext highlighter-rouge">frame_count</code>.</p>

<p>Sadly, this kind of got stuck in my craw.  The design at one time verified
in three timesteps, and now it was requiring four?  With a little bit more
work, I added the following assertions and it now passed
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>
in three timesteps again.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">frame_count</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">top_of_block</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">d_ce</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">frame_count</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">top_of_block</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">d_ce</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p_ce</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">frame_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">top_of_block</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">d_ce</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">p_ce</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_ce</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Remember that <code class="language-plaintext highlighter-rouge">f_phase</code> backbone we started with?  Wouldn’t it be nice to know
that <code class="language-plaintext highlighter-rouge">top_of_block</code> was always set for the first step of the design?  Using
<code class="language-plaintext highlighter-rouge">f_phase</code>, that becomes pretty easy.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_phase</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">((</span><span class="n">top_of_block</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">first_block</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">top_of_block</span><span class="p">);</span></code></pre></figure>

<p>The only trick here is that I defined <code class="language-plaintext highlighter-rouge">f_phase</code> to have one more bit than
was required to represent a full
<a href="/dsp/2018/10/02/fft.html">FFT</a>’s
width, so the comparison here needs to be limited to the right number of bits
in order to pass properly.</p>

<p>Let’s take another look at what happens when we are waiting for our first
output.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_waiting_for_first_frame</span><span class="p">)</span>
	<span class="k">begin</span></code></pre></figure>

<p>If more than three items (our pipeline depth) have arrived, and we are waiting
for our first frame, then all of our internal signals must be zero and
the <code class="language-plaintext highlighter-rouge">first_block</code> flag must still be true.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">if</span> <span class="p">(</span><span class="n">f_phase</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">((</span><span class="n">first_block</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">o_frame</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">{</span><span class="n">o_ce</span><span class="p">,</span> <span class="n">p_ce</span><span class="p">,</span> <span class="n">d_ce</span><span class="o">}</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">frame_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>If the <code class="language-plaintext highlighter-rouge">f_phase</code> is zero, then we haven’t yet had a first sample arrive.
Again, all of the pipeline signals must be zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f_phase</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="k">assert</span><span class="p">((</span><span class="o">!</span><span class="n">o_frame</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">{</span><span class="n">o_ce</span><span class="p">,</span> <span class="n">p_ce</span><span class="p">,</span> <span class="n">d_ce</span><span class="o">}</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">frame_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>Let me pause and ask you, why do I need these assertions?  It’s not to prove,
necessarily, that the design does the right thing.  That is, it’s not part
of the <a href="/formal/2020/06/12/four-keys.html"><em>contract</em></a>
associated with the behavior of this component.  Rather, this is just one of
those things you need to make certain the design will pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a> and
that the various registers within it will never get out of sync with each other.</p>

<p>So, if <code class="language-plaintext highlighter-rouge">f_phase</code> is either one or two, and this isn’t the first block but
we still haven’t produced any outputs yet and so <code class="language-plaintext highlighter-rouge">f_waiting_for_first_frame</code>
is still clear, then we must have some signals moving through our pipeline.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">f_phase</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">first_block</span><span class="p">))</span>
			<span class="k">assert</span><span class="p">(</span><span class="o">|{</span><span class="n">o_ce</span><span class="p">,</span> <span class="n">p_ce</span><span class="p">,</span> <span class="n">d_ce</span> <span class="o">}</span><span class="p">);</span>
		<span class="c1">// ...</span>
	<span class="k">end</span></code></pre></figure>

<p>I also want to make certain that <code class="language-plaintext highlighter-rouge">o_sample</code> only ever changes if <code class="language-plaintext highlighter-rouge">o_ce</code>
is set.  That’s easy enough to express.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">i_reset</span><span class="p">)))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">o_ce</span> <span class="o">||</span> <span class="p">$</span><span class="nb">stable</span><span class="p">(</span><span class="n">o_sample</span><span class="p">));</span></code></pre></figure>

<p>We can even use the backbone signal, <code class="language-plaintext highlighter-rouge">f_phase</code>, to guarantee that our
coefficient index is correct.  Just beware–the two have different widths.
(<code class="language-plaintext highlighter-rouge">f_phase</code> captures the width of <em>two</em>
<a href="/dsp/2018/10/02/fft.html">FFT</a>s.)  That means we need
to do a quick width conversion and rename here.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_tidx</span> <span class="o">=</span> <span class="n">f_phase</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_tidx</span> <span class="o">==</span> <span class="n">tidx</span><span class="p">);</span></code></pre></figure>

<p>The data write index should also stay synchronized with <code class="language-plaintext highlighter-rouge">f_phase</code>, but
capturing this is more difficult.  Indeed, I needed to stare at the
traces a couple of times before I captured this properly and I wrote the
wrong assertion for this relationship more than once.  The key thing to note
here is that <code class="language-plaintext highlighter-rouge">dwidx</code> increments once for every two increments of <code class="language-plaintext highlighter-rouge">f_phase</code>.
I thought I might just be able to downshift <code class="language-plaintext highlighter-rouge">f_phase</code> to get the right
value of <code class="language-plaintext highlighter-rouge">dwidx</code>, but both will increment on an incoming sample when both
are zero.  The key therefore is to offset the comparison by one first before
making it, and so <code class="language-plaintext highlighter-rouge">f_phase_plus_one</code> has <code class="language-plaintext highlighter-rouge">LGNFFT+1</code> bits–just like <code class="language-plaintext highlighter-rouge">f_phase</code>,
but it’s one greater.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_phase_plus_one</span> <span class="o">=</span> <span class="n">f_phase</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	       <span class="k">assert</span><span class="p">(</span><span class="n">f_phase_plus_one</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span></code></pre></figure>

<p>We can also verify <code class="language-plaintext highlighter-rouge">f_phase</code> against the data index.  Here you see why
<code class="language-plaintext highlighter-rouge">f_phase</code> needs to be <code class="language-plaintext highlighter-rouge">LGNFFT+1</code> bits in length–because for the first
<a href="/dsp/2018/10/02/fft.html">FFT</a> <code class="language-plaintext highlighter-rouge">f_phase</code> matches
<code class="language-plaintext highlighter-rouge">didx</code>, but for odd <a href="/dsp/2018/10/02/fft.html">FFT</a>s
the top bit is flipped.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_phase</span><span class="p">[</span><span class="n">LGNFFT</span><span class="p">])</span>
	<span class="k">begin</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_phase</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">{!</span><span class="n">didx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">didx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">}</span><span class="p">);</span>
		<span class="k">assert</span><span class="p">((</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
				<span class="o">||</span><span class="p">(</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">));</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
		<span class="k">assert</span><span class="p">((</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
			<span class="o">||</span><span class="p">((</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">dwidx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f_phase</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])));</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_phase</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">didx</span><span class="p">[</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">end</span></code></pre></figure>

<p>One of the things that was important for me to be able to prove was that
the write data would never overtake the read data function–corrupting the
memory read operation.  This part of the proof requires a subtraction, but
otherwise we’re just saying that the difference between the two indexes must
remain less than the size of one
<a href="/dsp/2018/10/02/fft.html">FFT</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">assign</span>	<span class="n">f_diff_idx</span> <span class="o">=</span> <span class="n">didx</span> <span class="o">-</span> <span class="n">dwidx</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_block</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_diff_idx</span> <span class="o">&lt;</span> <span class="o">{</span> <span class="mb">1'b1</span><span class="p">,</span> <span class="o">{</span><span class="p">(</span><span class="n">LGNFFT</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span> <span class="o">}</span><span class="p">);</span></code></pre></figure>

<p>Let’s now look at that <code class="language-plaintext highlighter-rouge">first_block</code> signal.  Once we get to the top of
any block, that is once we’ve passed the last element in the last block,
then we can’t be in the <code class="language-plaintext highlighter-rouge">first_block</code> anymore.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">top_of_block</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">first_block</span><span class="p">);</span></code></pre></figure>

<p>Let’s now come back and talk about that multiply.</p>

<p>Remember how I said multiplies were hard to verify?  We need some form of
alternative if we want to make certain the design works apart from the
multiply.</p>

<p>You might also notice that we didn’t generate a <code class="language-plaintext highlighter-rouge">product</code> before if we
were running our formal proof.  The <code class="language-plaintext highlighter-rouge">product</code> logic was disabled by the
<code class="language-plaintext highlighter-rouge">ifdef FORMAL</code> macro.  We’ll build that logic here.  First, we’ll let
<code class="language-plaintext highlighter-rouge">f_pre_product</code> be any number the solver wants it to be–the solver can
just choose anything on any clock–subject to a few constraints below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="p">(</span><span class="o">*</span> <span class="n">anyseq</span> <span class="o">*</span><span class="p">)</span> <span class="kt">reg</span> <span class="kt">signed</span> <span class="p">[</span><span class="n">IW</span><span class="o">+</span><span class="n">TW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">f_pre_product</span><span class="p">;</span></code></pre></figure>

<p>Our first constraint is that if either of the inputs to the
multiply is zero, the pre-product should also be zero.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">f_pre_product</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">f_pre_product</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>Similarly, if either of the inputs is one, then the pre-product value should
have the value of the other input as a result.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">f_pre_product</span> <span class="o">==</span> <span class="n">tap</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">f_pre_product</span> <span class="o">==</span> <span class="n">data</span><span class="p">);</span></code></pre></figure>

<p>Finally, if the inputs don’t change, then the product shouldn’t either.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">$</span><span class="nb">stable</span><span class="p">(</span><span class="n">tap</span><span class="p">))</span>
		<span class="k">assume</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">f_pre_product</span><span class="p">));</span></code></pre></figure>

<p>I suppose this last assumption isn’t required, but it doesn’t really hurt me
either.</p>

<p>Finally, we can now set <code class="language-plaintext highlighter-rouge">product</code> equal to the pre-product, but delayed by
one clock cycle.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">f_pre_product</span><span class="p">;</span></code></pre></figure>

<p>Now let’s sample a value as it works it’s way through our pipeline–just to
double check that all the processing of this value gets done properly.</p>

<p>Let’s start by picking an address, I’ll call it <code class="language-plaintext highlighter-rouge">f_addr</code>, and a value to
be at that address-we’ll call it <code class="language-plaintext highlighter-rouge">f_tap</code> for the coefficient and <code class="language-plaintext highlighter-rouge">f_value</code>
for the data element.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="cp">`ifdef</span>	<span class="n">VERIFIC</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f_past_valid</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">f_tap</span> <span class="o">==</span> <span class="n">cmem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]);</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">dmem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]</span> <span class="o">==</span> <span class="n">f_value</span><span class="p">);</span>
	<span class="k">end</span>
<span class="cp">`else</span>
	<span class="k">initial</span>	<span class="k">assume</span><span class="p">(</span><span class="n">f_tap</span> <span class="o">==</span> <span class="n">cmem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]);</span>
	<span class="k">initial</span>	<span class="k">assume</span><span class="p">(</span><span class="n">dmem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]</span> <span class="o">==</span> <span class="n">f_value</span><span class="p">);</span>
<span class="cp">`endif</span></code></pre></figure>

<p>Now that we know the value was correct at the beginning of time, let’s
follow it through time.  First, <code class="language-plaintext highlighter-rouge">f_tap</code> gets updated if ever the coefficient
it matches gets updated.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_tap</span> <span class="o">==</span> <span class="n">cmem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_tap_wr</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_addr</span> <span class="o">==</span> <span class="n">tapwidx</span><span class="p">))</span>
		<span class="n">f_tap</span> <span class="o">&lt;=</span> <span class="n">i_tap</span><span class="p">;</span></code></pre></figure>

<p>In a similar fashion, <code class="language-plaintext highlighter-rouge">f_value</code> needs to always match <code class="language-plaintext highlighter-rouge">dmem[f_addr]</code> at all
times.  Here, we’ll adjust it anytime a new value comes in and we write it to
our special address, <code class="language-plaintext highlighter-rouge">f_addr</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_value</span> <span class="o">==</span> <span class="n">dmem</span><span class="p">[</span><span class="n">f_addr</span><span class="p">]);</span>

	<span class="k">initial</span>	<span class="n">f_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">dwidx</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">))</span>
		<span class="n">f_value</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span></code></pre></figure>

<p>Let’s now follow this data value through our pipeline.  I like to use
<code class="language-plaintext highlighter-rouge">*this*</code> indicators to highlight the special value being used.  Here, there’s
a <code class="language-plaintext highlighter-rouge">this</code> indicator for each of the various <code class="language-plaintext highlighter-rouge">*_ce</code> steps in the pipeline.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="o">{</span> <span class="n">f_this_oce</span><span class="p">,</span> <span class="n">f_this_pce</span><span class="p">,</span> <span class="n">f_this_dce</span> <span class="o">}</span> <span class="o">=</span> <span class="mh">3'h0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">i_reset</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_tap_wr</span><span class="p">))</span>
		<span class="o">{</span> <span class="n">f_this_oce</span><span class="p">,</span> <span class="n">f_this_pce</span><span class="p">,</span> <span class="n">f_this_dce</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="mh">3'h0</span><span class="p">;</span>
	<span class="k">else</span> 
		<span class="o">{</span> <span class="n">f_this_oce</span><span class="p">,</span> <span class="n">f_this_pce</span><span class="p">,</span> <span class="n">f_this_dce</span> <span class="o">}</span>
			<span class="o">&lt;=</span> <span class="o">{</span> <span class="n">f_this_pce</span><span class="p">,</span> <span class="n">f_this_dce</span><span class="p">,</span> <span class="p">(((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_alt_ce</span><span class="p">))</span>
					<span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_addr</span> <span class="o">==</span> <span class="n">didx</span><span class="p">))</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>I could do the same with the coefficient, but realistically I only need to
capture the first step in the pipeline for that.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="n">f_this_tap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">f_this_tap</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">i_ce</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">i_alt_ce</span><span class="p">))</span>
		<span class="n">f_this_tap</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_addr</span> <span class="o">==</span> <span class="n">tidx</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">f_this_tap</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure>

<p>Now, let’s verify reading from the two memories respectively.  If this value
is read, it should find itself in both the <code class="language-plaintext highlighter-rouge">tap</code> and <code class="language-plaintext highlighter-rouge">data</code> registers.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_this_tap</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">tap</span> <span class="o">==</span> <span class="n">f_tap</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_this_dce</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">f_value</span><span class="p">));</span></code></pre></figure>

<p>I also double checked this value with the output of the product, but I didn’t
really push the comparison any further.  This seemed to be sufficient, and
even overkill–as it now felt like I was verifying the obvious.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">f_past_data</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">f_past_tap</span>  <span class="o">&lt;=</span> <span class="n">tap</span><span class="p">;</span>
	<span class="k">end</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">f_past_valid</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">f_this_pce</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_past_tap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">product</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_past_data</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">product</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_past_tap</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">product</span><span class="o">=={</span> <span class="o">{</span><span class="p">(</span><span class="n">TW</span><span class="p">)</span><span class="o">{</span><span class="n">f_past_data</span><span class="p">[</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">}</span> <span class="o">}</span><span class="p">,</span><span class="n">f_past_data</span><span class="o">}</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f_past_data</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">assert</span><span class="p">(</span><span class="n">product</span><span class="o">=={</span> <span class="o">{</span><span class="p">(</span><span class="n">IW</span><span class="p">)</span><span class="o">{</span><span class="n">f_past_tap</span><span class="p">[</span><span class="n">TW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">}</span> <span class="o">}</span><span class="p">,</span><span class="n">f_past_tap</span><span class="o">}</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>The bottom line was that this was enough to 1) pass
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
2) verify proper pipeline signal handling, and 3) guarantee that I wouldn’t
overwrite the data I was reading from as the algorithm was working through
it’s buffer.  Even better, I can see how well the design works from a quick
cover trace.</p>

<h2 id="conclusion">Conclusion</h2>

<p>There you have a basic
<a href="https://en.wikipedia.org/wiki/Window_function">Window function</a>
calculator.  It operates on a data stream, breaking the stream into 
blocks with a 50% overlap and applying a taper to each block of data.  It’s
ideal as a first step prior to applying an
<a href="/dsp/2018/10/02/fft.html">FFT</a>.</p>

<p>The reality is that all
<a href="/dsp/2018/10/02/fft.html">FFT</a> processing uses a <a href="https://en.wikipedia.org/wiki/Window_function">Window
function</a>.  Even if you aren’t
consciously using one, you are likely using a <a href="https://en.wikipedia.org/wiki/Window_function#Rectangular_window">rectangular window
function</a>–and
getting poor performance as a result.  Let me encourage you instead to take
the time and do your homework.  You can get much better
performance than a <a href="https://en.wikipedia.org/wiki/Window_function#Rectangular_window">rectangular
window</a>
with only the minimal amount of engineering above.</p>

<p>Unfortunately, this article only touches the surface of spectral estimation
within FPGAs.  I feel like I could spend more time talking about what we haven’t
discussed over and above I’ve discussed above.  Here’s a list of just some
of the things we haven’t covered, that could easily fit into several nice
follow up articles:</p>

<ol>
  <li>
    <p>Converting the <code class="language-plaintext highlighter-rouge">i_ce</code>/<code class="language-plaintext highlighter-rouge">o_ce</code> signaling to AXI stream signaling.  It’s easy
to do, and so this might make for a nice and quick article on the topic.
The trick is handling the
<a href="https://en.wikipedia.org/wiki/Back_pressure">back pressure</a>
in an algorithm that has no
<a href="https://en.wikipedia.org/wiki/Back_pressure">back pressure</a>
handling.  It’s easy to do, but if you haven’t seen the trick
to it you might scratch your head wondering how to do it for a while.
(Hint: it requires a FIFO on the back end, and the calculation of FIFO full
signaling on the incoming end.)</p>
  </li>
  <li>
    <p>A second, more challenging, protocol challenge is to convert the
<a href="/dsp/2018/10/02/fft.html">FFT</a>’s signal handling to
AXI stream as well.  That’s quite doable, but doing it ended up being more
of a challenge than I was expecting.</p>
  </li>
  <li>
    <p>One of the fun things <a href="http://ieeexplore.ieee.org/document/1162950/">Allen</a>
discusses is how to handle
<a href="https://en.wikipedia.org/wiki/Window_function">window</a>s that are much
longer than a single <a href="/dsp/2018/10/02/fft.html">FFT</a> in
length.  This is really a requirement if you want <a href="/dsp/freq-teaser.html">good spectral
resolution</a>.  Indeed, it makes
the <img src="/img/windowfn/eqn-D-N2.png" alt="`D=N/2`" /> filtering
option both possible and sufficient for most uses.  The logic above, however,
won’t handle a
<a href="https://en.wikipedia.org/wiki/Window_function">window</a> longer than a single
<a href="/dsp/2018/10/02/fft.html">FFT</a> length, so we may have
to come back to this topic again to discuss how to accomplish that operation.
The good news is that the required logic isn’t any more complex than the
<a href="https://github.com/ZipCPU/dblclockfft/blob/master/rtl/windowfn.v">logic above</a>,
so once you understand how the algorithm works the logic is fairly easy.</p>
  </li>
  <li>
    <p>I’d love to prove that a single-taper window <em>always</em> performs at least
as good or better than a multi-taper window.  Sadly, I’m concerned that
the proof of this might be too esoteric for my audience, so I’m not sure
whether I’ll be able to get to that proof or not.  It’s a fun proof, though,
and only takes a couple of pages.</p>
  </li>
  <li>
    <p>There’s a lot to be said for
<a href="https://en.wikipedia.org/wiki/Window_function">window</a>
design.  Lord willing, I look forward
to being able to post something on that topic.  For example, did you know
that a good <a href="/dsp/2018/10/02/fft.html">FFT</a>
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a>,
one that conserves energy, is sufficient to render the
entire <a href="/dsp/2018/10/02/fft.html">FFT</a>
operation invertible?  I mean invertible to the point of recovering the
original signal.  That’s a fun proof, and I look forward to sharing it
in due time as well.</p>
  </li>
  <li>
    <p>I haven’t mentioned scaling
<a href="/dsp/2018/10/02/fft.html">FFT</a> results for display, nor
have I mentioned my favorite choice in colormaps.  Both are essential
for display, and neither get discussed much.</p>

    <p>Another, related question, is whether a log should be taken of any
<a href="/dsp/2018/10/02/fft.html">FFT</a> results or not.
Perhaps the discussion above will help answer that question, although the
real bottom line answer is: it depends.</p>
  </li>
  <li>
    <p>My <a href="https://github.com/ZipCPU/fftdemo">FFT demo</a> design has a fun capability
to scroll a raster across the screen horizontally.  This is a fun video
trick, using an external memory, that would be a lot of fun to share.</p>

    <p>Scrolling vertically is easier.  Horizontally was a fun challenge.</p>
  </li>
</ol>

<p>If nothing else, there remains a lot left to discuss.</p>

<p>Until that time, may God bless you and yours.</p>

<!-- [Allen](http://ieeexplore.ieee.org/document/1455039/) -->
<!-- [Uncertainty Principle](http://ieeexplore.ieee.org/document/1085842/) -->
<!-- [Windows with good Sidelobe Behavior](http://ieeexplore.ieee.org/document/1163506/) -->
<!-- [Analysis, Synthesis, and Modification](http://ieeexplore.ieee.org/document/1162950/) -->
<!-- [Time-Varying Spectrum Estimators](http://ieeexplore.ieee.org/document/679147/) -->


  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>Now when Daniel knew that the writing was signed, he went into his house; and his windows being open in his chamber toward Jerusalem, he kneeled upon his knees three times a day, and prayed, and gave thanks before his God, as he did aforetime. (Daniel 6:10)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
