<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Adjusting our logic PLL to handle I&Q</title>
  <meta name="description" content="Some time ago, I posted an article on how to create a basic logic PLLin Verilog.  Thedesignwas simple, basic, and easy to implement in an FPGA.  It worked by...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2020/03/12/quadpll.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Adjusting our logic PLL to handle I&Q</h1>
    <p class="post-meta"><time datetime="2020-03-12T00:00:00-04:00" itemprop="datePublished">Mar 12, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Some time ago, I posted an article on <a href="/dsp/2017/12/14/logic-pll.html">how to create a basic logic PLL
in Verilog</a>.  <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">The
design</a>
was simple, basic, and easy to implement in an FPGA.  It worked by tracking
the <a href="/dsp/2017/07/11/simplest-sinewave-generator.html">most significant bit of any
sinewave</a>
given to it, giving it a nice gain invariance which would make it useful
in a large variety of contexts.</p>

<p>More recently, I was asked to build a <a href="https://github.com/ZipCPU/sdr">demonstration design for a
software (gateware) defined radio</a>.  Yes,
I call it a <a href="https://en.wikipedia.org/wiki/Software-defined_radio">“software” defined
radio</a>, although in
actuality all of the processing within it is done by the
<a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>.  There’s no
<a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a>
involved, so perhaps it is better termed as a “gateware” defined radio.  I’m
going to stick with the “software” label for now–under protest if I have to.
Why?  Because like a true <em>software</em> defined radio, you really need to know
and understand the guts of this one in order to get it to work.  Further,
as with any FPGA design, <a href="https://github.com/ZipCPU/sdr">this radio design</a>
is fully reprogrammable.</p>

<p><a href="https://github.com/ZipCPU/sdr">The design</a>
was to have both AM and FM examples within it.  When I went to build those
examples, I quickly realized that both the <a href="https://github.com/ZipCPU/sdr/blob/3eb914db4175ecc3b5a9374825110d0b80435dca/rtl/amdemod.v#L212-L216">AM
demodulator</a>
and the <a href="https://github.com/ZipCPU/sdr/blob/3eb914db4175ecc3b5a9374825110d0b80435dca/rtl/fmdemod.v#L165-L169">FM
demodulator</a>
would require <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/quadpll.v">a PLL that could track the incoming carrier
frequency</a>.
An ideal candidate for this PLL was my <a href="/dsp/2017/12/14/logic-pll.html">previous logic
PLL</a>.
The only problem was simply that the
<a href="/dsp/2017/12/14/logic-pll.html">logic PLL</a>
only worked on a single sinewave input, rather than the quadrature
input available on this board.</p>

<p>Today, let’s take a look at why a quadrature demodulator is a good thing, and
then look over the difference between the two cores.  We can then compare
the performance between the two cores so you can see why a <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/quadpll.v">quadrature
PLL</a> is really
a good idea.</p>

<h2 id="what-is-quadrature">What is Quadrature?</h2>

<p>The word “quadrature” in today’s article is a reference to a transmit or
receive architecture that uses two “arms” or “rails” as they might be
called to either transmit,
or receive an incoming signal.</p>

<table align="center" style="float: none"><tr><th>Fig 1. A quadrature transmit scheme</th><th>Fig 2. A quadrature receiver scheme</th></tr><tr><td><img src="/img/quadpll/quadtx.svg" alt="" width="320" /></td><td><img src="/img/quadpll/quadrx.svg" alt="" width="320" /></td></tr></table>

<p>Since each arm of a signal in such a scheme is controlled/represented by either
a real or an imaginary signal, depending on the arm, I think of “quadrature”
signals as a reference more to the complex nature of the signal than to the
structure used to create it.  In engineering, the two axes of this <a href="https://en.wikipedia.org/wiki/Complex_plane">complex
plane</a> are often called
“in-phase” or I, referencing the “real” signal rail that is multiplied by
the cosine term, and “quadrature” or Q, which references the rail multiplied
by the imaginary sine term.  The <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/quadpll.v">quadrature
PLL</a> we are
discussing today is one that takes both I and Q inputs.</p>

<p>But let’s back up a bit.  There’s a reason why imaginary numbers are
<em>imaginary</em>.  The square root of negative one can’t really be produced in
any physical system, so what reality does this even pretend to represent?</p>

<p>That’s a good question, so let’s start at the top and examine a radio
frequency (RF) receiver.</p>

<p>From an engineering standpoint, a good RF front end consists of an
<a href="https://en.wikipedia.org/wiki/Antenna_(radio)">antenna</a>, a
<a href="https://en.wikipedia.org/wiki/Low-noise_amplifier">low-noise pre-amplifier</a>,
a <a href="https://en.wikipedia.org/wiki/Band-pass_filter">band-pass filter</a>, an
optional adjustable or <a href="https://en.wikipedia.org/wiki/Automatic_gain_control">automatic gain</a>, an <a href="https://en.wikipedia.org/wiki/Frequency_mixer">RF mixer</a>
followed by a <a href="/dsp/2017/12/30/slowfil.html">lowpass filter</a>.</p>

<table align="center" style="float: none"><caption>Fig 3. A basic RF front end</caption><tr><td><img src="/img/quadpll/receiver.svg" alt="" width="780" /></td></tr></table>

<p>Mathematically, I like to cheat and just represent a receiver as a
<a href="https://en.wikipedia.org/wiki/Heterdyne">downconverter</a> followed by a
<a href="https://en.wikipedia.org/wiki/Digital_down_converter">lowpass filter and then a
downsampler</a>.</p>

<table align="center" style="float: none"><caption>Fig 4. A simplified receiver model</caption><tr><td><img src="/img/quadpll/math-frontend.svg" alt="" width="360" /></td></tr></table>

<p>It just makes the processing easier to understand.</p>

<p>At issue in today’s discussion is the form of the RF mixer, whether the form
shown in Fig. 4 above or in Fig 2 above that.</p>

<p>One common way of building a mixer is to simply multiply the incoming
signal by a
<a href="/dsp/2017/07/11/simplest-sinewave-generator.html">sinewave</a>
above or below the signal of interest.  This is part
of the <a href="https://en.wikipedia.org/wiki/Superheterodyne_receiver">super-heterodyne
receiver</a>
architecture.  Assuming a signal frequency of <code class="language-plaintext highlighter-rouge">f_c</code> and a local oscillator
frequency, within the receiver, of <code class="language-plaintext highlighter-rouge">f_LO</code>, the resulting signal will be placed
at frequencies <code class="language-plaintext highlighter-rouge">f_c+f_LO</code> and <code class="language-plaintext highlighter-rouge">f_c-f_LO</code>.  (We’ll see this in a moment.)  A
<a href="/dsp/2017/12/30/slowfil.html">lowpass filter</a>
can then be used to select one of these two frequency bands, making it
possible to then work on the signal at a lower (and slower) frequency–perhaps
even in the digital domain.</p>

<p>Not so with this receiver.</p>

<p>No, the <a href="https://github.com/xil-se/SX1257-PMOD">SX1257 Radio PMod</a> uses
a <em>quadrature</em> mixer.  Within the
<a href="https://www.semtech.com/products/wireless-rf/lora-gateways/SX1257">SX1257</a>,
the local oscillator consists of both sine and cosine components.  Together,
they <a href="https://en.wikipedia.org/wiki/Digital_down_converter">downconvert</a>
a signal much like multiplying by a <a href="https://en.wikipedia.org/wiki/Euler's_formula">complex
exponential</a> would.  The nice
part of this setup is that the final signal can be placed near zero
frequency–rather than some <a href="https://en.wikipedia.org/wiki/Intermediate_frequency">intermediate
frequency</a> offset from
zero.</p>

<p>Mathematically, this can really simplify the analysis.  There is an
engineering cost, however, to making sure that the two “rails” are
properly balanced–but that’s not our topic today.</p>

<p>So, imagine if we started with an <a href="https://en.wikipedia.org/wiki/Amplitude_modulation">AM
signal</a>.  This <a href="https://en.wikipedia.org/wiki/Amplitude_modulation">AM
signal</a> is created from
some real (not imaginary or complex) information signal, we’ll call it <code class="language-plaintext highlighter-rouge">m(t)</code>,
containing whatever it was we want to transmit and then recover.  Inside
the transmitter, <code class="language-plaintext highlighter-rouge">m(t)</code> will be multiplied by a cosine wave to bring it up
to a radio frequency, just as we showed in Fig. 1 above.  After propagation
decays and delays this signal and noise gets added to it, it might then show
up to the receiver looking something like:</p>

<table align="center" style="float: none"><tr><td><img src="/img/quadpll/eqn-amrx.png" alt="x_RX(t)=A_RX[C+m(t-d_RX)cos(2pi f_c t+theta_RX)+n_RX(t)" width="577" /></td></tr></table>

<p>where</p>

<table align="center" style="float: none"><tr><td><img src="/img/quadpll/term-defns.png" alt="Variables defined" width="580" /></td></tr></table>

<p>Our goal will be to recover the message, <code class="language-plaintext highlighter-rouge">m(t)</code>.</p>

<p>You may have noticed the colors in the expression above.  I like to do this
to help me understand what it is I have to work with.  In particular, I like
to write out all of my unknown values in red.  In general, the whole expression
is red save for the waveform we’ve measured.  We can argue about whether or not
the amount of carrier, <code class="language-plaintext highlighter-rouge">C</code>, is known or not–in the end it’s not all that
relevant since we’re just going to filter it out anyway.</p>

<p>Several of these terms take a lot of work to track from the origin to the
receiver.  Particularly complex terms include the amplitude, A, the propagation
delay, delta, and the phase.  Each of these is related to how the waveform
propagated from the source to the receiver, so they cannot necessarily be
known when the waveform is received.  Worse, they are particularly difficult
to track and apply meaning to even in the receiver since so many components
of the receiver’s processing path adjust them along the way.</p>

<p>For example, our first step in processing this signal will be to adjust
the frequency to “<a href="https://en.wikipedia.org/wiki/Baseband">baseband</a>”–where
the frequency of the cosine term gets (approximately) zeroed out.  Let’s
suppose we know about what <code class="language-plaintext highlighter-rouge">fc</code> is so that we can create a <em>local oscillator</em>
(one generated in the receiver) at something close to <code class="language-plaintext highlighter-rouge">f_c</code>–let’s call it
<code class="language-plaintext highlighter-rouge">f_LO</code> for the frequency of the local oscillator.  We might then multiply
<code class="language-plaintext highlighter-rouge">x(t)</code> by this local oscillator to get a
<a href="https://en.wikipedia.org/wiki/Baseband">baseband</a> signal.</p>

<table align="center" style="float: none"><tr><td><img src="/img/quadpll/eqn-mixed.png" alt="" width="340" /></td></tr></table>

<p>If we ignore the noise term for now, we can expand this out a bit to simplify
it.</p>

<table align="center" style="float: none"><tr><td><img src="/img/quadpll/eqn-mixed-simpler.png" alt="" width="672" /></td></tr></table>

<p>If we then use a
<a href="/dsp/2017/12/30/slowfil.html">lowpass filter</a> to remove the
term at <code class="language-plaintext highlighter-rouge">f_c+f_LO</code>, we can then get a useful waveform to work with.</p>

<table align="center" style="float: none"><tr><td><img src="/img/quadpll/eqn-ambblo.png" alt="" width="655" /></td></tr></table>

<p>Did you notice how the amplitude, frequency, and phase all changed during
this process?  Keeping track of all of these changes can be quite a
challenge.  It’s often much easier just to merge the details of the local
oscillator processing stage together with the values of the signal that
are already unknown.  Therefore, I will often create new frequency and
phase terms just to keep my notation simpler.</p>

<table align="center" style="float: none"><tr><td><img src="/img/quadpll/eqn-ambb.png" alt="" width="499" /></td></tr></table>

<p>This newer, simpler, signal description is still the same thing that
we were just looking at.</p>

<h4 id="am-demodulation">AM Demodulation</h4>

<p>Let’s pause for a moment and consider what this <code class="language-plaintext highlighter-rouge">m(t)</code> signal might “look”
like.</p>

<p>First, we know that <code class="language-plaintext highlighter-rouge">m(t)</code> was real.</p>

<table align="center" style="float: none"><caption>Fig 5. Initial message signal in time</caption><tr><td><img src="/img/quadpll/am-source-time.png" alt="" width="435" /></td></tr></table>

<p>If we place rotate this figure so that time goes in and out of the page
(screen), <code class="language-plaintext highlighter-rouge">m(t)</code> can then be plotted on a
<a href="https://en.wikipedia.org/wiki/Complex_plane">complex plane</a>
and it would look like points along the <code class="language-plaintext highlighter-rouge">x</code> axis as shown in Fig. 6 below.</p>

<table align="center" style="float: none"><caption>Fig 6. The initial message shown as a phasor</caption><tr><td><img src="/img/quadpll/am-source-phasor.png" alt="" width="433" /></td></tr></table>

<p>If we then add the
<a href="https://en.wikipedia.org/wiki/Amplitude_modulation">AM</a>
carrier offset <code class="language-plaintext highlighter-rouge">C</code> to it, the message points just shift to the right.</p>

<table align="center" style="float: none"><caption>Fig 7. The initial message, but offset by the constant carrier</caption><tr><td><img src="/img/quadpll/am-wcarrier.png" alt="" width="433" /></td></tr></table>

<p>Once the message gets multiplied by a complex carrier, this diagram starts
spinning in circles at the carrier frequency.</p>

<table align="center" style="float: none"><caption>Fig 8. The transmitted waveform, spinning at RF frequency</caption><tr><td><img src="/img/quadpll/am-atcarrier.png" alt="" width="433" /></td></tr></table>

<p>Of course, only the <em>real</em> component of this diagram will ever get
transmitted, so the picture over the airwaves will likely look like a more
traditional AM signal.</p>

<table align="center" style="float: none"><caption>Fig 9. The transmitted waveform, as viewed in time</caption><tr><td><img src="/img/quadpll/am-atcarrier-time.png" alt="" width="436" /></td></tr></table>

<p>Inside our receiver, we’re going to try to de-spin this signal.  If we do
the task right, so that <code class="language-plaintext highlighter-rouge">f_c == f_LO</code>, the incoming signal will look something
like,</p>

<table align="center" style="float: none"><caption>Fig 10. The received waveform, once the carrier has been removed</caption><tr><td><img src="/img/quadpll/am-baseband.png" alt="" width="433" /></td></tr></table>

<p>At this point, we don’t want just the real or imaginary portions.  Were we
to only grab the real component, as an example, there would be a worst case
where we might just happen to get so unlucky that we lose the entire
signal.</p>

<table align="center" style="float: none"><caption>Fig 11. The received waveform, once the carrier has been removed</caption><tr><td><img src="/img/quadpll/am-baseband-diabolical.png" alt="" width="433" /></td></tr></table>

<p>We could’ve picked some <a href="https://en.wikipedia.org/wiki/Intermediate_frequency">intermediate
frequency</a>, <code class="language-plaintext highlighter-rouge">f_IF</code>
 such that <code class="language-plaintext highlighter-rouge">f_LO = f_c - f_IF</code>.  Had we done that, our signal would’ve still
been spinning as it was in Fig. 8 above, just spinning slower.  We’d still
need to eventually remove the rotation, so we’re going to get to
Fig. 10 either way.</p>

<p>If <code class="language-plaintext highlighter-rouge">f_LO</code> is only approximately equal to <code class="language-plaintext highlighter-rouge">f_c</code>, such as would be the case in
real life, then this constellation plot would rotate slower.
Our goal, as part of our
<a href="https://en.wikipedia.org/wiki/Amplitude_modulation">AM</a>
<a href="https://github.com/ZipCPU/sdr/blob/master/rtl/amdemod.v">demodulator</a>,
is going to be slowing and eventually stopping this rotation.  We’ll then
want to <a href="https://github.com/ZipCPU/sdr/blob/3eb914db4175ecc3b5a9374825110d0b80435dca/rtl/amdemod.v#L211-L219">rotate the constellation that results back to zero
phase</a>, and to
<a href="https://github.com/ZipCPU/sdr/blob/3eb914db4175ecc3b5a9374825110d0b80435dca/rtl/amdemod.v#L221-L225">remove the carrier offset</a>.</p>

<p><a href="https://github.com/ZipCPU/sdr/blob/3eb914db4175ecc3b5a9374825110d0b80435dca/rtl/amdemod.v#L212-L216">Tracking this rotation</a>
is the purpose of <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">our quadrature
PLL</a>.</p>

<h4 id="fm-demodulation">FM Demodulation</h4>

<p>If we were to start with <a href="https://en.wikipedia.org/wiki/Frequency_modulation">frequency
modulation (FM)</a>, the signal
might not necessarily be real, but many of the same principles would still
apply.  In this case, the signal would start out slowly rotating back and
forth around the
<a href="https://en.wikipedia.org/wiki/Complex_plane">complex plane</a>.</p>

<p>If the frequency excursions were small enough, they could be approximated
as purely imaginary excursions from the right side of the unit circle,
as shown in Fig. 12 below.</p>

<table align="center" style="float: none"><caption>Fig 12. A narrowband FM signal</caption><tr><td><img src="/img/quadpll/fm-narrowband.png" alt="" width="433" /></td></tr></table>

<p>If they are larger, the approximation no longer applies, but it’s still
<a href="https://en.wikipedia.org/wiki/Frequency_modulation">FM</a>.</p>

<table align="center" style="float: none"><caption>Fig 13. A widerband FM signal</caption><tr><td><img src="/img/quadpll/fm-wideband.png" alt="" width="433" /></td></tr></table>

<p>How big the frequency changes within the message are is a function of how
the system is set up.</p>

<p>As before, the transmitter spins this signal.</p>

<table align="center" style="float: none"><caption>Fig 14. The transmitted waveform, spinning at RF frequency</caption><tr><td><img src="/img/quadpll/fm-atcarrier.png" alt="" width="433" /></td></tr></table>

<p>Unlike the
<a href="https://en.wikipedia.org/wiki/Amplitude_modulation">AM</a>
signal shown in Fig. 8, this signal has a constant amplitude, as shown by the
narrow line drawing the blue circle in Fig. 14.  The transmitter
then transmits only the real portion of it,</p>

<table align="center" style="float: none"><caption>Fig 15. The FM waveform, as transmitted, but shown in time</caption><tr><td><img src="/img/quadpll/fm-time.png" alt="" width="436" /></td></tr></table>

<p>because imaginary signals are only <em>imaginary</em>–right?</p>

<p>Inside the receiver, our goal will be to first remove most of the spinning,
and then to capture the spin frequency as our resulting message.</p>

<p>As with the
<a href="https://github.com/ZipCPU/sdr/blob/master/rtl/amdemod.v">AM demodulator</a>,
the <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/fmdemod.v">FM demodulator</a>,
can be accomplished with a
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">PLL</a>.
Likewise, the quadrature information helps to keep us from diabolical
cases.  In the end, our task is essentially to measure the speed of a point
as it spins around a circle in the
<a href="https://en.wikipedia.org/wiki/Complex_plane">complex plane</a>.</p>

<table align="center" style="float: none"><caption>Fig 16. Demodulating FM is about determining the speed of rotation about the circle</caption><tr><td><img src="/img/quadpll/fm-demod.png" alt="" width="433" /></td></tr></table>

<h2 id="adjusting-the-phase-detector">Adjusting the Phase Detector</h2>

<p>When we <a href="/dsp/2017/12/14/logic-pll.html">first built our PLL</a>,
we had to do a lot of work to figure out whether or not the PLL phase was
ahead of or behind the incoming sinusoid.  This required <a href="https://github.com/ZipCPU/dpll/blob/af052626172d6cfc156fc820d41dcfdc393f2f0d/rtl/sdpll.v#L74-L85">finding when the two
inputs agreed with each other</a>,
and then <a href="https://github.com/ZipCPU/dpll/blob/af052626172d6cfc156fc820d41dcfdc393f2f0d/rtl/sdpll.v#L91-L100">looking at which input changed
first</a>
to know which of the two clocks was faster or slower.</p>

<p>With quadrature signals, things are different.  The first change will be
admitting two input bits, one for I and one for Q, into our core.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="kt">input</span>	<span class="kt">wire</span>	<span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>		<span class="n">i_input</span><span class="p">;</span> <span class="c1">// = { I, Q }</span></code></pre></figure>

<p>These two incoming bits can be used to approximate the incoming phase
as either 45, 135, -135 or -45 degrees.</p>

<table align="center" style="float: none"><caption>Fig 17. Incoming IQ phase map</caption><tr><td><img src="/img/quadpll/iq-map.png" alt="" width="433" /></td></tr></table>

<p>Similarly, the top two MSB of the phase counter internal to our PLL can
also be mapped to these same points.</p>

<table align="center" style="float: none"><caption>Fig 18. Phase as given by the top two MSB bits of the phase counter</caption><tr><td><img src="/img/quadpll/counter-map.png" alt="" width="547" /></td></tr></table>

<p>The mapping isn’t quite the same, so we’ll need to watch out for this
difference as we go along.</p>

<p>Our next goal is to determine whether or not a phase error exists.  Are these
two waveforms locked, or should we adjust the phase within our PLL?</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">case</span><span class="p">(</span><span class="o">{</span> <span class="n">i_input</span><span class="p">,</span> <span class="n">ctr</span><span class="p">[</span><span class="n">MSB</span><span class="o">:</span><span class="n">MSB</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">}</span><span class="p">)</span>
	<span class="mb">4'b0000</span><span class="o">:</span> <span class="n">phase_err</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>	<span class="c1">// No err</span>
	<span class="mb">4'b1001</span><span class="o">:</span> <span class="n">phase_err</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>	<span class="c1">// No Err</span>
	<span class="mb">4'b1110</span><span class="o">:</span> <span class="n">phase_err</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>	<span class="c1">// No err</span>
	<span class="mb">4'b0111</span><span class="o">:</span> <span class="n">phase_err</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>	<span class="c1">// No err</span>
	<span class="nl">default:</span> <span class="n">phase_err</span> <span class="o">=</span> <span class="mb">1'b1</span><span class="p">;</span>
	<span class="k">endcase</span></code></pre></figure>

<p>Notice how the two coordinate systems, that of the <code class="language-plaintext highlighter-rouge">I,Q</code> input and the phase
counter, are not the same.  You can use the figures above to help decode them.
(While it felt like I was counting on my fingers, I got so confused I had
to use similar figures to work out which quadrants of each represented an
error and which did not.)</p>

<p>I also wanted a second bit as well–one that wound indicate whether or not the
PLL’s frequency should be increased or decreased.  A decrease in phase
(and frequency) would be warranted if the PLL’s counter was ever further
clockwise than the incoming phasor, otherwise an increase of each
would be appropriate.</p>

<table align="center" style="float: none"><caption>Fig 19. Lead vs Lag</caption><tr><td><img src="/img/quadpll/lead-vs-lag.png" alt="" width="433" /></td></tr></table>

<p>But what if the two are in opposite quadrants?  That is, what if the <code class="language-plaintext highlighter-rouge">I,Q</code>
input represents a 180 degree difference from the angle represented by the
PLL’s counter?  In this case, I chose to
go both ways–for two quadrants I judged the phase to be too far
forward, and for the other too far backwards.  The resulting table, including
the phase error from above, is shown below.  It should match Fig. 19 for the
first quadrant, and similarly for the other three.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="c1">//</span>
	<span class="c1">// Input {I,Q} (i.e. X,Y) will rotate: 00, 10, 11, 01</span>
	<span class="c1">// The counter will rotate: 00, 01, 10, 11</span>
	<span class="c1">//</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">case</span><span class="p">(</span><span class="o">{</span> <span class="n">i_input</span><span class="p">,</span> <span class="n">ctr</span><span class="p">[</span><span class="n">MSB</span><span class="o">:</span><span class="n">MSB</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">}</span><span class="p">)</span>
	<span class="c1">//</span>
	<span class="mb">4'b0000</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span>	<span class="c1">// No err</span>
	<span class="mb">4'b0001</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b11</span><span class="p">;</span>
	<span class="mb">4'b0010</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b11</span><span class="p">;</span>
	<span class="mb">4'b0011</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b01</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="mb">4'b1000</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b01</span><span class="p">;</span>
	<span class="mb">4'b1001</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span>	<span class="c1">// No Err</span>
	<span class="mb">4'b1010</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b11</span><span class="p">;</span>
	<span class="mb">4'b1011</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b01</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="mb">4'b1100</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b11</span><span class="p">;</span>
	<span class="mb">4'b1101</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b01</span><span class="p">;</span>
	<span class="mb">4'b1110</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span>	<span class="c1">// No err</span>
	<span class="mb">4'b1111</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b11</span><span class="p">;</span>
	<span class="c1">//</span>
	<span class="mb">4'b0100</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b11</span><span class="p">;</span>
	<span class="mb">4'b0101</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b01</span><span class="p">;</span>
	<span class="mb">4'b0110</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b01</span><span class="p">;</span>
	<span class="mb">4'b0111</span><span class="o">:</span> <span class="o">{</span> <span class="n">lead</span><span class="p">,</span> <span class="n">phase_err</span> <span class="o">}</span> <span class="o">=</span> <span class="mb">2'b00</span><span class="p">;</span>	<span class="c1">// No err</span>
	<span class="k">endcase</span></code></pre></figure>

<p>The fun part of this table is that despite its ugly form, it can be
<a href="/blog/2017/06/12/minimizing-luts.html">implemented with nothing more than two
4-LUTs</a>.</p>

<p>But what about that 180-degree out of phase measurement?  You could think
about it as an annoying offset to figure out lead and lag for, or you could
look at it as an opportunity.  If the phase measurement is ever so far out
of phase that we can’t tell which came first, then we are clearly out of lock.</p>

<p>We can use this to generate a crude lock indication.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">quadpll</span><span class="p">(</span><span class="cm">/* ... */</span> <span class="n">o_locked</span><span class="p">);</span>
	<span class="c1">// ...</span>
	<span class="kt">output</span>	<span class="kt">reg</span>			<span class="n">o_locked</span><span class="p">;</span></code></pre></figure>

<p>We can set this lock indicator to be low any time we are off by 180 degrees,
and high otherwise.  True, it’s crude.  Any phase errors between -135 and 135
degrees will appear to be locked.  Worse, this lock indicator will appear
to glitch if it ever falls out of lock.  However, such glitches should be
easy to quickly identify on a trace, and so use to know if the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">PLL</a>
is properly locked or not.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">case</span><span class="p">(</span><span class="o">{</span> <span class="n">i_input</span><span class="p">,</span> <span class="n">ctr</span><span class="p">[</span><span class="n">MSB</span><span class="o">:</span><span class="n">MSB</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">}</span><span class="p">)</span>
		<span class="c1">//</span>
		<span class="mb">4'b0010</span><span class="o">:</span> <span class="n">o_locked</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="mb">4'b1011</span><span class="o">:</span> <span class="n">o_locked</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="mb">4'b1100</span><span class="o">:</span> <span class="n">o_locked</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="mb">4'b0101</span><span class="o">:</span> <span class="n">o_locked</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="n">o_locked</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>	<span class="c1">// Everything else</span>
		<span class="k">endcase</span>
	<span class="k">end</span></code></pre></figure>

<p>The rest of the design, to include how we tracked both phase and frequency, <a href="/dsp/2017/12/14/logic-pll.html">is
the same as our prior design</a>.
That means our tracking loops should all have the same gains and transfer
functions.  In other words, they should perform the same … right?</p>

<p>Let’s take a peek.</p>

<h2 id="performance-difference">Performance difference</h2>

<p>The good news with this new <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature PLL
implementation</a>
is that it is so similar to our last one that we can nearly use the
same Verilator script.  Indeed, a <a href="http://meldmerge.org">graphical diff</a>,
shown in Fig. 20, shows how similar the two scripts actually are.</p>

<table align="center" style="float: right"><caption>Fig 20. Test script differences</caption><tr><td><a href="/img/quadpll/cppdiff.png"><img src="/img/quadpll/cppdiff.png" alt="" width="323" /></a></td></tr></table>

<p>The biggest difference between the two scripts is how the phase is sent to the
core.  In our <a href="https://github.com/ZipCPU/dpll/blob/master/bench/cpp/sdpll_tb.cpp">original test
script</a>,
we defined the phase going into the PLL as nothing more than the MSB
of the phase counter.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">                <span class="n">lclphase</span> <span class="o">+=</span> <span class="n">lclstep</span><span class="p">;</span>
                <span class="n">tb</span><span class="p">.</span><span class="n">i_input</span> <span class="o">=</span> <span class="p">(</span><span class="n">lclphase</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>It’s a little more involved for the quadrature PLL, since we need to convert
from the coordinates of the top two counter bits, as shown in Fig. 18 above,
to the IQ coordinates used by the core, as shown in Fig. 17 above.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">                <span class="n">lclphase</span> <span class="o">+=</span> <span class="n">lclstep</span><span class="p">;</span>
                <span class="n">tb</span><span class="p">.</span><span class="n">i_input</span> <span class="o">=</span> <span class="p">(</span><span class="n">lclphase</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">3</span><span class="p">;</span>
                <span class="c1">// 00 10 11 01</span>
                <span class="k">switch</span><span class="p">(</span><span class="n">tb</span><span class="p">.</span><span class="n">i_input</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="n">tb</span><span class="p">.</span><span class="n">i_input</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="n">tb</span><span class="p">.</span><span class="n">i_input</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="n">tb</span><span class="p">.</span><span class="n">i_input</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="n">tb</span><span class="p">.</span><span class="n">i_input</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span></code></pre></figure>

<p>I say a “little more” involved, because this really isn’t that big of a
change.</p>

<p>Surely this wouldn’t affect performance, right?</p>

<p>Well, let’s take a look at the phase error outputs and compare the two
over time in Fig. 21.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 21. Absolute phase errors</caption><tr><td><img src="/img/quadpll/chart-abserr.png" alt="" width="464" /></td></tr></table>

<p>In this chart, the error is a <code class="language-plaintext highlighter-rouge">-1</code> if the PLL is leading the incoming signal,
<code class="language-plaintext highlighter-rouge">1</code> if the PLL is lagging behind and <code class="language-plaintext highlighter-rouge">0</code> if the two match.  Unfortunately, this
2-bit error quantization approach hasn’t left this chart very readable.  Still,
we might stare at Fig. 21 long enough to imagine that after about 4k samples
the <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature PLL</a>
no longer had the error the
<a href="/dsp/2017/12/14/logic-pll.html">logic PLL</a>
was struggling with.</p>

<p>But are we only imagining this?</p>

<p>Well, I suppose we could cheat and examine the various phase counters from
within the PLLs and compare them to the original counter used to generate
the signal itself.  If you do that, you’ll get something that looks like
Fig. 22.</p>

<table align="center" style="float: right"><caption>Fig 22. Instantaneous phase counter error</caption><tr><td><img src="/img/quadpll/chart-perr.png" alt="" width="490" /></td></tr></table>

<p>As with the previous figure, there’s a lot of junky noise on the left side of
this chart.  This is due to frequency error, and marked by the phase wrapping
around the unit circle and back again.  The large units, +/- 2e9, are simply
the <a href="/dsp/2017/06/15/no-pi-for-you.html">units of the phase
counter</a> that we are
using.  Even in this figure, however, it appears as though the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature PLL</a>’s
phase error converges on a right answer much faster than the
<a href="/dsp/2017/12/14/logic-pll.html">logic PLL</a>’s
error does.</p>

<p>Is there a way to “see” though this junk, though, and get a better picture
of what’s going on?</p>

<p>To find out, let’s average our phase error and see which one gets closer.
Using the same <a href="/dsp/2017/10/16/boxcar.html">boxcar filter</a>
applied to the phase error output from both PLL’s, we see an averaged phase
error plotted in Fig. 23 on the right.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 23. Averaged phase errors</caption><tr><td><img src="/img/quadpll/chart-averr.png" alt="" width="476" /></td></tr></table>

<p>In this chart, it appears as though the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature PLL</a>
quickly ran up a phase error so large it wrapped around the unit
circle.  The
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature PLL</a>
then went from estimating a lead to estimating a lag.  However, before you draw
too much of a conclusion from that, you need to notice that it recovers very
quickly and that from a point of about 8k steps on there’s essentially no
averaged phase error in the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature PLL</a>
whereas the
<a href="/dsp/2017/12/14/logic-pll.html">logic PLL</a>
we built earlier still takes another 5k samples or so to lock.</p>

<p>Are we really achieving a faster lock?</p>

<p>Let’s peek inside the two cores and check their frequency steps.  As you may
recall, the <a href="/dsp/2017/12/09/nco.html">frequency “step” is really a phase step that’s used to implement
a frequency</a>.  As with our
<a href="/dsp/2017/06/15/no-pi-for-you.html">other phase units</a>,
this step ranges from -2e9 to 2e9, although the chosen
“correct” answer is found somewhere near 8.25e8.  Both PLLs are started with
the same erroneous frequency, and then tasked with finding and tracking the
right one.  Fig. 24 shows the frequency steps of the two PLLs as they each
attempt to track the frequency of the incoming waveform.</p>

<table align="center" style="float: right"><caption>Fig 24. Frequency step vs time, showing frequency acquisition time</caption><tr><td><img src="/img/quadpll/chart-fstep.png" alt="" width="476" /></td></tr></table>

<p>By this time, the result comes as no surprise.  The
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature PLL</a>
indeed acquires a phase lock much faster than the basic
<a href="/dsp/2017/12/14/logic-pll.html">logic PLL</a>.</p>

<p>Perhaps this shouldn’t come as such a surprise.  While both cores are using
the same tracking loop, the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature PLL</a>
has a better phase estimator.
Better information going into the loop <em>should</em> result in better performance,
which is what we’ve seen in these figures.  As far as whether the performance
is really 2x better, I’ll let the charts speak for themselves.</p>

<h2 id="conclusions">Conclusions</h2>

<p>With only a few minor modifications, we were able to transform our simple,
basic
<a href="/dsp/2017/12/14/logic-pll.html">logic PLL</a>
into a full-blown
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature PLL</a>
for <a href="https://github.com/ZipCPU/sdr">software (gateware) defined</a>
radio applications.</p>

<p>How well does the
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">new PLL</a>
work?  Judging from performance simulations, it works much better than the
<a href="/dsp/2017/12/14/logic-pll.html">prior PLL</a>.
How about in actual practice?  Sadly, I have
yet to put the two radios together on my desk to measure how well either
the <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/amdemod.v">AM demodulator</a>
or the <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/fmdemod.v">FM demodulator</a>
actually performs.  Until then, I suppose these simulations will feel real good
while never quite being the same as the real thing.</p>

<p>As it is, I’ve already got another discussion queued up regarding how I built
the downsampling filters for the two demodulators.  Those should form another
good discussion, since it’s an important part of digital filtering that we have
yet to discuss on this blog.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>But in those sacrifices there is a remembrance again made of sins every year.  For it is not possible that the blood of bulls and of goats should take away sins. (Heb 10:3-4)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
