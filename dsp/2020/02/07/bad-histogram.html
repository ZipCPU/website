<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A Histogram Gone Bad</title>
  <meta name="description" content="We all like “true stories”.  Today’s tale is one of those “Doh!  It justhappened to me!” stories.">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2020/02/07/bad-histogram.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">A Histogram Gone Bad</h1>
    <p class="post-meta"><time datetime="2020-02-07T00:00:00-05:00" itemprop="datePublished">Feb 7, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>We all like “true stories”.  Today’s tale is one of those “Doh!  It just
happened to me!” stories.</p>

<p>If you’ve been following my blog, you’ll remember the comments I made late last
year about <a href="/dsp/2019/12/21/histogram.html">how valuable a histogram can
be</a>.</p>

<table align="center" style="float: right"><caption>Fig 1. An FPGA defined radio setup</caption><tr><td><img src="/img/histogram/radio-set.jpg" alt="" width="320" /></td></tr></table>

<p>Well, Edmund from <a href="https://symbioticeda.com">Symbiotic EDA</a> had asked me
to build an <a href="https://github.com/ZipCPU/sdr">FPGA radio core</a> for him–just
some simple demonstrator cores that could be used to help teach basic software
defined radio principles to new and young engineers.  The hardware I was given
to use was an <a href="https://github.com/icebreaker-fpga/icebreaker">icebreaker FPGA
board</a>, and an <a href="https://github.com/xil-se/SX1257-PMOD">SX1257
radio PMod</a>.
More specifically, I had two of each of these as shown in Fig. 1.</p>

<p>My thought was to use one of these as a transmitter, and the other as a
receiver.  Even better, I had a <a href="https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/">PMod MIC3 microphone from
Digilent</a>
that I could use to capture audio for the transmitter, and a <a href="https://store.digilentinc.com/pmod-amp2-audio-amplifier/">PMod
AMP2</a>
that I could use to drive a speaker.  I’d used both of these before.  They’re
both easy to use and require little logic.</p>

<p>Put together, the entire system would look something like Fig. 2 below.  An
audio signal would enter the
<a href="https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/">microphone</a>,
get <a href="https://github.com/ZipCPU/sdr">encoded by the
FPGA</a>, and transmitted via the <a href="https://github.com/xil-se/SX1257-PMOD">SX1257
PMod</a>.
On the other half, the reverse would be true: it would be received by the
<a href="https://github.com/xil-se/SX1257-PMOD">SX1257 PMod</a>,
demodulated by the <a href="https://github.com/ZipCPU/sdr">FPGA design</a>, amplified
and then played out using a set of speakers.</p>

<table align="center" style="float: none"><caption>Fig 2. Design components</caption><tr><td><img src="/img/histogram/radio-chain.svg" alt="" width="720" /></td></tr></table>

<p>I also thought I’d get a jump start on the problem by using
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a> and a
<a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">debugging bus</a>.  When
I didn’t have an <a href="https://github.com/ZipCPU/wbi2c">I2C controller suitable</a>
for the I2C to SPI bridge on the part, I reflected that I could <a href="https://github.com/ZipCPU/sdr/blob/master/sw/rfregs.cpp">bit-bang
the configuration of the RF chip from an external CPU host</a>.</p>

<p>My verification strategy was also very simple: I’d create four ports from within
the RTL design of each modulation component, for both transmitter or receiver.
These ports would output a stream of signal data from within the core to a
place where I could capture that data with either a
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">Wishbone scope</a>
or a <a href="/dsp/2019/12/21/histogram.html">histogram</a>.
This would allow me to verify that the data were sufficiently
good before they ever got to the RF chip.</p>

<p>I then quickly drafted some awesomely grand designs: I built an <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/amxmit.v">AM transmitter
core</a>, an <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/fmxmit.v">FM
transmitter core</a>,
and even a 16QAM transmitter.  I then built an
<a href="https://github.com/ZipCPU/sdr/blob/master/rtl/amdemod.v">AM</a> and an
<a href="https://github.com/ZipCPU/sdr/blob/master/rtl/fmdemod.v">FM receiver</a>.
(No, the 16QAM receiver isn’t done yet … which should come as
no surprise to anyone familiar with the challenge.)</p>

<p>Of course, every good tragedy needs to start with a bit of hubris.  In my case,
I got sloppy.  I didn’t build a
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
(initially).  Why not?  I wanted the design done fast.  I had six days where
I could work hand-in-hand with the engineers from <a href="https://symbioticeda.com">Symbiotic
EDA</a>, and I couldn’t wait to see how this looked
on a scope.  What about bugs?  I figured I could debug anything with my
brand-new, wonderful <a href="/dsp/2019/12/21/histogram.html">histogram
core</a> together with my
<a href="/blog/2017/07/08/getting-started-with-wbscope.html">wishbone scope</a>.</p>

<p>Care to hazard a guess at what was going to happen next?</p>

<p>Ok, now that you’ve ventured a guess, let’s see what actually happened.</p>

<h2 id="it-didnt-fit-on-the-device">It didn’t fit on the device</h2>

<p>The first problem I had was that my initial design
<a href="/blog/2020/01/13/reuse.html">didn’t fit</a>.  Worse,
it failed to fit in a way I wasn’t expecting: I’m used to working with
designs that <a href="/blog/2017/06/12/minimizing-luts.html">don’t have enough
LUTs</a>.  If a DSP
algorithm runs out of LUTs, I just lower the various bit-widths in the
processing chain.  I also know how to work around not having enough
multiplies–by working at lower data rates and multiplexing the multiplies
across the algorithm.  You can also look to replace multiplies by shifts.
No, in this case the design didn’t have enough <em>block RAMs</em>.</p>

<p>How much block RAM did I need?</p>

<p>I wanted 4kW (kilo-words) of 16-bit block RAM.  The
<a href="/dsp/2019/12/21/histogram.html">histogram</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/histogram.v">implementation</a>
I had was going to double this into two areas of 4kW, so 8kW in total.
That’s 256 kilobits, or 16 kilobytes.</p>

<p>Why did I want 256 kilobits?  Because I could then split the histogram address
space into a 6-bit X address and a 6-bit Y address.  This would then allow me to
generate a <a href="https://en.wikipedia.org/wiki/Constellation_diagram">constellation
diagram</a> within the FPGA
that would allow me to debug some of the higher order modulations–like my
draft 16QAM transmitter.  While I could use 5x5 bits, 6x6 would give me a
clearer indication, in any 16QAM system, of what was working or not.</p>

<p>Sadly, those 16kB (kilobytes) of memory weren’t fitting on the device.</p>

<p>So I wandered over to <a href="https://github.com/YosysHQ/yosys/blob/master/techlibs/ice40/cells_sim.v">Yosys’ iCE40 cell simulation
library</a>
to understand just how much RAM I actually had available to me.
<a href="https://github.com/YosysHQ/nextpnr">NextPNR</a> told me there
were only 20 RAM cells on this chip.  (There were actually 30, but I had
<a href="https://github.com/YosysHQ/nextpnr">NextPNR</a> configured for
the wrong chip at first.)  I then went and found the library for the
<a href="https://github.com/YosysHQ/yosys/blob/89adef352fde57fa599d66fe404c3c2b9e607a7f/techlibs/ice40/cells_sim.v#L472-L641">SiliconBlue RAM cell</a> used by the
iCE40 UP5K.  With only a cursory glance, I discovered that this RAM required
<a href="https://github.com/YosysHQ/yosys/blob/89adef352fde57fa599d66fe404c3c2b9e607a7f/techlibs/ice40/cells_sim.v#L478">11-bits of read (or write) address</a>,
and <a href="https://github.com/YosysHQ/yosys/blob/89adef352fde57fa599d66fe404c3c2b9e607a7f/techlibs/ice40/cells_sim.v#L476">16-bits of data</a>.  Perfect!  That
would make for 2kW of 16-bit RAM per block, so my design should fit in 8 blocks.</p>

<p>Why was <a href="https://github.com/YosysHQ/yosys">yosys</a> mapping my design to more
than 20 blocks?</p>

<p>I decided to look deeper, and so I added a
<a href="https://github.com/YosysHQ/yosys">yosys</a> <a href="http://www.clifford.at/yosys/cmd_write_verilog.html">command to output the synthesized
netlist in Verilog</a> form.
Much to my surprise, it was only ever using four bits of this RAM at any given
time.</p>

<p>Huh?</p>

<p>With some help from mwk, I learned that my cursory examination of the
<a href="https://github.com/YosysHQ/yosys/blob/89adef352fde57fa599d66fe404c3c2b9e607a7f/techlibs/ice40/cells_sim.v#L472-L641">SB_RAM40_4K</a>
block was too cursory.  The
<a href="https://github.com/YosysHQ/yosys/blob/89adef352fde57fa599d66fe404c3c2b9e607a7f/techlibs/ice40/cells_sim.v#L472-L641">SB_RAM40_4K</a>
block only offered four <em>kilobits</em> of RAM.  This ram had several configurations.
It could be configured into 256 words of 16-bits each, requiring the 16-bit
data width.  It could also be configured into 2048 words of 2-bits each,
requiring the 11-bit address width.  Each of those configurations used exactly
four <em>kilobits</em> of memory, and they were mutually exclusive.  There was no
configuration that used both 11 address bits and 16-data bits.</p>

<p>Apparently, this is common among FPGA architectures: to have a block of RAM
that has multiple data and address width configurations.</p>

<p>Worse, my
<a href="/dsp/2019/12/21/histogram.html">histogram</a>
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/histogram.v">implementation</a>
had two read ports.  Since the iCE40 doesn’t have RAMs with dual read ports,
<a href="https://github.com/YosysHQ/yosys">Yosys</a>
was doubling my RAM usage to create two read ports.  Each RAM was connected
to the same write port, so each RAM would have the same contents, I could
just read them from different places within my design.</p>

<p>Ok, I can deal with that.  How hard can it be to adjust a design so that it
shares a single read port between two pieces of logic?  Just a couple changes
should be sufficient:</p>

<ol>
  <li>
    <p>I set the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone stall
signal</a>, so that on
any internal data read/update request within the
<a href="/dsp/2019/12/21/histogram.html">histogram</a> logic, the
data request would get priority.</p>

    <p>This shouldn’t slow down the
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>
at all: the debugging core I was using was the <a href="https://github.com/ZipCPU/dbgbus/tree/master/hexbus">hexbus we’d built together
on this blog</a>.  It’s
slow, but low logic.  Moreover, the audio samples weren’t likely to
generate constant valid signals into the
<a href="/dsp/2019/12/21/histogram.html">histogram</a>,
so this should at most stall the bus by a single clock cycle.</p>
  </li>
  <li>
    <p>I then added a new <a href="/blog/2017/08/14/strategies-for-pipelining.html">pipeline
stage</a>
to the <a href="/dsp/2019/12/21/histogram.html">histogram</a>’s
to the processing chain–one where I
calculated the memory address.  While this didn’t seem to adjust the area
much at all, I judged it to be a good addition.  In my
<a href="/tutorial">beginner’s tutorial</a>, I discuss several rules
of block RAM usage, one of which is that the address should always be
registered.  This change registered that address.</p>
  </li>
</ol>

<p>Just so you can understand how simple this change was, compare the two
waveforms shown in Fig. 3 below.</p>

<table align="center" style="float: center"><caption>Fig 3. Design waveform before and after the change</caption><tr><td><img src="/img/histogram/badhist-before.svg" alt="" width="294" /></td><td><img src="/img/histogram/badhist-after.svg" alt="" width="378" /></td></tr><tr><th>Before</th><th>With Changes</th></tr></table>

<p>Here you can see how the stall line becomes the equivalent of the <code class="language-plaintext highlighter-rouge">i_ce</code> line,
and how there’s now a new <code class="language-plaintext highlighter-rouge">read_addr</code> register multiplexing the two read
requests together.  You can also see how the data takes another clock before
it can become valid.</p>

<h2 id="other-changes">Other changes</h2>

<p>I did need to make some other changes as well.  One in particular was needed for
the <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/amdemod.v">AM demodulator</a>.
For this project, I needed an <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/quadpll.v">quadrature (complex I+Q)
PLL</a>,
and the <a href="/dsp/2017/12/14/logic-pll.html">one we built
together</a> was only a
<a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">single wire PLL</a>.</p>

<p>This was easily adjusted for quadrature, and the resulting (simulated)
performance appeared to be twice as good as the <a href="https://github.com/ZipCPU/dpll/blob/master/rtl/sdpll.v">similar, single channel
PLL implementation</a>
for the same PLL gain.</p>

<table align="center" style="float: left"><caption>Fig 4. Comparing the original PLL with the I+Q Quadrature PLL</caption><tr><td><img src="/img/histogram/quad-pll-comparison.png" alt="" width="496" /></td></tr></table>

<p>I’m going to try to remember to come back to this to make it an article in
its own right–since the change was easy to do, and since I think it’d make
an awesome blog article.</p>

<h2 id="what-happened">What happened?</h2>

<p>Well, the updated design didn’t work.  (Surprise!)  Perhaps you figured out
that this was going to happen from the setup above.</p>

<ol>
  <li>
    <p>The first curious problem was that I was often not getting any data at
all into the <a href="/dsp/2019/12/21/histogram.html">histogram</a>.
It would read all zeros.</p>

    <p>This suggested that the <code class="language-plaintext highlighter-rouge">i_ce</code> signal was never getting set.  We’ll look
at what happened there in a moment.</p>
  </li>
  <li>
    <p>When I did get a
<a href="/dsp/2019/12/21/histogram.html">histogram</a>
result, it just looked like junk.</p>

    <p>Was it just that the
<a href="https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/">microphone</a>
was returning junk in the first place?  That didn’t make sense, since I’d
used the <a href="https://github.com/ZipCPU/wbpmic">microphone SPI</a> core
<a href="https://github.com/ZipCPU/fftdemo">before</a>.</p>
  </li>
  <li>
    <p>Often, the <a href="/dsp/2019/12/21/histogram.html">histogram</a>
might read like it was all <em>large</em> values.  For example, when taking a
<a href="/dsp/2019/12/21/histogram.html">histogram</a>
of 16k samples, adding all the elements together might result in over
a million counts.</p>

    <p>Ok, now that’s a clear bug.</p>
  </li>
</ol>

<p>What might the problem be?</p>

<p>As it turns out, there were several.</p>

<p>The first problem was associated with how I generated the sampling signal for
the <a href="https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/">microphone</a>.
As is common with designs such as this, the signal processing
chain can use the <a href="/blog/2017/08/14/strategies-for-pipelining.html">“global CE” strategy for pipeline
signaling</a>.
Key to this strategy is to set the time when a new sample would be generated.
For this I used a straight <a href="/blog/2017/06/02/generating-timing.html">fractional clock
divider</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">        <span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_audio_en</span><span class="p">)</span>
                <span class="o">{</span> <span class="n">mic_ce</span><span class="p">,</span> <span class="n">mic_ce_counter</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">else</span>
                <span class="o">{</span> <span class="n">mic_ce</span><span class="p">,</span> <span class="n">mic_ce_counter</span> <span class="o">}</span> <span class="o">&lt;=</span> <span class="n">mic_ce_counter</span> <span class="o">+</span> <span class="n">MIC_STEP</span><span class="p">;</span></code></pre></figure>

<p>Perhaps you may recall <a href="/blog/2017/06/02/generating-timing.html">discussing this
earlier</a>?  Or again
when we discussed the <a href="/dsp/2017/06/15/no-pi-for-you.html">units of
phase</a> in the
<a href="/dsp/2017/12/09/nco.html">NCO article</a>?</p>

<p>The entire downsample rate was governed by a simple equation,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="n">MIC_STEP</span> <span class="o">=</span> <span class="n">CLOCK_RATE_HZ</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span> <span class="o">/</span> <span class="n">AUDIO_SAMPLE_RATE</span><span class="p">;</span></code></pre></figure>

<p>Well, no, that didn’t work right.  Worse, it doesn’t pass the smell test.
(Remember studying units in science?)  In this case, as the <code class="language-plaintext highlighter-rouge">AUDIO_SAMPLE_RATE</code>
increases, the step size should increase–not decrease.</p>

<p>Let’s try that again.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="n">MIC_STEP</span> <span class="o">=</span> <span class="n">AUDIO_SAMPLE_RATE</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCK_RATE_HZ</span><span class="p">;</span></code></pre></figure>

<p>(This actually took me <em>hours</em> to find, since I was looking all over in the
wrong places, but that’s another story.)</p>

<p>This change made things better, but they still weren’t quite right.  Using
this formula, the <a href="/dsp/2019/12/21/histogram.html">histogram</a>
would never  count any samples coming into it: <code class="language-plaintext highlighter-rouge">mic_ce</code> was staying low.
Indeed, if you dug into the design, <code class="language-plaintext highlighter-rouge">mic_ce_counter</code> was set to zero and never
updated.</p>

<p>If you haven’t figured it yet, the hidden issue here is that all Verilog
integers are 32-bits in size by default.  In a 32-bit word, <code class="language-plaintext highlighter-rouge">1&lt;&lt;32</code> truncates
to zero.  This was not the desired effect I wanted.</p>

<p>One way around this is to use floating point values, and then to round the
results to fixed point.  We’ll also insist that <code class="language-plaintext highlighter-rouge">1&lt;&lt;32</code> be replaced with
something that won’t overflow, <code class="language-plaintext highlighter-rouge">4.0 * (1&lt;&lt;30)</code> for example.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">localparam</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">MIC_STEP</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">)</span> <span class="o">*</span> <span class="n">AUDIO_SAMPLE_RATE</span>
			<span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">CLOCK_RATE_HZ</span><span class="p">;</span></code></pre></figure>

<table align="center" style="float: right"><caption>Fig 5. The histogram didn't look right</caption><tr><td><img src="/img/histogram/bad-histogram.png" alt="" width="478" /></td></tr></table>

<p>Now I could see samples coming from the
<a href="/dsp/2019/12/21/histogram.html">histogram</a>, as shown
in Fig. 5.</p>

<p>Well, I suppose that’s better than all zeros.  Only, it’s still not what I was
expecting at all.</p>

<p>Were the incoming samples from the
<a href="https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/">microphone</a>
really all that bad?  Was I over driving the
<a href="https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/">microphone</a>?
Sure, there was a lot of talking in a busy room, but I could still hear myself
whisper.</p>

<p>After desk checking my design again for the umpteenth time looking for a bug,
I decided to return to <a href="https://symbiyosys.readthedocs.io/en">SymbiYosys</a>
and formally verify my changes to my
<a href="/dsp/2019/12/21/histogram.html">histogram</a> core.</p>

<p>What were the changes?  Well, the biggest change was replacing the <code class="language-plaintext highlighter-rouge">o_wb_stall</code>
signal,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span></code></pre></figure>

<p>with a signal that would only accept an request if the <code class="language-plaintext highlighter-rouge">i_ce</code> signal, indicating
a new incoming sample, was low.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">o_wb_stall</span> <span class="o">=</span> <span class="n">i_ce</span><span class="p">;</span></code></pre></figure>

<p>I also replaced the read address to memory with a register that would select
between one of two read addresses–either the one read from the bus, or the
one to be written to in order to reflect the new data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_wb_stall</span><span class="p">)</span>
		<span class="c1">// Read a count to update it with a new sample</span>
		<span class="n">read_addr</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="n">activemem</span><span class="p">,</span> <span class="n">i_sample</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="c1">// Bus read</span>
		<span class="n">read_addr</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="o">!</span><span class="n">activemem</span><span class="p">,</span> <span class="n">i_wb_addr</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>The one block RAM read would then read from this new address one clock later.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">memval</span> <span class="o">&lt;=</span> <span class="n">mem</span><span class="p">[</span><span class="n">read_addr</span><span class="p">];</span></code></pre></figure>

<p>The outgoing data was also adjusted.  Instead of returning the value from
the memory straight to the bus,</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_wb_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">o_wb_data</span><span class="p">[</span><span class="n">ACCW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="o">{</span> <span class="o">!</span><span class="n">activemem</span><span class="p">,</span> <span class="n">i_wb_addr</span> <span class="o">}</span><span class="p">];</span>
	<span class="k">end</span></code></pre></figure>

<p>I would now return this intermediate value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_wb_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">o_wb_data</span><span class="p">[</span><span class="n">ACCW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">memval</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>Looking through these changes, I didn’t see any problems.  They all looked
good to me.  So, as I mentioned before, in a moment of frustration I turned
to formal methods.</p>

<p>I also added my <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone property
file</a> to the formal proof.
Sure, the <a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone</a>
interaction was simple enough that I should’ve been able to verify it by eye,
but I still couldn’t find the bug and it made sense to check all possibilities,
and this was an easy one to check.</p>

<p>Once the properties were in place, I found the following in a matter of
seconds.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">reset</span> <span class="o">&amp;&amp;</span> <span class="n">i_wb_stb</span><span class="p">;</span></code></pre></figure>

<p>This says that we’ll acknowledge a request immediately on the clock following
the request.  Notice how the acknowledgment isn’t dependent upon the stall
signal, <code class="language-plaintext highlighter-rouge">o_wb_stall</code>.</p>

<p>One of the basic rules of bus property files is that there should never be
any acknowledgments without prior requests.  In this case, the formal tool
held <code class="language-plaintext highlighter-rouge">i_ce &amp;&amp; i_wb_stb</code> high long enough to get an <code class="language-plaintext highlighter-rouge">o_wb_ack</code>–even without
<code class="language-plaintext highlighter-rouge">i_wb_stb &amp;&amp; !o_wb_stall</code> ever having been true.</p>

<p>Staring at this some more, I realized that it would also take two clock
cycles for any read, so I adjusted this ACK line for a two cycle read.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span> <span class="o">{</span> <span class="n">o_wb_ack</span><span class="p">,</span> <span class="n">pre_ack</span> <span class="o">}</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">pre_ack</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">i_reset</span> <span class="o">&amp;&amp;</span> <span class="n">i_wb_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_wb_stall</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">o_wb_ack</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">reset</span> <span class="o">&amp;&amp;</span> <span class="n">i_wb_cyc</span> <span class="o">&amp;&amp;</span> <span class="n">pre_ack</span><span class="p">;</span></code></pre></figure>

<p>Now the acknowledgment would match Fig. 3 above!</p>

<p>I was so excited!  I’d now found my bug–after midnight, after I’d left the
lab, etc.  I was very excited to go to the lab the next day to check out
how things had changed.  Indeed, I was so excited about finding this bug that
I started writing this article to share what had happened.</p>

<p>The good news is that, once I got to the lab, I was now getting different
<a href="/dsp/2019/12/21/histogram.html">histogram</a>s.</p>

<table align="center" style="float: left"><caption>Fig 6. First fix, but still not right</caption><tr><td><img src="/img/histogram/bad-hist-multimode.png" alt="" width="490" /></td></tr></table>

<p>The bad news was that they still didn’t look right.  Fig. 6 shows one of the
traces I received after making the fix above.</p>

<p>At this point I finally bit the bullet and built a proper
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a> of
the design.  In my
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
I would feed a swept tone into the <a href="https://github.com/ZipCPU/wbpmic/blob/master/bench/cpp/micnco.cpp">emulated
microphone</a>,
and watch how the design responded.  More specifically, I’d request a
<a href="/dsp/2019/12/21/histogram.html">histogram</a>,
and then look at the trace of what was happening.</p>

<p>Sure enough, the <a href="/blog/2017/06/21/looking-at-verilator.html">simulation
trace</a>
showed the problem: The acknowledgment was set one clock before the data was
ready.</p>

<p>Did you catch that in the logic above?  There was …</p>

<ol>
  <li>
    <p>One clock to accept the bus request and set the address</p>
  </li>
  <li>
    <p>One clock to read from memory (and set the acknowledgment), and</p>
  </li>
  <li>
    <p>A third clock to return the results to the bus.</p>
  </li>
</ol>

<p>The third clock was simply added in because I didn’t quite think through
what was going on.  It would’ve helped if I had drawn out a design waveform,
similar to Fig. 3 above, but, No, I didn’t do that until I started writing
this article.  Here was the block at fault.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">o_wb_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">o_wb_data</span><span class="p">[</span><span class="n">ACCW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">memval</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>One simple change fixed this bug.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>	<span class="c1">// &lt;&lt;---- The change</span>
	<span class="k">begin</span>
		<span class="n">o_wb_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">o_wb_data</span><span class="p">[</span><span class="n">ACCW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">memval</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<table align="center" style="float: right"><caption>Fig 7. Histogram, now fixed</caption><tr><td><img src="/img/histogram/good-histogram.png" alt="" width="490" /></td></tr></table>

<p>Once I made this change, the
<a href="/dsp/2019/12/21/histogram.html">histogram</a> started looking
more reasonable.  Fig. 7 on the right shows an example of the new
<a href="/dsp/2019/12/21/histogram.html">histogram</a> output.
Indeed, this was very much what I was expecting.</p>

<p>Notice that all of the data are centered around either zero or the maximum
value (i.e. -1, or in this case <code class="language-plaintext highlighter-rouge">10'h3ff</code>).  This would be indicative of
an idle channel, where the
<a href="https://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain/">microphone</a>
isn’t overloaded.</p>

<p>Perfect!</p>

<p>What about the fact that I was recording millions of counts from a 16k count
<a href="/dsp/2019/12/21/histogram.html">histogram</a>?  That was now
fixed.  What was happening was that the data being sent to the core was
routinely the most common value, causing the
<a href="/dsp/2019/12/21/histogram.html">histogram</a>
to stall on a bus read, but then return the
<a href="/dsp/2019/12/21/histogram.html">histogram</a> point for that
most common value rather than the point requested from the bus.</p>

<p>Shouldn’t this have been caught using formal methods?  Indeed, it should
have been.  Then why didn’t my formal properties catch this?</p>

<p>Because I had used a <code class="language-plaintext highlighter-rouge">cover()</code> statement to capture the property that the
<em>right</em> value would be returned from the bus, and not an <code class="language-plaintext highlighter-rouge">assert()</code> statement.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">cover</span> <span class="k">property</span> <span class="p">(</span><span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">clk</span><span class="p">)</span>
		<span class="c1">// A read request, for our formally tracked value</span>
		<span class="n">i_wb_stb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o_wb_stall</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i_wb_addr</span> <span class="o">==</span> <span class="n">f_addr</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">activemem</span>
			<span class="o">&amp;&amp;</span> <span class="n">f_addr</span><span class="p">[</span><span class="n">AW</span><span class="p">]</span> <span class="o">==</span> <span class="o">!</span><span class="n">activemem</span>
		<span class="c1">//</span>
		<span class="c1">// The valid address cycle</span>
		<span class="p">##</span><span class="mi">1</span> <span class="n">i_wb_cyc</span> <span class="o">&amp;&amp;</span> <span class="n">pre_ack</span>
		<span class="c1">//</span>
		<span class="c1">// The returned data cycle</span>
		<span class="p">##</span><span class="mi">2</span> <span class="n">o_wb_ack</span> <span class="o">&amp;&amp;</span> <span class="n">o_wb_data</span><span class="p">[</span><span class="n">ACCW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">f_mem_data</span>
			<span class="o">&amp;&amp;</span> <span class="n">f_mem_data</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure>

<p>Yes, it was <em>possible</em> to return the right value to the bus, and so the
<code class="language-plaintext highlighter-rouge">cover()</code> statement passed.  Had I expressed this in the form of an <code class="language-plaintext highlighter-rouge">assert()</code>
statement, <a href="https://symbiyosys.readthedocs.io/en">SymbiYosys</a>
would’ve caught the bug.</p>

<h2 id="conclusion">Conclusion</h2>

<p>So, what sorts of conclusions can we draw from this?</p>

<ol>
  <li>
    <p>Even the “perfect” core might <a href="/blog/2020/01/13/reuse.html">need to be adjusted to fit the
hardware</a> du jour.</p>
  </li>
  <li>
    <p>Sloppiness, whether by not formally verifying these changes or not building a
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
to check my work earlier, slowed me down.  It didn’t speed me up–in spite
of my best intentions.</p>
  </li>
  <li>
    <p>From the “Tau of Programming” and roughly quoted, “Though a piece of code
be but four lines long, someday it will need to be maintained.”</p>
  </li>
</ol>

<p>The <a href="https://github.com/ZipCPU/sdr">entire design</a> is now posted, although I’ll
be the first to say that only the AM and FM modulations work, and even then
they only work in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>.
Chances are I would’ve made more progress if I’d immediately gone to formal
verification and then
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>,
rather than trying to jump straight to the hardware where debugging is just
that much more difficult.  For now, the design will wait again in its current
unfinished/limbo state until I have some more time to play with it.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>If the iron be blunt, and he do not whet the edge, then must he put to more strength: but wisdom is profitable to direct. (Eccl 10:10)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
