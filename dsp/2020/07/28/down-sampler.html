<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Building a Downsampling Filter</title>
  <meta name="description" content="Some time back, I asked my Patreon sponsorsfor topics they’d be interested in reading about.  One particular request wasto discuss how to put all the pieces ...">

  <link rel="shortcut icon" type="image/x-icon" href="/img/GT.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://zipcpu.com/dsp/2020/07/28/down-sampler.html">
  <link rel="alternate" type="application/rss+xml" title="The ZipCPU by Gisselquist Technology" href="https://zipcpu.com/feed.xml">
</head>


  <body>

    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4ZK7HKHSVW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4ZK7HKHSVW');
</script>

    <header class="site-header">
  <div id="banner">
  <a href="/"><picture>
    <img height=120 id="site-logo" src="/img/fullgqtech.png" alt="Gisselquist Technology, LLC">
  </picture></A>
  </div>

  <div class="site-nav">
<ul>

<li><a HREF="/">Main/Blog</a>


<li><a HREF="/about/">About Us</a>


<li><a HREF="/fpga-hell.html">FPGA Hell</a>


<li><a HREF="/tutorial/">Tutorial</a>
<li><a HREF="/tutorial/formal.html">Formal training</a>


<li><a HREF="/quiz/quizzes.html">Quizzes</a>


<li><a HREF="/projects.html">Projects</a>


<li><a HREF="/topics.html">Site Index</a>

<HR>

<li><a href="https://twitter.com/zipcpu"><span class="icon--twitter"><svg viewBox="0 0 400 400"><path fill="#1da1f2" d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23"/></svg>
</span><span class="username">@zipcpu</span></a>

<li><a href="https://www.reddit.com/r/ZipCPU"><span class="username">Reddit</a>
<li><a HREF="https://www.patreon.com/ZipCPU"><IMG SRC="/img/patreon_logomark_color_on_white.png" WIDTH="25"> Support</a>
</ul>
</div>


</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="https://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Building a Downsampling Filter</h1>
    <p class="post-meta"><time datetime="2020-07-28T00:00:00-04:00" itemprop="datePublished">Jul 28, 2020</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Some time back, I asked <a href="https://www.patreon.com/ZipCPU">my Patreon sponsors</a>
for topics they’d be interested in reading about.  One particular request was
to discuss how to put all the pieces together into a
DSP design.  Since I had a nice <a href="https://github.com/ZipCPU/fftdemo">open-source FFT demonstrator–a basic
spectrogram display</a>–I thought that
might make a nice example to work with.</p>

<p>If you look at that project, you might be surprised at how easy it is to read
the data flow through the
<a href="https://github.com/ZipCPU/fftdemo/blob/master/rtl/main.v">main verilog file</a>.
As shown in Fig. 1 below, the data flow follows a very linear series of steps.</p>

<table align="center" style="float: right"><caption>Fig 1. Steps to a Spectrogram</caption><tr><td><a href="/img/fftdemo/spectral-overview.svg"><img src="/img/fftdemo/spectral-overview.svg" alt="" width="559" /></a></td></tr></table>

<p>It starts with a analog to digital converter, in this case from a <a href="http://store.digilentinc.com/pmod-mic3-mems-microphone-with-adjustable-gain">Digilent
PMod that produces data at
1Msps</a>.
Since this is still way too fast for a
<a href="https://en.wikipedia.org/wiki/Spectrogram">spectrogram</a> operation, the data is
sent into a <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">downsampler</a>–the
topic of today’s discussion.  Coming out of the <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">downsampler</a>,
the data goes either into a traditional
<a href="/dsp/2018/10/02/fft.html">FFT</a>
<a href="https://en.wikipedia.org/wiki/Window_function">window function</a>
or a <a href="/dsp/freq-teaser.html">fancier
window</a>
with (almost) no spectral leakage.  From there, the data passes through an
<a href="/dsp/2018/10/02/fft.html">FFT</a>, the
logarithm of the complex output magnitude squared is calculated, and then
everything gets written to memory.  The final step, <a href="/blog/2018/11/29/llvga.html">drawing the results to
the screen</a>, is somewhat
of an icing on the cake.</p>

<p>Let’s set ourselves as a goal understanding <a href="https://github.com/ZipCPU/fftdemo/blob/master/rtl/main.v">how this design
works</a>.
We’ve already discussed how to build a <a href="/blog/2018/11/29/llvga.html">VGA display
controller</a>, although we
may also choose to come back in order to discuss it’s
<a href="https://github.com/ZipCPU/fftdemo/blob/master/rtl/hdmiddr.v">HDMI cousin</a>
along the way.  We’ve also discussed the
<a href="/blog/2018/07/06/afifo.html">asynchronous FIFO</a> that’s used
to feed this <a href="/blog/2018/11/29/llvga.html">VGA controller</a>,
and the <a href="/dsp/2018/10/02/fft.html">FFT</a>
that forms the center of the operation.  We’ve also discussed the
<a href="/blog/2020/03/23/wbm2axisp.html">Wishbone to AXI bridge</a>
that I use to make <a href="https://en.wikipedia.org/wiki/DDR3_SDRAM">DDR3 SDRAM</a>
access easy to work with.</p>

<p>Other fun topics we might discuss include the <a href="https://en.wikipedia.org/wiki/Window_function">FFT window
function</a>, or how the
display was put together so as to give the appearance of a horizontally
scrolling raster.  (Vertical scrolling would’ve been easier.)  Perhaps the
more important components are
<a href="https://github.com/ZipCPU/wbpmic">the A/D controller</a>, and the <a href="https://github.com/ZipCPU/fftdemo/blob/master/rtl/video/wbvgaframe.v">framebuffer
“memory to pixel”
controller</a>.</p>

<p>Today, though, I’d like to discuss the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">downsampler</a>.</p>

<p>Yes, <a href="/dsp/dsp.html">we’ve discussed filtering before</a>.
We’ve even gone over several filtering implementations.
[<a href="/dsp/2017/08/19/simple-filter.html">1</a>]
[<a href="/dsp/2017/09/15/fastfir.html">2</a>]
[<a href="/dsp/2017/09/29/cheaper-fast-fir.html">3</a>]
[<a href="/dsp/2017/10/16/boxcar.html">4</a>]
[<a href="/dsp/2017/11/04/genfil-tb.html">5</a>]
[<a href="/dsp/2017/12/30/slowfil.html">6</a>]
[<a href="/dsp/2018/05/17/slowsymf.html">7</a>]
[<a href="/zipcpu/2018/12/20/sby-makefile.html">8</a>]
That said, we haven’t really discussed how to integrate
<a href="/blog/2017/10/19/formal-intro.html">formal verification</a>
in DSP designs.  Nor have we discussed how to handle multiple signaling rates.
I’d also like to discuss the ever present scaling problem, but at this point
I’m not sure I have a good solution to offer for it.</p>

<p>But we’ll get to all that.</p>

<p>For now, let’s start with the
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">downsampler</a>.</p>

<h2 id="downsampling">Downsampling</h2>

<p>At it’s most basic, a
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampler</a>
is a logic block that takes a signal sampled at one rate and
<a href="https://en.wikipedia.org/wiki/Sample-rate_conversion">resamples</a> it at a
lower rate.  This can be as simple as just
picking every Nth sample.  You can also get fancy and <a href="/dsp/2018/03/30/quadratic.html">interpolate between
sample points</a>, and
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsample</a>
by some rational amount such as <code class="language-plaintext highlighter-rouge">16368/2048</code> (a common
<a href="https://en.wikipedia.org/wiki/Global_Positioning_System">GPS</a>
problem).  Since this is really my first post on the topic of
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampling</a>,
we’ll stick to the every Nth sample variety.</p>

<table align="center" style="float: left"><caption>Fig 2. A digital downsampler</caption><tr><td><img src="/img/fftdemo/downsampler.svg" alt="" width="130" /></td></tr></table>
<p><!-- Was 13 wide --></p>

<p>For such a simple
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampler</a>,
we might initially describe the operation as simply taking one point out of
every <code class="language-plaintext highlighter-rouge">D</code> points,</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-raw-dsample.png" alt="" width="164" /></td></tr></table>

<p>Of course, there are problems with this easy solution in practice.  The biggest
of these problems is “<a href="https://en.wikipedia.org/wiki/Aliasing">aliasing</a>”.
Perhaps you may remember the <a href="/dsp/2017/09/16/pwm-demo.html">problem with
aliasing from the demonstration</a> of the <a href="/dsp/2017/09/04/pwm-reinvention.html">“improved” PWM
implementation</a>.  In
<a href="/dsp/2017/09/16/pwm-demo.html">that implementation</a>, a single
up-swept tone input also produced a tone sweeping in the other direction.</p>

<table align="center" style="float: none"><caption>Fig 3: Test Results for the Improved Signal Generator</caption><tr><td><img src="/img/pwm-demo/pdm32k.png" alt="Test Results, PDM, 32kHz sample rate" width="780" /></td></tr></table>

<p>Note that the zero frequency is (unconventionally) at the <em>top</em> of Fig. 3,
so an upswept tone appears as a diagonal line from the top (zero frequency)
left (zero time) corner.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Aliasing">aliasing</a> problem was worse when
we didn’t use a
<a href="https://en.wikipedia.org/wiki/Sample-rate_conversion">resampling</a>
filter.  In this case, the single swept tone input appeared to produce multiple
swept tones in what appeared to be a crosshatch pattern on the
<a href="https://en.wikipedia.org/wiki/Spectrogram">spectrogram</a>.</p>

<table align="center" style="float: none"><caption>Fig 4: Test Results for the improved signal generator, with an 8kHz based interval</caption><tr><td><img src="/img/pwm-demo/pdm8k.png" alt="Test Results, PDM, 8kHz interval rate" width="780" /></td></tr></table>

<p>In <a href="/dsp/2017/09/16/pwm-demo.html">that application</a>,
we were <a href="https://en.wikipedia.org/wiki/Upsampling">upsampling</a> and not
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampling</a>,
but the principle is still the same: out of band signals might
<a href="https://en.wikipedia.org/wiki/Aliasing">alias</a> in-band if we aren’t careful.</p>

<p>To see this mathematically, imagine we have an incoming signal which
consists of a <a href="https://en.wikipedia.org/wiki/Euler's_formula">complex
exponential</a>.</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-xomega.png" alt="" width="269" /></td></tr></table>

<p>If you just
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsample</a>,
this signal, picking every <code class="language-plaintext highlighter-rouge">D</code>‘th sample, then
<a href="https://en.wikipedia.org/wiki/Euler's_formula">this exponential</a>
will now exist in many places of the resulting spectrum.</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-yw-unwanted.png" alt="" width="496" /></td></tr></table>

<p>If on the other hand we first
<a href="https://en.wikipedia.org/wiki/Convolution">convolve</a> our signal with some kind
of “<a href="/dsp/2017/09/15/fastfir.html">filter</a>”,</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-yw-filtered.png" alt="" width="629" /></td></tr></table>

<p>we can now use the <a href="/dsp/2017/09/15/fastfir.html">filter</a>
to control how much of this
<a href="https://en.wikipedia.org/wiki/Euler's_formula">exponential</a> ends up in our
result.</p>

<table align="center" style="float: right"><caption>Fig 5. Solution to aliasing: filter before downsampling</caption><tr><td><img src="/img/fftdemo/subfildown.svg" alt="" width="240" /></td></tr></table>

<p>Indeed, the only way to make certain that the
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampled</a>
signal, <img src="/img/fftdemo/eqn-ydomega.png" alt="Y_d(omega)" />,
contains only the spectral content from the band of interest is to
<a href="/dsp/2017/09/15/fastfir.html">filter</a> out all of the other
<img src="/img/fftdemo/eqn-xomega-relevant.png" alt="X()" /> bands.  For this
reason, the <a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampling
operation</a>
needs to be coupled with a
<a href="/dsp/2017/09/15/fastfir.html">filter</a>
operation as well, as shown in Fig. 5.</p>

<p>With a proper <a href="/dsp/2017/09/15/fastfir.html">filter</a>
before our
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampler</a>,
we can mitigate the problems associated with
<a href="https://en.wikipedia.org/wiki/Aliasing">aliasing</a>.</p>

<p>Operationally, this would look like Fig. 5 above.  We might write the two
steps as,</p>

<ol>
  <li><a href="/dsp/2017/09/15/fastfir.html">Filter</a></li>
</ol>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-convolution.png" alt="" width="254" /></td></tr></table>

<ol start="2">
  <li>Select every <code class="language-plaintext highlighter-rouge">D'</code>th output sample</li>
</ol>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-postfilter-resample.png" alt="" width="164" /></td></tr></table>

<p>Sadly, <a href="/dsp/2017/09/15/fastfir.html">filter</a>s
can be <a href="/dsp/2017/12/30/slowfil.html">expensive to
implement</a>, and good
<a href="/dsp/2017/09/15/fastfir.html">filter</a>s
all the more so.  The <a href="/dsp/2017/09/15/fastfir.html">filtering
operation</a> associated with a
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampler</a>,
however, is a special case since we don’t really care about <em>every</em> outgoing
sample.  We only care about every <code class="language-plaintext highlighter-rouge">Dth</code> sample.  A <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">smarter
implementation</a>
might calculate just these outputs, and spare us from the heavy computational
burden of calculating results we aren’t going to use.</p>

<p>Here’s the problem: my <a href="/dsp/2018/05/17/slowsymf.html">cheapest filter so
far</a> can only accomplish a
<img src="/img/fftdemo/eqn-2n.png" alt="2N" /> tap filter if the data rate is
<img src="/img/fftdemo/eqn-1overn.png" alt="1/N" /> to begin with.  In
the case of the above <a href="https://github.com/ZipCPU/fftdemo">FFT demonstration
design</a>,
the system clock is 100Mhz, and the incoming sample rate is 1MHz.  If I used
<a href="/dsp/2018/05/17/slowsymf.html">this cheap filter</a>,
I would only ever be able to implement a 200 tap filter.</p>

<table align="center" style="float: left; padding: 15px"><caption>Fig 6. Chosen decimation filter response</caption><tr><td><img src="/img/fftdemo/decimator-response.png" alt="" width="491" /></td></tr></table>

<p><a href="https://github.com/ZipCPU/fftdemo">My spectrogram design</a>,
required a 1023 tap filter followed by a 23:1
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampler</a>
in order to get the -80 dB out-of-band rejection I wanted.
A 200 tap filter would never cut it.</p>

<p>On the other hand, what if we built something like the <a href="/dsp/2017/12/30/slowfil.html">cheap filter we built
before</a>, but this time
engineered it so that it only produced those values that we were going to keep?
Hence, we we’d only calculate values
<img src="/img/fftdemo/eqn-ynd.png" alt="y[nD]" />
(for all values of <code class="language-plaintext highlighter-rouge">n</code>), rather
than the unused values such as
<img src="/img/fftdemo/eqn-unused-series.png" alt="y[nD+1], y[nD+2]" />, etc.
We could do this if
we <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">merged the downsampler and the filter
together</a>,
as in:</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-downsampled-convolution.png" alt="" width="282" /></td></tr></table>

<p>Using this method, I could then implement a 2300 tap filter as we’ll discuss
below–even though <a href="https://github.com/ZipCPU/fftdemo">my design</a>
only required a 1023 tap filter.</p>

<h2 id="slow-filters-implementation-overview">Slow Filters (Implementation Overview)</h2>

<p><a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">This downsampler</a>
follows a particular class of filters I call “<a href="/dsp/2017/12/30/slowfil.html">slow
filters</a>”.  What makes them
slow is that they are <em>area</em> optimized, rather than <em>throughput</em> optimized.
The goal of these <a href="/dsp/2017/12/30/slowfil.html">“slow”
filters</a> is to do the entire
operation using a single, multiplexed, hard multiplication element.  This will
also restrict how fast data can be given to the filter.  By contrast, I’ve used
the term “fast” filter to describe <a href="/dsp/2017/09/29/cheaper-fast-fir.html">a filter that can handle a new data value
every sample</a>.  Such
“fast filters” often require as many hard multiplication
elements as they have coefficients.  Of course, compromises exist between
these two extremes–but that’s another topic for another day.</p>

<p>Indeed, my <a href="/dsp/2017/09/15/fastfir.html">initial filter
designs</a> were all focused
around “fast filters”.
[<a href="/dsp/2017/09/15/fastfir.html">1</a>]
[<a href="/dsp/2017/09/29/cheaper-fast-fir.html">2</a>]
[<a href="/dsp/2017/10/16/boxcar.html">3</a>]
That was before I tried working with audio on Lattice’s iCE40 chips.  Suddenly
my entire “fast filter” library was too expensive for the applications I
needed, and I needed to spend some time building filters that didn’t use
as many hard multiplies.</p>

<p>The fascinating part about <a href="/dsp/2017/12/30/slowfil.html">slow
filters</a> is that they all have
almost exactly the same structure–although with subtle variations from
application to application.  Data comes in, <a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L127-L141">gets written to
memory</a>,
<a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L143-L187">memory and coefficient indexes are calculated</a>,
<a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L195-L205">data and coefficient values are read from memory</a>,
<a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L220-L222">products get calculated</a>
and then <a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L224-L230">accumulated</a> <a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L232-L244">into a
result</a>.
On a clock by clock basis, this looks like:</p>

<ol>
  <li>Wait for and then accept a new data value when it becomes available,
<a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L139-L141">write it to memory</a>, and
<a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L135-L138">adjust the memory write index</a></li>
  <li><a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L195-L205">Read one value from data memory and one value from coefficient memory</a>.
<a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L143-L187">Adjust the read-memory indexes</a>.</li>
  <li><a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L220-L222">Multiply these two values together</a></li>
  <li><a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L224-L230">Accumulate the results together</a></li>
  <li>Round the accumulated value <a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L237-L240">into a result</a>,
and <a href="https://github.com/ZipCPU/dspfilters/blob/f1f39fa729acce182ddf59d4138e5aea0aab2082/rtl/slowfil.v#L242-L244">set a flag when</a> it’s ready.</li>
</ol>

<p>For reference, Fig. 7 below was the figure we used when explaining this
operation before.</p>

<table align="center" style="float: none"><caption>Fig 7. The structure of a basic slow filter</caption><tr><td><img src="/img/slowfil/fir-slow-form.svg" alt="" width="560" /></td></tr></table>

<h2 id="coefficient-updates">Coefficient Updates</h2>

<p>If your goal is to build the
<a href="/dsp/2017/09/15/fastfir.html">fastest</a> and <a href="/dsp/2017/09/29/cheaper-fast-fir.html">cheapest
digital filter</a> out
there, then updating the coefficients post-implementation is a bad thing: it
prevents a lot of synthesis optimizations that might otherwise take place.  For
example, multiplies by constant zeros could be removed, by constant <code class="language-plaintext highlighter-rouge">2^n</code>
values can be replaced with shifts, and <code class="language-plaintext highlighter-rouge">2^n+2^k</code> values can be replaced
with shift and adds.</p>

<p>The problem with doing this is that if you want to build a
<a href="/dsp/2017/09/15/fastfir.html">generic filter</a>,
and then to discuss how much area a
<a href="/dsp/2017/09/15/fastfir.html">generic filter</a>
would use, or even to test a
<a href="/dsp/2017/09/15/fastfir.html">generic filter</a>
on a <a href="/dsp/2017/11/04/genfil-tb.html">test bench</a>
with multiple coefficient
sets, then you need an interface that will allow you to update the
coefficients within your filter.</p>

<table align="center" style="float: right"><caption>Fig 8. Filter coefficients individually adjustable</caption><tr><td><img src="/img/fftdemo/bus-mux.svg" alt="" width="360" /></td></tr></table>

<p>Years ago, when I built my first FPGA filter, I created a filter with
over a thousand elements for which the coefficients could be accessed
and read or written using a
<a href="/zipcpu/2017/11/07/wb-formal.html">Wishbone bus</a>
interface.  At the time, I thought this would be the ideal interface
for adjusting filter coefficients.  I was then rudely awakened when I
tried to implement this design on an FPGA.</p>

<p>The problem I had was specifically that in order to implement each of the
multiplies in hardware in parallel at the same time, all operating on the
same clock cycle, all of the filter coefficients have to be present in FFs
at the same time.  The memory interface then created a series of 1024
10-bit decoders and a 1:1024 demultiplexer–one for each bit of the
coefficients–and that was just the write half.  Sorry, but such a “beautiful”
interface isn’t worth the logic cost.  (I’m not sure I could’ve afforded the
board it would’ve taken to make this work at the time.)</p>

<table align="center" style="float: right"><caption>Fig 9. Adjusting filter ccoefficients via shift register</caption><tr><td><img src="/img/fftdemo/bus-sreg.svg" alt="" width="560" /></td></tr></table>

<p>A simpler interface is to use a series of shift registers, together with a
flag indicating when to update the FPGA with a new coefficient.  If done
properly, this won’t cost anything more than the number of FFs you already
need to hold the coefficients in the first place.</p>

<p>While we don’t need to use this shift register implementation with a typical
“<a href="/dsp/2017/12/30/slowfil.html">slow filter</a>”,
it still forms the motivation the interface we’ll use today.  Writes to the
coefficient “port”, a memory port occupying only a single address on the bus,
will write new values to the coefficient memory.  Resetting the core will
reset the write pointer to the beginning of coefficient memory.  That way we
can reset the core and then write the coefficients to it one at a time.  Even
better, any bus interface wrapper that works for
<a href="/dsp/2017/09/15/fastfir.html">“fast” filter</a>s
will also work for our
<a href="/dsp/2017/12/30/slowfil.html">“slow” filters</a>.</p>

<h2 id="implementation-in-detail">Implementation in Detail</h2>

<p>At this point, implementing a
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampling</a>
filter should be fairly straightforward.  We’re just implementing a
straightforward equation.</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-subsampling.png" alt="" width="288" /></td></tr></table>

<p>We’ve gone over the <a href="/dsp/2017/12/30/slowfil.html">basic sections of such a
filter</a>, and
we’ve outlined roughly how the algorithm works.  All that remains is to walk
through the actual logic, and see how it gets accomplished in detail below.
Then, in the next section, we’ll discuss how <a href="/blog/2017/10/19/formal-intro.html">formal
methods</a> might help
verifying a structure like this one.  For those interested in following along
within the design itself, I’ll be working through <a href="https://github.com/ZipCPU/dspfilters/blob/629474e69c68343ec04e93e4df69f4738c0971c8/rtl/subfildown.v">this version of the
downsampling filter
implementation</a>
below.</p>

<p>The filter itself starts out with a declaration of the parameters that can
be used to control the implementation of <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">the
core</a>.</p>

<p>This includes specifying the widths of the input, the output, and the
coefficients, as well as what our downsample rate is–what we called <code class="language-plaintext highlighter-rouge">D</code>
above.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"><span class="k">module</span>	<span class="n">subfildown</span> <span class="p">#(</span>
		<span class="c1">//</span>
		<span class="c1">// Bit widths: input width (IW),</span>
		<span class="k">parameter</span>	<span class="n">IW</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
		<span class="c1">// output bit-width (OW),</span>
				<span class="n">OW</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
		<span class="c1">// and coefficient bit-width (CW)</span>
				<span class="n">CW</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
		<span class="c1">//</span>
		<span class="c1">// Downsample rate, NDOWN.  For every NDOWN incoming samples,</span>
		<span class="c1">// this core will produce one outgoing sample.</span>
		<span class="k">parameter</span>	<span class="n">NDOWN</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
		<span class="c1">// LGNDOWN is the number of bits necessary to represent a</span>
		<span class="c1">// counter holding values between 0 and NDOWN-1</span>
		<span class="k">localparam</span>	<span class="n">LGNDOWN</span><span class="o">=</span><span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">NDOWN</span><span class="p">),</span></code></pre></figure>

<p>The next section controls our initial coefficient loading, ultimately ending
with the <code class="language-plaintext highlighter-rouge">INITIAL_COEFFS</code> parameter that names a file containing the
coefficients to be used in the filters implementation.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="c1">//</span>
		<span class="c1">// If "FIXED_COEFFS" is set to one, the logic necessary to</span>
		<span class="c1">// update coefficients will be removed to save space.  If you</span>
		<span class="c1">// know the coefficients you need, you can set this for that</span>
		<span class="c1">// purpose.</span>
		<span class="k">parameter</span> <span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">FIXED_COEFFS</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">,</span>
		<span class="c1">//</span>
		<span class="c1">// LGNCOEFFS is the log (based two) of the number of</span>
		<span class="c1">// coefficients.  So, for LGNCOEFFS=10, a 2^10 = 1024 tap</span>
		<span class="c1">// filter will be implemented.</span>
		<span class="k">parameter</span>	<span class="n">NCOEFFS</span><span class="o">=</span><span class="mi">103</span><span class="p">,</span>
		<span class="k">localparam</span>	<span class="n">LGNCOEFFS</span><span class="o">=</span><span class="p">$</span><span class="nb">clog2</span><span class="p">(</span><span class="n">NCOEFFS</span><span class="p">),</span>
		<span class="c1">//</span>
		<span class="c1">// For fixed coefficients, if INITIAL_COEFFS != 0 (i.e. ""),</span>
		<span class="c1">// then the filter's coefficients will be initialized from the</span>
		<span class="c1">// filename given.</span>
		<span class="k">parameter</span>	<span class="n">INITIAL_COEFFS</span> <span class="o">=</span> <span class="s">""</span><span class="p">,</span></code></pre></figure>

<p>You’ll notice that I tend to make a liberal use of <code class="language-plaintext highlighter-rouge">localparam</code>s above.  They
are very useful for creating parameter-like structures of derived values that
cannot be overridden from the parent context.  My only problem with using
<code class="language-plaintext highlighter-rouge">localparam</code>s has been that <a href="http://iverilog.icarus.com">Icarus Verilog</a>’s
support is more recent than the version provided for my current flavor of
Ubuntu.  You might find, therefore, that you need to upgrade <a href="http://iverilog.icarus.com">Icarus
Verilog</a> to the latest
version from source and use the <code class="language-plaintext highlighter-rouge">-g2012</code> option to get access to this feature.</p>

<p>Let me also caution you when using <code class="language-plaintext highlighter-rouge">$clog2()</code> to calculate the bit-width
required of a given value: the <code class="language-plaintext highlighter-rouge">$clog2()</code> result will produce the bitwidth
necessary to contain a value between zero and the value minus one–not the
bit-width necessary to maintain the value itself.  If this is a problem, you
can add one to the argument of the <code class="language-plaintext highlighter-rouge">$clog2</code> value, as in <code class="language-plaintext highlighter-rouge">$clog2(A+1)</code>.  I’ve
had no end of this problem when working with
<a href="https://github.com/ZipCPU/autofpga">AutoFPGA</a>, however in <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">today’s
example</a>
<code class="language-plaintext highlighter-rouge">$clog2</code> will work nicely as is.</p>

<p>There is, however, one parameter in <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">today’s
example</a>
that I’ve been burned by, and worse I’m not quite sure the right answer at this
point, and that is the <code class="language-plaintext highlighter-rouge">SHIFT</code> parameter.  At issue is, how shall the design
go from the bit width of the accumulator to the outgoing bitwidth?  The easy
answer is to drop any bits below the desired amount, or perhaps to <a href="/dsp/2017/07/22/rounding.html">round to
a nearby
value</a>.  (Beware of overflow!)</p>

<p>The problem with this answer is that your <a href="/dsp/2017/09/15/fastfir.html">filter
coefficients</a> might be such
that the maximum value will never be reached.  In that case, you’ll want to
multiply the accumulator’s result by a power of two in order to
recapture some <a href="https://en.wikipedia.org/wiki/Dynamic_range">dynamic range</a>
and get it into the range that you want.  This is the purpose of the <code class="language-plaintext highlighter-rouge">SHIFT</code>
parameter below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">parameter</span>	<span class="n">SHIFT</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span></code></pre></figure>

<p>A <code class="language-plaintext highlighter-rouge">SHIFT</code> of two specifies that we’ll multiply the result by <code class="language-plaintext highlighter-rouge">2^SHIFT = 4</code>
before returning the output.</p>

<p>The problem with this parameter, and the problem I’m still mulling over, is
that this definition doesn’t relate very well to the problem definition.  If
you run your favorite analysis tools on the coefficients, you can easily
calculate the gain of the
<a href="/dsp/2017/09/15/fastfir.html">filter</a>
and then a shift to place the results of the
<a href="/dsp/2017/09/15/fastfir.html">filter</a>
into range.  This <code class="language-plaintext highlighter-rouge">SHIFT</code> value isn’t that.  It’s more like the opposite of
that, and so I’ve been confused more than once at how to set it.</p>

<p>In other words, this portion of the
<a href="/dsp/2017/09/15/fastfir.html">filter</a>
is likely to be changed in the future once I figure out a better answer to
this problem–something that makes adjusting the scale at the end more
intuitive.</p>

<p>The last local parameter is the bit width of our accumulator.  This
follows from the <a href="/dsp/2017/07/21/bit-growth.html">bit width of multiplying two values together, one with <code class="language-plaintext highlighter-rouge">IW</code>
bits and another with <code class="language-plaintext highlighter-rouge">CW</code> bits, and then adding <code class="language-plaintext highlighter-rouge">NCOEFFS</code> of these values
together</a>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">localparam</span>	<span class="n">AW</span> <span class="o">=</span> <span class="n">IW</span><span class="o">+</span><span class="n">CW</span><span class="o">+</span><span class="n">LGNCOEFFS</span></code></pre></figure>

<table align="center" style="float: left; padding: 20px"><caption>Fig 10. A generic filter's portlist</caption><tr><td><img src="/img/fir-ports.svg" alt="" width="280" /></td></tr></table>

<p>The next step is to define a set of ports appropriate for this design.
When we <a href="/dsp/2017/11/04/genfil-tb.html">last discussed how to go about testing a filter, we came up with a
“universal” filter port set</a>.
This port set included the more obvious clock and reset, as well as a incoming
data port.  When the incoming <code class="language-plaintext highlighter-rouge">i_ce</code> signal was true, new data was available
on that port.  There was similarly an <code class="language-plaintext highlighter-rouge">i_tap_wr</code> signal to indicate that we
wanted to write a new coefficient value (tap) into the coefficient shift
register.  Using this approach, we could apply a new value on every clock
cycle to this filter.</p>

<table align="center" style="float: right"><caption>Fig 11. Ports to a downsampling filter</caption><tr><td><img src="/img/fftdemo/subfildown-ports.svg" alt="" width="280" /></td></tr></table>

<p><a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">This downsampling
filter</a> has
to be different, specifically because the <a href="/blog/2017/08/14/strategies-for-pipelining.html"><code class="language-plaintext highlighter-rouge">i_ce</code>
signal</a>
would be inappropriate for driving a sample stream at one <code class="language-plaintext highlighter-rouge">D</code>th the incoming
rate.  Instead, <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this
filter</a>
has an <a href="/blog/2017/08/14/strategies-for-pipelining.html">outgoing sample valid signal,
<code class="language-plaintext highlighter-rouge">o_ce</code></a>,
as shown in Fig. 11.  Indeed, that’s probably the biggest difference in ports
between <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this downsampling
filter</a>
and the <a href="/dsp/2017/11/04/genfil-tb.html">filters we’ve built
before</a>.</p>

<p>Enough of the preliminaries, let’s look into how
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this filter</a>
is implemented.</p>

<p>The first step is to initialize our coefficients.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">FIXED_COEFFS</span> <span class="o">||</span> <span class="n">INITIAL_COEFFS</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">LOAD_INITIAL_COEFFS</span>

		<span class="k">initial</span> <span class="p">$</span><span class="nb">readmemh</span><span class="p">(</span><span class="n">INITIAL_COEFFS</span><span class="p">,</span> <span class="n">cmem</span><span class="p">);</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Note that the generate will always load a filter any time <code class="language-plaintext highlighter-rouge">FIXED_COEFFS</code> is
set.  This should force an error if the file isn’t defined.  Of course, if the
file <code class="language-plaintext highlighter-rouge">INITIAL_COEFFS</code> is defined, we’ll always load the coefficients from that
file.  Otherwise, they’ll be need to be loaded across the bus since their
initial values would be implementation dependent upon startup.</p>

<p>Above I said that the ideal method for adjusting filter coefficients was
a shift register implementation.  Such an implementation would require an
update flag, herein called <code class="language-plaintext highlighter-rouge">i_tap_wr</code>, together with the new value, <code class="language-plaintext highlighter-rouge">i_tap</code>.</p>

<p>That interface works great for a shift register implementation, but the
optimizations used by
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this filter</a>
require that the coefficients be kept in a
block RAM, rather than in registers.  So, instead, we’ll keep track of an
index register.  We’ll set the index register to zero on any reset, but
otherwise increment it with every write.  Likewise, on every write we’ll write
our value to memory at the index given by the index register.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">FIXED_COEFFS</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">UNUSED_LOADING_PORTS</span>
		<span class="c1">// ...</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">LOAD_COEFFICIENTS</span>
		<span class="c1">// Coeff memory write index</span>
		<span class="kt">reg</span>	<span class="p">[</span><span class="n">LGNCOEFFS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">wr_coeff_index</span><span class="p">;</span>

		<span class="k">initial</span>	<span class="n">wr_coeff_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
			<span class="n">wr_coeff_index</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_tap_wr</span><span class="p">)</span>
			<span class="n">wr_coeff_index</span> <span class="o">&lt;=</span> <span class="n">wr_coeff_index</span><span class="o">+</span><span class="mb">1'b1</span><span class="p">;</span>

		<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i_tap_wr</span><span class="p">)</span>
			<span class="n">cmem</span><span class="p">[</span><span class="n">wr_coeff_index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_tap</span><span class="p">;</span>

	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>The second major block of <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this
filter</a> is
where we write the data samples into memory.  On every new sample, marked by
the incoming <a href="/blog/2017/08/14/strategies-for-pipelining.html">clock enable
line</a>
<code class="language-plaintext highlighter-rouge">i_ce</code> we adjust our write address and write one sample to memory.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">wraddr</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">wraddr</span> <span class="o">&lt;=</span> <span class="n">wraddr</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
		<span class="n">dmem</span><span class="p">[</span><span class="n">wraddr</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">i_sample</span><span class="p">;</span></code></pre></figure>

<p>One of the implementation keys that often surprise individuals is that block
RAM cannot be reset.  If you make the mistake at this point, therefore, and
try to re-initialize the block RAM on any reset, you’ll be disappointed to
find that the data memory will no longer be implemented in block RAM.  Indeed,
it might no longer fit on your chip.  For more information on what assumptions
may be assumed of block RAM, feel free to check out the block RAM
lesson from <a href="/tutorial">my beginner’s tutorial</a>.</p>

<p>In most cases, this isn’t usually a problem–the filter will glitch following
any reset, but then it will settle out.  If it becomes a problem, you can
add some circuitry to the outgoing <code class="language-plaintext highlighter-rouge">CE</code> signal to prevent <code class="language-plaintext highlighter-rouge">CE</code> generation until
enough data values have been set–effectively skipping the filter’s runup.</p>

<p>This did became a problem for me at one time when trying to figure out how to
properly reset a filter of this type to a known configuration for
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
testing.  The solution I picked for my test bench was to just hold
<code class="language-plaintext highlighter-rouge">i_reset</code> and <code class="language-plaintext highlighter-rouge">i_ce</code> high while holding <code class="language-plaintext highlighter-rouge">i_sample</code> at zero for
<code class="language-plaintext highlighter-rouge">(1&lt;&lt;LGNCOEFFS)</code> cycles.  As you’ll see later, holding <code class="language-plaintext highlighter-rouge">i_reset</code> high prevents
any outputs from being generated.  This approach allowed me to reset the data
memory–even if it requires some external work to get there.</p>

<p>Since we’re implementing a
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsampling</a>
filter, we will be accepting <code class="language-plaintext highlighter-rouge">D</code>
(<code class="language-plaintext highlighter-rouge">NDOWN</code>) samples into our filter for every sample out we produce.  That means
one of every <code class="language-plaintext highlighter-rouge">D</code> samples entering <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">our
design</a>
will trigger the processing necessary to create a new output sample.  To know
when a given incoming sample is the one that will trigger the processing for
new output, we’ll need to implement a counter.  This particular counter
implementation is a count down counter, counting down from <code class="language-plaintext highlighter-rouge">NDOWN-1</code> to zero,
and at zero we set the <code class="language-plaintext highlighter-rouge">first_sample</code> flag to indicate that the next incoming
sample will start our processing run.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">countdown</span> <span class="o">=</span> <span class="n">NDOWN</span><span class="p">[</span><span class="n">LGNDOWN</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">first_sample</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">countdown</span> <span class="o">&lt;=</span> <span class="n">countdown</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">first_sample</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">countdown</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">countdown</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">countdown</span> <span class="o">&lt;=</span> <span class="n">NDOWN</span><span class="p">[</span><span class="n">LGNDOWN</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>The next step is to read from our memories–the data memory and the coefficient
memory.  Getting there, however, requires that we know the memory indexes we
need to read from.</p>

<p>Our first step towards calculating the two indexes we need is to calculate
when we are on the last coefficient of our filter and so need to stop our
operation.  The last coefficient will be marked as <code class="language-plaintext highlighter-rouge">NCOEFFS-1</code>, but we’d like
to set this flag one clock earlier–leading to the logic below.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">last_coeff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">last_coeff</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="o">!</span><span class="n">last_coeff</span> <span class="o">&amp;&amp;</span> <span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="n">tidx</span> <span class="o">&gt;=</span> <span class="n">NCOEFFS</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span></code></pre></figure>

<p>So, here’s how it works: when the first sample of a set comes in, our
coefficient index will be <code class="language-plaintext highlighter-rouge">0</code>.  We’ll then increment that coefficient index,
<code class="language-plaintext highlighter-rouge">tidx</code> (read tap index) on every clock cycle until it gets to <code class="language-plaintext highlighter-rouge">NCOEFFS-1</code>.
Along the way, we’ll use a flag, <code class="language-plaintext highlighter-rouge">running</code>, to indicate that we are running
through that coefficient list.  Then, on that cycle, <code class="language-plaintext highlighter-rouge">last_coeff</code> will be
true and we can stop <code class="language-plaintext highlighter-rouge">running</code>.</p>

<p>When we’re not running, we’ll hold <code class="language-plaintext highlighter-rouge">running</code> at zero–up until the first
incoming sample (<code class="language-plaintext highlighter-rouge">i_ce</code>).</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">tidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span> <span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">running</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="o">!</span><span class="n">i_ce</span><span class="p">))</span>
	<span class="k">begin</span>
		<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">running</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">running</span><span class="p">)</span><span class="o">||</span><span class="p">((</span><span class="n">first_sample</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_ce</span><span class="p">)))</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_coeff</span><span class="p">)</span>
		<span class="k">begin</span>
			<span class="n">running</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
			<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span>
			<span class="n">tidx</span> <span class="o">&lt;=</span> <span class="n">tidx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">first_sample</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_ce</span><span class="p">))</span>
				<span class="n">running</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
		<span class="k">end</span>
	<span class="k">end</span></code></pre></figure>

<p>You’ll note that I haven’t used a reset here.  I’m going to contend that it’s
not necessary.  Even in a design requiring a reset, where the initial values
are ignored, the <code class="language-plaintext highlighter-rouge">running</code> and <code class="language-plaintext highlighter-rouge">tidx</code> (coefficient index) flags will settle
into their appropriate values within <code class="language-plaintext highlighter-rouge">2*NCOEFFS</code> clocks.  If you really want
a reset, you could add it to the first <code class="language-plaintext highlighter-rouge">if</code> statement above.</p>

<p>What happens if the first sample comes in and the design was already <code class="language-plaintext highlighter-rouge">running</code>
with the last set of <code class="language-plaintext highlighter-rouge">NDOWN</code> incoming samples?  Simply, the design would no
longer function as designed.  Sure, it would still produce outputs, but they
would be based upon the wrong coefficient indices.  It is the responsibility
of the surrounding environment to make certain this assumption isn’t broken.
We <em>must</em> issue the last coefficient index before the first sample of the
next set.  Once the design stops running, it will then wait for an incoming
sample where <code class="language-plaintext highlighter-rouge">first_sample</code> is also set before starting its next
run–guaranteeing that we’ll end up synchronized even without a reset.</p>

<p>The data memory index, <code class="language-plaintext highlighter-rouge">didx</code>, is very similar to the coefficient index above.
The difference is that the data memory index doesn’t get reset at the beginning
of every run.  Instead, when we aren’t running, the data index gets set
to the index of the next data to be accepted into the core.  On the clock
cycle that data is accepted, we’ll read from what used to be there.  That
will then be the oldest data.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">didx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">running</span> <span class="o">||</span> <span class="n">last_coeff</span><span class="p">)</span>
		<span class="c1">// Waiting here for the first sample to come through</span>
		<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">wraddr</span> <span class="o">+</span> <span class="p">(</span><span class="n">i_ce</span> <span class="o">?</span> <span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="c1">// Always read from oldest first, that way we can rewrite</span>
		<span class="c1">// the data as new data comes in--since we've already used it.</span>
		<span class="n">didx</span> <span class="o">&lt;=</span> <span class="n">didx</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span></code></pre></figure>

<p>In case you are starting to get lost in the words here, it might help to have
a trace to see what’s going on.  Therefore, here’s a possible trace showing
what might be expected at this point in our implementation.</p>

<table align="center" style="float: none"><caption>Fig 12. Example trace, showing index and flag generation</caption><tr><td><a href="/img/fftdemo/subfildown-basic.svg"><img src="/img/fftdemo/subfildown-basic.svg" alt="" width="780" /></a></td></tr></table>

<p>This trace has been built for a subsample size of <code class="language-plaintext highlighter-rouge">D=5</code> and a filter length of
<code class="language-plaintext highlighter-rouge">NCOEFFS = N = 31</code>.  As you can see, the run is triggered by the first sample of
<code class="language-plaintext highlighter-rouge">D</code> arriving.  From that point on, the core runs through its coefficient set
and past data.  Once complete, <code class="language-plaintext highlighter-rouge">last_coeff</code> is set and the design sets up for
the next run.  As part of a separate pipeline, <code class="language-plaintext highlighter-rouge">D</code> values are accepted and then
<code class="language-plaintext highlighter-rouge">first_sample</code> is set high.  These can arrive at any speed, subject to the
requirement that no more than <code class="language-plaintext highlighter-rouge">D</code> samples can be accepted mid run.  Then, once
<code class="language-plaintext highlighter-rouge">first_sample</code> is set, the next data sample coming in starts a new run.  It’s
important that this next sample not arrive until the run has complete.
Perhaps this core should also have a <code class="language-plaintext highlighter-rouge">ready</code>
output, perhaps even <code class="language-plaintext highlighter-rouge">!running || !first_sample</code>, but I haven’t needed to
attach such a ready input (yet).</p>

<p>Now that we have indices for both data and coefficient memories, we can now
read their values from their respective block RAM’s.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">dval</span> <span class="o">&lt;=</span> <span class="n">dmem</span><span class="p">[</span><span class="n">didx</span><span class="p">];</span>
		<span class="n">cval</span> <span class="o">&lt;=</span> <span class="n">cmem</span><span class="p">[</span><span class="n">tidx</span><span class="p">];</span>
	<span class="k">end</span></code></pre></figure>

<p>If you look back at the formula we are implementing, we now know what
<code class="language-plaintext highlighter-rouge">h[k]</code> and <code class="language-plaintext highlighter-rouge">x[nD-k]</code> portions of our convolution product are.</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-cvaldval.png" alt="" width="295" /></td></tr></table>

<p>The next big steps will be to multiply these two values together, and then
to accumulate their result into a sum to create our output.</p>

<p>Before leaving this initial clock cycle and launching into our pipeline,
there’s two other required steps.  First, we’ll need to track the initial
sample through our pipeline to know when to generate an outgoing sample.
Second, we’ll need to generate a flag to tell us when to accumulate a new
value, versus when to clear our accumulator.</p>

<p>By way of introducing the values we need for keeping track of this pipeline,
let me diagram out the pipeline itself in Fig. 13.</p>

<table align="center" style="float: none"><caption>Fig 13. Pipeline structure</caption><tr><td><a href="/img/fftdemo/subfil-pipeline.svg"><img src="/img/fftdemo/subfil-pipeline.svg" alt="" width="780" /></a></td></tr></table>

<p>This pipeline is really driven by the time it takes to read from block RAM,
the time it takes to form a product, and the time it takes to sum the results.
Each of these tasks takes one clock, and there’s no real easy way to speed
this up other than
<a href="/blog/2017/08/14/strategies-for-pipelining.html">pipelining</a>
the processing as shown in Fig. 13 above.
The figure shows a first stage where the indexes are calculated.  At the same
clock cycle indexes are valid, the new sample may arrive.  One clock later,
the data are available from the block RAM memory reads above.  One clock later,
the product is complete.  That will be our next step, once we finish up with
the signaling here.  Once the product is available, we’ll enter into first
an accumulator stage and then the output stage.</p>

<p>As the first stage has an <code class="language-plaintext highlighter-rouge">i_ce</code> value to kick it off, I also use a <code class="language-plaintext highlighter-rouge">d_ce</code>
value to capture that cycle of the first sample as it exists after the
data are read and <code class="language-plaintext highlighter-rouge">d_last</code> to capture the last valid data cycle.  In a similar
vein, only one clock later, <code class="language-plaintext highlighter-rouge">p_ce</code> will capture the first cycle where the
product is valid and <code class="language-plaintext highlighter-rouge">p_last</code> will capture the last one.  There’s also the
<code class="language-plaintext highlighter-rouge">p_run</code> signal, used to tell the accumulator when to accumulate versus
reloading from the product result.  This <code class="language-plaintext highlighter-rouge">p_run</code> signal will get set by
<code class="language-plaintext highlighter-rouge">p_ce</code>, and then again cleared by <code class="language-plaintext highlighter-rouge">p_last</code>.  So let’s
quickly discuss these five registers, <code class="language-plaintext highlighter-rouge">d_ce</code>, <code class="language-plaintext highlighter-rouge">d_last</code>, <code class="language-plaintext highlighter-rouge">p_ce</code>, <code class="language-plaintext highlighter-rouge">p_last</code>,
and <code class="language-plaintext highlighter-rouge">p_run</code>.</p>

<p>We’ll skip the reset preliminaries for these registers.  Basically, all of
these five flags get cleared on any reset.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">d_ce</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">p_run</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">p_ce</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">d_last</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">initial</span>	<span class="n">p_last</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="n">d_ce</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p_ce</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p_run</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">d_last</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">p_last</span>  <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span></code></pre></figure>

<p>As mentioned above, <code class="language-plaintext highlighter-rouge">d_ce</code> describes when the data stage has the first valid
value within it.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">d_ce</span>  <span class="o">&lt;=</span> <span class="p">(</span><span class="n">first_sample</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">i_ce</span><span class="p">);</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">d_last</code> describes the last clock cycle with valid data within it.  This is
easily set based upon the <code class="language-plaintext highlighter-rouge">last_coeff</code> register we set earlier.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">d_last</span><span class="o">&lt;=</span> <span class="n">last_coeff</span> <span class="o">&amp;&amp;</span> <span class="n">p_run</span><span class="p">;</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">p_ce</code> follows after <code class="language-plaintext highlighter-rouge">d_ce</code> one cycle later, to indicate when the
multiplication product has its first valid output.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">p_ce</span>  <span class="o">&lt;=</span> <span class="n">d_ce</span><span class="p">;</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">p_run</code> is just a little
different.  Instead of referencing the first item in the run, <code class="language-plaintext highlighter-rouge">p_run</code> will
be true for all subsequent valid products.  It gets set on the cycle after
<code class="language-plaintext highlighter-rouge">p_ce</code>, and gets cleared by the last product.  The result is that <code class="language-plaintext highlighter-rouge">p_run</code> can
be used later to indicate when it’s time to accumulate into our accumulator.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">p_run</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">p_last</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p_run</span> <span class="o">||</span> <span class="n">p_ce</span><span class="p">);</span></code></pre></figure>

<p>The last product itself, noted by <code class="language-plaintext highlighter-rouge">p_last</code>, is valid one clock cycle after the
last data value.  This value needs to be gated by <code class="language-plaintext highlighter-rouge">p_run</code>, however, or a
reset mid-run might throw the whole cycle off.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="n">p_last</span><span class="o">&lt;=</span> <span class="n">p_run</span> <span class="o">&amp;&amp;</span> <span class="n">d_last</span><span class="p">;</span>
	<span class="k">end</span></code></pre></figure>

<p>If this seems confusing, then perhaps Fig. 14 below will help clear things up.</p>

<table align="center" style="float: none"><caption>Fig 14. Trace showing the relationship of d_ce, p_ce, and p_run compared to the other signals</caption><tr><td><a href="/img/fftdemo/subfil-ce.svg"><img src="/img/fftdemo/subfil-ce.svg" alt="" width="780" /></a></td></tr></table>

<p>Here you can see that <code class="language-plaintext highlighter-rouge">p_ce</code> is true on the first clock cycle where the product
is valid.  That will be our signal to reload the accumulator with an initial
value.  After that clock cycle, we’ll hold <code class="language-plaintext highlighter-rouge">p_run</code> high for another <code class="language-plaintext highlighter-rouge">N-1</code>
cycles, before resetting as part of the next cycle.  Here you can see how
<code class="language-plaintext highlighter-rouge">p_last</code> is our signal to reset <code class="language-plaintext highlighter-rouge">p_run</code>.  Further, you can compare the <code class="language-plaintext highlighter-rouge">running</code>
signal to <code class="language-plaintext highlighter-rouge">p_run</code>.  The two signals are identical, save for a
two cycle delay–caused by propagating the signal through the pipeline.  The
other check, to make sure we’ve done this right, is to make certain that
the number of cycles where <code class="language-plaintext highlighter-rouge">p_ce || p_run</code> are true are equal to the number
of coefficients in our filter.</p>

<p>We can now calculate the product of data sample with our coefficient.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="p">(</span><span class="o">*</span> <span class="n">mul2dsp</span> <span class="o">*</span><span class="p">)</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">dval</span> <span class="o">*</span> <span class="n">cval</span><span class="p">;</span></code></pre></figure>

<p>This forms the product portion of the formula we are trying to implement.</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-product.png" alt="" width="291" /></td></tr></table>

<p>At this point I need to introduce one more signal, <code class="language-plaintext highlighter-rouge">acc_valid</code>.  The problem
with our current setup is that the signal for <code class="language-plaintext highlighter-rouge">o_ce</code> to become valid is when
the first product is true.  That will be the same cycle the accumulator is
cleared, so it’s a perfect time to copy the value to the output.  What happens,
though, if we haven’t run through our summation at that time?  For this reason,
I use a quick and simple flag I call <code class="language-plaintext highlighter-rouge">acc_valid</code>.  If <code class="language-plaintext highlighter-rouge">acc_valid</code> is true,
then on the first product when I would clear the accumulator, I can also
generate an output sample from the accumulator.</p>

<p>To make this work, I’ll reset <code class="language-plaintext highlighter-rouge">acc_valid</code> on any reset.  If we ever add
anything to our accumulator, then there will be a valid amount in the
accumulator and so I can then set <code class="language-plaintext highlighter-rouge">acc_valid</code>.  I can now use
this to gate when <code class="language-plaintext highlighter-rouge">o_ce</code> should be set or not in another step or two.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">acc_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">acc_valid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p_run</span><span class="p">)</span>
		<span class="n">acc_valid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>If I later decide that it’s important to keep <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">the
filter</a>
from glitching following a reset, I could come back and add a counter to this
<code class="language-plaintext highlighter-rouge">acc_valid</code> register–forcing <code class="language-plaintext highlighter-rouge">NCOEFFS</code> inputs before setting the first
<code class="language-plaintext highlighter-rouge">acc_valid</code>.</p>

<p>The next task is to form our sum.  Using the <code class="language-plaintext highlighter-rouge">p_ce</code> flag, to indicate the
first product in the run, and the <code class="language-plaintext highlighter-rouge">p_run</code> flag, indicating that more
accumulation is necessary, this gets really easy.  On a <code class="language-plaintext highlighter-rouge">p_ce</code> cycle, we
set the accumulator to the result of the product, and on any <code class="language-plaintext highlighter-rouge">p_run</code> cycle
we add the new product to the prior accumulator value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">accumulator</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">accumulator</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p_ce</span><span class="p">)</span>
		<span class="c1">// If p_ce is true, this is the first valid product of the set</span>
		<span class="n">accumulator</span> <span class="o">&lt;=</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">LGNCOEFFS</span><span class="p">)</span><span class="o">{</span><span class="n">product</span><span class="p">[</span><span class="n">IW</span><span class="o">+</span><span class="n">CW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">}}</span><span class="p">,</span> <span class="n">product</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p_run</span><span class="p">)</span>
		<span class="n">accumulator</span> <span class="o">&lt;=</span> <span class="n">accumulator</span>
			<span class="o">+</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">LGNCOEFFS</span><span class="p">)</span><span class="o">{</span><span class="n">product</span><span class="p">[</span><span class="n">IW</span><span class="o">+</span><span class="n">CW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">}}</span><span class="p">,</span> <span class="n">product</span> <span class="o">}</span><span class="p">;</span></code></pre></figure>

<p>Now that we have our result, let’s adjust the number of bits in it.</p>

<p>So far, our product has <code class="language-plaintext highlighter-rouge">AW</code> bits in it.  That’s the <a href="/dsp/2017/07/21/bit-growth.html"><code class="language-plaintext highlighter-rouge">IW+CW</code> bits
required to hold a product of values having <code class="language-plaintext highlighter-rouge">IW</code> and then <code class="language-plaintext highlighter-rouge">CW</code> bits,
together with an additional <code class="language-plaintext highlighter-rouge">LGNCOEFFS</code> bits to account for adding <code class="language-plaintext highlighter-rouge">NCOEFFS</code>
of these products together</a>.</p>

<p>The good news of this <code class="language-plaintext highlighter-rouge">AW=IW+CW+LGNCOEFFS</code> number is that it is <a href="/dsp/2017/07/21/bit-growth.html">guaranteed
never to overflow</a>.  If
we just grab the top <code class="language-plaintext highlighter-rouge">OW</code> bits, our output bit-width,
we are guaranteed not to have overflowed.  That’s the good news.  The bad news
is that it is a very conservative width, and may well be many more bits than are
truly necessary to hold the result.  The result of just grabbing the top
<code class="language-plaintext highlighter-rouge">OW</code> bits may then reduce our precious
<a href="https://en.wikipedia.org/wiki/Dynamic_range">dynamic range</a>.
For this reason, I’ve introduced the <code class="language-plaintext highlighter-rouge">SHIFT</code> parameter above.  We’ll now
shift our signal left by <code class="language-plaintext highlighter-rouge">SHIFT</code> bits before rounding and grabbing the result.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OW</span> <span class="o">==</span> <span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">NO_SHIFT</span>
		<span class="k">assign</span>	<span class="n">rounded_result</span> <span class="o">=</span> <span class="n">accumulator</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span><span class="o">-</span><span class="n">OW</span><span class="p">];</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span> <span class="o">&gt;</span> <span class="n">OW</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">SHIFT_OUTPUT</span>
		<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">prerounded</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">prerounded</span> <span class="o">=</span> <span class="o">{</span><span class="n">accumulator</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span>
						<span class="o">{</span><span class="p">(</span><span class="n">SHIFT</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span> <span class="o">}</span><span class="p">;</span>
		<span class="k">assign</span>	<span class="n">rounded_result</span> <span class="o">=</span> <span class="n">prerounded</span>
				<span class="o">+</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span> <span class="n">prerounded</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
					<span class="o">{</span><span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{!</span><span class="n">prerounded</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">}}</span> <span class="o">}</span><span class="p">;</span>
	<span class="k">end</span> <span class="k">else</span> <span class="k">begin</span> <span class="o">:</span> <span class="n">UNIMPLEMENTED_SHIFT</span>
	<span class="k">end</span> <span class="k">endgenerate</span></code></pre></figure>

<p>Sadly, after using the logic above many times, I kept running into overflow
problems.  My answer to “overflow” when designing
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this core</a>
was that it was the responsibility of the designer to keep overflow from
happening.  Unfortunately, as the designer using the core, it became difficult
to just look at a trace and know that a particular problem was the result of
overflow.  Therefore, I came back to this design to retro-fit it for overflow
detection.</p>

<p>The key to overflow detection is to check the sign of the result from before
shifting and compare it to the sign bit afterwards.  If the two disagree,
there’s been an overflow.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">generate</span> <span class="k">if</span> <span class="p">(</span><span class="n">OW</span> <span class="o">==</span> <span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">NO_SHIFT</span>
		<span class="k">assign</span>	<span class="n">sgn</span> <span class="o">=</span> <span class="n">accumulator</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">assign</span>	<span class="n">rounded_result</span> <span class="o">=</span> <span class="n">accumulator</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span><span class="o">-</span><span class="n">OW</span><span class="p">];</span>
		<span class="k">assign</span>	<span class="n">overflow</span>  <span class="o">=</span> <span class="p">(</span><span class="n">sgn</span> <span class="o">!=</span> <span class="n">rounded_result</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span></code></pre></figure>

<p>Sadly, when I tried this same approach on the section where I rounded
the data to the nearest value, I was surprised to see the result glitching
every now and then.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">end</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span> <span class="o">&gt;</span> <span class="n">OW</span><span class="p">)</span>
	<span class="k">begin</span> <span class="o">:</span> <span class="n">SHIFT_OUTPUT</span>
		<span class="kt">wire</span>	<span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">prerounded</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">prerounded</span> <span class="o">=</span> <span class="o">{</span><span class="n">accumulator</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="n">SHIFT</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span>
						<span class="o">{</span><span class="p">(</span><span class="n">SHIFT</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span> <span class="o">}</span><span class="p">;</span>

		<span class="k">assign</span>	<span class="n">sgn</span> <span class="o">=</span> <span class="n">accumulator</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">assign</span>	<span class="n">rounded_result</span> <span class="o">=</span> <span class="n">prerounded</span>
				<span class="o">+</span> <span class="o">{</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span><span class="p">,</span> <span class="n">prerounded</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
					<span class="o">{</span><span class="p">(</span><span class="n">AW</span><span class="o">-</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{!</span><span class="n">prerounded</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">}}</span> <span class="o">}</span><span class="p">;</span>
		<span class="k">assign</span>	<span class="n">overflow</span>  <span class="o">=</span> <span class="p">(</span><span class="n">sgn</span> <span class="o">!=</span> <span class="n">rounded_result</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span></code></pre></figure>

<p>The problem is that rounding a value between -1/2 and 0 up to 0 will trigger
a sign change.  “Correcting” this change under the assumption that the correct
result should be a maximum negative value rather than leaving it alone was
creating glitches I wasn’t expecting.</p>

<p>My solution is a two-fold check for overflow.  If the original value is
negative, and it becomes positive as a result of the shift, then there was an
overflow.  On the other hand, if the sign was positive before the shift but
became negative after rounding, then there’s been an overflow.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">		<span class="k">assign</span>	<span class="n">overflow</span> <span class="o">=</span> <span class="p">(</span><span class="n">sgn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">prerounded</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">sgn</span> <span class="o">&amp;&amp;</span> <span class="n">rounded_result</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span></code></pre></figure>

<p>Even this isn’t true overflow protection, since we only checked the sign
bit–not all of the <code class="language-plaintext highlighter-rouge">SHIFT</code> bits we shifted away.  Still, it does get us
that much closer.</p>

<p>What value should the <code class="language-plaintext highlighter-rouge">SHIFT</code> be?  That follows from the maximum value one
might expect out of the filter, generated by applying a signal consisting of
all maximum values where every value matches the sign of the coefficient
of the filter within.  Something like the following expression, therefore,
can calculate our maximum result.</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-dsampled-maximum.png" alt="" width="257" /></td></tr></table>

<p>Using this result I’d like to be able to specify a shift by,</p>

<table align="center" style="float: none"><tr><td><img src="/img/fftdemo/eqn-bestshift.png" alt="" width="539" /></td></tr></table>

<p>Unfortunately, my currently chosen <code class="language-plaintext highlighter-rouge">SHIFT</code> parameter doesn’t relate to this
ideal formula listed above very well.  Indeed, the relationship appears
to be backwards, so I might need to update it in the future.</p>

<p>Let’s continue on anyway.  The last and final step of this algorithm is to
report the result.</p>

<p>Our result will be valid as soon as the accumulator starts a new sum.  At this
point, the accumulator may have been idle for some time.  It doesn’t matter.
The accumulator will have the prior sum within it.  There’s one exception,
however, and that is if the design was reset mid-run.  In that case, the
<code class="language-plaintext highlighter-rouge">acc_valid</code> flag will be false telling us not to produce an output this run.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">o_ce</span> <span class="o">=</span> <span class="mb">1'b0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">o_ce</span> <span class="o">&lt;=</span> <span class="o">!</span><span class="n">i_reset</span> <span class="o">&amp;&amp;</span> <span class="n">p_ce</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">acc_valid</span><span class="p">);</span></code></pre></figure>

<p>Nominally our output would simply be the result of rounding and shifting the
accumulator.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_ce</span><span class="p">)</span>
		<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="n">rounded_result</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">AW</span><span class="o">-</span><span class="n">OW</span><span class="p">];</span></code></pre></figure>

<p>However, if multiplying by <code class="language-plaintext highlighter-rouge">2^SHIFT</code> or rounding caused an overflow, then
this is the place to correct for it.  In the case of overflow, the correct
answer is either the maximum negative value if the sign were negative, or
the maximum positive value if not.  This is an easy check and update.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p_ce</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">overflow</span><span class="p">)</span>
			<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">sgn</span><span class="p">)</span> <span class="o">?</span> <span class="o">{</span> <span class="mb">1'b1</span><span class="p">,</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b0</span><span class="o">}}</span> <span class="o">}</span>
					<span class="o">:</span> <span class="o">{</span> <span class="mb">1'b0</span><span class="p">,</span> <span class="o">{</span><span class="p">(</span><span class="n">OW</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">{</span><span class="mb">1'b1</span><span class="o">}}</span> <span class="o">}</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">o_result</span> <span class="o">&lt;=</span> <span class="n">rounded_result</span><span class="p">[</span><span class="n">AW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="n">AW</span><span class="o">-</span><span class="n">OW</span><span class="p">];</span>
	<span class="k">end</span></code></pre></figure>

<p>The fascinating part of this design is how similar it is to other filtering
designs I’ve built.
[<a href="/dsp/2017/12/30/slowfil.html">1</a>]
[<a href="/dsp/2018/05/17/slowsymf.html">2</a>]
[<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/shalfband.v">3</a>]
They all seem to have (roughly) the same structure, and the same basic
steps to their implementation.</p>

<p>Before leaving this implementation section, I should point out that I’ve
also built a <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/subfildowniq.v">similar implementation for complex
signals</a>,
that is–those containing both in-phase and quadrature components.  That
version is nearly identical to <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this
version</a>,
save that it handles two data paths.  While I suppose I might have technically
just used two versions of <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this same
filter</a>,
by combining both paths into a <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/subfildowniq.v">quadrature
version</a>,
building a <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/subfildowniq.v">quadrature down
converter</a>
allows me to ensure that the synthesis tool doesn’t infer more logic than
necessary.</p>

<h2 id="formal-verification">Formal Verification</h2>

<p>When <a href="/tutorial/formal.html">I teach formal verification</a>,
one of my early points is that formal methods can’t handle multiplies.  The
result is that I don’t use formal methods on DSP algorithms–or so I teach.
The reality is that there’s a lot to the algorithm above
that can be formally
verified–just not the product of the multiplication.  Not only that, but
I’ve gotten to the point where it’s easier to use
<a href="https://symbiyosys.readthedocs.io/en/latest/">SymbiYosys</a>
to get something
up and running than anything else.  The reality, therefore, is that you can
use formal methods on DSP algorithms–at least enough to get you most of
the way there.  You’ll still need to do some
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
to be sure the design truly works, but formal methods will get you to that
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>
that much faster.</p>

<h4 id="step-one-replace-the-multiply">Step one: Replace the multiply</h4>

<p>The first step, however, is to replace the multiply.  In our case, we’ll
replace it with an abstract result–something that might or might not give
us the right answer.  Any assertions that pass, therefore, would still pass
with the right answer.</p>

<p>The key to doing this is to declare a register with the
<a href="https://symbiyosys.readthedocs.io/en/latest/">SymbiYosys</a>
recognized
<code class="language-plaintext highlighter-rouge">(* anyseq *)</code> attribute.  This will tell the solver that this register
can contain any sequence of values–potentially changing on every clock tick.
These values act like an input port to our routine, only they act like an input
coming into the routine in the middle rather than at the portlist at the top.
As such, the proper constraints for them are assumptions.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="p">(</span><span class="o">*</span> <span class="n">anyseq</span> <span class="o">*</span><span class="p">)</span>	<span class="kt">reg</span>	<span class="kt">signed</span> <span class="p">[</span><span class="n">IW</span><span class="o">+</span><span class="n">CW</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span>	<span class="n">f_abstract_product</span><span class="p">;</span></code></pre></figure>

<p>I’m going to constrain my product with just a couple of assumptions.  First,
the sign of the result must match.  Second, anything multiplied by zero must
be zero.  Third, anything multiplied by one keeps its value.  In all other
respects, I’m not going to constrain the result of the product at all.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">begin</span>
		<span class="k">assume</span><span class="p">(</span><span class="n">f_abstract_product</span><span class="p">[</span><span class="n">IW</span><span class="o">+</span><span class="n">CW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span> <span class="p">(</span><span class="n">dval</span><span class="p">[</span><span class="n">IW</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">cval</span><span class="p">[</span><span class="n">CW</span><span class="o">-</span><span class="mi">1</span><span class="p">]));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">cval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">assume</span><span class="p">(</span><span class="n">f_abstract_product</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cval</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">assume</span><span class="p">(</span><span class="n">f_abstract_product</span> <span class="o">==</span> <span class="n">dval</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dval</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">assume</span><span class="p">(</span><span class="n">f_abstract_product</span> <span class="o">==</span> <span class="n">cval</span><span class="p">);</span>
	<span class="k">end</span></code></pre></figure>

<p>Then, instead of setting <code class="language-plaintext highlighter-rouge">product = dval * cval</code>, I’ll set it to this abstract
value.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
		<span class="n">product</span> <span class="o">&lt;=</span> <span class="n">f_abstract_product</span><span class="p">;</span></code></pre></figure>

<p>This was the approach I used when <a href="/dsp/2018/10/02/fft.html">formally verifying my
FFT</a>.  In that case, these
assumptions were sufficient to be able to reason about the design using a
formal solver.  In this case, they are overkill since I’m not asserting
any properties of either the product, the accumulator, or the resulting output
(yet).</p>

<h4 id="step-two-constrain-the-inputs">Step two: Constrain the inputs</h4>

<p>The next step is to constrain the input.  In this case, there’s only one
constraint–there can only be <code class="language-plaintext highlighter-rouge">D</code> (<code class="language-plaintext highlighter-rouge">NDOWN</code>) inputs per run of <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">the
filter</a>.
Until <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">the
filter</a> is
ready for its next set of <code class="language-plaintext highlighter-rouge">D</code> inputs, the surrounding environment must wait.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
		<span class="k">assume</span><span class="p">(</span><span class="o">!</span><span class="n">i_ce</span> <span class="o">||</span> <span class="o">!</span><span class="n">first_sample</span><span class="p">);</span></code></pre></figure>

<p>This will keep us from overrunning <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">the
filter</a>
when using it.</p>

<p>There is a risk here, however.  By using a local value within an assertion,
you run the risk that the assertion might prevent proper operation of the
design.  We’ll use <code class="language-plaintext highlighter-rouge">cover()</code> statement later to make certain that isn’t the
case here.</p>

<p>That’s our only input constraint.  Together with the assumptions associated
with the abstract multiply above, those are our only assumptions.  Everything
else is asserted from here on out.</p>

<h4 id="step-three-generate-a-quick-trace">Step three: Generate a quick trace</h4>

<p>The next step in getting a DSP algorithm up and running is to generate a
quick cover trace.</p>

<table align="center" style="float: right"><caption>Fig 15. A quick cover trace check</caption><tr><td><a href="/img/fftdemo/subfil-cover.png"><img src="/img/fftdemo/subfil-cover.png" alt="" width="876" /></a></td></tr></table>

<p>Depending on the algorithm, such a trace might simply be generated by running
a counter and looking for some number of steps from the beginning of time.
In the case of one of my <a href="/dsp/freq-teaser.html">polyphase Fourier transform filterbank
implementations</a>,
a counter was exactly what I needed to get the trace.  I counted the number of
<a href="/dsp/2018/10/02/fft.html">Fourier transform</a>
blocks generated by the <a href="/dsp/freq-teaser.html">filterbank</a>.
After seeing two whole blocks, I could examine the core and start making
assertions about it.</p>

<p><a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">This design</a>
ended up using a simpler approach.  In
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this case</a>,
I chose to cover the first output so that I could see the entire operation of
<a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this core</a>.</p>

<p>Well, not quite.  That alone wasn’t quite good enough.  In order to get a trace
generated in a short period of time, and moreover one that would fit on my
screen, I had to carefully trim down the
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsample</a>
ratio and <a href="/dsp/2017/09/15/fastfir.html">filter</a>
length.  As mentioned above, this example trace is for a
<a href="https://en.wikipedia.org/wiki/Downsampling_(signal_processing)">downsample</a>
ratio of 5:1 and a 31-coefficient filter even though the default filter
length and proof is designed for 103 coefficients.</p>

<p>Still, it only takes about <a href="https://github.com/ZipCPU/dspfilters/blob/629474e69c68343ec04e93e4df69f4738c0971c8/rtl/subfildown.v#L623-L624">2 lines of
formal</a>
to get started with a trace that you can then examine to see how well (or
poorly) your algorithm is working.</p>

<h4 id="step-four-start-adding-assertions">Step four: Start adding assertions</h4>

<p>My next step was to work back through the algorithm, looking at every
counter within, in order to capture any obvious logic redundancies across
values together.  While the process is rather ad-hoc, I caught a lot of bugs
out of the gate by doing this–still <a href="/formal/2018/07/14/dev-cycle.html">before
simulation</a>.</p>

<p>So, for example, the countdown counter should never be greater than <code class="language-plaintext highlighter-rouge">NDOWN-1</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">countdown</span> <span class="o">&lt;=</span> <span class="n">NDOWN</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p>Similarly, the <code class="language-plaintext highlighter-rouge">first_sample</code> flag should be equivalent to the counter being
at <code class="language-plaintext highlighter-rouge">NDOWN-1</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">first_sample</span> <span class="o">==</span> <span class="p">(</span><span class="n">countdown</span> <span class="o">==</span> <span class="n">NDOWN</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span></code></pre></figure>

<p>Moving to the filter index stage, every time I read over the logic for
<code class="language-plaintext highlighter-rouge">last_coeff</code> I got confused.  I wanted the <code class="language-plaintext highlighter-rouge">last_coeff</code> flag to be true
on the last coefficient, so a quick assertion checked that for me.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">last_coeff</span> <span class="o">==</span> <span class="p">(</span><span class="n">tidx</span> <span class="o">&gt;=</span> <span class="n">NCOEFFS</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span></code></pre></figure>

<p>Much of the rest of the algorithm is like clock work.  If we just keep track
of the right values from the right cycles, we should be able to capture
everything together.</p>

<p>For example, the data index used within the algorithm is based upon the write
address when the first value of the set is written.  Let’s capture this value,
then, and make assertions about our other values with respect to this one.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">f_start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_ce</span> <span class="o">&amp;&amp;</span> <span class="n">first_sample</span><span class="p">)</span>
		<span class="n">f_start_index</span> <span class="o">&lt;=</span> <span class="n">wraddr</span><span class="p">;</span></code></pre></figure>

<p>For example, we can count how many items have been written to our filter
by comparing this starting index with the current write index.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_written</span> <span class="o">=</span> <span class="n">wraddr</span> <span class="o">-</span> <span class="n">f_start_index</span><span class="p">;</span></code></pre></figure>

<p>For example, we can insist that the <code class="language-plaintext highlighter-rouge">countdown</code> be equivalent to it’s maximum
value minus the number of values that have been written in this set.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_sample</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">countdown</span> <span class="o">==</span> <span class="p">(</span><span class="n">NDOWN</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">f_written</span><span class="p">));</span></code></pre></figure>

<p>Don’t let the <code class="language-plaintext highlighter-rouge">!first_sample</code> criteria fool you: this is really an assertion
for all time.  The <code class="language-plaintext highlighter-rouge">!first_sample</code> criteria was required to get past the
initial conditions which weren’t quite consistent–nothing more.</p>

<p>A similar assertion can be used to guarantee that we never write more than
<code class="language-plaintext highlighter-rouge">NDOWN</code> values per set.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_written</span> <span class="o">&lt;=</span> <span class="n">NDOWN</span><span class="p">);</span></code></pre></figure>

<p>One of my big concerns was that I might overwrite a data value mid run.
Was the assumption above sufficient to guarantee that the run would be
consistent throughout, and only using the data that was there originally?
For this, I added another assertion–only this one based on the coefficient
index.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tidx</span> <span class="o">&lt;</span> <span class="n">NDOWN</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">running</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">f_written</span> <span class="o">&lt;=</span> <span class="n">tidx</span><span class="p">);</span></code></pre></figure>

<p>On the first sample of any set, we should have written either nothing (i.e.
coming from reset), or a full set of <code class="language-plaintext highlighter-rouge">NDOWN</code> samples.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">first_sample</span> <span class="o">==</span><span class="p">((</span><span class="n">f_written</span> <span class="o">==</span> <span class="n">NDOWN</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">f_written</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)));</span></code></pre></figure>

<p>I also wanted to make certain that the data and coefficient indices stayed
aligned.  As you may recall, the data index starts with the first value
written of the set of <code class="language-plaintext highlighter-rouge">NDOWN</code> values, and continues up by one from there whereas
the filter coefficient index starts from zero.</p>

<p>A quick subtraction, subtracting the starting index from the current data index
turns this into a number that should match our filter coefficient index.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="n">f_dindex</span> <span class="o">=</span> <span class="n">didx</span> <span class="o">-</span> <span class="n">f_start_index</span><span class="p">;</span>

 	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">tidx</span> <span class="o">==</span> <span class="n">f_dindex</span><span class="p">);</span></code></pre></figure>

<p>The two steps in this case are important.  The first step, the subtraction,
wasn’t rolled up into the assertion.  That’s because I wanted to guarantee
that it was properly limited to the right number of bits.  Once address
wrapping was taken into account, then the assertion above holds.</p>

<p>While building this core, I had a bit of a problem getting the data index
right.  When I saw it doing some inconsistent things in the trace, I added
an assertion that the data read index should always equal the data write address
whenever the design wasn’t running.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog"> 	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">running</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">didx</span> <span class="o">==</span> <span class="n">wraddr</span><span class="p">);</span></code></pre></figure>

<p>This allowed me to find and fix that bug, and so I keep it around to make sure
I remember how the data read index is supposed to work with relation to the
other parts of the design.</p>

<p>Likewise, the first stages of the pipeline should be <code class="language-plaintext highlighter-rouge">running</code> any time
the coefficient index is non-zero.  Once it returns to zero, we’ll stop
running through our data and then just settle back to waiting for the next
value to come in.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">running</span> <span class="o">==</span> <span class="p">(</span><span class="n">tidx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">));</span></code></pre></figure>

<p>I’d also like to have some confidence that the coefficient index stays between
<code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">NCOEFFS-1</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="n">tidx</span> <span class="o">&lt;</span> <span class="n">NCOEFFS</span><span class="p">);</span></code></pre></figure>

<p>This is, in general, a part of every state machine I verify: I include an
assertion that the state is always within bounds.  The proof, then, also
spares me a lot of defensive logic–such as I would typically write when
building software.</p>

<p>At this point I turned my attention to the various internal <code class="language-plaintext highlighter-rouge">*_ce</code> signals.
These are only supposed to be asserted at particular parts of the processing
flow, so lets guarantee that to be the case.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tidx</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">d_ce</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tidx</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">p_ce</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d_ce</span> <span class="o">||</span> <span class="n">p_ce</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">p_run</span><span class="p">);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tidx</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">o_ce</span><span class="p">);</span></code></pre></figure>

<p>Normally when building something like this, I’d do expression equivalence
checks instead of these one-way assertions.  You know, something like
<code class="language-plaintext highlighter-rouge">assert(x_CE == condition);</code>.  Not so here.  The reason has to do with the
reset signal, and the fact that neither the coefficient index nor the
running flag get reset.  Hence, all I can prove is that the various ce’s will
only happen at there right locations, not that they will always happen at those
locations–since a reset would disprove such an assertion.</p>

<p>As a final assertion, I wanted to make certain that the outgoing result would
only ever get set on <code class="language-plaintext highlighter-rouge">p_ce</code>.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f_past_valid</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">$</span><span class="nb">past</span><span class="p">(</span><span class="n">p_ce</span><span class="p">))</span>
		<span class="k">assert</span><span class="p">($</span><span class="nb">stable</span><span class="p">(</span><span class="n">o_result</span><span class="p">));</span></code></pre></figure>

<p>This will simplify the logic around us, since that logic can then depend upon
our result being constant for many cycles if necessary.</p>

<h2 id="cover-checking">Cover Checking</h2>

<p>In a recent article, I argued that there were <a href="/formal/2020/06/12/four-keys.html">four necessary keys to getting
a design to work on the very first
time</a>: a contract check,
an interface property set,
<a href="/blog/2018/03/10/induction-exercise.html">induction</a>,
and cover checking.  In this design, we’re only going to do two of those:
we have only one interface property, and the problems with the multiply make
it difficult to do a proper contract check.  Still, a cover check is quite
useful, so let’s take a peek at how to do that.</p>

<p>In general, I’d like to just cover an output and see what happens.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">o_ce</span><span class="p">);</span></code></pre></figure>

<p>Often, this is good enough.</p>

<p>The problem with such a cover statement is, what happens when it fails?</p>

<p>I also had the problem in this case where <code class="language-plaintext highlighter-rouge">o_ce</code> might get set early in the
algorithm (before I added <code class="language-plaintext highlighter-rouge">acc_valid</code>), and so the generated trace wasn’t
all that indicative of any real processing.</p>

<p>The solution to both problems is to add additional intermediate cover points.</p>

<p>The logic below follows from our discussion of <a href="/formal/2019/02/21/txuart.html">poor mans
sequences</a>.  It’s designed
around a quick 4-step sequence I call <code class="language-plaintext highlighter-rouge">cvr_seq</code>.  The sequence starts when
the design reaches <code class="language-plaintext highlighter-rouge">last_coeff</code>–the last coefficient indicator from our run
through the coefficients.  It continues if, on the next clock cycle, both
<code class="language-plaintext highlighter-rouge">first_sample</code> and <code class="language-plaintext highlighter-rouge">i_ce</code> are true in order to start a new run through the
coefficients.  The sequence then collects two more clock cycles.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">initial</span>	<span class="n">cvr_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">i_clk</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_reset</span><span class="p">)</span>
		<span class="n">cvr_seq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">begin</span>
		<span class="n">cvr_seq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_coeff</span> <span class="o">&amp;&amp;</span> <span class="n">running</span><span class="p">)</span>
			<span class="n">cvr_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cvr_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">cvr_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">first_sample</span> <span class="o">&amp;&amp;</span> <span class="n">i_ce</span><span class="p">);</span>
		<span class="n">cvr_seq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cvr_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">cvr_seq</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cvr_seq</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">end</span></code></pre></figure>

<p>In general, I’m only really interested in the last cycle of this sequence.
However, covering the prior cycles is useful when trying to determine why
a cover fails.</p>

<figure class="highlight"><pre><code class="language-verilog" data-lang="verilog">	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_seq</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
		<span class="k">cover</span><span class="p">(</span><span class="n">cvr_seq</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span></code></pre></figure>

<h2 id="conclusions">Conclusions</h2>

<p>This downsampling filter has turned out to be very useful across multiple
projects.  As I mentioned above, not only did it play a prominent role in <a href="https://github.com/ZipCPU/fftdemo">my
spectrogram display</a>, but it now also
features prominently in my demonstration
<a href="https://github.com/ZipCPU/sdr/blob/master/rtl/amdemod.v">AM demodulator</a>,
<a href="https://github.com/ZipCPU/sdr/blob/master/rtl/fmdemod.v">FM demodulator</a>, and
my <a href="https://github.com/ZipCPU/sdr/blob/master/rtl/qpskrcvr.v">QPSK demodulator</a>.
As it turns out, it’s quite a useful tool.  I expect I’ll be using it on other
signal processing projects in the future.  I’m also likely to build a
hybrid fast-slow version of this downsampler as well, in order to get access
to more coefficients when running at higher clock speeds.</p>

<p>Further, as you’ve seen above, <a href="https://github.com/ZipCPU/dspfilters/blob/master/rtl/subfildown.v">this
downsampler</a>
follows much of the same form as the <a href="/dsp/2017/12/30/slowfil.html">slow
filter</a> we built before.
Indeed, the form has become so routine, that I tend to write out the processing
blocks in comments now when building new filters of this type–long before
I write down the actual logic.</p>

<p>I should warn readers that the verification of this core isn’t really complete.
Yes, it is working within two of my projects: the 
<a href="https://github.com/ZipCPU/fftdemo">spectrogram FFT demo</a> and a <a href="https://github.com/ZipCPU/sdr">Software
(really gateware) defined radio project</a>.
Yes, I have some confidence in it from using it in both projects.
However, when writing this article I still found a bug remaining within it.</p>

<p>Yes, that’s right: a design that passed a <a href="/formal/2020/06/12/four-keys.html">(partial) formal verification
check</a>
still had a bug in it.  Perhaps that shouldn’t be too surprising–I hadn’t
followed <a href="/formal/2020/06/12/four-keys.html">all four of the steps to verifying a
module</a>.</p>

<p>What was the bug?  Accumulating everything but the product from the last
coefficient.  How serious was it?  Perhaps not that serious–a good filter
will have very small tails.  Still, it helps to illustrate that the formal
proof above isn’t complete.</p>

<p>Don’t I have a <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/subfildown_tb.cpp">bench test</a>
to check for this in
<a href="/blog/2018/08/22/what-is-simulation.html">simulation</a>?
Yes, but <a href="https://github.com/ZipCPU/dspfilters/blob/master/bench/cpp/subfildown_tb.cpp">that bench test</a> isn’t really complete.  That’s really a story for
another day though.</p>

  </div>


<div class "verse">
<HR align="center;" width="25%">
<P><em>And the LORD said unto Gideon, The people are yet too many; bring them down unto the water, and I will try them for thee there: and it shall be, that of whom I say unto thee, This shall go with thee, the same shall go with thee; and of whomsoever I say unto thee, This shall not go with thee, the same shall not go. (Judges 7:4)</em>


</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">The ZipCPU by Gisselquist Technology</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li></li> -->
          <li><a href="mailto:zipcpu@gmail.com">zipcpu@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="soc-medlist">
          
          <li>
            <a href="https://github.com/ZipCPU"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">ZipCPU</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/zipcpu"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">@zipcpu</span></a>

          </li>
          
          
          <li><A href="https://www.patreon.com/ZipCPU"><img src="/img/become_a_patron_button.png"></a></li>
          

        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>The ZipCPU blog, featuring how to discussions of FPGA and soft-core CPU design.  This site will be focused on Verilog solutions, using exclusively OpenSource IP products for FPGA design.  Particular focus areas include topics often left out of more mainstream FPGA design courses such as how to debug an FPGA design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
